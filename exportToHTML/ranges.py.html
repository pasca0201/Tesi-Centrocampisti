<html>
<head>
<title>ranges.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ranges.py</font>
</center></td></tr></table>
<pre><span class="s0"># dialects/postgresql/ranges.py</span>
<span class="s0"># Copyright (C) 2013-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">dataclasses</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">date</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">timedelta</span>
<span class="s2">from </span><span class="s1">decimal </span><span class="s2">import </span><span class="s1">Decimal</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">cast</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Generic</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">List</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">overload</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Sequence</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Tuple</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Type</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TypeVar</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Union</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">operators </span><span class="s2">import </span><span class="s1">ADJACENT_TO</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">operators </span><span class="s2">import </span><span class="s1">CONTAINED_BY</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">operators </span><span class="s2">import </span><span class="s1">CONTAINS</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">operators </span><span class="s2">import </span><span class="s1">NOT_EXTEND_LEFT_OF</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">operators </span><span class="s2">import </span><span class="s1">NOT_EXTEND_RIGHT_OF</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">operators </span><span class="s2">import </span><span class="s1">OVERLAP</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">operators </span><span class="s2">import </span><span class="s1">STRICTLY_LEFT_OF</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">operators </span><span class="s2">import </span><span class="s1">STRICTLY_RIGHT_OF</span>
<span class="s2">from </span><span class="s3">... </span><span class="s2">import </span><span class="s1">types </span><span class="s2">as </span><span class="s1">sqltypes</span>
<span class="s2">from </span><span class="s3">...</span><span class="s1">sql </span><span class="s2">import </span><span class="s1">operators</span>
<span class="s2">from </span><span class="s3">...</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">type_api </span><span class="s2">import </span><span class="s1">TypeEngine</span>
<span class="s2">from </span><span class="s3">...</span><span class="s1">util </span><span class="s2">import </span><span class="s1">py310</span>
<span class="s2">from </span><span class="s3">...</span><span class="s1">util</span><span class="s3">.</span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Literal</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s3">...</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">elements </span><span class="s2">import </span><span class="s1">ColumnElement</span>
    <span class="s2">from </span><span class="s3">...</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">type_api </span><span class="s2">import </span><span class="s1">_TE</span>
    <span class="s2">from </span><span class="s3">...</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">type_api </span><span class="s2">import </span><span class="s1">TypeEngineMixin</span>

<span class="s1">_T </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">&quot;_T&quot;</span><span class="s3">, </span><span class="s1">bound</span><span class="s3">=</span><span class="s1">Any</span><span class="s3">)</span>

<span class="s1">_BoundsType </span><span class="s3">= </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">&quot;()&quot;</span><span class="s3">, </span><span class="s4">&quot;[)&quot;</span><span class="s3">, </span><span class="s4">&quot;(]&quot;</span><span class="s3">, </span><span class="s4">&quot;[]&quot;</span><span class="s3">]</span>

<span class="s2">if </span><span class="s1">py310</span><span class="s3">:</span>
    <span class="s1">dc_slots </span><span class="s3">= {</span><span class="s4">&quot;slots&quot;</span><span class="s3">: </span><span class="s2">True</span><span class="s3">}</span>
    <span class="s1">dc_kwonly </span><span class="s3">= {</span><span class="s4">&quot;kw_only&quot;</span><span class="s3">: </span><span class="s2">True</span><span class="s3">}</span>
<span class="s2">else</span><span class="s3">:</span>
    <span class="s1">dc_slots </span><span class="s3">= {}</span>
    <span class="s1">dc_kwonly </span><span class="s3">= {}</span>


<span class="s3">@</span><span class="s1">dataclasses</span><span class="s3">.</span><span class="s1">dataclass</span><span class="s3">(</span><span class="s1">frozen</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, **</span><span class="s1">dc_slots</span><span class="s3">)</span>
<span class="s2">class </span><span class="s1">Range</span><span class="s3">(</span><span class="s1">Generic</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Represent a PostgreSQL range. 
 
    E.g.:: 
 
        r = Range(10, 50, bounds=&quot;()&quot;) 
 
    The calling style is similar to that of psycopg and psycopg2, in part 
    to allow easier migration from previous SQLAlchemy versions that used 
    these objects directly. 
 
    :param lower: Lower bound value, or None 
    :param upper: Upper bound value, or None 
    :param bounds: keyword-only, optional string value that is one of 
     ``&quot;()&quot;``, ``&quot;[)&quot;``, ``&quot;(]&quot;``, ``&quot;[]&quot;``.  Defaults to ``&quot;[)&quot;``. 
    :param empty: keyword-only, optional bool indicating this is an &quot;empty&quot; 
     range 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">lower</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">] = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;the lower bound&quot;&quot;&quot;</span>

    <span class="s1">upper</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">] = </span><span class="s2">None</span>
    <span class="s4">&quot;&quot;&quot;the upper bound&quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
        <span class="s1">bounds</span><span class="s3">: </span><span class="s1">_BoundsType </span><span class="s3">= </span><span class="s1">dataclasses</span><span class="s3">.</span><span class="s1">field</span><span class="s3">(</span><span class="s1">default</span><span class="s3">=</span><span class="s4">&quot;[)&quot;</span><span class="s3">)</span>
        <span class="s1">empty</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s1">dataclasses</span><span class="s3">.</span><span class="s1">field</span><span class="s3">(</span><span class="s1">default</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">bounds</span><span class="s3">: </span><span class="s1">_BoundsType </span><span class="s3">= </span><span class="s1">dataclasses</span><span class="s3">.</span><span class="s1">field</span><span class="s3">(</span><span class="s1">default</span><span class="s3">=</span><span class="s4">&quot;[)&quot;</span><span class="s3">, **</span><span class="s1">dc_kwonly</span><span class="s3">)</span>
        <span class="s1">empty</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s1">dataclasses</span><span class="s3">.</span><span class="s1">field</span><span class="s3">(</span><span class="s1">default</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, **</span><span class="s1">dc_kwonly</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">py310</span><span class="s3">:</span>

        <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">lower</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
            <span class="s1">upper</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
            <span class="s3">*,</span>
            <span class="s1">bounds</span><span class="s3">: </span><span class="s1">_BoundsType </span><span class="s3">= </span><span class="s4">&quot;[)&quot;</span><span class="s3">,</span>
            <span class="s1">empty</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">):</span>
            <span class="s0"># no __slots__ either so we can update dict</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span>
                <span class="s3">{</span>
                    <span class="s4">&quot;lower&quot;</span><span class="s3">: </span><span class="s1">lower</span><span class="s3">,</span>
                    <span class="s4">&quot;upper&quot;</span><span class="s3">: </span><span class="s1">upper</span><span class="s3">,</span>
                    <span class="s4">&quot;bounds&quot;</span><span class="s3">: </span><span class="s1">bounds</span><span class="s3">,</span>
                    <span class="s4">&quot;empty&quot;</span><span class="s3">: </span><span class="s1">empty</span><span class="s3">,</span>
                <span class="s3">}</span>
            <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__bool__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s2">return not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">isempty</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;A synonym for the 'empty' attribute.&quot;</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">is_empty</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;A synonym for the 'empty' attribute.&quot;</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">lower_inc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Return True if the lower bound is inclusive.&quot;&quot;&quot;</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] == </span><span class="s4">&quot;[&quot;</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">lower_inf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Return True if this range is non-empty and lower bound is 
        infinite.&quot;&quot;&quot;</span>

        <span class="s2">return not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower </span><span class="s2">is None</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">upper_inc</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Return True if the upper bound is inclusive.&quot;&quot;&quot;</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] == </span><span class="s4">&quot;]&quot;</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">upper_inf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Return True if this range is non-empty and the upper bound is 
        infinite.&quot;&quot;&quot;</span>

        <span class="s2">return not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper </span><span class="s2">is None</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">__sa_type_engine__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; AbstractSingleRange</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]:</span>
        <span class="s2">return </span><span class="s1">AbstractSingleRange</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_contains_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">: </span><span class="s1">_T</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Return True if this range contains the given value.&quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s2">return False</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper </span><span class="s2">is None or </span><span class="s3">(</span>
                <span class="s1">value </span><span class="s3">&lt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper</span>
                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] == </span><span class="s4">&quot;)&quot;</span>
                <span class="s2">else </span><span class="s1">value </span><span class="s3">&lt;= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper</span>
            <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">(  </span><span class="s0"># type: ignore</span>
                <span class="s1">value </span><span class="s3">&gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower</span>
                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] == </span><span class="s4">&quot;(&quot;</span>
                <span class="s2">else </span><span class="s1">value </span><span class="s3">&gt;= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower</span>
            <span class="s3">)</span>

        <span class="s2">return </span><span class="s3">(  </span><span class="s0"># type: ignore</span>
            <span class="s1">value </span><span class="s3">&gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] == </span><span class="s4">&quot;(&quot;</span>
            <span class="s2">else </span><span class="s1">value </span><span class="s3">&gt;= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s3">) </span><span class="s2">and </span><span class="s3">(</span>
            <span class="s1">value </span><span class="s3">&lt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] == </span><span class="s4">&quot;)&quot;</span>
            <span class="s2">else </span><span class="s1">value </span><span class="s3">&lt;= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_discrete_step</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s5">&quot;Determine the “step” for this range, if it is a discrete one.&quot;</span>

        <span class="s0"># See</span>
        <span class="s0"># https://www.postgresql.org/docs/current/rangetypes.html#RANGETYPES-DISCRETE</span>
        <span class="s0"># for the rationale</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">, </span><span class="s1">int</span><span class="s3">) </span><span class="s2">or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s6">1</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">, </span><span class="s1">datetime</span><span class="s3">) </span><span class="s2">or </span><span class="s1">isinstance</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">upper</span><span class="s3">, </span><span class="s1">datetime</span>
        <span class="s3">):</span>
            <span class="s0"># This is required, because a `isinstance(datetime.now(), date)`</span>
            <span class="s0"># is True</span>
            <span class="s2">return None</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">, </span><span class="s1">date</span><span class="s3">) </span><span class="s2">or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper</span><span class="s3">, </span><span class="s1">date</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">timedelta</span><span class="s3">(</span><span class="s1">days</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_compare_edges</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">value1</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">],</span>
        <span class="s1">bound1</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">value2</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">],</span>
        <span class="s1">bound2</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">only_values</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; int</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Compare two range bounds. 
 
        Return -1, 0 or 1 respectively when `value1` is less than, 
        equal to or greater than `value2`. 
 
        When `only_value` is ``True``, do not consider the *inclusivity* 
        of the edges, just their values. 
        &quot;&quot;&quot;</span>

        <span class="s1">value1_is_lower_bound </span><span class="s3">= </span><span class="s1">bound1 </span><span class="s2">in </span><span class="s3">{</span><span class="s4">&quot;[&quot;</span><span class="s3">, </span><span class="s4">&quot;(&quot;</span><span class="s3">}</span>
        <span class="s1">value2_is_lower_bound </span><span class="s3">= </span><span class="s1">bound2 </span><span class="s2">in </span><span class="s3">{</span><span class="s4">&quot;[&quot;</span><span class="s3">, </span><span class="s4">&quot;(&quot;</span><span class="s3">}</span>

        <span class="s0"># Infinite edges are equal when they are on the same side,</span>
        <span class="s0"># otherwise a lower edge is considered less than the upper end</span>
        <span class="s2">if </span><span class="s1">value1 </span><span class="s2">is </span><span class="s1">value2 </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">value1_is_lower_bound </span><span class="s3">== </span><span class="s1">value2_is_lower_bound</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s6">0</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s3">-</span><span class="s6">1 </span><span class="s2">if </span><span class="s1">value1_is_lower_bound </span><span class="s2">else </span><span class="s6">1</span>
        <span class="s2">elif </span><span class="s1">value1 </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">-</span><span class="s6">1 </span><span class="s2">if </span><span class="s1">value1_is_lower_bound </span><span class="s2">else </span><span class="s6">1</span>
        <span class="s2">elif </span><span class="s1">value2 </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s6">1 </span><span class="s2">if </span><span class="s1">value2_is_lower_bound </span><span class="s2">else </span><span class="s3">-</span><span class="s6">1</span>

        <span class="s0"># Short path for trivial case</span>
        <span class="s2">if </span><span class="s1">bound1 </span><span class="s3">== </span><span class="s1">bound2 </span><span class="s2">and </span><span class="s1">value1 </span><span class="s3">== </span><span class="s1">value2</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s6">0</span>

        <span class="s1">value1_inc </span><span class="s3">= </span><span class="s1">bound1 </span><span class="s2">in </span><span class="s3">{</span><span class="s4">&quot;[&quot;</span><span class="s3">, </span><span class="s4">&quot;]&quot;</span><span class="s3">}</span>
        <span class="s1">value2_inc </span><span class="s3">= </span><span class="s1">bound2 </span><span class="s2">in </span><span class="s3">{</span><span class="s4">&quot;[&quot;</span><span class="s3">, </span><span class="s4">&quot;]&quot;</span><span class="s3">}</span>
        <span class="s1">step </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_discrete_step</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">step </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s0"># &quot;Normalize&quot; the two edges as '[)', to simplify successive</span>
            <span class="s0"># logic when the range is discrete: otherwise we would need</span>
            <span class="s0"># to handle the comparison between ``(0`` and ``[1`` that</span>
            <span class="s0"># are equal when dealing with integers while for floats the</span>
            <span class="s0"># former is lesser than the latter</span>

            <span class="s2">if </span><span class="s1">value1_is_lower_bound</span><span class="s3">:</span>
                <span class="s2">if not </span><span class="s1">value1_inc</span><span class="s3">:</span>
                    <span class="s1">value1 </span><span class="s3">+= </span><span class="s1">step</span>
                    <span class="s1">value1_inc </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">value1_inc</span><span class="s3">:</span>
                    <span class="s1">value1 </span><span class="s3">+= </span><span class="s1">step</span>
                    <span class="s1">value1_inc </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s2">if </span><span class="s1">value2_is_lower_bound</span><span class="s3">:</span>
                <span class="s2">if not </span><span class="s1">value2_inc</span><span class="s3">:</span>
                    <span class="s1">value2 </span><span class="s3">+= </span><span class="s1">step</span>
                    <span class="s1">value2_inc </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">value2_inc</span><span class="s3">:</span>
                    <span class="s1">value2 </span><span class="s3">+= </span><span class="s1">step</span>
                    <span class="s1">value2_inc </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">value1 </span><span class="s3">&lt; </span><span class="s1">value2</span><span class="s3">:  </span><span class="s0"># type: ignore</span>
            <span class="s2">return </span><span class="s3">-</span><span class="s6">1</span>
        <span class="s2">elif </span><span class="s1">value1 </span><span class="s3">&gt; </span><span class="s1">value2</span><span class="s3">:  </span><span class="s0"># type: ignore</span>
            <span class="s2">return </span><span class="s6">1</span>
        <span class="s2">elif </span><span class="s1">only_values</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s6">0</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># Neither one is infinite but are equal, so we</span>
            <span class="s0"># need to consider the respective inclusive/exclusive</span>
            <span class="s0"># flag</span>

            <span class="s2">if </span><span class="s1">value1_inc </span><span class="s2">and </span><span class="s1">value2_inc</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s6">0</span>
            <span class="s2">elif not </span><span class="s1">value1_inc </span><span class="s2">and not </span><span class="s1">value2_inc</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">value1_is_lower_bound </span><span class="s3">== </span><span class="s1">value2_is_lower_bound</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s6">0</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s6">1 </span><span class="s2">if </span><span class="s1">value1_is_lower_bound </span><span class="s2">else </span><span class="s3">-</span><span class="s6">1</span>
            <span class="s2">elif not </span><span class="s1">value1_inc</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s6">1 </span><span class="s2">if </span><span class="s1">value1_is_lower_bound </span><span class="s2">else </span><span class="s3">-</span><span class="s6">1</span>
            <span class="s2">elif not </span><span class="s1">value2_inc</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s3">-</span><span class="s6">1 </span><span class="s2">if </span><span class="s1">value2_is_lower_bound </span><span class="s2">else </span><span class="s6">1</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s6">0</span>

    <span class="s2">def </span><span class="s1">__eq__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Compare this range to the `other` taking into account 
        bounds inclusivity, returning ``True`` if they are equal. 
        &quot;&quot;&quot;</span>

        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">Range</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty </span><span class="s2">and </span><span class="s1">other</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s2">return True</span>
        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty </span><span class="s3">!= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s2">return False</span>

        <span class="s1">slower </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">slower_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">olower </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">olower_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">supper </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">supper_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">oupper </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">oupper_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

        <span class="s2">return </span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">slower</span><span class="s3">, </span><span class="s1">slower_b</span><span class="s3">, </span><span class="s1">olower</span><span class="s3">, </span><span class="s1">olower_b</span><span class="s3">) == </span><span class="s6">0</span>
            <span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">supper</span><span class="s3">, </span><span class="s1">supper_b</span><span class="s3">, </span><span class="s1">oupper</span><span class="s3">, </span><span class="s1">oupper_b</span><span class="s3">) == </span><span class="s6">0</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">contained_by</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;Determine whether this range is a contained by `other`.&quot;</span>

        <span class="s0"># Any range contains the empty one</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s2">return True</span>

        <span class="s0"># An empty range does not contain any range except the empty one</span>
        <span class="s2">if </span><span class="s1">other</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s2">return False</span>

        <span class="s1">slower </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">slower_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">olower </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">olower_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">slower</span><span class="s3">, </span><span class="s1">slower_b</span><span class="s3">, </span><span class="s1">olower</span><span class="s3">, </span><span class="s1">olower_b</span><span class="s3">) &lt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">return False</span>

        <span class="s1">supper </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">supper_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">oupper </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">oupper_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">supper</span><span class="s3">, </span><span class="s1">supper_b</span><span class="s3">, </span><span class="s1">oupper</span><span class="s3">, </span><span class="s1">oupper_b</span><span class="s3">) &gt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">return False</span>

        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">contains</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">, </span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]]) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;Determine whether this range contains `value`.&quot;</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">Range</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">value</span><span class="s3">.</span><span class="s1">contained_by</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_contains_value</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">overlaps</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;Determine whether this range overlaps with `other`.&quot;</span>

        <span class="s0"># Empty ranges never overlap with any other range</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty </span><span class="s2">or </span><span class="s1">other</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s2">return False</span>

        <span class="s1">slower </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">slower_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">supper </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">supper_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">olower </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">olower_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">oupper </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">oupper_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

        <span class="s0"># Check whether this lower bound is contained in the other range</span>
        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">slower</span><span class="s3">, </span><span class="s1">slower_b</span><span class="s3">, </span><span class="s1">olower</span><span class="s3">, </span><span class="s1">olower_b</span><span class="s3">) &gt;= </span><span class="s6">0</span>
            <span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">slower</span><span class="s3">, </span><span class="s1">slower_b</span><span class="s3">, </span><span class="s1">oupper</span><span class="s3">, </span><span class="s1">oupper_b</span><span class="s3">) &lt;= </span><span class="s6">0</span>
        <span class="s3">):</span>
            <span class="s2">return True</span>

        <span class="s0"># Check whether other lower bound is contained in this range</span>
        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">olower</span><span class="s3">, </span><span class="s1">olower_b</span><span class="s3">, </span><span class="s1">slower</span><span class="s3">, </span><span class="s1">slower_b</span><span class="s3">) &gt;= </span><span class="s6">0</span>
            <span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">olower</span><span class="s3">, </span><span class="s1">olower_b</span><span class="s3">, </span><span class="s1">supper</span><span class="s3">, </span><span class="s1">supper_b</span><span class="s3">) &lt;= </span><span class="s6">0</span>
        <span class="s3">):</span>
            <span class="s2">return True</span>

        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">strictly_left_of</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;Determine whether this range is completely to the left of `other`.&quot;</span>

        <span class="s0"># Empty ranges are neither to left nor to the right of any other range</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty </span><span class="s2">or </span><span class="s1">other</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s2">return False</span>

        <span class="s1">supper </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">supper_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">olower </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">olower_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>

        <span class="s0"># Check whether this upper edge is less than other's lower end</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">supper</span><span class="s3">, </span><span class="s1">supper_b</span><span class="s3">, </span><span class="s1">olower</span><span class="s3">, </span><span class="s1">olower_b</span><span class="s3">) &lt; </span><span class="s6">0</span>

    <span class="s1">__lshift__ </span><span class="s3">= </span><span class="s1">strictly_left_of</span>

    <span class="s2">def </span><span class="s1">strictly_right_of</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;Determine whether this range is completely to the right of `other`.&quot;</span>

        <span class="s0"># Empty ranges are neither to left nor to the right of any other range</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty </span><span class="s2">or </span><span class="s1">other</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s2">return False</span>

        <span class="s1">slower </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">slower_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">oupper </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">oupper_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

        <span class="s0"># Check whether this lower edge is greater than other's upper end</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">slower</span><span class="s3">, </span><span class="s1">slower_b</span><span class="s3">, </span><span class="s1">oupper</span><span class="s3">, </span><span class="s1">oupper_b</span><span class="s3">) &gt; </span><span class="s6">0</span>

    <span class="s1">__rshift__ </span><span class="s3">= </span><span class="s1">strictly_right_of</span>

    <span class="s2">def </span><span class="s1">not_extend_left_of</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;Determine whether this does not extend to the left of `other`.&quot;</span>

        <span class="s0"># Empty ranges are neither to left nor to the right of any other range</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty </span><span class="s2">or </span><span class="s1">other</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s2">return False</span>

        <span class="s1">slower </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">slower_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">olower </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">olower_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>

        <span class="s0"># Check whether this lower edge is not less than other's lower end</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">slower</span><span class="s3">, </span><span class="s1">slower_b</span><span class="s3">, </span><span class="s1">olower</span><span class="s3">, </span><span class="s1">olower_b</span><span class="s3">) &gt;= </span><span class="s6">0</span>

    <span class="s2">def </span><span class="s1">not_extend_right_of</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;Determine whether this does not extend to the right of `other`.&quot;</span>

        <span class="s0"># Empty ranges are neither to left nor to the right of any other range</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty </span><span class="s2">or </span><span class="s1">other</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s2">return False</span>

        <span class="s1">supper </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">supper_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">oupper </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">oupper_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

        <span class="s0"># Check whether this upper edge is not greater than other's upper end</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">supper</span><span class="s3">, </span><span class="s1">supper_b</span><span class="s3">, </span><span class="s1">oupper</span><span class="s3">, </span><span class="s1">oupper_b</span><span class="s3">) &lt;= </span><span class="s6">0</span>

    <span class="s2">def </span><span class="s1">_upper_edge_adjacent_to_lower</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">value1</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">],</span>
        <span class="s1">bound1</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
        <span class="s1">value2</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">],</span>
        <span class="s1">bound2</span><span class="s3">: </span><span class="s1">str</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Determine whether an upper bound is immediately successive to a 
        lower bound.&quot;&quot;&quot;</span>

        <span class="s0"># Since we need a peculiar way to handle the bounds inclusivity,</span>
        <span class="s0"># just do a comparison by value here</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">value1</span><span class="s3">, </span><span class="s1">bound1</span><span class="s3">, </span><span class="s1">value2</span><span class="s3">, </span><span class="s1">bound2</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">res </span><span class="s3">== -</span><span class="s6">1</span><span class="s3">:</span>
            <span class="s1">step </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_discrete_step</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">step </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">return False</span>
            <span class="s2">if </span><span class="s1">bound1 </span><span class="s3">== </span><span class="s4">&quot;]&quot;</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">bound2 </span><span class="s3">== </span><span class="s4">&quot;[&quot;</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">value1 </span><span class="s3">== </span><span class="s1">value2 </span><span class="s3">- </span><span class="s1">step  </span><span class="s0"># type: ignore</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">value1 </span><span class="s3">== </span><span class="s1">value2</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">bound2 </span><span class="s3">== </span><span class="s4">&quot;[&quot;</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">value1 </span><span class="s3">== </span><span class="s1">value2</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">return </span><span class="s1">value1 </span><span class="s3">== </span><span class="s1">value2 </span><span class="s3">- </span><span class="s1">step  </span><span class="s0"># type: ignore</span>
        <span class="s2">elif </span><span class="s1">res </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s0"># Cover cases like [0,0] -|- [1,] and [0,2) -|- (1,3]</span>
            <span class="s2">if </span><span class="s3">(</span>
                <span class="s1">bound1 </span><span class="s3">== </span><span class="s4">&quot;]&quot;</span>
                <span class="s2">and </span><span class="s1">bound2 </span><span class="s3">== </span><span class="s4">&quot;[&quot;</span>
                <span class="s2">or </span><span class="s1">bound1 </span><span class="s3">== </span><span class="s4">&quot;)&quot;</span>
                <span class="s2">and </span><span class="s1">bound2 </span><span class="s3">== </span><span class="s4">&quot;(&quot;</span>
            <span class="s3">):</span>
                <span class="s1">step </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_discrete_step</span><span class="s3">()</span>
                <span class="s2">if </span><span class="s1">step </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s2">return True</span>
            <span class="s2">return </span><span class="s3">(</span>
                <span class="s1">bound1 </span><span class="s3">== </span><span class="s4">&quot;)&quot;</span>
                <span class="s2">and </span><span class="s1">bound2 </span><span class="s3">== </span><span class="s4">&quot;[&quot;</span>
                <span class="s2">or </span><span class="s1">bound1 </span><span class="s3">== </span><span class="s4">&quot;]&quot;</span>
                <span class="s2">and </span><span class="s1">bound2 </span><span class="s3">== </span><span class="s4">&quot;(&quot;</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">adjacent_to</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s5">&quot;Determine whether this range is adjacent to the `other`.&quot;</span>

        <span class="s0"># Empty ranges are not adjacent to any other range</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty </span><span class="s2">or </span><span class="s1">other</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s2">return False</span>

        <span class="s1">slower </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">slower_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">supper </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">supper_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">olower </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">olower_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">oupper </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">oupper_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_upper_edge_adjacent_to_lower</span><span class="s3">(</span>
            <span class="s1">supper</span><span class="s3">, </span><span class="s1">supper_b</span><span class="s3">, </span><span class="s1">olower</span><span class="s3">, </span><span class="s1">olower_b</span>
        <span class="s3">) </span><span class="s2">or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_upper_edge_adjacent_to_lower</span><span class="s3">(</span>
            <span class="s1">oupper</span><span class="s3">, </span><span class="s1">oupper_b</span><span class="s3">, </span><span class="s1">slower</span><span class="s3">, </span><span class="s1">slower_b</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">union</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]) </span><span class="s1">-&gt; Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]:</span>
        <span class="s5">&quot;&quot;&quot;Compute the union of this range with the `other`. 
 
        This raises a ``ValueError`` exception if the two ranges are 
        &quot;disjunct&quot;, that is neither adjacent nor overlapping. 
        &quot;&quot;&quot;</span>

        <span class="s0"># Empty ranges are &quot;additive identities&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">other</span>
        <span class="s2">if </span><span class="s1">other</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span>

        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">overlaps</span><span class="s3">(</span><span class="s1">other</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">adjacent_to</span><span class="s3">(</span><span class="s1">other</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;Adding non-overlapping and non-adjacent&quot;</span>
                <span class="s4">&quot; ranges is not implemented&quot;</span>
            <span class="s3">)</span>

        <span class="s1">slower </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">slower_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">supper </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">supper_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">olower </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">olower_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">oupper </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">oupper_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">slower</span><span class="s3">, </span><span class="s1">slower_b</span><span class="s3">, </span><span class="s1">olower</span><span class="s3">, </span><span class="s1">olower_b</span><span class="s3">) &lt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">rlower </span><span class="s3">= </span><span class="s1">slower</span>
            <span class="s1">rlower_b </span><span class="s3">= </span><span class="s1">slower_b</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">rlower </span><span class="s3">= </span><span class="s1">olower</span>
            <span class="s1">rlower_b </span><span class="s3">= </span><span class="s1">olower_b</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">supper</span><span class="s3">, </span><span class="s1">supper_b</span><span class="s3">, </span><span class="s1">oupper</span><span class="s3">, </span><span class="s1">oupper_b</span><span class="s3">) &gt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">rupper </span><span class="s3">= </span><span class="s1">supper</span>
            <span class="s1">rupper_b </span><span class="s3">= </span><span class="s1">supper_b</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">rupper </span><span class="s3">= </span><span class="s1">oupper</span>
            <span class="s1">rupper_b </span><span class="s3">= </span><span class="s1">oupper_b</span>

        <span class="s2">return </span><span class="s1">Range</span><span class="s3">(</span>
            <span class="s1">rlower</span><span class="s3">, </span><span class="s1">rupper</span><span class="s3">, </span><span class="s1">bounds</span><span class="s3">=</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">_BoundsType</span><span class="s3">, </span><span class="s1">rlower_b </span><span class="s3">+ </span><span class="s1">rupper_b</span><span class="s3">)</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__add__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]) </span><span class="s1">-&gt; Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">union</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">difference</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]) </span><span class="s1">-&gt; Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]:</span>
        <span class="s5">&quot;&quot;&quot;Compute the difference between this range and the `other`. 
 
        This raises a ``ValueError`` exception if the two ranges are 
        &quot;disjunct&quot;, that is neither adjacent nor overlapping. 
        &quot;&quot;&quot;</span>

        <span class="s0"># Subtracting an empty range is a no-op</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty </span><span class="s2">or </span><span class="s1">other</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span>

        <span class="s1">slower </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">slower_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">supper </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">supper_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">olower </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">olower_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">oupper </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">oupper_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

        <span class="s1">sl_vs_ol </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">slower</span><span class="s3">, </span><span class="s1">slower_b</span><span class="s3">, </span><span class="s1">olower</span><span class="s3">, </span><span class="s1">olower_b</span><span class="s3">)</span>
        <span class="s1">su_vs_ou </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">supper</span><span class="s3">, </span><span class="s1">supper_b</span><span class="s3">, </span><span class="s1">oupper</span><span class="s3">, </span><span class="s1">oupper_b</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">sl_vs_ol </span><span class="s3">&lt; </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">su_vs_ou </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">&quot;Subtracting a strictly inner range is not implemented&quot;</span>
            <span class="s3">)</span>

        <span class="s1">sl_vs_ou </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">slower</span><span class="s3">, </span><span class="s1">slower_b</span><span class="s3">, </span><span class="s1">oupper</span><span class="s3">, </span><span class="s1">oupper_b</span><span class="s3">)</span>
        <span class="s1">su_vs_ol </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">supper</span><span class="s3">, </span><span class="s1">supper_b</span><span class="s3">, </span><span class="s1">olower</span><span class="s3">, </span><span class="s1">olower_b</span><span class="s3">)</span>

        <span class="s0"># If the ranges do not overlap, result is simply the first</span>
        <span class="s2">if </span><span class="s1">sl_vs_ou </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">or </span><span class="s1">su_vs_ol </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span>

        <span class="s0"># If this range is completely contained by the other, result is empty</span>
        <span class="s2">if </span><span class="s1">sl_vs_ol </span><span class="s3">&gt;= </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">su_vs_ou </span><span class="s3">&lt;= </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">Range</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">empty</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s0"># If this range extends to the left of the other and ends in its</span>
        <span class="s0"># middle</span>
        <span class="s2">if </span><span class="s1">sl_vs_ol </span><span class="s3">&lt;= </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">su_vs_ol </span><span class="s3">&gt;= </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">su_vs_ou </span><span class="s3">&lt;= </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">rupper_b </span><span class="s3">= </span><span class="s4">&quot;)&quot; </span><span class="s2">if </span><span class="s1">olower_b </span><span class="s3">== </span><span class="s4">&quot;[&quot; </span><span class="s2">else </span><span class="s4">&quot;]&quot;</span>
            <span class="s2">if </span><span class="s3">(</span>
                <span class="s1">slower_b </span><span class="s3">!= </span><span class="s4">&quot;[&quot;</span>
                <span class="s2">and </span><span class="s1">rupper_b </span><span class="s3">!= </span><span class="s4">&quot;]&quot;</span>
                <span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">slower</span><span class="s3">, </span><span class="s1">slower_b</span><span class="s3">, </span><span class="s1">olower</span><span class="s3">, </span><span class="s1">rupper_b</span><span class="s3">)</span>
                <span class="s3">== </span><span class="s6">0</span>
            <span class="s3">):</span>
                <span class="s2">return </span><span class="s1">Range</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">empty</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">Range</span><span class="s3">(</span>
                    <span class="s1">slower</span><span class="s3">,</span>
                    <span class="s1">olower</span><span class="s3">,</span>
                    <span class="s1">bounds</span><span class="s3">=</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">_BoundsType</span><span class="s3">, </span><span class="s1">slower_b </span><span class="s3">+ </span><span class="s1">rupper_b</span><span class="s3">),</span>
                <span class="s3">)</span>

        <span class="s0"># If this range starts in the middle of the other and extends to its</span>
        <span class="s0"># right</span>
        <span class="s2">if </span><span class="s1">sl_vs_ol </span><span class="s3">&gt;= </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">su_vs_ou </span><span class="s3">&gt;= </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">sl_vs_ou </span><span class="s3">&lt;= </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">rlower_b </span><span class="s3">= </span><span class="s4">&quot;(&quot; </span><span class="s2">if </span><span class="s1">oupper_b </span><span class="s3">== </span><span class="s4">&quot;]&quot; </span><span class="s2">else </span><span class="s4">&quot;[&quot;</span>
            <span class="s2">if </span><span class="s3">(</span>
                <span class="s1">rlower_b </span><span class="s3">!= </span><span class="s4">&quot;[&quot;</span>
                <span class="s2">and </span><span class="s1">supper_b </span><span class="s3">!= </span><span class="s4">&quot;]&quot;</span>
                <span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">oupper</span><span class="s3">, </span><span class="s1">rlower_b</span><span class="s3">, </span><span class="s1">supper</span><span class="s3">, </span><span class="s1">supper_b</span><span class="s3">)</span>
                <span class="s3">== </span><span class="s6">0</span>
            <span class="s3">):</span>
                <span class="s2">return </span><span class="s1">Range</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">empty</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">Range</span><span class="s3">(</span>
                    <span class="s1">oupper</span><span class="s3">,</span>
                    <span class="s1">supper</span><span class="s3">,</span>
                    <span class="s1">bounds</span><span class="s3">=</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">_BoundsType</span><span class="s3">, </span><span class="s1">rlower_b </span><span class="s3">+ </span><span class="s1">supper_b</span><span class="s3">),</span>
                <span class="s3">)</span>

        <span class="s2">assert False</span><span class="s3">, </span><span class="s4">f&quot;Unhandled case computing </span><span class="s2">{</span><span class="s1">self</span><span class="s2">} </span><span class="s4">- </span><span class="s2">{</span><span class="s1">other</span><span class="s2">}</span><span class="s4">&quot;</span>

    <span class="s2">def </span><span class="s1">__sub__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]) </span><span class="s1">-&gt; Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">difference</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">intersection</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]) </span><span class="s1">-&gt; Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]:</span>
        <span class="s5">&quot;&quot;&quot;Compute the intersection of this range with the `other`. 
 
        .. versionadded:: 2.0.10 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty </span><span class="s2">or </span><span class="s1">other</span><span class="s3">.</span><span class="s1">empty </span><span class="s2">or not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">overlaps</span><span class="s3">(</span><span class="s1">other</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">Range</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">empty</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s1">slower </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">slower_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">supper </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">supper_b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">olower </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">lower</span>
        <span class="s1">olower_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">oupper </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">oupper_b </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">slower</span><span class="s3">, </span><span class="s1">slower_b</span><span class="s3">, </span><span class="s1">olower</span><span class="s3">, </span><span class="s1">olower_b</span><span class="s3">) &lt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">rlower </span><span class="s3">= </span><span class="s1">olower</span>
            <span class="s1">rlower_b </span><span class="s3">= </span><span class="s1">olower_b</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">rlower </span><span class="s3">= </span><span class="s1">slower</span>
            <span class="s1">rlower_b </span><span class="s3">= </span><span class="s1">slower_b</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_compare_edges</span><span class="s3">(</span><span class="s1">supper</span><span class="s3">, </span><span class="s1">supper_b</span><span class="s3">, </span><span class="s1">oupper</span><span class="s3">, </span><span class="s1">oupper_b</span><span class="s3">) &gt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">rupper </span><span class="s3">= </span><span class="s1">oupper</span>
            <span class="s1">rupper_b </span><span class="s3">= </span><span class="s1">oupper_b</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">rupper </span><span class="s3">= </span><span class="s1">supper</span>
            <span class="s1">rupper_b </span><span class="s3">= </span><span class="s1">supper_b</span>

        <span class="s2">return </span><span class="s1">Range</span><span class="s3">(</span>
            <span class="s1">rlower</span><span class="s3">,</span>
            <span class="s1">rupper</span><span class="s3">,</span>
            <span class="s1">bounds</span><span class="s3">=</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">_BoundsType</span><span class="s3">, </span><span class="s1">rlower_b </span><span class="s3">+ </span><span class="s1">rupper_b</span><span class="s3">),</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__mul__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]) </span><span class="s1">-&gt; Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">intersection</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__str__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_stringify</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">_stringify</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; str</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s4">&quot;empty&quot;</span>

        <span class="s1">l</span><span class="s3">, </span><span class="s1">r </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">upper</span>
        <span class="s1">l </span><span class="s3">= </span><span class="s4">&quot;&quot; </span><span class="s2">if </span><span class="s1">l </span><span class="s2">is None else </span><span class="s1">l  </span><span class="s0"># type: ignore</span>
        <span class="s1">r </span><span class="s3">= </span><span class="s4">&quot;&quot; </span><span class="s2">if </span><span class="s1">r </span><span class="s2">is None else </span><span class="s1">r  </span><span class="s0"># type: ignore</span>

        <span class="s1">b0</span><span class="s3">, </span><span class="s1">b1 </span><span class="s3">= </span><span class="s1">cast</span><span class="s3">(</span><span class="s4">&quot;Tuple[str, str]&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">bounds</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">b0</span><span class="s2">}{</span><span class="s1">l</span><span class="s2">}</span><span class="s4">,</span><span class="s2">{</span><span class="s1">r</span><span class="s2">}{</span><span class="s1">b1</span><span class="s2">}</span><span class="s4">&quot;</span>


<span class="s2">class </span><span class="s1">MultiRange</span><span class="s3">(</span><span class="s1">List</span><span class="s3">[</span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]]):</span>
    <span class="s5">&quot;&quot;&quot;Represents a multirange sequence. 
 
    This list subclass is an utility to allow automatic type inference of 
    the proper multi-range SQL type depending on the single range values. 
    This is useful when operating on literal multi-ranges:: 
 
        import sqlalchemy as sa 
        from sqlalchemy.dialects.postgresql import MultiRange, Range 
 
        value = literal(MultiRange([Range(2, 4)])) 
 
        select(tbl).where(tbl.c.value.op(&quot;@&quot;)(MultiRange([Range(-3, 7)]))) 
 
    .. versionadded:: 2.0.26 
 
    .. seealso:: 
 
        - :ref:`postgresql_multirange_list_use`. 
    &quot;&quot;&quot;</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">__sa_type_engine__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; AbstractMultiRange</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]:</span>
        <span class="s2">return </span><span class="s1">AbstractMultiRange</span><span class="s3">()</span>


<span class="s2">class </span><span class="s1">AbstractRange</span><span class="s3">(</span><span class="s1">sqltypes</span><span class="s3">.</span><span class="s1">TypeEngine</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Base class for single and multi Range SQL types.&quot;&quot;&quot;</span>

    <span class="s1">render_bind_cast </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s1">__abstract__ </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">adapt</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">: </span><span class="s1">Type</span><span class="s3">[</span><span class="s1">_TE</span><span class="s3">], **</span><span class="s1">kw</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; _TE</span><span class="s3">: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">adapt</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">: </span><span class="s1">Type</span><span class="s3">[</span><span class="s1">TypeEngineMixin</span><span class="s3">], **</span><span class="s1">kw</span><span class="s3">: </span><span class="s1">Any</span>
    <span class="s3">) </span><span class="s1">-&gt; TypeEngine</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]: ...</span>

    <span class="s2">def </span><span class="s1">adapt</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">cls</span><span class="s3">: </span><span class="s1">Type</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">TypeEngine</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">], </span><span class="s1">TypeEngineMixin</span><span class="s3">]],</span>
        <span class="s3">**</span><span class="s1">kw</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; TypeEngine</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]:</span>
        <span class="s5">&quot;&quot;&quot;Dynamically adapt a range type to an abstract impl. 
 
        For example ``INT4RANGE().adapt(_Psycopg2NumericRange)`` should 
        produce a type that will have ``_Psycopg2NumericRange`` behaviors 
        and also render as ``INT4RANGE`` in SQL and DDL. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s3">(</span>
            <span class="s1">issubclass</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, (</span><span class="s1">AbstractSingleRangeImpl</span><span class="s3">, </span><span class="s1">AbstractMultiRangeImpl</span><span class="s3">))</span>
            <span class="s2">and </span><span class="s1">cls </span><span class="s2">is not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__class__</span>
        <span class="s3">):</span>
            <span class="s0"># two ways to do this are:  1. create a new type on the fly</span>
            <span class="s0"># or 2. have AbstractRangeImpl(visit_name) constructor and a</span>
            <span class="s0"># visit_abstract_range_impl() method in the PG compiler.</span>
            <span class="s0"># I'm choosing #1 as the resulting type object</span>
            <span class="s0"># will then make use of the same mechanics</span>
            <span class="s0"># as if we had made all these sub-types explicitly, and will</span>
            <span class="s0"># also look more obvious under pdb etc.</span>
            <span class="s0"># The adapt() operation here is cached per type-class-per-dialect,</span>
            <span class="s0"># so is not much of a performance concern</span>
            <span class="s1">visit_name </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__visit_name__</span>
            <span class="s2">return </span><span class="s1">type</span><span class="s3">(  </span><span class="s0"># type: ignore</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">visit_name</span><span class="s2">}</span><span class="s4">RangeImpl&quot;</span><span class="s3">,</span>
                <span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">),</span>
                <span class="s3">{</span><span class="s4">&quot;__visit_name__&quot;</span><span class="s3">: </span><span class="s1">visit_name</span><span class="s3">},</span>
            <span class="s3">)()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">adapt</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">)</span>

    <span class="s2">class </span><span class="s1">comparator_factory</span><span class="s3">(</span><span class="s1">TypeEngine</span><span class="s3">.</span><span class="s1">Comparator</span><span class="s3">[</span><span class="s1">Range</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]]):</span>
        <span class="s5">&quot;&quot;&quot;Define comparison operations for range types.&quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">contains</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, **</span><span class="s1">kw</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; ColumnElement</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">]:</span>
            <span class="s5">&quot;&quot;&quot;Boolean expression. Returns true if the right hand operand, 
            which can be an element or a range, is contained within the 
            column. 
 
            kwargs may be ignored by this operator but are required for API 
            conformance. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">operate</span><span class="s3">(</span><span class="s1">CONTAINS</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">contained_by</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; ColumnElement</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">]:</span>
            <span class="s5">&quot;&quot;&quot;Boolean expression. Returns true if the column is contained 
            within the right hand operand. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">operate</span><span class="s3">(</span><span class="s1">CONTAINED_BY</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">overlaps</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; ColumnElement</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">]:</span>
            <span class="s5">&quot;&quot;&quot;Boolean expression. Returns true if the column overlaps 
            (has points in common with) the right hand operand. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">operate</span><span class="s3">(</span><span class="s1">OVERLAP</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">strictly_left_of</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; ColumnElement</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">]:</span>
            <span class="s5">&quot;&quot;&quot;Boolean expression. Returns true if the column is strictly 
            left of the right hand operand. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">operate</span><span class="s3">(</span><span class="s1">STRICTLY_LEFT_OF</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

        <span class="s1">__lshift__ </span><span class="s3">= </span><span class="s1">strictly_left_of</span>

        <span class="s2">def </span><span class="s1">strictly_right_of</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; ColumnElement</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">]:</span>
            <span class="s5">&quot;&quot;&quot;Boolean expression. Returns true if the column is strictly 
            right of the right hand operand. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">operate</span><span class="s3">(</span><span class="s1">STRICTLY_RIGHT_OF</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

        <span class="s1">__rshift__ </span><span class="s3">= </span><span class="s1">strictly_right_of</span>

        <span class="s2">def </span><span class="s1">not_extend_right_of</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; ColumnElement</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">]:</span>
            <span class="s5">&quot;&quot;&quot;Boolean expression. Returns true if the range in the column 
            does not extend right of the range in the operand. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">operate</span><span class="s3">(</span><span class="s1">NOT_EXTEND_RIGHT_OF</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">not_extend_left_of</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; ColumnElement</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">]:</span>
            <span class="s5">&quot;&quot;&quot;Boolean expression. Returns true if the range in the column 
            does not extend left of the range in the operand. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">operate</span><span class="s3">(</span><span class="s1">NOT_EXTEND_LEFT_OF</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">adjacent_to</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; ColumnElement</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">]:</span>
            <span class="s5">&quot;&quot;&quot;Boolean expression. Returns true if the range in the column 
            is adjacent to the range in the operand. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">operate</span><span class="s3">(</span><span class="s1">ADJACENT_TO</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">union</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; ColumnElement</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">]:</span>
            <span class="s5">&quot;&quot;&quot;Range expression. Returns the union of the two ranges. 
            Will raise an exception if the resulting range is not 
            contiguous. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">operate</span><span class="s3">(</span><span class="s1">operators</span><span class="s3">.</span><span class="s1">add</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">difference</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; ColumnElement</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">]:</span>
            <span class="s5">&quot;&quot;&quot;Range expression. Returns the union of the two ranges. 
            Will raise an exception if the resulting range is not 
            contiguous. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">operate</span><span class="s3">(</span><span class="s1">operators</span><span class="s3">.</span><span class="s1">sub</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">intersection</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; ColumnElement</span><span class="s3">[</span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]]:</span>
            <span class="s5">&quot;&quot;&quot;Range expression. Returns the intersection of the two ranges. 
            Will raise an exception if the resulting range is not 
            contiguous. 
            &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">expr</span><span class="s3">.</span><span class="s1">operate</span><span class="s3">(</span><span class="s1">operators</span><span class="s3">.</span><span class="s1">mul</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">AbstractSingleRange</span><span class="s3">(</span><span class="s1">AbstractRange</span><span class="s3">[</span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]]):</span>
    <span class="s4">&quot;&quot;&quot;Base for PostgreSQL RANGE types. 
 
    These are types that return a single :class:`_postgresql.Range` object. 
 
    .. seealso:: 
 
        `PostgreSQL range functions &lt;https://www.postgresql.org/docs/current/static/functions-range.html&gt;`_ 
 
    &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

    <span class="s1">__abstract__ </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_resolve_for_literal</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">: </span><span class="s1">Range</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s1">spec </span><span class="s3">= </span><span class="s1">value</span><span class="s3">.</span><span class="s1">lower </span><span class="s2">if </span><span class="s1">value</span><span class="s3">.</span><span class="s1">lower </span><span class="s2">is not None else </span><span class="s1">value</span><span class="s3">.</span><span class="s1">upper</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">spec</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
            <span class="s0"># pg is unreasonably picky here: the query</span>
            <span class="s0"># &quot;select 1::INTEGER &lt;@ '[1, 4)'::INT8RANGE&quot; raises</span>
            <span class="s0"># &quot;operator does not exist: integer &lt;@ int8range&quot; as of pg 16</span>
            <span class="s2">if </span><span class="s1">_is_int32</span><span class="s3">(</span><span class="s1">value</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">INT4RANGE</span><span class="s3">()</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">INT8RANGE</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">spec</span><span class="s3">, (</span><span class="s1">Decimal</span><span class="s3">, </span><span class="s1">float</span><span class="s3">)):</span>
            <span class="s2">return </span><span class="s1">NUMRANGE</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">spec</span><span class="s3">, </span><span class="s1">datetime</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">TSRANGE</span><span class="s3">() </span><span class="s2">if not </span><span class="s1">spec</span><span class="s3">.</span><span class="s1">tzinfo </span><span class="s2">else </span><span class="s1">TSTZRANGE</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">spec</span><span class="s3">, </span><span class="s1">date</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">DATERANGE</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># empty Range, SQL datatype can't be determined here</span>
            <span class="s2">return </span><span class="s1">sqltypes</span><span class="s3">.</span><span class="s1">NULLTYPE</span>


<span class="s2">class </span><span class="s1">AbstractSingleRangeImpl</span><span class="s3">(</span><span class="s1">AbstractSingleRange</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Marker for AbstractSingleRange that will apply a subclass-specific 
    adaptation&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">AbstractMultiRange</span><span class="s3">(</span><span class="s1">AbstractRange</span><span class="s3">[</span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Range</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]]]):</span>
    <span class="s5">&quot;&quot;&quot;Base for PostgreSQL MULTIRANGE types. 
 
    these are types that return a sequence of :class:`_postgresql.Range` 
    objects. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__abstract__ </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_resolve_for_literal</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">: </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Range</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]]) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">value</span><span class="s3">:</span>
            <span class="s0"># empty MultiRange, SQL datatype can't be determined here</span>
            <span class="s2">return </span><span class="s1">sqltypes</span><span class="s3">.</span><span class="s1">NULLTYPE</span>
        <span class="s1">first </span><span class="s3">= </span><span class="s1">value</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">spec </span><span class="s3">= </span><span class="s1">first</span><span class="s3">.</span><span class="s1">lower </span><span class="s2">if </span><span class="s1">first</span><span class="s3">.</span><span class="s1">lower </span><span class="s2">is not None else </span><span class="s1">first</span><span class="s3">.</span><span class="s1">upper</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">spec</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
            <span class="s0"># pg is unreasonably picky here: the query</span>
            <span class="s0"># &quot;select 1::INTEGER &lt;@ '{[1, 4),[6,19)}'::INT8MULTIRANGE&quot; raises</span>
            <span class="s0"># &quot;operator does not exist: integer &lt;@ int8multirange&quot; as of pg 16</span>
            <span class="s2">if </span><span class="s1">all</span><span class="s3">(</span><span class="s1">_is_int32</span><span class="s3">(</span><span class="s1">r</span><span class="s3">) </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">value</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">INT4MULTIRANGE</span><span class="s3">()</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">INT8MULTIRANGE</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">spec</span><span class="s3">, (</span><span class="s1">Decimal</span><span class="s3">, </span><span class="s1">float</span><span class="s3">)):</span>
            <span class="s2">return </span><span class="s1">NUMMULTIRANGE</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">spec</span><span class="s3">, </span><span class="s1">datetime</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">TSMULTIRANGE</span><span class="s3">() </span><span class="s2">if not </span><span class="s1">spec</span><span class="s3">.</span><span class="s1">tzinfo </span><span class="s2">else </span><span class="s1">TSTZMULTIRANGE</span><span class="s3">()</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">spec</span><span class="s3">, </span><span class="s1">date</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">DATEMULTIRANGE</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># empty Range, SQL datatype can't be determined here</span>
            <span class="s2">return </span><span class="s1">sqltypes</span><span class="s3">.</span><span class="s1">NULLTYPE</span>


<span class="s2">class </span><span class="s1">AbstractMultiRangeImpl</span><span class="s3">(</span><span class="s1">AbstractMultiRange</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Marker for AbstractMultiRange that will apply a subclass-specific 
    adaptation&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">INT4RANGE</span><span class="s3">(</span><span class="s1">AbstractSingleRange</span><span class="s3">[</span><span class="s1">int</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL INT4RANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s3">= </span><span class="s4">&quot;INT4RANGE&quot;</span>


<span class="s2">class </span><span class="s1">INT8RANGE</span><span class="s3">(</span><span class="s1">AbstractSingleRange</span><span class="s3">[</span><span class="s1">int</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL INT8RANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s3">= </span><span class="s4">&quot;INT8RANGE&quot;</span>


<span class="s2">class </span><span class="s1">NUMRANGE</span><span class="s3">(</span><span class="s1">AbstractSingleRange</span><span class="s3">[</span><span class="s1">Decimal</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL NUMRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s3">= </span><span class="s4">&quot;NUMRANGE&quot;</span>


<span class="s2">class </span><span class="s1">DATERANGE</span><span class="s3">(</span><span class="s1">AbstractSingleRange</span><span class="s3">[</span><span class="s1">date</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL DATERANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s3">= </span><span class="s4">&quot;DATERANGE&quot;</span>


<span class="s2">class </span><span class="s1">TSRANGE</span><span class="s3">(</span><span class="s1">AbstractSingleRange</span><span class="s3">[</span><span class="s1">datetime</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL TSRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s3">= </span><span class="s4">&quot;TSRANGE&quot;</span>


<span class="s2">class </span><span class="s1">TSTZRANGE</span><span class="s3">(</span><span class="s1">AbstractSingleRange</span><span class="s3">[</span><span class="s1">datetime</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL TSTZRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s3">= </span><span class="s4">&quot;TSTZRANGE&quot;</span>


<span class="s2">class </span><span class="s1">INT4MULTIRANGE</span><span class="s3">(</span><span class="s1">AbstractMultiRange</span><span class="s3">[</span><span class="s1">int</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL INT4MULTIRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s3">= </span><span class="s4">&quot;INT4MULTIRANGE&quot;</span>


<span class="s2">class </span><span class="s1">INT8MULTIRANGE</span><span class="s3">(</span><span class="s1">AbstractMultiRange</span><span class="s3">[</span><span class="s1">int</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL INT8MULTIRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s3">= </span><span class="s4">&quot;INT8MULTIRANGE&quot;</span>


<span class="s2">class </span><span class="s1">NUMMULTIRANGE</span><span class="s3">(</span><span class="s1">AbstractMultiRange</span><span class="s3">[</span><span class="s1">Decimal</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL NUMMULTIRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s3">= </span><span class="s4">&quot;NUMMULTIRANGE&quot;</span>


<span class="s2">class </span><span class="s1">DATEMULTIRANGE</span><span class="s3">(</span><span class="s1">AbstractMultiRange</span><span class="s3">[</span><span class="s1">date</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL DATEMULTIRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s3">= </span><span class="s4">&quot;DATEMULTIRANGE&quot;</span>


<span class="s2">class </span><span class="s1">TSMULTIRANGE</span><span class="s3">(</span><span class="s1">AbstractMultiRange</span><span class="s3">[</span><span class="s1">datetime</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL TSRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s3">= </span><span class="s4">&quot;TSMULTIRANGE&quot;</span>


<span class="s2">class </span><span class="s1">TSTZMULTIRANGE</span><span class="s3">(</span><span class="s1">AbstractMultiRange</span><span class="s3">[</span><span class="s1">datetime</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Represent the PostgreSQL TSTZRANGE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s3">= </span><span class="s4">&quot;TSTZMULTIRANGE&quot;</span>


<span class="s1">_max_int_32 </span><span class="s3">= </span><span class="s6">2</span><span class="s3">**</span><span class="s6">31 </span><span class="s3">- </span><span class="s6">1</span>
<span class="s1">_min_int_32 </span><span class="s3">= -(</span><span class="s6">2</span><span class="s3">**</span><span class="s6">31</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_is_int32</span><span class="s3">(</span><span class="s1">r</span><span class="s3">: </span><span class="s1">Range</span><span class="s3">[</span><span class="s1">int</span><span class="s3">]) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s3">(</span><span class="s1">r</span><span class="s3">.</span><span class="s1">lower </span><span class="s2">is None or </span><span class="s1">_min_int_32 </span><span class="s3">&lt;= </span><span class="s1">r</span><span class="s3">.</span><span class="s1">lower </span><span class="s3">&lt;= </span><span class="s1">_max_int_32</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span>
        <span class="s1">r</span><span class="s3">.</span><span class="s1">upper </span><span class="s2">is None or </span><span class="s1">_min_int_32 </span><span class="s3">&lt;= </span><span class="s1">r</span><span class="s3">.</span><span class="s1">upper </span><span class="s3">&lt;= </span><span class="s1">_max_int_32</span>
    <span class="s3">)</span>
</pre>
</body>
</html>