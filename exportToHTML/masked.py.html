<html>
<head>
<title>masked.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
masked.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">Literal</span><span class="s2">,</span>
    <span class="s1">overload</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">lib</span><span class="s2">,</span>
    <span class="s1">missing </span><span class="s0">as </span><span class="s1">libmissing</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs</span><span class="s2">.</span><span class="s1">tslibs </span><span class="s0">import </span><span class="s1">is_supported_dtype</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_typing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">ArrayLike</span><span class="s2">,</span>
    <span class="s1">AstypeArg</span><span class="s2">,</span>
    <span class="s1">AxisInt</span><span class="s2">,</span>
    <span class="s1">DtypeObj</span><span class="s2">,</span>
    <span class="s1">FillnaOptions</span><span class="s2">,</span>
    <span class="s1">InterpolateOptions</span><span class="s2">,</span>
    <span class="s1">NpDtype</span><span class="s2">,</span>
    <span class="s1">PositionalIndexer</span><span class="s2">,</span>
    <span class="s1">Scalar</span><span class="s2">,</span>
    <span class="s1">ScalarIndexer</span><span class="s2">,</span>
    <span class="s1">Self</span><span class="s2">,</span>
    <span class="s1">SequenceIndexer</span><span class="s2">,</span>
    <span class="s1">Shape</span><span class="s2">,</span>
    <span class="s1">npt</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">compat </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">IS64</span><span class="s2">,</span>
    <span class="s1">is_platform_windows</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">errors </span><span class="s0">import </span><span class="s1">AbstractMethodError</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">util</span><span class="s2">.</span><span class="s1">_decorators </span><span class="s0">import </span><span class="s1">doc</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">util</span><span class="s2">.</span><span class="s1">_validators </span><span class="s0">import </span><span class="s1">validate_fillna_kwargs</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">base </span><span class="s0">import </span><span class="s1">ExtensionDtype</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">common </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">is_bool</span><span class="s2">,</span>
    <span class="s1">is_integer_dtype</span><span class="s2">,</span>
    <span class="s1">is_list_like</span><span class="s2">,</span>
    <span class="s1">is_scalar</span><span class="s2">,</span>
    <span class="s1">is_string_dtype</span><span class="s2">,</span>
    <span class="s1">pandas_dtype</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">dtypes </span><span class="s0">import </span><span class="s1">BaseMaskedDtype</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">missing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">array_equivalent</span><span class="s2">,</span>
    <span class="s1">is_valid_na_for_dtype</span><span class="s2">,</span>
    <span class="s1">isna</span><span class="s2">,</span>
    <span class="s1">notna</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">algorithms </span><span class="s0">as </span><span class="s1">algos</span><span class="s2">,</span>
    <span class="s1">arraylike</span><span class="s2">,</span>
    <span class="s1">missing</span><span class="s2">,</span>
    <span class="s1">nanops</span><span class="s2">,</span>
    <span class="s1">ops</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">algorithms </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">factorize_array</span><span class="s2">,</span>
    <span class="s1">isin</span><span class="s2">,</span>
    <span class="s1">map_array</span><span class="s2">,</span>
    <span class="s1">mode</span><span class="s2">,</span>
    <span class="s1">take</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">array_algos </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">masked_accumulations</span><span class="s2">,</span>
    <span class="s1">masked_reductions</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">array_algos</span><span class="s2">.</span><span class="s1">quantile </span><span class="s0">import </span><span class="s1">quantile_with_mask</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arraylike </span><span class="s0">import </span><span class="s1">OpsMixin</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays</span><span class="s2">.</span><span class="s1">_utils </span><span class="s0">import </span><span class="s1">to_numpy_dtype_inference</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays</span><span class="s2">.</span><span class="s1">base </span><span class="s0">import </span><span class="s1">ExtensionArray</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">construction </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">array </span><span class="s0">as </span><span class="s1">pd_array</span><span class="s2">,</span>
    <span class="s1">ensure_wrapped_if_datetimelike</span><span class="s2">,</span>
    <span class="s1">extract_array</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">indexers </span><span class="s0">import </span><span class="s1">check_array_indexer</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">ops </span><span class="s0">import </span><span class="s1">invalid_comparison</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">util</span><span class="s2">.</span><span class="s1">hashing </span><span class="s0">import </span><span class="s1">hash_array</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">Iterator</span><span class="s2">,</span>
        <span class="s1">Sequence</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays </span><span class="s0">import </span><span class="s1">BooleanArray</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_typing </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">NumpySorter</span><span class="s2">,</span>
        <span class="s1">NumpyValueArrayLike</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays </span><span class="s0">import </span><span class="s1">FloatingArray</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">compat</span><span class="s2">.</span><span class="s1">numpy </span><span class="s0">import </span><span class="s1">function </span><span class="s0">as </span><span class="s1">nv</span>


<span class="s0">class </span><span class="s1">BaseMaskedArray</span><span class="s2">(</span><span class="s1">OpsMixin</span><span class="s2">, </span><span class="s1">ExtensionArray</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Base class for masked arrays (which use _data and _mask to store the data). 
 
    numpy based 
    &quot;&quot;&quot;</span>

    <span class="s4"># The value used to fill '_data' to avoid upcasting</span>
    <span class="s1">_internal_fill_value</span><span class="s2">: </span><span class="s1">Scalar</span>
    <span class="s4"># our underlying data and mask are each ndarrays</span>
    <span class="s1">_data</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span>
    <span class="s1">_mask</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">]</span>

    <span class="s4"># Fill values used for any/all</span>
    <span class="s1">_truthy_value </span><span class="s2">= </span><span class="s1">Scalar  </span><span class="s4"># bool(_truthy_value) = True</span>
    <span class="s1">_falsey_value </span><span class="s2">= </span><span class="s1">Scalar  </span><span class="s4"># bool(_falsey_value) = False</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">values</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">]) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">BaseMaskedArray</span><span class="s2">.</span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">)</span>
        <span class="s1">result</span><span class="s2">.</span><span class="s1">_data </span><span class="s2">= </span><span class="s1">values</span>
        <span class="s1">result</span><span class="s2">.</span><span class="s1">_mask </span><span class="s2">= </span><span class="s1">mask</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">], </span><span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4"># values is supposed to already be validated in the subclass</span>
        <span class="s0">if not </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">mask</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s0">and </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s5">&quot;mask should be boolean numpy array. Use &quot;</span>
                <span class="s5">&quot;the 'pd.array' function instead&quot;</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;values.shape must match mask.shape&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">copy</span><span class="s2">:</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_data </span><span class="s2">= </span><span class="s1">values</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_mask </span><span class="s2">= </span><span class="s1">mask</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">_from_sequence</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">scalars</span><span class="s2">, *, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s1">values</span><span class="s2">, </span><span class="s1">mask </span><span class="s2">= </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">_coerce_to_array</span><span class="s2">(</span><span class="s1">scalars</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">cls</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">ExtensionArray</span><span class="s2">.</span><span class="s1">_empty</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">_empty</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">: </span><span class="s1">Shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">ExtensionDtype</span><span class="s2">):</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">)</span>
        <span class="s1">values</span><span class="s2">.</span><span class="s1">fill</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">.</span><span class="s1">_internal_fill_value</span><span class="s2">)</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">cls</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">) </span><span class="s0">or </span><span class="s1">dtype </span><span class="s2">!= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
                <span class="s5">f&quot;Default 'empty' implementation is invalid for dtype='</span><span class="s0">{</span><span class="s1">dtype</span><span class="s0">}</span><span class="s5">'&quot;</span>
            <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_formatter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">boxed</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">) </span><span class="s1">-&gt; Callable</span><span class="s2">[[</span><span class="s1">Any</span><span class="s2">], </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None</span><span class="s2">]:</span>
        <span class="s4"># NEP 51: https://github.com/numpy/numpy/pull/22449</span>
        <span class="s0">return </span><span class="s1">str</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; BaseMaskedDtype</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">AbstractMethodError</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">overload</span>
    <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">item</span><span class="s2">: </span><span class="s1">ScalarIndexer</span><span class="s2">) </span><span class="s1">-&gt; Any</span><span class="s2">:</span>
        <span class="s2">...</span>

    <span class="s2">@</span><span class="s1">overload</span>
    <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">item</span><span class="s2">: </span><span class="s1">SequenceIndexer</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s2">...</span>

    <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">item</span><span class="s2">: </span><span class="s1">PositionalIndexer</span><span class="s2">) </span><span class="s1">-&gt; Self </span><span class="s2">| </span><span class="s1">Any</span><span class="s2">:</span>
        <span class="s1">item </span><span class="s2">= </span><span class="s1">check_array_indexer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">item</span><span class="s2">)</span>

        <span class="s1">newmask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">[</span><span class="s1">item</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">is_bool</span><span class="s2">(</span><span class="s1">newmask</span><span class="s2">):</span>
            <span class="s4"># This is a scalar indexing</span>
            <span class="s0">if </span><span class="s1">newmask</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">na_value</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">[</span><span class="s1">item</span><span class="s2">]</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">[</span><span class="s1">item</span><span class="s2">], </span><span class="s1">newmask</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_pad_or_backfill</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">method</span><span class="s2">: </span><span class="s1">FillnaOptions</span><span class="s2">,</span>
        <span class="s1">limit</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">limit_area</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;inside&quot;</span><span class="s2">, </span><span class="s5">&quot;outside&quot;</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span>

        <span class="s0">if </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
            <span class="s1">func </span><span class="s2">= </span><span class="s1">missing</span><span class="s2">.</span><span class="s1">get_fill_func</span><span class="s2">(</span><span class="s1">method</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>

            <span class="s1">npvalues </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">T</span>
            <span class="s1">new_mask </span><span class="s2">= </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">T</span>
            <span class="s0">if </span><span class="s1">copy</span><span class="s2">:</span>
                <span class="s1">npvalues </span><span class="s2">= </span><span class="s1">npvalues</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
                <span class="s1">new_mask </span><span class="s2">= </span><span class="s1">new_mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s0">elif </span><span class="s1">limit_area </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">mask </span><span class="s2">= </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s1">func</span><span class="s2">(</span><span class="s1">npvalues</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">=</span><span class="s1">new_mask</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">limit_area </span><span class="s0">is not None and not </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">all</span><span class="s2">():</span>
                <span class="s1">mask </span><span class="s2">= </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">T</span>
                <span class="s1">neg_mask </span><span class="s2">= ~</span><span class="s1">mask</span>
                <span class="s1">first </span><span class="s2">= </span><span class="s1">neg_mask</span><span class="s2">.</span><span class="s1">argmax</span><span class="s2">()</span>
                <span class="s1">last </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">neg_mask</span><span class="s2">) - </span><span class="s1">neg_mask</span><span class="s2">[::-</span><span class="s6">1</span><span class="s2">].</span><span class="s1">argmax</span><span class="s2">() - </span><span class="s6">1</span>
                <span class="s0">if </span><span class="s1">limit_area </span><span class="s2">== </span><span class="s5">&quot;inside&quot;</span><span class="s2">:</span>
                    <span class="s1">new_mask</span><span class="s2">[:</span><span class="s1">first</span><span class="s2">] |= </span><span class="s1">mask</span><span class="s2">[:</span><span class="s1">first</span><span class="s2">]</span>
                    <span class="s1">new_mask</span><span class="s2">[</span><span class="s1">last </span><span class="s2">+ </span><span class="s6">1 </span><span class="s2">:] |= </span><span class="s1">mask</span><span class="s2">[</span><span class="s1">last </span><span class="s2">+ </span><span class="s6">1 </span><span class="s2">:]</span>
                <span class="s0">elif </span><span class="s1">limit_area </span><span class="s2">== </span><span class="s5">&quot;outside&quot;</span><span class="s2">:</span>
                    <span class="s1">new_mask</span><span class="s2">[</span><span class="s1">first </span><span class="s2">+ </span><span class="s6">1 </span><span class="s2">: </span><span class="s1">last</span><span class="s2">] |= </span><span class="s1">mask</span><span class="s2">[</span><span class="s1">first </span><span class="s2">+ </span><span class="s6">1 </span><span class="s2">: </span><span class="s1">last</span><span class="s2">]</span>

            <span class="s0">if </span><span class="s1">copy</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">npvalues</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">new_mask</span><span class="s2">.</span><span class="s1">T</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">self</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">copy</span><span class="s2">:</span>
                <span class="s1">new_values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">new_values </span><span class="s2">= </span><span class="s1">self</span>
        <span class="s0">return </span><span class="s1">new_values</span>

    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">ExtensionArray</span><span class="s2">.</span><span class="s1">fillna</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">fillna</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s1">value</span><span class="s2">, </span><span class="s1">method </span><span class="s2">= </span><span class="s1">validate_fillna_kwargs</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">method</span><span class="s2">)</span>

        <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span>

        <span class="s1">value </span><span class="s2">= </span><span class="s1">missing</span><span class="s2">.</span><span class="s1">check_value_size</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">))</span>

        <span class="s0">if </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
            <span class="s0">if </span><span class="s1">method </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">func </span><span class="s2">= </span><span class="s1">missing</span><span class="s2">.</span><span class="s1">get_fill_func</span><span class="s2">(</span><span class="s1">method</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>
                <span class="s1">npvalues </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">T</span>
                <span class="s1">new_mask </span><span class="s2">= </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">T</span>
                <span class="s0">if </span><span class="s1">copy</span><span class="s2">:</span>
                    <span class="s1">npvalues </span><span class="s2">= </span><span class="s1">npvalues</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
                    <span class="s1">new_mask </span><span class="s2">= </span><span class="s1">new_mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
                <span class="s1">func</span><span class="s2">(</span><span class="s1">npvalues</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">=</span><span class="s1">new_mask</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">npvalues</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">new_mask</span><span class="s2">.</span><span class="s1">T</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s4"># fill with value</span>
                <span class="s0">if </span><span class="s1">copy</span><span class="s2">:</span>
                    <span class="s1">new_values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">new_values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">[:]</span>
                <span class="s1">new_values</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">] = </span><span class="s1">value</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">copy</span><span class="s2">:</span>
                <span class="s1">new_values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">new_values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">[:]</span>
        <span class="s0">return </span><span class="s1">new_values</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">_coerce_to_array</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, *, </span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">DtypeObj</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">]:</span>
        <span class="s0">raise </span><span class="s1">AbstractMethodError</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_validate_setitem_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Check if we have a scalar that we can cast losslessly. 
 
        Raises 
        ------ 
        TypeError 
        &quot;&quot;&quot;</span>
        <span class="s1">kind </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind</span>
        <span class="s4"># TODO: get this all from np_can_hold_element?</span>
        <span class="s0">if </span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;b&quot;</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">is_bool</span><span class="s2">(</span><span class="s1">value</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">value</span>

        <span class="s0">elif </span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;f&quot;</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">is_integer</span><span class="s2">(</span><span class="s1">value</span><span class="s2">) </span><span class="s0">or </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">is_float</span><span class="s2">(</span><span class="s1">value</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">value</span>

        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">is_integer</span><span class="s2">(</span><span class="s1">value</span><span class="s2">) </span><span class="s0">or </span><span class="s2">(</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">is_float</span><span class="s2">(</span><span class="s1">value</span><span class="s2">) </span><span class="s0">and </span><span class="s1">value</span><span class="s2">.</span><span class="s1">is_integer</span><span class="s2">()):</span>
                <span class="s0">return </span><span class="s1">value</span>
            <span class="s4"># TODO: unsigned checks</span>

        <span class="s4"># Note: without the &quot;str&quot; here, the f-string rendering raises in</span>
        <span class="s4">#  py38 builds.</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">f&quot;Invalid value '</span><span class="s0">{</span><span class="s1">str</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span><span class="s0">}</span><span class="s5">' for dtype </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__setitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">key </span><span class="s2">= </span><span class="s1">check_array_indexer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">is_scalar</span><span class="s2">(</span><span class="s1">value</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">is_valid_na_for_dtype</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s0">True</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">value </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_validate_setitem_value</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s1">value</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s0">return</span>

        <span class="s1">value</span><span class="s2">, </span><span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_coerce_to_array</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s1">value</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s1">mask</span>

    <span class="s0">def </span><span class="s1">__contains__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">isna</span><span class="s2">(</span><span class="s1">key</span><span class="s2">) </span><span class="s0">and </span><span class="s1">key </span><span class="s0">is not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">na_value</span><span class="s2">:</span>
            <span class="s4"># GH#52840</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;f&quot; </span><span class="s0">and </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">is_float</span><span class="s2">(</span><span class="s1">key</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">bool</span><span class="s2">((</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">) &amp; ~</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">).</span><span class="s1">any</span><span class="s2">())</span>

        <span class="s0">return </span><span class="s1">bool</span><span class="s2">(</span><span class="s1">super</span><span class="s2">().</span><span class="s1">__contains__</span><span class="s2">(</span><span class="s1">key</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">__iter__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Iterator</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_hasna</span><span class="s2">:</span>
                <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">:</span>
                    <span class="s0">yield </span><span class="s1">val</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">na_value </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">na_value</span>
                <span class="s0">for </span><span class="s1">isna_</span><span class="s2">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">):</span>
                    <span class="s0">if </span><span class="s1">isna_</span><span class="s2">:</span>
                        <span class="s0">yield </span><span class="s1">na_value</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s0">yield </span><span class="s1">val</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)):</span>
                <span class="s0">yield </span><span class="s1">self</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">__len__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">shape</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Shape</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">shape</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">ndim</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">ndim</span>

    <span class="s0">def </span><span class="s1">swapaxes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axis1</span><span class="s2">, </span><span class="s1">axis2</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">swapaxes</span><span class="s2">(</span><span class="s1">axis1</span><span class="s2">, </span><span class="s1">axis2</span><span class="s2">)</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">swapaxes</span><span class="s2">(</span><span class="s1">axis1</span><span class="s2">, </span><span class="s1">axis2</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">delete</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">= </span><span class="s6">0</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">delete</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">delete</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">ravel</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s4"># TODO: need to make sure we have the same order for data/mask</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">T</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">T</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">round</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">decimals</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s6">0</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Round each value in the array a to the given number of decimals. 
 
        Parameters 
        ---------- 
        decimals : int, default 0 
            Number of decimal places to round to. If decimals is negative, 
            it specifies the number of positions to the left of the decimal point. 
        *args, **kwargs 
            Additional arguments and keywords have no effect but might be 
            accepted for compatibility with NumPy. 
 
        Returns 
        ------- 
        NumericArray 
            Rounded values of the NumericArray. 
 
        See Also 
        -------- 
        numpy.around : Round values of an np.array. 
        DataFrame.round : Round values of a DataFrame. 
        Series.round : Round values of a Series. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;b&quot;</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_round</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">round</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s1">decimals</span><span class="s2">=</span><span class="s1">decimals</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s4"># Usually we'll get same type as self, but ndarray[bool] casts to float</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_mask_result</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">())</span>

    <span class="s4"># ------------------------------------------------------------------</span>
    <span class="s4"># Unary Methods</span>

    <span class="s0">def </span><span class="s1">__invert__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(~</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">())</span>

    <span class="s0">def </span><span class="s1">__neg__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(-</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">())</span>

    <span class="s0">def </span><span class="s1">__pos__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">__abs__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">), </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">())</span>

    <span class="s4"># ------------------------------------------------------------------</span>

    <span class="s0">def </span><span class="s1">_values_for_json</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">object</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">to_numpy</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">DTypeLike </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">na_value</span><span class="s2">: </span><span class="s1">object </span><span class="s2">= </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert to a NumPy Array. 
 
        By default converts to an object-dtype NumPy array. Specify the `dtype` and 
        `na_value` keywords to customize the conversion. 
 
        Parameters 
        ---------- 
        dtype : dtype, default object 
            The numpy dtype to convert to. 
        copy : bool, default False 
            Whether to ensure that the returned value is a not a view on 
            the array. Note that ``copy=False`` does not *ensure* that 
            ``to_numpy()`` is no-copy. Rather, ``copy=True`` ensure that 
            a copy is made, even if not strictly necessary. This is typically 
            only possible when no missing values are present and `dtype` 
            is the equivalent numpy dtype. 
        na_value : scalar, optional 
             Scalar missing value indicator to use in numpy array. Defaults 
             to the native missing value indicator of this array (pd.NA). 
 
        Returns 
        ------- 
        numpy.ndarray 
 
        Examples 
        -------- 
        An object-dtype is the default result 
 
        &gt;&gt;&gt; a = pd.array([True, False, pd.NA], dtype=&quot;boolean&quot;) 
        &gt;&gt;&gt; a.to_numpy() 
        array([True, False, &lt;NA&gt;], dtype=object) 
 
        When no missing values are present, an equivalent dtype can be used. 
 
        &gt;&gt;&gt; pd.array([True, False], dtype=&quot;boolean&quot;).to_numpy(dtype=&quot;bool&quot;) 
        array([ True, False]) 
        &gt;&gt;&gt; pd.array([1, 2], dtype=&quot;Int64&quot;).to_numpy(&quot;int64&quot;) 
        array([1, 2]) 
 
        However, requesting such dtype will raise a ValueError if 
        missing values are present and the default missing value :attr:`NA` 
        is used. 
 
        &gt;&gt;&gt; a = pd.array([True, False, pd.NA], dtype=&quot;boolean&quot;) 
        &gt;&gt;&gt; a 
        &lt;BooleanArray&gt; 
        [True, False, &lt;NA&gt;] 
        Length: 3, dtype: boolean 
 
        &gt;&gt;&gt; a.to_numpy(dtype=&quot;bool&quot;) 
        Traceback (most recent call last): 
        ... 
        ValueError: cannot convert to bool numpy array in presence of missing values 
 
        Specify a valid `na_value` instead 
 
        &gt;&gt;&gt; a.to_numpy(dtype=&quot;bool&quot;, na_value=False) 
        array([ True, False, False]) 
        &quot;&quot;&quot;</span>
        <span class="s1">hasna </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_hasna</span>
        <span class="s1">dtype</span><span class="s2">, </span><span class="s1">na_value </span><span class="s2">= </span><span class="s1">to_numpy_dtype_inference</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">, </span><span class="s1">hasna</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">dtype </span><span class="s2">= </span><span class="s1">object</span>

        <span class="s0">if </span><span class="s1">hasna</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s2">(</span>
                <span class="s1">dtype </span><span class="s2">!= </span><span class="s1">object</span>
                <span class="s0">and not </span><span class="s1">is_string_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
                <span class="s0">and </span><span class="s1">na_value </span><span class="s0">is </span><span class="s1">libmissing</span><span class="s2">.</span><span class="s1">NA</span>
            <span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s5">f&quot;cannot convert to '</span><span class="s0">{</span><span class="s1">dtype</span><span class="s0">}</span><span class="s5">'-dtype NumPy array &quot;</span>
                    <span class="s5">&quot;with missing values. Specify an appropriate 'na_value' &quot;</span>
                    <span class="s5">&quot;for this dtype.&quot;</span>
                <span class="s2">)</span>
            <span class="s4"># don't pass copy to astype -&gt; always need a copy since we are mutating</span>
            <span class="s0">with </span><span class="s1">warnings</span><span class="s2">.</span><span class="s1">catch_warnings</span><span class="s2">():</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">filterwarnings</span><span class="s2">(</span><span class="s5">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">category</span><span class="s2">=</span><span class="s1">RuntimeWarning</span><span class="s2">)</span>
                <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">data</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">] = </span><span class="s1">na_value</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">warnings</span><span class="s2">.</span><span class="s1">catch_warnings</span><span class="s2">():</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">filterwarnings</span><span class="s2">(</span><span class="s5">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">category</span><span class="s2">=</span><span class="s1">RuntimeWarning</span><span class="s2">)</span>
                <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">data</span>

    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">ExtensionArray</span><span class="s2">.</span><span class="s1">tolist</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">tolist</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">x</span><span class="s2">.</span><span class="s1">tolist</span><span class="s2">() </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self</span><span class="s2">]</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s0">None if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_hasna </span><span class="s0">else </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">to_numpy</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">=</span><span class="s1">libmissing</span><span class="s2">.</span><span class="s1">NA</span><span class="s2">).</span><span class="s1">tolist</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">overload</span>
    <span class="s0">def </span><span class="s1">astype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">DTypeLike</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= ...) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">:</span>
        <span class="s2">...</span>

    <span class="s2">@</span><span class="s1">overload</span>
    <span class="s0">def </span><span class="s1">astype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">ExtensionDtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= ...) </span><span class="s1">-&gt; ExtensionArray</span><span class="s2">:</span>
        <span class="s2">...</span>

    <span class="s2">@</span><span class="s1">overload</span>
    <span class="s0">def </span><span class="s1">astype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">AstypeArg</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= ...) </span><span class="s1">-&gt; ArrayLike</span><span class="s2">:</span>
        <span class="s2">...</span>

    <span class="s0">def </span><span class="s1">astype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">AstypeArg</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">) </span><span class="s1">-&gt; ArrayLike</span><span class="s2">:</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">pandas_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">copy</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s4"># if we are astyping to another nullable masked dtype, we can fastpath</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">BaseMaskedDtype</span><span class="s2">):</span>
            <span class="s4"># TODO deal with NaNs for FloatingArray case</span>
            <span class="s0">with </span><span class="s1">warnings</span><span class="s2">.</span><span class="s1">catch_warnings</span><span class="s2">():</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">filterwarnings</span><span class="s2">(</span><span class="s5">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">category</span><span class="s2">=</span><span class="s1">RuntimeWarning</span><span class="s2">)</span>
                <span class="s4"># TODO: Is rounding what we want long term?</span>
                <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">numpy_dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>
            <span class="s4"># mask is copied depending on whether the data was copied, and</span>
            <span class="s4"># not directly depending on the `copy` keyword</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask </span><span class="s0">if </span><span class="s1">data </span><span class="s0">is </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data </span><span class="s0">else </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s1">cls </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">construct_array_type</span><span class="s2">()</span>
            <span class="s0">return </span><span class="s1">cls</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype</span><span class="s2">):</span>
            <span class="s1">eacls </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">construct_array_type</span><span class="s2">()</span>
            <span class="s0">return </span><span class="s1">eacls</span><span class="s2">.</span><span class="s1">_from_sequence</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>

        <span class="s1">na_value</span><span class="s2">: </span><span class="s1">float </span><span class="s2">| </span><span class="s1">np</span><span class="s2">.</span><span class="s1">datetime64 </span><span class="s2">| </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">NoDefault</span>

        <span class="s4"># coerce</span>
        <span class="s0">if </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;f&quot;</span><span class="s2">:</span>
            <span class="s4"># In astype, we consider dtype=float to also mean na_value=np.nan</span>
            <span class="s1">na_value </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span>
        <span class="s0">elif </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;M&quot;</span><span class="s2">:</span>
            <span class="s1">na_value </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">datetime64</span><span class="s2">(</span><span class="s5">&quot;NaT&quot;</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">na_value </span><span class="s2">= </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span>

        <span class="s4"># to_numpy will also raise, but we get somewhat nicer exception messages here</span>
        <span class="s0">if </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">in </span><span class="s5">&quot;iu&quot; </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_hasna</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;cannot convert NA to integer&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;b&quot; </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_hasna</span><span class="s2">:</span>
            <span class="s4"># careful: astype_nansafe converts np.nan to True</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;cannot convert float NaN to bool&quot;</span><span class="s2">)</span>

        <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">to_numpy</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">=</span><span class="s1">na_value</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">data</span>

    <span class="s1">__array_priority__ </span><span class="s2">= </span><span class="s6">1000  </span><span class="s4"># higher than ndarray so ops dispatch to us</span>

    <span class="s0">def </span><span class="s1">__array__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">NpDtype </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s2">) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        the array interface, return my values 
        We return an object array here to preserve our scalar values 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">to_numpy</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s1">_HANDLED_TYPES</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">type</span><span class="s2">, ...]</span>

    <span class="s0">def </span><span class="s1">__array_ufunc__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ufunc</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">method</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, *</span><span class="s1">inputs</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s4"># For MaskedArray inputs, we apply the ufunc to ._data</span>
        <span class="s4"># and mask the result.</span>

        <span class="s1">out </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s5">&quot;out&quot;</span><span class="s2">, ())</span>

        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">inputs </span><span class="s2">+ </span><span class="s1">out</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_HANDLED_TYPES </span><span class="s2">+ (</span><span class="s1">BaseMaskedArray</span><span class="s2">,)):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>

        <span class="s4"># for binary ops, use our custom dunder methods</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">arraylike</span><span class="s2">.</span><span class="s1">maybe_dispatch_ufunc_to_dunder_op</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, *</span><span class="s1">inputs</span><span class="s2">, **</span><span class="s1">kwargs</span>
        <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">result </span><span class="s0">is not </span><span class="s1">NotImplemented</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">result</span>

        <span class="s0">if </span><span class="s5">&quot;out&quot; </span><span class="s0">in </span><span class="s1">kwargs</span><span class="s2">:</span>
            <span class="s4"># e.g. test_ufunc_with_out</span>
            <span class="s0">return </span><span class="s1">arraylike</span><span class="s2">.</span><span class="s1">dispatch_ufunc_with_out</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">, </span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, *</span><span class="s1">inputs</span><span class="s2">, **</span><span class="s1">kwargs</span>
            <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">method </span><span class="s2">== </span><span class="s5">&quot;reduce&quot;</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">arraylike</span><span class="s2">.</span><span class="s1">dispatch_reduction_ufunc</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">, </span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, *</span><span class="s1">inputs</span><span class="s2">, **</span><span class="s1">kwargs</span>
            <span class="s2">)</span>
            <span class="s0">if </span><span class="s1">result </span><span class="s0">is not </span><span class="s1">NotImplemented</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">result</span>

        <span class="s1">mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
        <span class="s1">inputs2 </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">inputs</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">BaseMaskedArray</span><span class="s2">):</span>
                <span class="s1">mask </span><span class="s2">|= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">_mask</span>
                <span class="s1">inputs2</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">inputs2</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">reconstruct</span><span class="s2">(</span><span class="s1">x</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">):</span>
            <span class="s4"># we don't worry about scalar `x` here, since we</span>
            <span class="s4"># raise for reduce up above.</span>
            <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays </span><span class="s0">import </span><span class="s2">(</span>
                <span class="s1">BooleanArray</span><span class="s2">,</span>
                <span class="s1">FloatingArray</span><span class="s2">,</span>
                <span class="s1">IntegerArray</span><span class="s2">,</span>
            <span class="s2">)</span>

            <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;b&quot;</span><span class="s2">:</span>
                <span class="s1">m </span><span class="s2">= </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
                <span class="s0">return </span><span class="s1">BooleanArray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">m</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">in </span><span class="s5">&quot;iu&quot;</span><span class="s2">:</span>
                <span class="s1">m </span><span class="s2">= </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
                <span class="s0">return </span><span class="s1">IntegerArray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">m</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;f&quot;</span><span class="s2">:</span>
                <span class="s1">m </span><span class="s2">= </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
                <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float16</span><span class="s2">:</span>
                    <span class="s4"># reached in e.g. np.sqrt on BooleanArray</span>
                    <span class="s4"># we don't support float16</span>
                    <span class="s1">x </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">FloatingArray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">m</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">x</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span>
            <span class="s0">return </span><span class="s1">x</span>

        <span class="s1">result </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">method</span><span class="s2">)(*</span><span class="s1">inputs2</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nout </span><span class="s2">&gt; </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s4"># e.g. np.divmod</span>
            <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">reconstruct</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">result</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">method </span><span class="s2">== </span><span class="s5">&quot;reduce&quot;</span><span class="s2">:</span>
            <span class="s4"># e.g. np.add.reduce; test_ufunc_reduce_raises</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_na_value</span>
            <span class="s0">return </span><span class="s1">result</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">reconstruct</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__arrow_array__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert myself into a pyarrow Array. 
        &quot;&quot;&quot;</span>
        <span class="s0">import </span><span class="s1">pyarrow </span><span class="s0">as </span><span class="s1">pa</span>

        <span class="s0">return </span><span class="s1">pa</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">, </span><span class="s1">type</span><span class="s2">=</span><span class="s1">type</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">_hasna</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s4"># Note: this is expensive right now! The hope is that we can</span>
        <span class="s4"># make this faster by having an optional mask, but not have to change</span>
        <span class="s4"># source code using it..</span>

        <span class="s4"># error: Incompatible return value type (got &quot;bool_&quot;, expected &quot;bool&quot;)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">any</span><span class="s2">()  </span><span class="s4"># type: ignore[return-value]</span>

    <span class="s0">def </span><span class="s1">_propagate_mask</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">] | </span><span class="s0">None</span><span class="s2">, </span><span class="s1">other</span>
    <span class="s2">) </span><span class="s1">-&gt; npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">]:</span>
        <span class="s0">if </span><span class="s1">mask </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()  </span><span class="s4"># TODO: need test for BooleanArray needing a copy</span>
            <span class="s0">if </span><span class="s1">other </span><span class="s0">is </span><span class="s1">libmissing</span><span class="s2">.</span><span class="s1">NA</span><span class="s2">:</span>
                <span class="s4"># GH#45421 don't alter inplace</span>
                <span class="s1">mask </span><span class="s2">= </span><span class="s1">mask </span><span class="s2">| </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">other</span><span class="s2">) </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">other</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">mask</span><span class="s2">):</span>
                <span class="s1">mask </span><span class="s2">= </span><span class="s1">mask </span><span class="s2">| </span><span class="s1">isna</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask </span><span class="s2">| </span><span class="s1">mask</span>
        <span class="s4"># Incompatible return value type (got &quot;Optional[ndarray[Any, dtype[bool_]]]&quot;,</span>
        <span class="s4"># expected &quot;ndarray[Any, dtype[bool_]]&quot;)</span>
        <span class="s0">return </span><span class="s1">mask  </span><span class="s4"># type: ignore[return-value]</span>

    <span class="s0">def </span><span class="s1">_arith_method</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op</span><span class="s2">):</span>
        <span class="s1">op_name </span><span class="s2">= </span><span class="s1">op</span><span class="s2">.</span><span class="s1">__name__</span>
        <span class="s1">omask </span><span class="s2">= </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s2">(</span>
            <span class="s0">not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s5">&quot;dtype&quot;</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">other</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
        <span class="s2">):</span>
            <span class="s4"># Try inferring masked dtype instead of casting to object</span>
            <span class="s1">other </span><span class="s2">= </span><span class="s1">pd_array</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
            <span class="s1">other </span><span class="s2">= </span><span class="s1">extract_array</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">extract_numpy</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">BaseMaskedArray</span><span class="s2">):</span>
            <span class="s1">other</span><span class="s2">, </span><span class="s1">omask </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">_mask</span>

        <span class="s0">elif </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">ExtensionArray</span><span class="s2">):</span>
                <span class="s1">other </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">other</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s5">&quot;can only perform ops with 1-d structures&quot;</span><span class="s2">)</span>

        <span class="s4"># We wrap the non-masked arithmetic logic used for numpy dtypes</span>
        <span class="s4">#  in Series/Index arithmetic ops.</span>
        <span class="s1">other </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">maybe_prepare_scalar_for_op</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, (</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">),))</span>
        <span class="s1">pd_op </span><span class="s2">= </span><span class="s1">ops</span><span class="s2">.</span><span class="s1">get_array_op</span><span class="s2">(</span><span class="s1">op</span><span class="s2">)</span>
        <span class="s1">other </span><span class="s2">= </span><span class="s1">ensure_wrapped_if_datetimelike</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">op_name </span><span class="s0">in </span><span class="s2">{</span><span class="s5">&quot;pow&quot;</span><span class="s2">, </span><span class="s5">&quot;rpow&quot;</span><span class="s2">} </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">):</span>
            <span class="s4"># Avoid DeprecationWarning: In future, it will be an error</span>
            <span class="s4">#  for 'np.bool_' scalars to be interpreted as an index</span>
            <span class="s4">#  e.g. test_array_scalar_like_equivalence</span>
            <span class="s1">other </span><span class="s2">= </span><span class="s1">bool</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>

        <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_propagate_mask</span><span class="s2">(</span><span class="s1">omask</span><span class="s2">, </span><span class="s1">other</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">other </span><span class="s0">is </span><span class="s1">libmissing</span><span class="s2">.</span><span class="s1">NA</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones_like</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;b&quot;</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">op_name </span><span class="s0">in </span><span class="s2">{</span>
                    <span class="s5">&quot;floordiv&quot;</span><span class="s2">,</span>
                    <span class="s5">&quot;rfloordiv&quot;</span><span class="s2">,</span>
                    <span class="s5">&quot;pow&quot;</span><span class="s2">,</span>
                    <span class="s5">&quot;rpow&quot;</span><span class="s2">,</span>
                    <span class="s5">&quot;truediv&quot;</span><span class="s2">,</span>
                    <span class="s5">&quot;rtruediv&quot;</span><span class="s2">,</span>
                <span class="s2">}:</span>
                    <span class="s4"># GH#41165 Try to match non-masked Series behavior</span>
                    <span class="s4">#  This is still imperfect GH#46043</span>
                    <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
                        <span class="s5">f&quot;operator '</span><span class="s0">{</span><span class="s1">op_name</span><span class="s0">}</span><span class="s5">' not implemented for bool dtypes&quot;</span>
                    <span class="s2">)</span>
                <span class="s0">if </span><span class="s1">op_name </span><span class="s0">in </span><span class="s2">{</span><span class="s5">&quot;mod&quot;</span><span class="s2">, </span><span class="s5">&quot;rmod&quot;</span><span class="s2">}:</span>
                    <span class="s1">dtype </span><span class="s2">= </span><span class="s5">&quot;int8&quot;</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">dtype </span><span class="s2">= </span><span class="s5">&quot;bool&quot;</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s5">&quot;truediv&quot; </span><span class="s0">in </span><span class="s1">op_name </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">!= </span><span class="s5">&quot;f&quot;</span><span class="s2">:</span>
                <span class="s4"># The actual data here doesn't matter since the mask</span>
                <span class="s4">#  will be all-True, but since this is division, we want</span>
                <span class="s4">#  to end up with floating dtype.</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># Make sure we do this before the &quot;pow&quot; mask checks</span>
            <span class="s4">#  to get an expected exception message on shape mismatch.</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">in </span><span class="s5">&quot;iu&quot; </span><span class="s0">and </span><span class="s1">op_name </span><span class="s0">in </span><span class="s2">[</span><span class="s5">&quot;floordiv&quot;</span><span class="s2">, </span><span class="s5">&quot;mod&quot;</span><span class="s2">]:</span>
                <span class="s4"># TODO(GH#30188) ATM we don't match the behavior of non-masked</span>
                <span class="s4">#  types with respect to floordiv-by-zero</span>
                <span class="s1">pd_op </span><span class="s2">= </span><span class="s1">op</span>

            <span class="s0">with </span><span class="s1">np</span><span class="s2">.</span><span class="s1">errstate</span><span class="s2">(</span><span class="s1">all</span><span class="s2">=</span><span class="s5">&quot;ignore&quot;</span><span class="s2">):</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">pd_op</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s1">other</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">op_name </span><span class="s2">== </span><span class="s5">&quot;pow&quot;</span><span class="s2">:</span>
            <span class="s4"># 1 ** x is 1.</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data </span><span class="s2">== </span><span class="s6">1</span><span class="s2">) &amp; ~</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>
            <span class="s4"># x ** 0 is 1.</span>
            <span class="s0">if </span><span class="s1">omask </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">((</span><span class="s1">other </span><span class="s2">== </span><span class="s6">0</span><span class="s2">) &amp; ~</span><span class="s1">omask</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">other </span><span class="s0">is not </span><span class="s1">libmissing</span><span class="s2">.</span><span class="s1">NA</span><span class="s2">:</span>
                <span class="s1">mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">other </span><span class="s2">== </span><span class="s6">0</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>

        <span class="s0">elif </span><span class="s1">op_name </span><span class="s2">== </span><span class="s5">&quot;rpow&quot;</span><span class="s2">:</span>
            <span class="s4"># 1 ** x is 1.</span>
            <span class="s0">if </span><span class="s1">omask </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">((</span><span class="s1">other </span><span class="s2">== </span><span class="s6">1</span><span class="s2">) &amp; ~</span><span class="s1">omask</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">other </span><span class="s0">is not </span><span class="s1">libmissing</span><span class="s2">.</span><span class="s1">NA</span><span class="s2">:</span>
                <span class="s1">mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">other </span><span class="s2">== </span><span class="s6">1</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>
            <span class="s4"># x ** 0 is 1.</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data </span><span class="s2">== </span><span class="s6">0</span><span class="s2">) &amp; ~</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_mask_result</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>

    <span class="s1">_logical_method </span><span class="s2">= </span><span class="s1">_arith_method</span>

    <span class="s0">def </span><span class="s1">_cmp_method</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op</span><span class="s2">) </span><span class="s1">-&gt; BooleanArray</span><span class="s2">:</span>
        <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays </span><span class="s0">import </span><span class="s1">BooleanArray</span>

        <span class="s1">mask </span><span class="s2">= </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">BaseMaskedArray</span><span class="s2">):</span>
            <span class="s1">other</span><span class="s2">, </span><span class="s1">mask </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">_mask</span>

        <span class="s0">elif </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s1">other </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">other</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s5">&quot;can only perform ops with 1-d structures&quot;</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;Lengths must match to compare&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">other </span><span class="s0">is </span><span class="s1">libmissing</span><span class="s2">.</span><span class="s1">NA</span><span class="s2">:</span>
            <span class="s4"># numpy does not handle pd.NA well as &quot;other&quot; scalar (it returns</span>
            <span class="s4"># a scalar False instead of an array)</span>
            <span class="s4"># This may be fixed by NA.__array_ufunc__. Revisit this check</span>
            <span class="s4"># once that's implemented.</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s5">&quot;bool&quot;</span><span class="s2">)</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s5">&quot;bool&quot;</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">warnings</span><span class="s2">.</span><span class="s1">catch_warnings</span><span class="s2">():</span>
                <span class="s4"># numpy may show a FutureWarning or DeprecationWarning:</span>
                <span class="s4">#     elementwise comparison failed; returning scalar instead,</span>
                <span class="s4">#     but in the future will perform elementwise comparison</span>
                <span class="s4"># before returning NotImplemented. We fall back to the correct</span>
                <span class="s4"># behavior today, so that should be fine to ignore.</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">filterwarnings</span><span class="s2">(</span><span class="s5">&quot;ignore&quot;</span><span class="s2">, </span><span class="s5">&quot;elementwise&quot;</span><span class="s2">, </span><span class="s1">FutureWarning</span><span class="s2">)</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">filterwarnings</span><span class="s2">(</span><span class="s5">&quot;ignore&quot;</span><span class="s2">, </span><span class="s5">&quot;elementwise&quot;</span><span class="s2">, </span><span class="s1">DeprecationWarning</span><span class="s2">)</span>
                <span class="s1">method </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s5">f&quot;__</span><span class="s0">{</span><span class="s1">op</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">}</span><span class="s5">__&quot;</span><span class="s2">)</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">method</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>

                <span class="s0">if </span><span class="s1">result </span><span class="s0">is </span><span class="s1">NotImplemented</span><span class="s2">:</span>
                    <span class="s1">result </span><span class="s2">= </span><span class="s1">invalid_comparison</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op</span><span class="s2">)</span>

        <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_propagate_mask</span><span class="s2">(</span><span class="s1">mask</span><span class="s2">, </span><span class="s1">other</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">BooleanArray</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_maybe_mask_result</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">result</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray </span><span class="s2">| </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">], </span><span class="s1">mask</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span>
    <span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        result : array-like or tuple[array-like] 
        mask : array-like bool 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
            <span class="s4"># i.e. divmod</span>
            <span class="s1">div</span><span class="s2">, </span><span class="s1">mod </span><span class="s2">= </span><span class="s1">result</span>
            <span class="s0">return </span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_mask_result</span><span class="s2">(</span><span class="s1">div</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">),</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_mask_result</span><span class="s2">(</span><span class="s1">mod</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">),</span>
            <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">result</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;f&quot;</span><span class="s2">:</span>
            <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays </span><span class="s0">import </span><span class="s1">FloatingArray</span>

            <span class="s0">return </span><span class="s1">FloatingArray</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

        <span class="s0">elif </span><span class="s1">result</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;b&quot;</span><span class="s2">:</span>
            <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays </span><span class="s0">import </span><span class="s1">BooleanArray</span>

            <span class="s0">return </span><span class="s1">BooleanArray</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

        <span class="s0">elif </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">is_np_dtype</span><span class="s2">(</span><span class="s1">result</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s5">&quot;m&quot;</span><span class="s2">) </span><span class="s0">and </span><span class="s1">is_supported_dtype</span><span class="s2">(</span><span class="s1">result</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">):</span>
            <span class="s4"># e.g. test_numeric_arr_mul_tdscalar_numexpr_path</span>
            <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays </span><span class="s0">import </span><span class="s1">TimedeltaArray</span>

            <span class="s1">result</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">] = </span><span class="s1">result</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">(</span><span class="s5">&quot;NaT&quot;</span><span class="s2">)</span>

            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">TimedeltaArray</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">TimedeltaArray</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">result</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

            <span class="s0">return </span><span class="s1">result</span>

        <span class="s0">elif </span><span class="s1">result</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">in </span><span class="s5">&quot;iu&quot;</span><span class="s2">:</span>
            <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays </span><span class="s0">import </span><span class="s1">IntegerArray</span>

            <span class="s0">return </span><span class="s1">IntegerArray</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">result</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span>
            <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">isna</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">_na_value</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">na_value</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">nbytes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">nbytes </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">nbytes</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">_concat_same_type</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">to_concat</span><span class="s2">: </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">Self</span><span class="s2">],</span>
        <span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">([</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_data </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">to_concat</span><span class="s2">], </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">([</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_mask </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">to_concat</span><span class="s2">], </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">cls</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_hash_pandas_object</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, *, </span><span class="s1">encoding</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">hash_key</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">categorize</span><span class="s2">: </span><span class="s1">bool</span>
    <span class="s2">) </span><span class="s1">-&gt; npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">]:</span>
        <span class="s1">hashed_array </span><span class="s2">= </span><span class="s1">hash_array</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">=</span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">hash_key</span><span class="s2">=</span><span class="s1">hash_key</span><span class="s2">, </span><span class="s1">categorize</span><span class="s2">=</span><span class="s1">categorize</span>
        <span class="s2">)</span>
        <span class="s1">hashed_array</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">isna</span><span class="s2">()] = </span><span class="s1">hash</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">na_value</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">hashed_array</span>

    <span class="s0">def </span><span class="s1">take</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">indexer</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">allow_fill</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">fill_value</span><span class="s2">: </span><span class="s1">Scalar </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s4"># we always fill with 1 internally</span>
        <span class="s4"># to avoid upcasting</span>
        <span class="s1">data_fill_value </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_internal_fill_value </span><span class="s0">if </span><span class="s1">isna</span><span class="s2">(</span><span class="s1">fill_value</span><span class="s2">) </span><span class="s0">else </span><span class="s1">fill_value</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">take</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">,</span>
            <span class="s1">indexer</span><span class="s2">,</span>
            <span class="s1">fill_value</span><span class="s2">=</span><span class="s1">data_fill_value</span><span class="s2">,</span>
            <span class="s1">allow_fill</span><span class="s2">=</span><span class="s1">allow_fill</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s1">mask </span><span class="s2">= </span><span class="s1">take</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">allow_fill</span><span class="s2">=</span><span class="s1">allow_fill</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span>
        <span class="s2">)</span>

        <span class="s4"># if we are filling</span>
        <span class="s4"># we only fill where the indexer is null</span>
        <span class="s4"># not existing missing values</span>
        <span class="s4"># TODO(jreback) what if we have a non-na float as a fill value?</span>
        <span class="s0">if </span><span class="s1">allow_fill </span><span class="s0">and </span><span class="s1">notna</span><span class="s2">(</span><span class="s1">fill_value</span><span class="s2">):</span>
            <span class="s1">fill_mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">) == -</span><span class="s6">1</span>
            <span class="s1">result</span><span class="s2">[</span><span class="s1">fill_mask</span><span class="s2">] = </span><span class="s1">fill_value</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">mask </span><span class="s2">^ </span><span class="s1">fill_mask</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>

    <span class="s4"># error: Return type &quot;BooleanArray&quot; of &quot;isin&quot; incompatible with return type</span>
    <span class="s4"># &quot;ndarray&quot; in supertype &quot;ExtensionArray&quot;</span>
    <span class="s0">def </span><span class="s1">isin</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">: </span><span class="s1">ArrayLike</span><span class="s2">) </span><span class="s1">-&gt; BooleanArray</span><span class="s2">:  </span><span class="s4"># type: ignore[override]</span>
        <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays </span><span class="s0">import </span><span class="s1">BooleanArray</span>

        <span class="s4"># algorithms.isin will eventually convert values to an ndarray, so no extra</span>
        <span class="s4"># cost to doing it here first</span>
        <span class="s1">values_arr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">values</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">isin</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s1">values_arr</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_hasna</span><span class="s2">:</span>
            <span class="s1">values_have_NA </span><span class="s2">= </span><span class="s1">values_arr</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">object </span><span class="s0">and </span><span class="s1">any</span><span class="s2">(</span>
                <span class="s1">val </span><span class="s0">is </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">na_value </span><span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">values_arr</span>
            <span class="s2">)</span>

            <span class="s4"># For now, NA does not propagate so set result according to presence of NA,</span>
            <span class="s4"># see https://github.com/pandas-dev/pandas/pull/38379 for some discussion</span>
            <span class="s1">result</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">] = </span><span class="s1">values_have_NA</span>

        <span class="s1">mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">BooleanArray</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">copy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">ExtensionArray</span><span class="s2">.</span><span class="s1">duplicated</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">duplicated</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">keep</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;first&quot;</span><span class="s2">, </span><span class="s5">&quot;last&quot;</span><span class="s2">, </span><span class="s0">False</span><span class="s2">] = </span><span class="s5">&quot;first&quot;</span>
    <span class="s2">) </span><span class="s1">-&gt; npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">]:</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span>
        <span class="s0">return </span><span class="s1">algos</span><span class="s2">.</span><span class="s1">duplicated</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">keep</span><span class="s2">=</span><span class="s1">keep</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">=</span><span class="s1">mask</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">unique</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute the BaseMaskedArray of unique values. 
 
        Returns 
        ------- 
        uniques : BaseMaskedArray 
        &quot;&quot;&quot;</span>
        <span class="s1">uniques</span><span class="s2">, </span><span class="s1">mask </span><span class="s2">= </span><span class="s1">algos</span><span class="s2">.</span><span class="s1">unique_with_mask</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">uniques</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">ExtensionArray</span><span class="s2">.</span><span class="s1">searchsorted</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">searchsorted</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">value</span><span class="s2">: </span><span class="s1">NumpyValueArrayLike </span><span class="s2">| </span><span class="s1">ExtensionArray</span><span class="s2">,</span>
        <span class="s1">side</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;left&quot;</span><span class="s2">, </span><span class="s5">&quot;right&quot;</span><span class="s2">] = </span><span class="s5">&quot;left&quot;</span><span class="s2">,</span>
        <span class="s1">sorter</span><span class="s2">: </span><span class="s1">NumpySorter </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">] | </span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_hasna</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s5">&quot;searchsorted requires array to be sorted, which is impossible &quot;</span>
                <span class="s5">&quot;with NAs present.&quot;</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">ExtensionArray</span><span class="s2">):</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">value</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">object</span><span class="s2">)</span>
        <span class="s4"># Base class searchsorted would cast to object, which is *much* slower.</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">searchsorted</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">side</span><span class="s2">=</span><span class="s1">side</span><span class="s2">, </span><span class="s1">sorter</span><span class="s2">=</span><span class="s1">sorter</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">ExtensionArray</span><span class="s2">.</span><span class="s1">factorize</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">factorize</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">use_na_sentinel</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">ExtensionArray</span><span class="s2">]:</span>
        <span class="s1">arr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span>

        <span class="s4"># Use a sentinel for na; recode and add NA to uniques if necessary below</span>
        <span class="s1">codes</span><span class="s2">, </span><span class="s1">uniques </span><span class="s2">= </span><span class="s1">factorize_array</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">use_na_sentinel</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">=</span><span class="s1">mask</span><span class="s2">)</span>

        <span class="s4"># check that factorize_array correctly preserves dtype.</span>
        <span class="s0">assert </span><span class="s1">uniques</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">numpy_dtype</span><span class="s2">, (</span><span class="s1">uniques</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s1">has_na </span><span class="s2">= </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">any</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">use_na_sentinel </span><span class="s0">or not </span><span class="s1">has_na</span><span class="s2">:</span>
            <span class="s1">size </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">uniques</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># Make room for an NA value</span>
            <span class="s1">size </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">uniques</span><span class="s2">) + </span><span class="s6">1</span>
        <span class="s1">uniques_mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">use_na_sentinel </span><span class="s0">and </span><span class="s1">has_na</span><span class="s2">:</span>
            <span class="s1">na_index </span><span class="s2">= </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">argmax</span><span class="s2">()</span>
            <span class="s4"># Insert na with the proper code</span>
            <span class="s0">if </span><span class="s1">na_index </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s1">na_code </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">na_code </span><span class="s2">= </span><span class="s1">codes</span><span class="s2">[:</span><span class="s1">na_index</span><span class="s2">].</span><span class="s1">max</span><span class="s2">() + </span><span class="s6">1</span>
            <span class="s1">codes</span><span class="s2">[</span><span class="s1">codes </span><span class="s2">&gt;= </span><span class="s1">na_code</span><span class="s2">] += </span><span class="s6">1</span>
            <span class="s1">codes</span><span class="s2">[</span><span class="s1">codes </span><span class="s2">== -</span><span class="s6">1</span><span class="s2">] = </span><span class="s1">na_code</span>
            <span class="s4"># dummy value for uniques; not used since uniques_mask will be True</span>
            <span class="s1">uniques </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s1">uniques</span><span class="s2">, </span><span class="s1">na_code</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>
            <span class="s1">uniques_mask</span><span class="s2">[</span><span class="s1">na_code</span><span class="s2">] = </span><span class="s0">True</span>
        <span class="s1">uniques_ea </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">uniques</span><span class="s2">, </span><span class="s1">uniques_mask</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">codes</span><span class="s2">, </span><span class="s1">uniques_ea</span>

    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">ExtensionArray</span><span class="s2">.</span><span class="s1">_values_for_argsort</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">_values_for_argsort</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span>

    <span class="s0">def </span><span class="s1">value_counts</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dropna</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">) </span><span class="s1">-&gt; Series</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns a Series containing counts of each unique value. 
 
        Parameters 
        ---------- 
        dropna : bool, default True 
            Don't include counts of missing values. 
 
        Returns 
        ------- 
        counts : Series 
 
        See Also 
        -------- 
        Series.value_counts 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s2">(</span>
            <span class="s1">Index</span><span class="s2">,</span>
            <span class="s1">Series</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">arrays </span><span class="s0">import </span><span class="s1">IntegerArray</span>

        <span class="s1">keys</span><span class="s2">, </span><span class="s1">value_counts</span><span class="s2">, </span><span class="s1">na_counter </span><span class="s2">= </span><span class="s1">algos</span><span class="s2">.</span><span class="s1">value_counts_arraylike</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s1">dropna</span><span class="s2">=</span><span class="s1">dropna</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span>
        <span class="s2">)</span>
        <span class="s1">mask_index </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">len</span><span class="s2">(</span><span class="s1">value_counts</span><span class="s2">),), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">)</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">mask_index</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

        <span class="s0">if </span><span class="s1">na_counter </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">mask_index</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] = </span><span class="s0">True</span>

        <span class="s1">arr </span><span class="s2">= </span><span class="s1">IntegerArray</span><span class="s2">(</span><span class="s1">value_counts</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>
        <span class="s1">index </span><span class="s2">= </span><span class="s1">Index</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">construct_array_type</span><span class="s2">()(</span>
                <span class="s1">keys</span><span class="s2">, </span><span class="s1">mask_index  </span><span class="s4"># type: ignore[arg-type]</span>
            <span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">Series</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s1">index</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s5">&quot;count&quot;</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_mode</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dropna</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">dropna</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">mode</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s1">dropna</span><span class="s2">=</span><span class="s1">dropna</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">)</span>
            <span class="s1">res_mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">result</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">result</span><span class="s2">, </span><span class="s1">res_mask </span><span class="s2">= </span><span class="s1">mode</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s1">dropna</span><span class="s2">=</span><span class="s1">dropna</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">res_mask</span><span class="s2">)  </span><span class="s4"># type: ignore[arg-type]</span>
        <span class="s0">return </span><span class="s1">result</span><span class="s2">[</span><span class="s1">result</span><span class="s2">.</span><span class="s1">argsort</span><span class="s2">()]</span>

    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">ExtensionArray</span><span class="s2">.</span><span class="s1">equals</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">equals</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) != </span><span class="s1">type</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s0">return False</span>
        <span class="s0">if </span><span class="s1">other</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">!= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">:</span>
            <span class="s0">return False</span>

        <span class="s4"># GH#44382 if e.g. self[1] is np.nan and other[1] is pd.NA, we are NOT</span>
        <span class="s4">#  equal.</span>
        <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">):</span>
            <span class="s0">return False</span>

        <span class="s1">left </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">[~</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">]</span>
        <span class="s1">right </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">[~</span><span class="s1">other</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">array_equivalent</span><span class="s2">(</span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">strict_nan</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">dtype_equal</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_quantile</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">qs</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">], </span><span class="s1">interpolation</span><span class="s2">: </span><span class="s1">str</span>
    <span class="s2">) </span><span class="s1">-&gt; BaseMaskedArray</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Dispatch to quantile_with_mask, needed because we do not have 
        _from_factorized. 
 
        Notes 
        ----- 
        We assume that all impacted cases are 1D-only. 
        &quot;&quot;&quot;</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">quantile_with_mask</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">,</span>
            <span class="s1">mask</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">,</span>
            <span class="s4"># TODO(GH#40932): na_value_for_dtype(self.dtype.numpy_dtype)</span>
            <span class="s4">#  instead of np.nan</span>
            <span class="s1">fill_value</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">,</span>
            <span class="s1">qs</span><span class="s2">=</span><span class="s1">qs</span><span class="s2">,</span>
            <span class="s1">interpolation</span><span class="s2">=</span><span class="s1">interpolation</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_hasna</span><span class="s2">:</span>
            <span class="s4"># Our result mask is all-False unless we are all-NA, in which</span>
            <span class="s4">#  case it is all-True.</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">2</span><span class="s2">:</span>
                <span class="s4"># I think this should be out_mask=self.isna().all(axis=1)</span>
                <span class="s4">#  but am holding off until we have tests</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">isna</span><span class="s2">().</span><span class="s1">all</span><span class="s2">():</span>
                <span class="s1">out_mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">res</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>

                <span class="s0">if </span><span class="s1">is_integer_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">):</span>
                    <span class="s4"># We try to maintain int dtype if possible for not all-na case</span>
                    <span class="s4"># as well</span>
                    <span class="s1">res </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">res</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">numpy_dtype</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">out_mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">res</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">out_mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">res</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_mask_result</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">=</span><span class="s1">out_mask</span><span class="s2">)</span>

    <span class="s4"># ------------------------------------------------------------------</span>
    <span class="s4"># Reductions</span>

    <span class="s0">def </span><span class="s1">_reduce</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, *, </span><span class="s1">skipna</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">, </span><span class="s1">keepdims</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">, **</span><span class="s1">kwargs</span>
    <span class="s2">):</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s2">{</span><span class="s5">&quot;any&quot;</span><span class="s2">, </span><span class="s5">&quot;all&quot;</span><span class="s2">, </span><span class="s5">&quot;min&quot;</span><span class="s2">, </span><span class="s5">&quot;max&quot;</span><span class="s2">, </span><span class="s5">&quot;sum&quot;</span><span class="s2">, </span><span class="s5">&quot;prod&quot;</span><span class="s2">, </span><span class="s5">&quot;mean&quot;</span><span class="s2">, </span><span class="s5">&quot;var&quot;</span><span class="s2">, </span><span class="s5">&quot;std&quot;</span><span class="s2">}:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)(</span><span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># median, skew, kurt, sem</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span>
            <span class="s1">op </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">nanops</span><span class="s2">, </span><span class="s5">f&quot;nan</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s2">)</span>
            <span class="s1">axis </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s5">&quot;axis&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">op</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">=</span><span class="s1">mask</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">keepdims</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isna</span><span class="s2">(</span><span class="s1">result</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wrap_na_result</span><span class="s2">(</span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">mask_size</span><span class="s2">=(</span><span class="s6">1</span><span class="s2">,))</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s6">1</span><span class="s2">)</span>
                <span class="s1">mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_mask_result</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">isna</span><span class="s2">(</span><span class="s1">result</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">libmissing</span><span class="s2">.</span><span class="s1">NA</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_wrap_reduction_result</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, *, </span><span class="s1">skipna</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">skipna</span><span class="s2">:</span>
                <span class="s4"># we only retain mask for all-NA rows/columns</span>
                <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>

            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_mask_result</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_wrap_na_result</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">mask_size</span><span class="s2">):</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">mask_size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>

        <span class="s1">float_dtyp </span><span class="s2">= </span><span class="s5">&quot;float32&quot; </span><span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s5">&quot;Float32&quot; </span><span class="s0">else </span><span class="s5">&quot;float64&quot;</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s2">[</span><span class="s5">&quot;mean&quot;</span><span class="s2">, </span><span class="s5">&quot;median&quot;</span><span class="s2">, </span><span class="s5">&quot;var&quot;</span><span class="s2">, </span><span class="s5">&quot;std&quot;</span><span class="s2">, </span><span class="s5">&quot;skew&quot;</span><span class="s2">, </span><span class="s5">&quot;kurt&quot;</span><span class="s2">]:</span>
            <span class="s1">np_dtype </span><span class="s2">= </span><span class="s1">float_dtyp</span>
        <span class="s0">elif </span><span class="s1">name </span><span class="s0">in </span><span class="s2">[</span><span class="s5">&quot;min&quot;</span><span class="s2">, </span><span class="s5">&quot;max&quot;</span><span class="s2">] </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">itemsize </span><span class="s2">== </span><span class="s6">8</span><span class="s2">:</span>
            <span class="s1">np_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">numpy_dtype</span><span class="s2">.</span><span class="s1">name</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">is_windows_or_32bit </span><span class="s2">= </span><span class="s1">is_platform_windows</span><span class="s2">() </span><span class="s0">or not </span><span class="s1">IS64</span>
            <span class="s1">int_dtyp </span><span class="s2">= </span><span class="s5">&quot;int32&quot; </span><span class="s0">if </span><span class="s1">is_windows_or_32bit </span><span class="s0">else </span><span class="s5">&quot;int64&quot;</span>
            <span class="s1">uint_dtyp </span><span class="s2">= </span><span class="s5">&quot;uint32&quot; </span><span class="s0">if </span><span class="s1">is_windows_or_32bit </span><span class="s0">else </span><span class="s5">&quot;uint64&quot;</span>
            <span class="s1">np_dtype </span><span class="s2">= {</span><span class="s5">&quot;b&quot;</span><span class="s2">: </span><span class="s1">int_dtyp</span><span class="s2">, </span><span class="s5">&quot;i&quot;</span><span class="s2">: </span><span class="s1">int_dtyp</span><span class="s2">, </span><span class="s5">&quot;u&quot;</span><span class="s2">: </span><span class="s1">uint_dtyp</span><span class="s2">, </span><span class="s5">&quot;f&quot;</span><span class="s2">: </span><span class="s1">float_dtyp</span><span class="s2">}[</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind</span>
            <span class="s2">]</span>

        <span class="s1">value </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s6">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np_dtype</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_mask_result</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">=</span><span class="s1">mask</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_wrap_min_count_reduction_result</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, *, </span><span class="s1">skipna</span><span class="s2">, </span><span class="s1">min_count</span><span class="s2">, </span><span class="s1">axis</span>
    <span class="s2">):</span>
        <span class="s0">if </span><span class="s1">min_count </span><span class="s2">== </span><span class="s6">0 </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_mask_result</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">result</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wrap_reduction_result</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">sum</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">skipna</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">min_count</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_sum</span><span class="s2">((), </span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s1">result </span><span class="s2">= </span><span class="s1">masked_reductions</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">,</span>
            <span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">,</span>
            <span class="s1">min_count</span><span class="s2">=</span><span class="s1">min_count</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wrap_min_count_reduction_result</span><span class="s2">(</span>
            <span class="s5">&quot;sum&quot;</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">, </span><span class="s1">min_count</span><span class="s2">=</span><span class="s1">min_count</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">prod</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">skipna</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">min_count</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_prod</span><span class="s2">((), </span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s1">result </span><span class="s2">= </span><span class="s1">masked_reductions</span><span class="s2">.</span><span class="s1">prod</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">,</span>
            <span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">,</span>
            <span class="s1">min_count</span><span class="s2">=</span><span class="s1">min_count</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wrap_min_count_reduction_result</span><span class="s2">(</span>
            <span class="s5">&quot;prod&quot;</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">, </span><span class="s1">min_count</span><span class="s2">=</span><span class="s1">min_count</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">mean</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *, </span><span class="s1">skipna</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_mean</span><span class="s2">((), </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">masked_reductions</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">,</span>
            <span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wrap_reduction_result</span><span class="s2">(</span><span class="s5">&quot;mean&quot;</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">var</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, *, </span><span class="s1">skipna</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">, </span><span class="s1">ddof</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s6">1</span><span class="s2">, **</span><span class="s1">kwargs</span>
    <span class="s2">):</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_stat_ddof_func</span><span class="s2">((), </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">fname</span><span class="s2">=</span><span class="s5">&quot;var&quot;</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">masked_reductions</span><span class="s2">.</span><span class="s1">var</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">,</span>
            <span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
            <span class="s1">ddof</span><span class="s2">=</span><span class="s1">ddof</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wrap_reduction_result</span><span class="s2">(</span><span class="s5">&quot;var&quot;</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">std</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, *, </span><span class="s1">skipna</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">, </span><span class="s1">ddof</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s6">1</span><span class="s2">, **</span><span class="s1">kwargs</span>
    <span class="s2">):</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_stat_ddof_func</span><span class="s2">((), </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">fname</span><span class="s2">=</span><span class="s5">&quot;std&quot;</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">masked_reductions</span><span class="s2">.</span><span class="s1">std</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">,</span>
            <span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
            <span class="s1">ddof</span><span class="s2">=</span><span class="s1">ddof</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wrap_reduction_result</span><span class="s2">(</span><span class="s5">&quot;std&quot;</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">min</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *, </span><span class="s1">skipna</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_min</span><span class="s2">((), </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">masked_reductions</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">,</span>
            <span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wrap_reduction_result</span><span class="s2">(</span><span class="s5">&quot;min&quot;</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">max</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *, </span><span class="s1">skipna</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_max</span><span class="s2">((), </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">masked_reductions</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">,</span>
            <span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wrap_reduction_result</span><span class="s2">(</span><span class="s5">&quot;max&quot;</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">map</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">mapper</span><span class="s2">, </span><span class="s1">na_action</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">map_array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">to_numpy</span><span class="s2">(), </span><span class="s1">mapper</span><span class="s2">, </span><span class="s1">na_action</span><span class="s2">=</span><span class="s1">na_action</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">any</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *, </span><span class="s1">skipna</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return whether any element is truthy. 
 
        Returns False unless there is at least one element that is truthy. 
        By default, NAs are skipped. If ``skipna=False`` is specified and 
        missing values are present, similar :ref:`Kleene logic &lt;boolean.kleene&gt;` 
        is used as for logical operations. 
 
        .. versionchanged:: 1.4.0 
 
        Parameters 
        ---------- 
        skipna : bool, default True 
            Exclude NA values. If the entire array is NA and `skipna` is 
            True, then the result will be False, as for an empty array. 
            If `skipna` is False, the result will still be True if there is 
            at least one element that is truthy, otherwise NA will be returned 
            if there are NA's present. 
        axis : int, optional, default 0 
        **kwargs : any, default None 
            Additional keywords have no effect but might be accepted for 
            compatibility with NumPy. 
 
        Returns 
        ------- 
        bool or :attr:`pandas.NA` 
 
        See Also 
        -------- 
        numpy.any : Numpy version of this method. 
        BaseMaskedArray.all : Return whether all elements are truthy. 
 
        Examples 
        -------- 
        The result indicates whether any element is truthy (and by default 
        skips NAs): 
 
        &gt;&gt;&gt; pd.array([True, False, True]).any() 
        True 
        &gt;&gt;&gt; pd.array([True, False, pd.NA]).any() 
        True 
        &gt;&gt;&gt; pd.array([False, False, pd.NA]).any() 
        False 
        &gt;&gt;&gt; pd.array([], dtype=&quot;boolean&quot;).any() 
        False 
        &gt;&gt;&gt; pd.array([pd.NA], dtype=&quot;boolean&quot;).any() 
        False 
        &gt;&gt;&gt; pd.array([pd.NA], dtype=&quot;Float64&quot;).any() 
        False 
 
        With ``skipna=False``, the result can be NA if this is logically 
        required (whether ``pd.NA`` is True or False influences the result): 
 
        &gt;&gt;&gt; pd.array([True, False, pd.NA]).any(skipna=False) 
        True 
        &gt;&gt;&gt; pd.array([1, 0, pd.NA]).any(skipna=False) 
        True 
        &gt;&gt;&gt; pd.array([False, False, pd.NA]).any(skipna=False) 
        &lt;NA&gt; 
        &gt;&gt;&gt; pd.array([0, 0, pd.NA]).any(skipna=False) 
        &lt;NA&gt; 
        &quot;&quot;&quot;</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_any</span><span class="s2">((), </span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s4"># error: Argument 3 to &quot;putmask&quot; has incompatible type &quot;object&quot;;</span>
        <span class="s4"># expected &quot;Union[_SupportsArray[dtype[Any]],</span>
        <span class="s4"># _NestedSequence[_SupportsArray[dtype[Any]]],</span>
        <span class="s4"># bool, int, float, complex, str, bytes,</span>
        <span class="s4"># _NestedSequence[Union[bool, int, float, complex, str, bytes]]]&quot;</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">putmask</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_falsey_value</span><span class="s2">)  </span><span class="s4"># type: ignore[arg-type]</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">any</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">skipna</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">result</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">result </span><span class="s0">or </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) == </span><span class="s6">0 </span><span class="s0">or not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
                <span class="s0">return </span><span class="s1">result</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">na_value</span>

    <span class="s0">def </span><span class="s1">all</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *, </span><span class="s1">skipna</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return whether all elements are truthy. 
 
        Returns True unless there is at least one element that is falsey. 
        By default, NAs are skipped. If ``skipna=False`` is specified and 
        missing values are present, similar :ref:`Kleene logic &lt;boolean.kleene&gt;` 
        is used as for logical operations. 
 
        .. versionchanged:: 1.4.0 
 
        Parameters 
        ---------- 
        skipna : bool, default True 
            Exclude NA values. If the entire array is NA and `skipna` is 
            True, then the result will be True, as for an empty array. 
            If `skipna` is False, the result will still be False if there is 
            at least one element that is falsey, otherwise NA will be returned 
            if there are NA's present. 
        axis : int, optional, default 0 
        **kwargs : any, default None 
            Additional keywords have no effect but might be accepted for 
            compatibility with NumPy. 
 
        Returns 
        ------- 
        bool or :attr:`pandas.NA` 
 
        See Also 
        -------- 
        numpy.all : Numpy version of this method. 
        BooleanArray.any : Return whether any element is truthy. 
 
        Examples 
        -------- 
        The result indicates whether all elements are truthy (and by default 
        skips NAs): 
 
        &gt;&gt;&gt; pd.array([True, True, pd.NA]).all() 
        True 
        &gt;&gt;&gt; pd.array([1, 1, pd.NA]).all() 
        True 
        &gt;&gt;&gt; pd.array([True, False, pd.NA]).all() 
        False 
        &gt;&gt;&gt; pd.array([], dtype=&quot;boolean&quot;).all() 
        True 
        &gt;&gt;&gt; pd.array([pd.NA], dtype=&quot;boolean&quot;).all() 
        True 
        &gt;&gt;&gt; pd.array([pd.NA], dtype=&quot;Float64&quot;).all() 
        True 
 
        With ``skipna=False``, the result can be NA if this is logically 
        required (whether ``pd.NA`` is True or False influences the result): 
 
        &gt;&gt;&gt; pd.array([True, True, pd.NA]).all(skipna=False) 
        &lt;NA&gt; 
        &gt;&gt;&gt; pd.array([1, 1, pd.NA]).all(skipna=False) 
        &lt;NA&gt; 
        &gt;&gt;&gt; pd.array([True, False, pd.NA]).all(skipna=False) 
        False 
        &gt;&gt;&gt; pd.array([1, 0, pd.NA]).all(skipna=False) 
        False 
        &quot;&quot;&quot;</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_all</span><span class="s2">((), </span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s4"># error: Argument 3 to &quot;putmask&quot; has incompatible type &quot;object&quot;;</span>
        <span class="s4"># expected &quot;Union[_SupportsArray[dtype[Any]],</span>
        <span class="s4"># _NestedSequence[_SupportsArray[dtype[Any]]],</span>
        <span class="s4"># bool, int, float, complex, str, bytes,</span>
        <span class="s4"># _NestedSequence[Union[bool, int, float, complex, str, bytes]]]&quot;</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">putmask</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_truthy_value</span><span class="s2">)  </span><span class="s4"># type: ignore[arg-type]</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">skipna</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">result</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">result </span><span class="s0">or </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) == </span><span class="s6">0 </span><span class="s0">or not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
                <span class="s0">return </span><span class="s1">result</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">na_value</span>

    <span class="s0">def </span><span class="s1">interpolate</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">method</span><span class="s2">: </span><span class="s1">InterpolateOptions</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">: </span><span class="s1">int</span><span class="s2">,</span>
        <span class="s1">index</span><span class="s2">,</span>
        <span class="s1">limit</span><span class="s2">,</span>
        <span class="s1">limit_direction</span><span class="s2">,</span>
        <span class="s1">limit_area</span><span class="s2">,</span>
        <span class="s1">copy</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; FloatingArray</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        See NDFrame.interpolate.__doc__. 
        &quot;&quot;&quot;</span>
        <span class="s4"># NB: we return type(self) even if copy=False</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;f&quot;</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">copy</span><span class="s2">:</span>
                <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
                <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span>
                <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">in </span><span class="s5">&quot;iu&quot;</span><span class="s2">:</span>
            <span class="s1">copy </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s5">&quot;f8&quot;</span><span class="s2">)</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span>
                <span class="s5">f&quot;interpolate is not implemented for dtype=</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s0">}</span><span class="s5">&quot;</span>
            <span class="s2">)</span>

        <span class="s1">missing</span><span class="s2">.</span><span class="s1">interpolate_2d_inplace</span><span class="s2">(</span>
            <span class="s1">data</span><span class="s2">,</span>
            <span class="s1">method</span><span class="s2">=</span><span class="s1">method</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s6">0</span><span class="s2">,</span>
            <span class="s1">index</span><span class="s2">=</span><span class="s1">index</span><span class="s2">,</span>
            <span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">,</span>
            <span class="s1">limit_direction</span><span class="s2">=</span><span class="s1">limit_direction</span><span class="s2">,</span>
            <span class="s1">limit_area</span><span class="s2">=</span><span class="s1">limit_area</span><span class="s2">,</span>
            <span class="s1">mask</span><span class="s2">=</span><span class="s1">mask</span><span class="s2">,</span>
            <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">copy</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self  </span><span class="s4"># type: ignore[return-value]</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;f&quot;</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)  </span><span class="s4"># type: ignore[return-value]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays </span><span class="s0">import </span><span class="s1">FloatingArray</span>

            <span class="s0">return </span><span class="s1">FloatingArray</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_accumulate</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, *, </span><span class="s1">skipna</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">, **</span><span class="s1">kwargs</span>
    <span class="s2">) </span><span class="s1">-&gt; BaseMaskedArray</span><span class="s2">:</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span>

        <span class="s1">op </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">masked_accumulations</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>
        <span class="s1">data</span><span class="s2">, </span><span class="s1">mask </span><span class="s2">= </span><span class="s1">op</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>

    <span class="s4"># ------------------------------------------------------------------</span>
    <span class="s4"># GroupBy Methods</span>

    <span class="s0">def </span><span class="s1">_groupby_op</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">how</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
        <span class="s1">has_dropped_na</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">,</span>
        <span class="s1">min_count</span><span class="s2">: </span><span class="s1">int</span><span class="s2">,</span>
        <span class="s1">ngroups</span><span class="s2">: </span><span class="s1">int</span><span class="s2">,</span>
        <span class="s1">ids</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">],</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">groupby</span><span class="s2">.</span><span class="s1">ops </span><span class="s0">import </span><span class="s1">WrappedCythonOp</span>

        <span class="s1">kind </span><span class="s2">= </span><span class="s1">WrappedCythonOp</span><span class="s2">.</span><span class="s1">get_kind_from_how</span><span class="s2">(</span><span class="s1">how</span><span class="s2">)</span>
        <span class="s1">op </span><span class="s2">= </span><span class="s1">WrappedCythonOp</span><span class="s2">(</span><span class="s1">how</span><span class="s2">=</span><span class="s1">how</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">=</span><span class="s1">kind</span><span class="s2">, </span><span class="s1">has_dropped_na</span><span class="s2">=</span><span class="s1">has_dropped_na</span><span class="s2">)</span>

        <span class="s4"># libgroupby functions are responsible for NOT altering mask</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mask</span>
        <span class="s0">if </span><span class="s1">op</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">!= </span><span class="s5">&quot;aggregate&quot;</span><span class="s2">:</span>
            <span class="s1">result_mask </span><span class="s2">= </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">result_mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">ngroups</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">how </span><span class="s2">== </span><span class="s5">&quot;rank&quot; </span><span class="s0">and </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s5">&quot;na_option&quot;</span><span class="s2">) </span><span class="s0">in </span><span class="s2">[</span><span class="s5">&quot;top&quot;</span><span class="s2">, </span><span class="s5">&quot;bottom&quot;</span><span class="s2">]:</span>
            <span class="s1">result_mask</span><span class="s2">[:] = </span><span class="s0">False</span>

        <span class="s1">res_values </span><span class="s2">= </span><span class="s1">op</span><span class="s2">.</span><span class="s1">_cython_op_ndim_compat</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">,</span>
            <span class="s1">min_count</span><span class="s2">=</span><span class="s1">min_count</span><span class="s2">,</span>
            <span class="s1">ngroups</span><span class="s2">=</span><span class="s1">ngroups</span><span class="s2">,</span>
            <span class="s1">comp_ids</span><span class="s2">=</span><span class="s1">ids</span><span class="s2">,</span>
            <span class="s1">mask</span><span class="s2">=</span><span class="s1">mask</span><span class="s2">,</span>
            <span class="s1">result_mask</span><span class="s2">=</span><span class="s1">result_mask</span><span class="s2">,</span>
            <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">op</span><span class="s2">.</span><span class="s1">how </span><span class="s2">== </span><span class="s5">&quot;ohlc&quot;</span><span class="s2">:</span>
            <span class="s1">arity </span><span class="s2">= </span><span class="s1">op</span><span class="s2">.</span><span class="s1">_cython_arity</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">op</span><span class="s2">.</span><span class="s1">how</span><span class="s2">, </span><span class="s6">1</span><span class="s2">)</span>
            <span class="s1">result_mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">tile</span><span class="s2">(</span><span class="s1">result_mask</span><span class="s2">, (</span><span class="s1">arity</span><span class="s2">, </span><span class="s6">1</span><span class="s2">)).</span><span class="s1">T</span>

        <span class="s0">if </span><span class="s1">op</span><span class="s2">.</span><span class="s1">how </span><span class="s0">in </span><span class="s2">[</span><span class="s5">&quot;idxmin&quot;</span><span class="s2">, </span><span class="s5">&quot;idxmax&quot;</span><span class="s2">]:</span>
            <span class="s4"># Result values are indexes to take, keep as ndarray</span>
            <span class="s0">return </span><span class="s1">res_values</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># res_values should already have the correct dtype, we just need to</span>
            <span class="s4">#  wrap in a MaskedArray</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_mask_result</span><span class="s2">(</span><span class="s1">res_values</span><span class="s2">, </span><span class="s1">result_mask</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">transpose_homogeneous_masked_arrays</span><span class="s2">(</span>
    <span class="s1">masked_arrays</span><span class="s2">: </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">BaseMaskedArray</span><span class="s2">],</span>
<span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">BaseMaskedArray</span><span class="s2">]:</span>
    <span class="s3">&quot;&quot;&quot;Transpose masked arrays in a list, but faster. 
 
    Input should be a list of 1-dim masked arrays of equal length and all have the 
    same dtype. The caller is responsible for ensuring validity of input data. 
    &quot;&quot;&quot;</span>
    <span class="s1">masked_arrays </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">masked_arrays</span><span class="s2">)</span>
    <span class="s1">dtype </span><span class="s2">= </span><span class="s1">masked_arrays</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">dtype</span>

    <span class="s1">values </span><span class="s2">= [</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s6">1</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">) </span><span class="s0">for </span><span class="s1">arr </span><span class="s0">in </span><span class="s1">masked_arrays</span><span class="s2">]</span>
    <span class="s1">transposed_values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span>
        <span class="s1">values</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">=</span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">out</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span>
            <span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">masked_arrays</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">masked_arrays</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])),</span>
            <span class="s1">order</span><span class="s2">=</span><span class="s5">&quot;F&quot;</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">numpy_dtype</span><span class="s2">,</span>
        <span class="s2">),</span>
    <span class="s2">)</span>

    <span class="s1">masks </span><span class="s2">= [</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">_mask</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s6">1</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">) </span><span class="s0">for </span><span class="s1">arr </span><span class="s0">in </span><span class="s1">masked_arrays</span><span class="s2">]</span>
    <span class="s1">transposed_masks </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span>
        <span class="s1">masks</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">transposed_values</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
    <span class="s2">)</span>

    <span class="s1">arr_type </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">construct_array_type</span><span class="s2">()</span>
    <span class="s1">transposed_arrays</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">BaseMaskedArray</span><span class="s2">] = []</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">transposed_values</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]):</span>
        <span class="s1">transposed_arr </span><span class="s2">= </span><span class="s1">arr_type</span><span class="s2">(</span><span class="s1">transposed_values</span><span class="s2">[:, </span><span class="s1">i</span><span class="s2">], </span><span class="s1">mask</span><span class="s2">=</span><span class="s1">transposed_masks</span><span class="s2">[:, </span><span class="s1">i</span><span class="s2">])</span>
        <span class="s1">transposed_arrays</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">transposed_arr</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">transposed_arrays</span>
</pre>
</body>
</html>