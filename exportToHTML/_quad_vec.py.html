<html>
<head>
<title>_quad_vec.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_quad_vec.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">copy</span>
<span class="s0">import </span><span class="s1">heapq</span>
<span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">_lib</span><span class="s2">.</span><span class="s1">_util </span><span class="s0">import </span><span class="s1">MapWrapper</span><span class="s2">, </span><span class="s1">_FunctionWrapper</span>


<span class="s0">class </span><span class="s1">LRUDict</span><span class="s2">(</span><span class="s1">collections</span><span class="s2">.</span><span class="s1">OrderedDict</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">max_size</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__max_size </span><span class="s2">= </span><span class="s1">max_size</span>

    <span class="s0">def </span><span class="s1">__setitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">):</span>
        <span class="s1">existing_key </span><span class="s2">= (</span><span class="s1">key </span><span class="s0">in </span><span class="s1">self</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__setitem__</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">existing_key</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">move_to_end</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) &gt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__max_size</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">popitem</span><span class="s2">(</span><span class="s1">last</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">update</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s3"># Not needed below</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">()</span>


<span class="s0">class </span><span class="s1">SemiInfiniteFunc</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Argument transform from (start, +-oo) to (0, 1) 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">infty</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_func </span><span class="s2">= </span><span class="s1">func</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_start </span><span class="s2">= </span><span class="s1">start</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_sgn </span><span class="s2">= -</span><span class="s5">1 </span><span class="s0">if </span><span class="s1">infty </span><span class="s2">&lt; </span><span class="s5">0 </span><span class="s0">else </span><span class="s5">1</span>

        <span class="s3"># Overflow threshold for the 1/t**2 factor</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_tmin </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">float_info</span><span class="s2">.</span><span class="s1">min</span><span class="s2">**</span><span class="s5">0.5</span>

    <span class="s0">def </span><span class="s1">get_t</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s1">z </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_sgn </span><span class="s2">* (</span><span class="s1">x </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_start</span><span class="s2">) + </span><span class="s5">1</span>
        <span class="s0">if </span><span class="s1">z </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s3"># Can happen only if point not in range</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>
        <span class="s0">return </span><span class="s5">1 </span><span class="s2">/ </span><span class="s1">z</span>

    <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">t</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">t </span><span class="s2">&lt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_tmin</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s5">0.0</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_start </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_sgn </span><span class="s2">* (</span><span class="s5">1 </span><span class="s2">- </span><span class="s1">t</span><span class="s2">) / </span><span class="s1">t</span>
            <span class="s1">f </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_sgn </span><span class="s2">* (</span><span class="s1">f </span><span class="s2">/ </span><span class="s1">t</span><span class="s2">) / </span><span class="s1">t</span>


<span class="s0">class </span><span class="s1">DoubleInfiniteFunc</span><span class="s2">:</span>
    <span class="s4">&quot;&quot;&quot; 
    Argument transform from (-oo, oo) to (-1, 1) 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_func </span><span class="s2">= </span><span class="s1">func</span>

        <span class="s3"># Overflow threshold for the 1/t**2 factor</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_tmin </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">float_info</span><span class="s2">.</span><span class="s1">min</span><span class="s2">**</span><span class="s5">0.5</span>

    <span class="s0">def </span><span class="s1">get_t</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s1">s </span><span class="s2">= -</span><span class="s5">1 </span><span class="s0">if </span><span class="s1">x </span><span class="s2">&lt; </span><span class="s5">0 </span><span class="s0">else </span><span class="s5">1</span>
        <span class="s0">return </span><span class="s1">s </span><span class="s2">/ (</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) + </span><span class="s5">1</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">t</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">t</span><span class="s2">) &lt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_tmin</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s5">0.0</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">x </span><span class="s2">= (</span><span class="s5">1 </span><span class="s2">- </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">t</span><span class="s2">)) / </span><span class="s1">t</span>
            <span class="s1">f </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s2">(</span><span class="s1">f </span><span class="s2">/ </span><span class="s1">t</span><span class="s2">) / </span><span class="s1">t</span>


<span class="s0">def </span><span class="s1">_max_norm</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">amax</span><span class="s2">(</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">_get_sizeof</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">):</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">getsizeof</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
        <span class="s3"># occurs on pypy</span>
        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s6">'__sizeof__'</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">int</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">__sizeof__</span><span class="s2">())</span>
        <span class="s0">return </span><span class="s5">64</span>


<span class="s0">class </span><span class="s1">_Bunch</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__keys </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s6">&quot;_Bunch({})&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s6">&quot;, &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s6">f&quot;</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s6">=</span><span class="s0">{</span><span class="s1">repr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">[</span><span class="s1">k</span><span class="s2">])</span><span class="s0">}</span><span class="s6">&quot;</span>
                                             <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__keys</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">quad_vec</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">epsabs</span><span class="s2">=</span><span class="s5">1e-200</span><span class="s2">, </span><span class="s1">epsrel</span><span class="s2">=</span><span class="s5">1e-8</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">=</span><span class="s6">'2'</span><span class="s2">, </span><span class="s1">cache_size</span><span class="s2">=</span><span class="s5">100e6</span><span class="s2">,</span>
             <span class="s1">limit</span><span class="s2">=</span><span class="s5">10000</span><span class="s2">, </span><span class="s1">workers</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">points</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">quadrature</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
             <span class="s2">*, </span><span class="s1">args</span><span class="s2">=()):</span>
    <span class="s4">r&quot;&quot;&quot;Adaptive integration of a vector-valued function. 
 
    Parameters 
    ---------- 
    f : callable 
        Vector-valued function f(x) to integrate. 
    a : float 
        Initial point. 
    b : float 
        Final point. 
    epsabs : float, optional 
        Absolute tolerance. 
    epsrel : float, optional 
        Relative tolerance. 
    norm : {'max', '2'}, optional 
        Vector norm to use for error estimation. 
    cache_size : int, optional 
        Number of bytes to use for memoization. 
    limit : float or int, optional 
        An upper bound on the number of subintervals used in the adaptive 
        algorithm. 
    workers : int or map-like callable, optional 
        If `workers` is an integer, part of the computation is done in 
        parallel subdivided to this many tasks (using 
        :class:`python:multiprocessing.pool.Pool`). 
        Supply `-1` to use all cores available to the Process. 
        Alternatively, supply a map-like callable, such as 
        :meth:`python:multiprocessing.pool.Pool.map` for evaluating the 
        population in parallel. 
        This evaluation is carried out as ``workers(func, iterable)``. 
    points : list, optional 
        List of additional breakpoints. 
    quadrature : {'gk21', 'gk15', 'trapezoid'}, optional 
        Quadrature rule to use on subintervals. 
        Options: 'gk21' (Gauss-Kronrod 21-point rule), 
        'gk15' (Gauss-Kronrod 15-point rule), 
        'trapezoid' (composite trapezoid rule). 
        Default: 'gk21' for finite intervals and 'gk15' for (semi-)infinite 
    full_output : bool, optional 
        Return an additional ``info`` dictionary. 
    args : tuple, optional 
        Extra arguments to pass to function, if any. 
 
        .. versionadded:: 1.8.0 
 
    Returns 
    ------- 
    res : {float, array-like} 
        Estimate for the result 
    err : float 
        Error estimate for the result in the given norm 
    info : dict 
        Returned only when ``full_output=True``. 
        Info dictionary. Is an object with the attributes: 
 
            success : bool 
                Whether integration reached target precision. 
            status : int 
                Indicator for convergence, success (0), 
                failure (1), and failure due to rounding error (2). 
            neval : int 
                Number of function evaluations. 
            intervals : ndarray, shape (num_intervals, 2) 
                Start and end points of subdivision intervals. 
            integrals : ndarray, shape (num_intervals, ...) 
                Integral for each interval. 
                Note that at most ``cache_size`` values are recorded, 
                and the array may contains *nan* for missing items. 
            errors : ndarray, shape (num_intervals,) 
                Estimated integration error for each interval. 
 
    Notes 
    ----- 
    The algorithm mainly follows the implementation of QUADPACK's 
    DQAG* algorithms, implementing global error control and adaptive 
    subdivision. 
 
    The algorithm here has some differences to the QUADPACK approach: 
 
    Instead of subdividing one interval at a time, the algorithm 
    subdivides N intervals with largest errors at once. This enables 
    (partial) parallelization of the integration. 
 
    The logic of subdividing &quot;next largest&quot; intervals first is then 
    not implemented, and we rely on the above extension to avoid 
    concentrating on &quot;small&quot; intervals only. 
 
    The Wynn epsilon table extrapolation is not used (QUADPACK uses it 
    for infinite intervals). This is because the algorithm here is 
    supposed to work on vector-valued functions, in an user-specified 
    norm, and the extension of the epsilon algorithm to this case does 
    not appear to be widely agreed. For max-norm, using elementwise 
    Wynn epsilon could be possible, but we do not do this here with 
    the hope that the epsilon extrapolation is mainly useful in 
    special cases. 
 
    References 
    ---------- 
    [1] R. Piessens, E. de Doncker, QUADPACK (1983). 
 
    Examples 
    -------- 
    We can compute integrations of a vector-valued function: 
 
    &gt;&gt;&gt; from scipy.integrate import quad_vec 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; alpha = np.linspace(0.0, 2.0, num=30) 
    &gt;&gt;&gt; f = lambda x: x**alpha 
    &gt;&gt;&gt; x0, x1 = 0, 2 
    &gt;&gt;&gt; y, err = quad_vec(f, x0, x1) 
    &gt;&gt;&gt; plt.plot(alpha, y) 
    &gt;&gt;&gt; plt.xlabel(r&quot;$\alpha$&quot;) 
    &gt;&gt;&gt; plt.ylabel(r&quot;$\int_{0}^{2} x^\alpha dx$&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
    <span class="s1">b </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">args</span><span class="s2">:</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
            <span class="s1">args </span><span class="s2">= (</span><span class="s1">args</span><span class="s2">,)</span>

        <span class="s3"># create a wrapped function to allow the use of map and Pool.map</span>
        <span class="s1">f </span><span class="s2">= </span><span class="s1">_FunctionWrapper</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>

    <span class="s3"># Use simple transformations to deal with integrals over infinite</span>
    <span class="s3"># intervals.</span>
    <span class="s1">kwargs </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">epsabs</span><span class="s2">=</span><span class="s1">epsabs</span><span class="s2">,</span>
                  <span class="s1">epsrel</span><span class="s2">=</span><span class="s1">epsrel</span><span class="s2">,</span>
                  <span class="s1">norm</span><span class="s2">=</span><span class="s1">norm</span><span class="s2">,</span>
                  <span class="s1">cache_size</span><span class="s2">=</span><span class="s1">cache_size</span><span class="s2">,</span>
                  <span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">,</span>
                  <span class="s1">workers</span><span class="s2">=</span><span class="s1">workers</span><span class="s2">,</span>
                  <span class="s1">points</span><span class="s2">=</span><span class="s1">points</span><span class="s2">,</span>
                  <span class="s1">quadrature</span><span class="s2">=</span><span class="s6">'gk15' </span><span class="s0">if </span><span class="s1">quadrature </span><span class="s0">is None else </span><span class="s1">quadrature</span><span class="s2">,</span>
                  <span class="s1">full_output</span><span class="s2">=</span><span class="s1">full_output</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) </span><span class="s0">and </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">b</span><span class="s2">):</span>
        <span class="s1">f2 </span><span class="s2">= </span><span class="s1">SemiInfiniteFunc</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">start</span><span class="s2">=</span><span class="s1">a</span><span class="s2">, </span><span class="s1">infty</span><span class="s2">=</span><span class="s1">b</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">points </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">kwargs</span><span class="s2">[</span><span class="s6">'points'</span><span class="s2">] = </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">f2</span><span class="s2">.</span><span class="s1">get_t</span><span class="s2">(</span><span class="s1">xp</span><span class="s2">) </span><span class="s0">for </span><span class="s1">xp </span><span class="s0">in </span><span class="s1">points</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">quad_vec</span><span class="s2">(</span><span class="s1">f2</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">b</span><span class="s2">) </span><span class="s0">and </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
        <span class="s1">f2 </span><span class="s2">= </span><span class="s1">SemiInfiniteFunc</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">start</span><span class="s2">=</span><span class="s1">b</span><span class="s2">, </span><span class="s1">infty</span><span class="s2">=</span><span class="s1">a</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">points </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">kwargs</span><span class="s2">[</span><span class="s6">'points'</span><span class="s2">] = </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">f2</span><span class="s2">.</span><span class="s1">get_t</span><span class="s2">(</span><span class="s1">xp</span><span class="s2">) </span><span class="s0">for </span><span class="s1">xp </span><span class="s0">in </span><span class="s1">points</span><span class="s2">)</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">quad_vec</span><span class="s2">(</span><span class="s1">f2</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s2">(-</span><span class="s1">res</span><span class="s2">[</span><span class="s5">0</span><span class="s2">],) + </span><span class="s1">res</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]</span>
    <span class="s0">elif </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) </span><span class="s0">and </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">b</span><span class="s2">):</span>
        <span class="s1">sgn </span><span class="s2">= -</span><span class="s5">1 </span><span class="s0">if </span><span class="s1">b </span><span class="s2">&lt; </span><span class="s1">a </span><span class="s0">else </span><span class="s5">1</span>

        <span class="s3"># NB. explicitly split integral at t=0, which separates</span>
        <span class="s3"># the positive and negative sides</span>
        <span class="s1">f2 </span><span class="s2">= </span><span class="s1">DoubleInfiniteFunc</span><span class="s2">(</span><span class="s1">f</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">points </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">kwargs</span><span class="s2">[</span><span class="s6">'points'</span><span class="s2">] = (</span><span class="s5">0</span><span class="s2">,) + </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">f2</span><span class="s2">.</span><span class="s1">get_t</span><span class="s2">(</span><span class="s1">xp</span><span class="s2">) </span><span class="s0">for </span><span class="s1">xp </span><span class="s0">in </span><span class="s1">points</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">kwargs</span><span class="s2">[</span><span class="s6">'points'</span><span class="s2">] = (</span><span class="s5">0</span><span class="s2">,)</span>

        <span class="s0">if </span><span class="s1">a </span><span class="s2">!= </span><span class="s1">b</span><span class="s2">:</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">quad_vec</span><span class="s2">(</span><span class="s1">f2</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">quad_vec</span><span class="s2">(</span><span class="s1">f2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s2">(</span><span class="s1">res</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]*</span><span class="s1">sgn</span><span class="s2">,) + </span><span class="s1">res</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]</span>
    <span class="s0">elif not </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) </span><span class="s0">and </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">f&quot;invalid integration bounds a=</span><span class="s0">{</span><span class="s1">a</span><span class="s0">}</span><span class="s6">, b=</span><span class="s0">{</span><span class="s1">b</span><span class="s0">}</span><span class="s6">&quot;</span><span class="s2">)</span>

    <span class="s1">norm_funcs </span><span class="s2">= {</span>
        <span class="s0">None</span><span class="s2">: </span><span class="s1">_max_norm</span><span class="s2">,</span>
        <span class="s6">'max'</span><span class="s2">: </span><span class="s1">_max_norm</span><span class="s2">,</span>
        <span class="s6">'2'</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span>
    <span class="s2">}</span>
    <span class="s0">if </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">norm</span><span class="s2">):</span>
        <span class="s1">norm_func </span><span class="s2">= </span><span class="s1">norm</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">norm_func </span><span class="s2">= </span><span class="s1">norm_funcs</span><span class="s2">[</span><span class="s1">norm</span><span class="s2">]</span>

    <span class="s1">parallel_count </span><span class="s2">= </span><span class="s5">128</span>
    <span class="s1">min_intervals </span><span class="s2">= </span><span class="s5">2</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">_quadrature </span><span class="s2">= {</span><span class="s0">None</span><span class="s2">: </span><span class="s1">_quadrature_gk21</span><span class="s2">,</span>
                       <span class="s6">'gk21'</span><span class="s2">: </span><span class="s1">_quadrature_gk21</span><span class="s2">,</span>
                       <span class="s6">'gk15'</span><span class="s2">: </span><span class="s1">_quadrature_gk15</span><span class="s2">,</span>
                       <span class="s6">'trapz'</span><span class="s2">: </span><span class="s1">_quadrature_trapezoid</span><span class="s2">,  </span><span class="s3"># alias for backcompat</span>
                       <span class="s6">'trapezoid'</span><span class="s2">: </span><span class="s1">_quadrature_trapezoid</span><span class="s2">}[</span><span class="s1">quadrature</span><span class="s2">]</span>
    <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">f&quot;unknown quadrature </span><span class="s0">{</span><span class="s1">quadrature</span><span class="s0">!r}</span><span class="s6">&quot;</span><span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>

    <span class="s0">if </span><span class="s1">quadrature </span><span class="s2">== </span><span class="s6">&quot;trapz&quot;</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= (</span><span class="s6">&quot;`quadrature='trapz'` is deprecated in favour of &quot;</span>
               <span class="s6">&quot;`quadrature='trapezoid' and will raise an error from SciPy 1.16.0 &quot;</span>
               <span class="s6">&quot;onwards.&quot;</span><span class="s2">)</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">DeprecationWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>

    <span class="s3"># Initial interval set</span>
    <span class="s0">if </span><span class="s1">points </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">initial_intervals </span><span class="s2">= [(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)]</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">prev </span><span class="s2">= </span><span class="s1">a</span>
        <span class="s1">initial_intervals </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">points</span><span class="s2">):</span>
            <span class="s1">p </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>
            <span class="s0">if not </span><span class="s2">(</span><span class="s1">a </span><span class="s2">&lt; </span><span class="s1">p </span><span class="s2">&lt; </span><span class="s1">b</span><span class="s2">) </span><span class="s0">or </span><span class="s1">p </span><span class="s2">== </span><span class="s1">prev</span><span class="s2">:</span>
                <span class="s0">continue</span>
            <span class="s1">initial_intervals</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">prev</span><span class="s2">, </span><span class="s1">p</span><span class="s2">))</span>
            <span class="s1">prev </span><span class="s2">= </span><span class="s1">p</span>
        <span class="s1">initial_intervals</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">prev</span><span class="s2">, </span><span class="s1">b</span><span class="s2">))</span>

    <span class="s1">global_integral </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">global_error </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">rounding_error </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">interval_cache </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">intervals </span><span class="s2">= []</span>
    <span class="s1">neval </span><span class="s2">= </span><span class="s5">0</span>

    <span class="s0">for </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2 </span><span class="s0">in </span><span class="s1">initial_intervals</span><span class="s2">:</span>
        <span class="s1">ig</span><span class="s2">, </span><span class="s1">err</span><span class="s2">, </span><span class="s1">rnd </span><span class="s2">= </span><span class="s1">_quadrature</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">norm_func</span><span class="s2">)</span>
        <span class="s1">neval </span><span class="s2">+= </span><span class="s1">_quadrature</span><span class="s2">.</span><span class="s1">num_eval</span>

        <span class="s0">if </span><span class="s1">global_integral </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ig</span><span class="s2">, (</span><span class="s1">float</span><span class="s2">, </span><span class="s1">complex</span><span class="s2">)):</span>
                <span class="s3"># Specialize for scalars</span>
                <span class="s0">if </span><span class="s1">norm_func </span><span class="s0">in </span><span class="s2">(</span><span class="s1">_max_norm</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">):</span>
                    <span class="s1">norm_func </span><span class="s2">= </span><span class="s1">abs</span>

            <span class="s1">global_integral </span><span class="s2">= </span><span class="s1">ig</span>
            <span class="s1">global_error </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s1">err</span><span class="s2">)</span>
            <span class="s1">rounding_error </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s1">rnd</span><span class="s2">)</span>

            <span class="s1">cache_count </span><span class="s2">= </span><span class="s1">cache_size </span><span class="s2">// </span><span class="s1">_get_sizeof</span><span class="s2">(</span><span class="s1">ig</span><span class="s2">)</span>
            <span class="s1">interval_cache </span><span class="s2">= </span><span class="s1">LRUDict</span><span class="s2">(</span><span class="s1">cache_count</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">global_integral </span><span class="s2">+= </span><span class="s1">ig</span>
            <span class="s1">global_error </span><span class="s2">+= </span><span class="s1">err</span>
            <span class="s1">rounding_error </span><span class="s2">+= </span><span class="s1">rnd</span>

        <span class="s1">interval_cache</span><span class="s2">[(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">)] = </span><span class="s1">copy</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">ig</span><span class="s2">)</span>
        <span class="s1">intervals</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((-</span><span class="s1">err</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">))</span>

    <span class="s1">heapq</span><span class="s2">.</span><span class="s1">heapify</span><span class="s2">(</span><span class="s1">intervals</span><span class="s2">)</span>

    <span class="s1">CONVERGED </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">NOT_CONVERGED </span><span class="s2">= </span><span class="s5">1</span>
    <span class="s1">ROUNDING_ERROR </span><span class="s2">= </span><span class="s5">2</span>
    <span class="s1">NOT_A_NUMBER </span><span class="s2">= </span><span class="s5">3</span>

    <span class="s1">status_msg </span><span class="s2">= {</span>
        <span class="s1">CONVERGED</span><span class="s2">: </span><span class="s6">&quot;Target precision reached.&quot;</span><span class="s2">,</span>
        <span class="s1">NOT_CONVERGED</span><span class="s2">: </span><span class="s6">&quot;Target precision not reached.&quot;</span><span class="s2">,</span>
        <span class="s1">ROUNDING_ERROR</span><span class="s2">: </span><span class="s6">&quot;Target precision could not be reached due to rounding error.&quot;</span><span class="s2">,</span>
        <span class="s1">NOT_A_NUMBER</span><span class="s2">: </span><span class="s6">&quot;Non-finite values encountered.&quot;</span>
    <span class="s2">}</span>

    <span class="s3"># Process intervals</span>
    <span class="s0">with </span><span class="s1">MapWrapper</span><span class="s2">(</span><span class="s1">workers</span><span class="s2">) </span><span class="s0">as </span><span class="s1">mapwrapper</span><span class="s2">:</span>
        <span class="s1">ier </span><span class="s2">= </span><span class="s1">NOT_CONVERGED</span>

        <span class="s0">while </span><span class="s1">intervals </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">intervals</span><span class="s2">) &lt; </span><span class="s1">limit</span><span class="s2">:</span>
            <span class="s3"># Select intervals with largest errors for subdivision</span>
            <span class="s1">tol </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">epsabs</span><span class="s2">, </span><span class="s1">epsrel</span><span class="s2">*</span><span class="s1">norm_func</span><span class="s2">(</span><span class="s1">global_integral</span><span class="s2">))</span>

            <span class="s1">to_process </span><span class="s2">= []</span>
            <span class="s1">err_sum </span><span class="s2">= </span><span class="s5">0</span>

            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">parallel_count</span><span class="s2">):</span>
                <span class="s0">if not </span><span class="s1">intervals</span><span class="s2">:</span>
                    <span class="s0">break</span>

                <span class="s0">if </span><span class="s1">j </span><span class="s2">&gt; </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">err_sum </span><span class="s2">&gt; </span><span class="s1">global_error </span><span class="s2">- </span><span class="s1">tol</span><span class="s2">/</span><span class="s5">8</span><span class="s2">:</span>
                    <span class="s3"># avoid unnecessary parallel splitting</span>
                    <span class="s0">break</span>

                <span class="s1">interval </span><span class="s2">= </span><span class="s1">heapq</span><span class="s2">.</span><span class="s1">heappop</span><span class="s2">(</span><span class="s1">intervals</span><span class="s2">)</span>

                <span class="s1">neg_old_err</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">= </span><span class="s1">interval</span>
                <span class="s1">old_int </span><span class="s2">= </span><span class="s1">interval_cache</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">((</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">), </span><span class="s0">None</span><span class="s2">)</span>
                <span class="s1">to_process</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span>
                    <span class="s2">((-</span><span class="s1">neg_old_err</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">old_int</span><span class="s2">), </span><span class="s1">f</span><span class="s2">, </span><span class="s1">norm_func</span><span class="s2">, </span><span class="s1">_quadrature</span><span class="s2">)</span>
                <span class="s2">)</span>
                <span class="s1">err_sum </span><span class="s2">+= -</span><span class="s1">neg_old_err</span>

            <span class="s3"># Subdivide intervals</span>
            <span class="s0">for </span><span class="s1">parts </span><span class="s0">in </span><span class="s1">mapwrapper</span><span class="s2">(</span><span class="s1">_subdivide_interval</span><span class="s2">, </span><span class="s1">to_process</span><span class="s2">):</span>
                <span class="s1">dint</span><span class="s2">, </span><span class="s1">derr</span><span class="s2">, </span><span class="s1">dround_err</span><span class="s2">, </span><span class="s1">subint</span><span class="s2">, </span><span class="s1">dneval </span><span class="s2">= </span><span class="s1">parts</span>
                <span class="s1">neval </span><span class="s2">+= </span><span class="s1">dneval</span>
                <span class="s1">global_integral </span><span class="s2">+= </span><span class="s1">dint</span>
                <span class="s1">global_error </span><span class="s2">+= </span><span class="s1">derr</span>
                <span class="s1">rounding_error </span><span class="s2">+= </span><span class="s1">dround_err</span>
                <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">subint</span><span class="s2">:</span>
                    <span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">ig</span><span class="s2">, </span><span class="s1">err </span><span class="s2">= </span><span class="s1">x</span>
                    <span class="s1">interval_cache</span><span class="s2">[(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">)] = </span><span class="s1">ig</span>
                    <span class="s1">heapq</span><span class="s2">.</span><span class="s1">heappush</span><span class="s2">(</span><span class="s1">intervals</span><span class="s2">, (-</span><span class="s1">err</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">))</span>

            <span class="s3"># Termination check</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">intervals</span><span class="s2">) &gt;= </span><span class="s1">min_intervals</span><span class="s2">:</span>
                <span class="s1">tol </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">epsabs</span><span class="s2">, </span><span class="s1">epsrel</span><span class="s2">*</span><span class="s1">norm_func</span><span class="s2">(</span><span class="s1">global_integral</span><span class="s2">))</span>
                <span class="s0">if </span><span class="s1">global_error </span><span class="s2">&lt; </span><span class="s1">tol</span><span class="s2">/</span><span class="s5">8</span><span class="s2">:</span>
                    <span class="s1">ier </span><span class="s2">= </span><span class="s1">CONVERGED</span>
                    <span class="s0">break</span>
                <span class="s0">if </span><span class="s1">global_error </span><span class="s2">&lt; </span><span class="s1">rounding_error</span><span class="s2">:</span>
                    <span class="s1">ier </span><span class="s2">= </span><span class="s1">ROUNDING_ERROR</span>
                    <span class="s0">break</span>

            <span class="s0">if not </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">global_error</span><span class="s2">) </span><span class="s0">and </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">rounding_error</span><span class="s2">)):</span>
                <span class="s1">ier </span><span class="s2">= </span><span class="s1">NOT_A_NUMBER</span>
                <span class="s0">break</span>

    <span class="s1">res </span><span class="s2">= </span><span class="s1">global_integral</span>
    <span class="s1">err </span><span class="s2">= </span><span class="s1">global_error </span><span class="s2">+ </span><span class="s1">rounding_error</span>

    <span class="s0">if </span><span class="s1">full_output</span><span class="s2">:</span>
        <span class="s1">res_arr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">res</span><span class="s2">)</span>
        <span class="s1">dummy </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full</span><span class="s2">(</span><span class="s1">res_arr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">res_arr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">integrals </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">interval_cache</span><span class="s2">.</span><span class="s1">get</span><span class="s2">((</span><span class="s1">z</span><span class="s2">[</span><span class="s5">1</span><span class="s2">], </span><span class="s1">z</span><span class="s2">[</span><span class="s5">2</span><span class="s2">]), </span><span class="s1">dummy</span><span class="s2">)</span>
                                      <span class="s0">for </span><span class="s1">z </span><span class="s0">in </span><span class="s1">intervals</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">res_arr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">errors </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([-</span><span class="s1">z</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] </span><span class="s0">for </span><span class="s1">z </span><span class="s0">in </span><span class="s1">intervals</span><span class="s2">])</span>
        <span class="s1">intervals </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s1">z</span><span class="s2">[</span><span class="s5">1</span><span class="s2">], </span><span class="s1">z</span><span class="s2">[</span><span class="s5">2</span><span class="s2">]] </span><span class="s0">for </span><span class="s1">z </span><span class="s0">in </span><span class="s1">intervals</span><span class="s2">])</span>

        <span class="s1">info </span><span class="s2">= </span><span class="s1">_Bunch</span><span class="s2">(</span><span class="s1">neval</span><span class="s2">=</span><span class="s1">neval</span><span class="s2">,</span>
                      <span class="s1">success</span><span class="s2">=(</span><span class="s1">ier </span><span class="s2">== </span><span class="s1">CONVERGED</span><span class="s2">),</span>
                      <span class="s1">status</span><span class="s2">=</span><span class="s1">ier</span><span class="s2">,</span>
                      <span class="s1">message</span><span class="s2">=</span><span class="s1">status_msg</span><span class="s2">[</span><span class="s1">ier</span><span class="s2">],</span>
                      <span class="s1">intervals</span><span class="s2">=</span><span class="s1">intervals</span><span class="s2">,</span>
                      <span class="s1">integrals</span><span class="s2">=</span><span class="s1">integrals</span><span class="s2">,</span>
                      <span class="s1">errors</span><span class="s2">=</span><span class="s1">errors</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s1">err</span><span class="s2">, </span><span class="s1">info</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s1">err</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_subdivide_interval</span><span class="s2">(</span><span class="s1">args</span><span class="s2">):</span>
    <span class="s1">interval</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">norm_func</span><span class="s2">, </span><span class="s1">_quadrature </span><span class="s2">= </span><span class="s1">args</span>
    <span class="s1">old_err</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">old_int </span><span class="s2">= </span><span class="s1">interval</span>

    <span class="s1">c </span><span class="s2">= </span><span class="s5">0.5 </span><span class="s2">* (</span><span class="s1">a </span><span class="s2">+ </span><span class="s1">b</span><span class="s2">)</span>

    <span class="s3"># Left-hand side</span>
    <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">_quadrature</span><span class="s2">, </span><span class="s6">'cache_size'</span><span class="s2">, </span><span class="s5">0</span><span class="s2">) &gt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">f </span><span class="s2">= </span><span class="s1">functools</span><span class="s2">.</span><span class="s1">lru_cache</span><span class="s2">(</span><span class="s1">_quadrature</span><span class="s2">.</span><span class="s1">cache_size</span><span class="s2">)(</span><span class="s1">f</span><span class="s2">)</span>

    <span class="s1">s1</span><span class="s2">, </span><span class="s1">err1</span><span class="s2">, </span><span class="s1">round1 </span><span class="s2">= </span><span class="s1">_quadrature</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">norm_func</span><span class="s2">)</span>
    <span class="s1">dneval </span><span class="s2">= </span><span class="s1">_quadrature</span><span class="s2">.</span><span class="s1">num_eval</span>
    <span class="s1">s2</span><span class="s2">, </span><span class="s1">err2</span><span class="s2">, </span><span class="s1">round2 </span><span class="s2">= </span><span class="s1">_quadrature</span><span class="s2">(</span><span class="s1">c</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">norm_func</span><span class="s2">)</span>
    <span class="s1">dneval </span><span class="s2">+= </span><span class="s1">_quadrature</span><span class="s2">.</span><span class="s1">num_eval</span>
    <span class="s0">if </span><span class="s1">old_int </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">old_int</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_quadrature</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">norm_func</span><span class="s2">)</span>
        <span class="s1">dneval </span><span class="s2">+= </span><span class="s1">_quadrature</span><span class="s2">.</span><span class="s1">num_eval</span>

    <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">_quadrature</span><span class="s2">, </span><span class="s6">'cache_size'</span><span class="s2">, </span><span class="s5">0</span><span class="s2">) &gt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">dneval </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">cache_info</span><span class="s2">().</span><span class="s1">misses</span>

    <span class="s1">dint </span><span class="s2">= </span><span class="s1">s1 </span><span class="s2">+ </span><span class="s1">s2 </span><span class="s2">- </span><span class="s1">old_int</span>
    <span class="s1">derr </span><span class="s2">= </span><span class="s1">err1 </span><span class="s2">+ </span><span class="s1">err2 </span><span class="s2">- </span><span class="s1">old_err</span>
    <span class="s1">dround_err </span><span class="s2">= </span><span class="s1">round1 </span><span class="s2">+ </span><span class="s1">round2</span>

    <span class="s1">subintervals </span><span class="s2">= ((</span><span class="s1">a</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s1</span><span class="s2">, </span><span class="s1">err1</span><span class="s2">), (</span><span class="s1">c</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">s2</span><span class="s2">, </span><span class="s1">err2</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s1">dint</span><span class="s2">, </span><span class="s1">derr</span><span class="s2">, </span><span class="s1">dround_err</span><span class="s2">, </span><span class="s1">subintervals</span><span class="s2">, </span><span class="s1">dneval</span>


<span class="s0">def </span><span class="s1">_quadrature_trapezoid</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">norm_func</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Composite trapezoid quadrature 
    &quot;&quot;&quot;</span>
    <span class="s1">x3 </span><span class="s2">= </span><span class="s5">0.5</span><span class="s2">*(</span><span class="s1">x1 </span><span class="s2">+ </span><span class="s1">x2</span><span class="s2">)</span>
    <span class="s1">f1 </span><span class="s2">= </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">)</span>
    <span class="s1">f2 </span><span class="s2">= </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">)</span>
    <span class="s1">f3 </span><span class="s2">= </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x3</span><span class="s2">)</span>

    <span class="s1">s2 </span><span class="s2">= </span><span class="s5">0.25 </span><span class="s2">* (</span><span class="s1">x2 </span><span class="s2">- </span><span class="s1">x1</span><span class="s2">) * (</span><span class="s1">f1 </span><span class="s2">+ </span><span class="s5">2</span><span class="s2">*</span><span class="s1">f3 </span><span class="s2">+ </span><span class="s1">f2</span><span class="s2">)</span>

    <span class="s1">round_err </span><span class="s2">= </span><span class="s5">0.25 </span><span class="s2">* </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">x2 </span><span class="s2">- </span><span class="s1">x1</span><span class="s2">) * (</span><span class="s1">float</span><span class="s2">(</span><span class="s1">norm_func</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">))</span>
                                       <span class="s2">+ </span><span class="s5">2</span><span class="s2">*</span><span class="s1">float</span><span class="s2">(</span><span class="s1">norm_func</span><span class="s2">(</span><span class="s1">f3</span><span class="s2">))</span>
                                       <span class="s2">+ </span><span class="s1">float</span><span class="s2">(</span><span class="s1">norm_func</span><span class="s2">(</span><span class="s1">f2</span><span class="s2">))) * </span><span class="s5">2e-16</span>

    <span class="s1">s1 </span><span class="s2">= </span><span class="s5">0.5 </span><span class="s2">* (</span><span class="s1">x2 </span><span class="s2">- </span><span class="s1">x1</span><span class="s2">) * (</span><span class="s1">f1 </span><span class="s2">+ </span><span class="s1">f2</span><span class="s2">)</span>
    <span class="s1">err </span><span class="s2">= </span><span class="s5">1</span><span class="s2">/</span><span class="s5">3 </span><span class="s2">* </span><span class="s1">float</span><span class="s2">(</span><span class="s1">norm_func</span><span class="s2">(</span><span class="s1">s1 </span><span class="s2">- </span><span class="s1">s2</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s1">s2</span><span class="s2">, </span><span class="s1">err</span><span class="s2">, </span><span class="s1">round_err</span>


<span class="s1">_quadrature_trapezoid</span><span class="s2">.</span><span class="s1">cache_size </span><span class="s2">= </span><span class="s5">3 </span><span class="s2">* </span><span class="s5">3</span>
<span class="s1">_quadrature_trapezoid</span><span class="s2">.</span><span class="s1">num_eval </span><span class="s2">= </span><span class="s5">3</span>


<span class="s0">def </span><span class="s1">_quadrature_gk</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">norm_func</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">v</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Generic Gauss-Kronrod quadrature 
    &quot;&quot;&quot;</span>

    <span class="s1">fv </span><span class="s2">= [</span><span class="s5">0.0</span><span class="s2">]*</span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s1">c </span><span class="s2">= </span><span class="s5">0.5 </span><span class="s2">* (</span><span class="s1">a </span><span class="s2">+ </span><span class="s1">b</span><span class="s2">)</span>
    <span class="s1">h </span><span class="s2">= </span><span class="s5">0.5 </span><span class="s2">* (</span><span class="s1">b </span><span class="s2">- </span><span class="s1">a</span><span class="s2">)</span>

    <span class="s3"># Gauss-Kronrod</span>
    <span class="s1">s_k </span><span class="s2">= </span><span class="s5">0.0</span>
    <span class="s1">s_k_abs </span><span class="s2">= </span><span class="s5">0.0</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)):</span>
        <span class="s1">ff </span><span class="s2">= </span><span class="s1">f</span><span class="s2">(</span><span class="s1">c </span><span class="s2">+ </span><span class="s1">h</span><span class="s2">*</span><span class="s1">x</span><span class="s2">[</span><span class="s1">i</span><span class="s2">])</span>
        <span class="s1">fv</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">ff</span>

        <span class="s1">vv </span><span class="s2">= </span><span class="s1">v</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>

        <span class="s3"># \int f(x)</span>
        <span class="s1">s_k </span><span class="s2">+= </span><span class="s1">vv </span><span class="s2">* </span><span class="s1">ff</span>
        <span class="s3"># \int |f(x)|</span>
        <span class="s1">s_k_abs </span><span class="s2">+= </span><span class="s1">vv </span><span class="s2">* </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">ff</span><span class="s2">)</span>

    <span class="s3"># Gauss</span>
    <span class="s1">s_g </span><span class="s2">= </span><span class="s5">0.0</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">w</span><span class="s2">)):</span>
        <span class="s1">s_g </span><span class="s2">+= </span><span class="s1">w</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] * </span><span class="s1">fv</span><span class="s2">[</span><span class="s5">2</span><span class="s2">*</span><span class="s1">i </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">]</span>

    <span class="s3"># Quadrature of abs-deviation from average</span>
    <span class="s1">s_k_dabs </span><span class="s2">= </span><span class="s5">0.0</span>
    <span class="s1">y0 </span><span class="s2">= </span><span class="s1">s_k </span><span class="s2">/ </span><span class="s5">2.0</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)):</span>
        <span class="s3"># \int |f(x) - y0|</span>
        <span class="s1">s_k_dabs </span><span class="s2">+= </span><span class="s1">v</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] * </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">fv</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] - </span><span class="s1">y0</span><span class="s2">)</span>

    <span class="s3"># Use similar error estimation as quadpack</span>
    <span class="s1">err </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s1">norm_func</span><span class="s2">((</span><span class="s1">s_k </span><span class="s2">- </span><span class="s1">s_g</span><span class="s2">) * </span><span class="s1">h</span><span class="s2">))</span>
    <span class="s1">dabs </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s1">norm_func</span><span class="s2">(</span><span class="s1">s_k_dabs </span><span class="s2">* </span><span class="s1">h</span><span class="s2">))</span>
    <span class="s0">if </span><span class="s1">dabs </span><span class="s2">!= </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">err </span><span class="s2">!= </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">err </span><span class="s2">= </span><span class="s1">dabs </span><span class="s2">* </span><span class="s1">min</span><span class="s2">(</span><span class="s5">1.0</span><span class="s2">, (</span><span class="s5">200 </span><span class="s2">* </span><span class="s1">err </span><span class="s2">/ </span><span class="s1">dabs</span><span class="s2">)**</span><span class="s5">1.5</span><span class="s2">)</span>

    <span class="s1">eps </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">float_info</span><span class="s2">.</span><span class="s1">epsilon</span>
    <span class="s1">round_err </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s1">norm_func</span><span class="s2">(</span><span class="s5">50 </span><span class="s2">* </span><span class="s1">eps </span><span class="s2">* </span><span class="s1">h </span><span class="s2">* </span><span class="s1">s_k_abs</span><span class="s2">))</span>

    <span class="s0">if </span><span class="s1">round_err </span><span class="s2">&gt; </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">float_info</span><span class="s2">.</span><span class="s1">min</span><span class="s2">:</span>
        <span class="s1">err </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">err</span><span class="s2">, </span><span class="s1">round_err</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">h </span><span class="s2">* </span><span class="s1">s_k</span><span class="s2">, </span><span class="s1">err</span><span class="s2">, </span><span class="s1">round_err</span>


<span class="s0">def </span><span class="s1">_quadrature_gk21</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">norm_func</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Gauss-Kronrod 21 quadrature with error estimate 
    &quot;&quot;&quot;</span>
    <span class="s3"># Gauss-Kronrod points</span>
    <span class="s1">x </span><span class="s2">= (</span><span class="s5">0.995657163025808080735527280689003</span><span class="s2">,</span>
         <span class="s5">0.973906528517171720077964012084452</span><span class="s2">,</span>
         <span class="s5">0.930157491355708226001207180059508</span><span class="s2">,</span>
         <span class="s5">0.865063366688984510732096688423493</span><span class="s2">,</span>
         <span class="s5">0.780817726586416897063717578345042</span><span class="s2">,</span>
         <span class="s5">0.679409568299024406234327365114874</span><span class="s2">,</span>
         <span class="s5">0.562757134668604683339000099272694</span><span class="s2">,</span>
         <span class="s5">0.433395394129247190799265943165784</span><span class="s2">,</span>
         <span class="s5">0.294392862701460198131126603103866</span><span class="s2">,</span>
         <span class="s5">0.148874338981631210884826001129720</span><span class="s2">,</span>
         <span class="s5">0</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s5">0.148874338981631210884826001129720</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s5">0.294392862701460198131126603103866</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s5">0.433395394129247190799265943165784</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s5">0.562757134668604683339000099272694</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s5">0.679409568299024406234327365114874</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s5">0.780817726586416897063717578345042</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s5">0.865063366688984510732096688423493</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s5">0.930157491355708226001207180059508</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s5">0.973906528517171720077964012084452</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s5">0.995657163025808080735527280689003</span><span class="s2">)</span>

    <span class="s3"># 10-point weights</span>
    <span class="s1">w </span><span class="s2">= (</span><span class="s5">0.066671344308688137593568809893332</span><span class="s2">,</span>
         <span class="s5">0.149451349150580593145776339657697</span><span class="s2">,</span>
         <span class="s5">0.219086362515982043995534934228163</span><span class="s2">,</span>
         <span class="s5">0.269266719309996355091226921569469</span><span class="s2">,</span>
         <span class="s5">0.295524224714752870173892994651338</span><span class="s2">,</span>
         <span class="s5">0.295524224714752870173892994651338</span><span class="s2">,</span>
         <span class="s5">0.269266719309996355091226921569469</span><span class="s2">,</span>
         <span class="s5">0.219086362515982043995534934228163</span><span class="s2">,</span>
         <span class="s5">0.149451349150580593145776339657697</span><span class="s2">,</span>
         <span class="s5">0.066671344308688137593568809893332</span><span class="s2">)</span>

    <span class="s3"># 21-point weights</span>
    <span class="s1">v </span><span class="s2">= (</span><span class="s5">0.011694638867371874278064396062192</span><span class="s2">,</span>
         <span class="s5">0.032558162307964727478818972459390</span><span class="s2">,</span>
         <span class="s5">0.054755896574351996031381300244580</span><span class="s2">,</span>
         <span class="s5">0.075039674810919952767043140916190</span><span class="s2">,</span>
         <span class="s5">0.093125454583697605535065465083366</span><span class="s2">,</span>
         <span class="s5">0.109387158802297641899210590325805</span><span class="s2">,</span>
         <span class="s5">0.123491976262065851077958109831074</span><span class="s2">,</span>
         <span class="s5">0.134709217311473325928054001771707</span><span class="s2">,</span>
         <span class="s5">0.142775938577060080797094273138717</span><span class="s2">,</span>
         <span class="s5">0.147739104901338491374841515972068</span><span class="s2">,</span>
         <span class="s5">0.149445554002916905664936468389821</span><span class="s2">,</span>
         <span class="s5">0.147739104901338491374841515972068</span><span class="s2">,</span>
         <span class="s5">0.142775938577060080797094273138717</span><span class="s2">,</span>
         <span class="s5">0.134709217311473325928054001771707</span><span class="s2">,</span>
         <span class="s5">0.123491976262065851077958109831074</span><span class="s2">,</span>
         <span class="s5">0.109387158802297641899210590325805</span><span class="s2">,</span>
         <span class="s5">0.093125454583697605535065465083366</span><span class="s2">,</span>
         <span class="s5">0.075039674810919952767043140916190</span><span class="s2">,</span>
         <span class="s5">0.054755896574351996031381300244580</span><span class="s2">,</span>
         <span class="s5">0.032558162307964727478818972459390</span><span class="s2">,</span>
         <span class="s5">0.011694638867371874278064396062192</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">_quadrature_gk</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">norm_func</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">v</span><span class="s2">)</span>


<span class="s1">_quadrature_gk21</span><span class="s2">.</span><span class="s1">num_eval </span><span class="s2">= </span><span class="s5">21</span>


<span class="s0">def </span><span class="s1">_quadrature_gk15</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">norm_func</span><span class="s2">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Gauss-Kronrod 15 quadrature with error estimate 
    &quot;&quot;&quot;</span>
    <span class="s3"># Gauss-Kronrod points</span>
    <span class="s1">x </span><span class="s2">= (</span><span class="s5">0.991455371120812639206854697526329</span><span class="s2">,</span>
         <span class="s5">0.949107912342758524526189684047851</span><span class="s2">,</span>
         <span class="s5">0.864864423359769072789712788640926</span><span class="s2">,</span>
         <span class="s5">0.741531185599394439863864773280788</span><span class="s2">,</span>
         <span class="s5">0.586087235467691130294144838258730</span><span class="s2">,</span>
         <span class="s5">0.405845151377397166906606412076961</span><span class="s2">,</span>
         <span class="s5">0.207784955007898467600689403773245</span><span class="s2">,</span>
         <span class="s5">0.000000000000000000000000000000000</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s5">0.207784955007898467600689403773245</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s5">0.405845151377397166906606412076961</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s5">0.586087235467691130294144838258730</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s5">0.741531185599394439863864773280788</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s5">0.864864423359769072789712788640926</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s5">0.949107912342758524526189684047851</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s5">0.991455371120812639206854697526329</span><span class="s2">)</span>

    <span class="s3"># 7-point weights</span>
    <span class="s1">w </span><span class="s2">= (</span><span class="s5">0.129484966168869693270611432679082</span><span class="s2">,</span>
         <span class="s5">0.279705391489276667901467771423780</span><span class="s2">,</span>
         <span class="s5">0.381830050505118944950369775488975</span><span class="s2">,</span>
         <span class="s5">0.417959183673469387755102040816327</span><span class="s2">,</span>
         <span class="s5">0.381830050505118944950369775488975</span><span class="s2">,</span>
         <span class="s5">0.279705391489276667901467771423780</span><span class="s2">,</span>
         <span class="s5">0.129484966168869693270611432679082</span><span class="s2">)</span>

    <span class="s3"># 15-point weights</span>
    <span class="s1">v </span><span class="s2">= (</span><span class="s5">0.022935322010529224963732008058970</span><span class="s2">,</span>
         <span class="s5">0.063092092629978553290700663189204</span><span class="s2">,</span>
         <span class="s5">0.104790010322250183839876322541518</span><span class="s2">,</span>
         <span class="s5">0.140653259715525918745189590510238</span><span class="s2">,</span>
         <span class="s5">0.169004726639267902826583426598550</span><span class="s2">,</span>
         <span class="s5">0.190350578064785409913256402421014</span><span class="s2">,</span>
         <span class="s5">0.204432940075298892414161999234649</span><span class="s2">,</span>
         <span class="s5">0.209482141084727828012999174891714</span><span class="s2">,</span>
         <span class="s5">0.204432940075298892414161999234649</span><span class="s2">,</span>
         <span class="s5">0.190350578064785409913256402421014</span><span class="s2">,</span>
         <span class="s5">0.169004726639267902826583426598550</span><span class="s2">,</span>
         <span class="s5">0.140653259715525918745189590510238</span><span class="s2">,</span>
         <span class="s5">0.104790010322250183839876322541518</span><span class="s2">,</span>
         <span class="s5">0.063092092629978553290700663189204</span><span class="s2">,</span>
         <span class="s5">0.022935322010529224963732008058970</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">_quadrature_gk</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">norm_func</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">v</span><span class="s2">)</span>


<span class="s1">_quadrature_gk15</span><span class="s2">.</span><span class="s1">num_eval </span><span class="s2">= </span><span class="s5">15</span>
</pre>
</body>
</html>