<html>
<head>
<title>_mstats_basic.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #cf8e6d;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_mstats_basic.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
An extension of scipy.stats._stats_py to support masked arrays 
 
&quot;&quot;&quot;</span>
<span class="s2"># Original author (2007): Pierre GF Gerard-Marchant</span>


<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">'argstoarray'</span><span class="s3">,</span>
           <span class="s4">'count_tied_groups'</span><span class="s3">,</span>
           <span class="s4">'describe'</span><span class="s3">,</span>
           <span class="s4">'f_oneway'</span><span class="s3">, </span><span class="s4">'find_repeats'</span><span class="s3">,</span><span class="s4">'friedmanchisquare'</span><span class="s3">,</span>
           <span class="s4">'kendalltau'</span><span class="s3">,</span><span class="s4">'kendalltau_seasonal'</span><span class="s3">,</span><span class="s4">'kruskal'</span><span class="s3">,</span><span class="s4">'kruskalwallis'</span><span class="s3">,</span>
           <span class="s4">'ks_twosamp'</span><span class="s3">, </span><span class="s4">'ks_2samp'</span><span class="s3">, </span><span class="s4">'kurtosis'</span><span class="s3">, </span><span class="s4">'kurtosistest'</span><span class="s3">,</span>
           <span class="s4">'ks_1samp'</span><span class="s3">, </span><span class="s4">'kstest'</span><span class="s3">,</span>
           <span class="s4">'linregress'</span><span class="s3">,</span>
           <span class="s4">'mannwhitneyu'</span><span class="s3">, </span><span class="s4">'meppf'</span><span class="s3">,</span><span class="s4">'mode'</span><span class="s3">,</span><span class="s4">'moment'</span><span class="s3">,</span><span class="s4">'mquantiles'</span><span class="s3">,</span><span class="s4">'msign'</span><span class="s3">,</span>
           <span class="s4">'normaltest'</span><span class="s3">,</span>
           <span class="s4">'obrientransform'</span><span class="s3">,</span>
           <span class="s4">'pearsonr'</span><span class="s3">,</span><span class="s4">'plotting_positions'</span><span class="s3">,</span><span class="s4">'pointbiserialr'</span><span class="s3">,</span>
           <span class="s4">'rankdata'</span><span class="s3">,</span>
           <span class="s4">'scoreatpercentile'</span><span class="s3">,</span><span class="s4">'sem'</span><span class="s3">,</span>
           <span class="s4">'sen_seasonal_slopes'</span><span class="s3">,</span><span class="s4">'skew'</span><span class="s3">,</span><span class="s4">'skewtest'</span><span class="s3">,</span><span class="s4">'spearmanr'</span><span class="s3">,</span>
           <span class="s4">'siegelslopes'</span><span class="s3">, </span><span class="s4">'theilslopes'</span><span class="s3">,</span>
           <span class="s4">'tmax'</span><span class="s3">,</span><span class="s4">'tmean'</span><span class="s3">,</span><span class="s4">'tmin'</span><span class="s3">,</span><span class="s4">'trim'</span><span class="s3">,</span><span class="s4">'trimboth'</span><span class="s3">,</span>
           <span class="s4">'trimtail'</span><span class="s3">,</span><span class="s4">'trima'</span><span class="s3">,</span><span class="s4">'trimr'</span><span class="s3">,</span><span class="s4">'trimmed_mean'</span><span class="s3">,</span><span class="s4">'trimmed_std'</span><span class="s3">,</span>
           <span class="s4">'trimmed_stde'</span><span class="s3">,</span><span class="s4">'trimmed_var'</span><span class="s3">,</span><span class="s4">'tsem'</span><span class="s3">,</span><span class="s4">'ttest_1samp'</span><span class="s3">,</span><span class="s4">'ttest_onesamp'</span><span class="s3">,</span>
           <span class="s4">'ttest_ind'</span><span class="s3">,</span><span class="s4">'ttest_rel'</span><span class="s3">,</span><span class="s4">'tvar'</span><span class="s3">,</span>
           <span class="s4">'variation'</span><span class="s3">,</span>
           <span class="s4">'winsorize'</span><span class="s3">,</span>
           <span class="s4">'brunnermunzel'</span><span class="s3">,</span>
           <span class="s3">]</span>

<span class="s5">import </span><span class="s1">numpy </span><span class="s5">as </span><span class="s1">np</span>
<span class="s5">from </span><span class="s1">numpy </span><span class="s5">import </span><span class="s1">ndarray</span>
<span class="s5">import </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">ma </span><span class="s5">as </span><span class="s1">ma</span>
<span class="s5">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">ma </span><span class="s5">import </span><span class="s1">masked</span><span class="s3">, </span><span class="s1">nomask</span>
<span class="s5">import </span><span class="s1">math</span>

<span class="s5">import </span><span class="s1">itertools</span>
<span class="s5">import </span><span class="s1">warnings</span>
<span class="s5">from </span><span class="s1">collections </span><span class="s5">import </span><span class="s1">namedtuple</span>

<span class="s5">from </span><span class="s3">. </span><span class="s5">import </span><span class="s1">distributions</span>
<span class="s5">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">_lib</span><span class="s3">.</span><span class="s1">_util </span><span class="s5">import </span><span class="s1">_rename_parameter</span><span class="s3">, </span><span class="s1">_contains_nan</span>
<span class="s5">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">_lib</span><span class="s3">.</span><span class="s1">_bunch </span><span class="s5">import </span><span class="s1">_make_tuple_bunch</span>
<span class="s5">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special </span><span class="s5">as </span><span class="s1">special</span>
<span class="s5">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats</span><span class="s3">.</span><span class="s1">_stats_py</span>
<span class="s5">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats</span><span class="s3">.</span><span class="s1">_stats_py </span><span class="s5">as </span><span class="s1">_stats_py</span>

<span class="s5">from </span><span class="s3">.</span><span class="s1">_stats_mstats_common </span><span class="s5">import </span><span class="s3">(</span>
        <span class="s1">_find_repeats</span><span class="s3">,</span>
        <span class="s1">theilslopes </span><span class="s5">as </span><span class="s1">stats_theilslopes</span><span class="s3">,</span>
        <span class="s1">siegelslopes </span><span class="s5">as </span><span class="s1">stats_siegelslopes</span>
        <span class="s3">)</span>


<span class="s5">def </span><span class="s1">_chk_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s2"># Always returns a masked array, raveled for axis=None</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">axis </span><span class="s5">is None</span><span class="s3">:</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">outaxis </span><span class="s3">= </span><span class="s6">0</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">outaxis </span><span class="s3">= </span><span class="s1">axis</span>
    <span class="s5">return </span><span class="s1">a</span><span class="s3">, </span><span class="s1">outaxis</span>


<span class="s5">def </span><span class="s1">_chk2_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">b </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">axis </span><span class="s5">is None</span><span class="s3">:</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
        <span class="s1">outaxis </span><span class="s3">= </span><span class="s6">0</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">outaxis </span><span class="s3">= </span><span class="s1">axis</span>
    <span class="s5">return </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">outaxis</span>


<span class="s5">def </span><span class="s1">_chk_size</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">b </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
    <span class="s3">(</span><span class="s1">na</span><span class="s3">, </span><span class="s1">nb</span><span class="s3">) = (</span><span class="s1">a</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">b</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">na </span><span class="s3">!= </span><span class="s1">nb</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;The size of the input array should match!&quot;</span>
                         <span class="s4">f&quot; (</span><span class="s5">{</span><span class="s1">na</span><span class="s5">} </span><span class="s4">&lt;&gt; </span><span class="s5">{</span><span class="s1">nb</span><span class="s5">}</span><span class="s4">)&quot;</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">na</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">_ttest_finish</span><span class="s3">(</span><span class="s1">df</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Common code between all 3 t-test functions.&quot;&quot;&quot;</span>
    <span class="s2"># We use ``stdtr`` directly here to preserve masked arrays</span>

    <span class="s5">if </span><span class="s1">alternative </span><span class="s3">== </span><span class="s4">'less'</span><span class="s3">:</span>
        <span class="s1">pval </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">stdtr</span><span class="s3">(</span><span class="s1">df</span><span class="s3">, </span><span class="s1">t</span><span class="s3">)</span>
    <span class="s5">elif </span><span class="s1">alternative </span><span class="s3">== </span><span class="s4">'greater'</span><span class="s3">:</span>
        <span class="s1">pval </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">stdtr</span><span class="s3">(</span><span class="s1">df</span><span class="s3">, -</span><span class="s1">t</span><span class="s3">)</span>
    <span class="s5">elif </span><span class="s1">alternative </span><span class="s3">== </span><span class="s4">'two-sided'</span><span class="s3">:</span>
        <span class="s1">pval </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">stdtr</span><span class="s3">(</span><span class="s1">df</span><span class="s3">, -</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">t</span><span class="s3">))*</span><span class="s6">2</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;alternative must be &quot;</span>
                         <span class="s4">&quot;'less', 'greater' or 'two-sided'&quot;</span><span class="s3">)</span>

    <span class="s5">if </span><span class="s1">t</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s1">t </span><span class="s3">= </span><span class="s1">t</span><span class="s3">[()]</span>
    <span class="s5">if </span><span class="s1">pval</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s1">pval </span><span class="s3">= </span><span class="s1">pval</span><span class="s3">[()]</span>

    <span class="s5">return </span><span class="s1">t</span><span class="s3">, </span><span class="s1">pval</span>


<span class="s5">def </span><span class="s1">argstoarray</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Constructs a 2D array from a group of sequences. 
 
    Sequences are filled with missing values to match the length of the longest 
    sequence. 
 
    Parameters 
    ---------- 
    *args : sequences 
        Group of sequences. 
 
    Returns 
    ------- 
    argstoarray : MaskedArray 
        A ( `m` x `n` ) masked array, where `m` is the number of arguments and 
        `n` the length of the longest argument. 
 
    Notes 
    ----- 
    `numpy.ma.vstack` has identical behavior, but is called with a sequence 
    of sequences. 
 
    Examples 
    -------- 
    A 2D masked array constructed from a group of sequences is returned. 
 
    &gt;&gt;&gt; from scipy.stats.mstats import argstoarray 
    &gt;&gt;&gt; argstoarray([1, 2, 3], [4, 5, 6]) 
    masked_array( 
     data=[[1.0, 2.0, 3.0], 
           [4.0, 5.0, 6.0]], 
     mask=[[False, False, False], 
           [False, False, False]], 
     fill_value=1e+20) 
 
    The returned masked array filled with missing values when the lengths of 
    sequences are different. 
 
    &gt;&gt;&gt; argstoarray([1, 3], [4, 5, 6]) 
    masked_array( 
     data=[[1.0, 3.0, --], 
           [4.0, 5.0, 6.0]], 
     mask=[[False, False,  True], 
           [False, False, False]], 
     fill_value=1e+20) 
 
    &quot;&quot;&quot;</span>
    <span class="s5">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">args</span><span class="s3">) == </span><span class="s6">1 </span><span class="s5">and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>
        <span class="s5">if </span><span class="s1">output</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;The input should be 2D&quot;</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">max</span><span class="s3">([</span><span class="s1">len</span><span class="s3">(</span><span class="s1">k</span><span class="s3">) </span><span class="s5">for </span><span class="s1">k </span><span class="s5">in </span><span class="s1">args</span><span class="s3">])</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n</span><span class="s3">,</span><span class="s1">m</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">), </span><span class="s1">mask</span><span class="s3">=</span><span class="s5">True</span><span class="s3">)</span>
        <span class="s5">for </span><span class="s3">(</span><span class="s1">k</span><span class="s3">,</span><span class="s1">v</span><span class="s3">) </span><span class="s5">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">args</span><span class="s3">):</span>
            <span class="s1">output</span><span class="s3">[</span><span class="s1">k</span><span class="s3">,:</span><span class="s1">len</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)] = </span><span class="s1">v</span>

    <span class="s1">output</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">logical_not</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">output</span><span class="s3">.</span><span class="s1">_data</span><span class="s3">))] = </span><span class="s1">masked</span>
    <span class="s5">return </span><span class="s1">output</span>


<span class="s5">def </span><span class="s1">find_repeats</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Find repeats in arr and return a tuple (repeats, repeat_count). 
 
    The input is cast to float64. Masked values are discarded. 
 
    Parameters 
    ---------- 
    arr : sequence 
        Input array. The array is flattened if it is not 1D. 
 
    Returns 
    ------- 
    repeats : ndarray 
        Array of repeated values. 
    counts : ndarray 
        Array of counts. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.stats import mstats 
    &gt;&gt;&gt; mstats.find_repeats([2, 1, 2, 3, 2, 2, 5]) 
    (array([2.]), array([4])) 
 
    In the above example, 2 repeats 4 times. 
 
    &gt;&gt;&gt; mstats.find_repeats([[10, 20, 1, 2], [5, 5, 4, 4]]) 
    (array([4., 5.]), array([2, 2])) 
 
    In the above example, both 4 and 5 repeat 2 times. 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># Make sure we get a copy. ma.compressed promises a &quot;new array&quot;, but can</span>
    <span class="s2"># actually return a reference.</span>
    <span class="s1">compr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">compressed</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s5">try</span><span class="s3">:</span>
        <span class="s1">need_copy </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">may_share_memory</span><span class="s3">(</span><span class="s1">compr</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">)</span>
    <span class="s5">except </span><span class="s1">AttributeError</span><span class="s3">:</span>
        <span class="s2"># numpy &lt; 1.8.2 bug: np.may_share_memory([], []) raises,</span>
        <span class="s2"># while in numpy 1.8.2 and above it just (correctly) returns False.</span>
        <span class="s1">need_copy </span><span class="s3">= </span><span class="s5">False</span>
    <span class="s5">if </span><span class="s1">need_copy</span><span class="s3">:</span>
        <span class="s1">compr </span><span class="s3">= </span><span class="s1">compr</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s5">return </span><span class="s1">_find_repeats</span><span class="s3">(</span><span class="s1">compr</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">count_tied_groups</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">use_missing</span><span class="s3">=</span><span class="s5">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Counts the number of tied values. 
 
    Parameters 
    ---------- 
    x : sequence 
        Sequence of data on which to counts the ties 
    use_missing : bool, optional 
        Whether to consider missing values as tied. 
 
    Returns 
    ------- 
    count_tied_groups : dict 
        Returns a dictionary (nb of ties: nb of groups). 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.stats import mstats 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; z = [0, 0, 0, 2, 2, 2, 3, 3, 4, 5, 6] 
    &gt;&gt;&gt; mstats.count_tied_groups(z) 
    {2: 1, 3: 2} 
 
    In the above example, the ties were 0 (3x), 2 (3x) and 3 (2x). 
 
    &gt;&gt;&gt; z = np.ma.array([0, 0, 1, 2, 2, 2, 3, 3, 4, 5, 6]) 
    &gt;&gt;&gt; mstats.count_tied_groups(z) 
    {2: 2, 3: 1} 
    &gt;&gt;&gt; z[[1,-1]] = np.ma.masked 
    &gt;&gt;&gt; mstats.count_tied_groups(z, use_missing=True) 
    {2: 2, 3: 1} 
 
    &quot;&quot;&quot;</span>
    <span class="s1">nmasked </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">getmask</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">()</span>
    <span class="s2"># We need the copy as find_repeats will overwrite the initial data</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">compressed</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s3">(</span><span class="s1">ties</span><span class="s3">, </span><span class="s1">counts</span><span class="s3">) = </span><span class="s1">find_repeats</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
    <span class="s1">nties </span><span class="s3">= {}</span>
    <span class="s5">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">ties</span><span class="s3">):</span>
        <span class="s1">nties </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">counts</span><span class="s3">), </span><span class="s1">itertools</span><span class="s3">.</span><span class="s1">repeat</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)))</span>
        <span class="s1">nties</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">dict</span><span class="s3">(</span><span class="s1">zip</span><span class="s3">(*</span><span class="s1">find_repeats</span><span class="s3">(</span><span class="s1">counts</span><span class="s3">))))</span>

    <span class="s5">if </span><span class="s1">nmasked </span><span class="s5">and </span><span class="s1">use_missing</span><span class="s3">:</span>
        <span class="s5">try</span><span class="s3">:</span>
            <span class="s1">nties</span><span class="s3">[</span><span class="s1">nmasked</span><span class="s3">] += </span><span class="s6">1</span>
        <span class="s5">except </span><span class="s1">KeyError</span><span class="s3">:</span>
            <span class="s1">nties</span><span class="s3">[</span><span class="s1">nmasked</span><span class="s3">] = </span><span class="s6">1</span>

    <span class="s5">return </span><span class="s1">nties</span>


<span class="s5">def </span><span class="s1">rankdata</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">use_missing</span><span class="s3">=</span><span class="s5">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Returns the rank (also known as order statistics) of each data point 
    along the given axis. 
 
    If some values are tied, their rank is averaged. 
    If some values are masked, their rank is set to 0 if use_missing is False, 
    or set to the average rank of the unmasked values if use_missing is True. 
 
    Parameters 
    ---------- 
    data : sequence 
        Input data. The data is transformed to a masked array 
    axis : {None,int}, optional 
        Axis along which to perform the ranking. 
        If None, the array is first flattened. An exception is raised if 
        the axis is specified for arrays with a dimension larger than 2 
    use_missing : bool, optional 
        Whether the masked values have a rank of 0 (False) or equal to the 
        average rank of the unmasked values (True). 
 
    &quot;&quot;&quot;</span>
    <span class="s5">def </span><span class="s1">_rank1d</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">use_missing</span><span class="s3">=</span><span class="s5">False</span><span class="s3">):</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">count</span><span class="s3">()</span>
        <span class="s1">rk </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">)</span>
        <span class="s1">idx </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">()</span>
        <span class="s1">rk</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">[:</span><span class="s1">n</span><span class="s3">]] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">1</span><span class="s3">,</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)</span>

        <span class="s5">if </span><span class="s1">use_missing</span><span class="s3">:</span>
            <span class="s1">rk</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">[</span><span class="s1">n</span><span class="s3">:]] = (</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)/</span><span class="s6">2.</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">rk</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">[</span><span class="s1">n</span><span class="s3">:]] = </span><span class="s6">0</span>

        <span class="s1">repeats </span><span class="s3">= </span><span class="s1">find_repeats</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">())</span>
        <span class="s5">for </span><span class="s1">r </span><span class="s5">in </span><span class="s1">repeats</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]:</span>
            <span class="s1">condition </span><span class="s3">= (</span><span class="s1">data </span><span class="s3">== </span><span class="s1">r</span><span class="s3">).</span><span class="s1">filled</span><span class="s3">(</span><span class="s5">False</span><span class="s3">)</span>
            <span class="s1">rk</span><span class="s3">[</span><span class="s1">condition</span><span class="s3">] = </span><span class="s1">rk</span><span class="s3">[</span><span class="s1">condition</span><span class="s3">].</span><span class="s1">mean</span><span class="s3">()</span>
        <span class="s5">return </span><span class="s1">rk</span>

    <span class="s1">data </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">False</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">axis </span><span class="s5">is None</span><span class="s3">:</span>
        <span class="s5">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s5">return </span><span class="s1">_rank1d</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(), </span><span class="s1">use_missing</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s5">return </span><span class="s1">_rank1d</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">use_missing</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">apply_along_axis</span><span class="s3">(</span><span class="s1">_rank1d</span><span class="s3">,</span><span class="s1">axis</span><span class="s3">,</span><span class="s1">data</span><span class="s3">,</span><span class="s1">use_missing</span><span class="s3">).</span><span class="s1">view</span><span class="s3">(</span><span class="s1">ndarray</span><span class="s3">)</span>


<span class="s1">ModeResult </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'ModeResult'</span><span class="s3">, (</span><span class="s4">'mode'</span><span class="s3">, </span><span class="s4">'count'</span><span class="s3">))</span>


<span class="s5">def </span><span class="s1">mode</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns an array of the modal (most common) value in the passed array. 
 
    Parameters 
    ---------- 
    a : array_like 
        n-dimensional array of which to find mode(s). 
    axis : int or None, optional 
        Axis along which to operate. Default is 0. If None, compute over 
        the whole array `a`. 
 
    Returns 
    ------- 
    mode : ndarray 
        Array of modal values. 
    count : ndarray 
        Array of counts for each mode. 
 
    Notes 
    ----- 
    For more details, see `scipy.stats.mode`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; from scipy.stats import mstats 
    &gt;&gt;&gt; m_arr = np.ma.array([1, 1, 0, 0, 0, 0], mask=[0, 0, 1, 1, 1, 0]) 
    &gt;&gt;&gt; mstats.mode(m_arr)  # note that most zeros are masked 
    ModeResult(mode=array([1.]), count=array([2.])) 
 
    &quot;&quot;&quot;</span>
    <span class="s5">return </span><span class="s1">_mode</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s5">True</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">_mode</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s5">True</span><span class="s3">):</span>
    <span class="s2"># Don't want to expose `keepdims` from the public `mstats.mode`</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">= </span><span class="s1">_chk_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">_mode1D</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s3">(</span><span class="s1">rep</span><span class="s3">,</span><span class="s1">cnt</span><span class="s3">) = </span><span class="s1">find_repeats</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">cnt</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
            <span class="s5">return </span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">)</span>
        <span class="s5">elif </span><span class="s1">cnt</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
            <span class="s5">return </span><span class="s3">(</span><span class="s1">rep</span><span class="s3">[</span><span class="s1">cnt</span><span class="s3">.</span><span class="s1">argmax</span><span class="s3">()], </span><span class="s1">cnt</span><span class="s3">.</span><span class="s1">max</span><span class="s3">())</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s5">return </span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(), </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s5">if </span><span class="s1">axis </span><span class="s5">is None</span><span class="s3">:</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">_mode1D</span><span class="s3">(</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">a</span><span class="s3">))</span>
        <span class="s1">output </span><span class="s3">= (</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">output</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]), </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">output</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]))</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">apply_along_axis</span><span class="s3">(</span><span class="s1">_mode1D</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">keepdims </span><span class="s5">is None or </span><span class="s1">keepdims</span><span class="s3">:</span>
            <span class="s1">newshape </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
            <span class="s1">newshape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s6">1</span>
            <span class="s1">slices </span><span class="s3">= [</span><span class="s1">slice</span><span class="s3">(</span><span class="s5">None</span><span class="s3">)] * </span><span class="s1">output</span><span class="s3">.</span><span class="s1">ndim</span>
            <span class="s1">slices</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s6">0</span>
            <span class="s1">modes </span><span class="s3">= </span><span class="s1">output</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">slices</span><span class="s3">)].</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">newshape</span><span class="s3">)</span>
            <span class="s1">slices</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s6">1</span>
            <span class="s1">counts </span><span class="s3">= </span><span class="s1">output</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">slices</span><span class="s3">)].</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">newshape</span><span class="s3">)</span>
            <span class="s1">output </span><span class="s3">= (</span><span class="s1">modes</span><span class="s3">, </span><span class="s1">counts</span><span class="s3">)</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">output </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s6">0</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">ModeResult</span><span class="s3">(*</span><span class="s1">output</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">_betai</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">x </span><span class="s3">&lt; </span><span class="s6">1.0</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s6">1.0</span><span class="s3">)  </span><span class="s2"># if x &gt; 1 then return 1.0</span>
    <span class="s5">return </span><span class="s1">special</span><span class="s3">.</span><span class="s1">betainc</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">msign</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Returns the sign of x, or 0 if x is masked.&quot;&quot;&quot;</span>
    <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">filled</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sign</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s6">0</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">pearsonr</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Pearson correlation coefficient and p-value for testing non-correlation. 
 
    The Pearson correlation coefficient [1]_ measures the linear relationship 
    between two datasets.  The calculation of the p-value relies on the 
    assumption that each dataset is normally distributed.  (See Kowalski [3]_ 
    for a discussion of the effects of non-normality of the input on the 
    distribution of the correlation coefficient.)  Like other correlation 
    coefficients, this one varies between -1 and +1 with 0 implying no 
    correlation. Correlations of -1 or +1 imply an exact linear relationship. 
 
    Parameters 
    ---------- 
    x : (N,) array_like 
        Input array. 
    y : (N,) array_like 
        Input array. 
 
    Returns 
    ------- 
    r : float 
        Pearson's correlation coefficient. 
    p-value : float 
        Two-tailed p-value. 
 
    Warns 
    ----- 
    `~scipy.stats.ConstantInputWarning` 
        Raised if an input is a constant array.  The correlation coefficient 
        is not defined in this case, so ``np.nan`` is returned. 
 
    `~scipy.stats.NearConstantInputWarning` 
        Raised if an input is &quot;nearly&quot; constant.  The array ``x`` is considered 
        nearly constant if ``norm(x - mean(x)) &lt; 1e-13 * abs(mean(x))``. 
        Numerical errors in the calculation ``x - mean(x)`` in this case might 
        result in an inaccurate calculation of r. 
 
    See Also 
    -------- 
    spearmanr : Spearman rank-order correlation coefficient. 
    kendalltau : Kendall's tau, a correlation measure for ordinal data. 
 
    Notes 
    ----- 
    The correlation coefficient is calculated as follows: 
 
    .. math:: 
 
        r = \frac{\sum (x - m_x) (y - m_y)} 
                 {\sqrt{\sum (x - m_x)^2 \sum (y - m_y)^2}} 
 
    where :math:`m_x` is the mean of the vector x and :math:`m_y` is 
    the mean of the vector y. 
 
    Under the assumption that x and y are drawn from 
    independent normal distributions (so the population correlation coefficient 
    is 0), the probability density function of the sample correlation 
    coefficient r is ([1]_, [2]_): 
 
    .. math:: 
 
        f(r) = \frac{{(1-r^2)}^{n/2-2}}{\mathrm{B}(\frac{1}{2},\frac{n}{2}-1)} 
 
    where n is the number of samples, and B is the beta function.  This 
    is sometimes referred to as the exact distribution of r.  This is 
    the distribution that is used in `pearsonr` to compute the p-value. 
    The distribution is a beta distribution on the interval [-1, 1], 
    with equal shape parameters a = b = n/2 - 1.  In terms of SciPy's 
    implementation of the beta distribution, the distribution of r is:: 
 
        dist = scipy.stats.beta(n/2 - 1, n/2 - 1, loc=-1, scale=2) 
 
    The p-value returned by `pearsonr` is a two-sided p-value. The p-value 
    roughly indicates the probability of an uncorrelated system 
    producing datasets that have a Pearson correlation at least as extreme 
    as the one computed from these datasets. More precisely, for a 
    given sample with correlation coefficient r, the p-value is 
    the probability that abs(r') of a random sample x' and y' drawn from 
    the population with zero correlation would be greater than or equal 
    to abs(r). In terms of the object ``dist`` shown above, the p-value 
    for a given r and length n can be computed as:: 
 
        p = 2*dist.cdf(-abs(r)) 
 
    When n is 2, the above continuous distribution is not well-defined. 
    One can interpret the limit of the beta distribution as the shape 
    parameters a and b approach a = b = 0 as a discrete distribution with 
    equal probability masses at r = 1 and r = -1.  More directly, one 
    can observe that, given the data x = [x1, x2] and y = [y1, y2], and 
    assuming x1 != x2 and y1 != y2, the only possible values for r are 1 
    and -1.  Because abs(r') for any sample x' and y' with length 2 will 
    be 1, the two-sided p-value for a sample of length 2 is always 1. 
 
    References 
    ---------- 
    .. [1] &quot;Pearson correlation coefficient&quot;, Wikipedia, 
           https://en.wikipedia.org/wiki/Pearson_correlation_coefficient 
    .. [2] Student, &quot;Probable error of a correlation coefficient&quot;, 
           Biometrika, Volume 6, Issue 2-3, 1 September 1908, pp. 302-310. 
    .. [3] C. J. Kowalski, &quot;On the Effects of Non-Normality on the Distribution 
           of the Sample Product-Moment Correlation Coefficient&quot; 
           Journal of the Royal Statistical Society. Series C (Applied 
           Statistics), Vol. 21, No. 1 (1972), pp. 1-12. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; from scipy.stats import mstats 
    &gt;&gt;&gt; mstats.pearsonr([1, 2, 3, 4, 5], [10, 9, 2.5, 6, 4]) 
    (-0.7426106572325057, 0.1505558088534455) 
 
    There is a linear dependence between x and y if y = a + b*x + e, where 
    a,b are constants and e is a random error term, assumed to be independent 
    of x. For simplicity, assume that x is standard normal, a=0, b=1 and let 
    e follow a normal distribution with mean zero and standard deviation s&gt;0. 
 
    &gt;&gt;&gt; s = 0.5 
    &gt;&gt;&gt; x = stats.norm.rvs(size=500) 
    &gt;&gt;&gt; e = stats.norm.rvs(scale=s, size=500) 
    &gt;&gt;&gt; y = x + e 
    &gt;&gt;&gt; mstats.pearsonr(x, y) 
    (0.9029601878969703, 8.428978827629898e-185) # may vary 
 
    This should be close to the exact value given by 
 
    &gt;&gt;&gt; 1/np.sqrt(1 + s**2) 
    0.8944271909999159 
 
    For s=0.5, we observe a high level of correlation. In general, a large 
    variance of the noise reduces the correlation, while the correlation 
    approaches one as the variance of the error goes to zero. 
 
    It is important to keep in mind that no correlation does not imply 
    independence unless (x, y) is jointly normal. Correlation can even be zero 
    when there is a very simple dependence structure: if X follows a 
    standard normal distribution, let y = abs(x). Note that the correlation 
    between x and y is zero. Indeed, since the expectation of x is zero, 
    cov(x, y) = E[x*y]. By definition, this equals E[x*abs(x)] which is zero 
    by symmetry. The following lines of code illustrate this observation: 
 
    &gt;&gt;&gt; y = np.abs(x) 
    &gt;&gt;&gt; mstats.pearsonr(x, y) 
    (-0.016172891856853524, 0.7182823678751942) # may vary 
 
    A non-zero correlation coefficient can be misleading. For example, if X has 
    a standard normal distribution, define y = x if x &lt; 0 and y = 0 otherwise. 
    A simple calculation shows that corr(x, y) = sqrt(2/Pi) = 0.797..., 
    implying a high level of correlation: 
 
    &gt;&gt;&gt; y = np.where(x &lt; 0, x, 0) 
    &gt;&gt;&gt; mstats.pearsonr(x, y) 
    (0.8537091583771509, 3.183461621422181e-143) # may vary 
 
    This is unintuitive since there is no dependence of x and y if x is larger 
    than zero which happens in about half of the cases if we sample x and y. 
    &quot;&quot;&quot;</span>
    <span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">n</span><span class="s3">) = </span><span class="s1">_chk_size</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) = (</span><span class="s1">x</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(), </span><span class="s1">y</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">())</span>
    <span class="s2"># Get the common mask and the total nb of unmasked elements</span>
    <span class="s1">m </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">mask_or</span><span class="s3">(</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">getmask</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">getmask</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>
    <span class="s1">n </span><span class="s3">-= </span><span class="s1">m</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">()</span>
    <span class="s1">df </span><span class="s3">= </span><span class="s1">n</span><span class="s3">-</span><span class="s6">2</span>
    <span class="s5">if </span><span class="s1">df </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s3">(</span><span class="s1">masked</span><span class="s3">, </span><span class="s1">masked</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats</span><span class="s3">.</span><span class="s1">_stats_py</span><span class="s3">.</span><span class="s1">pearsonr</span><span class="s3">(</span>
                <span class="s1">ma</span><span class="s3">.</span><span class="s1">masked_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">=</span><span class="s1">m</span><span class="s3">).</span><span class="s1">compressed</span><span class="s3">(),</span>
                <span class="s1">ma</span><span class="s3">.</span><span class="s1">masked_array</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">=</span><span class="s1">m</span><span class="s3">).</span><span class="s1">compressed</span><span class="s3">())</span>


<span class="s5">def </span><span class="s1">spearmanr</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">use_ties</span><span class="s3">=</span><span class="s5">True</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">nan_policy</span><span class="s3">=</span><span class="s4">'propagate'</span><span class="s3">,</span>
              <span class="s1">alternative</span><span class="s3">=</span><span class="s4">'two-sided'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculates a Spearman rank-order correlation coefficient and the p-value 
    to test for non-correlation. 
 
    The Spearman correlation is a nonparametric measure of the linear 
    relationship between two datasets. Unlike the Pearson correlation, the 
    Spearman correlation does not assume that both datasets are normally 
    distributed. Like other correlation coefficients, this one varies 
    between -1 and +1 with 0 implying no correlation. Correlations of -1 or 
    +1 imply a monotonic relationship. Positive correlations imply that 
    as `x` increases, so does `y`. Negative correlations imply that as `x` 
    increases, `y` decreases. 
 
    Missing values are discarded pair-wise: if a value is missing in `x`, the 
    corresponding value in `y` is masked. 
 
    The p-value roughly indicates the probability of an uncorrelated system 
    producing datasets that have a Spearman correlation at least as extreme 
    as the one computed from these datasets. The p-values are not entirely 
    reliable but are probably reasonable for datasets larger than 500 or so. 
 
    Parameters 
    ---------- 
    x, y : 1D or 2D array_like, y is optional 
        One or two 1-D or 2-D arrays containing multiple variables and 
        observations. When these are 1-D, each represents a vector of 
        observations of a single variable. For the behavior in the 2-D case, 
        see under ``axis``, below. 
    use_ties : bool, optional 
        DO NOT USE.  Does not do anything, keyword is only left in place for 
        backwards compatibility reasons. 
    axis : int or None, optional 
        If axis=0 (default), then each column represents a variable, with 
        observations in the rows. If axis=1, the relationship is transposed: 
        each row represents a variable, while the columns contain observations. 
        If axis=None, then both arrays will be raveled. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 'propagate' returns nan, 
        'raise' throws an error, 'omit' performs the calculations ignoring nan 
        values. Default is 'propagate'. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. Default is 'two-sided'. 
        The following options are available: 
 
        * 'two-sided': the correlation is nonzero 
        * 'less': the correlation is negative (less than zero) 
        * 'greater':  the correlation is positive (greater than zero) 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    res : SignificanceResult 
        An object containing attributes: 
 
        statistic : float or ndarray (2-D square) 
            Spearman correlation matrix or correlation coefficient (if only 2 
            variables are given as parameters). Correlation matrix is square 
            with length equal to total number of variables (columns or rows) in 
            ``a`` and ``b`` combined. 
        pvalue : float 
            The p-value for a hypothesis test whose null hypothesis 
            is that two sets of data are linearly uncorrelated. See 
            `alternative` above for alternative hypotheses. `pvalue` has the 
            same shape as `statistic`. 
 
    References 
    ---------- 
    [CRCProbStat2000] section 14.7 
 
    &quot;&quot;&quot;</span>
    <span class="s5">if not </span><span class="s1">use_ties</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;`use_ties=False` is not supported in SciPy &gt;= 1.2.0&quot;</span><span class="s3">)</span>

    <span class="s2"># Always returns a masked array, raveled if axis=None</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">axisout </span><span class="s3">= </span><span class="s1">_chk_asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">y </span><span class="s5">is not None</span><span class="s3">:</span>
        <span class="s2"># Deal only with 2-D `x` case.</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">_chk_asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">axisout </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">column_stack</span><span class="s3">((</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">((</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>

    <span class="s5">if </span><span class="s1">axisout </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s2"># To simplify the code that follow (always use `n_obs, n_vars` shape)</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">T</span>

    <span class="s5">if </span><span class="s1">nan_policy </span><span class="s3">== </span><span class="s4">'omit'</span><span class="s3">:</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">masked_invalid</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">_spearmanr_2cols</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2"># Mask the same observations for all variables, and then drop those</span>
        <span class="s2"># observations (can't leave them masked, rankdata is weird).</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">mask_rowcols</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[~</span><span class="s1">x</span><span class="s3">.</span><span class="s1">mask</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s6">1</span><span class="s3">), :]</span>

        <span class="s2"># If either column is entirely NaN or Inf</span>
        <span class="s5">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">data</span><span class="s3">):</span>
            <span class="s1">res </span><span class="s3">= </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats</span><span class="s3">.</span><span class="s1">_stats_py</span><span class="s3">.</span><span class="s1">SignificanceResult</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">)</span>
            <span class="s1">res</span><span class="s3">.</span><span class="s1">correlation </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
            <span class="s5">return </span><span class="s1">res</span>

        <span class="s1">m </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">getmask</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">n_obs </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">dof </span><span class="s3">= </span><span class="s1">n_obs </span><span class="s3">- </span><span class="s6">2 </span><span class="s3">- </span><span class="s1">int</span><span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)[</span><span class="s6">0</span><span class="s3">])</span>
        <span class="s5">if </span><span class="s1">dof </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;The input must have at least 3 entries!&quot;</span><span class="s3">)</span>

        <span class="s2"># Gets the ranks and rank differences</span>
        <span class="s1">x_ranked </span><span class="s3">= </span><span class="s1">rankdata</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">rs </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">corrcoef</span><span class="s3">(</span><span class="s1">x_ranked</span><span class="s3">, </span><span class="s1">rowvar</span><span class="s3">=</span><span class="s5">False</span><span class="s3">).</span><span class="s1">data</span>

        <span class="s2"># rs can have elements equal to 1, so avoid zero division warnings</span>
        <span class="s5">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">divide</span><span class="s3">=</span><span class="s4">'ignore'</span><span class="s3">):</span>
            <span class="s2"># clip the small negative values possibly caused by rounding</span>
            <span class="s2"># errors before taking the square root</span>
            <span class="s1">t </span><span class="s3">= </span><span class="s1">rs </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">((</span><span class="s1">dof </span><span class="s3">/ ((</span><span class="s1">rs</span><span class="s3">+</span><span class="s6">1.0</span><span class="s3">) * (</span><span class="s6">1.0</span><span class="s3">-</span><span class="s1">rs</span><span class="s3">))).</span><span class="s1">clip</span><span class="s3">(</span><span class="s6">0</span><span class="s3">))</span>

        <span class="s1">t</span><span class="s3">, </span><span class="s1">prob </span><span class="s3">= </span><span class="s1">_ttest_finish</span><span class="s3">(</span><span class="s1">dof</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">)</span>

        <span class="s2"># For backwards compatibility, return scalars when comparing 2 columns</span>
        <span class="s5">if </span><span class="s1">rs</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">):</span>
            <span class="s1">res </span><span class="s3">= </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats</span><span class="s3">.</span><span class="s1">_stats_py</span><span class="s3">.</span><span class="s1">SignificanceResult</span><span class="s3">(</span><span class="s1">rs</span><span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">0</span><span class="s3">],</span>
                                                           <span class="s1">prob</span><span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">0</span><span class="s3">])</span>
            <span class="s1">res</span><span class="s3">.</span><span class="s1">correlation </span><span class="s3">= </span><span class="s1">rs</span><span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s6">0</span><span class="s3">]</span>
            <span class="s5">return </span><span class="s1">res</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">res </span><span class="s3">= </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats</span><span class="s3">.</span><span class="s1">_stats_py</span><span class="s3">.</span><span class="s1">SignificanceResult</span><span class="s3">(</span><span class="s1">rs</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">)</span>
            <span class="s1">res</span><span class="s3">.</span><span class="s1">correlation </span><span class="s3">= </span><span class="s1">rs</span>
            <span class="s5">return </span><span class="s1">res</span>

    <span class="s2"># Need to do this per pair of variables, otherwise the dropped observations</span>
    <span class="s2"># in a third column mess up the result for a pair.</span>
    <span class="s1">n_vars </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
    <span class="s5">if </span><span class="s1">n_vars </span><span class="s3">== </span><span class="s6">2</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">_spearmanr_2cols</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">rs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s1">n_vars</span><span class="s3">, </span><span class="s1">n_vars</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">)</span>
        <span class="s1">prob </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">n_vars</span><span class="s3">, </span><span class="s1">n_vars</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">)</span>
        <span class="s5">for </span><span class="s1">var1 </span><span class="s5">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_vars </span><span class="s3">- </span><span class="s6">1</span><span class="s3">):</span>
            <span class="s5">for </span><span class="s1">var2 </span><span class="s5">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">var1</span><span class="s3">+</span><span class="s6">1</span><span class="s3">, </span><span class="s1">n_vars</span><span class="s3">):</span>
                <span class="s1">result </span><span class="s3">= </span><span class="s1">_spearmanr_2cols</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[:, [</span><span class="s1">var1</span><span class="s3">, </span><span class="s1">var2</span><span class="s3">]])</span>
                <span class="s1">rs</span><span class="s3">[</span><span class="s1">var1</span><span class="s3">, </span><span class="s1">var2</span><span class="s3">] = </span><span class="s1">result</span><span class="s3">.</span><span class="s1">correlation</span>
                <span class="s1">rs</span><span class="s3">[</span><span class="s1">var2</span><span class="s3">, </span><span class="s1">var1</span><span class="s3">] = </span><span class="s1">result</span><span class="s3">.</span><span class="s1">correlation</span>
                <span class="s1">prob</span><span class="s3">[</span><span class="s1">var1</span><span class="s3">, </span><span class="s1">var2</span><span class="s3">] = </span><span class="s1">result</span><span class="s3">.</span><span class="s1">pvalue</span>
                <span class="s1">prob</span><span class="s3">[</span><span class="s1">var2</span><span class="s3">, </span><span class="s1">var1</span><span class="s3">] = </span><span class="s1">result</span><span class="s3">.</span><span class="s1">pvalue</span>

        <span class="s1">res </span><span class="s3">= </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats</span><span class="s3">.</span><span class="s1">_stats_py</span><span class="s3">.</span><span class="s1">SignificanceResult</span><span class="s3">(</span><span class="s1">rs</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">)</span>
        <span class="s1">res</span><span class="s3">.</span><span class="s1">correlation </span><span class="s3">= </span><span class="s1">rs</span>
        <span class="s5">return </span><span class="s1">res</span>


<span class="s5">def </span><span class="s1">_kendall_p_exact</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">=</span><span class="s4">'two-sided'</span><span class="s3">):</span>

    <span class="s2"># Use the fact that distribution is symmetric: always calculate a CDF in</span>
    <span class="s2"># the left tail.</span>
    <span class="s2"># This will be the one-sided p-value if `c` is on the side of</span>
    <span class="s2"># the null distribution predicted by the alternative hypothesis.</span>
    <span class="s2"># The two-sided p-value will be twice this value.</span>
    <span class="s2"># If `c` is on the other side of the null distribution, we'll need to</span>
    <span class="s2"># take the complement and add back the probability mass at `c`.</span>
    <span class="s1">in_right_tail </span><span class="s3">= (</span><span class="s1">c </span><span class="s3">&gt;= (</span><span class="s1">n</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">))//</span><span class="s6">2 </span><span class="s3">- </span><span class="s1">c</span><span class="s3">)</span>
    <span class="s1">alternative_greater </span><span class="s3">= (</span><span class="s1">alternative </span><span class="s3">== </span><span class="s4">'greater'</span><span class="s3">)</span>
    <span class="s1">c </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">min</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, (</span><span class="s1">n</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">))//</span><span class="s6">2 </span><span class="s3">- </span><span class="s1">c</span><span class="s3">))</span>

    <span class="s2"># Exact p-value, see Maurice G. Kendall, &quot;Rank Correlation Methods&quot;</span>
    <span class="s2"># (4th Edition), Charles Griffin &amp; Co., 1970.</span>
    <span class="s5">if </span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f'n (</span><span class="s5">{</span><span class="s1">n</span><span class="s5">}</span><span class="s4">) must be positive'</span><span class="s3">)</span>
    <span class="s5">elif </span><span class="s1">c </span><span class="s3">&lt; </span><span class="s6">0 </span><span class="s5">or </span><span class="s6">4</span><span class="s3">*</span><span class="s1">c </span><span class="s3">&gt; </span><span class="s1">n</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">):</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f'c (</span><span class="s5">{</span><span class="s1">c</span><span class="s5">}</span><span class="s4">) must satisfy 0 &lt;= 4c &lt;= n(n-1) = </span><span class="s5">{</span><span class="s1">n</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)</span><span class="s5">}</span><span class="s4">.'</span><span class="s3">)</span>
    <span class="s5">elif </span><span class="s1">n </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s1">prob </span><span class="s3">= </span><span class="s6">1.0</span>
        <span class="s1">p_mass_at_c </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s5">elif </span><span class="s1">n </span><span class="s3">== </span><span class="s6">2</span><span class="s3">:</span>
        <span class="s1">prob </span><span class="s3">= </span><span class="s6">1.0</span>
        <span class="s1">p_mass_at_c </span><span class="s3">= </span><span class="s6">0.5</span>
    <span class="s5">elif </span><span class="s1">c </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s1">prob </span><span class="s3">= </span><span class="s6">2.0</span><span class="s3">/</span><span class="s1">math</span><span class="s3">.</span><span class="s1">factorial</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) </span><span class="s5">if </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s6">171 </span><span class="s5">else </span><span class="s6">0.0</span>
        <span class="s1">p_mass_at_c </span><span class="s3">= </span><span class="s1">prob</span><span class="s3">/</span><span class="s6">2</span>
    <span class="s5">elif </span><span class="s1">c </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s1">prob </span><span class="s3">= </span><span class="s6">2.0</span><span class="s3">/</span><span class="s1">math</span><span class="s3">.</span><span class="s1">factorial</span><span class="s3">(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">) </span><span class="s5">if </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s6">172 </span><span class="s5">else </span><span class="s6">0.0</span>
        <span class="s1">p_mass_at_c </span><span class="s3">= (</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)/</span><span class="s1">math</span><span class="s3">.</span><span class="s1">factorial</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s5">elif </span><span class="s6">4</span><span class="s3">*</span><span class="s1">c </span><span class="s3">== </span><span class="s1">n</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">) </span><span class="s5">and </span><span class="s1">alternative </span><span class="s3">== </span><span class="s4">'two-sided'</span><span class="s3">:</span>
        <span class="s2"># I'm sure there's a simple formula for p_mass_at_c in this</span>
        <span class="s2"># case, but I don't know it. Use generic formula for one-sided p-value.</span>
        <span class="s1">prob </span><span class="s3">= </span><span class="s6">1.0</span>
    <span class="s5">elif </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s6">171</span><span class="s3">:</span>
        <span class="s1">new </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">c</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)</span>
        <span class="s1">new</span><span class="s3">[</span><span class="s6">0</span><span class="s3">:</span><span class="s6">2</span><span class="s3">] = </span><span class="s6">1.0</span>
        <span class="s5">for </span><span class="s1">j </span><span class="s5">in </span><span class="s1">range</span><span class="s3">(</span><span class="s6">3</span><span class="s3">,</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">):</span>
            <span class="s1">new </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cumsum</span><span class="s3">(</span><span class="s1">new</span><span class="s3">)</span>
            <span class="s5">if </span><span class="s1">j </span><span class="s3">&lt;= </span><span class="s1">c</span><span class="s3">:</span>
                <span class="s1">new</span><span class="s3">[</span><span class="s1">j</span><span class="s3">:] -= </span><span class="s1">new</span><span class="s3">[:</span><span class="s1">c</span><span class="s3">+</span><span class="s6">1</span><span class="s3">-</span><span class="s1">j</span><span class="s3">]</span>
        <span class="s1">prob </span><span class="s3">= </span><span class="s6">2.0</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">new</span><span class="s3">)/</span><span class="s1">math</span><span class="s3">.</span><span class="s1">factorial</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">p_mass_at_c </span><span class="s3">= </span><span class="s1">new</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]/</span><span class="s1">math</span><span class="s3">.</span><span class="s1">factorial</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">new </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">c</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)</span>
        <span class="s1">new</span><span class="s3">[</span><span class="s6">0</span><span class="s3">:</span><span class="s6">2</span><span class="s3">] = </span><span class="s6">1.0</span>
        <span class="s5">for </span><span class="s1">j </span><span class="s5">in </span><span class="s1">range</span><span class="s3">(</span><span class="s6">3</span><span class="s3">, </span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">):</span>
            <span class="s1">new </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cumsum</span><span class="s3">(</span><span class="s1">new</span><span class="s3">)/</span><span class="s1">j</span>
            <span class="s5">if </span><span class="s1">j </span><span class="s3">&lt;= </span><span class="s1">c</span><span class="s3">:</span>
                <span class="s1">new</span><span class="s3">[</span><span class="s1">j</span><span class="s3">:] -= </span><span class="s1">new</span><span class="s3">[:</span><span class="s1">c</span><span class="s3">+</span><span class="s6">1</span><span class="s3">-</span><span class="s1">j</span><span class="s3">]</span>
        <span class="s1">prob </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">new</span><span class="s3">)</span>
        <span class="s1">p_mass_at_c </span><span class="s3">= </span><span class="s1">new</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]/</span><span class="s6">2</span>

    <span class="s5">if </span><span class="s1">alternative </span><span class="s3">!= </span><span class="s4">'two-sided'</span><span class="s3">:</span>
        <span class="s2"># if the alternative hypothesis and alternative agree,</span>
        <span class="s2"># one-sided p-value is half the two-sided p-value</span>
        <span class="s5">if </span><span class="s1">in_right_tail </span><span class="s3">== </span><span class="s1">alternative_greater</span><span class="s3">:</span>
            <span class="s1">prob </span><span class="s3">/= </span><span class="s6">2</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">prob </span><span class="s3">= </span><span class="s6">1 </span><span class="s3">- </span><span class="s1">prob</span><span class="s3">/</span><span class="s6">2 </span><span class="s3">+ </span><span class="s1">p_mass_at_c</span>

    <span class="s1">prob </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">clip</span><span class="s3">(</span><span class="s1">prob</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">prob</span>


<span class="s5">def </span><span class="s1">kendalltau</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">use_ties</span><span class="s3">=</span><span class="s5">True</span><span class="s3">, </span><span class="s1">use_missing</span><span class="s3">=</span><span class="s5">False</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">'auto'</span><span class="s3">,</span>
               <span class="s1">alternative</span><span class="s3">=</span><span class="s4">'two-sided'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes Kendall's rank correlation tau on two variables *x* and *y*. 
 
    Parameters 
    ---------- 
    x : sequence 
        First data list (for example, time). 
    y : sequence 
        Second data list. 
    use_ties : {True, False}, optional 
        Whether ties correction should be performed. 
    use_missing : {False, True}, optional 
        Whether missing data should be allocated a rank of 0 (False) or the 
        average rank (True) 
    method : {'auto', 'asymptotic', 'exact'}, optional 
        Defines which method is used to calculate the p-value [1]_. 
        'asymptotic' uses a normal approximation valid for large samples. 
        'exact' computes the exact p-value, but can only be used if no ties 
        are present. As the sample size increases, the 'exact' computation 
        time may grow and the result may lose some precision. 
        'auto' is the default and selects the appropriate 
        method based on a trade-off between speed and accuracy. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. Default is 'two-sided'. 
        The following options are available: 
 
        * 'two-sided': the rank correlation is nonzero 
        * 'less': the rank correlation is negative (less than zero) 
        * 'greater':  the rank correlation is positive (greater than zero) 
 
    Returns 
    ------- 
    res : SignificanceResult 
        An object containing attributes: 
 
        statistic : float 
           The tau statistic. 
        pvalue : float 
           The p-value for a hypothesis test whose null hypothesis is 
           an absence of association, tau = 0. 
 
    References 
    ---------- 
    .. [1] Maurice G. Kendall, &quot;Rank Correlation Methods&quot; (4th Edition), 
           Charles Griffin &amp; Co., 1970. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">n</span><span class="s3">) = </span><span class="s1">_chk_size</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) = (</span><span class="s1">x</span><span class="s3">.</span><span class="s1">flatten</span><span class="s3">(), </span><span class="s1">y</span><span class="s3">.</span><span class="s1">flatten</span><span class="s3">())</span>
    <span class="s1">m </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">mask_or</span><span class="s3">(</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">getmask</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">getmask</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>
    <span class="s5">if </span><span class="s1">m </span><span class="s5">is not </span><span class="s1">nomask</span><span class="s3">:</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">=</span><span class="s1">m</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">True</span><span class="s3">)</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">=</span><span class="s1">m</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">True</span><span class="s3">)</span>
        <span class="s2"># need int() here, otherwise numpy defaults to 32 bit</span>
        <span class="s2"># integer on all Windows architectures, causing overflow.</span>
        <span class="s2"># int() will keep it infinite precision.</span>
        <span class="s1">n </span><span class="s3">-= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">m</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">())</span>

    <span class="s5">if </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s6">2</span><span class="s3">:</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats</span><span class="s3">.</span><span class="s1">_stats_py</span><span class="s3">.</span><span class="s1">SignificanceResult</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">)</span>
        <span class="s1">res</span><span class="s3">.</span><span class="s1">correlation </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
        <span class="s5">return </span><span class="s1">res</span>

    <span class="s1">rx </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">masked_equal</span><span class="s3">(</span><span class="s1">rankdata</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">use_missing</span><span class="s3">=</span><span class="s1">use_missing</span><span class="s3">), </span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">ry </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">masked_equal</span><span class="s3">(</span><span class="s1">rankdata</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">use_missing</span><span class="s3">=</span><span class="s1">use_missing</span><span class="s3">), </span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">idx </span><span class="s3">= </span><span class="s1">rx</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">()</span>
    <span class="s3">(</span><span class="s1">rx</span><span class="s3">, </span><span class="s1">ry</span><span class="s3">) = (</span><span class="s1">rx</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">], </span><span class="s1">ry</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">])</span>
    <span class="s1">C </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">([((</span><span class="s1">ry</span><span class="s3">[</span><span class="s1">i</span><span class="s3">+</span><span class="s6">1</span><span class="s3">:] &gt; </span><span class="s1">ry</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]) * (</span><span class="s1">rx</span><span class="s3">[</span><span class="s1">i</span><span class="s3">+</span><span class="s6">1</span><span class="s3">:] &gt; </span><span class="s1">rx</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])).</span><span class="s1">filled</span><span class="s3">(</span><span class="s6">0</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">()</span>
                <span class="s5">for </span><span class="s1">i </span><span class="s5">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">ry</span><span class="s3">)-</span><span class="s6">1</span><span class="s3">)], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">)</span>
    <span class="s1">D </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">([((</span><span class="s1">ry</span><span class="s3">[</span><span class="s1">i</span><span class="s3">+</span><span class="s6">1</span><span class="s3">:] &lt; </span><span class="s1">ry</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])*(</span><span class="s1">rx</span><span class="s3">[</span><span class="s1">i</span><span class="s3">+</span><span class="s6">1</span><span class="s3">:] &gt; </span><span class="s1">rx</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])).</span><span class="s1">filled</span><span class="s3">(</span><span class="s6">0</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">()</span>
                <span class="s5">for </span><span class="s1">i </span><span class="s5">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">ry</span><span class="s3">)-</span><span class="s6">1</span><span class="s3">)], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">)</span>
    <span class="s1">xties </span><span class="s3">= </span><span class="s1">count_tied_groups</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">yties </span><span class="s3">= </span><span class="s1">count_tied_groups</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">use_ties</span><span class="s3">:</span>
        <span class="s1">corr_x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">([</span><span class="s1">v</span><span class="s3">*</span><span class="s1">k</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">) </span><span class="s5">for </span><span class="s3">(</span><span class="s1">k</span><span class="s3">,</span><span class="s1">v</span><span class="s3">) </span><span class="s5">in </span><span class="s1">xties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">)</span>
        <span class="s1">corr_y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">([</span><span class="s1">v</span><span class="s3">*</span><span class="s1">k</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">) </span><span class="s5">for </span><span class="s3">(</span><span class="s1">k</span><span class="s3">,</span><span class="s1">v</span><span class="s3">) </span><span class="s5">in </span><span class="s1">yties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">)</span>
        <span class="s1">denom </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">((</span><span class="s1">n</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)-</span><span class="s1">corr_x</span><span class="s3">)/</span><span class="s6">2. </span><span class="s3">* (</span><span class="s1">n</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)-</span><span class="s1">corr_y</span><span class="s3">)/</span><span class="s6">2.</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">denom </span><span class="s3">= </span><span class="s1">n</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)/</span><span class="s6">2.</span>
    <span class="s1">tau </span><span class="s3">= (</span><span class="s1">C</span><span class="s3">-</span><span class="s1">D</span><span class="s3">) / </span><span class="s1">denom</span>

    <span class="s5">if </span><span class="s1">method </span><span class="s3">== </span><span class="s4">'exact' </span><span class="s5">and </span><span class="s3">(</span><span class="s1">xties </span><span class="s5">or </span><span class="s1">yties</span><span class="s3">):</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Ties found, exact method cannot be used.&quot;</span><span class="s3">)</span>

    <span class="s5">if </span><span class="s1">method </span><span class="s3">== </span><span class="s4">'auto'</span><span class="s3">:</span>
        <span class="s5">if </span><span class="s3">(</span><span class="s5">not </span><span class="s1">xties </span><span class="s5">and not </span><span class="s1">yties</span><span class="s3">) </span><span class="s5">and </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s6">33 </span><span class="s5">or </span><span class="s1">min</span><span class="s3">(</span><span class="s1">C</span><span class="s3">, </span><span class="s1">n</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)/</span><span class="s6">2.0</span><span class="s3">-</span><span class="s1">C</span><span class="s3">) &lt;= </span><span class="s6">1</span><span class="s3">):</span>
            <span class="s1">method </span><span class="s3">= </span><span class="s4">'exact'</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">method </span><span class="s3">= </span><span class="s4">'asymptotic'</span>

    <span class="s5">if not </span><span class="s1">xties </span><span class="s5">and not </span><span class="s1">yties </span><span class="s5">and </span><span class="s1">method </span><span class="s3">== </span><span class="s4">'exact'</span><span class="s3">:</span>
        <span class="s1">prob </span><span class="s3">= </span><span class="s1">_kendall_p_exact</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">C</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">)</span>

    <span class="s5">elif </span><span class="s1">method </span><span class="s3">== </span><span class="s4">'asymptotic'</span><span class="s3">:</span>
        <span class="s1">var_s </span><span class="s3">= </span><span class="s1">n</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)*(</span><span class="s6">2</span><span class="s3">*</span><span class="s1">n</span><span class="s3">+</span><span class="s6">5</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">use_ties</span><span class="s3">:</span>
            <span class="s1">var_s </span><span class="s3">-= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">([</span><span class="s1">v</span><span class="s3">*</span><span class="s1">k</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)*(</span><span class="s6">2</span><span class="s3">*</span><span class="s1">k</span><span class="s3">+</span><span class="s6">5</span><span class="s3">)*</span><span class="s6">1. </span><span class="s5">for </span><span class="s3">(</span><span class="s1">k</span><span class="s3">,</span><span class="s1">v</span><span class="s3">) </span><span class="s5">in </span><span class="s1">xties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()])</span>
            <span class="s1">var_s </span><span class="s3">-= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">([</span><span class="s1">v</span><span class="s3">*</span><span class="s1">k</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)*(</span><span class="s6">2</span><span class="s3">*</span><span class="s1">k</span><span class="s3">+</span><span class="s6">5</span><span class="s3">)*</span><span class="s6">1. </span><span class="s5">for </span><span class="s3">(</span><span class="s1">k</span><span class="s3">,</span><span class="s1">v</span><span class="s3">) </span><span class="s5">in </span><span class="s1">yties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()])</span>
            <span class="s1">v1 </span><span class="s3">= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">([</span><span class="s1">v</span><span class="s3">*</span><span class="s1">k</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">) </span><span class="s5">for </span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">) </span><span class="s5">in </span><span class="s1">xties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">) *</span>
                  <span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">([</span><span class="s1">v</span><span class="s3">*</span><span class="s1">k</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">) </span><span class="s5">for </span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">) </span><span class="s5">in </span><span class="s1">yties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">))</span>
            <span class="s1">v1 </span><span class="s3">/= </span><span class="s6">2.</span><span class="s3">*</span><span class="s1">n</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)</span>
            <span class="s5">if </span><span class="s1">n </span><span class="s3">&gt; </span><span class="s6">2</span><span class="s3">:</span>
                <span class="s1">v2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">([</span><span class="s1">v</span><span class="s3">*</span><span class="s1">k</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)*(</span><span class="s1">k</span><span class="s3">-</span><span class="s6">2</span><span class="s3">) </span><span class="s5">for </span><span class="s3">(</span><span class="s1">k</span><span class="s3">,</span><span class="s1">v</span><span class="s3">) </span><span class="s5">in </span><span class="s1">xties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()],</span>
                            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">) * </span><span class="s1">\</span>
                     <span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">([</span><span class="s1">v</span><span class="s3">*</span><span class="s1">k</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)*(</span><span class="s1">k</span><span class="s3">-</span><span class="s6">2</span><span class="s3">) </span><span class="s5">for </span><span class="s3">(</span><span class="s1">k</span><span class="s3">,</span><span class="s1">v</span><span class="s3">) </span><span class="s5">in </span><span class="s1">yties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()],</span>
                            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">)</span>
                <span class="s1">v2 </span><span class="s3">/= </span><span class="s6">9.</span><span class="s3">*</span><span class="s1">n</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">2</span><span class="s3">)</span>
            <span class="s5">else</span><span class="s3">:</span>
                <span class="s1">v2 </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">v1 </span><span class="s3">= </span><span class="s1">v2 </span><span class="s3">= </span><span class="s6">0</span>

        <span class="s1">var_s </span><span class="s3">/= </span><span class="s6">18.</span>
        <span class="s1">var_s </span><span class="s3">+= (</span><span class="s1">v1 </span><span class="s3">+ </span><span class="s1">v2</span><span class="s3">)</span>
        <span class="s1">z </span><span class="s3">= (</span><span class="s1">C</span><span class="s3">-</span><span class="s1">D</span><span class="s3">)/</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">var_s</span><span class="s3">)</span>
        <span class="s1">prob </span><span class="s3">= </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats</span><span class="s3">.</span><span class="s1">_stats_py</span><span class="s3">.</span><span class="s1">_get_pvalue</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">distributions</span><span class="s3">.</span><span class="s1">norm</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Unknown method &quot;</span><span class="s3">+</span><span class="s1">str</span><span class="s3">(</span><span class="s1">method</span><span class="s3">)+</span><span class="s4">&quot; specified, please &quot;</span>
                         <span class="s4">&quot;use auto, exact or asymptotic.&quot;</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats</span><span class="s3">.</span><span class="s1">_stats_py</span><span class="s3">.</span><span class="s1">SignificanceResult</span><span class="s3">(</span><span class="s1">tau</span><span class="s3">[()], </span><span class="s1">prob</span><span class="s3">[()])</span>
    <span class="s1">res</span><span class="s3">.</span><span class="s1">correlation </span><span class="s3">= </span><span class="s1">tau</span>
    <span class="s5">return </span><span class="s1">res</span>


<span class="s5">def </span><span class="s1">kendalltau_seasonal</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes a multivariate Kendall's rank correlation tau, for seasonal data. 
 
    Parameters 
    ---------- 
    x : 2-D ndarray 
        Array of seasonal data, with seasons in columns. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">subok</span><span class="s3">=</span><span class="s5">True</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">False</span><span class="s3">, </span><span class="s1">ndmin</span><span class="s3">=</span><span class="s6">2</span><span class="s3">)</span>
    <span class="s3">(</span><span class="s1">n</span><span class="s3">,</span><span class="s1">m</span><span class="s3">) = </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s1">n_p </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>

    <span class="s1">S_szn </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">msign</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">:]-</span><span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]).</span><span class="s1">sum</span><span class="s3">(</span><span class="s6">0</span><span class="s3">) </span><span class="s5">for </span><span class="s1">i </span><span class="s5">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">))</span>
    <span class="s1">S_tot </span><span class="s3">= </span><span class="s1">S_szn</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">()</span>

    <span class="s1">n_tot </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">count</span><span class="s3">()</span>
    <span class="s1">ties </span><span class="s3">= </span><span class="s1">count_tied_groups</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">compressed</span><span class="s3">())</span>
    <span class="s1">corr_ties </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">v</span><span class="s3">*</span><span class="s1">k</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">) </span><span class="s5">for </span><span class="s3">(</span><span class="s1">k</span><span class="s3">,</span><span class="s1">v</span><span class="s3">) </span><span class="s5">in </span><span class="s1">ties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())</span>
    <span class="s1">denom_tot </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s6">1.</span><span class="s3">*</span><span class="s1">n_tot</span><span class="s3">*(</span><span class="s1">n_tot</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)*(</span><span class="s1">n_tot</span><span class="s3">*(</span><span class="s1">n_tot</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)-</span><span class="s1">corr_ties</span><span class="s3">))/</span><span class="s6">2.</span>

    <span class="s1">R </span><span class="s3">= </span><span class="s1">rankdata</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">use_missing</span><span class="s3">=</span><span class="s5">True</span><span class="s3">)</span>
    <span class="s1">K </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">m</span><span class="s3">,</span><span class="s1">m</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">int</span><span class="s3">)</span>
    <span class="s1">covmat </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">m</span><span class="s3">,</span><span class="s1">m</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">)</span>
    <span class="s1">denom_szn </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">)</span>
    <span class="s5">for </span><span class="s1">j </span><span class="s5">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">m</span><span class="s3">):</span>
        <span class="s1">ties_j </span><span class="s3">= </span><span class="s1">count_tied_groups</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[:,</span><span class="s1">j</span><span class="s3">].</span><span class="s1">compressed</span><span class="s3">())</span>
        <span class="s1">corr_j </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">v</span><span class="s3">*</span><span class="s1">k</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">) </span><span class="s5">for </span><span class="s3">(</span><span class="s1">k</span><span class="s3">,</span><span class="s1">v</span><span class="s3">) </span><span class="s5">in </span><span class="s1">ties_j</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())</span>
        <span class="s1">cmb </span><span class="s3">= </span><span class="s1">n_p</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]*(</span><span class="s1">n_p</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]-</span><span class="s6">1</span><span class="s3">)</span>
        <span class="s5">for </span><span class="s1">k </span><span class="s5">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">j</span><span class="s3">,</span><span class="s1">m</span><span class="s3">,</span><span class="s6">1</span><span class="s3">):</span>
            <span class="s1">K</span><span class="s3">[</span><span class="s1">j</span><span class="s3">,</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">msign</span><span class="s3">((</span><span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">:,</span><span class="s1">j</span><span class="s3">]-</span><span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">,</span><span class="s1">j</span><span class="s3">])*(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">:,</span><span class="s1">k</span><span class="s3">]-</span><span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">,</span><span class="s1">k</span><span class="s3">])).</span><span class="s1">sum</span><span class="s3">()</span>
                         <span class="s5">for </span><span class="s1">i </span><span class="s5">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">))</span>
            <span class="s1">covmat</span><span class="s3">[</span><span class="s1">j</span><span class="s3">,</span><span class="s1">k</span><span class="s3">] = (</span><span class="s1">K</span><span class="s3">[</span><span class="s1">j</span><span class="s3">,</span><span class="s1">k</span><span class="s3">] + </span><span class="s6">4</span><span class="s3">*(</span><span class="s1">R</span><span class="s3">[:,</span><span class="s1">j</span><span class="s3">]*</span><span class="s1">R</span><span class="s3">[:,</span><span class="s1">k</span><span class="s3">]).</span><span class="s1">sum</span><span class="s3">() -</span>
                           <span class="s1">n</span><span class="s3">*(</span><span class="s1">n_p</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]+</span><span class="s6">1</span><span class="s3">)*(</span><span class="s1">n_p</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]+</span><span class="s6">1</span><span class="s3">))/</span><span class="s6">3.</span>
            <span class="s1">K</span><span class="s3">[</span><span class="s1">k</span><span class="s3">,</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">K</span><span class="s3">[</span><span class="s1">j</span><span class="s3">,</span><span class="s1">k</span><span class="s3">]</span>
            <span class="s1">covmat</span><span class="s3">[</span><span class="s1">k</span><span class="s3">,</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">covmat</span><span class="s3">[</span><span class="s1">j</span><span class="s3">,</span><span class="s1">k</span><span class="s3">]</span>

        <span class="s1">denom_szn</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">cmb</span><span class="s3">*(</span><span class="s1">cmb</span><span class="s3">-</span><span class="s1">corr_j</span><span class="s3">)) / </span><span class="s6">2.</span>

    <span class="s1">var_szn </span><span class="s3">= </span><span class="s1">covmat</span><span class="s3">.</span><span class="s1">diagonal</span><span class="s3">()</span>

    <span class="s1">z_szn </span><span class="s3">= </span><span class="s1">msign</span><span class="s3">(</span><span class="s1">S_szn</span><span class="s3">) * (</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">S_szn</span><span class="s3">)-</span><span class="s6">1</span><span class="s3">) / </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">var_szn</span><span class="s3">)</span>
    <span class="s1">z_tot_ind </span><span class="s3">= </span><span class="s1">msign</span><span class="s3">(</span><span class="s1">S_tot</span><span class="s3">) * (</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">S_tot</span><span class="s3">)-</span><span class="s6">1</span><span class="s3">) / </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">var_szn</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">())</span>
    <span class="s1">z_tot_dep </span><span class="s3">= </span><span class="s1">msign</span><span class="s3">(</span><span class="s1">S_tot</span><span class="s3">) * (</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">S_tot</span><span class="s3">)-</span><span class="s6">1</span><span class="s3">) / </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">covmat</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">())</span>

    <span class="s1">prob_szn </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">erfc</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">z_szn</span><span class="s3">.</span><span class="s1">data</span><span class="s3">)/</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s6">2</span><span class="s3">))</span>
    <span class="s1">prob_tot_ind </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">erfc</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">z_tot_ind</span><span class="s3">)/</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s6">2</span><span class="s3">))</span>
    <span class="s1">prob_tot_dep </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">erfc</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">z_tot_dep</span><span class="s3">)/</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s6">2</span><span class="s3">))</span>

    <span class="s1">chi2_tot </span><span class="s3">= (</span><span class="s1">z_szn</span><span class="s3">*</span><span class="s1">z_szn</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">()</span>
    <span class="s1">chi2_trd </span><span class="s3">= </span><span class="s1">m </span><span class="s3">* </span><span class="s1">z_szn</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">()**</span><span class="s6">2</span>
    <span class="s1">output </span><span class="s3">= {</span><span class="s4">'seasonal tau'</span><span class="s3">: </span><span class="s1">S_szn</span><span class="s3">/</span><span class="s1">denom_szn</span><span class="s3">,</span>
              <span class="s4">'global tau'</span><span class="s3">: </span><span class="s1">S_tot</span><span class="s3">/</span><span class="s1">denom_tot</span><span class="s3">,</span>
              <span class="s4">'global tau (alt)'</span><span class="s3">: </span><span class="s1">S_tot</span><span class="s3">/</span><span class="s1">denom_szn</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(),</span>
              <span class="s4">'seasonal p-value'</span><span class="s3">: </span><span class="s1">prob_szn</span><span class="s3">,</span>
              <span class="s4">'global p-value (indep)'</span><span class="s3">: </span><span class="s1">prob_tot_ind</span><span class="s3">,</span>
              <span class="s4">'global p-value (dep)'</span><span class="s3">: </span><span class="s1">prob_tot_dep</span><span class="s3">,</span>
              <span class="s4">'chi2 total'</span><span class="s3">: </span><span class="s1">chi2_tot</span><span class="s3">,</span>
              <span class="s4">'chi2 trend'</span><span class="s3">: </span><span class="s1">chi2_trd</span><span class="s3">,</span>
              <span class="s3">}</span>
    <span class="s5">return </span><span class="s1">output</span>


<span class="s1">PointbiserialrResult </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'PointbiserialrResult'</span><span class="s3">, (</span><span class="s4">'correlation'</span><span class="s3">,</span>
                                                           <span class="s4">'pvalue'</span><span class="s3">))</span>


<span class="s5">def </span><span class="s1">pointbiserialr</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Calculates a point biserial correlation coefficient and its p-value. 
 
    Parameters 
    ---------- 
    x : array_like of bools 
        Input array. 
    y : array_like 
        Input array. 
 
    Returns 
    ------- 
    correlation : float 
        R value 
    pvalue : float 
        2-tailed p-value 
 
    Notes 
    ----- 
    Missing values are considered pair-wise: if a value is missing in x, 
    the corresponding value in y is masked. 
 
    For more details on `pointbiserialr`, see `scipy.stats.pointbiserialr`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">fix_invalid</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">True</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">fix_invalid</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">True</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">)</span>
    <span class="s2"># Get rid of the missing data</span>
    <span class="s1">m </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">mask_or</span><span class="s3">(</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">getmask</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">getmask</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>
    <span class="s5">if </span><span class="s1">m </span><span class="s5">is not </span><span class="s1">nomask</span><span class="s3">:</span>
        <span class="s1">unmask </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">logical_not</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[</span><span class="s1">unmask</span><span class="s3">]</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">y</span><span class="s3">[</span><span class="s1">unmask</span><span class="s3">]</span>

    <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2"># phat is the fraction of x values that are True</span>
    <span class="s1">phat </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">() / </span><span class="s1">float</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">y0 </span><span class="s3">= </span><span class="s1">y</span><span class="s3">[~</span><span class="s1">x</span><span class="s3">]  </span><span class="s2"># y-values where x is False</span>
    <span class="s1">y1 </span><span class="s3">= </span><span class="s1">y</span><span class="s3">[</span><span class="s1">x</span><span class="s3">]  </span><span class="s2"># y-values where x is True</span>
    <span class="s1">y0m </span><span class="s3">= </span><span class="s1">y0</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">()</span>
    <span class="s1">y1m </span><span class="s3">= </span><span class="s1">y1</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">()</span>

    <span class="s1">rpb </span><span class="s3">= (</span><span class="s1">y1m </span><span class="s3">- </span><span class="s1">y0m</span><span class="s3">)*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">phat </span><span class="s3">* (</span><span class="s6">1</span><span class="s3">-</span><span class="s1">phat</span><span class="s3">)) / </span><span class="s1">y</span><span class="s3">.</span><span class="s1">std</span><span class="s3">()</span>

    <span class="s1">df </span><span class="s3">= </span><span class="s1">n</span><span class="s3">-</span><span class="s6">2</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">rpb</span><span class="s3">*</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">df</span><span class="s3">/(</span><span class="s6">1.0</span><span class="s3">-</span><span class="s1">rpb</span><span class="s3">**</span><span class="s6">2</span><span class="s3">))</span>
    <span class="s1">prob </span><span class="s3">= </span><span class="s1">_betai</span><span class="s3">(</span><span class="s6">0.5</span><span class="s3">*</span><span class="s1">df</span><span class="s3">, </span><span class="s6">0.5</span><span class="s3">, </span><span class="s1">df</span><span class="s3">/(</span><span class="s1">df</span><span class="s3">+</span><span class="s1">t</span><span class="s3">*</span><span class="s1">t</span><span class="s3">))</span>

    <span class="s5">return </span><span class="s1">PointbiserialrResult</span><span class="s3">(</span><span class="s1">rpb</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">linregress</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Calculate a linear least-squares regression for two sets of measurements. 
 
    Parameters 
    ---------- 
    x, y : array_like 
        Two sets of measurements.  Both arrays should have the same length N.  If 
        only `x` is given (and ``y=None``), then it must be a two-dimensional 
        array where one dimension has length 2.  The two sets of measurements 
        are then found by splitting the array along the length-2 dimension. In 
        the case where ``y=None`` and `x` is a 2xN array, ``linregress(x)`` is 
        equivalent to ``linregress(x[0], x[1])``. 
 
    Returns 
    ------- 
    result : ``LinregressResult`` instance 
        The return value is an object with the following attributes: 
 
        slope : float 
            Slope of the regression line. 
        intercept : float 
            Intercept of the regression line. 
        rvalue : float 
            The Pearson correlation coefficient. The square of ``rvalue`` 
            is equal to the coefficient of determination. 
        pvalue : float 
            The p-value for a hypothesis test whose null hypothesis is 
            that the slope is zero, using Wald Test with t-distribution of 
            the test statistic. See `alternative` above for alternative 
            hypotheses. 
        stderr : float 
            Standard error of the estimated slope (gradient), under the 
            assumption of residual normality. 
        intercept_stderr : float 
            Standard error of the estimated intercept, under the assumption 
            of residual normality. 
 
    See Also 
    -------- 
    scipy.optimize.curve_fit : 
        Use non-linear least squares to fit a function to data. 
    scipy.optimize.leastsq : 
        Minimize the sum of squares of a set of equations. 
 
    Notes 
    ----- 
    Missing values are considered pair-wise: if a value is missing in `x`, 
    the corresponding value in `y` is masked. 
 
    For compatibility with older versions of SciPy, the return value acts 
    like a ``namedtuple`` of length 5, with fields ``slope``, ``intercept``, 
    ``rvalue``, ``pvalue`` and ``stderr``, so one can continue to write:: 
 
        slope, intercept, r, p, se = linregress(x, y) 
 
    With that style, however, the standard error of the intercept is not 
    available.  To have access to all the computed values, including the 
    standard error of the intercept, use the return value as an object 
    with attributes, e.g.:: 
 
        result = linregress(x, y) 
        print(result.intercept, result.intercept_stderr) 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; rng = np.random.default_rng() 
 
    Generate some data: 
 
    &gt;&gt;&gt; x = rng.random(10) 
    &gt;&gt;&gt; y = 1.6*x + rng.random(10) 
 
    Perform the linear regression: 
 
    &gt;&gt;&gt; res = stats.mstats.linregress(x, y) 
 
    Coefficient of determination (R-squared): 
 
    &gt;&gt;&gt; print(f&quot;R-squared: {res.rvalue**2:.6f}&quot;) 
    R-squared: 0.717533 
 
    Plot the data along with the fitted line: 
 
    &gt;&gt;&gt; plt.plot(x, y, 'o', label='original data') 
    &gt;&gt;&gt; plt.plot(x, res.intercept + res.slope*x, 'r', label='fitted line') 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.show() 
 
    Calculate 95% confidence interval on slope and intercept: 
 
    &gt;&gt;&gt; # Two-sided inverse Students t-distribution 
    &gt;&gt;&gt; # p - probability, df - degrees of freedom 
    &gt;&gt;&gt; from scipy.stats import t 
    &gt;&gt;&gt; tinv = lambda p, df: abs(t.ppf(p/2, df)) 
 
    &gt;&gt;&gt; ts = tinv(0.05, len(x)-2) 
    &gt;&gt;&gt; print(f&quot;slope (95%): {res.slope:.6f} +/- {ts*res.stderr:.6f}&quot;) 
    slope (95%): 1.453392 +/- 0.743465 
    &gt;&gt;&gt; print(f&quot;intercept (95%): {res.intercept:.6f}&quot; 
    ...       f&quot; +/- {ts*res.intercept_stderr:.6f}&quot;) 
    intercept (95%): 0.616950 +/- 0.544475 
 
    &quot;&quot;&quot;</span>
    <span class="s5">if </span><span class="s1">y </span><span class="s5">is None</span><span class="s3">:</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] == </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">x</span>
        <span class="s5">elif </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] == </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">T</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;If only `x` is given as input, &quot;</span>
                             <span class="s4">&quot;it has to be of shape (2, N) or (N, 2), &quot;</span>
                             <span class="s4">f&quot;provided shape was </span><span class="s5">{</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s5">}</span><span class="s4">&quot;</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">flatten</span><span class="s3">()</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">flatten</span><span class="s3">()</span>

    <span class="s5">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">amax</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) == </span><span class="s1">np</span><span class="s3">.</span><span class="s1">amin</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s5">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) &gt; </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Cannot calculate a linear regression &quot;</span>
                         <span class="s4">&quot;if all x values are identical&quot;</span><span class="s3">)</span>

    <span class="s1">m </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">mask_or</span><span class="s3">(</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">getmask</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">getmask</span><span class="s3">(</span><span class="s1">y</span><span class="s3">), </span><span class="s1">shrink</span><span class="s3">=</span><span class="s5">False</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">m </span><span class="s5">is not </span><span class="s1">nomask</span><span class="s3">:</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">=</span><span class="s1">m</span><span class="s3">)</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">=</span><span class="s1">m</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(~</span><span class="s1">m</span><span class="s3">):</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">_stats_py</span><span class="s3">.</span><span class="s1">linregress</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[~</span><span class="s1">m</span><span class="s3">], </span><span class="s1">y</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[~</span><span class="s1">m</span><span class="s3">])</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s2"># All data is masked</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">_stats_py</span><span class="s3">.</span><span class="s1">LinregressResult</span><span class="s3">(</span><span class="s1">slope</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">intercept</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
                                                <span class="s1">rvalue</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">pvalue</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
                                                <span class="s1">stderr</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
                                                <span class="s1">intercept_stderr</span><span class="s3">=</span><span class="s5">None</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">_stats_py</span><span class="s3">.</span><span class="s1">linregress</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">y</span><span class="s3">.</span><span class="s1">data</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">result</span>


<span class="s5">def </span><span class="s1">theilslopes</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">=</span><span class="s6">0.95</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">'separate'</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Computes the Theil-Sen estimator for a set of points (x, y). 
 
    `theilslopes` implements a method for robust linear regression.  It 
    computes the slope as the median of all slopes between paired values. 
 
    Parameters 
    ---------- 
    y : array_like 
        Dependent variable. 
    x : array_like or None, optional 
        Independent variable. If None, use ``arange(len(y))`` instead. 
    alpha : float, optional 
        Confidence degree between 0 and 1. Default is 95% confidence. 
        Note that `alpha` is symmetric around 0.5, i.e. both 0.1 and 0.9 are 
        interpreted as &quot;find the 90% confidence interval&quot;. 
    method : {'joint', 'separate'}, optional 
        Method to be used for computing estimate for intercept. 
        Following methods are supported, 
 
            * 'joint': Uses np.median(y - slope * x) as intercept. 
            * 'separate': Uses np.median(y) - slope * np.median(x) 
                          as intercept. 
 
        The default is 'separate'. 
 
        .. versionadded:: 1.8.0 
 
    Returns 
    ------- 
    result : ``TheilslopesResult`` instance 
        The return value is an object with the following attributes: 
 
        slope : float 
            Theil slope. 
        intercept : float 
            Intercept of the Theil line. 
        low_slope : float 
            Lower bound of the confidence interval on `slope`. 
        high_slope : float 
            Upper bound of the confidence interval on `slope`. 
 
    See Also 
    -------- 
    siegelslopes : a similar technique using repeated medians 
 
 
    Notes 
    ----- 
    For more details on `theilslopes`, see `scipy.stats.theilslopes`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">).</span><span class="s1">flatten</span><span class="s3">()</span>
    <span class="s5">if </span><span class="s1">x </span><span class="s5">is None</span><span class="s3">:</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">flatten</span><span class="s3">()</span>
        <span class="s5">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;Incompatible lengths ! (</span><span class="s5">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span><span class="s5">}</span><span class="s4">&lt;&gt;</span><span class="s5">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span><span class="s5">}</span><span class="s4">)&quot;</span><span class="s3">)</span>

    <span class="s1">m </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">mask_or</span><span class="s3">(</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">getmask</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">getmask</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>
    <span class="s1">y</span><span class="s3">.</span><span class="s1">_mask </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">_mask </span><span class="s3">= </span><span class="s1">m</span>
    <span class="s2"># Disregard any masked elements of x or y</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">compressed</span><span class="s3">()</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">compressed</span><span class="s3">().</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">)</span>
    <span class="s2"># We now have unmasked arrays so can use `scipy.stats.theilslopes`</span>
    <span class="s5">return </span><span class="s1">stats_theilslopes</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">=</span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s1">method</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">siegelslopes</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">&quot;hierarchical&quot;</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Computes the Siegel estimator for a set of points (x, y). 
 
    `siegelslopes` implements a method for robust linear regression 
    using repeated medians to fit a line to the points (x, y). 
    The method is robust to outliers with an asymptotic breakdown point 
    of 50%. 
 
    Parameters 
    ---------- 
    y : array_like 
        Dependent variable. 
    x : array_like or None, optional 
        Independent variable. If None, use ``arange(len(y))`` instead. 
    method : {'hierarchical', 'separate'} 
        If 'hierarchical', estimate the intercept using the estimated 
        slope ``slope`` (default option). 
        If 'separate', estimate the intercept independent of the estimated 
        slope. See Notes for details. 
 
    Returns 
    ------- 
    result : ``SiegelslopesResult`` instance 
        The return value is an object with the following attributes: 
 
        slope : float 
            Estimate of the slope of the regression line. 
        intercept : float 
            Estimate of the intercept of the regression line. 
 
    See Also 
    -------- 
    theilslopes : a similar technique without repeated medians 
 
    Notes 
    ----- 
    For more details on `siegelslopes`, see `scipy.stats.siegelslopes`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">).</span><span class="s1">ravel</span><span class="s3">()</span>
    <span class="s5">if </span><span class="s1">x </span><span class="s5">is None</span><span class="s3">:</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">ravel</span><span class="s3">()</span>
        <span class="s5">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;Incompatible lengths ! (</span><span class="s5">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span><span class="s5">}</span><span class="s4">&lt;&gt;</span><span class="s5">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span><span class="s5">}</span><span class="s4">)&quot;</span><span class="s3">)</span>

    <span class="s1">m </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">mask_or</span><span class="s3">(</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">getmask</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">getmask</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>
    <span class="s1">y</span><span class="s3">.</span><span class="s1">_mask </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">_mask </span><span class="s3">= </span><span class="s1">m</span>
    <span class="s2"># Disregard any masked elements of x or y</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">compressed</span><span class="s3">()</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">compressed</span><span class="s3">().</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">)</span>
    <span class="s2"># We now have unmasked arrays so can use `scipy.stats.siegelslopes`</span>
    <span class="s5">return </span><span class="s1">stats_siegelslopes</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s1">method</span><span class="s3">)</span>


<span class="s1">SenSeasonalSlopesResult </span><span class="s3">= </span><span class="s1">_make_tuple_bunch</span><span class="s3">(</span><span class="s4">'SenSeasonalSlopesResult'</span><span class="s3">,</span>
                                            <span class="s3">[</span><span class="s4">'intra_slope'</span><span class="s3">, </span><span class="s4">'inter_slope'</span><span class="s3">])</span>


<span class="s5">def </span><span class="s1">sen_seasonal_slopes</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Computes seasonal Theil-Sen and Kendall slope estimators. 
 
    The seasonal generalization of Sen's slope computes the slopes between all 
    pairs of values within a &quot;season&quot; (column) of a 2D array. It returns an 
    array containing the median of these &quot;within-season&quot; slopes for each 
    season (the Theil-Sen slope estimator of each season), and it returns the 
    median of the within-season slopes across all seasons (the seasonal Kendall 
    slope estimator). 
 
    Parameters 
    ---------- 
    x : 2D array_like 
        Each column of `x` contains measurements of the dependent variable 
        within a season. The independent variable (usually time) of each season 
        is assumed to be ``np.arange(x.shape[0])``. 
 
    Returns 
    ------- 
    result : ``SenSeasonalSlopesResult`` instance 
        The return value is an object with the following attributes: 
 
        intra_slope : ndarray 
            For each season, the Theil-Sen slope estimator: the median of 
            within-season slopes. 
        inter_slope : float 
            The seasonal Kendall slope estimateor: the median of within-season 
            slopes *across all* seasons. 
 
    See Also 
    -------- 
    theilslopes : the analogous function for non-seasonal data 
    scipy.stats.theilslopes : non-seasonal slopes for non-masked arrays 
 
    Notes 
    ----- 
    The slopes :math:`d_{ijk}` within season :math:`i` are: 
 
    .. math:: 
 
        d_{ijk} = \frac{x_{ij} - x_{ik}} 
                            {j - k} 
 
    for pairs of distinct integer indices :math:`j, k` of :math:`x`. 
 
    Element :math:`i` of the returned `intra_slope` array is the median of the 
    :math:`d_{ijk}` over all :math:`j &lt; k`; this is the Theil-Sen slope 
    estimator of season :math:`i`. The returned `inter_slope` value, better 
    known as the seasonal Kendall slope estimator, is the median of the 
    :math:`d_{ijk}` over all :math:`i, j, k`. 
 
    References 
    ---------- 
    .. [1] Hirsch, Robert M., James R. Slack, and Richard A. Smith. 
           &quot;Techniques of trend analysis for monthly water quality data.&quot; 
           *Water Resources Research* 18.1 (1982): 107-121. 
 
    Examples 
    -------- 
    Suppose we have 100 observations of a dependent variable for each of four 
    seasons: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; x = rng.random(size=(100, 4)) 
 
    We compute the seasonal slopes as: 
 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; intra_slope, inter_slope = stats.mstats.sen_seasonal_slopes(x) 
 
    If we define a function to compute all slopes between observations within 
    a season: 
 
    &gt;&gt;&gt; def dijk(yi): 
    ...     n = len(yi) 
    ...     x = np.arange(n) 
    ...     dy = yi - yi[:, np.newaxis] 
    ...     dx = x - x[:, np.newaxis] 
    ...     # we only want unique pairs of distinct indices 
    ...     mask = np.triu(np.ones((n, n), dtype=bool), k=1) 
    ...     return dy[mask]/dx[mask] 
 
    then element ``i`` of ``intra_slope`` is the median of ``dijk[x[:, i]]``: 
 
    &gt;&gt;&gt; i = 2 
    &gt;&gt;&gt; np.allclose(np.median(dijk(x[:, i])), intra_slope[i]) 
    True 
 
    and ``inter_slope`` is the median of the values returned by ``dijk`` for 
    all seasons: 
 
    &gt;&gt;&gt; all_slopes = np.concatenate([dijk(x[:, i]) for i in range(x.shape[1])]) 
    &gt;&gt;&gt; np.allclose(np.median(all_slopes), inter_slope) 
    True 
 
    Because the data are randomly generated, we would expect the median slopes 
    to be nearly zero both within and across all seasons, and indeed they are: 
 
    &gt;&gt;&gt; intra_slope.data 
    array([ 0.00124504, -0.00277761, -0.00221245, -0.00036338]) 
    &gt;&gt;&gt; inter_slope 
    -0.0010511779872922058 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">subok</span><span class="s3">=</span><span class="s5">True</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">False</span><span class="s3">, </span><span class="s1">ndmin</span><span class="s3">=</span><span class="s6">2</span><span class="s3">)</span>
    <span class="s3">(</span><span class="s1">n</span><span class="s3">,</span><span class="s1">_</span><span class="s3">) = </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s2"># Get list of slopes per season</span>
    <span class="s1">szn_slopes </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">([(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">+</span><span class="s6">1</span><span class="s3">:]-</span><span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])/</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">1</span><span class="s3">,</span><span class="s1">n</span><span class="s3">-</span><span class="s1">i</span><span class="s3">)[:,</span><span class="s5">None</span><span class="s3">]</span>
                            <span class="s5">for </span><span class="s1">i </span><span class="s5">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)])</span>
    <span class="s1">szn_medslopes </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">median</span><span class="s3">(</span><span class="s1">szn_slopes</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">medslope </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">median</span><span class="s3">(</span><span class="s1">szn_slopes</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s1">SenSeasonalSlopesResult</span><span class="s3">(</span><span class="s1">szn_medslopes</span><span class="s3">, </span><span class="s1">medslope</span><span class="s3">)</span>


<span class="s1">Ttest_1sampResult </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'Ttest_1sampResult'</span><span class="s3">, (</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s3">))</span>


<span class="s5">def </span><span class="s1">ttest_1samp</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">popmean</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">=</span><span class="s4">'two-sided'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculates the T-test for the mean of ONE group of scores. 
 
    Parameters 
    ---------- 
    a : array_like 
        sample observation 
    popmean : float or array_like 
        expected value in null hypothesis, if array_like than it must have the 
        same shape as `a` excluding the axis dimension 
    axis : int or None, optional 
        Axis along which to compute test. If None, compute over the whole 
        array `a`. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. 
        The following options are available (default is 'two-sided'): 
 
        * 'two-sided': the mean of the underlying distribution of the sample 
          is different than the given population mean (`popmean`) 
        * 'less': the mean of the underlying distribution of the sample is 
          less than the given population mean (`popmean`) 
        * 'greater': the mean of the underlying distribution of the sample is 
          greater than the given population mean (`popmean`) 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    statistic : float or array 
        t-statistic 
    pvalue : float or array 
        The p-value 
 
    Notes 
    ----- 
    For more details on `ttest_1samp`, see `scipy.stats.ttest_1samp`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">= </span><span class="s1">_chk_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">)</span>

    <span class="s1">x </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">v </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">var</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s2"># force df to be an array for masked division not to throw a warning</span>
    <span class="s1">df </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">n </span><span class="s3">- </span><span class="s6">1.0</span><span class="s3">)</span>
    <span class="s1">svar </span><span class="s3">= ((</span><span class="s1">n </span><span class="s3">- </span><span class="s6">1.0</span><span class="s3">) * </span><span class="s1">v</span><span class="s3">) / </span><span class="s1">df</span>
    <span class="s5">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">divide</span><span class="s3">=</span><span class="s4">'ignore'</span><span class="s3">, </span><span class="s1">invalid</span><span class="s3">=</span><span class="s4">'ignore'</span><span class="s3">):</span>
        <span class="s1">t </span><span class="s3">= (</span><span class="s1">x </span><span class="s3">- </span><span class="s1">popmean</span><span class="s3">) / </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">svar </span><span class="s3">/ </span><span class="s1">n</span><span class="s3">)</span>

    <span class="s1">t</span><span class="s3">, </span><span class="s1">prob </span><span class="s3">= </span><span class="s1">_ttest_finish</span><span class="s3">(</span><span class="s1">df</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s1">Ttest_1sampResult</span><span class="s3">(</span><span class="s1">t</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">)</span>


<span class="s1">ttest_onesamp </span><span class="s3">= </span><span class="s1">ttest_1samp</span>


<span class="s1">Ttest_indResult </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'Ttest_indResult'</span><span class="s3">, (</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s3">))</span>


<span class="s5">def </span><span class="s1">ttest_ind</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">equal_var</span><span class="s3">=</span><span class="s5">True</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">=</span><span class="s4">'two-sided'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculates the T-test for the means of TWO INDEPENDENT samples of scores. 
 
    Parameters 
    ---------- 
    a, b : array_like 
        The arrays must have the same shape, except in the dimension 
        corresponding to `axis` (the first, by default). 
    axis : int or None, optional 
        Axis along which to compute test. If None, compute over the whole 
        arrays, `a`, and `b`. 
    equal_var : bool, optional 
        If True, perform a standard independent 2 sample test that assumes equal 
        population variances. 
        If False, perform Welch's t-test, which does not assume equal population 
        variance. 
 
        .. versionadded:: 0.17.0 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. 
        The following options are available (default is 'two-sided'): 
 
        * 'two-sided': the means of the distributions underlying the samples 
          are unequal. 
        * 'less': the mean of the distribution underlying the first sample 
          is less than the mean of the distribution underlying the second 
          sample. 
        * 'greater': the mean of the distribution underlying the first 
          sample is greater than the mean of the distribution underlying 
          the second sample. 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    statistic : float or array 
        The calculated t-statistic. 
    pvalue : float or array 
        The p-value. 
 
    Notes 
    ----- 
    For more details on `ttest_ind`, see `scipy.stats.ttest_ind`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">= </span><span class="s1">_chk2_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s5">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s6">0 </span><span class="s5">or </span><span class="s1">b</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">Ttest_indResult</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">)</span>

    <span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">) = (</span><span class="s1">a</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">), </span><span class="s1">b</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">))</span>
    <span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">v2</span><span class="s3">) = (</span><span class="s1">a</span><span class="s3">.</span><span class="s1">var</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s6">1</span><span class="s3">), </span><span class="s1">b</span><span class="s3">.</span><span class="s1">var</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s6">1</span><span class="s3">))</span>
    <span class="s3">(</span><span class="s1">n1</span><span class="s3">, </span><span class="s1">n2</span><span class="s3">) = (</span><span class="s1">a</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">), </span><span class="s1">b</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">))</span>

    <span class="s5">if </span><span class="s1">equal_var</span><span class="s3">:</span>
        <span class="s2"># force df to be an array for masked division not to throw a warning</span>
        <span class="s1">df </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">n1 </span><span class="s3">+ </span><span class="s1">n2 </span><span class="s3">- </span><span class="s6">2.0</span><span class="s3">)</span>
        <span class="s1">svar </span><span class="s3">= ((</span><span class="s1">n1</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)*</span><span class="s1">v1</span><span class="s3">+(</span><span class="s1">n2</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)*</span><span class="s1">v2</span><span class="s3">) / </span><span class="s1">df</span>
        <span class="s1">denom </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">svar</span><span class="s3">*(</span><span class="s6">1.0</span><span class="s3">/</span><span class="s1">n1 </span><span class="s3">+ </span><span class="s6">1.0</span><span class="s3">/</span><span class="s1">n2</span><span class="s3">))  </span><span class="s2"># n-D computation here!</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">vn1 </span><span class="s3">= </span><span class="s1">v1</span><span class="s3">/</span><span class="s1">n1</span>
        <span class="s1">vn2 </span><span class="s3">= </span><span class="s1">v2</span><span class="s3">/</span><span class="s1">n2</span>
        <span class="s5">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">divide</span><span class="s3">=</span><span class="s4">'ignore'</span><span class="s3">, </span><span class="s1">invalid</span><span class="s3">=</span><span class="s4">'ignore'</span><span class="s3">):</span>
            <span class="s1">df </span><span class="s3">= (</span><span class="s1">vn1 </span><span class="s3">+ </span><span class="s1">vn2</span><span class="s3">)**</span><span class="s6">2 </span><span class="s3">/ (</span><span class="s1">vn1</span><span class="s3">**</span><span class="s6">2 </span><span class="s3">/ (</span><span class="s1">n1 </span><span class="s3">- </span><span class="s6">1</span><span class="s3">) + </span><span class="s1">vn2</span><span class="s3">**</span><span class="s6">2 </span><span class="s3">/ (</span><span class="s1">n2 </span><span class="s3">- </span><span class="s6">1</span><span class="s3">))</span>

        <span class="s2"># If df is undefined, variances are zero.</span>
        <span class="s2"># It doesn't matter what df is as long as it is not NaN.</span>
        <span class="s1">df </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">df</span><span class="s3">), </span><span class="s6">1</span><span class="s3">, </span><span class="s1">df</span><span class="s3">)</span>
        <span class="s1">denom </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">vn1 </span><span class="s3">+ </span><span class="s1">vn2</span><span class="s3">)</span>

    <span class="s5">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">divide</span><span class="s3">=</span><span class="s4">'ignore'</span><span class="s3">, </span><span class="s1">invalid</span><span class="s3">=</span><span class="s4">'ignore'</span><span class="s3">):</span>
        <span class="s1">t </span><span class="s3">= (</span><span class="s1">x1</span><span class="s3">-</span><span class="s1">x2</span><span class="s3">) / </span><span class="s1">denom</span>

    <span class="s1">t</span><span class="s3">, </span><span class="s1">prob </span><span class="s3">= </span><span class="s1">_ttest_finish</span><span class="s3">(</span><span class="s1">df</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s1">Ttest_indResult</span><span class="s3">(</span><span class="s1">t</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">)</span>


<span class="s1">Ttest_relResult </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'Ttest_relResult'</span><span class="s3">, (</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s3">))</span>


<span class="s5">def </span><span class="s1">ttest_rel</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">=</span><span class="s4">'two-sided'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculates the T-test on TWO RELATED samples of scores, a and b. 
 
    Parameters 
    ---------- 
    a, b : array_like 
        The arrays must have the same shape. 
    axis : int or None, optional 
        Axis along which to compute test. If None, compute over the whole 
        arrays, `a`, and `b`. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. 
        The following options are available (default is 'two-sided'): 
 
        * 'two-sided': the means of the distributions underlying the samples 
          are unequal. 
        * 'less': the mean of the distribution underlying the first sample 
          is less than the mean of the distribution underlying the second 
          sample. 
        * 'greater': the mean of the distribution underlying the first 
          sample is greater than the mean of the distribution underlying 
          the second sample. 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    statistic : float or array 
        t-statistic 
    pvalue : float or array 
        two-tailed p-value 
 
    Notes 
    ----- 
    For more details on `ttest_rel`, see `scipy.stats.ttest_rel`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">= </span><span class="s1">_chk2_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">b</span><span class="s3">):</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'unequal length arrays'</span><span class="s3">)</span>

    <span class="s5">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s6">0 </span><span class="s5">or </span><span class="s1">b</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">Ttest_relResult</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">)</span>

    <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">df </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1.0</span><span class="s3">)</span>
    <span class="s1">d </span><span class="s3">= (</span><span class="s1">a</span><span class="s3">-</span><span class="s1">b</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">'d'</span><span class="s3">)</span>
    <span class="s1">dm </span><span class="s3">= </span><span class="s1">d</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">v </span><span class="s3">= </span><span class="s1">d</span><span class="s3">.</span><span class="s1">var</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">denom </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">v </span><span class="s3">/ </span><span class="s1">n</span><span class="s3">)</span>
    <span class="s5">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">divide</span><span class="s3">=</span><span class="s4">'ignore'</span><span class="s3">, </span><span class="s1">invalid</span><span class="s3">=</span><span class="s4">'ignore'</span><span class="s3">):</span>
        <span class="s1">t </span><span class="s3">= </span><span class="s1">dm </span><span class="s3">/ </span><span class="s1">denom</span>

    <span class="s1">t</span><span class="s3">, </span><span class="s1">prob </span><span class="s3">= </span><span class="s1">_ttest_finish</span><span class="s3">(</span><span class="s1">df</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s1">Ttest_relResult</span><span class="s3">(</span><span class="s1">t</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">)</span>


<span class="s1">MannwhitneyuResult </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'MannwhitneyuResult'</span><span class="s3">, (</span><span class="s4">'statistic'</span><span class="s3">,</span>
                                                       <span class="s4">'pvalue'</span><span class="s3">))</span>


<span class="s5">def </span><span class="s1">mannwhitneyu</span><span class="s3">(</span><span class="s1">x</span><span class="s3">,</span><span class="s1">y</span><span class="s3">, </span><span class="s1">use_continuity</span><span class="s3">=</span><span class="s5">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes the Mann-Whitney statistic 
 
    Missing values in `x` and/or `y` are discarded. 
 
    Parameters 
    ---------- 
    x : sequence 
        Input 
    y : sequence 
        Input 
    use_continuity : {True, False}, optional 
        Whether a continuity correction (1/2.) should be taken into account. 
 
    Returns 
    ------- 
    statistic : float 
        The minimum of the Mann-Whitney statistics 
    pvalue : float 
        Approximate two-sided p-value assuming a normal distribution. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">compressed</span><span class="s3">().</span><span class="s1">view</span><span class="s3">(</span><span class="s1">ndarray</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">).</span><span class="s1">compressed</span><span class="s3">().</span><span class="s1">view</span><span class="s3">(</span><span class="s1">ndarray</span><span class="s3">)</span>
    <span class="s1">ranks </span><span class="s3">= </span><span class="s1">rankdata</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">([</span><span class="s1">x</span><span class="s3">,</span><span class="s1">y</span><span class="s3">]))</span>
    <span class="s3">(</span><span class="s1">nx</span><span class="s3">, </span><span class="s1">ny</span><span class="s3">) = (</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>
    <span class="s1">nt </span><span class="s3">= </span><span class="s1">nx </span><span class="s3">+ </span><span class="s1">ny</span>
    <span class="s1">U </span><span class="s3">= </span><span class="s1">ranks</span><span class="s3">[:</span><span class="s1">nx</span><span class="s3">].</span><span class="s1">sum</span><span class="s3">() - </span><span class="s1">nx</span><span class="s3">*(</span><span class="s1">nx</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)/</span><span class="s6">2.</span>
    <span class="s1">U </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">U</span><span class="s3">, </span><span class="s1">nx</span><span class="s3">*</span><span class="s1">ny </span><span class="s3">- </span><span class="s1">U</span><span class="s3">)</span>
    <span class="s1">u </span><span class="s3">= </span><span class="s1">nx</span><span class="s3">*</span><span class="s1">ny </span><span class="s3">- </span><span class="s1">U</span>

    <span class="s1">mu </span><span class="s3">= (</span><span class="s1">nx</span><span class="s3">*</span><span class="s1">ny</span><span class="s3">)/</span><span class="s6">2.</span>
    <span class="s1">sigsq </span><span class="s3">= (</span><span class="s1">nt</span><span class="s3">**</span><span class="s6">3 </span><span class="s3">- </span><span class="s1">nt</span><span class="s3">)/</span><span class="s6">12.</span>
    <span class="s1">ties </span><span class="s3">= </span><span class="s1">count_tied_groups</span><span class="s3">(</span><span class="s1">ranks</span><span class="s3">)</span>
    <span class="s1">sigsq </span><span class="s3">-= </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">v</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">**</span><span class="s6">3</span><span class="s3">-</span><span class="s1">k</span><span class="s3">) </span><span class="s5">for </span><span class="s3">(</span><span class="s1">k</span><span class="s3">,</span><span class="s1">v</span><span class="s3">) </span><span class="s5">in </span><span class="s1">ties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())/</span><span class="s6">12.</span>
    <span class="s1">sigsq </span><span class="s3">*= </span><span class="s1">nx</span><span class="s3">*</span><span class="s1">ny</span><span class="s3">/</span><span class="s1">float</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">*(</span><span class="s1">nt</span><span class="s3">-</span><span class="s6">1</span><span class="s3">))</span>

    <span class="s5">if </span><span class="s1">use_continuity</span><span class="s3">:</span>
        <span class="s1">z </span><span class="s3">= (</span><span class="s1">U </span><span class="s3">- </span><span class="s6">1</span><span class="s3">/</span><span class="s6">2. </span><span class="s3">- </span><span class="s1">mu</span><span class="s3">) / </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">sigsq</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">z </span><span class="s3">= (</span><span class="s1">U </span><span class="s3">- </span><span class="s1">mu</span><span class="s3">) / </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">sigsq</span><span class="s3">)</span>

    <span class="s1">prob </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">erfc</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)/</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s6">2</span><span class="s3">))</span>
    <span class="s5">return </span><span class="s1">MannwhitneyuResult</span><span class="s3">(</span><span class="s1">u</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">)</span>


<span class="s1">KruskalResult </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'KruskalResult'</span><span class="s3">, (</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s3">))</span>


<span class="s5">def </span><span class="s1">kruskal</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the Kruskal-Wallis H-test for independent samples 
 
    Parameters 
    ---------- 
    sample1, sample2, ... : array_like 
       Two or more arrays with the sample measurements can be given as 
       arguments. 
 
    Returns 
    ------- 
    statistic : float 
       The Kruskal-Wallis H statistic, corrected for ties 
    pvalue : float 
       The p-value for the test using the assumption that H has a chi 
       square distribution 
 
    Notes 
    ----- 
    For more details on `kruskal`, see `scipy.stats.kruskal`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.stats.mstats import kruskal 
 
    Random samples from three different brands of batteries were tested 
    to see how long the charge lasted. Results were as follows: 
 
    &gt;&gt;&gt; a = [6.3, 5.4, 5.7, 5.2, 5.0] 
    &gt;&gt;&gt; b = [6.9, 7.0, 6.1, 7.9] 
    &gt;&gt;&gt; c = [7.2, 6.9, 6.1, 6.5] 
 
    Test the hypothesis that the distribution functions for all of the brands' 
    durations are identical. Use 5% level of significance. 
 
    &gt;&gt;&gt; kruskal(a, b, c) 
    KruskalResult(statistic=7.113812154696133, pvalue=0.028526948491942164) 
 
    The null hypothesis is rejected at the 5% level of significance 
    because the returned p-value is less than the critical value of 5%. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">output </span><span class="s3">= </span><span class="s1">argstoarray</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">)</span>
    <span class="s1">ranks </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">masked_equal</span><span class="s3">(</span><span class="s1">rankdata</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">use_missing</span><span class="s3">=</span><span class="s5">False</span><span class="s3">), </span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">sumrk </span><span class="s3">= </span><span class="s1">ranks</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">ngrp </span><span class="s3">= </span><span class="s1">ranks</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">ntot </span><span class="s3">= </span><span class="s1">ranks</span><span class="s3">.</span><span class="s1">count</span><span class="s3">()</span>
    <span class="s1">H </span><span class="s3">= </span><span class="s6">12.</span><span class="s3">/(</span><span class="s1">ntot</span><span class="s3">*(</span><span class="s1">ntot</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)) * (</span><span class="s1">sumrk</span><span class="s3">**</span><span class="s6">2</span><span class="s3">/</span><span class="s1">ngrp</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">() - </span><span class="s6">3</span><span class="s3">*(</span><span class="s1">ntot</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)</span>
    <span class="s2"># Tie correction</span>
    <span class="s1">ties </span><span class="s3">= </span><span class="s1">count_tied_groups</span><span class="s3">(</span><span class="s1">ranks</span><span class="s3">)</span>
    <span class="s1">T </span><span class="s3">= </span><span class="s6">1. </span><span class="s3">- </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">v</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">**</span><span class="s6">3</span><span class="s3">-</span><span class="s1">k</span><span class="s3">) </span><span class="s5">for </span><span class="s3">(</span><span class="s1">k</span><span class="s3">,</span><span class="s1">v</span><span class="s3">) </span><span class="s5">in </span><span class="s1">ties</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())/</span><span class="s1">float</span><span class="s3">(</span><span class="s1">ntot</span><span class="s3">**</span><span class="s6">3</span><span class="s3">-</span><span class="s1">ntot</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">T </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'All numbers are identical in kruskal'</span><span class="s3">)</span>

    <span class="s1">H </span><span class="s3">/= </span><span class="s1">T</span>
    <span class="s1">df </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">output</span><span class="s3">) - </span><span class="s6">1</span>
    <span class="s1">prob </span><span class="s3">= </span><span class="s1">distributions</span><span class="s3">.</span><span class="s1">chi2</span><span class="s3">.</span><span class="s1">sf</span><span class="s3">(</span><span class="s1">H</span><span class="s3">, </span><span class="s1">df</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s1">KruskalResult</span><span class="s3">(</span><span class="s1">H</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">)</span>


<span class="s1">kruskalwallis </span><span class="s3">= </span><span class="s1">kruskal</span>


<span class="s3">@</span><span class="s1">_rename_parameter</span><span class="s3">(</span><span class="s4">&quot;mode&quot;</span><span class="s3">, </span><span class="s4">&quot;method&quot;</span><span class="s3">)</span>
<span class="s5">def </span><span class="s1">ks_1samp</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=(), </span><span class="s1">alternative</span><span class="s3">=</span><span class="s4">&quot;two-sided&quot;</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">'auto'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes the Kolmogorov-Smirnov test on one sample of masked values. 
 
    Missing values in `x` are discarded. 
 
    Parameters 
    ---------- 
    x : array_like 
        a 1-D array of observations of random variables. 
    cdf : str or callable 
        If a string, it should be the name of a distribution in `scipy.stats`. 
        If a callable, that callable is used to calculate the cdf. 
    args : tuple, sequence, optional 
        Distribution parameters, used if `cdf` is a string. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Indicates the alternative hypothesis.  Default is 'two-sided'. 
    method : {'auto', 'exact', 'asymp'}, optional 
        Defines the method used for calculating the p-value. 
        The following options are available (default is 'auto'): 
 
          * 'auto' : use 'exact' for small size arrays, 'asymp' for large 
          * 'exact' : use approximation to exact distribution of test statistic 
          * 'asymp' : use asymptotic distribution of test statistic 
 
    Returns 
    ------- 
    d : float 
        Value of the Kolmogorov Smirnov test 
    p : float 
        Corresponding p-value. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">alternative </span><span class="s3">= {</span><span class="s4">'t'</span><span class="s3">: </span><span class="s4">'two-sided'</span><span class="s3">, </span><span class="s4">'g'</span><span class="s3">: </span><span class="s4">'greater'</span><span class="s3">, </span><span class="s4">'l'</span><span class="s3">: </span><span class="s4">'less'</span><span class="s3">}.</span><span class="s1">get</span><span class="s3">(</span>
       <span class="s1">alternative</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">()[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">alternative</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats</span><span class="s3">.</span><span class="s1">_stats_py</span><span class="s3">.</span><span class="s1">ks_1samp</span><span class="s3">(</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=</span><span class="s1">args</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">=</span><span class="s1">alternative</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s1">method</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">_rename_parameter</span><span class="s3">(</span><span class="s4">&quot;mode&quot;</span><span class="s3">, </span><span class="s4">&quot;method&quot;</span><span class="s3">)</span>
<span class="s5">def </span><span class="s1">ks_2samp</span><span class="s3">(</span><span class="s1">data1</span><span class="s3">, </span><span class="s1">data2</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">=</span><span class="s4">&quot;two-sided&quot;</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">'auto'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes the Kolmogorov-Smirnov test on two samples. 
 
    Missing values in `x` and/or `y` are discarded. 
 
    Parameters 
    ---------- 
    data1 : array_like 
        First data set 
    data2 : array_like 
        Second data set 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Indicates the alternative hypothesis.  Default is 'two-sided'. 
    method : {'auto', 'exact', 'asymp'}, optional 
        Defines the method used for calculating the p-value. 
        The following options are available (default is 'auto'): 
 
          * 'auto' : use 'exact' for small size arrays, 'asymp' for large 
          * 'exact' : use approximation to exact distribution of test statistic 
          * 'asymp' : use asymptotic distribution of test statistic 
 
    Returns 
    ------- 
    d : float 
        Value of the Kolmogorov Smirnov test 
    p : float 
        Corresponding p-value. 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># Ideally this would be accomplished by</span>
    <span class="s2"># ks_2samp = scipy.stats._stats_py.ks_2samp</span>
    <span class="s2"># but the circular dependencies between _mstats_basic and stats prevent that.</span>
    <span class="s1">alternative </span><span class="s3">= {</span><span class="s4">'t'</span><span class="s3">: </span><span class="s4">'two-sided'</span><span class="s3">, </span><span class="s4">'g'</span><span class="s3">: </span><span class="s4">'greater'</span><span class="s3">, </span><span class="s4">'l'</span><span class="s3">: </span><span class="s4">'less'</span><span class="s3">}.</span><span class="s1">get</span><span class="s3">(</span>
       <span class="s1">alternative</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">()[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">alternative</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats</span><span class="s3">.</span><span class="s1">_stats_py</span><span class="s3">.</span><span class="s1">ks_2samp</span><span class="s3">(</span><span class="s1">data1</span><span class="s3">, </span><span class="s1">data2</span><span class="s3">,</span>
                                          <span class="s1">alternative</span><span class="s3">=</span><span class="s1">alternative</span><span class="s3">,</span>
                                          <span class="s1">method</span><span class="s3">=</span><span class="s1">method</span><span class="s3">)</span>


<span class="s1">ks_twosamp </span><span class="s3">= </span><span class="s1">ks_2samp</span>


<span class="s3">@</span><span class="s1">_rename_parameter</span><span class="s3">(</span><span class="s4">&quot;mode&quot;</span><span class="s3">, </span><span class="s4">&quot;method&quot;</span><span class="s3">)</span>
<span class="s5">def </span><span class="s1">kstest</span><span class="s3">(</span><span class="s1">data1</span><span class="s3">, </span><span class="s1">data2</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=(), </span><span class="s1">alternative</span><span class="s3">=</span><span class="s4">'two-sided'</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">'auto'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
 
    Parameters 
    ---------- 
    data1 : array_like 
    data2 : str, callable or array_like 
    args : tuple, sequence, optional 
        Distribution parameters, used if `data1` or `data2` are strings. 
    alternative : str, as documented in stats.kstest 
    method : str, as documented in stats.kstest 
 
    Returns 
    ------- 
    tuple of (K-S statistic, probability) 
 
    &quot;&quot;&quot;</span>
    <span class="s5">return </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats</span><span class="s3">.</span><span class="s1">_stats_py</span><span class="s3">.</span><span class="s1">kstest</span><span class="s3">(</span><span class="s1">data1</span><span class="s3">, </span><span class="s1">data2</span><span class="s3">, </span><span class="s1">args</span><span class="s3">,</span>
                                        <span class="s1">alternative</span><span class="s3">=</span><span class="s1">alternative</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s1">method</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">trima</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=(</span><span class="s5">True</span><span class="s3">,</span><span class="s5">True</span><span class="s3">)):</span>
    <span class="s0">&quot;&quot;&quot; 
    Trims an array by masking the data outside some given limits. 
 
    Returns a masked version of the input array. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array. 
    limits : {None, tuple}, optional 
        Tuple of (lower limit, upper limit) in absolute values. 
        Values of the input array lower (greater) than the lower (upper) limit 
        will be masked.  A limit is None indicates an open interval. 
    inclusive : (bool, bool) tuple, optional 
        Tuple of (lower flag, upper flag), indicating whether values exactly 
        equal to the lower (upper) limit are allowed. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.stats.mstats import trima 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; a = np.arange(10) 
 
    The interval is left-closed and right-open, i.e., `[2, 8)`. 
    Trim the array by keeping only values in the interval. 
 
    &gt;&gt;&gt; trima(a, limits=(2, 8), inclusive=(True, False)) 
    masked_array(data=[--, --, 2, 3, 4, 5, 6, 7, --, --], 
                 mask=[ True,  True, False, False, False, False, False, False, 
                        True,  True], 
           fill_value=999999) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">a</span><span class="s3">.</span><span class="s1">unshare_mask</span><span class="s3">()</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s1">limits </span><span class="s5">is None</span><span class="s3">) </span><span class="s5">or </span><span class="s3">(</span><span class="s1">limits </span><span class="s3">== (</span><span class="s5">None</span><span class="s3">, </span><span class="s5">None</span><span class="s3">)):</span>
        <span class="s5">return </span><span class="s1">a</span>

    <span class="s3">(</span><span class="s1">lower_lim</span><span class="s3">, </span><span class="s1">upper_lim</span><span class="s3">) = </span><span class="s1">limits</span>
    <span class="s3">(</span><span class="s1">lower_in</span><span class="s3">, </span><span class="s1">upper_in</span><span class="s3">) = </span><span class="s1">inclusive</span>
    <span class="s1">condition </span><span class="s3">= </span><span class="s5">False</span>
    <span class="s5">if </span><span class="s1">lower_lim </span><span class="s5">is not None</span><span class="s3">:</span>
        <span class="s5">if </span><span class="s1">lower_in</span><span class="s3">:</span>
            <span class="s1">condition </span><span class="s3">|= (</span><span class="s1">a </span><span class="s3">&lt; </span><span class="s1">lower_lim</span><span class="s3">)</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">condition </span><span class="s3">|= (</span><span class="s1">a </span><span class="s3">&lt;= </span><span class="s1">lower_lim</span><span class="s3">)</span>

    <span class="s5">if </span><span class="s1">upper_lim </span><span class="s5">is not None</span><span class="s3">:</span>
        <span class="s5">if </span><span class="s1">upper_in</span><span class="s3">:</span>
            <span class="s1">condition </span><span class="s3">|= (</span><span class="s1">a </span><span class="s3">&gt; </span><span class="s1">upper_lim</span><span class="s3">)</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">condition </span><span class="s3">|= (</span><span class="s1">a </span><span class="s3">&gt;= </span><span class="s1">upper_lim</span><span class="s3">)</span>

    <span class="s1">a</span><span class="s3">[</span><span class="s1">condition</span><span class="s3">.</span><span class="s1">filled</span><span class="s3">(</span><span class="s5">True</span><span class="s3">)] = </span><span class="s1">masked</span>
    <span class="s5">return </span><span class="s1">a</span>


<span class="s5">def </span><span class="s1">trimr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=(</span><span class="s5">True</span><span class="s3">, </span><span class="s5">True</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Trims an array by masking some proportion of the data on each end. 
    Returns a masked version of the input array. 
 
    Parameters 
    ---------- 
    a : sequence 
        Input array. 
    limits : {None, tuple}, optional 
        Tuple of the percentages to cut on each side of the array, with respect 
        to the number of unmasked data, as floats between 0. and 1. 
        Noting n the number of unmasked data before trimming, the 
        (n*limits[0])th smallest data and the (n*limits[1])th largest data are 
        masked, and the total number of unmasked data after trimming is 
        n*(1.-sum(limits)).  The value of one limit can be set to None to 
        indicate an open interval. 
    inclusive : {(True,True) tuple}, optional 
        Tuple of flags indicating whether the number of data being masked on 
        the left (right) end should be truncated (True) or rounded (False) to 
        integers. 
    axis : {None,int}, optional 
        Axis along which to trim. If None, the whole array is trimmed, but its 
        shape is maintained. 
 
    &quot;&quot;&quot;</span>
    <span class="s5">def </span><span class="s1">_trimr1D</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">low_limit</span><span class="s3">, </span><span class="s1">up_limit</span><span class="s3">, </span><span class="s1">low_inclusive</span><span class="s3">, </span><span class="s1">up_inclusive</span><span class="s3">):</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">count</span><span class="s3">()</span>
        <span class="s1">idx </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">()</span>
        <span class="s5">if </span><span class="s1">low_limit</span><span class="s3">:</span>
            <span class="s5">if </span><span class="s1">low_inclusive</span><span class="s3">:</span>
                <span class="s1">lowidx </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">low_limit</span><span class="s3">*</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s5">else</span><span class="s3">:</span>
                <span class="s1">lowidx </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">low_limit</span><span class="s3">*</span><span class="s1">n</span><span class="s3">))</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">[:</span><span class="s1">lowidx</span><span class="s3">]] = </span><span class="s1">masked</span>
        <span class="s5">if </span><span class="s1">up_limit </span><span class="s5">is not None</span><span class="s3">:</span>
            <span class="s5">if </span><span class="s1">up_inclusive</span><span class="s3">:</span>
                <span class="s1">upidx </span><span class="s3">= </span><span class="s1">n </span><span class="s3">- </span><span class="s1">int</span><span class="s3">(</span><span class="s1">n</span><span class="s3">*</span><span class="s1">up_limit</span><span class="s3">)</span>
            <span class="s5">else</span><span class="s3">:</span>
                <span class="s1">upidx </span><span class="s3">= </span><span class="s1">n </span><span class="s3">- </span><span class="s1">int</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">n</span><span class="s3">*</span><span class="s1">up_limit</span><span class="s3">))</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">[</span><span class="s1">upidx</span><span class="s3">:]] = </span><span class="s1">masked</span>
        <span class="s5">return </span><span class="s1">a</span>

    <span class="s1">a </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">a</span><span class="s3">.</span><span class="s1">unshare_mask</span><span class="s3">()</span>
    <span class="s5">if </span><span class="s1">limits </span><span class="s5">is None</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">a</span>

    <span class="s2"># Check the limits</span>
    <span class="s3">(</span><span class="s1">lolim</span><span class="s3">, </span><span class="s1">uplim</span><span class="s3">) = </span><span class="s1">limits</span>
    <span class="s1">errmsg </span><span class="s3">= </span><span class="s4">&quot;The proportion to cut from the %s should be between 0. and 1.&quot;</span>
    <span class="s5">if </span><span class="s1">lolim </span><span class="s5">is not None</span><span class="s3">:</span>
        <span class="s5">if </span><span class="s1">lolim </span><span class="s3">&gt; </span><span class="s6">1. </span><span class="s5">or </span><span class="s1">lolim </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">errmsg </span><span class="s3">% </span><span class="s4">'beginning' </span><span class="s3">+ </span><span class="s4">&quot;(got %s)&quot; </span><span class="s3">% </span><span class="s1">lolim</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">uplim </span><span class="s5">is not None</span><span class="s3">:</span>
        <span class="s5">if </span><span class="s1">uplim </span><span class="s3">&gt; </span><span class="s6">1. </span><span class="s5">or </span><span class="s1">uplim </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">errmsg </span><span class="s3">% </span><span class="s4">'end' </span><span class="s3">+ </span><span class="s4">&quot;(got %s)&quot; </span><span class="s3">% </span><span class="s1">uplim</span><span class="s3">)</span>

    <span class="s3">(</span><span class="s1">loinc</span><span class="s3">, </span><span class="s1">upinc</span><span class="s3">) = </span><span class="s1">inclusive</span>

    <span class="s5">if </span><span class="s1">axis </span><span class="s5">is None</span><span class="s3">:</span>
        <span class="s1">shp </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s5">return </span><span class="s1">_trimr1D</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(),</span><span class="s1">lolim</span><span class="s3">,</span><span class="s1">uplim</span><span class="s3">,</span><span class="s1">loinc</span><span class="s3">,</span><span class="s1">upinc</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">shp</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">apply_along_axis</span><span class="s3">(</span><span class="s1">_trimr1D</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">lolim</span><span class="s3">,</span><span class="s1">uplim</span><span class="s3">,</span><span class="s1">loinc</span><span class="s3">,</span><span class="s1">upinc</span><span class="s3">)</span>


<span class="s1">trimdoc </span><span class="s3">= </span><span class="s4">&quot;&quot;&quot; 
    Parameters 
    ---------- 
    a : sequence 
        Input array 
    limits : {None, tuple}, optional 
        If `relative` is False, tuple (lower limit, upper limit) in absolute values. 
        Values of the input array lower (greater) than the lower (upper) limit are 
        masked. 
 
        If `relative` is True, tuple (lower percentage, upper percentage) to cut 
        on each side of the  array, with respect to the number of unmasked data. 
 
        Noting n the number of unmasked data before trimming, the (n*limits[0])th 
        smallest data and the (n*limits[1])th largest data are masked, and the 
        total number of unmasked data after trimming is n*(1.-sum(limits)) 
        In each case, the value of one limit can be set to None to indicate an 
        open interval. 
 
        If limits is None, no trimming is performed 
    inclusive : {(bool, bool) tuple}, optional 
        If `relative` is False, tuple indicating whether values exactly equal 
        to the absolute limits are allowed. 
        If `relative` is True, tuple indicating whether the number of data 
        being masked on each side should be rounded (True) or truncated 
        (False). 
    relative : bool, optional 
        Whether to consider the limits as absolute values (False) or proportions 
        to cut (True). 
    axis : int, optional 
        Axis along which to trim. 
&quot;&quot;&quot;</span>


<span class="s5">def </span><span class="s1">trim</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=(</span><span class="s5">True</span><span class="s3">,</span><span class="s5">True</span><span class="s3">), </span><span class="s1">relative</span><span class="s3">=</span><span class="s5">False</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Trims an array by masking the data outside some given limits. 
 
    Returns a masked version of the input array. 
 
    %s 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.stats.mstats import trim 
    &gt;&gt;&gt; z = [ 1, 2, 3, 4, 5, 6, 7, 8, 9,10] 
    &gt;&gt;&gt; print(trim(z,(3,8))) 
    [-- -- 3 4 5 6 7 8 -- --] 
    &gt;&gt;&gt; print(trim(z,(0.1,0.2),relative=True)) 
    [-- 2 3 4 5 6 7 8 -- --] 
 
    &quot;&quot;&quot;</span>
    <span class="s5">if </span><span class="s1">relative</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">trimr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=</span><span class="s1">limits</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=</span><span class="s1">inclusive</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">trima</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=</span><span class="s1">limits</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=</span><span class="s1">inclusive</span><span class="s3">)</span>


<span class="s5">if </span><span class="s1">trim</span><span class="s3">.</span><span class="s1">__doc__</span><span class="s3">:</span>
    <span class="s1">trim</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= </span><span class="s1">trim</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">% </span><span class="s1">trimdoc</span>


<span class="s5">def </span><span class="s1">trimboth</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">proportiontocut</span><span class="s3">=</span><span class="s6">0.2</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=(</span><span class="s5">True</span><span class="s3">,</span><span class="s5">True</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Trims the smallest and largest data values. 
 
    Trims the `data` by masking the ``int(proportiontocut * n)`` smallest and 
    ``int(proportiontocut * n)`` largest values of data along the given axis, 
    where n is the number of unmasked values before trimming. 
 
    Parameters 
    ---------- 
    data : ndarray 
        Data to trim. 
    proportiontocut : float, optional 
        Percentage of trimming (as a float between 0 and 1). 
        If n is the number of unmasked values before trimming, the number of 
        values after trimming is ``(1 - 2*proportiontocut) * n``. 
        Default is 0.2. 
    inclusive : {(bool, bool) tuple}, optional 
        Tuple indicating whether the number of data being masked on each side 
        should be rounded (True) or truncated (False). 
    axis : int, optional 
        Axis along which to perform the trimming. 
        If None, the input array is first flattened. 
 
    &quot;&quot;&quot;</span>
    <span class="s5">return </span><span class="s1">trimr</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=(</span><span class="s1">proportiontocut</span><span class="s3">,</span><span class="s1">proportiontocut</span><span class="s3">),</span>
                 <span class="s1">inclusive</span><span class="s3">=</span><span class="s1">inclusive</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">trimtail</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">proportiontocut</span><span class="s3">=</span><span class="s6">0.2</span><span class="s3">, </span><span class="s1">tail</span><span class="s3">=</span><span class="s4">'left'</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=(</span><span class="s5">True</span><span class="s3">,</span><span class="s5">True</span><span class="s3">),</span>
             <span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Trims the data by masking values from one tail. 
 
    Parameters 
    ---------- 
    data : array_like 
        Data to trim. 
    proportiontocut : float, optional 
        Percentage of trimming. If n is the number of unmasked values 
        before trimming, the number of values after trimming is 
        ``(1 - proportiontocut) * n``.  Default is 0.2. 
    tail : {'left','right'}, optional 
        If 'left' the `proportiontocut` lowest values will be masked. 
        If 'right' the `proportiontocut` highest values will be masked. 
        Default is 'left'. 
    inclusive : {(bool, bool) tuple}, optional 
        Tuple indicating whether the number of data being masked on each side 
        should be rounded (True) or truncated (False).  Default is 
        (True, True). 
    axis : int, optional 
        Axis along which to perform the trimming. 
        If None, the input array is first flattened.  Default is None. 
 
    Returns 
    ------- 
    trimtail : ndarray 
        Returned array of same shape as `data` with masked tail values. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">tail </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">tail</span><span class="s3">).</span><span class="s1">lower</span><span class="s3">()[</span><span class="s6">0</span><span class="s3">]</span>
    <span class="s5">if </span><span class="s1">tail </span><span class="s3">== </span><span class="s4">'l'</span><span class="s3">:</span>
        <span class="s1">limits </span><span class="s3">= (</span><span class="s1">proportiontocut</span><span class="s3">,</span><span class="s5">None</span><span class="s3">)</span>
    <span class="s5">elif </span><span class="s1">tail </span><span class="s3">== </span><span class="s4">'r'</span><span class="s3">:</span>
        <span class="s1">limits </span><span class="s3">= (</span><span class="s5">None</span><span class="s3">, </span><span class="s1">proportiontocut</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;The tail argument should be in ('left','right')&quot;</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">trimr</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=</span><span class="s1">limits</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=</span><span class="s1">inclusive</span><span class="s3">)</span>


<span class="s1">trim1 </span><span class="s3">= </span><span class="s1">trimtail</span>


<span class="s5">def </span><span class="s1">trimmed_mean</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=(</span><span class="s6">0.1</span><span class="s3">,</span><span class="s6">0.1</span><span class="s3">), </span><span class="s1">inclusive</span><span class="s3">=(</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">), </span><span class="s1">relative</span><span class="s3">=</span><span class="s5">True</span><span class="s3">,</span>
                 <span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Returns the trimmed mean of the data along the given axis. 
 
    %s 
 
    &quot;&quot;&quot;</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s5">not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">limits</span><span class="s3">,</span><span class="s1">tuple</span><span class="s3">)) </span><span class="s5">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">limits</span><span class="s3">,</span><span class="s1">float</span><span class="s3">):</span>
        <span class="s1">limits </span><span class="s3">= (</span><span class="s1">limits</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">relative</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">trimr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">,</span><span class="s1">limits</span><span class="s3">=</span><span class="s1">limits</span><span class="s3">,</span><span class="s1">inclusive</span><span class="s3">=</span><span class="s1">inclusive</span><span class="s3">,</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">).</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">trima</span><span class="s3">(</span><span class="s1">a</span><span class="s3">,</span><span class="s1">limits</span><span class="s3">=</span><span class="s1">limits</span><span class="s3">,</span><span class="s1">inclusive</span><span class="s3">=</span><span class="s1">inclusive</span><span class="s3">).</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>


<span class="s5">if </span><span class="s1">trimmed_mean</span><span class="s3">.</span><span class="s1">__doc__</span><span class="s3">:</span>
    <span class="s1">trimmed_mean</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= </span><span class="s1">trimmed_mean</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">% </span><span class="s1">trimdoc</span>


<span class="s5">def </span><span class="s1">trimmed_var</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=(</span><span class="s6">0.1</span><span class="s3">,</span><span class="s6">0.1</span><span class="s3">), </span><span class="s1">inclusive</span><span class="s3">=(</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">), </span><span class="s1">relative</span><span class="s3">=</span><span class="s5">True</span><span class="s3">,</span>
                <span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s6">0</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Returns the trimmed variance of the data along the given axis. 
 
    %s 
    ddof : {0,integer}, optional 
        Means Delta Degrees of Freedom. The denominator used during computations 
        is (n-ddof). DDOF=0 corresponds to a biased estimate, DDOF=1 to an un- 
        biased estimate of the variance. 
 
    &quot;&quot;&quot;</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s5">not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">limits</span><span class="s3">,</span><span class="s1">tuple</span><span class="s3">)) </span><span class="s5">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">limits</span><span class="s3">,</span><span class="s1">float</span><span class="s3">):</span>
        <span class="s1">limits </span><span class="s3">= (</span><span class="s1">limits</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">relative</span><span class="s3">:</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">trimr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">,</span><span class="s1">limits</span><span class="s3">=</span><span class="s1">limits</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=</span><span class="s1">inclusive</span><span class="s3">,</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">trima</span><span class="s3">(</span><span class="s1">a</span><span class="s3">,</span><span class="s1">limits</span><span class="s3">=</span><span class="s1">limits</span><span class="s3">,</span><span class="s1">inclusive</span><span class="s3">=</span><span class="s1">inclusive</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">out</span><span class="s3">.</span><span class="s1">var</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s1">ddof</span><span class="s3">)</span>


<span class="s5">if </span><span class="s1">trimmed_var</span><span class="s3">.</span><span class="s1">__doc__</span><span class="s3">:</span>
    <span class="s1">trimmed_var</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= </span><span class="s1">trimmed_var</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">% </span><span class="s1">trimdoc</span>


<span class="s5">def </span><span class="s1">trimmed_std</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=(</span><span class="s6">0.1</span><span class="s3">,</span><span class="s6">0.1</span><span class="s3">), </span><span class="s1">inclusive</span><span class="s3">=(</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">), </span><span class="s1">relative</span><span class="s3">=</span><span class="s5">True</span><span class="s3">,</span>
                <span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s6">0</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Returns the trimmed standard deviation of the data along the given axis. 
 
    %s 
    ddof : {0,integer}, optional 
        Means Delta Degrees of Freedom. The denominator used during computations 
        is (n-ddof). DDOF=0 corresponds to a biased estimate, DDOF=1 to an un- 
        biased estimate of the variance. 
 
    &quot;&quot;&quot;</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s5">not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">limits</span><span class="s3">,</span><span class="s1">tuple</span><span class="s3">)) </span><span class="s5">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">limits</span><span class="s3">,</span><span class="s1">float</span><span class="s3">):</span>
        <span class="s1">limits </span><span class="s3">= (</span><span class="s1">limits</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">relative</span><span class="s3">:</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">trimr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">,</span><span class="s1">limits</span><span class="s3">=</span><span class="s1">limits</span><span class="s3">,</span><span class="s1">inclusive</span><span class="s3">=</span><span class="s1">inclusive</span><span class="s3">,</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">trima</span><span class="s3">(</span><span class="s1">a</span><span class="s3">,</span><span class="s1">limits</span><span class="s3">=</span><span class="s1">limits</span><span class="s3">,</span><span class="s1">inclusive</span><span class="s3">=</span><span class="s1">inclusive</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s1">out</span><span class="s3">.</span><span class="s1">std</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">,</span><span class="s1">ddof</span><span class="s3">=</span><span class="s1">ddof</span><span class="s3">)</span>


<span class="s5">if </span><span class="s1">trimmed_std</span><span class="s3">.</span><span class="s1">__doc__</span><span class="s3">:</span>
    <span class="s1">trimmed_std</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= </span><span class="s1">trimmed_std</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">% </span><span class="s1">trimdoc</span>


<span class="s5">def </span><span class="s1">trimmed_stde</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=(</span><span class="s6">0.1</span><span class="s3">,</span><span class="s6">0.1</span><span class="s3">), </span><span class="s1">inclusive</span><span class="s3">=(</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns the standard error of the trimmed mean along the given axis. 
 
    Parameters 
    ---------- 
    a : sequence 
        Input array 
    limits : {(0.1,0.1), tuple of float}, optional 
        tuple (lower percentage, upper percentage) to cut  on each side of the 
        array, with respect to the number of unmasked data. 
 
        If n is the number of unmasked data before trimming, the values 
        smaller than ``n * limits[0]`` and the values larger than 
        ``n * `limits[1]`` are masked, and the total number of unmasked 
        data after trimming is ``n * (1.-sum(limits))``.  In each case, 
        the value of one limit can be set to None to indicate an open interval. 
        If `limits` is None, no trimming is performed. 
    inclusive : {(bool, bool) tuple} optional 
        Tuple indicating whether the number of data being masked on each side 
        should be rounded (True) or truncated (False). 
    axis : int, optional 
        Axis along which to trim. 
 
    Returns 
    ------- 
    trimmed_stde : scalar or ndarray 
 
    &quot;&quot;&quot;</span>
    <span class="s5">def </span><span class="s1">_trimmed_stde_1D</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">low_limit</span><span class="s3">, </span><span class="s1">up_limit</span><span class="s3">, </span><span class="s1">low_inclusive</span><span class="s3">, </span><span class="s1">up_inclusive</span><span class="s3">):</span>
        <span class="s0">&quot;Returns the standard error of the trimmed mean for a 1D input data.&quot;</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">count</span><span class="s3">()</span>
        <span class="s1">idx </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">()</span>
        <span class="s5">if </span><span class="s1">low_limit</span><span class="s3">:</span>
            <span class="s5">if </span><span class="s1">low_inclusive</span><span class="s3">:</span>
                <span class="s1">lowidx </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">low_limit</span><span class="s3">*</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s5">else</span><span class="s3">:</span>
                <span class="s1">lowidx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">low_limit</span><span class="s3">*</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">[:</span><span class="s1">lowidx</span><span class="s3">]] = </span><span class="s1">masked</span>
        <span class="s5">if </span><span class="s1">up_limit </span><span class="s5">is not None</span><span class="s3">:</span>
            <span class="s5">if </span><span class="s1">up_inclusive</span><span class="s3">:</span>
                <span class="s1">upidx </span><span class="s3">= </span><span class="s1">n </span><span class="s3">- </span><span class="s1">int</span><span class="s3">(</span><span class="s1">n</span><span class="s3">*</span><span class="s1">up_limit</span><span class="s3">)</span>
            <span class="s5">else</span><span class="s3">:</span>
                <span class="s1">upidx </span><span class="s3">= </span><span class="s1">n </span><span class="s3">- </span><span class="s1">np</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">n</span><span class="s3">*</span><span class="s1">up_limit</span><span class="s3">)</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">[</span><span class="s1">upidx</span><span class="s3">:]] = </span><span class="s1">masked</span>
        <span class="s1">a</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">[:</span><span class="s1">lowidx</span><span class="s3">]] = </span><span class="s1">a</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">[</span><span class="s1">lowidx</span><span class="s3">]]</span>
        <span class="s1">a</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">[</span><span class="s1">upidx</span><span class="s3">:]] = </span><span class="s1">a</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">[</span><span class="s1">upidx</span><span class="s3">-</span><span class="s6">1</span><span class="s3">]]</span>
        <span class="s1">winstd </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">std</span><span class="s3">(</span><span class="s1">ddof</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)</span>
        <span class="s5">return </span><span class="s1">winstd </span><span class="s3">/ ((</span><span class="s6">1</span><span class="s3">-</span><span class="s1">low_limit</span><span class="s3">-</span><span class="s1">up_limit</span><span class="s3">)*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)))</span>

    <span class="s1">a </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">True</span><span class="s3">, </span><span class="s1">subok</span><span class="s3">=</span><span class="s5">True</span><span class="s3">)</span>
    <span class="s1">a</span><span class="s3">.</span><span class="s1">unshare_mask</span><span class="s3">()</span>
    <span class="s5">if </span><span class="s1">limits </span><span class="s5">is None</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">std</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">,</span><span class="s1">ddof</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)/</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">))</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s5">not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">limits</span><span class="s3">,</span><span class="s1">tuple</span><span class="s3">)) </span><span class="s5">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">limits</span><span class="s3">,</span><span class="s1">float</span><span class="s3">):</span>
        <span class="s1">limits </span><span class="s3">= (</span><span class="s1">limits</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">)</span>

    <span class="s2"># Check the limits</span>
    <span class="s3">(</span><span class="s1">lolim</span><span class="s3">, </span><span class="s1">uplim</span><span class="s3">) = </span><span class="s1">limits</span>
    <span class="s1">errmsg </span><span class="s3">= </span><span class="s4">&quot;The proportion to cut from the %s should be between 0. and 1.&quot;</span>
    <span class="s5">if </span><span class="s1">lolim </span><span class="s5">is not None</span><span class="s3">:</span>
        <span class="s5">if </span><span class="s1">lolim </span><span class="s3">&gt; </span><span class="s6">1. </span><span class="s5">or </span><span class="s1">lolim </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">errmsg </span><span class="s3">% </span><span class="s4">'beginning' </span><span class="s3">+ </span><span class="s4">&quot;(got %s)&quot; </span><span class="s3">% </span><span class="s1">lolim</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">uplim </span><span class="s5">is not None</span><span class="s3">:</span>
        <span class="s5">if </span><span class="s1">uplim </span><span class="s3">&gt; </span><span class="s6">1. </span><span class="s5">or </span><span class="s1">uplim </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">errmsg </span><span class="s3">% </span><span class="s4">'end' </span><span class="s3">+ </span><span class="s4">&quot;(got %s)&quot; </span><span class="s3">% </span><span class="s1">uplim</span><span class="s3">)</span>

    <span class="s3">(</span><span class="s1">loinc</span><span class="s3">, </span><span class="s1">upinc</span><span class="s3">) = </span><span class="s1">inclusive</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s1">axis </span><span class="s5">is None</span><span class="s3">):</span>
        <span class="s5">return </span><span class="s1">_trimmed_stde_1D</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(),</span><span class="s1">lolim</span><span class="s3">,</span><span class="s1">uplim</span><span class="s3">,</span><span class="s1">loinc</span><span class="s3">,</span><span class="s1">upinc</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Array 'a' must be at most two dimensional, &quot;</span>
                             <span class="s4">&quot;but got a.ndim = %d&quot; </span><span class="s3">% </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">apply_along_axis</span><span class="s3">(</span><span class="s1">_trimmed_stde_1D</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">a</span><span class="s3">,</span>
                                   <span class="s1">lolim</span><span class="s3">,</span><span class="s1">uplim</span><span class="s3">,</span><span class="s1">loinc</span><span class="s3">,</span><span class="s1">upinc</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">_mask_to_limits</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Mask an array for values outside of given limits. 
 
    This is primarily a utility function. 
 
    Parameters 
    ---------- 
    a : array 
    limits : (float or None, float or None) 
    A tuple consisting of the (lower limit, upper limit).  Values in the 
    input array less than the lower limit or greater than the upper limit 
    will be masked out. None implies no limit. 
    inclusive : (bool, bool) 
    A tuple consisting of the (lower flag, upper flag).  These flags 
    determine whether values exactly equal to lower or upper are allowed. 
 
    Returns 
    ------- 
    A MaskedArray. 
 
    Raises 
    ------ 
    A ValueError if there are no values within the given limits. 
    &quot;&quot;&quot;</span>
    <span class="s1">lower_limit</span><span class="s3">, </span><span class="s1">upper_limit </span><span class="s3">= </span><span class="s1">limits</span>
    <span class="s1">lower_include</span><span class="s3">, </span><span class="s1">upper_include </span><span class="s3">= </span><span class="s1">inclusive</span>
    <span class="s1">am </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">MaskedArray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">lower_limit </span><span class="s5">is not None</span><span class="s3">:</span>
        <span class="s5">if </span><span class="s1">lower_include</span><span class="s3">:</span>
            <span class="s1">am </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">masked_less</span><span class="s3">(</span><span class="s1">am</span><span class="s3">, </span><span class="s1">lower_limit</span><span class="s3">)</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">am </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">masked_less_equal</span><span class="s3">(</span><span class="s1">am</span><span class="s3">, </span><span class="s1">lower_limit</span><span class="s3">)</span>

    <span class="s5">if </span><span class="s1">upper_limit </span><span class="s5">is not None</span><span class="s3">:</span>
        <span class="s5">if </span><span class="s1">upper_include</span><span class="s3">:</span>
            <span class="s1">am </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">masked_greater</span><span class="s3">(</span><span class="s1">am</span><span class="s3">, </span><span class="s1">upper_limit</span><span class="s3">)</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">am </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">masked_greater_equal</span><span class="s3">(</span><span class="s1">am</span><span class="s3">, </span><span class="s1">upper_limit</span><span class="s3">)</span>

    <span class="s5">if </span><span class="s1">am</span><span class="s3">.</span><span class="s1">count</span><span class="s3">() == </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;No array values within given limits&quot;</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">am</span>


<span class="s5">def </span><span class="s1">tmean</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=(</span><span class="s5">True</span><span class="s3">, </span><span class="s5">True</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the trimmed mean. 
 
    Parameters 
    ---------- 
    a : array_like 
        Array of values. 
    limits : None or (lower limit, upper limit), optional 
        Values in the input array less than the lower limit or greater than the 
        upper limit will be ignored.  When limits is None (default), then all 
        values are used.  Either of the limit values in the tuple can also be 
        None representing a half-open interval. 
    inclusive : (bool, bool), optional 
        A tuple consisting of the (lower flag, upper flag).  These flags 
        determine whether values exactly equal to the lower or upper limits 
        are included.  The default value is (True, True). 
    axis : int or None, optional 
        Axis along which to operate. If None, compute over the 
        whole array. Default is None. 
 
    Returns 
    ------- 
    tmean : float 
 
    Notes 
    ----- 
    For more details on `tmean`, see `scipy.stats.tmean`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import mstats 
    &gt;&gt;&gt; a = np.array([[6, 8, 3, 0], 
    ...               [3, 9, 1, 2], 
    ...               [8, 7, 8, 2], 
    ...               [5, 6, 0, 2], 
    ...               [4, 5, 5, 2]]) 
    ... 
    ... 
    &gt;&gt;&gt; mstats.tmean(a, (2,5)) 
    3.3 
    &gt;&gt;&gt; mstats.tmean(a, (2,5), axis=0) 
    masked_array(data=[4.0, 5.0, 4.0, 2.0], 
                 mask=[False, False, False, False], 
           fill_value=1e+20) 
 
    &quot;&quot;&quot;</span>
    <span class="s5">return </span><span class="s1">trima</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=</span><span class="s1">limits</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=</span><span class="s1">inclusive</span><span class="s3">).</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">tvar</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=(</span><span class="s5">True</span><span class="s3">, </span><span class="s5">True</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s6">1</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the trimmed variance 
 
    This function computes the sample variance of an array of values, 
    while ignoring values which are outside of given `limits`. 
 
    Parameters 
    ---------- 
    a : array_like 
        Array of values. 
    limits : None or (lower limit, upper limit), optional 
        Values in the input array less than the lower limit or greater than the 
        upper limit will be ignored. When limits is None, then all values are 
        used. Either of the limit values in the tuple can also be None 
        representing a half-open interval.  The default value is None. 
    inclusive : (bool, bool), optional 
        A tuple consisting of the (lower flag, upper flag).  These flags 
        determine whether values exactly equal to the lower or upper limits 
        are included.  The default value is (True, True). 
    axis : int or None, optional 
        Axis along which to operate. If None, compute over the 
        whole array. Default is zero. 
    ddof : int, optional 
        Delta degrees of freedom. Default is 1. 
 
    Returns 
    ------- 
    tvar : float 
        Trimmed variance. 
 
    Notes 
    ----- 
    For more details on `tvar`, see `scipy.stats.tvar`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">).</span><span class="s1">ravel</span><span class="s3">()</span>
    <span class="s5">if </span><span class="s1">limits </span><span class="s5">is None</span><span class="s3">:</span>
        <span class="s1">n </span><span class="s3">= (~</span><span class="s1">a</span><span class="s3">.</span><span class="s1">mask</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">()  </span><span class="s2"># todo: better way to do that?</span>
        <span class="s5">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">var</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) * </span><span class="s1">n</span><span class="s3">/(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1.</span><span class="s3">)</span>
    <span class="s1">am </span><span class="s3">= </span><span class="s1">_mask_to_limits</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=</span><span class="s1">limits</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=</span><span class="s1">inclusive</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">var</span><span class="s3">(</span><span class="s1">am</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s1">ddof</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">tmin</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">lowerlimit</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=</span><span class="s5">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the trimmed minimum 
 
    Parameters 
    ---------- 
    a : array_like 
        array of values 
    lowerlimit : None or float, optional 
        Values in the input array less than the given limit will be ignored. 
        When lowerlimit is None, then all values are used. The default value 
        is None. 
    axis : int or None, optional 
        Axis along which to operate. Default is 0. If None, compute over the 
        whole array `a`. 
    inclusive : {True, False}, optional 
        This flag determines whether values exactly equal to the lower limit 
        are included.  The default value is True. 
 
    Returns 
    ------- 
    tmin : float, int or ndarray 
 
    Notes 
    ----- 
    For more details on `tmin`, see `scipy.stats.tmin`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import mstats 
    &gt;&gt;&gt; a = np.array([[6, 8, 3, 0], 
    ...               [3, 2, 1, 2], 
    ...               [8, 1, 8, 2], 
    ...               [5, 3, 0, 2], 
    ...               [4, 7, 5, 2]]) 
    ... 
    &gt;&gt;&gt; mstats.tmin(a, 5) 
    masked_array(data=[5, 7, 5, --], 
                 mask=[False, False, False,  True], 
           fill_value=999999) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">= </span><span class="s1">_chk_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">am </span><span class="s3">= </span><span class="s1">trima</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, (</span><span class="s1">lowerlimit</span><span class="s3">, </span><span class="s5">None</span><span class="s3">), (</span><span class="s1">inclusive</span><span class="s3">, </span><span class="s5">False</span><span class="s3">))</span>
    <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">minimum</span><span class="s3">.</span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">am</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">tmax</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">upperlimit</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=</span><span class="s5">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the trimmed maximum 
 
    This function computes the maximum value of an array along a given axis, 
    while ignoring values larger than a specified upper limit. 
 
    Parameters 
    ---------- 
    a : array_like 
        array of values 
    upperlimit : None or float, optional 
        Values in the input array greater than the given limit will be ignored. 
        When upperlimit is None, then all values are used. The default value 
        is None. 
    axis : int or None, optional 
        Axis along which to operate. Default is 0. If None, compute over the 
        whole array `a`. 
    inclusive : {True, False}, optional 
        This flag determines whether values exactly equal to the upper limit 
        are included.  The default value is True. 
 
    Returns 
    ------- 
    tmax : float, int or ndarray 
 
    Notes 
    ----- 
    For more details on `tmax`, see `scipy.stats.tmax`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import mstats 
    &gt;&gt;&gt; a = np.array([[6, 8, 3, 0], 
    ...               [3, 9, 1, 2], 
    ...               [8, 7, 8, 2], 
    ...               [5, 6, 0, 2], 
    ...               [4, 5, 5, 2]]) 
    ... 
    ... 
    &gt;&gt;&gt; mstats.tmax(a, 4) 
    masked_array(data=[4, --, 3, 2], 
                 mask=[False,  True, False, False], 
           fill_value=999999) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">= </span><span class="s1">_chk_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">am </span><span class="s3">= </span><span class="s1">trima</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, (</span><span class="s5">None</span><span class="s3">, </span><span class="s1">upperlimit</span><span class="s3">), (</span><span class="s5">False</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">))</span>
    <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">.</span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">am</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">tsem</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=(</span><span class="s5">True</span><span class="s3">, </span><span class="s5">True</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s6">1</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the trimmed standard error of the mean. 
 
    This function finds the standard error of the mean for given 
    values, ignoring values outside the given `limits`. 
 
    Parameters 
    ---------- 
    a : array_like 
        array of values 
    limits : None or (lower limit, upper limit), optional 
        Values in the input array less than the lower limit or greater than the 
        upper limit will be ignored. When limits is None, then all values are 
        used. Either of the limit values in the tuple can also be None 
        representing a half-open interval.  The default value is None. 
    inclusive : (bool, bool), optional 
        A tuple consisting of the (lower flag, upper flag).  These flags 
        determine whether values exactly equal to the lower or upper limits 
        are included.  The default value is (True, True). 
    axis : int or None, optional 
        Axis along which to operate. If None, compute over the 
        whole array. Default is zero. 
    ddof : int, optional 
        Delta degrees of freedom. Default is 1. 
 
    Returns 
    ------- 
    tsem : float 
 
    Notes 
    ----- 
    For more details on `tsem`, see `scipy.stats.tsem`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">).</span><span class="s1">ravel</span><span class="s3">()</span>
    <span class="s5">if </span><span class="s1">limits </span><span class="s5">is None</span><span class="s3">:</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">count</span><span class="s3">())</span>
        <span class="s5">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">std</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s1">ddof</span><span class="s3">)/</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>

    <span class="s1">am </span><span class="s3">= </span><span class="s1">trima</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(), </span><span class="s1">limits</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">)</span>
    <span class="s1">sd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">am</span><span class="s3">.</span><span class="s1">var</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s1">ddof</span><span class="s3">))</span>
    <span class="s5">return </span><span class="s1">sd </span><span class="s3">/ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">am</span><span class="s3">.</span><span class="s1">count</span><span class="s3">())</span>


<span class="s5">def </span><span class="s1">winsorize</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=(</span><span class="s5">True</span><span class="s3">, </span><span class="s5">True</span><span class="s3">), </span><span class="s1">inplace</span><span class="s3">=</span><span class="s5">False</span><span class="s3">,</span>
              <span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">nan_policy</span><span class="s3">=</span><span class="s4">'propagate'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Returns a Winsorized version of the input array. 
 
    The (limits[0])th lowest values are set to the (limits[0])th percentile, 
    and the (limits[1])th highest values are set to the (1 - limits[1])th 
    percentile. 
    Masked values are skipped. 
 
 
    Parameters 
    ---------- 
    a : sequence 
        Input array. 
    limits : {None, tuple of float}, optional 
        Tuple of the percentages to cut on each side of the array, with respect 
        to the number of unmasked data, as floats between 0. and 1. 
        Noting n the number of unmasked data before trimming, the 
        (n*limits[0])th smallest data and the (n*limits[1])th largest data are 
        masked, and the total number of unmasked data after trimming 
        is n*(1.-sum(limits)) The value of one limit can be set to None to 
        indicate an open interval. 
    inclusive : {(True, True) tuple}, optional 
        Tuple indicating whether the number of data being masked on each side 
        should be truncated (True) or rounded (False). 
    inplace : {False, True}, optional 
        Whether to winsorize in place (True) or to use a copy (False) 
    axis : {None, int}, optional 
        Axis along which to trim. If None, the whole array is trimmed, but its 
        shape is maintained. 
    nan_policy : {'propagate', 'raise', 'omit'}, optional 
        Defines how to handle when input contains nan. 
        The following options are available (default is 'propagate'): 
 
          * 'propagate': allows nan values and may overwrite or propagate them 
          * 'raise': throws an error 
          * 'omit': performs the calculations ignoring nan values 
 
    Notes 
    ----- 
    This function is applied to reduce the effect of possibly spurious outliers 
    by limiting the extreme values. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats.mstats import winsorize 
 
    A shuffled array contains integers from 1 to 10. 
 
    &gt;&gt;&gt; a = np.array([10, 4, 9, 8, 5, 3, 7, 2, 1, 6]) 
 
    The 10% of the lowest value (i.e., `1`) and the 20% of the highest 
    values (i.e., `9` and `10`) are replaced. 
 
    &gt;&gt;&gt; winsorize(a, limits=[0.1, 0.2]) 
    masked_array(data=[8, 4, 8, 8, 5, 3, 7, 2, 2, 6], 
                 mask=False, 
           fill_value=999999) 
 
    &quot;&quot;&quot;</span>
    <span class="s5">def </span><span class="s1">_winsorize1D</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">low_limit</span><span class="s3">, </span><span class="s1">up_limit</span><span class="s3">, </span><span class="s1">low_include</span><span class="s3">, </span><span class="s1">up_include</span><span class="s3">,</span>
                     <span class="s1">contains_nan</span><span class="s3">, </span><span class="s1">nan_policy</span><span class="s3">):</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">count</span><span class="s3">()</span>
        <span class="s1">idx </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">()</span>
        <span class="s5">if </span><span class="s1">contains_nan</span><span class="s3">:</span>
            <span class="s1">nan_count </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">count_nonzero</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">a</span><span class="s3">))</span>
        <span class="s5">if </span><span class="s1">low_limit</span><span class="s3">:</span>
            <span class="s5">if </span><span class="s1">low_include</span><span class="s3">:</span>
                <span class="s1">lowidx </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">low_limit </span><span class="s3">* </span><span class="s1">n</span><span class="s3">)</span>
            <span class="s5">else</span><span class="s3">:</span>
                <span class="s1">lowidx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">low_limit </span><span class="s3">* </span><span class="s1">n</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
            <span class="s5">if </span><span class="s1">contains_nan </span><span class="s5">and </span><span class="s1">nan_policy </span><span class="s3">== </span><span class="s4">'omit'</span><span class="s3">:</span>
                <span class="s1">lowidx </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">lowidx</span><span class="s3">, </span><span class="s1">n</span><span class="s3">-</span><span class="s1">nan_count</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">[:</span><span class="s1">lowidx</span><span class="s3">]] = </span><span class="s1">a</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">[</span><span class="s1">lowidx</span><span class="s3">]]</span>
        <span class="s5">if </span><span class="s1">up_limit </span><span class="s5">is not None</span><span class="s3">:</span>
            <span class="s5">if </span><span class="s1">up_include</span><span class="s3">:</span>
                <span class="s1">upidx </span><span class="s3">= </span><span class="s1">n </span><span class="s3">- </span><span class="s1">int</span><span class="s3">(</span><span class="s1">n </span><span class="s3">* </span><span class="s1">up_limit</span><span class="s3">)</span>
            <span class="s5">else</span><span class="s3">:</span>
                <span class="s1">upidx </span><span class="s3">= </span><span class="s1">n </span><span class="s3">- </span><span class="s1">np</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">n </span><span class="s3">* </span><span class="s1">up_limit</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
            <span class="s5">if </span><span class="s1">contains_nan </span><span class="s5">and </span><span class="s1">nan_policy </span><span class="s3">== </span><span class="s4">'omit'</span><span class="s3">:</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">[</span><span class="s1">upidx</span><span class="s3">:-</span><span class="s1">nan_count</span><span class="s3">]] = </span><span class="s1">a</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">[</span><span class="s1">upidx </span><span class="s3">- </span><span class="s6">1</span><span class="s3">]]</span>
            <span class="s5">else</span><span class="s3">:</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">[</span><span class="s1">upidx</span><span class="s3">:]] = </span><span class="s1">a</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">[</span><span class="s1">upidx </span><span class="s3">- </span><span class="s6">1</span><span class="s3">]]</span>
        <span class="s5">return </span><span class="s1">a</span>

    <span class="s1">contains_nan</span><span class="s3">, </span><span class="s1">nan_policy </span><span class="s3">= </span><span class="s1">_contains_nan</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">nan_policy</span><span class="s3">)</span>
    <span class="s2"># We are going to modify a: better make a copy</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">logical_not</span><span class="s3">(</span><span class="s1">inplace</span><span class="s3">))</span>

    <span class="s5">if </span><span class="s1">limits </span><span class="s5">is None</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">a</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s5">not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">limits</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)) </span><span class="s5">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">limits</span><span class="s3">, </span><span class="s1">float</span><span class="s3">):</span>
        <span class="s1">limits </span><span class="s3">= (</span><span class="s1">limits</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">)</span>

    <span class="s2"># Check the limits</span>
    <span class="s3">(</span><span class="s1">lolim</span><span class="s3">, </span><span class="s1">uplim</span><span class="s3">) = </span><span class="s1">limits</span>
    <span class="s1">errmsg </span><span class="s3">= </span><span class="s4">&quot;The proportion to cut from the %s should be between 0. and 1.&quot;</span>
    <span class="s5">if </span><span class="s1">lolim </span><span class="s5">is not None</span><span class="s3">:</span>
        <span class="s5">if </span><span class="s1">lolim </span><span class="s3">&gt; </span><span class="s6">1. </span><span class="s5">or </span><span class="s1">lolim </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">errmsg </span><span class="s3">% </span><span class="s4">'beginning' </span><span class="s3">+ </span><span class="s4">&quot;(got %s)&quot; </span><span class="s3">% </span><span class="s1">lolim</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">uplim </span><span class="s5">is not None</span><span class="s3">:</span>
        <span class="s5">if </span><span class="s1">uplim </span><span class="s3">&gt; </span><span class="s6">1. </span><span class="s5">or </span><span class="s1">uplim </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">errmsg </span><span class="s3">% </span><span class="s4">'end' </span><span class="s3">+ </span><span class="s4">&quot;(got %s)&quot; </span><span class="s3">% </span><span class="s1">uplim</span><span class="s3">)</span>

    <span class="s3">(</span><span class="s1">loinc</span><span class="s3">, </span><span class="s1">upinc</span><span class="s3">) = </span><span class="s1">inclusive</span>

    <span class="s5">if </span><span class="s1">axis </span><span class="s5">is None</span><span class="s3">:</span>
        <span class="s1">shp </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s5">return </span><span class="s1">_winsorize1D</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(), </span><span class="s1">lolim</span><span class="s3">, </span><span class="s1">uplim</span><span class="s3">, </span><span class="s1">loinc</span><span class="s3">, </span><span class="s1">upinc</span><span class="s3">,</span>
                            <span class="s1">contains_nan</span><span class="s3">, </span><span class="s1">nan_policy</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">shp</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">apply_along_axis</span><span class="s3">(</span><span class="s1">_winsorize1D</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">lolim</span><span class="s3">, </span><span class="s1">uplim</span><span class="s3">, </span><span class="s1">loinc</span><span class="s3">,</span>
                                   <span class="s1">upinc</span><span class="s3">, </span><span class="s1">contains_nan</span><span class="s3">, </span><span class="s1">nan_policy</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">moment</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">moment</span><span class="s3">=</span><span class="s6">1</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculates the nth moment about the mean for a sample. 
 
    Parameters 
    ---------- 
    a : array_like 
       data 
    moment : int, optional 
       order of central moment that is returned 
    axis : int or None, optional 
       Axis along which the central moment is computed. Default is 0. 
       If None, compute over the whole array `a`. 
 
    Returns 
    ------- 
    n-th central moment : ndarray or float 
       The appropriate moment along the given axis or over all values if axis 
       is None. The denominator for the moment calculation is the number of 
       observations, no degrees of freedom correction is done. 
 
    Notes 
    ----- 
    For more details about `moment`, see `scipy.stats.moment`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">= </span><span class="s1">_chk_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s1">moment_shape </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s5">del </span><span class="s1">moment_shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type </span><span class="s5">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s5">in </span><span class="s4">'fc' </span><span class="s5">else </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span>
        <span class="s2"># empty array, return nan(s) with shape matching `moment`</span>
        <span class="s1">out_shape </span><span class="s3">= (</span><span class="s1">moment_shape </span><span class="s5">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">moment</span><span class="s3">)</span>
                     <span class="s5">else </span><span class="s3">[</span><span class="s1">len</span><span class="s3">(</span><span class="s1">moment</span><span class="s3">)] + </span><span class="s1">moment_shape</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">out_shape</span><span class="s3">) == </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s5">return </span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">)</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">out_shape</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">))</span>

    <span class="s2"># for array_like moment input, return a value for each.</span>
    <span class="s5">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">moment</span><span class="s3">):</span>
        <span class="s1">mean </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s5">True</span><span class="s3">)</span>
        <span class="s1">mmnt </span><span class="s3">= [</span><span class="s1">_moment</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mean</span><span class="s3">=</span><span class="s1">mean</span><span class="s3">) </span><span class="s5">for </span><span class="s1">i </span><span class="s5">in </span><span class="s1">moment</span><span class="s3">]</span>
        <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">mmnt</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">_moment</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">moment</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>


<span class="s2"># Moment with optional pre-computed mean, equal to a.mean(axis, keepdims=True)</span>
<span class="s5">def </span><span class="s1">_moment</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">moment</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, *, </span><span class="s1">mean</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s5">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">moment </span><span class="s3">- </span><span class="s1">np</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">moment</span><span class="s3">)) &gt; </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;All moment parameters must be integers&quot;</span><span class="s3">)</span>

    <span class="s5">if </span><span class="s1">moment </span><span class="s3">== </span><span class="s6">0 </span><span class="s5">or </span><span class="s1">moment </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s2"># By definition the zeroth moment about the mean is 1, and the first</span>
        <span class="s2"># moment is 0.</span>
        <span class="s1">shape </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s5">del </span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type </span><span class="s5">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s5">in </span><span class="s4">'fc' </span><span class="s5">else </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span>

        <span class="s5">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">) == </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s5">return </span><span class="s1">dtype</span><span class="s3">(</span><span class="s6">1.0 </span><span class="s5">if </span><span class="s1">moment </span><span class="s3">== </span><span class="s6">0 </span><span class="s5">else </span><span class="s6">0.0</span><span class="s3">)</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s5">return </span><span class="s3">(</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">) </span><span class="s5">if </span><span class="s1">moment </span><span class="s3">== </span><span class="s6">0</span>
                    <span class="s5">else </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">))</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s2"># Exponentiation by squares: form exponent sequence</span>
        <span class="s1">n_list </span><span class="s3">= [</span><span class="s1">moment</span><span class="s3">]</span>
        <span class="s1">current_n </span><span class="s3">= </span><span class="s1">moment</span>
        <span class="s5">while </span><span class="s1">current_n </span><span class="s3">&gt; </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s5">if </span><span class="s1">current_n </span><span class="s3">% </span><span class="s6">2</span><span class="s3">:</span>
                <span class="s1">current_n </span><span class="s3">= (</span><span class="s1">current_n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)/</span><span class="s6">2</span>
            <span class="s5">else</span><span class="s3">:</span>
                <span class="s1">current_n </span><span class="s3">/= </span><span class="s6">2</span>
            <span class="s1">n_list</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">current_n</span><span class="s3">)</span>

        <span class="s2"># Starting point for exponentiation by squares</span>
        <span class="s1">mean </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s5">True</span><span class="s3">) </span><span class="s5">if </span><span class="s1">mean </span><span class="s5">is None else </span><span class="s1">mean</span>
        <span class="s1">a_zero_mean </span><span class="s3">= </span><span class="s1">a </span><span class="s3">- </span><span class="s1">mean</span>
        <span class="s5">if </span><span class="s1">n_list</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">] == </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s1">a_zero_mean</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s1">a_zero_mean</span><span class="s3">**</span><span class="s6">2</span>

        <span class="s2"># Perform multiplications</span>
        <span class="s5">for </span><span class="s1">n </span><span class="s5">in </span><span class="s1">n_list</span><span class="s3">[-</span><span class="s6">2</span><span class="s3">::-</span><span class="s6">1</span><span class="s3">]:</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s1">s</span><span class="s3">**</span><span class="s6">2</span>
            <span class="s5">if </span><span class="s1">n </span><span class="s3">% </span><span class="s6">2</span><span class="s3">:</span>
                <span class="s1">s </span><span class="s3">*= </span><span class="s1">a_zero_mean</span>
        <span class="s5">return </span><span class="s1">s</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">variation</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s6">0</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the coefficient of variation. 
 
    The coefficient of variation is the standard deviation divided by the 
    mean.  This function is equivalent to:: 
 
        np.std(x, axis=axis, ddof=ddof) / np.mean(x) 
 
    The default for ``ddof`` is 0, but many definitions of the coefficient 
    of variation use the square root of the unbiased sample variance 
    for the sample standard deviation, which corresponds to ``ddof=1``. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array. 
    axis : int or None, optional 
        Axis along which to calculate the coefficient of variation. Default 
        is 0. If None, compute over the whole array `a`. 
    ddof : int, optional 
        Delta degrees of freedom.  Default is 0. 
 
    Returns 
    ------- 
    variation : ndarray 
        The calculated variation along the requested axis. 
 
    Notes 
    ----- 
    For more details about `variation`, see `scipy.stats.variation`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats.mstats import variation 
    &gt;&gt;&gt; a = np.array([2,8,4]) 
    &gt;&gt;&gt; variation(a) 
    0.5345224838248487 
    &gt;&gt;&gt; b = np.array([2,8,3,4]) 
    &gt;&gt;&gt; c = np.ma.masked_array(b, mask=[0,0,1,0]) 
    &gt;&gt;&gt; variation(c) 
    0.5345224838248487 
 
    In the example above, it can be seen that this works the same as 
    `scipy.stats.variation` except 'stats.mstats.variation' ignores masked 
    array elements. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">= </span><span class="s1">_chk_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s1">a</span><span class="s3">.</span><span class="s1">std</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s1">ddof</span><span class="s3">)/</span><span class="s1">a</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">skew</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">bias</span><span class="s3">=</span><span class="s5">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes the skewness of a data set. 
 
    Parameters 
    ---------- 
    a : ndarray 
        data 
    axis : int or None, optional 
        Axis along which skewness is calculated. Default is 0. 
        If None, compute over the whole array `a`. 
    bias : bool, optional 
        If False, then the calculations are corrected for statistical bias. 
 
    Returns 
    ------- 
    skewness : ndarray 
        The skewness of values along an axis, returning 0 where all values are 
        equal. 
 
    Notes 
    ----- 
    For more details about `skew`, see `scipy.stats.skew`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">= </span><span class="s1">_chk_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">,</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">mean </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s5">True</span><span class="s3">)</span>
    <span class="s1">m2 </span><span class="s3">= </span><span class="s1">_moment</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mean</span><span class="s3">=</span><span class="s1">mean</span><span class="s3">)</span>
    <span class="s1">m3 </span><span class="s3">= </span><span class="s1">_moment</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">3</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mean</span><span class="s3">=</span><span class="s1">mean</span><span class="s3">)</span>
    <span class="s1">zero </span><span class="s3">= (</span><span class="s1">m2 </span><span class="s3">&lt;= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">m2</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">resolution </span><span class="s3">* </span><span class="s1">mean</span><span class="s3">.</span><span class="s1">squeeze</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">))**</span><span class="s6">2</span><span class="s3">)</span>
    <span class="s5">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">all</span><span class="s3">=</span><span class="s4">'ignore'</span><span class="s3">):</span>
        <span class="s1">vals </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">zero</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s1">m3 </span><span class="s3">/ </span><span class="s1">m2</span><span class="s3">**</span><span class="s6">1.5</span><span class="s3">)</span>

    <span class="s5">if not </span><span class="s1">bias </span><span class="s5">and </span><span class="s1">zero </span><span class="s5">is not </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">masked </span><span class="s5">and </span><span class="s1">m2 </span><span class="s5">is not </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">masked</span><span class="s3">:</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s1">can_correct </span><span class="s3">= ~</span><span class="s1">zero </span><span class="s3">&amp; (</span><span class="s1">n </span><span class="s3">&gt; </span><span class="s6">2</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">can_correct</span><span class="s3">.</span><span class="s1">any</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">extract</span><span class="s3">(</span><span class="s1">can_correct</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
            <span class="s1">m2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">extract</span><span class="s3">(</span><span class="s1">can_correct</span><span class="s3">, </span><span class="s1">m2</span><span class="s3">)</span>
            <span class="s1">m3 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">extract</span><span class="s3">(</span><span class="s1">can_correct</span><span class="s3">, </span><span class="s1">m3</span><span class="s3">)</span>
            <span class="s1">nval </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">((</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1.0</span><span class="s3">)*</span><span class="s1">n</span><span class="s3">)/(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">2.0</span><span class="s3">)*</span><span class="s1">m3</span><span class="s3">/</span><span class="s1">m2</span><span class="s3">**</span><span class="s6">1.5</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">place</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">, </span><span class="s1">can_correct</span><span class="s3">, </span><span class="s1">nval</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s1">vals</span>


<span class="s5">def </span><span class="s1">kurtosis</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">fisher</span><span class="s3">=</span><span class="s5">True</span><span class="s3">, </span><span class="s1">bias</span><span class="s3">=</span><span class="s5">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes the kurtosis (Fisher or Pearson) of a dataset. 
 
    Kurtosis is the fourth central moment divided by the square of the 
    variance. If Fisher's definition is used, then 3.0 is subtracted from 
    the result to give 0.0 for a normal distribution. 
 
    If bias is False then the kurtosis is calculated using k statistics to 
    eliminate bias coming from biased moment estimators 
 
    Use `kurtosistest` to see if result is close enough to normal. 
 
    Parameters 
    ---------- 
    a : array 
        data for which the kurtosis is calculated 
    axis : int or None, optional 
        Axis along which the kurtosis is calculated. Default is 0. 
        If None, compute over the whole array `a`. 
    fisher : bool, optional 
        If True, Fisher's definition is used (normal ==&gt; 0.0). If False, 
        Pearson's definition is used (normal ==&gt; 3.0). 
    bias : bool, optional 
        If False, then the calculations are corrected for statistical bias. 
 
    Returns 
    ------- 
    kurtosis : array 
        The kurtosis of values along an axis. If all values are equal, 
        return -3 for Fisher's definition and 0 for Pearson's definition. 
 
    Notes 
    ----- 
    For more details about `kurtosis`, see `scipy.stats.kurtosis`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">= </span><span class="s1">_chk_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">mean </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s5">True</span><span class="s3">)</span>
    <span class="s1">m2 </span><span class="s3">= </span><span class="s1">_moment</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mean</span><span class="s3">=</span><span class="s1">mean</span><span class="s3">)</span>
    <span class="s1">m4 </span><span class="s3">= </span><span class="s1">_moment</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">4</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mean</span><span class="s3">=</span><span class="s1">mean</span><span class="s3">)</span>
    <span class="s1">zero </span><span class="s3">= (</span><span class="s1">m2 </span><span class="s3">&lt;= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">m2</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">resolution </span><span class="s3">* </span><span class="s1">mean</span><span class="s3">.</span><span class="s1">squeeze</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">))**</span><span class="s6">2</span><span class="s3">)</span>
    <span class="s5">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">all</span><span class="s3">=</span><span class="s4">'ignore'</span><span class="s3">):</span>
        <span class="s1">vals </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">zero</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s1">m4 </span><span class="s3">/ </span><span class="s1">m2</span><span class="s3">**</span><span class="s6">2.0</span><span class="s3">)</span>

    <span class="s5">if not </span><span class="s1">bias </span><span class="s5">and </span><span class="s1">zero </span><span class="s5">is not </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">masked </span><span class="s5">and </span><span class="s1">m2 </span><span class="s5">is not </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">masked</span><span class="s3">:</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s1">can_correct </span><span class="s3">= ~</span><span class="s1">zero </span><span class="s3">&amp; (</span><span class="s1">n </span><span class="s3">&gt; </span><span class="s6">3</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">can_correct</span><span class="s3">.</span><span class="s1">any</span><span class="s3">():</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">extract</span><span class="s3">(</span><span class="s1">can_correct</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
            <span class="s1">m2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">extract</span><span class="s3">(</span><span class="s1">can_correct</span><span class="s3">, </span><span class="s1">m2</span><span class="s3">)</span>
            <span class="s1">m4 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">extract</span><span class="s3">(</span><span class="s1">can_correct</span><span class="s3">, </span><span class="s1">m4</span><span class="s3">)</span>
            <span class="s1">nval </span><span class="s3">= </span><span class="s6">1.0</span><span class="s3">/(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">2</span><span class="s3">)/(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">3</span><span class="s3">)*((</span><span class="s1">n</span><span class="s3">*</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1.0</span><span class="s3">)*</span><span class="s1">m4</span><span class="s3">/</span><span class="s1">m2</span><span class="s3">**</span><span class="s6">2.0</span><span class="s3">-</span><span class="s6">3</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)**</span><span class="s6">2.0</span><span class="s3">)</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">place</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">, </span><span class="s1">can_correct</span><span class="s3">, </span><span class="s1">nval</span><span class="s3">+</span><span class="s6">3.0</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">fisher</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">vals </span><span class="s3">- </span><span class="s6">3</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">vals</span>


<span class="s1">DescribeResult </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'DescribeResult'</span><span class="s3">, (</span><span class="s4">'nobs'</span><span class="s3">, </span><span class="s4">'minmax'</span><span class="s3">, </span><span class="s4">'mean'</span><span class="s3">,</span>
                                               <span class="s4">'variance'</span><span class="s3">, </span><span class="s4">'skewness'</span><span class="s3">,</span>
                                               <span class="s4">'kurtosis'</span><span class="s3">))</span>


<span class="s5">def </span><span class="s1">describe</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">bias</span><span class="s3">=</span><span class="s5">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes several descriptive statistics of the passed array. 
 
    Parameters 
    ---------- 
    a : array_like 
        Data array 
    axis : int or None, optional 
        Axis along which to calculate statistics. Default 0. If None, 
        compute over the whole array `a`. 
    ddof : int, optional 
        degree of freedom (default 0); note that default ddof is different 
        from the same routine in stats.describe 
    bias : bool, optional 
        If False, then the skewness and kurtosis calculations are corrected for 
        statistical bias. 
 
    Returns 
    ------- 
    nobs : int 
        (size of the data (discarding missing values) 
 
    minmax : (int, int) 
        min, max 
 
    mean : float 
        arithmetic mean 
 
    variance : float 
        unbiased variance 
 
    skewness : float 
        biased skewness 
 
    kurtosis : float 
        biased kurtosis 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats.mstats import describe 
    &gt;&gt;&gt; ma = np.ma.array(range(6), mask=[0, 0, 0, 1, 1, 1]) 
    &gt;&gt;&gt; describe(ma) 
    DescribeResult(nobs=np.int64(3), minmax=(masked_array(data=0, 
                 mask=False, 
           fill_value=999999), masked_array(data=2, 
                 mask=False, 
           fill_value=999999)), mean=np.float64(1.0), 
           variance=np.float64(0.6666666666666666), 
           skewness=masked_array(data=0., mask=False, fill_value=1e+20), 
            kurtosis=np.float64(-1.5)) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">= </span><span class="s1">_chk_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">mm </span><span class="s3">= (</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">minimum</span><span class="s3">.</span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">), </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">.</span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">))</span>
    <span class="s1">m </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">v </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">var</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s1">ddof</span><span class="s3">)</span>
    <span class="s1">sk </span><span class="s3">= </span><span class="s1">skew</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">bias</span><span class="s3">=</span><span class="s1">bias</span><span class="s3">)</span>
    <span class="s1">kurt </span><span class="s3">= </span><span class="s1">kurtosis</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">bias</span><span class="s3">=</span><span class="s1">bias</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">DescribeResult</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">mm</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">sk</span><span class="s3">, </span><span class="s1">kurt</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">stde_median</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Returns the McKean-Schrader estimate of the standard error of the sample 
    median along the given axis. masked values are discarded. 
 
    Parameters 
    ---------- 
    data : ndarray 
        Data to trim. 
    axis : {None,int}, optional 
        Axis along which to perform the trimming. 
        If None, the input array is first flattened. 
 
    &quot;&quot;&quot;</span>
    <span class="s5">def </span><span class="s1">_stdemed_1D</span><span class="s3">(</span><span class="s1">data</span><span class="s3">):</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">compressed</span><span class="s3">())</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
        <span class="s1">z </span><span class="s3">= </span><span class="s6">2.5758293035489004</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">round</span><span class="s3">((</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)/</span><span class="s6">2. </span><span class="s3">- </span><span class="s1">z </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">n</span><span class="s3">/</span><span class="s6">4.</span><span class="s3">),</span><span class="s6">0</span><span class="s3">))</span>
        <span class="s5">return </span><span class="s3">((</span><span class="s1">data</span><span class="s3">[</span><span class="s1">n</span><span class="s3">-</span><span class="s1">k</span><span class="s3">] - </span><span class="s1">data</span><span class="s3">[</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">])/(</span><span class="s6">2.</span><span class="s3">*</span><span class="s1">z</span><span class="s3">))</span>

    <span class="s1">data </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">False</span><span class="s3">, </span><span class="s1">subok</span><span class="s3">=</span><span class="s5">True</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s1">axis </span><span class="s5">is None</span><span class="s3">):</span>
        <span class="s5">return </span><span class="s1">_stdemed_1D</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Array 'data' must be at most two dimensional, &quot;</span>
                             <span class="s4">&quot;but got data.ndim = %d&quot; </span><span class="s3">% </span><span class="s1">data</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">apply_along_axis</span><span class="s3">(</span><span class="s1">_stdemed_1D</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">data</span><span class="s3">)</span>


<span class="s1">SkewtestResult </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'SkewtestResult'</span><span class="s3">, (</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s3">))</span>


<span class="s5">def </span><span class="s1">skewtest</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">=</span><span class="s4">'two-sided'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests whether the skew is different from the normal distribution. 
 
    Parameters 
    ---------- 
    a : array_like 
        The data to be tested 
    axis : int or None, optional 
       Axis along which statistics are calculated. Default is 0. 
       If None, compute over the whole array `a`. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. Default is 'two-sided'. 
        The following options are available: 
 
        * 'two-sided': the skewness of the distribution underlying the sample 
          is different from that of the normal distribution (i.e. 0) 
        * 'less': the skewness of the distribution underlying the sample 
          is less than that of the normal distribution 
        * 'greater': the skewness of the distribution underlying the sample 
          is greater than that of the normal distribution 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    statistic : array_like 
        The computed z-score for this test. 
    pvalue : array_like 
        A p-value for the hypothesis test 
 
    Notes 
    ----- 
    For more details about `skewtest`, see `scipy.stats.skewtest`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">= </span><span class="s1">_chk_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">axis </span><span class="s5">is None</span><span class="s3">:</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()</span>
        <span class="s1">axis </span><span class="s3">= </span><span class="s6">0</span>
    <span class="s1">b2 </span><span class="s3">= </span><span class="s1">skew</span><span class="s3">(</span><span class="s1">a</span><span class="s3">,</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) &lt; </span><span class="s6">8</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
            <span class="s4">&quot;skewtest is not valid with less than 8 samples; %i samples&quot;</span>
            <span class="s4">&quot; were given.&quot; </span><span class="s3">% </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">n</span><span class="s3">))</span>

    <span class="s1">y </span><span class="s3">= </span><span class="s1">b2 </span><span class="s3">* </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(((</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)*(</span><span class="s1">n</span><span class="s3">+</span><span class="s6">3</span><span class="s3">)) / (</span><span class="s6">6.0</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">2</span><span class="s3">)))</span>
    <span class="s1">beta2 </span><span class="s3">= (</span><span class="s6">3.0</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">*</span><span class="s1">n</span><span class="s3">+</span><span class="s6">27</span><span class="s3">*</span><span class="s1">n</span><span class="s3">-</span><span class="s6">70</span><span class="s3">)*(</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)*(</span><span class="s1">n</span><span class="s3">+</span><span class="s6">3</span><span class="s3">)) / ((</span><span class="s1">n</span><span class="s3">-</span><span class="s6">2.0</span><span class="s3">)*(</span><span class="s1">n</span><span class="s3">+</span><span class="s6">5</span><span class="s3">)*(</span><span class="s1">n</span><span class="s3">+</span><span class="s6">7</span><span class="s3">)*(</span><span class="s1">n</span><span class="s3">+</span><span class="s6">9</span><span class="s3">))</span>
    <span class="s1">W2 </span><span class="s3">= -</span><span class="s6">1 </span><span class="s3">+ </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s6">2</span><span class="s3">*(</span><span class="s1">beta2</span><span class="s3">-</span><span class="s6">1</span><span class="s3">))</span>
    <span class="s1">delta </span><span class="s3">= </span><span class="s6">1</span><span class="s3">/</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s6">0.5</span><span class="s3">*</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">W2</span><span class="s3">))</span>
    <span class="s1">alpha </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s6">2.0</span><span class="s3">/(</span><span class="s1">W2</span><span class="s3">-</span><span class="s6">1</span><span class="s3">))</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">y </span><span class="s3">== </span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">Z </span><span class="s3">= </span><span class="s1">delta</span><span class="s3">*</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">y</span><span class="s3">/</span><span class="s1">alpha </span><span class="s3">+ </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">((</span><span class="s1">y</span><span class="s3">/</span><span class="s1">alpha</span><span class="s3">)**</span><span class="s6">2</span><span class="s3">+</span><span class="s6">1</span><span class="s3">))</span>
    <span class="s1">pvalue </span><span class="s3">= </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats</span><span class="s3">.</span><span class="s1">_stats_py</span><span class="s3">.</span><span class="s1">_get_pvalue</span><span class="s3">(</span><span class="s1">Z</span><span class="s3">, </span><span class="s1">distributions</span><span class="s3">.</span><span class="s1">norm</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">SkewtestResult</span><span class="s3">(</span><span class="s1">Z</span><span class="s3">[()], </span><span class="s1">pvalue</span><span class="s3">[()])</span>


<span class="s1">KurtosistestResult </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'KurtosistestResult'</span><span class="s3">, (</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s3">))</span>


<span class="s5">def </span><span class="s1">kurtosistest</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">=</span><span class="s4">'two-sided'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests whether a dataset has normal kurtosis 
 
    Parameters 
    ---------- 
    a : array_like 
        array of the sample data 
    axis : int or None, optional 
       Axis along which to compute test. Default is 0. If None, 
       compute over the whole array `a`. 
    alternative : {'two-sided', 'less', 'greater'}, optional 
        Defines the alternative hypothesis. 
        The following options are available (default is 'two-sided'): 
 
        * 'two-sided': the kurtosis of the distribution underlying the sample 
          is different from that of the normal distribution 
        * 'less': the kurtosis of the distribution underlying the sample 
          is less than that of the normal distribution 
        * 'greater': the kurtosis of the distribution underlying the sample 
          is greater than that of the normal distribution 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    statistic : array_like 
        The computed z-score for this test. 
    pvalue : array_like 
        The p-value for the hypothesis test 
 
    Notes 
    ----- 
    For more details about `kurtosistest`, see `scipy.stats.kurtosistest`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">= </span><span class="s1">_chk_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) &lt; </span><span class="s6">5</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
            <span class="s4">&quot;kurtosistest requires at least 5 observations; %i observations&quot;</span>
            <span class="s4">&quot; were given.&quot; </span><span class="s3">% </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">n</span><span class="s3">))</span>
    <span class="s5">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) &lt; </span><span class="s6">20</span><span class="s3">:</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">&quot;kurtosistest only valid for n&gt;=20 ... continuing anyway, n=%i&quot; </span><span class="s3">% </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">n</span><span class="s3">),</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s6">2</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s1">b2 </span><span class="s3">= </span><span class="s1">kurtosis</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">fisher</span><span class="s3">=</span><span class="s5">False</span><span class="s3">)</span>
    <span class="s1">E </span><span class="s3">= </span><span class="s6">3.0</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">) / (</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">varb2 </span><span class="s3">= </span><span class="s6">24.0</span><span class="s3">*</span><span class="s1">n</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">2.</span><span class="s3">)*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">3</span><span class="s3">) / ((</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)*(</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1.</span><span class="s3">)*(</span><span class="s1">n</span><span class="s3">+</span><span class="s6">3</span><span class="s3">)*(</span><span class="s1">n</span><span class="s3">+</span><span class="s6">5</span><span class="s3">))</span>
    <span class="s1">x </span><span class="s3">= (</span><span class="s1">b2</span><span class="s3">-</span><span class="s1">E</span><span class="s3">)/</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">varb2</span><span class="s3">)</span>
    <span class="s1">sqrtbeta1 </span><span class="s3">= </span><span class="s6">6.0</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">*</span><span class="s1">n</span><span class="s3">-</span><span class="s6">5</span><span class="s3">*</span><span class="s1">n</span><span class="s3">+</span><span class="s6">2</span><span class="s3">)/((</span><span class="s1">n</span><span class="s3">+</span><span class="s6">7</span><span class="s3">)*(</span><span class="s1">n</span><span class="s3">+</span><span class="s6">9</span><span class="s3">)) * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">((</span><span class="s6">6.0</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">+</span><span class="s6">3</span><span class="s3">)*(</span><span class="s1">n</span><span class="s3">+</span><span class="s6">5</span><span class="s3">)) /</span>
                                                        <span class="s3">(</span><span class="s1">n</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">2</span><span class="s3">)*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">3</span><span class="s3">)))</span>
    <span class="s1">A </span><span class="s3">= </span><span class="s6">6.0 </span><span class="s3">+ </span><span class="s6">8.0</span><span class="s3">/</span><span class="s1">sqrtbeta1 </span><span class="s3">* (</span><span class="s6">2.0</span><span class="s3">/</span><span class="s1">sqrtbeta1 </span><span class="s3">+ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s6">1</span><span class="s3">+</span><span class="s6">4.0</span><span class="s3">/(</span><span class="s1">sqrtbeta1</span><span class="s3">**</span><span class="s6">2</span><span class="s3">)))</span>
    <span class="s1">term1 </span><span class="s3">= </span><span class="s6">1 </span><span class="s3">- </span><span class="s6">2.</span><span class="s3">/(</span><span class="s6">9.0</span><span class="s3">*</span><span class="s1">A</span><span class="s3">)</span>
    <span class="s1">denom </span><span class="s3">= </span><span class="s6">1 </span><span class="s3">+ </span><span class="s1">x</span><span class="s3">*</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s6">2</span><span class="s3">/(</span><span class="s1">A</span><span class="s3">-</span><span class="s6">4.0</span><span class="s3">))</span>
    <span class="s5">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">isMaskedArray</span><span class="s3">(</span><span class="s1">denom</span><span class="s3">):</span>
        <span class="s2"># For multi-dimensional array input</span>
        <span class="s1">denom</span><span class="s3">[</span><span class="s1">denom </span><span class="s3">== </span><span class="s6">0.0</span><span class="s3">] = </span><span class="s1">masked</span>
    <span class="s5">elif </span><span class="s1">denom </span><span class="s3">== </span><span class="s6">0.0</span><span class="s3">:</span>
        <span class="s1">denom </span><span class="s3">= </span><span class="s1">masked</span>

    <span class="s1">term2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">denom </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">, </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">power</span><span class="s3">((</span><span class="s6">1</span><span class="s3">-</span><span class="s6">2.0</span><span class="s3">/</span><span class="s1">A</span><span class="s3">)/</span><span class="s1">denom</span><span class="s3">, </span><span class="s6">1</span><span class="s3">/</span><span class="s6">3.0</span><span class="s3">),</span>
                        <span class="s3">-</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(-(</span><span class="s6">1</span><span class="s3">-</span><span class="s6">2.0</span><span class="s3">/</span><span class="s1">A</span><span class="s3">)/</span><span class="s1">denom</span><span class="s3">, </span><span class="s6">1</span><span class="s3">/</span><span class="s6">3.0</span><span class="s3">))</span>
    <span class="s1">Z </span><span class="s3">= (</span><span class="s1">term1 </span><span class="s3">- </span><span class="s1">term2</span><span class="s3">) / </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s6">2</span><span class="s3">/(</span><span class="s6">9.0</span><span class="s3">*</span><span class="s1">A</span><span class="s3">))</span>
    <span class="s1">pvalue </span><span class="s3">= </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats</span><span class="s3">.</span><span class="s1">_stats_py</span><span class="s3">.</span><span class="s1">_get_pvalue</span><span class="s3">(</span><span class="s1">Z</span><span class="s3">, </span><span class="s1">distributions</span><span class="s3">.</span><span class="s1">norm</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">KurtosistestResult</span><span class="s3">(</span><span class="s1">Z</span><span class="s3">[()], </span><span class="s1">pvalue</span><span class="s3">[()])</span>


<span class="s1">NormaltestResult </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'NormaltestResult'</span><span class="s3">, (</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s3">))</span>


<span class="s5">def </span><span class="s1">normaltest</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests whether a sample differs from a normal distribution. 
 
    Parameters 
    ---------- 
    a : array_like 
        The array containing the data to be tested. 
    axis : int or None, optional 
        Axis along which to compute test. Default is 0. If None, 
        compute over the whole array `a`. 
 
    Returns 
    ------- 
    statistic : float or array 
        ``s^2 + k^2``, where ``s`` is the z-score returned by `skewtest` and 
        ``k`` is the z-score returned by `kurtosistest`. 
    pvalue : float or array 
       A 2-sided chi squared probability for the hypothesis test. 
 
    Notes 
    ----- 
    For more details about `normaltest`, see `scipy.stats.normaltest`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">= </span><span class="s1">_chk_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">s</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">skewtest</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">k</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">kurtosistest</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">k2 </span><span class="s3">= </span><span class="s1">s</span><span class="s3">*</span><span class="s1">s </span><span class="s3">+ </span><span class="s1">k</span><span class="s3">*</span><span class="s1">k</span>

    <span class="s5">return </span><span class="s1">NormaltestResult</span><span class="s3">(</span><span class="s1">k2</span><span class="s3">, </span><span class="s1">distributions</span><span class="s3">.</span><span class="s1">chi2</span><span class="s3">.</span><span class="s1">sf</span><span class="s3">(</span><span class="s1">k2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">))</span>


<span class="s5">def </span><span class="s1">mquantiles</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">=</span><span class="s1">list</span><span class="s3">([</span><span class="s6">.25</span><span class="s3">,</span><span class="s6">.5</span><span class="s3">,</span><span class="s6">.75</span><span class="s3">]), </span><span class="s1">alphap</span><span class="s3">=</span><span class="s6">.4</span><span class="s3">, </span><span class="s1">betap</span><span class="s3">=</span><span class="s6">.4</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
               <span class="s1">limit</span><span class="s3">=()):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes empirical quantiles for a data array. 
 
    Samples quantile are defined by ``Q(p) = (1-gamma)*x[j] + gamma*x[j+1]``, 
    where ``x[j]`` is the j-th order statistic, and gamma is a function of 
    ``j = floor(n*p + m)``, ``m = alphap + p*(1 - alphap - betap)`` and 
    ``g = n*p + m - j``. 
 
    Reinterpreting the above equations to compare to **R** lead to the 
    equation: ``p(k) = (k - alphap)/(n + 1 - alphap - betap)`` 
 
    Typical values of (alphap,betap) are: 
        - (0,1)    : ``p(k) = k/n`` : linear interpolation of cdf 
          (**R** type 4) 
        - (.5,.5)  : ``p(k) = (k - 1/2.)/n`` : piecewise linear function 
          (**R** type 5) 
        - (0,0)    : ``p(k) = k/(n+1)`` : 
          (**R** type 6) 
        - (1,1)    : ``p(k) = (k-1)/(n-1)``: p(k) = mode[F(x[k])]. 
          (**R** type 7, **R** default) 
        - (1/3,1/3): ``p(k) = (k-1/3)/(n+1/3)``: Then p(k) ~ median[F(x[k])]. 
          The resulting quantile estimates are approximately median-unbiased 
          regardless of the distribution of x. 
          (**R** type 8) 
        - (3/8,3/8): ``p(k) = (k-3/8)/(n+1/4)``: Blom. 
          The resulting quantile estimates are approximately unbiased 
          if x is normally distributed 
          (**R** type 9) 
        - (.4,.4)  : approximately quantile unbiased (Cunnane) 
        - (.35,.35): APL, used with PWM 
 
    Parameters 
    ---------- 
    a : array_like 
        Input data, as a sequence or array of dimension at most 2. 
    prob : array_like, optional 
        List of quantiles to compute. 
    alphap : float, optional 
        Plotting positions parameter, default is 0.4. 
    betap : float, optional 
        Plotting positions parameter, default is 0.4. 
    axis : int, optional 
        Axis along which to perform the trimming. 
        If None (default), the input array is first flattened. 
    limit : tuple, optional 
        Tuple of (lower, upper) values. 
        Values of `a` outside this open interval are ignored. 
 
    Returns 
    ------- 
    mquantiles : MaskedArray 
        An array containing the calculated quantiles. 
 
    Notes 
    ----- 
    This formulation is very similar to **R** except the calculation of 
    ``m`` from ``alphap`` and ``betap``, where in **R** ``m`` is defined 
    with each type. 
 
    References 
    ---------- 
    .. [1] *R* statistical software: https://www.r-project.org/ 
    .. [2] *R* ``quantile`` function: 
            http://stat.ethz.ch/R-manual/R-devel/library/stats/html/quantile.html 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats.mstats import mquantiles 
    &gt;&gt;&gt; a = np.array([6., 47., 49., 15., 42., 41., 7., 39., 43., 40., 36.]) 
    &gt;&gt;&gt; mquantiles(a) 
    array([ 19.2,  40. ,  42.8]) 
 
    Using a 2D array, specifying axis and limit. 
 
    &gt;&gt;&gt; data = np.array([[   6.,    7.,    1.], 
    ...                  [  47.,   15.,    2.], 
    ...                  [  49.,   36.,    3.], 
    ...                  [  15.,   39.,    4.], 
    ...                  [  42.,   40., -999.], 
    ...                  [  41.,   41., -999.], 
    ...                  [   7., -999., -999.], 
    ...                  [  39., -999., -999.], 
    ...                  [  43., -999., -999.], 
    ...                  [  40., -999., -999.], 
    ...                  [  36., -999., -999.]]) 
    &gt;&gt;&gt; print(mquantiles(data, axis=0, limit=(0, 50))) 
    [[19.2  14.6   1.45] 
     [40.   37.5   2.5 ] 
     [42.8  40.05  3.55]] 
 
    &gt;&gt;&gt; data[:, 2] = -999. 
    &gt;&gt;&gt; print(mquantiles(data, axis=0, limit=(0, 50))) 
    [[19.200000000000003 14.6 --] 
     [40.0 37.5 --] 
     [42.800000000000004 40.05 --]] 
 
    &quot;&quot;&quot;</span>
    <span class="s5">def </span><span class="s1">_quantiles1D</span><span class="s3">(</span><span class="s1">data</span><span class="s3">,</span><span class="s1">m</span><span class="s3">,</span><span class="s1">p</span><span class="s3">):</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">compressed</span><span class="s3">())</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">n </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">), </span><span class="s1">mask</span><span class="s3">=</span><span class="s5">True</span><span class="s3">)</span>
        <span class="s5">elif </span><span class="s1">n </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">resize</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">p</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">), </span><span class="s1">mask</span><span class="s3">=</span><span class="s1">nomask</span><span class="s3">)</span>
        <span class="s1">aleph </span><span class="s3">= (</span><span class="s1">n</span><span class="s3">*</span><span class="s1">p </span><span class="s3">+ </span><span class="s1">m</span><span class="s3">)</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">aleph</span><span class="s3">.</span><span class="s1">clip</span><span class="s3">(</span><span class="s6">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
        <span class="s1">gamma </span><span class="s3">= (</span><span class="s1">aleph</span><span class="s3">-</span><span class="s1">k</span><span class="s3">).</span><span class="s1">clip</span><span class="s3">(</span><span class="s6">0</span><span class="s3">,</span><span class="s6">1</span><span class="s3">)</span>
        <span class="s5">return </span><span class="s3">(</span><span class="s6">1.</span><span class="s3">-</span><span class="s1">gamma</span><span class="s3">)*</span><span class="s1">x</span><span class="s3">[(</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">).</span><span class="s1">tolist</span><span class="s3">()] + </span><span class="s1">gamma</span><span class="s3">*</span><span class="s1">x</span><span class="s3">[</span><span class="s1">k</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">()]</span>

    <span class="s1">data </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">False</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s6">2</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;Array should be 2D at most !&quot;</span><span class="s3">)</span>

    <span class="s5">if </span><span class="s1">limit</span><span class="s3">:</span>
        <span class="s1">condition </span><span class="s3">= (</span><span class="s1">limit</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] &lt; </span><span class="s1">data</span><span class="s3">) &amp; (</span><span class="s1">data </span><span class="s3">&lt; </span><span class="s1">limit</span><span class="s3">[</span><span class="s6">1</span><span class="s3">])</span>
        <span class="s1">data</span><span class="s3">[~</span><span class="s1">condition</span><span class="s3">.</span><span class="s1">filled</span><span class="s3">(</span><span class="s5">True</span><span class="s3">)] = </span><span class="s1">masked</span>

    <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">prob</span><span class="s3">))</span>
    <span class="s1">m </span><span class="s3">= </span><span class="s1">alphap </span><span class="s3">+ </span><span class="s1">p</span><span class="s3">*(</span><span class="s6">1.</span><span class="s3">-</span><span class="s1">alphap</span><span class="s3">-</span><span class="s1">betap</span><span class="s3">)</span>
    <span class="s2"># Computes quantiles along axis (or globally)</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s1">axis </span><span class="s5">is None</span><span class="s3">):</span>
        <span class="s5">return </span><span class="s1">_quantiles1D</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">apply_along_axis</span><span class="s3">(</span><span class="s1">_quantiles1D</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">scoreatpercentile</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">per</span><span class="s3">, </span><span class="s1">limit</span><span class="s3">=(), </span><span class="s1">alphap</span><span class="s3">=</span><span class="s6">.4</span><span class="s3">, </span><span class="s1">betap</span><span class="s3">=</span><span class="s6">.4</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Calculate the score at the given 'per' percentile of the 
    sequence a.  For example, the score at per=50 is the median. 
 
    This function is a shortcut to mquantile 
 
    &quot;&quot;&quot;</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s1">per </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">) </span><span class="s5">or </span><span class="s3">(</span><span class="s1">per </span><span class="s3">&gt; </span><span class="s6">100.</span><span class="s3">):</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;The percentile should be between 0. and 100. !&quot;</span>
                         <span class="s4">&quot; (got %s)&quot; </span><span class="s3">% </span><span class="s1">per</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">mquantiles</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">=[</span><span class="s1">per</span><span class="s3">/</span><span class="s6">100.</span><span class="s3">], </span><span class="s1">alphap</span><span class="s3">=</span><span class="s1">alphap</span><span class="s3">, </span><span class="s1">betap</span><span class="s3">=</span><span class="s1">betap</span><span class="s3">,</span>
                      <span class="s1">limit</span><span class="s3">=</span><span class="s1">limit</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">).</span><span class="s1">squeeze</span><span class="s3">()</span>


<span class="s5">def </span><span class="s1">plotting_positions</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">=</span><span class="s6">0.4</span><span class="s3">, </span><span class="s1">beta</span><span class="s3">=</span><span class="s6">0.4</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns plotting positions (or empirical percentile points) for the data. 
 
    Plotting positions are defined as ``(i-alpha)/(n+1-alpha-beta)``, where: 
        - i is the rank order statistics 
        - n is the number of unmasked values along the given axis 
        - `alpha` and `beta` are two parameters. 
 
    Typical values for `alpha` and `beta` are: 
        - (0,1)    : ``p(k) = k/n``, linear interpolation of cdf (R, type 4) 
        - (.5,.5)  : ``p(k) = (k-1/2.)/n``, piecewise linear function 
          (R, type 5) 
        - (0,0)    : ``p(k) = k/(n+1)``, Weibull (R type 6) 
        - (1,1)    : ``p(k) = (k-1)/(n-1)``, in this case, 
          ``p(k) = mode[F(x[k])]``. That's R default (R type 7) 
        - (1/3,1/3): ``p(k) = (k-1/3)/(n+1/3)``, then 
          ``p(k) ~ median[F(x[k])]``. 
          The resulting quantile estimates are approximately median-unbiased 
          regardless of the distribution of x. (R type 8) 
        - (3/8,3/8): ``p(k) = (k-3/8)/(n+1/4)``, Blom. 
          The resulting quantile estimates are approximately unbiased 
          if x is normally distributed (R type 9) 
        - (.4,.4)  : approximately quantile unbiased (Cunnane) 
        - (.35,.35): APL, used with PWM 
        - (.3175, .3175): used in scipy.stats.probplot 
 
    Parameters 
    ---------- 
    data : array_like 
        Input data, as a sequence or array of dimension at most 2. 
    alpha : float, optional 
        Plotting positions parameter. Default is 0.4. 
    beta : float, optional 
        Plotting positions parameter. Default is 0.4. 
 
    Returns 
    ------- 
    positions : MaskedArray 
        The calculated plotting positions. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">False</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s6">1</span><span class="s3">,-</span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">count</span><span class="s3">()</span>
    <span class="s1">plpos </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">)</span>
    <span class="s1">plpos</span><span class="s3">[</span><span class="s1">n</span><span class="s3">:] = </span><span class="s6">0</span>
    <span class="s1">plpos</span><span class="s3">[</span><span class="s1">data</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">)[:</span><span class="s1">n</span><span class="s3">]] = ((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">) - </span><span class="s1">alpha</span><span class="s3">) /</span>
                                          <span class="s3">(</span><span class="s1">n </span><span class="s3">+ </span><span class="s6">1.0 </span><span class="s3">- </span><span class="s1">alpha </span><span class="s3">- </span><span class="s1">beta</span><span class="s3">))</span>
    <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">plpos</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">=</span><span class="s1">data</span><span class="s3">.</span><span class="s1">_mask</span><span class="s3">)</span>


<span class="s1">meppf </span><span class="s3">= </span><span class="s1">plotting_positions</span>


<span class="s5">def </span><span class="s1">obrientransform</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes a transform on input data (any number of columns).  Used to 
    test for homogeneity of variance prior to running one-way stats.  Each 
    array in ``*args`` is one level of a factor.  If an `f_oneway()` run on 
    the transformed data and found significant, variances are unequal.   From 
    Maxwell and Delaney, p.112. 
 
    Returns: transformed data for use in an ANOVA 
    &quot;&quot;&quot;</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">argstoarray</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">).</span><span class="s1">T</span>
    <span class="s1">v </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">var</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span><span class="s1">ddof</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">m </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s6">0</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">)</span>
    <span class="s2"># result = ((N-1.5)*N*(a-m)**2 - 0.5*v*(n-1))/((n-1)*(n-2))</span>
    <span class="s1">data </span><span class="s3">-= </span><span class="s1">m</span>
    <span class="s1">data </span><span class="s3">**= </span><span class="s6">2</span>
    <span class="s1">data </span><span class="s3">*= (</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1.5</span><span class="s3">)*</span><span class="s1">n</span>
    <span class="s1">data </span><span class="s3">-= </span><span class="s6">0.5</span><span class="s3">*</span><span class="s1">v</span><span class="s3">*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">data </span><span class="s3">/= (</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1.</span><span class="s3">)*(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">2.</span><span class="s3">)</span>
    <span class="s5">if not </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">allclose</span><span class="s3">(</span><span class="s1">v</span><span class="s3">,</span><span class="s1">data</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)):</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Lack of convergence in obrientransform.&quot;</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">data</span>


<span class="s5">def </span><span class="s1">sem</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s6">1</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculates the standard error of the mean of the input array. 
 
    Also sometimes called standard error of measurement. 
 
    Parameters 
    ---------- 
    a : array_like 
        An array containing the values for which the standard error is 
        returned. 
    axis : int or None, optional 
        If axis is None, ravel `a` first. If axis is an integer, this will be 
        the axis over which to operate. Defaults to 0. 
    ddof : int, optional 
        Delta degrees-of-freedom. How many degrees of freedom to adjust 
        for bias in limited samples relative to the population estimate 
        of variance. Defaults to 1. 
 
    Returns 
    ------- 
    s : ndarray or float 
        The standard error of the mean in the sample(s), along the input axis. 
 
    Notes 
    ----- 
    The default value for `ddof` changed in scipy 0.15.0 to be consistent with 
    `scipy.stats.sem` as well as with the most common definition used (like in 
    the R documentation). 
 
    Examples 
    -------- 
    Find standard error along the first axis: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; a = np.arange(20).reshape(5,4) 
    &gt;&gt;&gt; print(stats.mstats.sem(a)) 
    [2.8284271247461903 2.8284271247461903 2.8284271247461903 
     2.8284271247461903] 
 
    Find standard error across the whole array, using n degrees of freedom: 
 
    &gt;&gt;&gt; print(stats.mstats.sem(a, axis=None, ddof=0)) 
    1.2893796958227628 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">= </span><span class="s1">_chk_asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">std</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s1">ddof</span><span class="s3">) / </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s1">s</span>


<span class="s1">F_onewayResult </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'F_onewayResult'</span><span class="s3">, (</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s3">))</span>


<span class="s5">def </span><span class="s1">f_oneway</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Performs a 1-way ANOVA, returning an F-value and probability given 
    any number of groups.  From Heiman, pp.394-7. 
 
    Usage: ``f_oneway(*args)``, where ``*args`` is 2 or more arrays, 
    one per treatment group. 
 
    Returns 
    ------- 
    statistic : float 
        The computed F-value of the test. 
    pvalue : float 
        The associated p-value from the F-distribution. 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># Construct a single array of arguments: each row is a group</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">argstoarray</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">)</span>
    <span class="s1">ngroups </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
    <span class="s1">ntot </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">count</span><span class="s3">()</span>
    <span class="s1">sstot </span><span class="s3">= (</span><span class="s1">data</span><span class="s3">**</span><span class="s6">2</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">() - (</span><span class="s1">data</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">())**</span><span class="s6">2</span><span class="s3">/</span><span class="s1">float</span><span class="s3">(</span><span class="s1">ntot</span><span class="s3">)</span>
    <span class="s1">ssbg </span><span class="s3">= (</span><span class="s1">data</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">) * (</span><span class="s1">data</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">)-</span><span class="s1">data</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">())**</span><span class="s6">2</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">()</span>
    <span class="s1">sswg </span><span class="s3">= </span><span class="s1">sstot</span><span class="s3">-</span><span class="s1">ssbg</span>
    <span class="s1">dfbg </span><span class="s3">= </span><span class="s1">ngroups</span><span class="s3">-</span><span class="s6">1</span>
    <span class="s1">dfwg </span><span class="s3">= </span><span class="s1">ntot </span><span class="s3">- </span><span class="s1">ngroups</span>
    <span class="s1">msb </span><span class="s3">= </span><span class="s1">ssbg</span><span class="s3">/</span><span class="s1">float</span><span class="s3">(</span><span class="s1">dfbg</span><span class="s3">)</span>
    <span class="s1">msw </span><span class="s3">= </span><span class="s1">sswg</span><span class="s3">/</span><span class="s1">float</span><span class="s3">(</span><span class="s1">dfwg</span><span class="s3">)</span>
    <span class="s1">f </span><span class="s3">= </span><span class="s1">msb</span><span class="s3">/</span><span class="s1">msw</span>
    <span class="s1">prob </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">fdtrc</span><span class="s3">(</span><span class="s1">dfbg</span><span class="s3">, </span><span class="s1">dfwg</span><span class="s3">, </span><span class="s1">f</span><span class="s3">)  </span><span class="s2"># equivalent to stats.f.sf</span>

    <span class="s5">return </span><span class="s1">F_onewayResult</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">)</span>


<span class="s1">FriedmanchisquareResult </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'FriedmanchisquareResult'</span><span class="s3">,</span>
                                     <span class="s3">(</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s3">))</span>


<span class="s5">def </span><span class="s1">friedmanchisquare</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Friedman Chi-Square is a non-parametric, one-way within-subjects ANOVA. 
    This function calculates the Friedman Chi-square test for repeated measures 
    and returns the result, along with the associated probability value. 
 
    Each input is considered a given group. Ideally, the number of treatments 
    among each group should be equal. If this is not the case, only the first 
    n treatments are taken into account, where n is the number of treatments 
    of the smallest group. 
    If a group has some missing values, the corresponding treatments are masked 
    in the other groups. 
    The test statistic is corrected for ties. 
 
    Masked values in one group are propagated to the other groups. 
 
    Returns 
    ------- 
    statistic : float 
        the test statistic. 
    pvalue : float 
        the associated p-value. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">argstoarray</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">)</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">k </span><span class="s3">&lt; </span><span class="s6">3</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Less than 3 groups (%i): &quot; </span><span class="s3">% </span><span class="s1">k </span><span class="s3">+</span>
                         <span class="s4">&quot;the Friedman test is NOT appropriate.&quot;</span><span class="s3">)</span>

    <span class="s1">ranked </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">masked_values</span><span class="s3">(</span><span class="s1">rankdata</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">), </span><span class="s6">0</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">ranked</span><span class="s3">.</span><span class="s1">_mask </span><span class="s5">is not </span><span class="s1">nomask</span><span class="s3">:</span>
        <span class="s1">ranked </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">mask_cols</span><span class="s3">(</span><span class="s1">ranked</span><span class="s3">)</span>
        <span class="s1">ranked </span><span class="s3">= </span><span class="s1">ranked</span><span class="s3">.</span><span class="s1">compressed</span><span class="s3">().</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">k</span><span class="s3">,-</span><span class="s6">1</span><span class="s3">).</span><span class="s1">view</span><span class="s3">(</span><span class="s1">ndarray</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">ranked </span><span class="s3">= </span><span class="s1">ranked</span><span class="s3">.</span><span class="s1">_data</span>
    <span class="s3">(</span><span class="s1">k</span><span class="s3">,</span><span class="s1">n</span><span class="s3">) = </span><span class="s1">ranked</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s2"># Ties correction</span>
    <span class="s1">repeats </span><span class="s3">= [</span><span class="s1">find_repeats</span><span class="s3">(</span><span class="s1">row</span><span class="s3">) </span><span class="s5">for </span><span class="s1">row </span><span class="s5">in </span><span class="s1">ranked</span><span class="s3">.</span><span class="s1">T</span><span class="s3">]</span>
    <span class="s1">ties </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">y </span><span class="s5">for </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s5">in </span><span class="s1">repeats </span><span class="s5">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">])</span>
    <span class="s1">tie_correction </span><span class="s3">= </span><span class="s6">1 </span><span class="s3">- (</span><span class="s1">ties</span><span class="s3">**</span><span class="s6">3</span><span class="s3">-</span><span class="s1">ties</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">()/</span><span class="s1">float</span><span class="s3">(</span><span class="s1">n</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">**</span><span class="s6">3</span><span class="s3">-</span><span class="s1">k</span><span class="s3">))</span>

    <span class="s1">ssbg </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">((</span><span class="s1">ranked</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">) - </span><span class="s1">n</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)/</span><span class="s6">2.</span><span class="s3">)**</span><span class="s6">2</span><span class="s3">)</span>
    <span class="s1">chisq </span><span class="s3">= </span><span class="s1">ssbg </span><span class="s3">* </span><span class="s6">12.</span><span class="s3">/(</span><span class="s1">n</span><span class="s3">*</span><span class="s1">k</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)) * </span><span class="s6">1.</span><span class="s3">/</span><span class="s1">tie_correction</span>

    <span class="s5">return </span><span class="s1">FriedmanchisquareResult</span><span class="s3">(</span><span class="s1">chisq</span><span class="s3">,</span>
                                   <span class="s1">distributions</span><span class="s3">.</span><span class="s1">chi2</span><span class="s3">.</span><span class="s1">sf</span><span class="s3">(</span><span class="s1">chisq</span><span class="s3">, </span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">))</span>


<span class="s1">BrunnerMunzelResult </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span><span class="s4">'BrunnerMunzelResult'</span><span class="s3">, (</span><span class="s4">'statistic'</span><span class="s3">, </span><span class="s4">'pvalue'</span><span class="s3">))</span>


<span class="s5">def </span><span class="s1">brunnermunzel</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">alternative</span><span class="s3">=</span><span class="s4">&quot;two-sided&quot;</span><span class="s3">, </span><span class="s1">distribution</span><span class="s3">=</span><span class="s4">&quot;t&quot;</span><span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Compute the Brunner-Munzel test on samples x and y. 
 
    Any missing values in `x` and/or `y` are discarded. 
 
    The Brunner-Munzel test is a nonparametric test of the null hypothesis that 
    when values are taken one by one from each group, the probabilities of 
    getting large values in both groups are equal. 
    Unlike the Wilcoxon-Mann-Whitney's U test, this does not require the 
    assumption of equivariance of two groups. Note that this does not assume 
    the distributions are same. This test works on two independent samples, 
    which may have different sizes. 
 
    Parameters 
    ---------- 
    x, y : array_like 
        Array of samples, should be one-dimensional. 
    alternative : 'less', 'two-sided', or 'greater', optional 
        Whether to get the p-value for the one-sided hypothesis ('less' 
        or 'greater') or for the two-sided hypothesis ('two-sided'). 
        Defaults value is 'two-sided' . 
    distribution : 't' or 'normal', optional 
        Whether to get the p-value by t-distribution or by standard normal 
        distribution. 
        Defaults value is 't' . 
 
    Returns 
    ------- 
    statistic : float 
        The Brunner-Munzer W statistic. 
    pvalue : float 
        p-value assuming an t distribution. One-sided or 
        two-sided, depending on the choice of `alternative` and `distribution`. 
 
    See Also 
    -------- 
    mannwhitneyu : Mann-Whitney rank test on two samples. 
 
    Notes 
    ----- 
    For more details on `brunnermunzel`, see `scipy.stats.brunnermunzel`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.stats.mstats import brunnermunzel 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x1 = [1, 2, np.nan, np.nan, 1, 1, 1, 1, 1, 1, 2, 4, 1, 1] 
    &gt;&gt;&gt; x2 = [3, 3, 4, 3, 1, 2, 3, 1, 1, 5, 4] 
    &gt;&gt;&gt; brunnermunzel(x1, x2) 
    BrunnerMunzelResult(statistic=1.4723186918922935, pvalue=0.15479415300426624)  # may vary 
 
    &quot;&quot;&quot;  </span><span class="s2"># noqa: E501</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">compressed</span><span class="s3">().</span><span class="s1">view</span><span class="s3">(</span><span class="s1">ndarray</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">).</span><span class="s1">compressed</span><span class="s3">().</span><span class="s1">view</span><span class="s3">(</span><span class="s1">ndarray</span><span class="s3">)</span>
    <span class="s1">nx </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">ny </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">nx </span><span class="s3">== </span><span class="s6">0 </span><span class="s5">or </span><span class="s1">ny </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">BrunnerMunzelResult</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">)</span>
    <span class="s1">rankc </span><span class="s3">= </span><span class="s1">rankdata</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">x</span><span class="s3">,</span><span class="s1">y</span><span class="s3">)))</span>
    <span class="s1">rankcx </span><span class="s3">= </span><span class="s1">rankc</span><span class="s3">[</span><span class="s6">0</span><span class="s3">:</span><span class="s1">nx</span><span class="s3">]</span>
    <span class="s1">rankcy </span><span class="s3">= </span><span class="s1">rankc</span><span class="s3">[</span><span class="s1">nx</span><span class="s3">:</span><span class="s1">nx</span><span class="s3">+</span><span class="s1">ny</span><span class="s3">]</span>
    <span class="s1">rankcx_mean </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">rankcx</span><span class="s3">)</span>
    <span class="s1">rankcy_mean </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">rankcy</span><span class="s3">)</span>
    <span class="s1">rankx </span><span class="s3">= </span><span class="s1">rankdata</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">ranky </span><span class="s3">= </span><span class="s1">rankdata</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">rankx_mean </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">rankx</span><span class="s3">)</span>
    <span class="s1">ranky_mean </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">ranky</span><span class="s3">)</span>

    <span class="s1">Sx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s1">rankcx </span><span class="s3">- </span><span class="s1">rankx </span><span class="s3">- </span><span class="s1">rankcx_mean </span><span class="s3">+ </span><span class="s1">rankx_mean</span><span class="s3">, </span><span class="s6">2.0</span><span class="s3">))</span>
    <span class="s1">Sx </span><span class="s3">/= </span><span class="s1">nx </span><span class="s3">- </span><span class="s6">1</span>
    <span class="s1">Sy </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s1">rankcy </span><span class="s3">- </span><span class="s1">ranky </span><span class="s3">- </span><span class="s1">rankcy_mean </span><span class="s3">+ </span><span class="s1">ranky_mean</span><span class="s3">, </span><span class="s6">2.0</span><span class="s3">))</span>
    <span class="s1">Sy </span><span class="s3">/= </span><span class="s1">ny </span><span class="s3">- </span><span class="s6">1</span>

    <span class="s1">wbfn </span><span class="s3">= </span><span class="s1">nx </span><span class="s3">* </span><span class="s1">ny </span><span class="s3">* (</span><span class="s1">rankcy_mean </span><span class="s3">- </span><span class="s1">rankcx_mean</span><span class="s3">)</span>
    <span class="s1">wbfn </span><span class="s3">/= (</span><span class="s1">nx </span><span class="s3">+ </span><span class="s1">ny</span><span class="s3">) * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">nx </span><span class="s3">* </span><span class="s1">Sx </span><span class="s3">+ </span><span class="s1">ny </span><span class="s3">* </span><span class="s1">Sy</span><span class="s3">)</span>

    <span class="s5">if </span><span class="s1">distribution </span><span class="s3">== </span><span class="s4">&quot;t&quot;</span><span class="s3">:</span>
        <span class="s1">df_numer </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s1">nx </span><span class="s3">* </span><span class="s1">Sx </span><span class="s3">+ </span><span class="s1">ny </span><span class="s3">* </span><span class="s1">Sy</span><span class="s3">, </span><span class="s6">2.0</span><span class="s3">)</span>
        <span class="s1">df_denom </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s1">nx </span><span class="s3">* </span><span class="s1">Sx</span><span class="s3">, </span><span class="s6">2.0</span><span class="s3">) / (</span><span class="s1">nx </span><span class="s3">- </span><span class="s6">1</span><span class="s3">)</span>
        <span class="s1">df_denom </span><span class="s3">+= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s1">ny </span><span class="s3">* </span><span class="s1">Sy</span><span class="s3">, </span><span class="s6">2.0</span><span class="s3">) / (</span><span class="s1">ny </span><span class="s3">- </span><span class="s6">1</span><span class="s3">)</span>
        <span class="s1">df </span><span class="s3">= </span><span class="s1">df_numer </span><span class="s3">/ </span><span class="s1">df_denom</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">distributions</span><span class="s3">.</span><span class="s1">t</span><span class="s3">.</span><span class="s1">cdf</span><span class="s3">(</span><span class="s1">wbfn</span><span class="s3">, </span><span class="s1">df</span><span class="s3">)</span>
    <span class="s5">elif </span><span class="s1">distribution </span><span class="s3">== </span><span class="s4">&quot;normal&quot;</span><span class="s3">:</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">distributions</span><span class="s3">.</span><span class="s1">norm</span><span class="s3">.</span><span class="s1">cdf</span><span class="s3">(</span><span class="s1">wbfn</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
            <span class="s4">&quot;distribution should be 't' or 'normal'&quot;</span><span class="s3">)</span>

    <span class="s5">if </span><span class="s1">alternative </span><span class="s3">== </span><span class="s4">&quot;greater&quot;</span><span class="s3">:</span>
        <span class="s5">pass</span>
    <span class="s5">elif </span><span class="s1">alternative </span><span class="s3">== </span><span class="s4">&quot;less&quot;</span><span class="s3">:</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s6">1 </span><span class="s3">- </span><span class="s1">p</span>
    <span class="s5">elif </span><span class="s1">alternative </span><span class="s3">== </span><span class="s4">&quot;two-sided&quot;</span><span class="s3">:</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s6">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">([</span><span class="s1">p</span><span class="s3">, </span><span class="s6">1</span><span class="s3">-</span><span class="s1">p</span><span class="s3">])</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
            <span class="s4">&quot;alternative should be 'less', 'greater' or 'two-sided'&quot;</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">BrunnerMunzelResult</span><span class="s3">(</span><span class="s1">wbfn</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>
</pre>
</body>
</html>