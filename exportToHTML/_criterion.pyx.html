<html>
<head>
<title>_criterion.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_criterion.pyx</font>
</center></td></tr></table>
<pre><span class="s0"># Authors: Gilles Louppe &lt;g.louppe@gmail.com&gt;</span>
<span class="s0">#          Peter Prettenhofer &lt;peter.prettenhofer@gmail.com&gt;</span>
<span class="s0">#          Brian Holt &lt;bdholt1@gmail.com&gt;</span>
<span class="s0">#          Noel Dawe &lt;noel@dawe.me&gt;</span>
<span class="s0">#          Satrajit Gosh &lt;satrajit.ghosh@gmail.com&gt;</span>
<span class="s0">#          Lars Buitinck</span>
<span class="s0">#          Arnaud Joly &lt;arnaud.v.joly@gmail.com&gt;</span>
<span class="s0">#          Joel Nothman &lt;joel.nothman@gmail.com&gt;</span>
<span class="s0">#          Fares Hedayati &lt;fares.hedayati@gmail.com&gt;</span>
<span class="s0">#          Jacob Schreiber &lt;jmschreiber91@gmail.com&gt;</span>
<span class="s0">#          Nelson Liu &lt;nelson@nelsonliu.me&gt;</span>
<span class="s0">#</span>
<span class="s0"># License: BSD 3 clause</span>

<span class="s2">from </span><span class="s1">libc</span><span class="s3">.</span><span class="s1">string </span><span class="s2">cimport </span><span class="s1">memcpy</span>
<span class="s2">from </span><span class="s1">libc</span><span class="s3">.</span><span class="s1">string </span><span class="s2">cimport </span><span class="s1">memset</span>
<span class="s2">from </span><span class="s1">libc</span><span class="s3">.</span><span class="s1">math </span><span class="s2">cimport </span><span class="s1">fabs</span><span class="s3">, </span><span class="s1">INFINITY</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">cimport </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">cnp</span>
<span class="s1">cnp</span><span class="s3">.</span><span class="s1">import_array</span><span class="s3">()</span>

<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special</span><span class="s3">.</span><span class="s1">cython_special </span><span class="s2">cimport </span><span class="s1">xlogy</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">_utils </span><span class="s2">cimport </span><span class="s1">log</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_utils </span><span class="s2">cimport </span><span class="s1">WeightedMedianCalculator</span>

<span class="s0"># EPSILON is used in the Poisson criterion</span>
<span class="s2">cdef </span><span class="s1">float64_t EPSILON </span><span class="s3">= </span><span class="s4">10 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s5">'double'</span><span class="s3">).</span><span class="s1">eps</span>

<span class="s2">cdef class </span><span class="s1">Criterion</span><span class="s3">:</span>
    <span class="s6">&quot;&quot;&quot;Interface for impurity criteria. 
 
    This object stores methods on how to calculate how good a split is using 
    different metrics. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__getstate__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">{}</span>

    <span class="s2">def </span><span class="s1">__setstate__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">d</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s2">cdef </span><span class="s1">int init</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">y</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:] </span><span class="s1">sample_weight</span><span class="s3">,</span>
        <span class="s1">float64_t weighted_n_samples</span><span class="s3">,</span>
        <span class="s1">const intp_t</span><span class="s3">[:] </span><span class="s1">sample_indices</span><span class="s3">,</span>
        <span class="s1">intp_t start</span><span class="s3">,</span>
        <span class="s1">intp_t end</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Placeholder for a method which will initialize the criterion. 
 
        Returns -1 in case of failure to allocate memory (and raise MemoryError) 
        or 0 otherwise. 
 
        Parameters 
        ---------- 
        y : ndarray, dtype=float64_t 
            y is a buffer that can store values for n_outputs target variables 
            stored as a Cython memoryview. 
        sample_weight : ndarray, dtype=float64_t 
            The weight of each sample stored as a Cython memoryview. 
        weighted_n_samples : float64_t 
            The total weight of the samples being considered 
        sample_indices : ndarray, dtype=intp_t 
            A mask on the samples. Indices of the samples in X and y we want to use, 
            where sample_indices[start:end] correspond to the samples in this node. 
        start : intp_t 
            The first sample to be used on this node 
        end : intp_t 
            The last sample used on this node 
 
        &quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">cdef </span><span class="s1">void init_missing</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t n_missing</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Initialize sum_missing if there are missing values. 
 
        This method assumes that caller placed the missing samples in 
        self.sample_indices[-n_missing:] 
 
        Parameters 
        ---------- 
        n_missing: intp_t 
            Number of missing values for specific feature. 
        &quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">cdef </span><span class="s1">int reset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Reset the criterion at pos=start. 
 
        This method must be implemented by the subclass. 
        &quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">cdef </span><span class="s1">int reverse_reset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Reset the criterion at pos=end. 
 
        This method must be implemented by the subclass. 
        &quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">cdef </span><span class="s1">int update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t new_pos</span><span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Updated statistics by moving sample_indices[pos:new_pos] to the left child. 
 
        This updates the collected statistics by moving sample_indices[pos:new_pos] 
        from the right child to the left child. It must be implemented by 
        the subclass. 
 
        Parameters 
        ---------- 
        new_pos : intp_t 
            New starting index position of the sample_indices in the right child 
        &quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">cdef </span><span class="s1">float64_t node_impurity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Placeholder for calculating the impurity of the node. 
 
        Placeholder for a method which will evaluate the impurity of 
        the current node, i.e. the impurity of sample_indices[start:end]. This is the 
        primary function of the criterion class. The smaller the impurity the 
        better. 
        &quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">cdef </span><span class="s1">void children_impurity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t</span><span class="s3">* </span><span class="s1">impurity_left</span><span class="s3">,</span>
                                <span class="s1">float64_t</span><span class="s3">* </span><span class="s1">impurity_right</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Placeholder for calculating the impurity of children. 
 
        Placeholder for a method which evaluates the impurity in 
        children nodes, i.e. the impurity of sample_indices[start:pos] + the impurity 
        of sample_indices[pos:end]. 
 
        Parameters 
        ---------- 
        impurity_left : float64_t pointer 
            The memory address where the impurity of the left child should be 
            stored. 
        impurity_right : float64_t pointer 
            The memory address where the impurity of the right child should be 
            stored 
        &quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">cdef </span><span class="s1">void node_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t</span><span class="s3">* </span><span class="s1">dest</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Placeholder for storing the node value. 
 
        Placeholder for a method which will compute the node value 
        of sample_indices[start:end] and save the value into dest. 
 
        Parameters 
        ---------- 
        dest : float64_t pointer 
            The memory address where the node value should be stored. 
        &quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">cdef </span><span class="s1">void clip_node_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t</span><span class="s3">* </span><span class="s1">dest</span><span class="s3">, </span><span class="s1">float64_t lower_bound</span><span class="s3">, </span><span class="s1">float64_t upper_bound</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s2">pass</span>

    <span class="s2">cdef </span><span class="s1">float64_t middle_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Compute the middle value of a split for monotonicity constraints 
 
        This method is implemented in ClassificationCriterion and RegressionCriterion. 
        &quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">cdef </span><span class="s1">float64_t proxy_impurity_improvement</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Compute a proxy of the impurity reduction. 
 
        This method is used to speed up the search for the best split. 
        It is a proxy quantity such that the split that maximizes this value 
        also maximizes the impurity improvement. It neglects all constant terms 
        of the impurity decrease for a given split. 
 
        The absolute impurity improvement is only computed by the 
        impurity_improvement method once the best split has been found. 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">float64_t impurity_left</span>
        <span class="s2">cdef </span><span class="s1">float64_t impurity_right</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">children_impurity</span><span class="s3">(&amp;</span><span class="s1">impurity_left</span><span class="s3">, &amp;</span><span class="s1">impurity_right</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s3">(- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">* </span><span class="s1">impurity_right</span>
                <span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">* </span><span class="s1">impurity_left</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">float64_t impurity_improvement</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t impurity_parent</span><span class="s3">,</span>
                                        <span class="s1">float64_t impurity_left</span><span class="s3">,</span>
                                        <span class="s1">float64_t impurity_right</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Compute the improvement in impurity. 
 
        This method computes the improvement in impurity when a split occurs. 
        The weighted impurity improvement equation is the following: 
 
            N_t / N * (impurity - N_t_R / N_t * right_impurity 
                                - N_t_L / N_t * left_impurity) 
 
        where N is the total number of samples, N_t is the number of samples 
        at the current node, N_t_L is the number of samples in the left child, 
        and N_t_R is the number of samples in the right child, 
 
        Parameters 
        ---------- 
        impurity_parent : float64_t 
            The initial impurity of the parent node before the split 
 
        impurity_left : float64_t 
            The impurity of the left child 
 
        impurity_right : float64_t 
            The impurity of the right child 
 
        Return 
        ------ 
        float64_t : improvement in impurity after the split occurs 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">((</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">/ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_samples</span><span class="s3">) *</span>
                <span class="s3">(</span><span class="s1">impurity_parent </span><span class="s3">- (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">/</span>
                                    <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">* </span><span class="s1">impurity_right</span><span class="s3">)</span>
                                 <span class="s3">- (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">/</span>
                                    <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">* </span><span class="s1">impurity_left</span><span class="s3">)))</span>

    <span class="s2">cdef </span><span class="s1">bint check_monotonicity</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">cnp</span><span class="s3">.</span><span class="s1">int8_t monotonic_cst</span><span class="s3">,</span>
        <span class="s1">float64_t lower_bound</span><span class="s3">,</span>
        <span class="s1">float64_t upper_bound</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s2">pass</span>

    <span class="s2">cdef </span><span class="s1">inline bint _check_monotonicity</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">cnp</span><span class="s3">.</span><span class="s1">int8_t monotonic_cst</span><span class="s3">,</span>
        <span class="s1">float64_t lower_bound</span><span class="s3">,</span>
        <span class="s1">float64_t upper_bound</span><span class="s3">,</span>
        <span class="s1">float64_t value_left</span><span class="s3">,</span>
        <span class="s1">float64_t value_right</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s2">cdef</span><span class="s3">:</span>
            <span class="s1">bint check_lower_bound </span><span class="s3">= (</span>
                <span class="s3">(</span><span class="s1">value_left </span><span class="s3">&gt;= </span><span class="s1">lower_bound</span><span class="s3">) &amp;</span>
                <span class="s3">(</span><span class="s1">value_right </span><span class="s3">&gt;= </span><span class="s1">lower_bound</span><span class="s3">)</span>
            <span class="s3">)</span>
            <span class="s1">bint check_upper_bound </span><span class="s3">= (</span>
                <span class="s3">(</span><span class="s1">value_left </span><span class="s3">&lt;= </span><span class="s1">upper_bound</span><span class="s3">) &amp;</span>
                <span class="s3">(</span><span class="s1">value_right </span><span class="s3">&lt;= </span><span class="s1">upper_bound</span><span class="s3">)</span>
            <span class="s3">)</span>
            <span class="s1">bint check_monotonic_cst </span><span class="s3">= (</span>
                <span class="s3">(</span><span class="s1">value_left </span><span class="s3">- </span><span class="s1">value_right</span><span class="s3">) * </span><span class="s1">monotonic_cst </span><span class="s3">&lt;= </span><span class="s4">0</span>
            <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">check_lower_bound </span><span class="s3">&amp; </span><span class="s1">check_upper_bound </span><span class="s3">&amp; </span><span class="s1">check_monotonic_cst</span>

    <span class="s2">cdef </span><span class="s1">void init_sum_missing</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Init sum_missing to hold sums for missing values.&quot;&quot;&quot;</span>

<span class="s2">cdef </span><span class="s1">inline void _move_sums_classification</span><span class="s3">(</span>
    <span class="s1">ClassificationCriterion criterion</span><span class="s3">,</span>
    <span class="s1">float64_t</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">sum_1</span><span class="s3">,</span>
    <span class="s1">float64_t</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">sum_2</span><span class="s3">,</span>
    <span class="s1">float64_t</span><span class="s3">* </span><span class="s1">weighted_n_1</span><span class="s3">,</span>
    <span class="s1">float64_t</span><span class="s3">* </span><span class="s1">weighted_n_2</span><span class="s3">,</span>
    <span class="s1">bint put_missing_in_1</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot;Distribute sum_total and sum_missing into sum_1 and sum_2. 
 
    If there are missing values and: 
    - put_missing_in_1 is True, then missing values to go sum_1. Specifically: 
        sum_1 = sum_missing 
        sum_2 = sum_total - sum_missing 
 
    - put_missing_in_1 is False, then missing values go to sum_2. Specifically: 
        sum_1 = 0 
        sum_2 = sum_total 
    &quot;&quot;&quot;</span>
    <span class="s2">cdef </span><span class="s1">intp_t k</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">n_bytes</span>
    <span class="s2">if </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">n_missing </span><span class="s3">!= </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">put_missing_in_1</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">n_bytes </span><span class="s3">= </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">n_classes</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] * </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">float64_t</span><span class="s3">)</span>
            <span class="s1">memcpy</span><span class="s3">(&amp;</span><span class="s1">sum_1</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], &amp;</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">sum_missing</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], </span><span class="s1">n_bytes</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">n_classes</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]):</span>
                <span class="s1">sum_2</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">c</span><span class="s3">] = </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">sum_total</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">c</span><span class="s3">] - </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">sum_missing</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">c</span><span class="s3">]</span>

        <span class="s1">weighted_n_1</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">weighted_n_missing</span>
        <span class="s1">weighted_n_2</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">- </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">weighted_n_missing</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s0"># Assigning sum_2 = sum_total for all outputs.</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">n_bytes </span><span class="s3">= </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">n_classes</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] * </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">float64_t</span><span class="s3">)</span>
            <span class="s1">memset</span><span class="s3">(&amp;</span><span class="s1">sum_1</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], </span><span class="s4">0</span><span class="s3">, </span><span class="s1">n_bytes</span><span class="s3">)</span>
            <span class="s1">memcpy</span><span class="s3">(&amp;</span><span class="s1">sum_2</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], &amp;</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">sum_total</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], </span><span class="s1">n_bytes</span><span class="s3">)</span>

        <span class="s1">weighted_n_1</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s4">0.0</span>
        <span class="s1">weighted_n_2</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span>


<span class="s2">cdef class </span><span class="s1">ClassificationCriterion</span><span class="s3">(</span><span class="s1">Criterion</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Abstract criterion for classification.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__cinit__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t n_outputs</span><span class="s3">,</span>
                  <span class="s1">cnp</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">[</span><span class="s1">intp_t</span><span class="s3">, </span><span class="s1">ndim</span><span class="s3">=</span><span class="s4">1</span><span class="s3">] </span><span class="s1">n_classes</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Initialize attributes for this criterion. 
 
        Parameters 
        ---------- 
        n_outputs : intp_t 
            The number of targets, the dimensionality of the prediction 
        n_classes : numpy.ndarray, dtype=intp_t 
            The number of unique classes in each target 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">start </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">missing_go_to_left </span><span class="s3">= </span><span class="s4">0</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs </span><span class="s3">= </span><span class="s1">n_outputs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_node_samples </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_missing </span><span class="s3">= </span><span class="s4">0.0</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_classes </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>

        <span class="s2">cdef </span><span class="s1">intp_t k </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s2">cdef </span><span class="s1">intp_t max_n_classes </span><span class="s3">= </span><span class="s4">0</span>

        <span class="s0"># For each target, set the number of unique classes in that target,</span>
        <span class="s0"># and also compute the maximal stride of all targets</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">n_classes</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">n_classes</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>

            <span class="s2">if </span><span class="s1">n_classes</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] &gt; </span><span class="s1">max_n_classes</span><span class="s3">:</span>
                <span class="s1">max_n_classes </span><span class="s3">= </span><span class="s1">n_classes</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">max_n_classes </span><span class="s3">= </span><span class="s1">max_n_classes</span>

        <span class="s0"># Count labels for each output</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_total </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">max_n_classes</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">max_n_classes</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">max_n_classes</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__reduce__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">),</span>
                <span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_classes</span><span class="s3">)), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__getstate__</span><span class="s3">())</span>

    <span class="s2">cdef </span><span class="s1">int init</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">y</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:] </span><span class="s1">sample_weight</span><span class="s3">,</span>
        <span class="s1">float64_t weighted_n_samples</span><span class="s3">,</span>
        <span class="s1">const intp_t</span><span class="s3">[:] </span><span class="s1">sample_indices</span><span class="s3">,</span>
        <span class="s1">intp_t start</span><span class="s3">,</span>
        <span class="s1">intp_t end</span>
    <span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Initialize the criterion. 
 
        This initializes the criterion at node sample_indices[start:end] and children 
        sample_indices[start:start] and sample_indices[start:end]. 
 
        Returns -1 in case of failure to allocate memory (and raise MemoryError) 
        or 0 otherwise. 
 
        Parameters 
        ---------- 
        y : ndarray, dtype=float64_t 
            The target stored as a buffer for memory efficiency. 
        sample_weight : ndarray, dtype=float64_t 
            The weight of each sample stored as a Cython memoryview. 
        weighted_n_samples : float64_t 
            The total weight of all samples 
        sample_indices : ndarray, dtype=intp_t 
            A mask on the samples. Indices of the samples in X and y we want to use, 
            where sample_indices[start:end] correspond to the samples in this node. 
        start : intp_t 
            The first sample to use in the mask 
        end : intp_t 
            The last sample to use in the mask 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">y </span><span class="s3">= </span><span class="s1">y</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">sample_weight</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sample_indices </span><span class="s3">= </span><span class="s1">sample_indices</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">start </span><span class="s3">= </span><span class="s1">start</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">= </span><span class="s1">end</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_node_samples </span><span class="s3">= </span><span class="s1">end </span><span class="s3">- </span><span class="s1">start</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_samples </span><span class="s3">= </span><span class="s1">weighted_n_samples</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">= </span><span class="s4">0.0</span>

        <span class="s2">cdef </span><span class="s1">intp_t i</span>
        <span class="s2">cdef </span><span class="s1">intp_t p</span>
        <span class="s2">cdef </span><span class="s1">intp_t k</span>
        <span class="s2">cdef </span><span class="s1">intp_t c</span>
        <span class="s2">cdef </span><span class="s1">float64_t w </span><span class="s3">= </span><span class="s4">1.0</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">memset</span><span class="s3">(&amp;</span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_total</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], </span><span class="s4">0</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_classes</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] * </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">float64_t</span><span class="s3">))</span>

        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">):</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s1">sample_indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

            <span class="s0"># w is originally set to be 1.0, meaning that if no sample weights</span>
            <span class="s0"># are given, the default weight of each sample is 1.0.</span>
            <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">w </span><span class="s3">= </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

            <span class="s0"># Count weighted class frequency for each target</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
                <span class="s1">c </span><span class="s3">= &lt;</span><span class="s1">intp_t</span><span class="s3">&gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">]</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_total</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">c</span><span class="s3">] += </span><span class="s1">w</span>

            <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">+= </span><span class="s1">w</span>

        <span class="s0"># Reset to pos=start</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">reset</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">cdef </span><span class="s1">void init_sum_missing</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Init sum_missing to hold sums for missing values.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_missing </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">max_n_classes</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">void init_missing</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t n_missing</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Initialize sum_missing if there are missing values. 
 
        This method assumes that caller placed the missing samples in 
        self.sample_indices[-n_missing:] 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">intp_t i</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">c</span>
        <span class="s2">cdef </span><span class="s1">float64_t w </span><span class="s3">= </span><span class="s4">1.0</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_missing </span><span class="s3">= </span><span class="s1">n_missing</span>
        <span class="s2">if </span><span class="s1">n_missing </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return</span>

        <span class="s1">memset</span><span class="s3">(&amp;</span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_missing</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], </span><span class="s4">0</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">max_n_classes </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs </span><span class="s3">* </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">float64_t</span><span class="s3">))</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_missing </span><span class="s3">= </span><span class="s4">0.0</span>

        <span class="s0"># The missing samples are assumed to be in self.sample_indices[-n_missing:]</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">- </span><span class="s1">n_missing</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span><span class="s3">):</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">w </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
                <span class="s1">c </span><span class="s3">= &lt;</span><span class="s1">intp_t</span><span class="s3">&gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">]</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_missing</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">c</span><span class="s3">] += </span><span class="s1">w</span>

            <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_missing </span><span class="s3">+= </span><span class="s1">w</span>

    <span class="s2">cdef </span><span class="s1">int reset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Reset the criterion at pos=start. 
 
        Returns -1 in case of failure to allocate memory (and raise MemoryError) 
        or 0 otherwise. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span>
        <span class="s1">_move_sums_classification</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">,</span>
            <span class="s3">&amp;</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left</span><span class="s3">,</span>
            <span class="s3">&amp;</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">missing_go_to_left</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">cdef </span><span class="s1">int reverse_reset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Reset the criterion at pos=end. 
 
        Returns -1 in case of failure to allocate memory (and raise MemoryError) 
        or 0 otherwise. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span>
        <span class="s1">_move_sums_classification</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">,</span>
            <span class="s3">&amp;</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right</span><span class="s3">,</span>
            <span class="s3">&amp;</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left</span><span class="s3">,</span>
            <span class="s2">not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">missing_go_to_left</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">cdef </span><span class="s1">int update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t new_pos</span><span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Updated statistics by moving sample_indices[pos:new_pos] to the left child. 
 
        Returns -1 in case of failure to allocate memory (and raise MemoryError) 
        or 0 otherwise. 
 
        Parameters 
        ---------- 
        new_pos : intp_t 
            The new ending position for which to move sample_indices from the right 
            child to the left child. 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">intp_t pos </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pos</span>
        <span class="s0"># The missing samples are assumed to be in</span>
        <span class="s0"># self.sample_indices[-self.n_missing:] that is</span>
        <span class="s0"># self.sample_indices[end_non_missing:self.end].</span>
        <span class="s2">cdef </span><span class="s1">intp_t end_non_missing </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_missing</span>

        <span class="s2">cdef </span><span class="s1">const intp_t</span><span class="s3">[:] </span><span class="s1">sample_indices </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_indices</span>
        <span class="s2">cdef </span><span class="s1">const float64_t</span><span class="s3">[:] </span><span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_weight</span>

        <span class="s2">cdef </span><span class="s1">intp_t i</span>
        <span class="s2">cdef </span><span class="s1">intp_t p</span>
        <span class="s2">cdef </span><span class="s1">intp_t k</span>
        <span class="s2">cdef </span><span class="s1">intp_t c</span>
        <span class="s2">cdef </span><span class="s1">float64_t w </span><span class="s3">= </span><span class="s4">1.0</span>

        <span class="s0"># Update statistics up to new_pos</span>
        <span class="s0">#</span>
        <span class="s0"># Given that</span>
        <span class="s0">#   sum_left[x] +  sum_right[x] = sum_total[x]</span>
        <span class="s0"># and that sum_total is known, we are going to update</span>
        <span class="s0"># sum_left from the direction that require the least amount</span>
        <span class="s0"># of computations, i.e. from pos to new_pos or from end to new_po.</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">new_pos </span><span class="s3">- </span><span class="s1">pos</span><span class="s3">) &lt;= (</span><span class="s1">end_non_missing </span><span class="s3">- </span><span class="s1">new_pos</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">pos</span><span class="s3">, </span><span class="s1">new_pos</span><span class="s3">):</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">sample_indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

                <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">w </span><span class="s3">= </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, &lt;</span><span class="s1">intp_t</span><span class="s3">&gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">]] += </span><span class="s1">w</span>

                <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">+= </span><span class="s1">w</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">reverse_reset</span><span class="s3">()</span>

            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">end_non_missing </span><span class="s3">- </span><span class="s4">1</span><span class="s3">, </span><span class="s1">new_pos </span><span class="s3">- </span><span class="s4">1</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">sample_indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

                <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">w </span><span class="s3">= </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, &lt;</span><span class="s1">intp_t</span><span class="s3">&gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">]] -= </span><span class="s1">w</span>

                <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">-= </span><span class="s1">w</span>

        <span class="s0"># Update right part statistics</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_classes</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">c</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_total</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">c</span><span class="s3">] - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">c</span><span class="s3">]</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">= </span><span class="s1">new_pos</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">cdef </span><span class="s1">float64_t node_impurity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s2">pass</span>

    <span class="s2">cdef </span><span class="s1">void children_impurity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t</span><span class="s3">* </span><span class="s1">impurity_left</span><span class="s3">,</span>
                                <span class="s1">float64_t</span><span class="s3">* </span><span class="s1">impurity_right</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s2">pass</span>

    <span class="s2">cdef </span><span class="s1">void node_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t</span><span class="s3">* </span><span class="s1">dest</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Compute the node value of sample_indices[start:end] and save it into dest. 
 
        Parameters 
        ---------- 
        dest : float64_t pointer 
            The memory address which we will save the node value into. 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">intp_t k</span><span class="s3">, </span><span class="s1">c</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_classes</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]):</span>
                <span class="s1">dest</span><span class="s3">[</span><span class="s1">c</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_total</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">c</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span>
            <span class="s1">dest </span><span class="s3">+= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">max_n_classes</span>

    <span class="s2">cdef </span><span class="s1">inline void clip_node_value</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t </span><span class="s3">* </span><span class="s1">dest</span><span class="s3">, </span><span class="s1">float64_t lower_bound</span><span class="s3">, </span><span class="s1">float64_t upper_bound</span>
    <span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Clip the values in dest such that predicted probabilities stay between 
        `lower_bound` and `upper_bound` when monotonic constraints are enforced. 
        Note that monotonicity constraints are only supported for: 
        - single-output trees and 
        - binary classifications. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">dest</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] &lt; </span><span class="s1">lower_bound</span><span class="s3">:</span>
            <span class="s1">dest</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">lower_bound</span>
        <span class="s2">elif </span><span class="s1">dest</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] &gt; </span><span class="s1">upper_bound</span><span class="s3">:</span>
            <span class="s1">dest</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">upper_bound</span>

        <span class="s0"># Values for binary classification must sum to 1.</span>
        <span class="s1">dest</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] = </span><span class="s4">1 </span><span class="s3">- </span><span class="s1">dest</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

    <span class="s2">cdef </span><span class="s1">inline float64_t middle_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Compute the middle value of a split for monotonicity constraints as the simple average 
        of the left and right children values. 
 
        Note that monotonicity constraints are only supported for: 
        - single-output trees and 
        - binary classifications. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">(</span>
            <span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">] / (</span><span class="s4">2 </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left</span><span class="s3">)) +</span>
            <span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">] / (</span><span class="s4">2 </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right</span><span class="s3">))</span>
        <span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">inline bint check_monotonicity</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">cnp</span><span class="s3">.</span><span class="s1">int8_t monotonic_cst</span><span class="s3">,</span>
        <span class="s1">float64_t lower_bound</span><span class="s3">,</span>
        <span class="s1">float64_t upper_bound</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Check monotonicity constraint is satisfied at the current classification split&quot;&quot;&quot;</span>
        <span class="s2">cdef</span><span class="s3">:</span>
            <span class="s1">float64_t value_left </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s4">0</span><span class="s3">][</span><span class="s4">0</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left</span>
            <span class="s1">float64_t value_right </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">[</span><span class="s4">0</span><span class="s3">][</span><span class="s4">0</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_check_monotonicity</span><span class="s3">(</span><span class="s1">monotonic_cst</span><span class="s3">, </span><span class="s1">lower_bound</span><span class="s3">, </span><span class="s1">upper_bound</span><span class="s3">, </span><span class="s1">value_left</span><span class="s3">, </span><span class="s1">value_right</span><span class="s3">)</span>


<span class="s2">cdef class </span><span class="s1">Entropy</span><span class="s3">(</span><span class="s1">ClassificationCriterion</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot;Cross Entropy impurity criterion. 
 
    This handles cases where the target is a classification taking values 
    0, 1, ... K-2, K-1. If node m represents a region Rm with Nm observations, 
    then let 
 
        count_k = 1 / Nm \sum_{x_i in Rm} I(yi = k) 
 
    be the proportion of class k observations in node m. 
 
    The cross-entropy is then defined as 
 
        cross-entropy = -\sum_{k=0}^{K-1} count_k log(count_k) 
    &quot;&quot;&quot;</span>

    <span class="s2">cdef </span><span class="s1">float64_t node_impurity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Evaluate the impurity of the current node. 
 
        Evaluate the cross-entropy criterion as impurity of the current node, 
        i.e. the impurity of sample_indices[start:end]. The smaller the impurity the 
        better. 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">float64_t entropy </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s2">cdef </span><span class="s1">float64_t count_k</span>
        <span class="s2">cdef </span><span class="s1">intp_t k</span>
        <span class="s2">cdef </span><span class="s1">intp_t c</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_classes</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]):</span>
                <span class="s1">count_k </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_total</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">c</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">count_k </span><span class="s3">&gt; </span><span class="s4">0.0</span><span class="s3">:</span>
                    <span class="s1">count_k </span><span class="s3">/= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span>
                    <span class="s1">entropy </span><span class="s3">-= </span><span class="s1">count_k </span><span class="s3">* </span><span class="s1">log</span><span class="s3">(</span><span class="s1">count_k</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">entropy </span><span class="s3">/ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span>

    <span class="s2">cdef </span><span class="s1">void children_impurity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t</span><span class="s3">* </span><span class="s1">impurity_left</span><span class="s3">,</span>
                                <span class="s1">float64_t</span><span class="s3">* </span><span class="s1">impurity_right</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Evaluate the impurity in children nodes. 
 
        i.e. the impurity of the left child (sample_indices[start:pos]) and the 
        impurity the right child (sample_indices[pos:end]). 
 
        Parameters 
        ---------- 
        impurity_left : float64_t pointer 
            The memory address to save the impurity of the left node 
        impurity_right : float64_t pointer 
            The memory address to save the impurity of the right node 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">float64_t entropy_left </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s2">cdef </span><span class="s1">float64_t entropy_right </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s2">cdef </span><span class="s1">float64_t count_k</span>
        <span class="s2">cdef </span><span class="s1">intp_t k</span>
        <span class="s2">cdef </span><span class="s1">intp_t c</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_classes</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]):</span>
                <span class="s1">count_k </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">c</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">count_k </span><span class="s3">&gt; </span><span class="s4">0.0</span><span class="s3">:</span>
                    <span class="s1">count_k </span><span class="s3">/= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left</span>
                    <span class="s1">entropy_left </span><span class="s3">-= </span><span class="s1">count_k </span><span class="s3">* </span><span class="s1">log</span><span class="s3">(</span><span class="s1">count_k</span><span class="s3">)</span>

                <span class="s1">count_k </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">c</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">count_k </span><span class="s3">&gt; </span><span class="s4">0.0</span><span class="s3">:</span>
                    <span class="s1">count_k </span><span class="s3">/= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right</span>
                    <span class="s1">entropy_right </span><span class="s3">-= </span><span class="s1">count_k </span><span class="s3">* </span><span class="s1">log</span><span class="s3">(</span><span class="s1">count_k</span><span class="s3">)</span>

        <span class="s1">impurity_left</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">entropy_left </span><span class="s3">/ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span>
        <span class="s1">impurity_right</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">entropy_right </span><span class="s3">/ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span>


<span class="s2">cdef class </span><span class="s1">Gini</span><span class="s3">(</span><span class="s1">ClassificationCriterion</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot;Gini Index impurity criterion. 
 
    This handles cases where the target is a classification taking values 
    0, 1, ... K-2, K-1. If node m represents a region Rm with Nm observations, 
    then let 
 
        count_k = 1/ Nm \sum_{x_i in Rm} I(yi = k) 
 
    be the proportion of class k observations in node m. 
 
    The Gini Index is then defined as: 
 
        index = \sum_{k=0}^{K-1} count_k (1 - count_k) 
              = 1 - \sum_{k=0}^{K-1} count_k ** 2 
    &quot;&quot;&quot;</span>

    <span class="s2">cdef </span><span class="s1">float64_t node_impurity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Evaluate the impurity of the current node. 
 
        Evaluate the Gini criterion as impurity of the current node, 
        i.e. the impurity of sample_indices[start:end]. The smaller the impurity the 
        better. 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">float64_t gini </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s2">cdef </span><span class="s1">float64_t sq_count</span>
        <span class="s2">cdef </span><span class="s1">float64_t count_k</span>
        <span class="s2">cdef </span><span class="s1">intp_t k</span>
        <span class="s2">cdef </span><span class="s1">intp_t c</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">sq_count </span><span class="s3">= </span><span class="s4">0.0</span>

            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_classes</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]):</span>
                <span class="s1">count_k </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_total</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">c</span><span class="s3">]</span>
                <span class="s1">sq_count </span><span class="s3">+= </span><span class="s1">count_k </span><span class="s3">* </span><span class="s1">count_k</span>

            <span class="s1">gini </span><span class="s3">+= </span><span class="s4">1.0 </span><span class="s3">- </span><span class="s1">sq_count </span><span class="s3">/ (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">*</span>
                                      <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">gini </span><span class="s3">/ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span>

    <span class="s2">cdef </span><span class="s1">void children_impurity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t</span><span class="s3">* </span><span class="s1">impurity_left</span><span class="s3">,</span>
                                <span class="s1">float64_t</span><span class="s3">* </span><span class="s1">impurity_right</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Evaluate the impurity in children nodes. 
 
        i.e. the impurity of the left child (sample_indices[start:pos]) and the 
        impurity the right child (sample_indices[pos:end]) using the Gini index. 
 
        Parameters 
        ---------- 
        impurity_left : float64_t pointer 
            The memory address to save the impurity of the left node to 
        impurity_right : float64_t pointer 
            The memory address to save the impurity of the right node to 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">float64_t gini_left </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s2">cdef </span><span class="s1">float64_t gini_right </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s2">cdef </span><span class="s1">float64_t sq_count_left</span>
        <span class="s2">cdef </span><span class="s1">float64_t sq_count_right</span>
        <span class="s2">cdef </span><span class="s1">float64_t count_k</span>
        <span class="s2">cdef </span><span class="s1">intp_t k</span>
        <span class="s2">cdef </span><span class="s1">intp_t c</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">sq_count_left </span><span class="s3">= </span><span class="s4">0.0</span>
            <span class="s1">sq_count_right </span><span class="s3">= </span><span class="s4">0.0</span>

            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_classes</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]):</span>
                <span class="s1">count_k </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">c</span><span class="s3">]</span>
                <span class="s1">sq_count_left </span><span class="s3">+= </span><span class="s1">count_k </span><span class="s3">* </span><span class="s1">count_k</span>

                <span class="s1">count_k </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">[</span><span class="s1">k</span><span class="s3">, </span><span class="s1">c</span><span class="s3">]</span>
                <span class="s1">sq_count_right </span><span class="s3">+= </span><span class="s1">count_k </span><span class="s3">* </span><span class="s1">count_k</span>

            <span class="s1">gini_left </span><span class="s3">+= </span><span class="s4">1.0 </span><span class="s3">- </span><span class="s1">sq_count_left </span><span class="s3">/ (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">*</span>
                                                <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left</span><span class="s3">)</span>

            <span class="s1">gini_right </span><span class="s3">+= </span><span class="s4">1.0 </span><span class="s3">- </span><span class="s1">sq_count_right </span><span class="s3">/ (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">*</span>
                                                  <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right</span><span class="s3">)</span>

        <span class="s1">impurity_left</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">gini_left </span><span class="s3">/ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span>
        <span class="s1">impurity_right</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">gini_right </span><span class="s3">/ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span>


<span class="s2">cdef </span><span class="s1">inline void _move_sums_regression</span><span class="s3">(</span>
    <span class="s1">RegressionCriterion criterion</span><span class="s3">,</span>
    <span class="s1">float64_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">sum_1</span><span class="s3">,</span>
    <span class="s1">float64_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">sum_2</span><span class="s3">,</span>
    <span class="s1">float64_t</span><span class="s3">* </span><span class="s1">weighted_n_1</span><span class="s3">,</span>
    <span class="s1">float64_t</span><span class="s3">* </span><span class="s1">weighted_n_2</span><span class="s3">,</span>
    <span class="s1">bint put_missing_in_1</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot;Distribute sum_total and sum_missing into sum_1 and sum_2. 
 
    If there are missing values and: 
    - put_missing_in_1 is True, then missing values to go sum_1. Specifically: 
        sum_1 = sum_missing 
        sum_2 = sum_total - sum_missing 
 
    - put_missing_in_1 is False, then missing values go to sum_2. Specifically: 
        sum_1 = 0 
        sum_2 = sum_total 
    &quot;&quot;&quot;</span>
    <span class="s2">cdef</span><span class="s3">:</span>
        <span class="s1">intp_t i</span>
        <span class="s1">intp_t n_bytes </span><span class="s3">= </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">n_outputs </span><span class="s3">* </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">float64_t</span><span class="s3">)</span>
        <span class="s1">bint has_missing </span><span class="s3">= </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">n_missing </span><span class="s3">!= </span><span class="s4">0</span>

    <span class="s2">if </span><span class="s1">has_missing </span><span class="s2">and </span><span class="s1">put_missing_in_1</span><span class="s3">:</span>
        <span class="s1">memcpy</span><span class="s3">(&amp;</span><span class="s1">sum_1</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], &amp;</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">sum_missing</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">n_bytes</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">sum_2</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">sum_total</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">sum_missing</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s1">weighted_n_1</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">weighted_n_missing</span>
        <span class="s1">weighted_n_2</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">- </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">weighted_n_missing</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">memset</span><span class="s3">(&amp;</span><span class="s1">sum_1</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s4">0</span><span class="s3">, </span><span class="s1">n_bytes</span><span class="s3">)</span>
        <span class="s0"># Assigning sum_2 = sum_total for all outputs.</span>
        <span class="s1">memcpy</span><span class="s3">(&amp;</span><span class="s1">sum_2</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], &amp;</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">sum_total</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">n_bytes</span><span class="s3">)</span>
        <span class="s1">weighted_n_1</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s4">0.0</span>
        <span class="s1">weighted_n_2</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span>


<span class="s2">cdef class </span><span class="s1">RegressionCriterion</span><span class="s3">(</span><span class="s1">Criterion</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot;Abstract regression criterion. 
 
    This handles cases where the target is a continuous value, and is 
    evaluated by computing the variance of the target values left and right 
    of the split point. The computation takes linear time with `n_samples` 
    by using :: 
 
        var = \sum_i^n (y_i - y_bar) ** 2 
            = (\sum_i^n y_i ** 2) - n_samples * y_bar ** 2 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__cinit__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t n_outputs</span><span class="s3">, </span><span class="s1">intp_t n_samples</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Initialize parameters for this criterion. 
 
        Parameters 
        ---------- 
        n_outputs : intp_t 
            The number of targets to be predicted 
 
        n_samples : intp_t 
            The total number of samples to fit on 
        &quot;&quot;&quot;</span>
        <span class="s0"># Default values</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">start </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">= </span><span class="s4">0</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs </span><span class="s3">= </span><span class="s1">n_outputs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples </span><span class="s3">= </span><span class="s1">n_samples</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_node_samples </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_missing </span><span class="s3">= </span><span class="s4">0.0</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">sq_sum_total </span><span class="s3">= </span><span class="s4">0.0</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_total </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__reduce__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">), (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__getstate__</span><span class="s3">())</span>

    <span class="s2">cdef </span><span class="s1">int init</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">y</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:] </span><span class="s1">sample_weight</span><span class="s3">,</span>
        <span class="s1">float64_t weighted_n_samples</span><span class="s3">,</span>
        <span class="s1">const intp_t</span><span class="s3">[:] </span><span class="s1">sample_indices</span><span class="s3">,</span>
        <span class="s1">intp_t start</span><span class="s3">,</span>
        <span class="s1">intp_t end</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Initialize the criterion. 
 
        This initializes the criterion at node sample_indices[start:end] and children 
        sample_indices[start:start] and sample_indices[start:end]. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Initialize fields</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">y </span><span class="s3">= </span><span class="s1">y</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">sample_weight</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sample_indices </span><span class="s3">= </span><span class="s1">sample_indices</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">start </span><span class="s3">= </span><span class="s1">start</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">= </span><span class="s1">end</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_node_samples </span><span class="s3">= </span><span class="s1">end </span><span class="s3">- </span><span class="s1">start</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_samples </span><span class="s3">= </span><span class="s1">weighted_n_samples</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">= </span><span class="s4">0.</span>

        <span class="s2">cdef </span><span class="s1">intp_t i</span>
        <span class="s2">cdef </span><span class="s1">intp_t p</span>
        <span class="s2">cdef </span><span class="s1">intp_t k</span>
        <span class="s2">cdef </span><span class="s1">float64_t y_ik</span>
        <span class="s2">cdef </span><span class="s1">float64_t w_y_ik</span>
        <span class="s2">cdef </span><span class="s1">float64_t w </span><span class="s3">= </span><span class="s4">1.0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sq_sum_total </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s1">memset</span><span class="s3">(&amp;</span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_total</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s4">0</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs </span><span class="s3">* </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">float64_t</span><span class="s3">))</span>

        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">):</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s1">sample_indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

            <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">w </span><span class="s3">= </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
                <span class="s1">y_ik </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">]</span>
                <span class="s1">w_y_ik </span><span class="s3">= </span><span class="s1">w </span><span class="s3">* </span><span class="s1">y_ik</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_total</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] += </span><span class="s1">w_y_ik</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">sq_sum_total </span><span class="s3">+= </span><span class="s1">w_y_ik </span><span class="s3">* </span><span class="s1">y_ik</span>

            <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">+= </span><span class="s1">w</span>

        <span class="s0"># Reset to pos=start</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">reset</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">cdef </span><span class="s1">void init_sum_missing</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Init sum_missing to hold sums for missing values.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_missing </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">void init_missing</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t n_missing</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Initialize sum_missing if there are missing values. 
 
        This method assumes that caller placed the missing samples in 
        self.sample_indices[-n_missing:] 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">intp_t i</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span>
        <span class="s2">cdef </span><span class="s1">float64_t y_ik</span>
        <span class="s2">cdef </span><span class="s1">float64_t w_y_ik</span>
        <span class="s2">cdef </span><span class="s1">float64_t w </span><span class="s3">= </span><span class="s4">1.0</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_missing </span><span class="s3">= </span><span class="s1">n_missing</span>
        <span class="s2">if </span><span class="s1">n_missing </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return</span>

        <span class="s1">memset</span><span class="s3">(&amp;</span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_missing</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s4">0</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs </span><span class="s3">* </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">float64_t</span><span class="s3">))</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_missing </span><span class="s3">= </span><span class="s4">0.0</span>

        <span class="s0"># The missing samples are assumed to be in self.sample_indices[-n_missing:]</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">- </span><span class="s1">n_missing</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span><span class="s3">):</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">w </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
                <span class="s1">y_ik </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">]</span>
                <span class="s1">w_y_ik </span><span class="s3">= </span><span class="s1">w </span><span class="s3">* </span><span class="s1">y_ik</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_missing</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] += </span><span class="s1">w_y_ik</span>

            <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_missing </span><span class="s3">+= </span><span class="s1">w</span>

    <span class="s2">cdef </span><span class="s1">int reset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Reset the criterion at pos=start.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span>
        <span class="s1">_move_sums_regression</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">,</span>
            <span class="s3">&amp;</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left</span><span class="s3">,</span>
            <span class="s3">&amp;</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">missing_go_to_left</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">cdef </span><span class="s1">int reverse_reset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Reset the criterion at pos=end.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span>
        <span class="s1">_move_sums_regression</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">,</span>
            <span class="s3">&amp;</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right</span><span class="s3">,</span>
            <span class="s3">&amp;</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left</span><span class="s3">,</span>
            <span class="s2">not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">missing_go_to_left</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">cdef </span><span class="s1">int update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t new_pos</span><span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Updated statistics by moving sample_indices[pos:new_pos] to the left.&quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">const float64_t</span><span class="s3">[:] </span><span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_weight</span>
        <span class="s2">cdef </span><span class="s1">const intp_t</span><span class="s3">[:] </span><span class="s1">sample_indices </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_indices</span>

        <span class="s2">cdef </span><span class="s1">intp_t pos </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pos</span>

        <span class="s0"># The missing samples are assumed to be in</span>
        <span class="s0"># self.sample_indices[-self.n_missing:] that is</span>
        <span class="s0"># self.sample_indices[end_non_missing:self.end].</span>
        <span class="s2">cdef </span><span class="s1">intp_t end_non_missing </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_missing</span>
        <span class="s2">cdef </span><span class="s1">intp_t i</span>
        <span class="s2">cdef </span><span class="s1">intp_t p</span>
        <span class="s2">cdef </span><span class="s1">intp_t k</span>
        <span class="s2">cdef </span><span class="s1">float64_t w </span><span class="s3">= </span><span class="s4">1.0</span>

        <span class="s0"># Update statistics up to new_pos</span>
        <span class="s0">#</span>
        <span class="s0"># Given that</span>
        <span class="s0">#           sum_left[x] +  sum_right[x] = sum_total[x]</span>
        <span class="s0"># and that sum_total is known, we are going to update</span>
        <span class="s0"># sum_left from the direction that require the least amount</span>
        <span class="s0"># of computations, i.e. from pos to new_pos or from end to new_pos.</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">new_pos </span><span class="s3">- </span><span class="s1">pos</span><span class="s3">) &lt;= (</span><span class="s1">end_non_missing </span><span class="s3">- </span><span class="s1">new_pos</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">pos</span><span class="s3">, </span><span class="s1">new_pos</span><span class="s3">):</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">sample_indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

                <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">w </span><span class="s3">= </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] += </span><span class="s1">w </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">]</span>

                <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">+= </span><span class="s1">w</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">reverse_reset</span><span class="s3">()</span>

            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">end_non_missing </span><span class="s3">- </span><span class="s4">1</span><span class="s3">, </span><span class="s1">new_pos </span><span class="s3">- </span><span class="s4">1</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">sample_indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

                <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">w </span><span class="s3">= </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] -= </span><span class="s1">w </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">]</span>

                <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">-= </span><span class="s1">w</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">= (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">-</span>
                                 <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_total</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">= </span><span class="s1">new_pos</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">cdef </span><span class="s1">float64_t node_impurity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s2">pass</span>

    <span class="s2">cdef </span><span class="s1">void children_impurity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t</span><span class="s3">* </span><span class="s1">impurity_left</span><span class="s3">,</span>
                                <span class="s1">float64_t</span><span class="s3">* </span><span class="s1">impurity_right</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s2">pass</span>

    <span class="s2">cdef </span><span class="s1">void node_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t</span><span class="s3">* </span><span class="s1">dest</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Compute the node value of sample_indices[start:end] into dest.&quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">intp_t k</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">dest</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_total</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span>

    <span class="s2">cdef </span><span class="s1">inline void clip_node_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t</span><span class="s3">* </span><span class="s1">dest</span><span class="s3">, </span><span class="s1">float64_t lower_bound</span><span class="s3">, </span><span class="s1">float64_t upper_bound</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Clip the value in dest between lower_bound and upper_bound for monotonic constraints.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">dest</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] &lt; </span><span class="s1">lower_bound</span><span class="s3">:</span>
            <span class="s1">dest</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">lower_bound</span>
        <span class="s2">elif </span><span class="s1">dest</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] &gt; </span><span class="s1">upper_bound</span><span class="s3">:</span>
            <span class="s1">dest</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">upper_bound</span>

    <span class="s2">cdef </span><span class="s1">float64_t middle_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Compute the middle value of a split for monotonicity constraints as the simple average 
        of the left and right children values. 
 
        Monotonicity constraints are only supported for single-output trees we can safely assume 
        n_outputs == 1. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">(</span>
            <span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] / (</span><span class="s4">2 </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left</span><span class="s3">)) +</span>
            <span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] / (</span><span class="s4">2 </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right</span><span class="s3">))</span>
        <span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">bint check_monotonicity</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">cnp</span><span class="s3">.</span><span class="s1">int8_t monotonic_cst</span><span class="s3">,</span>
        <span class="s1">float64_t lower_bound</span><span class="s3">,</span>
        <span class="s1">float64_t upper_bound</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Check monotonicity constraint is satisfied at the current regression split&quot;&quot;&quot;</span>
        <span class="s2">cdef</span><span class="s3">:</span>
            <span class="s1">float64_t value_left </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left</span>
            <span class="s1">float64_t value_right </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_check_monotonicity</span><span class="s3">(</span><span class="s1">monotonic_cst</span><span class="s3">, </span><span class="s1">lower_bound</span><span class="s3">, </span><span class="s1">upper_bound</span><span class="s3">, </span><span class="s1">value_left</span><span class="s3">, </span><span class="s1">value_right</span><span class="s3">)</span>

<span class="s2">cdef class </span><span class="s1">MSE</span><span class="s3">(</span><span class="s1">RegressionCriterion</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Mean squared error impurity criterion. 
 
        MSE = var_left + var_right 
    &quot;&quot;&quot;</span>

    <span class="s2">cdef </span><span class="s1">float64_t node_impurity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Evaluate the impurity of the current node. 
 
        Evaluate the MSE criterion as impurity of the current node, 
        i.e. the impurity of sample_indices[start:end]. The smaller the impurity the 
        better. 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">float64_t impurity</span>
        <span class="s2">cdef </span><span class="s1">intp_t k</span>

        <span class="s1">impurity </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sq_sum_total </span><span class="s3">/ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">impurity </span><span class="s3">-= (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_total</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span><span class="s3">)**</span><span class="s4">2.0</span>

        <span class="s2">return </span><span class="s1">impurity </span><span class="s3">/ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span>

    <span class="s2">cdef </span><span class="s1">float64_t proxy_impurity_improvement</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Compute a proxy of the impurity reduction. 
 
        This method is used to speed up the search for the best split. 
        It is a proxy quantity such that the split that maximizes this value 
        also maximizes the impurity improvement. It neglects all constant terms 
        of the impurity decrease for a given split. 
 
        The absolute impurity improvement is only computed by the 
        impurity_improvement method once the best split has been found. 
 
        The MSE proxy is derived from 
 
            sum_{i left}(y_i - y_pred_L)^2 + sum_{i right}(y_i - y_pred_R)^2 
            = sum(y_i^2) - n_L * mean_{i left}(y_i)^2 - n_R * mean_{i right}(y_i)^2 
 
        Neglecting constant terms, this gives: 
 
            - 1/n_L * sum_{i left}(y_i)^2 - 1/n_R * sum_{i right}(y_i)^2 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">intp_t k</span>
        <span class="s2">cdef </span><span class="s1">float64_t proxy_impurity_left </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s2">cdef </span><span class="s1">float64_t proxy_impurity_right </span><span class="s3">= </span><span class="s4">0.0</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">proxy_impurity_left </span><span class="s3">+= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
            <span class="s1">proxy_impurity_right </span><span class="s3">+= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] * </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>

        <span class="s2">return </span><span class="s3">(</span><span class="s1">proxy_impurity_left </span><span class="s3">/ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">+</span>
                <span class="s1">proxy_impurity_right </span><span class="s3">/ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">void children_impurity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t</span><span class="s3">* </span><span class="s1">impurity_left</span><span class="s3">,</span>
                                <span class="s1">float64_t</span><span class="s3">* </span><span class="s1">impurity_right</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Evaluate the impurity in children nodes. 
 
        i.e. the impurity of the left child (sample_indices[start:pos]) and the 
        impurity the right child (sample_indices[pos:end]). 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">const float64_t</span><span class="s3">[:] </span><span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_weight</span>
        <span class="s2">cdef </span><span class="s1">const intp_t</span><span class="s3">[:] </span><span class="s1">sample_indices </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_indices</span>
        <span class="s2">cdef </span><span class="s1">intp_t pos </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pos</span>
        <span class="s2">cdef </span><span class="s1">intp_t start </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span>

        <span class="s2">cdef </span><span class="s1">float64_t y_ik</span>

        <span class="s2">cdef </span><span class="s1">float64_t sq_sum_left </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s2">cdef </span><span class="s1">float64_t sq_sum_right</span>

        <span class="s2">cdef </span><span class="s1">intp_t i</span>
        <span class="s2">cdef </span><span class="s1">intp_t p</span>
        <span class="s2">cdef </span><span class="s1">intp_t k</span>
        <span class="s2">cdef </span><span class="s1">float64_t w </span><span class="s3">= </span><span class="s4">1.0</span>

        <span class="s2">cdef </span><span class="s1">intp_t end_non_missing</span>

        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">):</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s1">sample_indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

            <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">w </span><span class="s3">= </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
                <span class="s1">y_ik </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">]</span>
                <span class="s1">sq_sum_left </span><span class="s3">+= </span><span class="s1">w </span><span class="s3">* </span><span class="s1">y_ik </span><span class="s3">* </span><span class="s1">y_ik</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">missing_go_to_left</span><span class="s3">:</span>
            <span class="s0"># add up the impact of these missing values on the left child</span>
            <span class="s0"># statistics.</span>
            <span class="s0"># Note: this only impacts the square sum as the sum</span>
            <span class="s0"># is modified elsewhere.</span>
            <span class="s1">end_non_missing </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_missing</span>

            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">end_non_missing</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span><span class="s3">):</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">sample_indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">w </span><span class="s3">= </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
                    <span class="s1">y_ik </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">]</span>
                    <span class="s1">sq_sum_left </span><span class="s3">+= </span><span class="s1">w </span><span class="s3">* </span><span class="s1">y_ik </span><span class="s3">* </span><span class="s1">y_ik</span>

        <span class="s1">sq_sum_right </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sq_sum_total </span><span class="s3">- </span><span class="s1">sq_sum_left</span>

        <span class="s1">impurity_left</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">sq_sum_left </span><span class="s3">/ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left</span>
        <span class="s1">impurity_right</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">sq_sum_right </span><span class="s3">/ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">impurity_left</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] -= (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left</span><span class="s3">) ** </span><span class="s4">2.0</span>
            <span class="s1">impurity_right</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] -= (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right</span><span class="s3">) ** </span><span class="s4">2.0</span>

        <span class="s1">impurity_left</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] /= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span>
        <span class="s1">impurity_right</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] /= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span>


<span class="s2">cdef class </span><span class="s1">MAE</span><span class="s3">(</span><span class="s1">RegressionCriterion</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot;Mean absolute error impurity criterion. 
 
       MAE = (1 / n)*(\sum_i |y_i - f_i|), where y_i is the true 
       value and f_i is the predicted value.&quot;&quot;&quot;</span>

    <span class="s2">cdef </span><span class="s1">cnp</span><span class="s3">.</span><span class="s1">ndarray left_child</span>
    <span class="s2">cdef </span><span class="s1">cnp</span><span class="s3">.</span><span class="s1">ndarray right_child</span>
    <span class="s2">cdef </span><span class="s1">void</span><span class="s3">** </span><span class="s1">left_child_ptr</span>
    <span class="s2">cdef </span><span class="s1">void</span><span class="s3">** </span><span class="s1">right_child_ptr</span>
    <span class="s2">cdef </span><span class="s1">float64_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">node_medians</span>

    <span class="s2">def </span><span class="s1">__cinit__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t n_outputs</span><span class="s3">, </span><span class="s1">intp_t n_samples</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Initialize parameters for this criterion. 
 
        Parameters 
        ---------- 
        n_outputs : intp_t 
            The number of targets to be predicted 
 
        n_samples : intp_t 
            The total number of samples to fit on 
        &quot;&quot;&quot;</span>
        <span class="s0"># Default values</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">start </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">= </span><span class="s4">0</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs </span><span class="s3">= </span><span class="s1">n_outputs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples </span><span class="s3">= </span><span class="s1">n_samples</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_node_samples </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">= </span><span class="s4">0.0</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">node_medians </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">left_child </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s5">'object'</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">right_child </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s5">'object'</span><span class="s3">)</span>
        <span class="s0"># initialize WeightedMedianCalculators</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">left_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">WeightedMedianCalculator</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">right_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">WeightedMedianCalculator</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">left_child_ptr </span><span class="s3">= &lt;</span><span class="s1">void</span><span class="s3">**&gt; </span><span class="s1">cnp</span><span class="s3">.</span><span class="s1">PyArray_DATA</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">left_child</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">right_child_ptr </span><span class="s3">= &lt;</span><span class="s1">void</span><span class="s3">**&gt; </span><span class="s1">cnp</span><span class="s3">.</span><span class="s1">PyArray_DATA</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">right_child</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">int init</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">y</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:] </span><span class="s1">sample_weight</span><span class="s3">,</span>
        <span class="s1">float64_t weighted_n_samples</span><span class="s3">,</span>
        <span class="s1">const intp_t</span><span class="s3">[:] </span><span class="s1">sample_indices</span><span class="s3">,</span>
        <span class="s1">intp_t start</span><span class="s3">,</span>
        <span class="s1">intp_t end</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Initialize the criterion. 
 
        This initializes the criterion at node sample_indices[start:end] and children 
        sample_indices[start:start] and sample_indices[start:end]. 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">intp_t i</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span>
        <span class="s2">cdef </span><span class="s1">float64_t w </span><span class="s3">= </span><span class="s4">1.0</span>

        <span class="s0"># Initialize fields</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">y </span><span class="s3">= </span><span class="s1">y</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">sample_weight</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sample_indices </span><span class="s3">= </span><span class="s1">sample_indices</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">start </span><span class="s3">= </span><span class="s1">start</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">= </span><span class="s1">end</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_node_samples </span><span class="s3">= </span><span class="s1">end </span><span class="s3">- </span><span class="s1">start</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_samples </span><span class="s3">= </span><span class="s1">weighted_n_samples</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">= </span><span class="s4">0.</span>

        <span class="s2">cdef </span><span class="s1">void</span><span class="s3">** </span><span class="s1">left_child </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">left_child_ptr</span>
        <span class="s2">cdef </span><span class="s1">void</span><span class="s3">** </span><span class="s1">right_child </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">right_child_ptr</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s3">(&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">left_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]).</span><span class="s1">reset</span><span class="s3">()</span>
            <span class="s3">(&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">right_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]).</span><span class="s1">reset</span><span class="s3">()</span>

        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">):</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s1">sample_indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

            <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">w </span><span class="s3">= </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
                <span class="s0"># push method ends up calling safe_realloc, hence `except -1`</span>
                <span class="s0"># push all values to the right side,</span>
                <span class="s0"># since pos = start initially anyway</span>
                <span class="s3">(&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">right_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]).</span><span class="s1">push</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">], </span><span class="s1">w</span><span class="s3">)</span>

            <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">+= </span><span class="s1">w</span>
        <span class="s0"># calculate the node medians</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">node_medians</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = (&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">right_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]).</span><span class="s1">get_median</span><span class="s3">()</span>

        <span class="s0"># Reset to pos=start</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">reset</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">cdef </span><span class="s1">void init_missing</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t n_missing</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Raise error if n_missing != 0.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">n_missing </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s2">with </span><span class="s1">gil</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;missing values is not supported for MAE.&quot;</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">int reset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Reset the criterion at pos=start. 
 
        Returns -1 in case of failure to allocate memory (and raise MemoryError) 
        or 0 otherwise. 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">intp_t i</span><span class="s3">, </span><span class="s1">k</span>
        <span class="s2">cdef </span><span class="s1">float64_t value</span>
        <span class="s2">cdef </span><span class="s1">float64_t weight</span>

        <span class="s2">cdef </span><span class="s1">void</span><span class="s3">** </span><span class="s1">left_child </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">left_child_ptr</span>
        <span class="s2">cdef </span><span class="s1">void</span><span class="s3">** </span><span class="s1">right_child </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">right_child_ptr</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span>

        <span class="s0"># reset the WeightedMedianCalculators, left should have no</span>
        <span class="s0"># elements and right should have all elements.</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s0"># if left has no elements, it's already reset</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">((&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">left_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]).</span><span class="s1">size</span><span class="s3">()):</span>
                <span class="s0"># remove everything from left and put it into right</span>
                <span class="s3">(&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">left_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]).</span><span class="s1">pop</span><span class="s3">(&amp;</span><span class="s1">value</span><span class="s3">,</span>
                                                               <span class="s3">&amp;</span><span class="s1">weight</span><span class="s3">)</span>
                <span class="s0"># push method ends up calling safe_realloc, hence `except -1`</span>
                <span class="s3">(&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">right_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]).</span><span class="s1">push</span><span class="s3">(</span><span class="s1">value</span><span class="s3">,</span>
                                                                 <span class="s1">weight</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">cdef </span><span class="s1">int reverse_reset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Reset the criterion at pos=end. 
 
        Returns -1 in case of failure to allocate memory (and raise MemoryError) 
        or 0 otherwise. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span>

        <span class="s2">cdef </span><span class="s1">float64_t value</span>
        <span class="s2">cdef </span><span class="s1">float64_t weight</span>
        <span class="s2">cdef </span><span class="s1">void</span><span class="s3">** </span><span class="s1">left_child </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">left_child_ptr</span>
        <span class="s2">cdef </span><span class="s1">void</span><span class="s3">** </span><span class="s1">right_child </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">right_child_ptr</span>

        <span class="s0"># reverse reset the WeightedMedianCalculators, right should have no</span>
        <span class="s0"># elements and left should have all elements.</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s0"># if right has no elements, it's already reset</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">((&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">right_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]).</span><span class="s1">size</span><span class="s3">()):</span>
                <span class="s0"># remove everything from right and put it into left</span>
                <span class="s3">(&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">right_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]).</span><span class="s1">pop</span><span class="s3">(&amp;</span><span class="s1">value</span><span class="s3">,</span>
                                                                <span class="s3">&amp;</span><span class="s1">weight</span><span class="s3">)</span>
                <span class="s0"># push method ends up calling safe_realloc, hence `except -1`</span>
                <span class="s3">(&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">left_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]).</span><span class="s1">push</span><span class="s3">(</span><span class="s1">value</span><span class="s3">,</span>
                                                                <span class="s1">weight</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">cdef </span><span class="s1">int update</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t new_pos</span><span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Updated statistics by moving sample_indices[pos:new_pos] to the left. 
 
        Returns -1 in case of failure to allocate memory (and raise MemoryError) 
        or 0 otherwise. 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">const float64_t</span><span class="s3">[:] </span><span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_weight</span>
        <span class="s2">cdef </span><span class="s1">const intp_t</span><span class="s3">[:] </span><span class="s1">sample_indices </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_indices</span>

        <span class="s2">cdef </span><span class="s1">void</span><span class="s3">** </span><span class="s1">left_child </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">left_child_ptr</span>
        <span class="s2">cdef </span><span class="s1">void</span><span class="s3">** </span><span class="s1">right_child </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">right_child_ptr</span>

        <span class="s2">cdef </span><span class="s1">intp_t pos </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pos</span>
        <span class="s2">cdef </span><span class="s1">intp_t end </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span>
        <span class="s2">cdef </span><span class="s1">intp_t i</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span>
        <span class="s2">cdef </span><span class="s1">float64_t w </span><span class="s3">= </span><span class="s4">1.0</span>

        <span class="s0"># Update statistics up to new_pos</span>
        <span class="s0">#</span>
        <span class="s0"># We are going to update right_child and left_child</span>
        <span class="s0"># from the direction that require the least amount of</span>
        <span class="s0"># computations, i.e. from pos to new_pos or from end to new_pos.</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">new_pos </span><span class="s3">- </span><span class="s1">pos</span><span class="s3">) &lt;= (</span><span class="s1">end </span><span class="s3">- </span><span class="s1">new_pos</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">pos</span><span class="s3">, </span><span class="s1">new_pos</span><span class="s3">):</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">sample_indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

                <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">w </span><span class="s3">= </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
                    <span class="s0"># remove y_ik and its weight w from right and add to left</span>
                    <span class="s3">(&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">right_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]).</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">], </span><span class="s1">w</span><span class="s3">)</span>
                    <span class="s0"># push method ends up calling safe_realloc, hence except -1</span>
                    <span class="s3">(&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">left_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]).</span><span class="s1">push</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">], </span><span class="s1">w</span><span class="s3">)</span>

                <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">+= </span><span class="s1">w</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">reverse_reset</span><span class="s3">()</span>

            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">end </span><span class="s3">- </span><span class="s4">1</span><span class="s3">, </span><span class="s1">new_pos </span><span class="s3">- </span><span class="s4">1</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">):</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">sample_indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

                <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">w </span><span class="s3">= </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
                    <span class="s0"># remove y_ik and its weight w from left and add to right</span>
                    <span class="s3">(&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">left_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]).</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">], </span><span class="s1">w</span><span class="s3">)</span>
                    <span class="s3">(&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">right_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]).</span><span class="s1">push</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">], </span><span class="s1">w</span><span class="s3">)</span>

                <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">-= </span><span class="s1">w</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">= (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">-</span>
                                 <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">= </span><span class="s1">new_pos</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">cdef </span><span class="s1">void node_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t</span><span class="s3">* </span><span class="s1">dest</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Computes the node value of sample_indices[start:end] into dest.&quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">intp_t k</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">dest</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = &lt;</span><span class="s1">float64_t</span><span class="s3">&gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">node_medians</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>

    <span class="s2">cdef </span><span class="s1">inline float64_t middle_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Compute the middle value of a split for monotonicity constraints as the simple average 
        of the left and right children values. 
 
        Monotonicity constraints are only supported for single-output trees we can safely assume 
        n_outputs == 1. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">(</span>
                <span class="s3">(&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">left_child_ptr</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]).</span><span class="s1">get_median</span><span class="s3">() +</span>
                <span class="s3">(&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">right_child_ptr</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]).</span><span class="s1">get_median</span><span class="s3">()</span>
        <span class="s3">) / </span><span class="s4">2</span>

    <span class="s2">cdef </span><span class="s1">inline bint check_monotonicity</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">cnp</span><span class="s3">.</span><span class="s1">int8_t monotonic_cst</span><span class="s3">,</span>
        <span class="s1">float64_t lower_bound</span><span class="s3">,</span>
        <span class="s1">float64_t upper_bound</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Check monotonicity constraint is satisfied at the current regression split&quot;&quot;&quot;</span>
        <span class="s2">cdef</span><span class="s3">:</span>
            <span class="s1">float64_t value_left </span><span class="s3">= (&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">left_child_ptr</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]).</span><span class="s1">get_median</span><span class="s3">()</span>
            <span class="s1">float64_t value_right </span><span class="s3">= (&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">right_child_ptr</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]).</span><span class="s1">get_median</span><span class="s3">()</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_check_monotonicity</span><span class="s3">(</span><span class="s1">monotonic_cst</span><span class="s3">, </span><span class="s1">lower_bound</span><span class="s3">, </span><span class="s1">upper_bound</span><span class="s3">, </span><span class="s1">value_left</span><span class="s3">, </span><span class="s1">value_right</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">float64_t node_impurity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Evaluate the impurity of the current node. 
 
        Evaluate the MAE criterion as impurity of the current node, 
        i.e. the impurity of sample_indices[start:end]. The smaller the impurity the 
        better. 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">const float64_t</span><span class="s3">[:] </span><span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_weight</span>
        <span class="s2">cdef </span><span class="s1">const intp_t</span><span class="s3">[:] </span><span class="s1">sample_indices </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_indices</span>
        <span class="s2">cdef </span><span class="s1">intp_t i</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span>
        <span class="s2">cdef </span><span class="s1">float64_t w </span><span class="s3">= </span><span class="s4">1.0</span>
        <span class="s2">cdef </span><span class="s1">float64_t impurity </span><span class="s3">= </span><span class="s4">0.0</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span><span class="s3">):</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">sample_indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

                <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">w </span><span class="s3">= </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

                <span class="s1">impurity </span><span class="s3">+= </span><span class="s1">fabs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">] - </span><span class="s1">self</span><span class="s3">.</span><span class="s1">node_medians</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]) * </span><span class="s1">w</span>

        <span class="s2">return </span><span class="s1">impurity </span><span class="s3">/ (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">void children_impurity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t</span><span class="s3">* </span><span class="s1">p_impurity_left</span><span class="s3">,</span>
                                <span class="s1">float64_t</span><span class="s3">* </span><span class="s1">p_impurity_right</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Evaluate the impurity in children nodes. 
 
        i.e. the impurity of the left child (sample_indices[start:pos]) and the 
        impurity the right child (sample_indices[pos:end]). 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">const float64_t</span><span class="s3">[:] </span><span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_weight</span>
        <span class="s2">cdef </span><span class="s1">const intp_t</span><span class="s3">[:] </span><span class="s1">sample_indices </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_indices</span>

        <span class="s2">cdef </span><span class="s1">intp_t start </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span>
        <span class="s2">cdef </span><span class="s1">intp_t pos </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pos</span>
        <span class="s2">cdef </span><span class="s1">intp_t end </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span>

        <span class="s2">cdef </span><span class="s1">intp_t i</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span>
        <span class="s2">cdef </span><span class="s1">float64_t median</span>
        <span class="s2">cdef </span><span class="s1">float64_t w </span><span class="s3">= </span><span class="s4">1.0</span>
        <span class="s2">cdef </span><span class="s1">float64_t impurity_left </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s2">cdef </span><span class="s1">float64_t impurity_right </span><span class="s3">= </span><span class="s4">0.0</span>

        <span class="s2">cdef </span><span class="s1">void</span><span class="s3">** </span><span class="s1">left_child </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">left_child_ptr</span>
        <span class="s2">cdef </span><span class="s1">void</span><span class="s3">** </span><span class="s1">right_child </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">right_child_ptr</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">median </span><span class="s3">= (&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">left_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]).</span><span class="s1">get_median</span><span class="s3">()</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">):</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">sample_indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

                <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">w </span><span class="s3">= </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

                <span class="s1">impurity_left </span><span class="s3">+= </span><span class="s1">fabs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">] - </span><span class="s1">median</span><span class="s3">) * </span><span class="s1">w</span>
        <span class="s1">p_impurity_left</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">impurity_left </span><span class="s3">/ (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">*</span>
                                              <span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">median </span><span class="s3">= (&lt;</span><span class="s1">WeightedMedianCalculator</span><span class="s3">&gt; </span><span class="s1">right_child</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]).</span><span class="s1">get_median</span><span class="s3">()</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">pos</span><span class="s3">, </span><span class="s1">end</span><span class="s3">):</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">sample_indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

                <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">w </span><span class="s3">= </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

                <span class="s1">impurity_right </span><span class="s3">+= </span><span class="s1">fabs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">] - </span><span class="s1">median</span><span class="s3">) * </span><span class="s1">w</span>
        <span class="s1">p_impurity_right</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">impurity_right </span><span class="s3">/ (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">*</span>
                                                <span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">)</span>


<span class="s2">cdef class </span><span class="s1">FriedmanMSE</span><span class="s3">(</span><span class="s1">MSE</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Mean squared error impurity criterion with improvement score by Friedman. 
 
    Uses the formula (35) in Friedman's original Gradient Boosting paper: 
 
        diff = mean_left - mean_right 
        improvement = n_left * n_right * diff^2 / (n_left + n_right) 
    &quot;&quot;&quot;</span>

    <span class="s2">cdef </span><span class="s1">float64_t proxy_impurity_improvement</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Compute a proxy of the impurity reduction. 
 
        This method is used to speed up the search for the best split. 
        It is a proxy quantity such that the split that maximizes this value 
        also maximizes the impurity improvement. It neglects all constant terms 
        of the impurity decrease for a given split. 
 
        The absolute impurity improvement is only computed by the 
        impurity_improvement method once the best split has been found. 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">float64_t total_sum_left </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s2">cdef </span><span class="s1">float64_t total_sum_right </span><span class="s3">= </span><span class="s4">0.0</span>

        <span class="s2">cdef </span><span class="s1">intp_t k</span>
        <span class="s2">cdef </span><span class="s1">float64_t diff </span><span class="s3">= </span><span class="s4">0.0</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">total_sum_left </span><span class="s3">+= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
            <span class="s1">total_sum_right </span><span class="s3">+= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>

        <span class="s1">diff </span><span class="s3">= (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">* </span><span class="s1">total_sum_left </span><span class="s3">-</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">* </span><span class="s1">total_sum_right</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">diff </span><span class="s3">* </span><span class="s1">diff </span><span class="s3">/ (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">float64_t impurity_improvement</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t impurity_parent</span><span class="s3">, </span><span class="s1">float64_t</span>
                                        <span class="s1">impurity_left</span><span class="s3">, </span><span class="s1">float64_t impurity_right</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s0"># Note: none of the arguments are used here</span>
        <span class="s2">cdef </span><span class="s1">float64_t total_sum_left </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s2">cdef </span><span class="s1">float64_t total_sum_right </span><span class="s3">= </span><span class="s4">0.0</span>

        <span class="s2">cdef </span><span class="s1">intp_t k</span>
        <span class="s2">cdef </span><span class="s1">float64_t diff </span><span class="s3">= </span><span class="s4">0.0</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s1">total_sum_left </span><span class="s3">+= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
            <span class="s1">total_sum_right </span><span class="s3">+= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>

        <span class="s1">diff </span><span class="s3">= (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">* </span><span class="s1">total_sum_left </span><span class="s3">-</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">* </span><span class="s1">total_sum_right</span><span class="s3">) / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span>

        <span class="s2">return </span><span class="s3">(</span><span class="s1">diff </span><span class="s3">* </span><span class="s1">diff </span><span class="s3">/ (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">*</span>
                               <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span><span class="s3">))</span>


<span class="s2">cdef class </span><span class="s1">Poisson</span><span class="s3">(</span><span class="s1">RegressionCriterion</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Half Poisson deviance as impurity criterion. 
 
    Poisson deviance = 2/n * sum(y_true * log(y_true/y_pred) + y_pred - y_true) 
 
    Note that the deviance is &gt;= 0, and since we have `y_pred = mean(y_true)` 
    at the leaves, one always has `sum(y_pred - y_true) = 0`. It remains the 
    implemented impurity (factor 2 is skipped): 
        1/n * sum(y_true * log(y_true/y_pred) 
    &quot;&quot;&quot;</span>
    <span class="s0"># FIXME in 1.0:</span>
    <span class="s0"># min_impurity_split with default = 0 forces us to use a non-negative</span>
    <span class="s0"># impurity like the Poisson deviance. Without this restriction, one could</span>
    <span class="s0"># throw away the 'constant' term sum(y_true * log(y_true)) and just use</span>
    <span class="s0"># Poisson loss = - 1/n * sum(y_true * log(y_pred))</span>
    <span class="s0">#              = - 1/n * sum(y_true * log(mean(y_true))</span>
    <span class="s0">#              = - mean(y_true) * log(mean(y_true))</span>
    <span class="s0"># With this trick (used in proxy_impurity_improvement()), as for MSE,</span>
    <span class="s0"># children_impurity would only need to go over left xor right split, not</span>
    <span class="s0"># both. This could be faster.</span>

    <span class="s2">cdef </span><span class="s1">float64_t node_impurity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Evaluate the impurity of the current node. 
 
        Evaluate the Poisson criterion as impurity of the current node, 
        i.e. the impurity of sample_indices[start:end]. The smaller the impurity the 
        better. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">poisson_loss</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_total</span><span class="s3">,</span>
                                 <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">float64_t proxy_impurity_improvement</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Compute a proxy of the impurity reduction. 
 
        This method is used to speed up the search for the best split. 
        It is a proxy quantity such that the split that maximizes this value 
        also maximizes the impurity improvement. It neglects all constant terms 
        of the impurity decrease for a given split. 
 
        The absolute impurity improvement is only computed by the 
        impurity_improvement method once the best split has been found. 
 
        The Poisson proxy is derived from: 
 
              sum_{i left }(y_i * log(y_i / y_pred_L)) 
            + sum_{i right}(y_i * log(y_i / y_pred_R)) 
            = sum(y_i * log(y_i) - n_L * mean_{i left}(y_i) * log(mean_{i left}(y_i)) 
                                 - n_R * mean_{i right}(y_i) * log(mean_{i right}(y_i)) 
 
        Neglecting constant terms, this gives 
 
            - sum{i left }(y_i) * log(mean{i left}(y_i)) 
            - sum{i right}(y_i) * log(mean{i right}(y_i)) 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">intp_t k</span>
        <span class="s2">cdef </span><span class="s1">float64_t proxy_impurity_left </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s2">cdef </span><span class="s1">float64_t proxy_impurity_right </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s2">cdef </span><span class="s1">float64_t y_mean_left </span><span class="s3">= </span><span class="s4">0.</span>
        <span class="s2">cdef </span><span class="s1">float64_t y_mean_right </span><span class="s3">= </span><span class="s4">0.</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] &lt;= </span><span class="s1">EPSILON</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] &lt;= </span><span class="s1">EPSILON</span><span class="s3">):</span>
                <span class="s0"># Poisson loss does not allow non-positive predictions. We</span>
                <span class="s0"># therefore forbid splits that have child nodes with</span>
                <span class="s0"># sum(y_i) &lt;= 0.</span>
                <span class="s0"># Since sum_right = sum_total - sum_left, it can lead to</span>
                <span class="s0"># floating point rounding error and will not give zero. Thus,</span>
                <span class="s0"># we relax the above comparison to sum(y_i) &lt;= EPSILON.</span>
                <span class="s2">return </span><span class="s3">-</span><span class="s1">INFINITY</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">y_mean_left </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left</span>
                <span class="s1">y_mean_right </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] / </span><span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right</span>
                <span class="s1">proxy_impurity_left </span><span class="s3">-= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] * </span><span class="s1">log</span><span class="s3">(</span><span class="s1">y_mean_left</span><span class="s3">)</span>
                <span class="s1">proxy_impurity_right </span><span class="s3">-= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] * </span><span class="s1">log</span><span class="s3">(</span><span class="s1">y_mean_right</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s3">- </span><span class="s1">proxy_impurity_left </span><span class="s3">- </span><span class="s1">proxy_impurity_right</span>

    <span class="s2">cdef </span><span class="s1">void children_impurity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t</span><span class="s3">* </span><span class="s1">impurity_left</span><span class="s3">,</span>
                                <span class="s1">float64_t</span><span class="s3">* </span><span class="s1">impurity_right</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Evaluate the impurity in children nodes. 
 
        i.e. the impurity of the left child (sample_indices[start:pos]) and the 
        impurity of the right child (sample_indices[pos:end]) for Poisson. 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">intp_t start </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span>
        <span class="s2">cdef </span><span class="s1">intp_t pos </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pos</span>
        <span class="s2">cdef </span><span class="s1">intp_t end </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span>

        <span class="s1">impurity_left</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">poisson_loss</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_left</span><span class="s3">,</span>
                                             <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_left</span><span class="s3">)</span>

        <span class="s1">impurity_right</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">poisson_loss</span><span class="s3">(</span><span class="s1">pos</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sum_right</span><span class="s3">,</span>
                                              <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_right</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">inline float64_t poisson_loss</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">intp_t start</span><span class="s3">,</span>
        <span class="s1">intp_t end</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">y_sum</span><span class="s3">,</span>
        <span class="s1">float64_t weight_sum</span>
    <span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Helper function to compute Poisson loss (~deviance) of a given node. 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">y </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span>
        <span class="s2">cdef </span><span class="s1">const float64_t</span><span class="s3">[:] </span><span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_weight</span>
        <span class="s2">cdef </span><span class="s1">const intp_t</span><span class="s3">[:] </span><span class="s1">sample_indices </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sample_indices</span>

        <span class="s2">cdef </span><span class="s1">float64_t y_mean </span><span class="s3">= </span><span class="s4">0.</span>
        <span class="s2">cdef </span><span class="s1">float64_t poisson_loss </span><span class="s3">= </span><span class="s4">0.</span>
        <span class="s2">cdef </span><span class="s1">float64_t w </span><span class="s3">= </span><span class="s4">1.0</span>
        <span class="s2">cdef </span><span class="s1">intp_t i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">p</span>
        <span class="s2">cdef </span><span class="s1">intp_t n_outputs </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_outputs</span>

        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_outputs</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">y_sum</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] &lt;= </span><span class="s1">EPSILON</span><span class="s3">:</span>
                <span class="s0"># y_sum could be computed from the subtraction</span>
                <span class="s0"># sum_right = sum_total - sum_left leading to a potential</span>
                <span class="s0"># floating point rounding error.</span>
                <span class="s0"># Thus, we relax the comparison y_sum &lt;= 0 to</span>
                <span class="s0"># y_sum &lt;= EPSILON.</span>
                <span class="s2">return </span><span class="s1">INFINITY</span>

            <span class="s1">y_mean </span><span class="s3">= </span><span class="s1">y_sum</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] / </span><span class="s1">weight_sum</span>

            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">):</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">sample_indices</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

                <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">w </span><span class="s3">= </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

                <span class="s1">poisson_loss </span><span class="s3">+= </span><span class="s1">w </span><span class="s3">* </span><span class="s1">xlogy</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">], </span><span class="s1">y</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">] / </span><span class="s1">y_mean</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">poisson_loss </span><span class="s3">/ (</span><span class="s1">weight_sum </span><span class="s3">* </span><span class="s1">n_outputs</span><span class="s3">)</span>
</pre>
</body>
</html>