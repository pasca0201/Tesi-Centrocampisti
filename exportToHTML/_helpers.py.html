<html>
<head>
<title>_helpers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_helpers.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Various helper functions which are not part of the spec. 
 
Functions which start with an underscore are for internal use only but helpers 
that are in __all__ are intended as additional helper functions for use by end 
users of the compat library. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span><span class="s3">, </span><span class="s1">Union</span><span class="s3">, </span><span class="s1">Any</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">Device</span>

<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">def </span><span class="s1">is_numpy_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return True if `x` is a NumPy array. 
 
    This function does not import NumPy if it has not already been imported 
    and is therefore cheap to use. 
 
    This also returns True for `ndarray` subclasses and NumPy scalar objects. 
 
    See Also 
    -------- 
 
    array_namespace 
    is_array_api_obj 
    is_cupy_array 
    is_torch_array 
    is_dask_array 
    is_jax_array 
    &quot;&quot;&quot;</span>
    <span class="s4"># Avoid importing NumPy if it isn't already</span>
    <span class="s2">if </span><span class="s5">'numpy' </span><span class="s2">not in </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">:</span>
        <span class="s2">return False</span>

    <span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

    <span class="s4"># TODO: Should we reject ndarray subclasses?</span>
    <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">generic</span><span class="s3">))</span>

<span class="s2">def </span><span class="s1">is_cupy_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return True if `x` is a CuPy array. 
 
    This function does not import CuPy if it has not already been imported 
    and is therefore cheap to use. 
 
    This also returns True for `cupy.ndarray` subclasses and CuPy scalar objects. 
 
    See Also 
    -------- 
 
    array_namespace 
    is_array_api_obj 
    is_numpy_array 
    is_torch_array 
    is_dask_array 
    is_jax_array 
    &quot;&quot;&quot;</span>
    <span class="s4"># Avoid importing NumPy if it isn't already</span>
    <span class="s2">if </span><span class="s5">'cupy' </span><span class="s2">not in </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">:</span>
        <span class="s2">return False</span>

    <span class="s2">import </span><span class="s1">cupy </span><span class="s2">as </span><span class="s1">cp</span>

    <span class="s4"># TODO: Should we reject ndarray subclasses?</span>
    <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, (</span><span class="s1">cp</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">, </span><span class="s1">cp</span><span class="s3">.</span><span class="s1">generic</span><span class="s3">))</span>

<span class="s2">def </span><span class="s1">is_torch_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return True if `x` is a PyTorch tensor. 
 
    This function does not import PyTorch if it has not already been imported 
    and is therefore cheap to use. 
 
    See Also 
    -------- 
 
    array_namespace 
    is_array_api_obj 
    is_numpy_array 
    is_cupy_array 
    is_dask_array 
    is_jax_array 
    &quot;&quot;&quot;</span>
    <span class="s4"># Avoid importing torch if it isn't already</span>
    <span class="s2">if </span><span class="s5">'torch' </span><span class="s2">not in </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">:</span>
        <span class="s2">return False</span>

    <span class="s2">import </span><span class="s1">torch</span>

    <span class="s4"># TODO: Should we reject ndarray subclasses?</span>
    <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">torch</span><span class="s3">.</span><span class="s1">Tensor</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">is_dask_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return True if `x` is a dask.array Array. 
 
    This function does not import dask if it has not already been imported 
    and is therefore cheap to use. 
 
    See Also 
    -------- 
 
    array_namespace 
    is_array_api_obj 
    is_numpy_array 
    is_cupy_array 
    is_torch_array 
    is_jax_array 
    &quot;&quot;&quot;</span>
    <span class="s4"># Avoid importing dask if it isn't already</span>
    <span class="s2">if </span><span class="s5">'dask.array' </span><span class="s2">not in </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">:</span>
        <span class="s2">return False</span>

    <span class="s2">import </span><span class="s1">dask</span><span class="s3">.</span><span class="s1">array</span>

    <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">dask</span><span class="s3">.</span><span class="s1">array</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">is_jax_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return True if `x` is a JAX array. 
 
    This function does not import JAX if it has not already been imported 
    and is therefore cheap to use. 
 
 
    See Also 
    -------- 
 
    array_namespace 
    is_array_api_obj 
    is_numpy_array 
    is_cupy_array 
    is_torch_array 
    is_dask_array 
    &quot;&quot;&quot;</span>
    <span class="s4"># Avoid importing jax if it isn't already</span>
    <span class="s2">if </span><span class="s5">'jax' </span><span class="s2">not in </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">:</span>
        <span class="s2">return False</span>

    <span class="s2">import </span><span class="s1">jax</span>

    <span class="s2">return </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">jax</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">is_array_api_obj</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return True if `x` is an array API compatible array object. 
 
    See Also 
    -------- 
 
    array_namespace 
    is_numpy_array 
    is_cupy_array 
    is_torch_array 
    is_dask_array 
    is_jax_array 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">is_numpy_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s1">\</span>
        <span class="s2">or </span><span class="s1">is_cupy_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s1">\</span>
        <span class="s2">or </span><span class="s1">is_torch_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s1">\</span>
        <span class="s2">or </span><span class="s1">is_dask_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s1">\</span>
        <span class="s2">or </span><span class="s1">is_jax_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s1">\</span>
        <span class="s2">or </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s5">'__array_namespace__'</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">_check_api_version</span><span class="s3">(</span><span class="s1">api_version</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">api_version </span><span class="s3">== </span><span class="s5">'2021.12'</span><span class="s3">:</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s5">&quot;The 2021.12 version of the array API specification was requested but the returned namespace is actually version 2022.12&quot;</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">api_version </span><span class="s2">is not None and </span><span class="s1">api_version </span><span class="s3">!= </span><span class="s5">'2022.12'</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;Only the 2022.12 version of the array API specification is currently supported&quot;</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">array_namespace</span><span class="s3">(*</span><span class="s1">xs</span><span class="s3">, </span><span class="s1">api_version</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">_use_compat</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Get the array API compatible namespace for the arrays `xs`. 
 
    Parameters 
    ---------- 
    xs: arrays 
        one or more arrays. 
 
    api_version: str 
        The newest version of the spec that you need support for (currently 
        the compat library wrapped APIs support v2022.12). 
 
    Returns 
    ------- 
 
    out: namespace 
        The array API compatible namespace corresponding to the arrays in `xs`. 
 
    Raises 
    ------ 
    TypeError 
        If `xs` contains arrays from different array libraries or contains a 
        non-array. 
 
 
    Typical usage is to pass the arguments of a function to 
    `array_namespace()` at the top of a function to get the corresponding 
    array API namespace: 
 
    .. code:: python 
 
       def your_function(x, y): 
           xp = array_api_compat.array_namespace(x, y) 
           # Now use xp as the array library namespace 
           return xp.mean(x, axis=0) + 2*xp.std(y, axis=0) 
 
 
    Wrapped array namespaces can also be imported directly. For example, 
    `array_namespace(np.array(...))` will return `array_api_compat.numpy`. 
    This function will also work for any array library not wrapped by 
    array-api-compat if it explicitly defines `__array_namespace__ 
    &lt;https://data-apis.org/array-api/latest/API_specification/generated/array_api.array.__array_namespace__.html&gt;`__ 
    (the wrapped namespace is always preferred if it exists). 
 
    See Also 
    -------- 
 
    is_array_api_obj 
    is_numpy_array 
    is_cupy_array 
    is_torch_array 
    is_dask_array 
    is_jax_array 
 
    &quot;&quot;&quot;</span>
    <span class="s1">namespaces </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">xs</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">is_numpy_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">_check_api_version</span><span class="s3">(</span><span class="s1">api_version</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">_use_compat</span><span class="s3">:</span>
                <span class="s2">from </span><span class="s3">.. </span><span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">numpy_namespace</span>
                <span class="s1">namespaces</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">numpy_namespace</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
                <span class="s1">namespaces</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">np</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">is_cupy_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">_check_api_version</span><span class="s3">(</span><span class="s1">api_version</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">_use_compat</span><span class="s3">:</span>
                <span class="s2">from </span><span class="s3">.. </span><span class="s2">import </span><span class="s1">cupy </span><span class="s2">as </span><span class="s1">cupy_namespace</span>
                <span class="s1">namespaces</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">cupy_namespace</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">import </span><span class="s1">cupy </span><span class="s2">as </span><span class="s1">cp</span>
                <span class="s1">namespaces</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">cp</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">is_torch_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">_check_api_version</span><span class="s3">(</span><span class="s1">api_version</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">_use_compat</span><span class="s3">:</span>
                <span class="s2">from </span><span class="s3">.. </span><span class="s2">import </span><span class="s1">torch </span><span class="s2">as </span><span class="s1">torch_namespace</span>
                <span class="s1">namespaces</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">torch_namespace</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">import </span><span class="s1">torch</span>
                <span class="s1">namespaces</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">torch</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">is_dask_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">_check_api_version</span><span class="s3">(</span><span class="s1">api_version</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">_use_compat</span><span class="s3">:</span>
                <span class="s2">from </span><span class="s3">..</span><span class="s1">dask </span><span class="s2">import </span><span class="s1">array </span><span class="s2">as </span><span class="s1">dask_namespace</span>
                <span class="s1">namespaces</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">dask_namespace</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">&quot;_use_compat cannot be False if input array is a dask array!&quot;</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">is_jax_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
            <span class="s1">_check_api_version</span><span class="s3">(</span><span class="s1">api_version</span><span class="s3">)</span>
            <span class="s4"># jax.experimental.array_api is already an array namespace. We do</span>
            <span class="s4"># not have a wrapper submodule for it.</span>
            <span class="s2">import </span><span class="s1">jax</span><span class="s3">.</span><span class="s1">experimental</span><span class="s3">.</span><span class="s1">array_api </span><span class="s2">as </span><span class="s1">jnp</span>
            <span class="s1">namespaces</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">jnp</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s5">'__array_namespace__'</span><span class="s3">):</span>
            <span class="s1">namespaces</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">__array_namespace__</span><span class="s3">(</span><span class="s1">api_version</span><span class="s3">=</span><span class="s1">api_version</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s4"># TODO: Support Python scalars?</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">__name__</span><span class="s2">} </span><span class="s5">is not a supported array type&quot;</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">namespaces</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">&quot;Unrecognized array input&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">namespaces</span><span class="s3">) != </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s5">f&quot;Multiple namespaces for array inputs: </span><span class="s2">{</span><span class="s1">namespaces</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s3">)</span>

    <span class="s1">xp</span><span class="s3">, = </span><span class="s1">namespaces</span>

    <span class="s2">return </span><span class="s1">xp</span>

<span class="s4"># backwards compatibility alias</span>
<span class="s1">get_namespace </span><span class="s3">= </span><span class="s1">array_namespace</span>

<span class="s2">def </span><span class="s1">_check_device</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s1">device</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">xp </span><span class="s3">== </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">modules</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">'numpy'</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">device </span><span class="s2">not in </span><span class="s3">[</span><span class="s5">&quot;cpu&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">f&quot;Unsupported device for NumPy: </span><span class="s2">{</span><span class="s1">device</span><span class="s2">!r}</span><span class="s5">&quot;</span><span class="s3">)</span>

<span class="s4"># Placeholder object to represent the dask device</span>
<span class="s4"># when the array backend is not the CPU.</span>
<span class="s4"># (since it is not easy to tell which device a dask array is on)</span>
<span class="s2">class </span><span class="s1">_dask_device</span><span class="s3">:</span>
    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s5">&quot;DASK_DEVICE&quot;</span>

<span class="s1">_DASK_DEVICE </span><span class="s3">= </span><span class="s1">_dask_device</span><span class="s3">()</span>

<span class="s4"># device() is not on numpy.ndarray or dask.array and to_device() is not on numpy.ndarray</span>
<span class="s4"># or cupy.ndarray. They are not included in array objects of this library</span>
<span class="s4"># because this library just reuses the respective ndarray classes without</span>
<span class="s4"># wrapping or subclassing them. These helper functions can be used instead of</span>
<span class="s4"># the wrapper functions for libraries that need to support both NumPy/CuPy and</span>
<span class="s4"># other libraries that use devices.</span>
<span class="s2">def </span><span class="s1">device</span><span class="s3">(</span><span class="s1">x</span><span class="s3">: </span><span class="s1">Array</span><span class="s3">, /) </span><span class="s1">-&gt; Device</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Hardware device the array data resides on. 
 
    This is equivalent to `x.device` according to the `standard 
    &lt;https://data-apis.org/array-api/latest/API_specification/generated/array_api.array.device.html&gt;`__. 
    This helper is included because some array libraries either do not have 
    the `device` attribute or include it with an incompatible API. 
 
    Parameters 
    ---------- 
    x: array 
        array instance from an array API compatible library. 
 
    Returns 
    ------- 
    out: device 
        a ``device`` object (see the `Device Support &lt;https://data-apis.org/array-api/latest/design_topics/device_support.html&gt;`__ 
        section of the array API specification). 
 
    Notes 
    ----- 
 
    For NumPy the device is always `&quot;cpu&quot;`. For Dask, the device is always a 
    special `DASK_DEVICE` object. 
 
    See Also 
    -------- 
 
    to_device : Move array data to a different device. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">is_numpy_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s5">&quot;cpu&quot;</span>
    <span class="s2">elif </span><span class="s1">is_dask_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s4"># Peek at the metadata of the jax array to determine type</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">_meta</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
                <span class="s4"># Must be on CPU since backed by numpy</span>
                <span class="s2">return </span><span class="s5">&quot;cpu&quot;</span>
        <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
            <span class="s2">pass</span>
        <span class="s2">return </span><span class="s1">_DASK_DEVICE</span>
    <span class="s2">elif </span><span class="s1">is_jax_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s4"># JAX has .device() as a method, but it is being deprecated so that it</span>
        <span class="s4"># can become a property, in accordance with the standard. In order for</span>
        <span class="s4"># this function to not break when JAX makes the flip, we check for</span>
        <span class="s4"># both here.</span>
        <span class="s2">if </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">ismethod</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">device</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">device</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">device</span>
    <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">device</span>

<span class="s4"># Based on cupy.array_api.Array.to_device</span>
<span class="s2">def </span><span class="s1">_cupy_to_device</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">device</span><span class="s3">, /, </span><span class="s1">stream</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">import </span><span class="s1">cupy </span><span class="s2">as </span><span class="s1">cp</span>
    <span class="s2">from </span><span class="s1">cupy</span><span class="s3">.</span><span class="s1">cuda </span><span class="s2">import </span><span class="s1">Device </span><span class="s2">as </span><span class="s1">_Device</span>
    <span class="s2">from </span><span class="s1">cupy</span><span class="s3">.</span><span class="s1">cuda </span><span class="s2">import </span><span class="s1">stream </span><span class="s2">as </span><span class="s1">stream_module</span>
    <span class="s2">from </span><span class="s1">cupy_backends</span><span class="s3">.</span><span class="s1">cuda</span><span class="s3">.</span><span class="s1">api </span><span class="s2">import </span><span class="s1">runtime</span>

    <span class="s2">if </span><span class="s1">device </span><span class="s3">== </span><span class="s1">x</span><span class="s3">.</span><span class="s1">device</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">x</span>
    <span class="s2">elif </span><span class="s1">device </span><span class="s3">== </span><span class="s5">&quot;cpu&quot;</span><span class="s3">:</span>
        <span class="s4"># allowing us to use `to_device(x, &quot;cpu&quot;)`</span>
        <span class="s4"># is useful for portable test swapping between</span>
        <span class="s4"># host and device backends</span>
        <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">get</span><span class="s3">()</span>
    <span class="s2">elif not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">device</span><span class="s3">, </span><span class="s1">_Device</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">f&quot;Unsupported device </span><span class="s2">{</span><span class="s1">device</span><span class="s2">!r}</span><span class="s5">&quot;</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s4"># see cupy/cupy#5985 for the reason how we handle device/stream here</span>
        <span class="s1">prev_device </span><span class="s3">= </span><span class="s1">runtime</span><span class="s3">.</span><span class="s1">getDevice</span><span class="s3">()</span>
        <span class="s1">prev_stream</span><span class="s3">: </span><span class="s1">stream_module</span><span class="s3">.</span><span class="s1">Stream </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">stream </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">prev_stream </span><span class="s3">= </span><span class="s1">stream_module</span><span class="s3">.</span><span class="s1">get_current_stream</span><span class="s3">()</span>
            <span class="s4"># stream can be an int as specified in __dlpack__, or a CuPy stream</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
                <span class="s1">stream </span><span class="s3">= </span><span class="s1">cp</span><span class="s3">.</span><span class="s1">cuda</span><span class="s3">.</span><span class="s1">ExternalStream</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">cp</span><span class="s3">.</span><span class="s1">cuda</span><span class="s3">.</span><span class="s1">Stream</span><span class="s3">):</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">'the input stream is not recognized'</span><span class="s3">)</span>
            <span class="s1">stream</span><span class="s3">.</span><span class="s1">use</span><span class="s3">()</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">runtime</span><span class="s3">.</span><span class="s1">setDevice</span><span class="s3">(</span><span class="s1">device</span><span class="s3">.</span><span class="s1">id</span><span class="s3">)</span>
            <span class="s1">arr </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s2">finally</span><span class="s3">:</span>
            <span class="s1">runtime</span><span class="s3">.</span><span class="s1">setDevice</span><span class="s3">(</span><span class="s1">prev_device</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">stream </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">prev_stream</span><span class="s3">.</span><span class="s1">use</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">arr</span>

<span class="s2">def </span><span class="s1">_torch_to_device</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">device</span><span class="s3">, /, </span><span class="s1">stream</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">stream </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>
    <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">to</span><span class="s3">(</span><span class="s1">device</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">to_device</span><span class="s3">(</span><span class="s1">x</span><span class="s3">: </span><span class="s1">Array</span><span class="s3">, </span><span class="s1">device</span><span class="s3">: </span><span class="s1">Device</span><span class="s3">, /, *, </span><span class="s1">stream</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; Array</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Copy the array from the device on which it currently resides to the specified ``device``. 
 
    This is equivalent to `x.to_device(device, stream=stream)` according to 
    the `standard 
    &lt;https://data-apis.org/array-api/latest/API_specification/generated/array_api.array.to_device.html&gt;`__. 
    This helper is included because some array libraries do not have the 
    `to_device` method. 
 
    Parameters 
    ---------- 
 
    x: array 
        array instance from an array API compatible library. 
 
    device: device 
        a ``device`` object (see the `Device Support &lt;https://data-apis.org/array-api/latest/design_topics/device_support.html&gt;`__ 
        section of the array API specification). 
 
    stream: Optional[Union[int, Any]] 
        stream object to use during copy. In addition to the types supported 
        in ``array.__dlpack__``, implementations may choose to support any 
        library-specific stream object with the caveat that any code using 
        such an object would not be portable. 
 
    Returns 
    ------- 
 
    out: array 
        an array with the same data and data type as ``x`` and located on the 
        specified ``device``. 
 
    Notes 
    ----- 
 
    For NumPy, this function effectively does nothing since the only supported 
    device is the CPU. For CuPy, this method supports CuPy CUDA 
    :external+cupy:class:`Device &lt;cupy.cuda.Device&gt;` and 
    :external+cupy:class:`Stream &lt;cupy.cuda.Stream&gt;` objects. For PyTorch, 
    this is the same as :external+torch:meth:`x.to(device) &lt;torch.Tensor.to&gt;` 
    (the ``stream`` argument is not supported in PyTorch). 
 
    See Also 
    -------- 
 
    device : Hardware device the array data resides on. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">is_numpy_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">stream </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;The stream argument to to_device() is not supported&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">device </span><span class="s3">== </span><span class="s5">'cpu'</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">x</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">f&quot;Unsupported device </span><span class="s2">{</span><span class="s1">device</span><span class="s2">!r}</span><span class="s5">&quot;</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">is_cupy_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s4"># cupy does not yet have to_device</span>
        <span class="s2">return </span><span class="s1">_cupy_to_device</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">device</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">is_torch_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">_torch_to_device</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">device</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">is_dask_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">stream </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">&quot;The stream argument to to_device() is not supported&quot;</span><span class="s3">)</span>
        <span class="s4"># TODO: What if our array is on the GPU already?</span>
        <span class="s2">if </span><span class="s1">device </span><span class="s3">== </span><span class="s5">'cpu'</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">x</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">f&quot;Unsupported device </span><span class="s2">{</span><span class="s1">device</span><span class="s2">!r}</span><span class="s5">&quot;</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">is_jax_array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s4"># This import adds to_device to x</span>
        <span class="s2">import </span><span class="s1">jax</span><span class="s3">.</span><span class="s1">experimental</span><span class="s3">.</span><span class="s1">array_api </span><span class="s4"># noqa: F401</span>
        <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">to_device</span><span class="s3">(</span><span class="s1">device</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">to_device</span><span class="s3">(</span><span class="s1">device</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">=</span><span class="s1">stream</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">size</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the total number of elements of x. 
 
    This is equivalent to `x.size` according to the `standard 
    &lt;https://data-apis.org/array-api/latest/API_specification/generated/array_api.array.size.html&gt;`__. 
    This helper is included because PyTorch defines `size` in an 
    :external+torch:meth:`incompatible way &lt;torch.Tensor.size&gt;`. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if None in </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
        <span class="s2">return None</span>
    <span class="s2">return </span><span class="s1">math</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>

<span class="s1">__all__ </span><span class="s3">= [</span>
    <span class="s5">&quot;array_namespace&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;device&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;get_namespace&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;is_array_api_obj&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;is_cupy_array&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;is_dask_array&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;is_jax_array&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;is_numpy_array&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;is_torch_array&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;size&quot;</span><span class="s3">,</span>
    <span class="s5">&quot;to_device&quot;</span><span class="s3">,</span>
<span class="s3">]</span>

<span class="s1">_all_ignore </span><span class="s3">= [</span><span class="s5">'sys'</span><span class="s3">, </span><span class="s5">'math'</span><span class="s3">, </span><span class="s5">'inspect'</span><span class="s3">, </span><span class="s5">'warnings'</span><span class="s3">]</span>
</pre>
</body>
</html>