<html>
<head>
<title>hyp2f1.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #6aab73;}
.s4 { color: #c77dbb;}
.s5 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
hyp2f1.h</font>
</center></td></tr></table>
<pre><span class="s0">/* Translated into C++ by SciPy developers in 2024. 
 * Original header with Copyright information appears below. 
 */</span>

<span class="s0">/*                                                      hyp2f1.c 
 * 
 *      Gauss hypergeometric function   F 
 *                                     2 1 
 * 
 * 
 * SYNOPSIS: 
 * 
 * double a, b, c, x, y, hyp2f1(); 
 * 
 * y = hyp2f1( a, b, c, x ); 
 * 
 * 
 * DESCRIPTION: 
 * 
 * 
 *  hyp2f1( a, b, c, x )  =   F ( a, b; c; x ) 
 *                           2 1 
 * 
 *           inf. 
 *            -   a(a+1)...(a+k) b(b+1)...(b+k)   k+1 
 *   =  1 +   &gt;   -----------------------------  x   . 
 *            -         c(c+1)...(c+k) (k+1)! 
 *          k = 0 
 * 
 *  Cases addressed are 
 *      Tests and escapes for negative integer a, b, or c 
 *      Linear transformation if c - a or c - b negative integer 
 *      Special case c = a or c = b 
 *      Linear transformation for  x near +1 
 *      Transformation for x &lt; -0.5 
 *      Psi function expansion if x &gt; 0.5 and c - a - b integer 
 *      Conditionally, a recurrence on c to make c-a-b &gt; 0 
 * 
 *      x &lt; -1  AMS 15.3.7 transformation applied (Travis Oliphant) 
 *         valid for b,a,c,(b-a) != integer and (c-a),(c-b) != negative integer 
 * 
 * x &gt;= 1 is rejected (unless special cases are present) 
 * 
 * The parameters a, b, c are considered to be integer 
 * valued if they are within 1.0e-14 of the nearest integer 
 * (1.0e-13 for IEEE arithmetic). 
 * 
 * ACCURACY: 
 * 
 * 
 *               Relative error (-1 &lt; x &lt; 1): 
 * arithmetic   domain     # trials      peak         rms 
 *    IEEE      -1,7        230000      1.2e-11     5.2e-14 
 * 
 * Several special cases also tested with a, b, c in 
 * the range -7 to 7. 
 * 
 * ERROR MESSAGES: 
 * 
 * A &quot;partial loss of precision&quot; message is printed if 
 * the internally estimated relative error exceeds 1^-12. 
 * A &quot;singularity&quot; message is printed on overflow or 
 * in cases not addressed (such as x &lt; -1). 
 */</span>

<span class="s0">/* 
 * Cephes Math Library Release 2.8:  June, 2000 
 * Copyright 1984, 1987, 1992, 2000 by Stephen L. Moshier 
 */</span>

<span class="s1">#pragma once</span>

<span class="s2">#include </span><span class="s3">&quot;../config.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;../error.h&quot;</span>

<span class="s2">#include </span><span class="s3">&quot;const.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;gamma.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;psi.h&quot;</span>

<span class="s4">namespace </span><span class="s1">special {</span>
<span class="s4">namespace </span><span class="s1">cephes {</span>

    <span class="s4">namespace </span><span class="s1">detail {</span>
        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">hyp2f1_EPS = </span><span class="s5">1</span><span class="s1">.</span><span class="s5">0</span><span class="s1">e-13;</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">hyp2f1_ETHRESH = </span><span class="s5">1</span><span class="s1">.</span><span class="s5">0</span><span class="s1">e-12;</span>
        <span class="s1">constexpr std::uint64_t hyp2f1_MAXITER = </span><span class="s5">10000</span><span class="s1">;</span>

        <span class="s0">/* hys2f1 and hyp2f1ra depend on each other, so we need this prototype */</span>
        <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s2">double </span><span class="s1">hyp2f1ra(</span><span class="s2">double </span><span class="s1">a, </span><span class="s2">double </span><span class="s1">b, </span><span class="s2">double </span><span class="s1">c, </span><span class="s2">double </span><span class="s1">x, </span><span class="s2">double </span><span class="s1">*loss);</span>

        <span class="s0">/* Defining power series expansion of Gauss hypergeometric function */</span>
        <span class="s0">/* The `loss` parameter estimates loss of significance */</span>
        <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s2">double </span><span class="s1">hys2f1(</span><span class="s2">double </span><span class="s1">a, </span><span class="s2">double </span><span class="s1">b, </span><span class="s2">double </span><span class="s1">c, </span><span class="s2">double </span><span class="s1">x, </span><span class="s2">double </span><span class="s1">*loss) {</span>
            <span class="s2">double </span><span class="s1">f, g, h, k, m, s, u, umax;</span>
            <span class="s1">std::uint64_t i;</span>
            <span class="s2">int </span><span class="s1">ib, intflag = </span><span class="s5">0</span><span class="s1">;</span>

            <span class="s2">if </span><span class="s1">(std::abs(b) &gt; std::abs(a)) {</span>
                <span class="s0">/* Ensure that |a| &gt; |b| ... */</span>
                <span class="s1">f = b;</span>
                <span class="s1">b = a;</span>
                <span class="s1">a = f;</span>
            <span class="s1">}</span>

            <span class="s1">ib = std::round(b);</span>

            <span class="s2">if </span><span class="s1">(std::abs(b - ib) &lt; hyp2f1_EPS &amp;&amp; ib &lt;= </span><span class="s5">0 </span><span class="s1">&amp;&amp; std::abs(b) &lt; std::abs(a)) {</span>
                <span class="s0">/* .. except when `b` is a smaller negative integer */</span>
                <span class="s1">f = b;</span>
                <span class="s1">b = a;</span>
                <span class="s1">a = f;</span>
                <span class="s1">intflag = </span><span class="s5">1</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">((std::abs(a) &gt; std::abs(c) + </span><span class="s5">1 </span><span class="s1">|| intflag) &amp;&amp; std::abs(c - a) &gt; </span><span class="s5">2 </span><span class="s1">&amp;&amp; std::abs(a) &gt; </span><span class="s5">2</span><span class="s1">) {</span>
                <span class="s0">/* |a| &gt;&gt; |c| implies that large cancellation error is to be expected. 
                 * 
                 * We try to reduce it with the recurrence relations 
                 */</span>
                <span class="s2">return </span><span class="s1">hyp2f1ra(a, b, c, x, loss);</span>
            <span class="s1">}</span>

            <span class="s1">i = </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s1">umax = </span><span class="s5">0.0</span><span class="s1">;</span>
            <span class="s1">f = a;</span>
            <span class="s1">g = b;</span>
            <span class="s1">h = c;</span>
            <span class="s1">s = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">u = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">k = </span><span class="s5">0.0</span><span class="s1">;</span>
            <span class="s2">do </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(std::abs(h) &lt; hyp2f1_EPS) {</span>
                    <span class="s1">*loss = </span><span class="s5">1.0</span><span class="s1">;</span>
                    <span class="s2">return </span><span class="s1">std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::infinity();</span>
                <span class="s1">}</span>
                <span class="s1">m = k + </span><span class="s5">1.0</span><span class="s1">;</span>
                <span class="s1">u = u * ((f + k) * (g + k) * x / ((h + k) * m));</span>
                <span class="s1">s += u;</span>
                <span class="s1">k = std::abs(u); </span><span class="s0">/* remember largest term summed */</span>
                <span class="s2">if </span><span class="s1">(k &gt; umax)</span>
                    <span class="s1">umax = k;</span>
                <span class="s1">k = m;</span>
                <span class="s2">if </span><span class="s1">(++i &gt; hyp2f1_MAXITER) { </span><span class="s0">/* should never happen */</span>
                    <span class="s1">*loss = </span><span class="s5">1.0</span><span class="s1">;</span>
                    <span class="s2">return </span><span class="s1">(s);</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">while </span><span class="s1">(s == </span><span class="s5">0 </span><span class="s1">|| std::abs(u / s) &gt; MACHEP);</span>

            <span class="s0">/* return estimated relative error */</span>
            <span class="s1">*loss = (MACHEP * umax) / fabs(s) + (MACHEP * i);</span>

            <span class="s2">return </span><span class="s1">(s);</span>
        <span class="s1">}</span>

        <span class="s0">/* Apply transformations for |x| near 1 then call the power series */</span>
        <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s2">double </span><span class="s1">hyt2f1(</span><span class="s2">double </span><span class="s1">a, </span><span class="s2">double </span><span class="s1">b, </span><span class="s2">double </span><span class="s1">c, </span><span class="s2">double </span><span class="s1">x, </span><span class="s2">double </span><span class="s1">*loss) {</span>
            <span class="s2">double </span><span class="s1">p, q, r, s, t, y, w, d, err, err1;</span>
            <span class="s2">double </span><span class="s1">ax, id, d1, d2, e, y1;</span>
            <span class="s2">int </span><span class="s1">i, aid, sign;</span>

            <span class="s2">int </span><span class="s1">ia, ib, neg_int_a = </span><span class="s5">0</span><span class="s1">, neg_int_b = </span><span class="s5">0</span><span class="s1">;</span>

            <span class="s1">ia = std::round(a);</span>
            <span class="s1">ib = std::round(b);</span>

            <span class="s2">if </span><span class="s1">(a &lt;= </span><span class="s5">0 </span><span class="s1">&amp;&amp; std::abs(a - ia) &lt; hyp2f1_EPS) { </span><span class="s0">/* a is a negative integer */</span>
                <span class="s1">neg_int_a = </span><span class="s5">1</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(b &lt;= </span><span class="s5">0 </span><span class="s1">&amp;&amp; std::abs(b - ib) &lt; hyp2f1_EPS) { </span><span class="s0">/* b is a negative integer */</span>
                <span class="s1">neg_int_b = </span><span class="s5">1</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s1">err = </span><span class="s5">0.0</span><span class="s1">;</span>
            <span class="s1">s = </span><span class="s5">1.0 </span><span class="s1">- x;</span>
            <span class="s2">if </span><span class="s1">(x &lt; -</span><span class="s5">0.5 </span><span class="s1">&amp;&amp; !(neg_int_a || neg_int_b)) {</span>
                <span class="s2">if </span><span class="s1">(b &gt; a)</span>
                    <span class="s1">y = std::pow(s, -a) * hys2f1(a, c - b, c, -x / s, &amp;err);</span>

                <span class="s2">else</span>
                    <span class="s1">y = std::pow(s, -b) * hys2f1(c - a, b, c, -x / s, &amp;err);</span>

                <span class="s2">goto </span><span class="s1">done;</span>
            <span class="s1">}</span>

            <span class="s1">d = c - a - b;</span>
            <span class="s1">id = std::round(d); </span><span class="s0">/* nearest integer to d */</span>

            <span class="s2">if </span><span class="s1">(x &gt; </span><span class="s5">0.9 </span><span class="s1">&amp;&amp; !(neg_int_a || neg_int_b)) {</span>
                <span class="s2">if </span><span class="s1">(std::abs(d - id) &gt; MACHEP) {</span>
                    <span class="s2">int </span><span class="s1">sgngam;</span>

                    <span class="s0">/* test for integer c-a-b */</span>
                    <span class="s0">/* Try the power series first */</span>
                    <span class="s1">y = hys2f1(a, b, c, x, &amp;err);</span>
                    <span class="s2">if </span><span class="s1">(err &lt; hyp2f1_ETHRESH) {</span>
                        <span class="s2">goto </span><span class="s1">done;</span>
                    <span class="s1">}</span>
                    <span class="s0">/* If power series fails, then apply AMS55 #15.3.6 */</span>
                    <span class="s1">q = hys2f1(a, b, </span><span class="s5">1.0 </span><span class="s1">- d, s, &amp;err);</span>
                    <span class="s1">sign = </span><span class="s5">1</span><span class="s1">;</span>
                    <span class="s1">w = lgam_sgn(d, &amp;sgngam);</span>
                    <span class="s1">sign *= sgngam;</span>
                    <span class="s1">w -= lgam_sgn(c - a, &amp;sgngam);</span>
                    <span class="s1">sign *= sgngam;</span>
                    <span class="s1">w -= lgam_sgn(c - b, &amp;sgngam);</span>
                    <span class="s1">sign *= sgngam;</span>
                    <span class="s1">q *= sign * std::exp(w);</span>
                    <span class="s1">r = std::pow(s, d) * hys2f1(c - a, c - b, d + </span><span class="s5">1.0</span><span class="s1">, s, &amp;err1);</span>
                    <span class="s1">sign = </span><span class="s5">1</span><span class="s1">;</span>
                    <span class="s1">w = lgam_sgn(-d, &amp;sgngam);</span>
                    <span class="s1">sign *= sgngam;</span>
                    <span class="s1">w -= lgam_sgn(a, &amp;sgngam);</span>
                    <span class="s1">sign *= sgngam;</span>
                    <span class="s1">w -= lgam_sgn(b, &amp;sgngam);</span>
                    <span class="s1">sign *= sgngam;</span>
                    <span class="s1">r *= sign * std::exp(w);</span>
                    <span class="s1">y = q + r;</span>

                    <span class="s1">q = std::abs(q); </span><span class="s0">/* estimate cancellation error */</span>
                    <span class="s1">r = std::abs(r);</span>
                    <span class="s2">if </span><span class="s1">(q &gt; r) {</span>
                        <span class="s1">r = q;</span>
                    <span class="s1">}</span>
                    <span class="s1">err += err1 + (MACHEP * r) / y;</span>

                    <span class="s1">y *= special::cephes::Gamma(c);</span>
                    <span class="s2">goto </span><span class="s1">done;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s0">/* Psi function expansion, AMS55 #15.3.10, #15.3.11, #15.3.12 
                     * 
                     * Although AMS55 does not explicitly state it, this expansion fails 
                     * for negative integer a or b, since the psi and Gamma functions 
                     * involved have poles. 
                     */</span>

                    <span class="s2">if </span><span class="s1">(id &gt;= </span><span class="s5">0.0</span><span class="s1">) {</span>
                        <span class="s1">e = d;</span>
                        <span class="s1">d1 = d;</span>
                        <span class="s1">d2 = </span><span class="s5">0.0</span><span class="s1">;</span>
                        <span class="s1">aid = id;</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">e = -d;</span>
                        <span class="s1">d1 = </span><span class="s5">0.0</span><span class="s1">;</span>
                        <span class="s1">d2 = d;</span>
                        <span class="s1">aid = -id;</span>
                    <span class="s1">}</span>

                    <span class="s1">ax = std::log(s);</span>

                    <span class="s0">/* sum for t = 0 */</span>
                    <span class="s1">y = special::cephes::psi(</span><span class="s5">1.0</span><span class="s1">) + special::cephes::psi(</span><span class="s5">1.0 </span><span class="s1">+ e) - special::cephes::psi(a + d1) -</span>
                        <span class="s1">special::cephes::psi(b + d1) - ax;</span>
                    <span class="s1">y /= special::cephes::Gamma(e + </span><span class="s5">1.0</span><span class="s1">);</span>

                    <span class="s1">p = (a + d1) * (b + d1) * s / special::cephes::Gamma(e + </span><span class="s5">2.0</span><span class="s1">); </span><span class="s0">/* Poch for t=1 */</span>
                    <span class="s1">t = </span><span class="s5">1.0</span><span class="s1">;</span>
                    <span class="s2">do </span><span class="s1">{</span>
                        <span class="s1">r = special::cephes::psi(</span><span class="s5">1.0 </span><span class="s1">+ t) + special::cephes::psi(</span><span class="s5">1.0 </span><span class="s1">+ t + e) -</span>
                            <span class="s1">special::cephes::psi(a + t + d1) - special::cephes::psi(b + t + d1) - ax;</span>
                        <span class="s1">q = p * r;</span>
                        <span class="s1">y += q;</span>
                        <span class="s1">p *= s * (a + t + d1) / (t + </span><span class="s5">1.0</span><span class="s1">);</span>
                        <span class="s1">p *= (b + t + d1) / (t + </span><span class="s5">1.0 </span><span class="s1">+ e);</span>
                        <span class="s1">t += </span><span class="s5">1.0</span><span class="s1">;</span>
                        <span class="s2">if </span><span class="s1">(t &gt; hyp2f1_MAXITER) { </span><span class="s0">/* should never happen */</span>
                            <span class="s1">set_error(</span><span class="s3">&quot;hyp2f1&quot;</span><span class="s1">, SF_ERROR_SLOW, NULL);</span>
                            <span class="s1">*loss = </span><span class="s5">1.0</span><span class="s1">;</span>
                            <span class="s2">return </span><span class="s1">std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::quiet_NaN();</span>
                        <span class="s1">}</span>
                    <span class="s1">} </span><span class="s2">while </span><span class="s1">(y == </span><span class="s5">0 </span><span class="s1">|| std::abs(q / y) &gt; hyp2f1_EPS);</span>

                    <span class="s2">if </span><span class="s1">(id == </span><span class="s5">0.0</span><span class="s1">) {</span>
                        <span class="s1">y *= special::cephes::Gamma(c) / (special::cephes::Gamma(a) * special::cephes::Gamma(b));</span>
                        <span class="s2">goto </span><span class="s1">psidon;</span>
                    <span class="s1">}</span>

                    <span class="s1">y1 = </span><span class="s5">1.0</span><span class="s1">;</span>

                    <span class="s2">if </span><span class="s1">(aid == </span><span class="s5">1</span><span class="s1">)</span>
                        <span class="s2">goto </span><span class="s1">nosum;</span>

                    <span class="s1">t = </span><span class="s5">0.0</span><span class="s1">;</span>
                    <span class="s1">p = </span><span class="s5">1.0</span><span class="s1">;</span>
                    <span class="s2">for </span><span class="s1">(i = </span><span class="s5">1</span><span class="s1">; i &lt; aid; i++) {</span>
                        <span class="s1">r = </span><span class="s5">1.0 </span><span class="s1">- e + t;</span>
                        <span class="s1">p *= s * (a + t + d2) * (b + t + d2) / r;</span>
                        <span class="s1">t += </span><span class="s5">1.0</span><span class="s1">;</span>
                        <span class="s1">p /= t;</span>
                        <span class="s1">y1 += p;</span>
                    <span class="s1">}</span>
                <span class="s1">nosum:</span>
                    <span class="s1">p = special::cephes::Gamma(c);</span>
                    <span class="s1">y1 *= special::cephes::Gamma(e) * p /</span>
                          <span class="s1">(special::cephes::Gamma(a + d1) * special::cephes::Gamma(b + d1));</span>

                    <span class="s1">y *= p / (special::cephes::Gamma(a + d2) * special::cephes::Gamma(b + d2));</span>
                    <span class="s2">if </span><span class="s1">((aid &amp; </span><span class="s5">1</span><span class="s1">) != </span><span class="s5">0</span><span class="s1">)</span>
                        <span class="s1">y = -y;</span>

                    <span class="s1">q = std::pow(s, id); </span><span class="s0">/* s to the id power */</span>
                    <span class="s2">if </span><span class="s1">(id &gt; </span><span class="s5">0.0</span><span class="s1">)</span>
                        <span class="s1">y *= q;</span>
                    <span class="s2">else</span>
                        <span class="s1">y1 *= q;</span>

                    <span class="s1">y += y1;</span>
                <span class="s1">psidon:</span>
                    <span class="s2">goto </span><span class="s1">done;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s0">/* Use defining power series if no special cases */</span>
            <span class="s1">y = hys2f1(a, b, c, x, &amp;err);</span>

        <span class="s1">done:</span>
            <span class="s1">*loss = err;</span>
            <span class="s2">return </span><span class="s1">(y);</span>
        <span class="s1">}</span>

        <span class="s0">/* 
          15.4.2 Abramowitz &amp; Stegun. 
        */</span>
        <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s2">double </span><span class="s1">hyp2f1_neg_c_equal_bc(</span><span class="s2">double </span><span class="s1">a, </span><span class="s2">double </span><span class="s1">b, </span><span class="s2">double </span><span class="s1">x) {</span>
            <span class="s2">double </span><span class="s1">k;</span>
            <span class="s2">double </span><span class="s1">collector = </span><span class="s5">1</span><span class="s1">;</span>
            <span class="s2">double </span><span class="s1">sum = </span><span class="s5">1</span><span class="s1">;</span>
            <span class="s2">double </span><span class="s1">collector_max = </span><span class="s5">1</span><span class="s1">;</span>

            <span class="s2">if </span><span class="s1">(!(std::abs(b) &lt; </span><span class="s5">1</span><span class="s1">e5)) {</span>
                <span class="s2">return </span><span class="s1">std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::quiet_NaN();</span>
            <span class="s1">}</span>

            <span class="s2">for </span><span class="s1">(k = </span><span class="s5">1</span><span class="s1">; k &lt;= -b; k++) {</span>
                <span class="s1">collector *= (a + k - </span><span class="s5">1</span><span class="s1">) * x / k;</span>
                <span class="s1">collector_max = std::fmax(std::abs(collector), collector_max);</span>
                <span class="s1">sum += collector;</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(</span><span class="s5">1</span><span class="s1">e-16 * (</span><span class="s5">1 </span><span class="s1">+ collector_max / std::abs(sum)) &gt; </span><span class="s5">1</span><span class="s1">e-7) {</span>
                <span class="s2">return </span><span class="s1">std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::quiet_NaN();</span>
            <span class="s1">}</span>

            <span class="s2">return </span><span class="s1">sum;</span>
        <span class="s1">}</span>

        <span class="s0">/* 
         * Evaluate hypergeometric function by two-term recurrence in `a`. 
         * 
         * This avoids some of the loss of precision in the strongly alternating 
         * hypergeometric series, and can be used to reduce the `a` and `b` parameters 
         * to smaller values. 
         * 
         * AMS55 #15.2.10 
         */</span>
        <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s2">double </span><span class="s1">hyp2f1ra(</span><span class="s2">double </span><span class="s1">a, </span><span class="s2">double </span><span class="s1">b, </span><span class="s2">double </span><span class="s1">c, </span><span class="s2">double </span><span class="s1">x, </span><span class="s2">double </span><span class="s1">*loss) {</span>
            <span class="s2">double </span><span class="s1">f2, f1, f0;</span>
            <span class="s2">int </span><span class="s1">n;</span>
            <span class="s2">double </span><span class="s1">t, err, da;</span>

            <span class="s0">/* Don't cross c or zero */</span>
            <span class="s2">if </span><span class="s1">((c &lt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; a &lt;= c) || (c &gt;= </span><span class="s5">0 </span><span class="s1">&amp;&amp; a &gt;= c)) {</span>
                <span class="s1">da = std::round(a - c);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">da = std::round(a);</span>
            <span class="s1">}</span>
            <span class="s1">t = a - da;</span>

            <span class="s1">*loss = </span><span class="s5">0</span><span class="s1">;</span>

            <span class="s1">SPECFUN_ASSERT(da != </span><span class="s5">0</span><span class="s1">);</span>

            <span class="s2">if </span><span class="s1">(std::abs(da) &gt; hyp2f1_MAXITER) {</span>
                <span class="s0">/* Too expensive to compute this value, so give up */</span>
                <span class="s1">set_error(</span><span class="s3">&quot;hyp2f1&quot;</span><span class="s1">, SF_ERROR_NO_RESULT, NULL);</span>
                <span class="s1">*loss = </span><span class="s5">1.0</span><span class="s1">;</span>
                <span class="s2">return </span><span class="s1">std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::quiet_NaN();</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(da &lt; </span><span class="s5">0</span><span class="s1">) {</span>
                <span class="s0">/* Recurse down */</span>
                <span class="s1">f2 = </span><span class="s5">0</span><span class="s1">;</span>
                <span class="s1">f1 = hys2f1(t, b, c, x, &amp;err);</span>
                <span class="s1">*loss += err;</span>
                <span class="s1">f0 = hys2f1(t - </span><span class="s5">1</span><span class="s1">, b, c, x, &amp;err);</span>
                <span class="s1">*loss += err;</span>
                <span class="s1">t -= </span><span class="s5">1</span><span class="s1">;</span>
                <span class="s2">for </span><span class="s1">(n = </span><span class="s5">1</span><span class="s1">; n &lt; -da; ++n) {</span>
                    <span class="s1">f2 = f1;</span>
                    <span class="s1">f1 = f0;</span>
                    <span class="s1">f0 = -(</span><span class="s5">2 </span><span class="s1">* t - c - t * x + b * x) / (c - t) * f1 - t * (x - </span><span class="s5">1</span><span class="s1">) / (c - t) * f2;</span>
                    <span class="s1">t -= </span><span class="s5">1</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s0">/* Recurse up */</span>
                <span class="s1">f2 = </span><span class="s5">0</span><span class="s1">;</span>
                <span class="s1">f1 = hys2f1(t, b, c, x, &amp;err);</span>
                <span class="s1">*loss += err;</span>
                <span class="s1">f0 = hys2f1(t + </span><span class="s5">1</span><span class="s1">, b, c, x, &amp;err);</span>
                <span class="s1">*loss += err;</span>
                <span class="s1">t += </span><span class="s5">1</span><span class="s1">;</span>
                <span class="s2">for </span><span class="s1">(n = </span><span class="s5">1</span><span class="s1">; n &lt; da; ++n) {</span>
                    <span class="s1">f2 = f1;</span>
                    <span class="s1">f1 = f0;</span>
                    <span class="s1">f0 = -((</span><span class="s5">2 </span><span class="s1">* t - c - t * x + b * x) * f1 + (c - t) * f2) / (t * (x - </span><span class="s5">1</span><span class="s1">));</span>
                    <span class="s1">t += </span><span class="s5">1</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>

            <span class="s2">return </span><span class="s1">f0;</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">// namespace detail</span>

    <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s2">double </span><span class="s1">hyp2f1(</span><span class="s2">double </span><span class="s1">a, </span><span class="s2">double </span><span class="s1">b, </span><span class="s2">double </span><span class="s1">c, </span><span class="s2">double </span><span class="s1">x) {</span>
        <span class="s2">double </span><span class="s1">d, d1, d2, e;</span>
        <span class="s2">double </span><span class="s1">p, q, r, s, y, ax;</span>
        <span class="s2">double </span><span class="s1">ia, ib, ic, id, err;</span>
        <span class="s2">double </span><span class="s1">t1;</span>
        <span class="s2">int </span><span class="s1">i, aid;</span>
        <span class="s2">int </span><span class="s1">neg_int_a = </span><span class="s5">0</span><span class="s1">, neg_int_b = </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s2">int </span><span class="s1">neg_int_ca_or_cb = </span><span class="s5">0</span><span class="s1">;</span>

        <span class="s1">err = </span><span class="s5">0.0</span><span class="s1">;</span>
        <span class="s1">ax = std::abs(x);</span>
        <span class="s1">s = </span><span class="s5">1.0 </span><span class="s1">- x;</span>
        <span class="s1">ia = std::round(a); </span><span class="s0">/* nearest integer to a */</span>
        <span class="s1">ib = std::round(b);</span>

        <span class="s2">if </span><span class="s1">(x == </span><span class="s5">0.0</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s5">1.0</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">d = c - a - b;</span>
        <span class="s1">id = std::round(d);</span>

        <span class="s2">if </span><span class="s1">((a == </span><span class="s5">0 </span><span class="s1">|| b == </span><span class="s5">0</span><span class="s1">) &amp;&amp; c != </span><span class="s5">0</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s5">1.0</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(a &lt;= </span><span class="s5">0 </span><span class="s1">&amp;&amp; std::abs(a - ia) &lt; detail::hyp2f1_EPS) { </span><span class="s0">/* a is a negative integer */</span>
            <span class="s1">neg_int_a = </span><span class="s5">1</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(b &lt;= </span><span class="s5">0 </span><span class="s1">&amp;&amp; std::abs(b - ib) &lt; detail::hyp2f1_EPS) { </span><span class="s0">/* b is a negative integer */</span>
            <span class="s1">neg_int_b = </span><span class="s5">1</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(d &lt;= -</span><span class="s5">1 </span><span class="s1">&amp;&amp; !(std::abs(d - id) &gt; detail::hyp2f1_EPS &amp;&amp; s &lt; </span><span class="s5">0</span><span class="s1">) &amp;&amp; !(neg_int_a || neg_int_b)) {</span>
            <span class="s2">return </span><span class="s1">std::pow(s, d) * hyp2f1(c - a, c - b, c, x);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(d &lt;= </span><span class="s5">0 </span><span class="s1">&amp;&amp; x == </span><span class="s5">1 </span><span class="s1">&amp;&amp; !(neg_int_a || neg_int_b))</span>
            <span class="s2">goto </span><span class="s1">hypdiv;</span>

        <span class="s2">if </span><span class="s1">(ax &lt; </span><span class="s5">1.0 </span><span class="s1">|| x == -</span><span class="s5">1.0</span><span class="s1">) {</span>
            <span class="s0">/* 2F1(a,b;b;x) = (1-x)**(-a) */</span>
            <span class="s2">if </span><span class="s1">(std::abs(b - c) &lt; detail::hyp2f1_EPS) { </span><span class="s0">/* b = c */</span>
                <span class="s2">if </span><span class="s1">(neg_int_b) {</span>
                    <span class="s1">y = detail::hyp2f1_neg_c_equal_bc(a, b, x);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">y = std::pow(s, -a); </span><span class="s0">/* s to the -a power */</span>
                <span class="s1">}</span>
                <span class="s2">goto </span><span class="s1">hypdon;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(std::abs(a - c) &lt; detail::hyp2f1_EPS) { </span><span class="s0">/* a = c */</span>
                <span class="s1">y = std::pow(s, -b);                    </span><span class="s0">/* s to the -b power */</span>
                <span class="s2">goto </span><span class="s1">hypdon;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(c &lt;= </span><span class="s5">0.0</span><span class="s1">) {</span>
            <span class="s1">ic = std::round(c);                          </span><span class="s0">/* nearest integer to c */</span>
            <span class="s2">if </span><span class="s1">(std::abs(c - ic) &lt; detail::hyp2f1_EPS) { </span><span class="s0">/* c is a negative integer */</span>
                <span class="s0">/* check if termination before explosion */</span>
                <span class="s2">if </span><span class="s1">(neg_int_a &amp;&amp; (ia &gt; ic))</span>
                    <span class="s2">goto </span><span class="s1">hypok;</span>
                <span class="s2">if </span><span class="s1">(neg_int_b &amp;&amp; (ib &gt; ic))</span>
                    <span class="s2">goto </span><span class="s1">hypok;</span>
                <span class="s2">goto </span><span class="s1">hypdiv;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(neg_int_a || neg_int_b) </span><span class="s0">/* function is a polynomial */</span>
            <span class="s2">goto </span><span class="s1">hypok;</span>

        <span class="s1">t1 = std::abs(b - a);</span>
        <span class="s2">if </span><span class="s1">(x &lt; -</span><span class="s5">2.0 </span><span class="s1">&amp;&amp; std::abs(t1 - round(t1)) &gt; detail::hyp2f1_EPS) {</span>
            <span class="s0">/* This transform has a pole for b-a integer, and 
             * may produce large cancellation errors for |1/x| close 1 
             */</span>
            <span class="s1">p = hyp2f1(a, </span><span class="s5">1 </span><span class="s1">- c + a, </span><span class="s5">1 </span><span class="s1">- b + a, </span><span class="s5">1.0 </span><span class="s1">/ x);</span>
            <span class="s1">q = hyp2f1(b, </span><span class="s5">1 </span><span class="s1">- c + b, </span><span class="s5">1 </span><span class="s1">- a + b, </span><span class="s5">1.0 </span><span class="s1">/ x);</span>
            <span class="s1">p *= std::pow(-x, -a);</span>
            <span class="s1">q *= std::pow(-x, -b);</span>
            <span class="s1">t1 = Gamma(c);</span>
            <span class="s1">s = t1 * Gamma(b - a) / (Gamma(b) * Gamma(c - a));</span>
            <span class="s1">y = t1 * Gamma(a - b) / (Gamma(a) * Gamma(c - b));</span>
            <span class="s2">return </span><span class="s1">s * p + y * q;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(x &lt; -</span><span class="s5">1.0</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(std::abs(a) &lt; std::abs(b)) {</span>
                <span class="s2">return </span><span class="s1">std::pow(s, -a) * hyp2f1(a, c - b, c, x / (x - </span><span class="s5">1</span><span class="s1">));</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">return </span><span class="s1">std::pow(s, -b) * hyp2f1(b, c - a, c, x / (x - </span><span class="s5">1</span><span class="s1">));</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(ax &gt; </span><span class="s5">1.0</span><span class="s1">) </span><span class="s0">/* series diverges  */</span>
            <span class="s2">goto </span><span class="s1">hypdiv;</span>

        <span class="s1">p = c - a;</span>
        <span class="s1">ia = std::round(p);                                         </span><span class="s0">/* nearest integer to c-a */</span>
        <span class="s2">if </span><span class="s1">((ia &lt;= </span><span class="s5">0.0</span><span class="s1">) &amp;&amp; (std::abs(p - ia) &lt; detail::hyp2f1_EPS)) </span><span class="s0">/* negative int c - a */</span>
            <span class="s1">neg_int_ca_or_cb = </span><span class="s5">1</span><span class="s1">;</span>

        <span class="s1">r = c - b;</span>
        <span class="s1">ib = std::round(r);                                         </span><span class="s0">/* nearest integer to c-b */</span>
        <span class="s2">if </span><span class="s1">((ib &lt;= </span><span class="s5">0.0</span><span class="s1">) &amp;&amp; (std::abs(r - ib) &lt; detail::hyp2f1_EPS)) </span><span class="s0">/* negative int c - b */</span>
            <span class="s1">neg_int_ca_or_cb = </span><span class="s5">1</span><span class="s1">;</span>

        <span class="s1">id = std::round(d); </span><span class="s0">/* nearest integer to d */</span>
        <span class="s1">q = std::abs(d - id);</span>

        <span class="s0">/* Thanks to Christian Burger &lt;BURGER@DMRHRZ11.HRZ.Uni-Marburg.DE&gt; 
         * for reporting a bug here.  */</span>
        <span class="s2">if </span><span class="s1">(std::abs(ax - </span><span class="s5">1.0</span><span class="s1">) &lt; detail::hyp2f1_EPS) { </span><span class="s0">/* |x| == 1.0   */</span>
            <span class="s2">if </span><span class="s1">(x &gt; </span><span class="s5">0.0</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(neg_int_ca_or_cb) {</span>
                    <span class="s2">if </span><span class="s1">(d &gt;= </span><span class="s5">0.0</span><span class="s1">)</span>
                        <span class="s2">goto </span><span class="s1">hypf;</span>
                    <span class="s2">else</span>
                        <span class="s2">goto </span><span class="s1">hypdiv;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(d &lt;= </span><span class="s5">0.0</span><span class="s1">)</span>
                    <span class="s2">goto </span><span class="s1">hypdiv;</span>
                <span class="s1">y = Gamma(c) * Gamma(d) / (Gamma(p) * Gamma(r));</span>
                <span class="s2">goto </span><span class="s1">hypdon;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(d &lt;= -</span><span class="s5">1.0</span><span class="s1">)</span>
                <span class="s2">goto </span><span class="s1">hypdiv;</span>
        <span class="s1">}</span>

        <span class="s0">/* Conditionally make d &gt; 0 by recurrence on c 
         * AMS55 #15.2.27 
         */</span>
        <span class="s2">if </span><span class="s1">(d &lt; </span><span class="s5">0.0</span><span class="s1">) {</span>
            <span class="s0">/* Try the power series first */</span>
            <span class="s1">y = detail::hyt2f1(a, b, c, x, &amp;err);</span>
            <span class="s2">if </span><span class="s1">(err &lt; detail::hyp2f1_ETHRESH)</span>
                <span class="s2">goto </span><span class="s1">hypdon;</span>
            <span class="s0">/* Apply the recurrence if power series fails */</span>
            <span class="s1">err = </span><span class="s5">0.0</span><span class="s1">;</span>
            <span class="s1">aid = </span><span class="s5">2 </span><span class="s1">- id;</span>
            <span class="s1">e = c + aid;</span>
            <span class="s1">d2 = hyp2f1(a, b, e, x);</span>
            <span class="s1">d1 = hyp2f1(a, b, e + </span><span class="s5">1.0</span><span class="s1">, x);</span>
            <span class="s1">q = a + b + </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s2">for </span><span class="s1">(i = </span><span class="s5">0</span><span class="s1">; i &lt; aid; i++) {</span>
                <span class="s1">r = e - </span><span class="s5">1.0</span><span class="s1">;</span>
                <span class="s1">y = (e * (r - (</span><span class="s5">2.0 </span><span class="s1">* e - q) * x) * d2 + (e - a) * (e - b) * x * d1) / (e * r * s);</span>
                <span class="s1">e = r;</span>
                <span class="s1">d1 = d2;</span>
                <span class="s1">d2 = y;</span>
            <span class="s1">}</span>
            <span class="s2">goto </span><span class="s1">hypdon;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(neg_int_ca_or_cb) {</span>
            <span class="s2">goto </span><span class="s1">hypf; </span><span class="s0">/* negative integer c-a or c-b */</span>
        <span class="s1">}</span>

    <span class="s1">hypok:</span>
        <span class="s1">y = detail::hyt2f1(a, b, c, x, &amp;err);</span>

    <span class="s1">hypdon:</span>
        <span class="s2">if </span><span class="s1">(err &gt; detail::hyp2f1_ETHRESH) {</span>
            <span class="s1">set_error(</span><span class="s3">&quot;hyp2f1&quot;</span><span class="s1">, SF_ERROR_LOSS, NULL);</span>
            <span class="s0">/*      printf( &quot;Estimated err = %.2e\n&quot;, err ); */</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">(y);</span>

        <span class="s0">/* The transformation for c-a or c-b negative integer 
         * AMS55 #15.3.3 
         */</span>
    <span class="s1">hypf:</span>
        <span class="s1">y = std::pow(s, d) * detail::hys2f1(c - a, c - b, c, x, &amp;err);</span>
        <span class="s2">goto </span><span class="s1">hypdon;</span>

        <span class="s0">/* The alarm exit */</span>
    <span class="s1">hypdiv:</span>
        <span class="s1">set_error(</span><span class="s3">&quot;hyp2f1&quot;</span><span class="s1">, SF_ERROR_OVERFLOW, NULL);</span>
        <span class="s2">return </span><span class="s1">std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::infinity();</span>
    <span class="s1">}</span>

<span class="s1">} </span><span class="s0">// namespace cephes</span>
<span class="s1">} </span><span class="s0">// namespace special</span>
</pre>
</body>
</html>