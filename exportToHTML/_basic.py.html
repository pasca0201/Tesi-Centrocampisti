<html>
<head>
<title>_basic.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_basic.py</font>
</center></td></tr></table>
<pre><span class="s0">#</span>
<span class="s0"># Author:  Travis Oliphant, 2002</span>
<span class="s0">#</span>

<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">defaultdict</span>
<span class="s2">from </span><span class="s1">heapq </span><span class="s2">import </span><span class="s1">heapify</span><span class="s3">, </span><span class="s1">heappop</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s3">(</span><span class="s1">pi</span><span class="s3">, </span><span class="s1">asarray</span><span class="s3">, </span><span class="s1">floor</span><span class="s3">, </span><span class="s1">isscalar</span><span class="s3">, </span><span class="s1">sqrt</span><span class="s3">, </span><span class="s1">where</span><span class="s3">,</span>
                   <span class="s1">sin</span><span class="s3">, </span><span class="s1">place</span><span class="s3">, </span><span class="s1">issubdtype</span><span class="s3">, </span><span class="s1">extract</span><span class="s3">, </span><span class="s1">inexact</span><span class="s3">, </span><span class="s1">nan</span><span class="s3">, </span><span class="s1">zeros</span><span class="s3">, </span><span class="s1">sinc</span><span class="s3">)</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_ufuncs</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_ufuncs </span><span class="s2">import </span><span class="s3">(</span><span class="s1">mathieu_a</span><span class="s3">, </span><span class="s1">mathieu_b</span><span class="s3">, </span><span class="s1">iv</span><span class="s3">, </span><span class="s1">jv</span><span class="s3">, </span><span class="s1">gamma</span><span class="s3">,</span>
                      <span class="s1">psi</span><span class="s3">, </span><span class="s1">hankel1</span><span class="s3">, </span><span class="s1">hankel2</span><span class="s3">, </span><span class="s1">yv</span><span class="s3">, </span><span class="s1">kv</span><span class="s3">, </span><span class="s1">poch</span><span class="s3">, </span><span class="s1">binom</span><span class="s3">,</span>
                      <span class="s1">_stirling2_inexact</span><span class="s3">)</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_gufuncs </span><span class="s2">import </span><span class="s3">(</span><span class="s1">_lpn</span><span class="s3">, </span><span class="s1">_lpmn</span><span class="s3">, </span><span class="s1">_clpmn</span><span class="s3">, </span><span class="s1">_lqn</span><span class="s3">, </span><span class="s1">_lqmn</span><span class="s3">, </span><span class="s1">_rctj</span><span class="s3">, </span><span class="s1">_rcty</span><span class="s3">,</span>
                       <span class="s1">_sph_harm_all </span><span class="s2">as </span><span class="s1">_sph_harm_all_gufunc</span><span class="s3">)</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_specfun</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_comb </span><span class="s2">import </span><span class="s1">_comb_int</span>


<span class="s1">__all__ </span><span class="s3">= [</span>
    <span class="s4">'ai_zeros'</span><span class="s3">,</span>
    <span class="s4">'assoc_laguerre'</span><span class="s3">,</span>
    <span class="s4">'bei_zeros'</span><span class="s3">,</span>
    <span class="s4">'beip_zeros'</span><span class="s3">,</span>
    <span class="s4">'ber_zeros'</span><span class="s3">,</span>
    <span class="s4">'bernoulli'</span><span class="s3">,</span>
    <span class="s4">'berp_zeros'</span><span class="s3">,</span>
    <span class="s4">'bi_zeros'</span><span class="s3">,</span>
    <span class="s4">'clpmn'</span><span class="s3">,</span>
    <span class="s4">'comb'</span><span class="s3">,</span>
    <span class="s4">'digamma'</span><span class="s3">,</span>
    <span class="s4">'diric'</span><span class="s3">,</span>
    <span class="s4">'erf_zeros'</span><span class="s3">,</span>
    <span class="s4">'euler'</span><span class="s3">,</span>
    <span class="s4">'factorial'</span><span class="s3">,</span>
    <span class="s4">'factorial2'</span><span class="s3">,</span>
    <span class="s4">'factorialk'</span><span class="s3">,</span>
    <span class="s4">'fresnel_zeros'</span><span class="s3">,</span>
    <span class="s4">'fresnelc_zeros'</span><span class="s3">,</span>
    <span class="s4">'fresnels_zeros'</span><span class="s3">,</span>
    <span class="s4">'h1vp'</span><span class="s3">,</span>
    <span class="s4">'h2vp'</span><span class="s3">,</span>
    <span class="s4">'ivp'</span><span class="s3">,</span>
    <span class="s4">'jn_zeros'</span><span class="s3">,</span>
    <span class="s4">'jnjnp_zeros'</span><span class="s3">,</span>
    <span class="s4">'jnp_zeros'</span><span class="s3">,</span>
    <span class="s4">'jnyn_zeros'</span><span class="s3">,</span>
    <span class="s4">'jvp'</span><span class="s3">,</span>
    <span class="s4">'kei_zeros'</span><span class="s3">,</span>
    <span class="s4">'keip_zeros'</span><span class="s3">,</span>
    <span class="s4">'kelvin_zeros'</span><span class="s3">,</span>
    <span class="s4">'ker_zeros'</span><span class="s3">,</span>
    <span class="s4">'kerp_zeros'</span><span class="s3">,</span>
    <span class="s4">'kvp'</span><span class="s3">,</span>
    <span class="s4">'lmbda'</span><span class="s3">,</span>
    <span class="s4">'lpmn'</span><span class="s3">,</span>
    <span class="s4">'lpn'</span><span class="s3">,</span>
    <span class="s4">'lqmn'</span><span class="s3">,</span>
    <span class="s4">'lqn'</span><span class="s3">,</span>
    <span class="s4">'mathieu_even_coef'</span><span class="s3">,</span>
    <span class="s4">'mathieu_odd_coef'</span><span class="s3">,</span>
    <span class="s4">'obl_cv_seq'</span><span class="s3">,</span>
    <span class="s4">'pbdn_seq'</span><span class="s3">,</span>
    <span class="s4">'pbdv_seq'</span><span class="s3">,</span>
    <span class="s4">'pbvv_seq'</span><span class="s3">,</span>
    <span class="s4">'perm'</span><span class="s3">,</span>
    <span class="s4">'polygamma'</span><span class="s3">,</span>
    <span class="s4">'pro_cv_seq'</span><span class="s3">,</span>
    <span class="s4">'riccati_jn'</span><span class="s3">,</span>
    <span class="s4">'riccati_yn'</span><span class="s3">,</span>
    <span class="s4">'sinc'</span><span class="s3">,</span>
    <span class="s4">'stirling2'</span><span class="s3">,</span>
    <span class="s4">'y0_zeros'</span><span class="s3">,</span>
    <span class="s4">'y1_zeros'</span><span class="s3">,</span>
    <span class="s4">'y1p_zeros'</span><span class="s3">,</span>
    <span class="s4">'yn_zeros'</span><span class="s3">,</span>
    <span class="s4">'ynp_zeros'</span><span class="s3">,</span>
    <span class="s4">'yvp'</span><span class="s3">,</span>
    <span class="s4">'zeta'</span>
<span class="s3">]</span>


<span class="s0"># mapping k to last n such that factorialk(n, k) &lt; np.iinfo(np.int64).max</span>
<span class="s1">_FACTORIALK_LIMITS_64BITS </span><span class="s3">= {</span><span class="s5">1</span><span class="s3">: </span><span class="s5">20</span><span class="s3">, </span><span class="s5">2</span><span class="s3">: </span><span class="s5">33</span><span class="s3">, </span><span class="s5">3</span><span class="s3">: </span><span class="s5">44</span><span class="s3">, </span><span class="s5">4</span><span class="s3">: </span><span class="s5">54</span><span class="s3">, </span><span class="s5">5</span><span class="s3">: </span><span class="s5">65</span><span class="s3">,</span>
                             <span class="s5">6</span><span class="s3">: </span><span class="s5">74</span><span class="s3">, </span><span class="s5">7</span><span class="s3">: </span><span class="s5">84</span><span class="s3">, </span><span class="s5">8</span><span class="s3">: </span><span class="s5">93</span><span class="s3">, </span><span class="s5">9</span><span class="s3">: </span><span class="s5">101</span><span class="s3">}</span>
<span class="s0"># mapping k to last n such that factorialk(n, k) &lt; np.iinfo(np.int32).max</span>
<span class="s1">_FACTORIALK_LIMITS_32BITS </span><span class="s3">= {</span><span class="s5">1</span><span class="s3">: </span><span class="s5">12</span><span class="s3">, </span><span class="s5">2</span><span class="s3">: </span><span class="s5">19</span><span class="s3">, </span><span class="s5">3</span><span class="s3">: </span><span class="s5">25</span><span class="s3">, </span><span class="s5">4</span><span class="s3">: </span><span class="s5">31</span><span class="s3">, </span><span class="s5">5</span><span class="s3">: </span><span class="s5">37</span><span class="s3">,</span>
                             <span class="s5">6</span><span class="s3">: </span><span class="s5">43</span><span class="s3">, </span><span class="s5">7</span><span class="s3">: </span><span class="s5">47</span><span class="s3">, </span><span class="s5">8</span><span class="s3">: </span><span class="s5">51</span><span class="s3">, </span><span class="s5">9</span><span class="s3">: </span><span class="s5">56</span><span class="s3">}</span>


<span class="s2">def </span><span class="s1">_nonneg_int_or_fail</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">var_name</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">strict</span><span class="s3">:</span>
            <span class="s0"># Raises an exception if float</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">n </span><span class="s3">== </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">()</span>
    <span class="s2">except </span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">TypeError</span><span class="s3">) </span><span class="s2">as </span><span class="s1">err</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">err</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">var_name</span><span class="s2">} </span><span class="s4">must be a non-negative integer&quot;</span><span class="s3">) </span><span class="s2">from </span><span class="s1">err</span>
    <span class="s2">return </span><span class="s1">n</span>


<span class="s2">def </span><span class="s1">diric</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Periodic sinc function, also called the Dirichlet function. 
 
    The Dirichlet function is defined as:: 
 
        diric(x, n) = sin(x * n/2) / (n * sin(x / 2)), 
 
    where `n` is a positive integer. 
 
    Parameters 
    ---------- 
    x : array_like 
        Input data 
    n : int 
        Integer defining the periodicity. 
 
    Returns 
    ------- 
    diric : ndarray 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import special 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; x = np.linspace(-8*np.pi, 8*np.pi, num=201) 
    &gt;&gt;&gt; plt.figure(figsize=(8, 8)); 
    &gt;&gt;&gt; for idx, n in enumerate([2, 3, 4, 9]): 
    ...     plt.subplot(2, 2, idx+1) 
    ...     plt.plot(x, special.diric(x, n)) 
    ...     plt.title('diric, n={}'.format(n)) 
    &gt;&gt;&gt; plt.show() 
 
    The following example demonstrates that `diric` gives the magnitudes 
    (modulo the sign and scaling) of the Fourier coefficients of a 
    rectangular pulse. 
 
    Suppress output of values that are effectively 0: 
 
    &gt;&gt;&gt; np.set_printoptions(suppress=True) 
 
    Create a signal `x` of length `m` with `k` ones: 
 
    &gt;&gt;&gt; m = 8 
    &gt;&gt;&gt; k = 3 
    &gt;&gt;&gt; x = np.zeros(m) 
    &gt;&gt;&gt; x[:k] = 1 
 
    Use the FFT to compute the Fourier transform of `x`, and 
    inspect the magnitudes of the coefficients: 
 
    &gt;&gt;&gt; np.abs(np.fft.fft(x)) 
    array([ 3.        ,  2.41421356,  1.        ,  0.41421356,  1.        , 
            0.41421356,  1.        ,  2.41421356]) 
 
    Now find the same values (up to sign) using `diric`. We multiply 
    by `k` to account for the different scaling conventions of 
    `numpy.fft.fft` and `diric`: 
 
    &gt;&gt;&gt; theta = np.linspace(0, 2*np.pi, m, endpoint=False) 
    &gt;&gt;&gt; k * special.diric(theta, k) 
    array([ 3.        ,  2.41421356,  1.        , -0.41421356, -1.        , 
           -0.41421356,  1.        ,  2.41421356]) 
    &quot;&quot;&quot;</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">n </span><span class="s3">+ (</span><span class="s1">x</span><span class="s3">-</span><span class="s1">x</span><span class="s3">))</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x </span><span class="s3">+ (</span><span class="s1">n</span><span class="s3">-</span><span class="s1">n</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">inexact</span><span class="s3">):</span>
        <span class="s1">ytype </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">ytype </span><span class="s3">= </span><span class="s1">float</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">ytype</span><span class="s3">)</span>

    <span class="s0"># empirical minval for 32, 64 or 128 bit float computations</span>
    <span class="s0"># where sin(x/2) &lt; minval, result is fixed at +1 or -1</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">ytype</span><span class="s3">).</span><span class="s1">eps </span><span class="s3">&lt; </span><span class="s5">1e-18</span><span class="s3">:</span>
        <span class="s1">minval </span><span class="s3">= </span><span class="s5">1e-11</span>
    <span class="s2">elif </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">ytype</span><span class="s3">).</span><span class="s1">eps </span><span class="s3">&lt; </span><span class="s5">1e-15</span><span class="s3">:</span>
        <span class="s1">minval </span><span class="s3">= </span><span class="s5">1e-7</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">minval </span><span class="s3">= </span><span class="s5">1e-3</span>

    <span class="s1">mask1 </span><span class="s3">= (</span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">) | (</span><span class="s1">n </span><span class="s3">!= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">n</span><span class="s3">))</span>
    <span class="s1">place</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">mask1</span><span class="s3">, </span><span class="s1">nan</span><span class="s3">)</span>

    <span class="s1">x </span><span class="s3">= </span><span class="s1">x </span><span class="s3">/ </span><span class="s5">2</span>
    <span class="s1">denom </span><span class="s3">= </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">mask2 </span><span class="s3">= (</span><span class="s5">1</span><span class="s3">-</span><span class="s1">mask1</span><span class="s3">) &amp; (</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">denom</span><span class="s3">) &lt; </span><span class="s1">minval</span><span class="s3">)</span>
    <span class="s1">xsub </span><span class="s3">= </span><span class="s1">extract</span><span class="s3">(</span><span class="s1">mask2</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">nsub </span><span class="s3">= </span><span class="s1">extract</span><span class="s3">(</span><span class="s1">mask2</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">zsub </span><span class="s3">= </span><span class="s1">xsub </span><span class="s3">/ </span><span class="s1">pi</span>
    <span class="s1">place</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">mask2</span><span class="s3">, </span><span class="s1">pow</span><span class="s3">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">zsub</span><span class="s3">)*(</span><span class="s1">nsub</span><span class="s3">-</span><span class="s5">1</span><span class="s3">)))</span>

    <span class="s1">mask </span><span class="s3">= (</span><span class="s5">1</span><span class="s3">-</span><span class="s1">mask1</span><span class="s3">) &amp; (</span><span class="s5">1</span><span class="s3">-</span><span class="s1">mask2</span><span class="s3">)</span>
    <span class="s1">xsub </span><span class="s3">= </span><span class="s1">extract</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">nsub </span><span class="s3">= </span><span class="s1">extract</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">dsub </span><span class="s3">= </span><span class="s1">extract</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">denom</span><span class="s3">)</span>
    <span class="s1">place</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">nsub</span><span class="s3">*</span><span class="s1">xsub</span><span class="s3">)/(</span><span class="s1">nsub</span><span class="s3">*</span><span class="s1">dsub</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">y</span>


<span class="s2">def </span><span class="s1">jnjnp_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute zeros of integer-order Bessel functions Jn and Jn'. 
 
    Results are arranged in order of the magnitudes of the zeros. 
 
    Parameters 
    ---------- 
    nt : int 
        Number (&lt;=1200) of zeros to compute 
 
    Returns 
    ------- 
    zo[l-1] : ndarray 
        Value of the lth zero of Jn(x) and Jn'(x). Of length `nt`. 
    n[l-1] : ndarray 
        Order of the Jn(x) or Jn'(x) associated with lth zero. Of length `nt`. 
    m[l-1] : ndarray 
        Serial number of the zeros of Jn(x) or Jn'(x) associated 
        with lth zero. Of length `nt`. 
    t[l-1] : ndarray 
        0 if lth zero in zo is zero of Jn(x), 1 if it is a zero of Jn'(x). Of 
        length `nt`. 
 
    See Also 
    -------- 
    jn_zeros, jnp_zeros : to get separated arrays of zeros. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 5. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&gt; </span><span class="s5">1200</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Number must be integer &lt;= 1200.&quot;</span><span class="s3">)</span>
    <span class="s1">nt </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">)</span>
    <span class="s1">n</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">zo </span><span class="s3">= </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">jdzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">zo</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:</span><span class="s1">nt</span><span class="s3">+</span><span class="s5">1</span><span class="s3">], </span><span class="s1">n</span><span class="s3">[:</span><span class="s1">nt</span><span class="s3">], </span><span class="s1">m</span><span class="s3">[:</span><span class="s1">nt</span><span class="s3">], </span><span class="s1">t</span><span class="s3">[:</span><span class="s1">nt</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">jnyn_zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute nt zeros of Bessel functions Jn(x), Jn'(x), Yn(x), and Yn'(x). 
 
    Returns 4 arrays of length `nt`, corresponding to the first `nt` 
    zeros of Jn(x), Jn'(x), Yn(x), and Yn'(x), respectively. The zeros 
    are returned in ascending order. 
 
    Parameters 
    ---------- 
    n : int 
        Order of the Bessel functions 
    nt : int 
        Number (&lt;=1200) of zeros to compute 
 
    Returns 
    ------- 
    Jn : ndarray 
        First `nt` zeros of Jn 
    Jnp : ndarray 
        First `nt` zeros of Jn' 
    Yn : ndarray 
        First `nt` zeros of Yn 
    Ynp : ndarray 
        First `nt` zeros of Yn' 
 
    See Also 
    -------- 
    jn_zeros, jnp_zeros, yn_zeros, ynp_zeros 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 5. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    Examples 
    -------- 
    Compute the first three roots of :math:`J_1`, :math:`J_1'`, 
    :math:`Y_1` and :math:`Y_1'`. 
 
    &gt;&gt;&gt; from scipy.special import jnyn_zeros 
    &gt;&gt;&gt; jn_roots, jnp_roots, yn_roots, ynp_roots = jnyn_zeros(1, 3) 
    &gt;&gt;&gt; jn_roots, yn_roots 
    (array([ 3.83170597,  7.01558667, 10.17346814]), 
     array([2.19714133, 5.42968104, 8.59600587])) 
 
    Plot :math:`J_1`, :math:`J_1'`, :math:`Y_1`, :math:`Y_1'` and their roots. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.special import jnyn_zeros, jvp, jn, yvp, yn 
    &gt;&gt;&gt; jn_roots, jnp_roots, yn_roots, ynp_roots = jnyn_zeros(1, 3) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; xmax= 11 
    &gt;&gt;&gt; x = np.linspace(0, xmax) 
    &gt;&gt;&gt; x[0] += 1e-15 
    &gt;&gt;&gt; ax.plot(x, jn(1, x), label=r&quot;$J_1$&quot;, c='r') 
    &gt;&gt;&gt; ax.plot(x, jvp(1, x, 1), label=r&quot;$J_1'$&quot;, c='b') 
    &gt;&gt;&gt; ax.plot(x, yn(1, x), label=r&quot;$Y_1$&quot;, c='y') 
    &gt;&gt;&gt; ax.plot(x, yvp(1, x, 1), label=r&quot;$Y_1'$&quot;, c='c') 
    &gt;&gt;&gt; zeros = np.zeros((3, )) 
    &gt;&gt;&gt; ax.scatter(jn_roots, zeros, s=30, c='r', zorder=5, 
    ...            label=r&quot;$J_1$ roots&quot;) 
    &gt;&gt;&gt; ax.scatter(jnp_roots, zeros, s=30, c='b', zorder=5, 
    ...            label=r&quot;$J_1'$ roots&quot;) 
    &gt;&gt;&gt; ax.scatter(yn_roots, zeros, s=30, c='y', zorder=5, 
    ...            label=r&quot;$Y_1$ roots&quot;) 
    &gt;&gt;&gt; ax.scatter(ynp_roots, zeros, s=30, c='c', zorder=5, 
    ...            label=r&quot;$Y_1'$ roots&quot;) 
    &gt;&gt;&gt; ax.hlines(0, 0, xmax, color='k') 
    &gt;&gt;&gt; ax.set_ylim(-0.6, 0.6) 
    &gt;&gt;&gt; ax.set_xlim(0, xmax) 
    &gt;&gt;&gt; ax.legend(ncol=2, bbox_to_anchor=(1., 0.75)) 
    &gt;&gt;&gt; plt.tight_layout() 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Arguments must be scalars.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) != </span><span class="s1">n</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Arguments must be integers.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;nt &gt; 0&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">jyzo</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">n</span><span class="s3">), </span><span class="s1">nt</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">jn_zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot;Compute zeros of integer-order Bessel functions Jn. 
 
    Compute `nt` zeros of the Bessel functions :math:`J_n(x)` on the 
    interval :math:`(0, \infty)`. The zeros are returned in ascending 
    order. Note that this interval excludes the zero at :math:`x = 0` 
    that exists for :math:`n &gt; 0`. 
 
    Parameters 
    ---------- 
    n : int 
        Order of Bessel function 
    nt : int 
        Number of zeros to return 
 
    Returns 
    ------- 
    ndarray 
        First `nt` zeros of the Bessel function. 
 
    See Also 
    -------- 
    jv: Real-order Bessel functions of the first kind 
    jnp_zeros: Zeros of :math:`Jn'` 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 5. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    Examples 
    -------- 
    Compute the first four positive roots of :math:`J_3`. 
 
    &gt;&gt;&gt; from scipy.special import jn_zeros 
    &gt;&gt;&gt; jn_zeros(3, 4) 
    array([ 6.3801619 ,  9.76102313, 13.01520072, 16.22346616]) 
 
    Plot :math:`J_3` and its first four positive roots. Note 
    that the root located at 0 is not returned by `jn_zeros`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.special import jn, jn_zeros 
    &gt;&gt;&gt; j3_roots = jn_zeros(3, 4) 
    &gt;&gt;&gt; xmax = 18 
    &gt;&gt;&gt; xmin = -1 
    &gt;&gt;&gt; x = np.linspace(xmin, xmax, 500) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(x, jn(3, x), label=r'$J_3$') 
    &gt;&gt;&gt; ax.scatter(j3_roots, np.zeros((4, )), s=30, c='r', 
    ...            label=r&quot;$J_3$_Zeros&quot;, zorder=5) 
    &gt;&gt;&gt; ax.scatter(0, 0, s=30, c='k', 
    ...            label=r&quot;Root at 0&quot;, zorder=5) 
    &gt;&gt;&gt; ax.hlines(0, 0, xmax, color='k') 
    &gt;&gt;&gt; ax.set_xlim(xmin, xmax) 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">jnyn_zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">jnp_zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot;Compute zeros of integer-order Bessel function derivatives Jn'. 
 
    Compute `nt` zeros of the functions :math:`J_n'(x)` on the 
    interval :math:`(0, \infty)`. The zeros are returned in ascending 
    order. Note that this interval excludes the zero at :math:`x = 0` 
    that exists for :math:`n &gt; 1`. 
 
    Parameters 
    ---------- 
    n : int 
        Order of Bessel function 
    nt : int 
        Number of zeros to return 
 
    Returns 
    ------- 
    ndarray 
        First `nt` zeros of the Bessel function. 
 
    See Also 
    -------- 
    jvp: Derivatives of integer-order Bessel functions of the first kind 
    jv: Float-order Bessel functions of the first kind 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 5. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    Examples 
    -------- 
    Compute the first four roots of :math:`J_2'`. 
 
    &gt;&gt;&gt; from scipy.special import jnp_zeros 
    &gt;&gt;&gt; jnp_zeros(2, 4) 
    array([ 3.05423693,  6.70613319,  9.96946782, 13.17037086]) 
 
    As `jnp_zeros` yields the roots of :math:`J_n'`, it can be used to 
    compute the locations of the peaks of :math:`J_n`. Plot 
    :math:`J_2`, :math:`J_2'` and the locations of the roots of :math:`J_2'`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.special import jn, jnp_zeros, jvp 
    &gt;&gt;&gt; j2_roots = jnp_zeros(2, 4) 
    &gt;&gt;&gt; xmax = 15 
    &gt;&gt;&gt; x = np.linspace(0, xmax, 500) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(x, jn(2, x), label=r'$J_2$') 
    &gt;&gt;&gt; ax.plot(x, jvp(2, x, 1), label=r&quot;$J_2'$&quot;) 
    &gt;&gt;&gt; ax.hlines(0, 0, xmax, color='k') 
    &gt;&gt;&gt; ax.scatter(j2_roots, np.zeros((4, )), s=30, c='r', 
    ...            label=r&quot;Roots of $J_2'$&quot;, zorder=5) 
    &gt;&gt;&gt; ax.set_ylim(-0.4, 0.8) 
    &gt;&gt;&gt; ax.set_xlim(0, xmax) 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">jnyn_zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">)[</span><span class="s5">1</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">yn_zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot;Compute zeros of integer-order Bessel function Yn(x). 
 
    Compute `nt` zeros of the functions :math:`Y_n(x)` on the interval 
    :math:`(0, \infty)`. The zeros are returned in ascending order. 
 
    Parameters 
    ---------- 
    n : int 
        Order of Bessel function 
    nt : int 
        Number of zeros to return 
 
    Returns 
    ------- 
    ndarray 
        First `nt` zeros of the Bessel function. 
 
    See Also 
    -------- 
    yn: Bessel function of the second kind for integer order 
    yv: Bessel function of the second kind for real order 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 5. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    Examples 
    -------- 
    Compute the first four roots of :math:`Y_2`. 
 
    &gt;&gt;&gt; from scipy.special import yn_zeros 
    &gt;&gt;&gt; yn_zeros(2, 4) 
    array([ 3.38424177,  6.79380751, 10.02347798, 13.20998671]) 
 
    Plot :math:`Y_2` and its first four roots. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.special import yn, yn_zeros 
    &gt;&gt;&gt; xmin = 2 
    &gt;&gt;&gt; xmax = 15 
    &gt;&gt;&gt; x = np.linspace(xmin, xmax, 500) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.hlines(0, xmin, xmax, color='k') 
    &gt;&gt;&gt; ax.plot(x, yn(2, x), label=r'$Y_2$') 
    &gt;&gt;&gt; ax.scatter(yn_zeros(2, 4), np.zeros((4, )), s=30, c='r', 
    ...            label='Roots', zorder=5) 
    &gt;&gt;&gt; ax.set_ylim(-0.4, 0.4) 
    &gt;&gt;&gt; ax.set_xlim(xmin, xmax) 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">jnyn_zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">)[</span><span class="s5">2</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">ynp_zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot;Compute zeros of integer-order Bessel function derivatives Yn'(x). 
 
    Compute `nt` zeros of the functions :math:`Y_n'(x)` on the 
    interval :math:`(0, \infty)`. The zeros are returned in ascending 
    order. 
 
    Parameters 
    ---------- 
    n : int 
        Order of Bessel function 
    nt : int 
        Number of zeros to return 
 
    Returns 
    ------- 
    ndarray 
        First `nt` zeros of the Bessel derivative function. 
 
 
    See Also 
    -------- 
    yvp 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 5. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    Examples 
    -------- 
    Compute the first four roots of the first derivative of the 
    Bessel function of second kind for order 0 :math:`Y_0'`. 
 
    &gt;&gt;&gt; from scipy.special import ynp_zeros 
    &gt;&gt;&gt; ynp_zeros(0, 4) 
    array([ 2.19714133,  5.42968104,  8.59600587, 11.74915483]) 
 
    Plot :math:`Y_0`, :math:`Y_0'` and confirm visually that the roots of 
    :math:`Y_0'` are located at local extrema of :math:`Y_0`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.special import yn, ynp_zeros, yvp 
    &gt;&gt;&gt; zeros = ynp_zeros(0, 4) 
    &gt;&gt;&gt; xmax = 13 
    &gt;&gt;&gt; x = np.linspace(0, xmax, 500) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(x, yn(0, x), label=r'$Y_0$') 
    &gt;&gt;&gt; ax.plot(x, yvp(0, x, 1), label=r&quot;$Y_0'$&quot;) 
    &gt;&gt;&gt; ax.scatter(zeros, np.zeros((4, )), s=30, c='r', 
    ...            label=r&quot;Roots of $Y_0'$&quot;, zorder=5) 
    &gt;&gt;&gt; for root in zeros: 
    ...     y0_extremum =  yn(0, root) 
    ...     lower = min(0, y0_extremum) 
    ...     upper = max(0, y0_extremum) 
    ...     ax.vlines(root, lower, upper, color='r') 
    &gt;&gt;&gt; ax.hlines(0, 0, xmax, color='k') 
    &gt;&gt;&gt; ax.set_ylim(-0.6, 0.6) 
    &gt;&gt;&gt; ax.set_xlim(0, xmax) 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">jnyn_zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">)[</span><span class="s5">3</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">y0_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s1">complex</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute nt zeros of Bessel function Y0(z), and derivative at each zero. 
 
    The derivatives are given by Y0'(z0) = -Y1(z0) at each zero z0. 
 
    Parameters 
    ---------- 
    nt : int 
        Number of zeros to return 
    complex : bool, default False 
        Set to False to return only the real zeros; set to True to return only 
        the complex zeros with negative real part and positive imaginary part. 
        Note that the complex conjugates of the latter are also zeros of the 
        function, but are not returned by this routine. 
 
    Returns 
    ------- 
    z0n : ndarray 
        Location of nth zero of Y0(z) 
    y0pz0n : ndarray 
        Value of derivative Y0'(z0) for nth zero 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 5. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    Examples 
    -------- 
    Compute the first 4 real roots and the derivatives at the roots of 
    :math:`Y_0`: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import y0_zeros 
    &gt;&gt;&gt; zeros, grads = y0_zeros(4) 
    &gt;&gt;&gt; with np.printoptions(precision=5): 
    ...     print(f&quot;Roots: {zeros}&quot;) 
    ...     print(f&quot;Gradients: {grads}&quot;) 
    Roots: [ 0.89358+0.j  3.95768+0.j  7.08605+0.j 10.22235+0.j] 
    Gradients: [-0.87942+0.j  0.40254+0.j -0.3001 +0.j  0.2497 +0.j] 
 
    Plot the real part of :math:`Y_0` and the first four computed roots. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.special import y0 
    &gt;&gt;&gt; xmin = 0 
    &gt;&gt;&gt; xmax = 11 
    &gt;&gt;&gt; x = np.linspace(xmin, xmax, 500) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.hlines(0, xmin, xmax, color='k') 
    &gt;&gt;&gt; ax.plot(x, y0(x), label=r'$Y_0$') 
    &gt;&gt;&gt; zeros, grads = y0_zeros(4) 
    &gt;&gt;&gt; ax.scatter(zeros.real, np.zeros((4, )), s=30, c='r', 
    ...            label=r'$Y_0$_zeros', zorder=5) 
    &gt;&gt;&gt; ax.set_ylim(-0.5, 0.6) 
    &gt;&gt;&gt; ax.set_xlim(xmin, xmax) 
    &gt;&gt;&gt; plt.legend(ncol=2) 
    &gt;&gt;&gt; plt.show() 
 
    Compute the first 4 complex roots and the derivatives at the roots of 
    :math:`Y_0` by setting ``complex=True``: 
 
    &gt;&gt;&gt; y0_zeros(4, True) 
    (array([ -2.40301663+0.53988231j,  -5.5198767 +0.54718001j, 
             -8.6536724 +0.54841207j, -11.79151203+0.54881912j]), 
     array([ 0.10074769-0.88196771j, -0.02924642+0.5871695j , 
             0.01490806-0.46945875j, -0.00937368+0.40230454j])) 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Arguments must be scalar positive integer.&quot;</span><span class="s3">)</span>
    <span class="s1">kf </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s1">kc </span><span class="s3">= </span><span class="s2">not </span><span class="s1">complex</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">cyzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s1">kf</span><span class="s3">, </span><span class="s1">kc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">y1_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s1">complex</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute nt zeros of Bessel function Y1(z), and derivative at each zero. 
 
    The derivatives are given by Y1'(z1) = Y0(z1) at each zero z1. 
 
    Parameters 
    ---------- 
    nt : int 
        Number of zeros to return 
    complex : bool, default False 
        Set to False to return only the real zeros; set to True to return only 
        the complex zeros with negative real part and positive imaginary part. 
        Note that the complex conjugates of the latter are also zeros of the 
        function, but are not returned by this routine. 
 
    Returns 
    ------- 
    z1n : ndarray 
        Location of nth zero of Y1(z) 
    y1pz1n : ndarray 
        Value of derivative Y1'(z1) for nth zero 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 5. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    Examples 
    -------- 
    Compute the first 4 real roots and the derivatives at the roots of 
    :math:`Y_1`: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import y1_zeros 
    &gt;&gt;&gt; zeros, grads = y1_zeros(4) 
    &gt;&gt;&gt; with np.printoptions(precision=5): 
    ...     print(f&quot;Roots: {zeros}&quot;) 
    ...     print(f&quot;Gradients: {grads}&quot;) 
    Roots: [ 2.19714+0.j  5.42968+0.j  8.59601+0.j 11.74915+0.j] 
    Gradients: [ 0.52079+0.j -0.34032+0.j  0.27146+0.j -0.23246+0.j] 
 
    Extract the real parts: 
 
    &gt;&gt;&gt; realzeros = zeros.real 
    &gt;&gt;&gt; realzeros 
    array([ 2.19714133,  5.42968104,  8.59600587, 11.74915483]) 
 
    Plot :math:`Y_1` and the first four computed roots. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.special import y1 
    &gt;&gt;&gt; xmin = 0 
    &gt;&gt;&gt; xmax = 13 
    &gt;&gt;&gt; x = np.linspace(xmin, xmax, 500) 
    &gt;&gt;&gt; zeros, grads = y1_zeros(4) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.hlines(0, xmin, xmax, color='k') 
    &gt;&gt;&gt; ax.plot(x, y1(x), label=r'$Y_1$') 
    &gt;&gt;&gt; ax.scatter(zeros.real, np.zeros((4, )), s=30, c='r', 
    ...            label=r'$Y_1$_zeros', zorder=5) 
    &gt;&gt;&gt; ax.set_ylim(-0.5, 0.5) 
    &gt;&gt;&gt; ax.set_xlim(xmin, xmax) 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.show() 
 
    Compute the first 4 complex roots and the derivatives at the roots of 
    :math:`Y_1` by setting ``complex=True``: 
 
    &gt;&gt;&gt; y1_zeros(4, True) 
    (array([ -0.50274327+0.78624371j,  -3.83353519+0.56235654j, 
             -7.01590368+0.55339305j, -10.17357383+0.55127339j]), 
     array([-0.45952768+1.31710194j,  0.04830191-0.69251288j, 
            -0.02012695+0.51864253j,  0.011614  -0.43203296j])) 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Arguments must be scalar positive integer.&quot;</span><span class="s3">)</span>
    <span class="s1">kf </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s1">kc </span><span class="s3">= </span><span class="s2">not </span><span class="s1">complex</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">cyzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s1">kf</span><span class="s3">, </span><span class="s1">kc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">y1p_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s1">complex</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute nt zeros of Bessel derivative Y1'(z), and value at each zero. 
 
    The values are given by Y1(z1) at each z1 where Y1'(z1)=0. 
 
    Parameters 
    ---------- 
    nt : int 
        Number of zeros to return 
    complex : bool, default False 
        Set to False to return only the real zeros; set to True to return only 
        the complex zeros with negative real part and positive imaginary part. 
        Note that the complex conjugates of the latter are also zeros of the 
        function, but are not returned by this routine. 
 
    Returns 
    ------- 
    z1pn : ndarray 
        Location of nth zero of Y1'(z) 
    y1z1pn : ndarray 
        Value of derivative Y1(z1) for nth zero 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 5. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    Examples 
    -------- 
    Compute the first four roots of :math:`Y_1'` and the values of 
    :math:`Y_1` at these roots. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import y1p_zeros 
    &gt;&gt;&gt; y1grad_roots, y1_values = y1p_zeros(4) 
    &gt;&gt;&gt; with np.printoptions(precision=5): 
    ...     print(f&quot;Y1' Roots: {y1grad_roots.real}&quot;) 
    ...     print(f&quot;Y1 values: {y1_values.real}&quot;) 
    Y1' Roots: [ 3.68302  6.9415  10.1234  13.28576] 
    Y1 values: [ 0.41673 -0.30317  0.25091 -0.21897] 
 
    `y1p_zeros` can be used to calculate the extremal points of :math:`Y_1` 
    directly. Here we plot :math:`Y_1` and the first four extrema. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.special import y1, yvp 
    &gt;&gt;&gt; y1_roots, y1_values_at_roots = y1p_zeros(4) 
    &gt;&gt;&gt; real_roots = y1_roots.real 
    &gt;&gt;&gt; xmax = 15 
    &gt;&gt;&gt; x = np.linspace(0, xmax, 500) 
    &gt;&gt;&gt; x[0] += 1e-15 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(x, y1(x), label=r'$Y_1$') 
    &gt;&gt;&gt; ax.plot(x, yvp(1, x, 1), label=r&quot;$Y_1'$&quot;) 
    &gt;&gt;&gt; ax.scatter(real_roots, np.zeros((4, )), s=30, c='r', 
    ...            label=r&quot;Roots of $Y_1'$&quot;, zorder=5) 
    &gt;&gt;&gt; ax.scatter(real_roots, y1_values_at_roots.real, s=30, c='k', 
    ...            label=r&quot;Extrema of $Y_1$&quot;, zorder=5) 
    &gt;&gt;&gt; ax.hlines(0, 0, xmax, color='k') 
    &gt;&gt;&gt; ax.set_ylim(-0.5, 0.5) 
    &gt;&gt;&gt; ax.set_xlim(0, xmax) 
    &gt;&gt;&gt; ax.legend(ncol=2, bbox_to_anchor=(1., 0.75)) 
    &gt;&gt;&gt; plt.tight_layout() 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Arguments must be scalar positive integer.&quot;</span><span class="s3">)</span>
    <span class="s1">kf </span><span class="s3">= </span><span class="s5">2</span>
    <span class="s1">kc </span><span class="s3">= </span><span class="s2">not </span><span class="s1">complex</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">cyzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s1">kf</span><span class="s3">, </span><span class="s1">kc</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_bessel_diff_formula</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">L</span><span class="s3">, </span><span class="s1">phase</span><span class="s3">):</span>
    <span class="s0"># from AMS55.</span>
    <span class="s0"># L(v, z) = J(v, z), Y(v, z), H1(v, z), H2(v, z), phase = -1</span>
    <span class="s0"># L(v, z) = I(v, z) or exp(v*pi*i)K(v, z), phase = 1</span>
    <span class="s0"># For K, you can pull out the exp((v-k)*pi*i) into the caller</span>
    <span class="s1">v </span><span class="s3">= </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s5">1.0</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">L</span><span class="s3">(</span><span class="s1">v</span><span class="s3">-</span><span class="s1">n</span><span class="s3">, </span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">phase </span><span class="s3">* (</span><span class="s1">p </span><span class="s3">* (</span><span class="s1">n</span><span class="s3">-</span><span class="s1">i</span><span class="s3">+</span><span class="s5">1</span><span class="s3">)) / </span><span class="s1">i   </span><span class="s0"># = choose(k, i)</span>
        <span class="s1">s </span><span class="s3">+= </span><span class="s1">p</span><span class="s3">*</span><span class="s1">L</span><span class="s3">(</span><span class="s1">v</span><span class="s3">-</span><span class="s1">n </span><span class="s3">+ </span><span class="s1">i</span><span class="s3">*</span><span class="s5">2</span><span class="s3">, </span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">s </span><span class="s3">/ (</span><span class="s5">2.</span><span class="s3">**</span><span class="s1">n</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">jvp</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s5">1</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute derivatives of Bessel functions of the first kind. 
 
    Compute the nth derivative of the Bessel function `Jv` with 
    respect to `z`. 
 
    Parameters 
    ---------- 
    v : array_like or float 
        Order of Bessel function 
    z : complex 
        Argument at which to evaluate the derivative; can be real or 
        complex. 
    n : int, default 1 
        Order of derivative. For 0 returns the Bessel function `jv` itself. 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the derivative of the Bessel function. 
 
    Notes 
    ----- 
    The derivative is computed using the relation DLFM 10.6.7 [2]_. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 5. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    .. [2] NIST Digital Library of Mathematical Functions. 
           https://dlmf.nist.gov/10.6.E7 
 
    Examples 
    -------- 
 
    Compute the Bessel function of the first kind of order 0 and 
    its first two derivatives at 1. 
 
    &gt;&gt;&gt; from scipy.special import jvp 
    &gt;&gt;&gt; jvp(0, 1, 0), jvp(0, 1, 1), jvp(0, 1, 2) 
    (0.7651976865579666, -0.44005058574493355, -0.3251471008130331) 
 
    Compute the first derivative of the Bessel function of the first 
    kind for several orders at 1 by providing an array for `v`. 
 
    &gt;&gt;&gt; jvp([0, 1, 2], 1, 1) 
    array([-0.44005059,  0.3251471 ,  0.21024362]) 
 
    Compute the first derivative of the Bessel function of the first 
    kind of order 0 at several points by providing an array for `z`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; points = np.array([0., 1.5, 3.]) 
    &gt;&gt;&gt; jvp(0, points, 1) 
    array([-0.        , -0.55793651, -0.33905896]) 
 
    Plot the Bessel function of the first kind of order 1 and its 
    first three derivatives. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.linspace(-10, 10, 1000) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(x, jvp(1, x, 0), label=r&quot;$J_1$&quot;) 
    &gt;&gt;&gt; ax.plot(x, jvp(1, x, 1), label=r&quot;$J_1'$&quot;) 
    &gt;&gt;&gt; ax.plot(x, jvp(1, x, 2), label=r&quot;$J_1''$&quot;) 
    &gt;&gt;&gt; ax.plot(x, jvp(1, x, 3), label=r&quot;$J_1'''$&quot;) 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">_nonneg_int_or_fail</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s4">'n'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">jv</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_bessel_diff_formula</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">jv</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">yvp</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s5">1</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute derivatives of Bessel functions of the second kind. 
 
    Compute the nth derivative of the Bessel function `Yv` with 
    respect to `z`. 
 
    Parameters 
    ---------- 
    v : array_like of float 
        Order of Bessel function 
    z : complex 
        Argument at which to evaluate the derivative 
    n : int, default 1 
        Order of derivative. For 0 returns the BEssel function `yv` 
 
    Returns 
    ------- 
    scalar or ndarray 
        nth derivative of the Bessel function. 
 
    See Also 
    -------- 
    yv : Bessel functions of the second kind 
 
    Notes 
    ----- 
    The derivative is computed using the relation DLFM 10.6.7 [2]_. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 5. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    .. [2] NIST Digital Library of Mathematical Functions. 
           https://dlmf.nist.gov/10.6.E7 
 
    Examples 
    -------- 
    Compute the Bessel function of the second kind of order 0 and 
    its first two derivatives at 1. 
 
    &gt;&gt;&gt; from scipy.special import yvp 
    &gt;&gt;&gt; yvp(0, 1, 0), yvp(0, 1, 1), yvp(0, 1, 2) 
    (0.088256964215677, 0.7812128213002889, -0.8694697855159659) 
 
    Compute the first derivative of the Bessel function of the second 
    kind for several orders at 1 by providing an array for `v`. 
 
    &gt;&gt;&gt; yvp([0, 1, 2], 1, 1) 
    array([0.78121282, 0.86946979, 2.52015239]) 
 
    Compute the first derivative of the Bessel function of the 
    second kind of order 0 at several points by providing an array for `z`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; points = np.array([0.5, 1.5, 3.]) 
    &gt;&gt;&gt; yvp(0, points, 1) 
    array([ 1.47147239,  0.41230863, -0.32467442]) 
 
    Plot the Bessel function of the second kind of order 1 and its 
    first three derivatives. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.linspace(0, 5, 1000) 
    &gt;&gt;&gt; x[0] += 1e-15 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(x, yvp(1, x, 0), label=r&quot;$Y_1$&quot;) 
    &gt;&gt;&gt; ax.plot(x, yvp(1, x, 1), label=r&quot;$Y_1'$&quot;) 
    &gt;&gt;&gt; ax.plot(x, yvp(1, x, 2), label=r&quot;$Y_1''$&quot;) 
    &gt;&gt;&gt; ax.plot(x, yvp(1, x, 3), label=r&quot;$Y_1'''$&quot;) 
    &gt;&gt;&gt; ax.set_ylim(-10, 10) 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">_nonneg_int_or_fail</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s4">'n'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">yv</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_bessel_diff_formula</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">yv</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">kvp</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s5">1</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute derivatives of real-order modified Bessel function Kv(z) 
 
    Kv(z) is the modified Bessel function of the second kind. 
    Derivative is calculated with respect to `z`. 
 
    Parameters 
    ---------- 
    v : array_like of float 
        Order of Bessel function 
    z : array_like of complex 
        Argument at which to evaluate the derivative 
    n : int, default 1 
        Order of derivative. For 0 returns the Bessel function `kv` itself. 
 
    Returns 
    ------- 
    out : ndarray 
        The results 
 
    See Also 
    -------- 
    kv 
 
    Notes 
    ----- 
    The derivative is computed using the relation DLFM 10.29.5 [2]_. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 6. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    .. [2] NIST Digital Library of Mathematical Functions. 
           https://dlmf.nist.gov/10.29.E5 
 
    Examples 
    -------- 
    Compute the modified bessel function of the second kind of order 0 and 
    its first two derivatives at 1. 
 
    &gt;&gt;&gt; from scipy.special import kvp 
    &gt;&gt;&gt; kvp(0, 1, 0), kvp(0, 1, 1), kvp(0, 1, 2) 
    (0.42102443824070834, -0.6019072301972346, 1.0229316684379428) 
 
    Compute the first derivative of the modified Bessel function of the second 
    kind for several orders at 1 by providing an array for `v`. 
 
    &gt;&gt;&gt; kvp([0, 1, 2], 1, 1) 
    array([-0.60190723, -1.02293167, -3.85158503]) 
 
    Compute the first derivative of the modified Bessel function of the 
    second kind of order 0 at several points by providing an array for `z`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; points = np.array([0.5, 1.5, 3.]) 
    &gt;&gt;&gt; kvp(0, points, 1) 
    array([-1.65644112, -0.2773878 , -0.04015643]) 
 
    Plot the modified bessel function of the second kind and its 
    first three derivatives. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.linspace(0, 5, 1000) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(x, kvp(1, x, 0), label=r&quot;$K_1$&quot;) 
    &gt;&gt;&gt; ax.plot(x, kvp(1, x, 1), label=r&quot;$K_1'$&quot;) 
    &gt;&gt;&gt; ax.plot(x, kvp(1, x, 2), label=r&quot;$K_1''$&quot;) 
    &gt;&gt;&gt; ax.plot(x, kvp(1, x, 3), label=r&quot;$K_1'''$&quot;) 
    &gt;&gt;&gt; ax.set_ylim(-2.5, 2.5) 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">_nonneg_int_or_fail</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s4">'n'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">kv</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s3">(-</span><span class="s5">1</span><span class="s3">)**</span><span class="s1">n </span><span class="s3">* </span><span class="s1">_bessel_diff_formula</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">kv</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">ivp</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s5">1</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute derivatives of modified Bessel functions of the first kind. 
 
    Compute the nth derivative of the modified Bessel function `Iv` 
    with respect to `z`. 
 
    Parameters 
    ---------- 
    v : array_like or float 
        Order of Bessel function 
    z : array_like 
        Argument at which to evaluate the derivative; can be real or 
        complex. 
    n : int, default 1 
        Order of derivative. For 0, returns the Bessel function `iv` itself. 
 
    Returns 
    ------- 
    scalar or ndarray 
        nth derivative of the modified Bessel function. 
 
    See Also 
    -------- 
    iv 
 
    Notes 
    ----- 
    The derivative is computed using the relation DLFM 10.29.5 [2]_. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 6. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    .. [2] NIST Digital Library of Mathematical Functions. 
           https://dlmf.nist.gov/10.29.E5 
 
    Examples 
    -------- 
    Compute the modified Bessel function of the first kind of order 0 and 
    its first two derivatives at 1. 
 
    &gt;&gt;&gt; from scipy.special import ivp 
    &gt;&gt;&gt; ivp(0, 1, 0), ivp(0, 1, 1), ivp(0, 1, 2) 
    (1.2660658777520084, 0.565159103992485, 0.7009067737595233) 
 
    Compute the first derivative of the modified Bessel function of the first 
    kind for several orders at 1 by providing an array for `v`. 
 
    &gt;&gt;&gt; ivp([0, 1, 2], 1, 1) 
    array([0.5651591 , 0.70090677, 0.29366376]) 
 
    Compute the first derivative of the modified Bessel function of the 
    first kind of order 0 at several points by providing an array for `z`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; points = np.array([0., 1.5, 3.]) 
    &gt;&gt;&gt; ivp(0, points, 1) 
    array([0.        , 0.98166643, 3.95337022]) 
 
    Plot the modified Bessel function of the first kind of order 1 and its 
    first three derivatives. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.linspace(-5, 5, 1000) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(x, ivp(1, x, 0), label=r&quot;$I_1$&quot;) 
    &gt;&gt;&gt; ax.plot(x, ivp(1, x, 1), label=r&quot;$I_1'$&quot;) 
    &gt;&gt;&gt; ax.plot(x, ivp(1, x, 2), label=r&quot;$I_1''$&quot;) 
    &gt;&gt;&gt; ax.plot(x, ivp(1, x, 3), label=r&quot;$I_1'''$&quot;) 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">_nonneg_int_or_fail</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s4">'n'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">iv</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_bessel_diff_formula</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">iv</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">h1vp</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s5">1</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute derivatives of Hankel function H1v(z) with respect to `z`. 
 
    Parameters 
    ---------- 
    v : array_like 
        Order of Hankel function 
    z : array_like 
        Argument at which to evaluate the derivative. Can be real or 
        complex. 
    n : int, default 1 
        Order of derivative. For 0 returns the Hankel function `h1v` itself. 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the derivative of the Hankel function. 
 
    See Also 
    -------- 
    hankel1 
 
    Notes 
    ----- 
    The derivative is computed using the relation DLFM 10.6.7 [2]_. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 5. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    .. [2] NIST Digital Library of Mathematical Functions. 
           https://dlmf.nist.gov/10.6.E7 
 
    Examples 
    -------- 
    Compute the Hankel function of the first kind of order 0 and 
    its first two derivatives at 1. 
 
    &gt;&gt;&gt; from scipy.special import h1vp 
    &gt;&gt;&gt; h1vp(0, 1, 0), h1vp(0, 1, 1), h1vp(0, 1, 2) 
    ((0.7651976865579664+0.088256964215677j), 
     (-0.44005058574493355+0.7812128213002889j), 
     (-0.3251471008130329-0.8694697855159659j)) 
 
    Compute the first derivative of the Hankel function of the first kind 
    for several orders at 1 by providing an array for `v`. 
 
    &gt;&gt;&gt; h1vp([0, 1, 2], 1, 1) 
    array([-0.44005059+0.78121282j,  0.3251471 +0.86946979j, 
           0.21024362+2.52015239j]) 
 
    Compute the first derivative of the Hankel function of the first kind 
    of order 0 at several points by providing an array for `z`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; points = np.array([0.5, 1.5, 3.]) 
    &gt;&gt;&gt; h1vp(0, points, 1) 
    array([-0.24226846+1.47147239j, -0.55793651+0.41230863j, 
           -0.33905896-0.32467442j]) 
    &quot;&quot;&quot;</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">_nonneg_int_or_fail</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s4">'n'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">hankel1</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_bessel_diff_formula</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">hankel1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">h2vp</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s5">1</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute derivatives of Hankel function H2v(z) with respect to `z`. 
 
    Parameters 
    ---------- 
    v : array_like 
        Order of Hankel function 
    z : array_like 
        Argument at which to evaluate the derivative. Can be real or 
        complex. 
    n : int, default 1 
        Order of derivative. For 0 returns the Hankel function `h2v` itself. 
 
    Returns 
    ------- 
    scalar or ndarray 
        Values of the derivative of the Hankel function. 
 
    See Also 
    -------- 
    hankel2 
 
    Notes 
    ----- 
    The derivative is computed using the relation DLFM 10.6.7 [2]_. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 5. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    .. [2] NIST Digital Library of Mathematical Functions. 
           https://dlmf.nist.gov/10.6.E7 
 
    Examples 
    -------- 
    Compute the Hankel function of the second kind of order 0 and 
    its first two derivatives at 1. 
 
    &gt;&gt;&gt; from scipy.special import h2vp 
    &gt;&gt;&gt; h2vp(0, 1, 0), h2vp(0, 1, 1), h2vp(0, 1, 2) 
    ((0.7651976865579664-0.088256964215677j), 
     (-0.44005058574493355-0.7812128213002889j), 
     (-0.3251471008130329+0.8694697855159659j)) 
 
    Compute the first derivative of the Hankel function of the second kind 
    for several orders at 1 by providing an array for `v`. 
 
    &gt;&gt;&gt; h2vp([0, 1, 2], 1, 1) 
    array([-0.44005059-0.78121282j,  0.3251471 -0.86946979j, 
           0.21024362-2.52015239j]) 
 
    Compute the first derivative of the Hankel function of the second kind 
    of order 0 at several points by providing an array for `z`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; points = np.array([0.5, 1.5, 3.]) 
    &gt;&gt;&gt; h2vp(0, points, 1) 
    array([-0.24226846-1.47147239j, -0.55793651-0.41230863j, 
           -0.33905896+0.32467442j]) 
    &quot;&quot;&quot;</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">_nonneg_int_or_fail</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s4">'n'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">hankel2</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_bessel_diff_formula</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">hankel2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">riccati_jn</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot;Compute Ricatti-Bessel function of the first kind and its derivative. 
 
    The Ricatti-Bessel function of the first kind is defined as :math:`x 
    j_n(x)`, where :math:`j_n` is the spherical Bessel function of the first 
    kind of order :math:`n`. 
 
    This function computes the value and first derivative of the 
    Ricatti-Bessel function for all orders up to and including `n`. 
 
    Parameters 
    ---------- 
    n : int 
        Maximum order of function to compute 
    x : float 
        Argument at which to evaluate 
 
    Returns 
    ------- 
    jn : ndarray 
        Value of j0(x), ..., jn(x) 
    jnp : ndarray 
        First derivative j0'(x), ..., jn'(x) 
 
    Notes 
    ----- 
    The computation is carried out via backward recurrence, using the 
    relation DLMF 10.51.1 [2]_. 
 
    Wrapper for a Fortran routine created by Shanjie Zhang and Jianming 
    Jin [1]_. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
    .. [2] NIST Digital Library of Mathematical Functions. 
           https://dlmf.nist.gov/10.51.E1 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;arguments must be scalars.&quot;</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">_nonneg_int_or_fail</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s4">'n'</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">== </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s1">n</span>

    <span class="s1">jn </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n1 </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">,), </span><span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s1">jnp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">jn</span><span class="s3">)</span>

    <span class="s1">_rctj</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">out </span><span class="s3">= (</span><span class="s1">jn</span><span class="s3">, </span><span class="s1">jnp</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">jn</span><span class="s3">[:(</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">)], </span><span class="s1">jnp</span><span class="s3">[:(</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">)]</span>


<span class="s2">def </span><span class="s1">riccati_yn</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute Ricatti-Bessel function of the second kind and its derivative. 
 
    The Ricatti-Bessel function of the second kind is defined as :math:`x 
    y_n(x)`, where :math:`y_n` is the spherical Bessel function of the second 
    kind of order :math:`n`. 
 
    This function computes the value and first derivative of the function for 
    all orders up to and including `n`. 
 
    Parameters 
    ---------- 
    n : int 
        Maximum order of function to compute 
    x : float 
        Argument at which to evaluate 
 
    Returns 
    ------- 
    yn : ndarray 
        Value of y0(x), ..., yn(x) 
    ynp : ndarray 
        First derivative y0'(x), ..., yn'(x) 
 
    Notes 
    ----- 
    The computation is carried out via ascending recurrence, using the 
    relation DLMF 10.51.1 [2]_. 
 
    Wrapper for a Fortran routine created by Shanjie Zhang and Jianming 
    Jin [1]_. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
    .. [2] NIST Digital Library of Mathematical Functions. 
           https://dlmf.nist.gov/10.51.E1 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;arguments must be scalars.&quot;</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">_nonneg_int_or_fail</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s4">'n'</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">== </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s1">n</span>

    <span class="s1">yn </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n1 </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">,), </span><span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s1">ynp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">yn</span><span class="s3">)</span>
    <span class="s1">_rcty</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">out </span><span class="s3">= (</span><span class="s1">yn</span><span class="s3">, </span><span class="s1">ynp</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">yn</span><span class="s3">[:(</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">)], </span><span class="s1">ynp</span><span class="s3">[:(</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">)]</span>


<span class="s2">def </span><span class="s1">erf_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute the first nt zero in the first quadrant, ordered by absolute value. 
 
    Zeros in the other quadrants can be obtained by using the symmetries 
    erf(-z) = erf(z) and erf(conj(z)) = conj(erf(z)). 
 
 
    Parameters 
    ---------- 
    nt : int 
        The number of zeros to compute 
 
    Returns 
    ------- 
    The locations of the zeros of erf : ndarray (complex) 
        Complex values at which zeros of erf(z) 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import special 
    &gt;&gt;&gt; special.erf_zeros(1) 
    array([1.45061616+1.880943j]) 
 
    Check that erf is (close to) zero for the value returned by erf_zeros 
 
    &gt;&gt;&gt; special.erf(special.erf_zeros(1)) 
    array([4.95159469e-14-1.16407394e-16j]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Argument must be positive scalar integer.&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">cerzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">fresnelc_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute nt complex zeros of cosine Fresnel integral C(z). 
 
    Parameters 
    ---------- 
    nt : int 
        Number of zeros to compute 
 
    Returns 
    ------- 
    fresnelc_zeros: ndarray 
        Zeros of the cosine Fresnel integral 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Argument must be positive scalar integer.&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">fcszo</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">fresnels_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute nt complex zeros of sine Fresnel integral S(z). 
 
    Parameters 
    ---------- 
    nt : int 
        Number of zeros to compute 
 
    Returns 
    ------- 
    fresnels_zeros: ndarray 
        Zeros of the sine Fresnel integral 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Argument must be positive scalar integer.&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">fcszo</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">fresnel_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute nt complex zeros of sine and cosine Fresnel integrals S(z) and C(z). 
 
    Parameters 
    ---------- 
    nt : int 
        Number of zeros to compute 
 
    Returns 
    ------- 
    zeros_sine: ndarray 
        Zeros of the sine Fresnel integral 
    zeros_cosine : ndarray 
        Zeros of the cosine Fresnel integral 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Argument must be positive scalar integer.&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">fcszo</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">), </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">fcszo</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">assoc_laguerre</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute the generalized (associated) Laguerre polynomial of degree n and order k. 
 
    The polynomial :math:`L^{(k)}_n(x)` is orthogonal over ``[0, inf)``, 
    with weighting function ``exp(-x) * x**k`` with ``k &gt; -1``. 
 
    Parameters 
    ---------- 
    x : float or ndarray 
        Points where to evaluate the Laguerre polynomial 
    n : int 
        Degree of the Laguerre polynomial 
    k : int 
        Order of the Laguerre polynomial 
 
    Returns 
    ------- 
    assoc_laguerre: float or ndarray 
        Associated laguerre polynomial values 
 
    Notes 
    ----- 
    `assoc_laguerre` is a simple wrapper around `eval_genlaguerre`, with 
    reversed argument order ``(x, n, k=0.0) --&gt; (n, k, x)``. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_ufuncs</span><span class="s3">.</span><span class="s1">eval_genlaguerre</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>


<span class="s1">digamma </span><span class="s3">= </span><span class="s1">psi</span>


<span class="s2">def </span><span class="s1">polygamma</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot;Polygamma functions. 
 
    Defined as :math:`\psi^{(n)}(x)` where :math:`\psi` is the 
    `digamma` function. See [dlmf]_ for details. 
 
    Parameters 
    ---------- 
    n : array_like 
        The order of the derivative of the digamma function; must be 
        integral 
    x : array_like 
        Real valued input 
 
    Returns 
    ------- 
    ndarray 
        Function results 
 
    See Also 
    -------- 
    digamma 
 
    References 
    ---------- 
    .. [dlmf] NIST, Digital Library of Mathematical Functions, 
        https://dlmf.nist.gov/5.15 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import special 
    &gt;&gt;&gt; x = [2, 3, 25.5] 
    &gt;&gt;&gt; special.polygamma(1, x) 
    array([ 0.64493407,  0.39493407,  0.03999467]) 
    &gt;&gt;&gt; special.polygamma(0, x) == special.psi(x) 
    array([ True,  True,  True], dtype=bool) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">n</span><span class="s3">, </span><span class="s1">x </span><span class="s3">= </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">n</span><span class="s3">), </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">fac2 </span><span class="s3">= (-</span><span class="s5">1.0</span><span class="s3">)**(</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">) * </span><span class="s1">gamma</span><span class="s3">(</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1.0</span><span class="s3">) * </span><span class="s1">zeta</span><span class="s3">(</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">where</span><span class="s3">(</span><span class="s1">n </span><span class="s3">== </span><span class="s5">0</span><span class="s3">, </span><span class="s1">psi</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">fac2</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">mathieu_even_coef</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">q</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot;Fourier coefficients for even Mathieu and modified Mathieu functions. 
 
    The Fourier series of the even solutions of the Mathieu differential 
    equation are of the form 
 
    .. math:: \mathrm{ce}_{2n}(z, q) = \sum_{k=0}^{\infty} A_{(2n)}^{(2k)} \cos 2kz 
 
    .. math:: \mathrm{ce}_{2n+1}(z, q) = 
              \sum_{k=0}^{\infty} A_{(2n+1)}^{(2k+1)} \cos (2k+1)z 
 
    This function returns the coefficients :math:`A_{(2n)}^{(2k)}` for even 
    input m=2n, and the coefficients :math:`A_{(2n+1)}^{(2k+1)}` for odd input 
    m=2n+1. 
 
    Parameters 
    ---------- 
    m : int 
        Order of Mathieu functions.  Must be non-negative. 
    q : float (&gt;=0) 
        Parameter of Mathieu functions.  Must be non-negative. 
 
    Returns 
    ------- 
    Ak : ndarray 
        Even or odd Fourier coefficients, corresponding to even or odd m. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
    .. [2] NIST Digital Library of Mathematical Functions 
           https://dlmf.nist.gov/28.4#i 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">m</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">q</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;m and q must be scalars.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">q </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;q &gt;=0&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">m </span><span class="s3">!= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">m </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;m must be an integer &gt;=0.&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">q </span><span class="s3">&lt;= </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">qm </span><span class="s3">= </span><span class="s5">7.5 </span><span class="s3">+ </span><span class="s5">56.1</span><span class="s3">*</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">q</span><span class="s3">) - </span><span class="s5">134.7</span><span class="s3">*</span><span class="s1">q </span><span class="s3">+ </span><span class="s5">90.7</span><span class="s3">*</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">q</span><span class="s3">)*</span><span class="s1">q</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">qm </span><span class="s3">= </span><span class="s5">17.0 </span><span class="s3">+ </span><span class="s5">3.1</span><span class="s3">*</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">q</span><span class="s3">) - </span><span class="s5">.126</span><span class="s3">*</span><span class="s1">q </span><span class="s3">+ </span><span class="s5">.0037</span><span class="s3">*</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">q</span><span class="s3">)*</span><span class="s1">q</span>
    <span class="s1">km </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">qm </span><span class="s3">+ </span><span class="s5">0.5</span><span class="s3">*</span><span class="s1">m</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">km </span><span class="s3">&gt; </span><span class="s5">251</span><span class="s3">:</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">&quot;Too many predicted coefficients.&quot;</span><span class="s3">, </span><span class="s1">RuntimeWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">kd </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s1">m </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">m</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">m </span><span class="s3">% </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s1">kd </span><span class="s3">= </span><span class="s5">2</span>

    <span class="s1">a </span><span class="s3">= </span><span class="s1">mathieu_a</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">q</span><span class="s3">)</span>
    <span class="s1">fc </span><span class="s3">= </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">fcoef</span><span class="s3">(</span><span class="s1">kd</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">fc</span><span class="s3">[:</span><span class="s1">km</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">mathieu_odd_coef</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">q</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot;Fourier coefficients for even Mathieu and modified Mathieu functions. 
 
    The Fourier series of the odd solutions of the Mathieu differential 
    equation are of the form 
 
    .. math:: \mathrm{se}_{2n+1}(z, q) = 
              \sum_{k=0}^{\infty} B_{(2n+1)}^{(2k+1)} \sin (2k+1)z 
 
    .. math:: \mathrm{se}_{2n+2}(z, q) = 
              \sum_{k=0}^{\infty} B_{(2n+2)}^{(2k+2)} \sin (2k+2)z 
 
    This function returns the coefficients :math:`B_{(2n+2)}^{(2k+2)}` for even 
    input m=2n+2, and the coefficients :math:`B_{(2n+1)}^{(2k+1)}` for odd 
    input m=2n+1. 
 
    Parameters 
    ---------- 
    m : int 
        Order of Mathieu functions.  Must be non-negative. 
    q : float (&gt;=0) 
        Parameter of Mathieu functions.  Must be non-negative. 
 
    Returns 
    ------- 
    Bk : ndarray 
        Even or odd Fourier coefficients, corresponding to even or odd m. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">m</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">q</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;m and q must be scalars.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">q </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;q &gt;=0&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">m </span><span class="s3">!= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">m </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;m must be an integer &gt; 0&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">q </span><span class="s3">&lt;= </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">qm </span><span class="s3">= </span><span class="s5">7.5 </span><span class="s3">+ </span><span class="s5">56.1</span><span class="s3">*</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">q</span><span class="s3">) - </span><span class="s5">134.7</span><span class="s3">*</span><span class="s1">q </span><span class="s3">+ </span><span class="s5">90.7</span><span class="s3">*</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">q</span><span class="s3">)*</span><span class="s1">q</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">qm </span><span class="s3">= </span><span class="s5">17.0 </span><span class="s3">+ </span><span class="s5">3.1</span><span class="s3">*</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">q</span><span class="s3">) - </span><span class="s5">.126</span><span class="s3">*</span><span class="s1">q </span><span class="s3">+ </span><span class="s5">.0037</span><span class="s3">*</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">q</span><span class="s3">)*</span><span class="s1">q</span>
    <span class="s1">km </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">qm </span><span class="s3">+ </span><span class="s5">0.5</span><span class="s3">*</span><span class="s1">m</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">km </span><span class="s3">&gt; </span><span class="s5">251</span><span class="s3">:</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">&quot;Too many predicted coefficients.&quot;</span><span class="s3">, </span><span class="s1">RuntimeWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">kd </span><span class="s3">= </span><span class="s5">4</span>
    <span class="s1">m </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">m</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">m </span><span class="s3">% </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s1">kd </span><span class="s3">= </span><span class="s5">3</span>

    <span class="s1">b </span><span class="s3">= </span><span class="s1">mathieu_b</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">q</span><span class="s3">)</span>
    <span class="s1">fc </span><span class="s3">= </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">fcoef</span><span class="s3">(</span><span class="s1">kd</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">fc</span><span class="s3">[:</span><span class="s1">km</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">lpmn</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">z</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Sequence of associated Legendre functions of the first kind. 
 
    Computes the associated Legendre function of the first kind of order m and 
    degree n, ``Pmn(z)`` = :math:`P_n^m(z)`, and its derivative, ``Pmn'(z)``. 
    Returns two arrays of size ``(m+1, n+1)`` containing ``Pmn(z)`` and 
    ``Pmn'(z)`` for all orders from ``0..m`` and degrees from ``0..n``. 
 
    This function takes a real argument ``z``. For complex arguments ``z`` 
    use clpmn instead. 
 
    Parameters 
    ---------- 
    m : int 
       ``|m| &lt;= n``; the order of the Legendre function. 
    n : int 
       where ``n &gt;= 0``; the degree of the Legendre function.  Often 
       called ``l`` (lower case L) in descriptions of the associated 
       Legendre function 
    z : array_like 
        Input value. 
 
    Returns 
    ------- 
    Pmn_z : (m+1, n+1) array 
       Values for all orders 0..m and degrees 0..n 
    Pmn_d_z : (m+1, n+1) array 
       Derivatives for all orders 0..m and degrees 0..n 
 
    See Also 
    -------- 
    clpmn: associated Legendre functions of the first kind for complex z 
 
    Notes 
    ----- 
    In the interval (-1, 1), Ferrer's function of the first kind is 
    returned. The phase convention used for the intervals (1, inf) 
    and (-inf, -1) is such that the result is always real. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
    .. [2] NIST Digital Library of Mathematical Functions 
           https://dlmf.nist.gov/14.3 
 
    &quot;&quot;&quot;</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">_nonneg_int_or_fail</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s4">'n'</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">m</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">m</span><span class="s3">) &gt; </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;m must be &lt;= n.&quot;</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;n must be a non-negative integer.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">z</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Argument must be real. Use clpmn instead.&quot;</span><span class="s3">)</span>

    <span class="s1">m</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">m</span><span class="s3">), </span><span class="s1">int</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)  </span><span class="s0"># Convert to int to maintain backwards compatibility.</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">m </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s1">m_signbit </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s1">m_abs </span><span class="s3">= -</span><span class="s1">m</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">m_signbit </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s1">m_abs </span><span class="s3">= </span><span class="s1">m</span>

    <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">z</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inexact</span><span class="s3">)):</span>
        <span class="s1">z </span><span class="s3">= </span><span class="s1">z</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">m_abs </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">n </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">) + </span><span class="s1">z</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s1">pd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">z</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s1">_lpmn</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">m_signbit</span><span class="s3">, </span><span class="s1">out </span><span class="s3">= (</span><span class="s1">p</span><span class="s3">, </span><span class="s1">pd</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">_lpmn</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">m_signbit</span><span class="s3">, </span><span class="s1">out </span><span class="s3">= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), (-</span><span class="s5">2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)),</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">pd</span><span class="s3">, (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), (-</span><span class="s5">2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">))))  </span><span class="s0"># new axes must be last for the ufunc</span>

    <span class="s2">return </span><span class="s1">p</span><span class="s3">, </span><span class="s1">pd</span>


<span class="s2">def </span><span class="s1">clpmn</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">type</span><span class="s3">=</span><span class="s5">3</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Associated Legendre function of the first kind for complex arguments. 
 
    Computes the associated Legendre function of the first kind of order m and 
    degree n, ``Pmn(z)`` = :math:`P_n^m(z)`, and its derivative, ``Pmn'(z)``. 
    Returns two arrays of size ``(m+1, n+1)`` containing ``Pmn(z)`` and 
    ``Pmn'(z)`` for all orders from ``0..m`` and degrees from ``0..n``. 
 
    Parameters 
    ---------- 
    m : int 
       ``|m| &lt;= n``; the order of the Legendre function. 
    n : int 
       where ``n &gt;= 0``; the degree of the Legendre function.  Often 
       called ``l`` (lower case L) in descriptions of the associated 
       Legendre function 
    z : array_like, float or complex 
        Input value. 
    type : int, optional 
       takes values 2 or 3 
       2: cut on the real axis ``|x| &gt; 1`` 
       3: cut on the real axis ``-1 &lt; x &lt; 1`` (default) 
 
    Returns 
    ------- 
    Pmn_z : (m+1, n+1) array 
       Values for all orders ``0..m`` and degrees ``0..n`` 
    Pmn_d_z : (m+1, n+1) array 
       Derivatives for all orders ``0..m`` and degrees ``0..n`` 
 
    See Also 
    -------- 
    lpmn: associated Legendre functions of the first kind for real z 
 
    Notes 
    ----- 
    By default, i.e. for ``type=3``, phase conventions are chosen according 
    to [1]_ such that the function is analytic. The cut lies on the interval 
    (-1, 1). Approaching the cut from above or below in general yields a phase 
    factor with respect to Ferrer's function of the first kind 
    (cf. `lpmn`). 
 
    For ``type=2`` a cut at ``|x| &gt; 1`` is chosen. Approaching the real values 
    on the interval (-1, 1) in the complex plane yields Ferrer's function 
    of the first kind. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
    .. [2] NIST Digital Library of Mathematical Functions 
           https://dlmf.nist.gov/14.21 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">m</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">m</span><span class="s3">) &gt; </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;m must be &lt;= n.&quot;</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;n must be a non-negative integer.&quot;</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">type </span><span class="s3">== </span><span class="s5">2 </span><span class="s2">or </span><span class="s1">type </span><span class="s3">== </span><span class="s5">3</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;type must be either 2 or 3.&quot;</span><span class="s3">)</span>

    <span class="s1">m</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">m</span><span class="s3">), </span><span class="s1">int</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)  </span><span class="s0"># Convert to int to maintain backwards compatibility.</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">m </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s1">mp </span><span class="s3">= -</span><span class="s1">m</span>
        <span class="s1">m_signbit </span><span class="s3">= </span><span class="s2">True</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">mp </span><span class="s3">= </span><span class="s1">m</span>
        <span class="s1">m_signbit </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">z</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inexact</span><span class="s3">)):</span>
        <span class="s1">z </span><span class="s3">= </span><span class="s1">z</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">complex128</span><span class="s3">)</span>

    <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">mp </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">n </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">) + </span><span class="s1">z</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">complex128</span><span class="s3">)</span>
    <span class="s1">pd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">z</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s1">_clpmn</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">m_signbit</span><span class="s3">, </span><span class="s1">out </span><span class="s3">= (</span><span class="s1">p</span><span class="s3">, </span><span class="s1">pd</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">_clpmn</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">type</span><span class="s3">, </span><span class="s1">m_signbit</span><span class="s3">, </span><span class="s1">out </span><span class="s3">= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), (-</span><span class="s5">2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)),</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">pd</span><span class="s3">, (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), (-</span><span class="s5">2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">))))  </span><span class="s0"># new axes must be last for the ufunc</span>

    <span class="s2">return </span><span class="s1">p</span><span class="s3">, </span><span class="s1">pd</span>


<span class="s2">def </span><span class="s1">lqmn</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">z</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Sequence of associated Legendre functions of the second kind. 
 
    Computes the associated Legendre function of the second kind of order m and 
    degree n, ``Qmn(z)`` = :math:`Q_n^m(z)`, and its derivative, ``Qmn'(z)``. 
    Returns two arrays of size ``(m+1, n+1)`` containing ``Qmn(z)`` and 
    ``Qmn'(z)`` for all orders from ``0..m`` and degrees from ``0..n``. 
 
    Parameters 
    ---------- 
    m : int 
       ``|m| &lt;= n``; the order of the Legendre function. 
    n : int 
       where ``n &gt;= 0``; the degree of the Legendre function.  Often 
       called ``l`` (lower case L) in descriptions of the associated 
       Legendre function 
    z : array_like, complex 
        Input value. 
 
    Returns 
    ------- 
    Qmn_z : (m+1, n+1) array 
       Values for all orders 0..m and degrees 0..n 
    Qmn_d_z : (m+1, n+1) array 
       Derivatives for all orders 0..m and degrees 0..n 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">m</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">m </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;m must be a non-negative integer.&quot;</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;n must be a non-negative integer.&quot;</span><span class="s3">)</span>

    <span class="s1">m</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">m</span><span class="s3">), </span><span class="s1">int</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)  </span><span class="s0"># Convert to int to maintain backwards compatibility.</span>
    <span class="s0"># Ensure neither m nor n == 0</span>
    <span class="s1">mm </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">m</span><span class="s3">)</span>
    <span class="s1">nn </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>

    <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">z</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inexact</span><span class="s3">)):</span>
        <span class="s1">z </span><span class="s3">= </span><span class="s1">z</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">z</span><span class="s3">):</span>
        <span class="s1">q </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">mm </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">nn </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">) + </span><span class="s1">z</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complex128</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">q </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">mm </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">nn </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">) + </span><span class="s1">z</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s1">qd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">q</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">z</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s1">_lqmn</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">out </span><span class="s3">= (</span><span class="s1">q</span><span class="s3">, </span><span class="s1">qd</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">_lqmn</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">out </span><span class="s3">= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">q</span><span class="s3">, (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), (-</span><span class="s5">2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)),</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">qd</span><span class="s3">, (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), (-</span><span class="s5">2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">))))  </span><span class="s0"># new axes must be last for the ufunc</span>

    <span class="s2">return </span><span class="s1">q</span><span class="s3">[:(</span><span class="s1">m</span><span class="s3">+</span><span class="s5">1</span><span class="s3">), :(</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">)], </span><span class="s1">qd</span><span class="s3">[:(</span><span class="s1">m</span><span class="s3">+</span><span class="s5">1</span><span class="s3">), :(</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">)]</span>


<span class="s2">def </span><span class="s1">bernoulli</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Bernoulli numbers B0..Bn (inclusive). 
 
    Parameters 
    ---------- 
    n : int 
        Indicated the number of terms in the Bernoulli series to generate. 
 
    Returns 
    ------- 
    ndarray 
        The Bernoulli numbers ``[B(0), B(1), ..., B(n)]``. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
    .. [2] &quot;Bernoulli number&quot;, Wikipedia, https://en.wikipedia.org/wiki/Bernoulli_number 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import bernoulli, zeta 
    &gt;&gt;&gt; bernoulli(4) 
    array([ 1.        , -0.5       ,  0.16666667,  0.        , -0.03333333]) 
 
    The Wikipedia article ([2]_) points out the relationship between the 
    Bernoulli numbers and the zeta function, ``B_n^+ = -n * zeta(1 - n)`` 
    for ``n &gt; 0``: 
 
    &gt;&gt;&gt; n = np.arange(1, 5) 
    &gt;&gt;&gt; -n * zeta(1 - n) 
    array([ 0.5       ,  0.16666667, -0.        , -0.03333333]) 
 
    Note that, in the notation used in the wikipedia article, 
    `bernoulli` computes ``B_n^-`` (i.e. it used the convention that 
    ``B_1`` is -1/2).  The relation given above is for ``B_n^+``, so the 
    sign of 0.5 does not match the output of ``bernoulli(4)``. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;n must be a non-negative integer.&quot;</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">2</span><span class="s3">):</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s5">2</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s1">n</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">bernob</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">n1</span><span class="s3">))[:(</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">)]</span>


<span class="s2">def </span><span class="s1">euler</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Euler numbers E(0), E(1), ..., E(n). 
 
    The Euler numbers [1]_ are also known as the secant numbers. 
 
    Because ``euler(n)`` returns floating point values, it does not give 
    exact values for large `n`.  The first inexact value is E(22). 
 
    Parameters 
    ---------- 
    n : int 
        The highest index of the Euler number to be returned. 
 
    Returns 
    ------- 
    ndarray 
        The Euler numbers [E(0), E(1), ..., E(n)]. 
        The odd Euler numbers, which are all zero, are included. 
 
    References 
    ---------- 
    .. [1] Sequence A122045, The On-Line Encyclopedia of Integer Sequences, 
           https://oeis.org/A122045 
    .. [2] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import euler 
    &gt;&gt;&gt; euler(6) 
    array([  1.,   0.,  -1.,   0.,   5.,   0., -61.]) 
 
    &gt;&gt;&gt; euler(13).astype(np.int64) 
    array([      1,       0,      -1,       0,       5,       0,     -61, 
                 0,    1385,       0,  -50521,       0, 2702765,       0]) 
 
    &gt;&gt;&gt; euler(22)[-1]  # Exact value of E(22) is -69348874393137901. 
    -69348874393137976.0 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;n must be a non-negative integer.&quot;</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">2</span><span class="s3">):</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s5">2</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s1">n</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">eulerb</span><span class="s3">(</span><span class="s1">n1</span><span class="s3">)[:(</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">)]</span>


<span class="s2">def </span><span class="s1">lpn</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">z</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Legendre function of the first kind. 
 
    Compute sequence of Legendre functions of the first kind (polynomials), 
    Pn(z) and derivatives for all degrees from 0 to n (inclusive). 
 
    See also special.legendre for polynomial class. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">_nonneg_int_or_fail</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s4">'n'</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">z</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inexact</span><span class="s3">)):</span>
        <span class="s1">z </span><span class="s3">= </span><span class="s1">z</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s1">pn </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">,) + </span><span class="s1">z</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">z</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">pd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">pn</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">z</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s1">_lpn</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">out </span><span class="s3">= (</span><span class="s1">pn</span><span class="s3">, </span><span class="s1">pd</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">_lpn</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">out </span><span class="s3">= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">pn</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">),</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">pd</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">))) </span><span class="s0"># new axes must be last for the ufunc</span>

    <span class="s2">return </span><span class="s1">pn</span><span class="s3">, </span><span class="s1">pd</span>


<span class="s2">def </span><span class="s1">lqn</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">z</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Legendre function of the second kind. 
 
    Compute sequence of Legendre functions of the second kind, Qn(z) and 
    derivatives for all degrees from 0 to n (inclusive). 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">_nonneg_int_or_fail</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s4">'n'</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s1">n</span>

    <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">z</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inexact</span><span class="s3">)):</span>
        <span class="s1">z </span><span class="s3">= </span><span class="s1">z</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">z</span><span class="s3">):</span>
        <span class="s1">qn </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n1 </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">,) + </span><span class="s1">z</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">complex128</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">qn </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n1 </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">,) + </span><span class="s1">z</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s1">qd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">qn</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">z</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s1">_lqn</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">out </span><span class="s3">= (</span><span class="s1">qn</span><span class="s3">, </span><span class="s1">qd</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">_lqn</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">out </span><span class="s3">= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">qn</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">),</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">qd</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">))) </span><span class="s0"># new axes must be last for the ufunc</span>

    <span class="s2">return </span><span class="s1">qn</span><span class="s3">[:(</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">)], </span><span class="s1">qd</span><span class="s3">[:(</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">)]</span>


<span class="s2">def </span><span class="s1">ai_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Compute `nt` zeros and values of the Airy function Ai and its derivative. 
 
    Computes the first `nt` zeros, `a`, of the Airy function Ai(x); 
    first `nt` zeros, `ap`, of the derivative of the Airy function Ai'(x); 
    the corresponding values Ai(a'); 
    and the corresponding values Ai'(a). 
 
    Parameters 
    ---------- 
    nt : int 
        Number of zeros to compute 
 
    Returns 
    ------- 
    a : ndarray 
        First `nt` zeros of Ai(x) 
    ap : ndarray 
        First `nt` zeros of Ai'(x) 
    ai : ndarray 
        Values of Ai(x) evaluated at first `nt` zeros of Ai'(x) 
    aip : ndarray 
        Values of Ai'(x) evaluated at first `nt` zeros of Ai(x) 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import special 
    &gt;&gt;&gt; a, ap, ai, aip = special.ai_zeros(3) 
    &gt;&gt;&gt; a 
    array([-2.33810741, -4.08794944, -5.52055983]) 
    &gt;&gt;&gt; ap 
    array([-1.01879297, -3.24819758, -4.82009921]) 
    &gt;&gt;&gt; ai 
    array([ 0.53565666, -0.41901548,  0.38040647]) 
    &gt;&gt;&gt; aip 
    array([ 0.70121082, -0.80311137,  0.86520403]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">kf </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;nt must be a positive integer scalar.&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">airyzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s1">kf</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">bi_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Compute `nt` zeros and values of the Airy function Bi and its derivative. 
 
    Computes the first `nt` zeros, b, of the Airy function Bi(x); 
    first `nt` zeros, b', of the derivative of the Airy function Bi'(x); 
    the corresponding values Bi(b'); 
    and the corresponding values Bi'(b). 
 
    Parameters 
    ---------- 
    nt : int 
        Number of zeros to compute 
 
    Returns 
    ------- 
    b : ndarray 
        First `nt` zeros of Bi(x) 
    bp : ndarray 
        First `nt` zeros of Bi'(x) 
    bi : ndarray 
        Values of Bi(x) evaluated at first `nt` zeros of Bi'(x) 
    bip : ndarray 
        Values of Bi'(x) evaluated at first `nt` zeros of Bi(x) 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import special 
    &gt;&gt;&gt; b, bp, bi, bip = special.bi_zeros(3) 
    &gt;&gt;&gt; b 
    array([-1.17371322, -3.2710933 , -4.83073784]) 
    &gt;&gt;&gt; bp 
    array([-2.29443968, -4.07315509, -5.51239573]) 
    &gt;&gt;&gt; bi 
    array([-0.45494438,  0.39652284, -0.36796916]) 
    &gt;&gt;&gt; bip 
    array([ 0.60195789, -0.76031014,  0.83699101]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">kf </span><span class="s3">= </span><span class="s5">2</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;nt must be a positive integer scalar.&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">airyzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s1">kf</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">lmbda</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot;Jahnke-Emden Lambda function, Lambdav(x). 
 
    This function is defined as [2]_, 
 
    .. math:: \Lambda_v(x) = \Gamma(v+1) \frac{J_v(x)}{(x/2)^v}, 
 
    where :math:`\Gamma` is the gamma function and :math:`J_v` is the 
    Bessel function of the first kind. 
 
    Parameters 
    ---------- 
    v : float 
        Order of the Lambda function 
    x : float 
        Value at which to evaluate the function and derivatives 
 
    Returns 
    ------- 
    vl : ndarray 
        Values of Lambda_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v. 
    dl : ndarray 
        Derivatives Lambda_vi'(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
    .. [2] Jahnke, E. and Emde, F. &quot;Tables of Functions with Formulae and 
           Curves&quot; (4th ed.), Dover, 1945 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;arguments must be scalars.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">v </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;argument must be &gt; 0.&quot;</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>
    <span class="s1">v0 </span><span class="s3">= </span><span class="s1">v </span><span class="s3">- </span><span class="s1">n</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s1">n</span>
    <span class="s1">v1 </span><span class="s3">= </span><span class="s1">n1 </span><span class="s3">+ </span><span class="s1">v0</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">v </span><span class="s3">!= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)):</span>
        <span class="s1">vm</span><span class="s3">, </span><span class="s1">vl</span><span class="s3">, </span><span class="s1">dl </span><span class="s3">= </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">lamv</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">vm</span><span class="s3">, </span><span class="s1">vl</span><span class="s3">, </span><span class="s1">dl </span><span class="s3">= </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">lamn</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">vl</span><span class="s3">[:(</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">)], </span><span class="s1">dl</span><span class="s3">[:(</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">)]</span>


<span class="s2">def </span><span class="s1">pbdv_seq</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Parabolic cylinder functions Dv(x) and derivatives. 
 
    Parameters 
    ---------- 
    v : float 
        Order of the parabolic cylinder function 
    x : float 
        Value at which to evaluate the function and derivatives 
 
    Returns 
    ------- 
    dv : ndarray 
        Values of D_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v. 
    dp : ndarray 
        Derivatives D_vi'(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 13. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;arguments must be scalars.&quot;</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>
    <span class="s1">v0 </span><span class="s3">= </span><span class="s1">v</span><span class="s3">-</span><span class="s1">n</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s1">n</span>
    <span class="s1">v1 </span><span class="s3">= </span><span class="s1">n1 </span><span class="s3">+ </span><span class="s1">v0</span>
    <span class="s1">dv</span><span class="s3">, </span><span class="s1">dp</span><span class="s3">, </span><span class="s1">pdf</span><span class="s3">, </span><span class="s1">pdd </span><span class="s3">= </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">pbdv</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">dv</span><span class="s3">[:</span><span class="s1">n1</span><span class="s3">+</span><span class="s5">1</span><span class="s3">], </span><span class="s1">dp</span><span class="s3">[:</span><span class="s1">n1</span><span class="s3">+</span><span class="s5">1</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">pbvv_seq</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Parabolic cylinder functions Vv(x) and derivatives. 
 
    Parameters 
    ---------- 
    v : float 
        Order of the parabolic cylinder function 
    x : float 
        Value at which to evaluate the function and derivatives 
 
    Returns 
    ------- 
    dv : ndarray 
        Values of V_vi(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v. 
    dp : ndarray 
        Derivatives V_vi'(x), for vi=v-int(v), vi=1+v-int(v), ..., vi=v. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 13. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;arguments must be scalars.&quot;</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>
    <span class="s1">v0 </span><span class="s3">= </span><span class="s1">v</span><span class="s3">-</span><span class="s1">n</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s1">n</span>
    <span class="s1">v1 </span><span class="s3">= </span><span class="s1">n1 </span><span class="s3">+ </span><span class="s1">v0</span>
    <span class="s1">dv</span><span class="s3">, </span><span class="s1">dp</span><span class="s3">, </span><span class="s1">pdf</span><span class="s3">, </span><span class="s1">pdd </span><span class="s3">= </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">pbvv</span><span class="s3">(</span><span class="s1">v1</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">dv</span><span class="s3">[:</span><span class="s1">n1</span><span class="s3">+</span><span class="s5">1</span><span class="s3">], </span><span class="s1">dp</span><span class="s3">[:</span><span class="s1">n1</span><span class="s3">+</span><span class="s5">1</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">pbdn_seq</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">z</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Parabolic cylinder functions Dn(z) and derivatives. 
 
    Parameters 
    ---------- 
    n : int 
        Order of the parabolic cylinder function 
    z : complex 
        Value at which to evaluate the function and derivatives 
 
    Returns 
    ------- 
    dv : ndarray 
        Values of D_i(z), for i=0, ..., i=n. 
    dp : ndarray 
        Derivatives D_i'(z), for i=0, ..., i=n. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996, chapter 13. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;arguments must be scalars.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) != </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;n must be an integer.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) &lt;= </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">n1 </span><span class="s3">= </span><span class="s1">n</span>
    <span class="s1">cpb</span><span class="s3">, </span><span class="s1">cpd </span><span class="s3">= </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">cpbdn</span><span class="s3">(</span><span class="s1">n1</span><span class="s3">, </span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">cpb</span><span class="s3">[:</span><span class="s1">n1</span><span class="s3">+</span><span class="s5">1</span><span class="s3">], </span><span class="s1">cpd</span><span class="s3">[:</span><span class="s1">n1</span><span class="s3">+</span><span class="s5">1</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">ber_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute nt zeros of the Kelvin function ber. 
 
    Parameters 
    ---------- 
    nt : int 
        Number of zeros to compute. Must be positive. 
 
    Returns 
    ------- 
    ndarray 
        First `nt` zeros of the Kelvin function. 
 
    See Also 
    -------- 
    ber 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;nt must be positive integer scalar.&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">klvnzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">bei_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute nt zeros of the Kelvin function bei. 
 
    Parameters 
    ---------- 
    nt : int 
        Number of zeros to compute. Must be positive. 
 
    Returns 
    ------- 
    ndarray 
        First `nt` zeros of the Kelvin function. 
 
    See Also 
    -------- 
    bei 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;nt must be positive integer scalar.&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">klvnzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">ker_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute nt zeros of the Kelvin function ker. 
 
    Parameters 
    ---------- 
    nt : int 
        Number of zeros to compute. Must be positive. 
 
    Returns 
    ------- 
    ndarray 
        First `nt` zeros of the Kelvin function. 
 
    See Also 
    -------- 
    ker 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;nt must be positive integer scalar.&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">klvnzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s5">3</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">kei_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute nt zeros of the Kelvin function kei. 
 
    Parameters 
    ---------- 
    nt : int 
        Number of zeros to compute. Must be positive. 
 
    Returns 
    ------- 
    ndarray 
        First `nt` zeros of the Kelvin function. 
 
    See Also 
    -------- 
    kei 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;nt must be positive integer scalar.&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">klvnzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s5">4</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">berp_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute nt zeros of the derivative of the Kelvin function ber. 
 
    Parameters 
    ---------- 
    nt : int 
        Number of zeros to compute. Must be positive. 
 
    Returns 
    ------- 
    ndarray 
        First `nt` zeros of the derivative of the Kelvin function. 
 
    See Also 
    -------- 
    ber, berp 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;nt must be positive integer scalar.&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">klvnzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s5">5</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">beip_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute nt zeros of the derivative of the Kelvin function bei. 
 
    Parameters 
    ---------- 
    nt : int 
        Number of zeros to compute. Must be positive. 
 
    Returns 
    ------- 
    ndarray 
        First `nt` zeros of the derivative of the Kelvin function. 
 
    See Also 
    -------- 
    bei, beip 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;nt must be positive integer scalar.&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">klvnzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s5">6</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">kerp_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute nt zeros of the derivative of the Kelvin function ker. 
 
    Parameters 
    ---------- 
    nt : int 
        Number of zeros to compute. Must be positive. 
 
    Returns 
    ------- 
    ndarray 
        First `nt` zeros of the derivative of the Kelvin function. 
 
    See Also 
    -------- 
    ker, kerp 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;nt must be positive integer scalar.&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">klvnzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s5">7</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">keip_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute nt zeros of the derivative of the Kelvin function kei. 
 
    Parameters 
    ---------- 
    nt : int 
        Number of zeros to compute. Must be positive. 
 
    Returns 
    ------- 
    ndarray 
        First `nt` zeros of the derivative of the Kelvin function. 
 
    See Also 
    -------- 
    kei, keip 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;nt must be positive integer scalar.&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">klvnzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s5">8</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">kelvin_zeros</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute nt zeros of all Kelvin functions. 
 
    Returned in a length-8 tuple of arrays of length nt.  The tuple contains 
    the arrays of zeros of (ber, bei, ker, kei, ber', bei', ker', kei'). 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">nt </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;nt must be positive integer scalar.&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s3">(</span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">klvnzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s5">1</span><span class="s3">),</span>
            <span class="s1">_specfun</span><span class="s3">.</span><span class="s1">klvnzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s5">2</span><span class="s3">),</span>
            <span class="s1">_specfun</span><span class="s3">.</span><span class="s1">klvnzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s5">3</span><span class="s3">),</span>
            <span class="s1">_specfun</span><span class="s3">.</span><span class="s1">klvnzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s5">4</span><span class="s3">),</span>
            <span class="s1">_specfun</span><span class="s3">.</span><span class="s1">klvnzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s5">5</span><span class="s3">),</span>
            <span class="s1">_specfun</span><span class="s3">.</span><span class="s1">klvnzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s5">6</span><span class="s3">),</span>
            <span class="s1">_specfun</span><span class="s3">.</span><span class="s1">klvnzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s5">7</span><span class="s3">),</span>
            <span class="s1">_specfun</span><span class="s3">.</span><span class="s1">klvnzo</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">, </span><span class="s5">8</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">pro_cv_seq</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">c</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Characteristic values for prolate spheroidal wave functions. 
 
    Compute a sequence of characteristic values for the prolate 
    spheroidal wave functions for mode m and n'=m..n and spheroidal 
    parameter c. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">m</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">c</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Arguments must be scalars.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">!= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">m </span><span class="s3">!= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Modes must be integers.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">n</span><span class="s3">-</span><span class="s1">m </span><span class="s3">&gt; </span><span class="s5">199</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Difference between n and m is too large.&quot;</span><span class="s3">)</span>
    <span class="s1">maxL </span><span class="s3">= </span><span class="s1">n</span><span class="s3">-</span><span class="s1">m</span><span class="s3">+</span><span class="s5">1</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">segv</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)[</span><span class="s5">1</span><span class="s3">][:</span><span class="s1">maxL</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">obl_cv_seq</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">c</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Characteristic values for oblate spheroidal wave functions. 
 
    Compute a sequence of characteristic values for the oblate 
    spheroidal wave functions for mode m and n'=m..n and spheroidal 
    parameter c. 
 
    References 
    ---------- 
    .. [1] Zhang, Shanjie and Jin, Jianming. &quot;Computation of Special 
           Functions&quot;, John Wiley and Sons, 1996. 
           https://people.sc.fsu.edu/~jburkardt/f77_src/special_functions/special_functions.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">m</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">c</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Arguments must be scalars.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">!= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">m </span><span class="s3">!= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Modes must be integers.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">n</span><span class="s3">-</span><span class="s1">m </span><span class="s3">&gt; </span><span class="s5">199</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Difference between n and m is too large.&quot;</span><span class="s3">)</span>
    <span class="s1">maxL </span><span class="s3">= </span><span class="s1">n</span><span class="s3">-</span><span class="s1">m</span><span class="s3">+</span><span class="s5">1</span>
    <span class="s2">return </span><span class="s1">_specfun</span><span class="s3">.</span><span class="s1">segv</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)[</span><span class="s5">1</span><span class="s3">][:</span><span class="s1">maxL</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">comb</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, *, </span><span class="s1">exact</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">repetition</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;The number of combinations of N things taken k at a time. 
 
    This is often expressed as &quot;N choose k&quot;. 
 
    Parameters 
    ---------- 
    N : int, ndarray 
        Number of things. 
    k : int, ndarray 
        Number of elements taken. 
    exact : bool, optional 
        For integers, if `exact` is False, then floating point precision is 
        used, otherwise the result is computed exactly. 
 
        .. deprecated:: 1.14.0 
            ``exact=True`` is deprecated for non-integer `N` and `k` and will raise an 
            error in SciPy 1.16.0 
    repetition : bool, optional 
        If `repetition` is True, then the number of combinations with 
        repetition is computed. 
 
    Returns 
    ------- 
    val : int, float, ndarray 
        The total number of combinations. 
 
    See Also 
    -------- 
    binom : Binomial coefficient considered as a function of two real 
            variables. 
 
    Notes 
    ----- 
    - Array arguments accepted only for exact=False case. 
    - If N &lt; 0, or k &lt; 0, then 0 is returned. 
    - If k &gt; N and repetition=False, then 0 is returned. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import comb 
    &gt;&gt;&gt; k = np.array([3, 4]) 
    &gt;&gt;&gt; n = np.array([10, 10]) 
    &gt;&gt;&gt; comb(n, k, exact=False) 
    array([ 120.,  210.]) 
    &gt;&gt;&gt; comb(10, 3, exact=True) 
    120 
    &gt;&gt;&gt; comb(10, 3, exact=True, repetition=True) 
    220 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">repetition</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">comb</span><span class="s3">(</span><span class="s1">N </span><span class="s3">+ </span><span class="s1">k </span><span class="s3">- </span><span class="s5">1</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">exact</span><span class="s3">=</span><span class="s1">exact</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">exact</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">int</span><span class="s3">(</span><span class="s1">N</span><span class="s3">) == </span><span class="s1">N </span><span class="s2">and </span><span class="s1">int</span><span class="s3">(</span><span class="s1">k</span><span class="s3">) == </span><span class="s1">k</span><span class="s3">:</span>
            <span class="s0"># _comb_int casts inputs to integers, which is safe &amp; intended here</span>
            <span class="s2">return </span><span class="s1">_comb_int</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>
        <span class="s0"># otherwise, we disregard `exact=True`; it makes no sense for</span>
        <span class="s0"># non-integral arguments</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;`exact=True` is deprecated for non-integer `N` and `k` and will raise &quot;</span>
               <span class="s4">&quot;an error in SciPy 1.16.0&quot;</span><span class="s3">)</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">comb</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">k</span><span class="s3">, </span><span class="s1">N </span><span class="s3">= </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">k</span><span class="s3">), </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)</span>
        <span class="s1">cond </span><span class="s3">= (</span><span class="s1">k </span><span class="s3">&lt;= </span><span class="s1">N</span><span class="s3">) &amp; (</span><span class="s1">N </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">) &amp; (</span><span class="s1">k </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">vals </span><span class="s3">= </span><span class="s1">binom</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
            <span class="s1">vals</span><span class="s3">[~</span><span class="s1">cond</span><span class="s3">] = </span><span class="s5">0</span>
        <span class="s2">elif not </span><span class="s1">cond</span><span class="s3">:</span>
            <span class="s1">vals </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">vals</span>


<span class="s2">def </span><span class="s1">perm</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">exact</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Permutations of N things taken k at a time, i.e., k-permutations of N. 
 
    It's also known as &quot;partial permutations&quot;. 
 
    Parameters 
    ---------- 
    N : int, ndarray 
        Number of things. 
    k : int, ndarray 
        Number of elements taken. 
    exact : bool, optional 
        If ``True``, calculate the answer exactly using long integer arithmetic (`N` 
        and `k` must be scalar integers). If ``False``, a floating point approximation 
        is calculated (more rapidly) using `poch`. Default is ``False``. 
 
    Returns 
    ------- 
    val : int, ndarray 
        The number of k-permutations of N. 
 
    Notes 
    ----- 
    - Array arguments accepted only for exact=False case. 
    - If k &gt; N, N &lt; 0, or k &lt; 0, then a 0 is returned. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import perm 
    &gt;&gt;&gt; k = np.array([3, 4]) 
    &gt;&gt;&gt; n = np.array([10, 10]) 
    &gt;&gt;&gt; perm(n, k) 
    array([  720.,  5040.]) 
    &gt;&gt;&gt; perm(10, 3, exact=True) 
    720 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">exact</span><span class="s3">:</span>
        <span class="s1">N </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">squeeze</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)[()]  </span><span class="s0"># for backward compatibility (accepted size 1 arrays)</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">squeeze</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)[()]</span>
        <span class="s2">if not </span><span class="s3">(</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">N</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;`N` and `k` must scalar integers be with `exact=True`.&quot;</span><span class="s3">)</span>

        <span class="s1">floor_N</span><span class="s3">, </span><span class="s1">floor_k </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">N</span><span class="s3">), </span><span class="s1">int</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>
        <span class="s1">non_integral </span><span class="s3">= </span><span class="s2">not </span><span class="s3">(</span><span class="s1">floor_N </span><span class="s3">== </span><span class="s1">N </span><span class="s2">and </span><span class="s1">floor_k </span><span class="s3">== </span><span class="s1">k</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">k </span><span class="s3">&gt; </span><span class="s1">N</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">N </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">k </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">non_integral</span><span class="s3">:</span>
                <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;Non-integer `N` and `k` with `exact=True` is deprecated and &quot;</span>
                       <span class="s4">&quot;will raise an error in SciPy 1.16.0.&quot;</span><span class="s3">)</span>
                <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s5">0</span>
        <span class="s2">if </span><span class="s1">non_integral</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Non-integer `N` and `k` with `exact=True` is not &quot;</span>
                             <span class="s4">&quot;supported.&quot;</span><span class="s3">)</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s5">1</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">floor_N </span><span class="s3">- </span><span class="s1">floor_k </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">floor_N </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
            <span class="s1">val </span><span class="s3">*= </span><span class="s1">i</span>
        <span class="s2">return </span><span class="s1">val</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">k</span><span class="s3">, </span><span class="s1">N </span><span class="s3">= </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">k</span><span class="s3">), </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)</span>
        <span class="s1">cond </span><span class="s3">= (</span><span class="s1">k </span><span class="s3">&lt;= </span><span class="s1">N</span><span class="s3">) &amp; (</span><span class="s1">N </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">) &amp; (</span><span class="s1">k </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">vals </span><span class="s3">= </span><span class="s1">poch</span><span class="s3">(</span><span class="s1">N </span><span class="s3">- </span><span class="s1">k </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
            <span class="s1">vals</span><span class="s3">[~</span><span class="s1">cond</span><span class="s3">] = </span><span class="s5">0</span>
        <span class="s2">elif not </span><span class="s1">cond</span><span class="s3">:</span>
            <span class="s1">vals </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">vals</span>


<span class="s0"># https://stackoverflow.com/a/16327037</span>
<span class="s2">def </span><span class="s1">_range_prod</span><span class="s3">(</span><span class="s1">lo</span><span class="s3">, </span><span class="s1">hi</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">1</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Product of a range of numbers spaced k apart (from hi). 
 
    For k=1, this returns the product of 
    lo * (lo+1) * (lo+2) * ... * (hi-2) * (hi-1) * hi 
    = hi! / (lo-1)! 
 
    For k&gt;1, it correspond to taking only every k'th number when 
    counting down from hi - e.g. 18!!!! = _range_prod(1, 18, 4). 
 
    Breaks into smaller products first for speed: 
    _range_prod(2, 9) = ((2*3)*(4*5))*((6*7)*(8*9)) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">lo </span><span class="s3">+ </span><span class="s1">k </span><span class="s3">&lt; </span><span class="s1">hi</span><span class="s3">:</span>
        <span class="s1">mid </span><span class="s3">= (</span><span class="s1">hi </span><span class="s3">+ </span><span class="s1">lo</span><span class="s3">) // </span><span class="s5">2</span>
        <span class="s2">if </span><span class="s1">k </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s0"># make sure mid is a multiple of k away from hi</span>
            <span class="s1">mid </span><span class="s3">= </span><span class="s1">mid </span><span class="s3">- ((</span><span class="s1">mid </span><span class="s3">- </span><span class="s1">hi</span><span class="s3">) % </span><span class="s1">k</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_range_prod</span><span class="s3">(</span><span class="s1">lo</span><span class="s3">, </span><span class="s1">mid</span><span class="s3">, </span><span class="s1">k</span><span class="s3">) * </span><span class="s1">_range_prod</span><span class="s3">(</span><span class="s1">mid </span><span class="s3">+ </span><span class="s1">k</span><span class="s3">, </span><span class="s1">hi</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">lo </span><span class="s3">+ </span><span class="s1">k </span><span class="s3">== </span><span class="s1">hi</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">lo </span><span class="s3">* </span><span class="s1">hi</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">hi</span>


<span class="s2">def </span><span class="s1">_factorialx_array_exact</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">1</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Exact computation of factorial for an array. 
 
    The factorials are computed in incremental fashion, by taking 
    the sorted unique values of n and multiplying the intervening 
    numbers between the different unique values. 
 
    In other words, the factorial for the largest input is only 
    computed once, with each other result computed in the process. 
 
    k &gt; 1 corresponds to the multifactorial. 
    &quot;&quot;&quot;</span>
    <span class="s1">un </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s0"># numpy changed nan-sorting behaviour with 1.21, see numpy/numpy#18070;</span>
    <span class="s0"># to unify the behaviour, we remove the nan's here; the respective</span>
    <span class="s0"># values will be set separately at the end</span>
    <span class="s1">un </span><span class="s3">= </span><span class="s1">un</span><span class="s3">[~</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">un</span><span class="s3">)]</span>

    <span class="s0"># Convert to object array if np.int64 can't handle size</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">n</span><span class="s3">).</span><span class="s1">any</span><span class="s3">():</span>
        <span class="s1">dt </span><span class="s3">= </span><span class="s1">float</span>
    <span class="s2">elif </span><span class="s1">k </span><span class="s2">in </span><span class="s1">_FACTORIALK_LIMITS_64BITS</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">():</span>
        <span class="s2">if </span><span class="s1">un</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] &gt; </span><span class="s1">_FACTORIALK_LIMITS_64BITS</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]:</span>
            <span class="s0"># e.g. k=1: 21! &gt; np.iinfo(np.int64).max</span>
            <span class="s1">dt </span><span class="s3">= </span><span class="s1">object</span>
        <span class="s2">elif </span><span class="s1">un</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] &gt; </span><span class="s1">_FACTORIALK_LIMITS_32BITS</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]:</span>
            <span class="s0"># e.g. k=3: 26!!! &gt; np.iinfo(np.int32).max</span>
            <span class="s1">dt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">dt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s4">&quot;long&quot;</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s0"># for k &gt;= 10, we always use object</span>
        <span class="s1">dt </span><span class="s3">= </span><span class="s1">object</span>

    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dt</span><span class="s3">)</span>

    <span class="s0"># Handle invalid/trivial values</span>
    <span class="s1">un </span><span class="s3">= </span><span class="s1">un</span><span class="s3">[</span><span class="s1">un </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">]</span>
    <span class="s1">out</span><span class="s3">[</span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">2</span><span class="s3">] = </span><span class="s5">1</span>
    <span class="s1">out</span><span class="s3">[</span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">] = </span><span class="s5">0</span>

    <span class="s0"># Calculate products of each range of numbers</span>
    <span class="s0"># we can only multiply incrementally if the values are k apart;</span>
    <span class="s0"># therefore we partition `un` into &quot;lanes&quot;, i.e. its residues modulo k</span>
    <span class="s2">for </span><span class="s1">lane </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">k</span><span class="s3">):</span>
        <span class="s1">ul </span><span class="s3">= </span><span class="s1">un</span><span class="s3">[(</span><span class="s1">un </span><span class="s3">% </span><span class="s1">k</span><span class="s3">) == </span><span class="s1">lane</span><span class="s3">] </span><span class="s2">if </span><span class="s1">k </span><span class="s3">&gt; </span><span class="s5">1 </span><span class="s2">else </span><span class="s1">un</span>
        <span class="s2">if </span><span class="s1">ul</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
            <span class="s0"># after np.unique, un resp. ul are sorted, ul[0] is the smallest;</span>
            <span class="s0"># cast to python ints to avoid overflow with np.int-types</span>
            <span class="s1">val </span><span class="s3">= </span><span class="s1">_range_prod</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">int</span><span class="s3">(</span><span class="s1">ul</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]), </span><span class="s1">k</span><span class="s3">=</span><span class="s1">k</span><span class="s3">)</span>
            <span class="s1">out</span><span class="s3">[</span><span class="s1">n </span><span class="s3">== </span><span class="s1">ul</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]] = </span><span class="s1">val</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">ul</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">):</span>
                <span class="s0"># by the filtering above, we have ensured that prev &amp; current</span>
                <span class="s0"># are a multiple of k apart</span>
                <span class="s1">prev </span><span class="s3">= </span><span class="s1">ul</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s1">current </span><span class="s3">= </span><span class="s1">ul</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">]</span>
                <span class="s0"># we already multiplied all factors until prev; continue</span>
                <span class="s0"># building the full factorial from the following (`prev + 1`);</span>
                <span class="s0"># use int() for the same reason as above</span>
                <span class="s1">val </span><span class="s3">*= </span><span class="s1">_range_prod</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">prev </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">), </span><span class="s1">int</span><span class="s3">(</span><span class="s1">current</span><span class="s3">), </span><span class="s1">k</span><span class="s3">=</span><span class="s1">k</span><span class="s3">)</span>
                <span class="s1">out</span><span class="s3">[</span><span class="s1">n </span><span class="s3">== </span><span class="s1">current</span><span class="s3">] = </span><span class="s1">val</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">n</span><span class="s3">).</span><span class="s1">any</span><span class="s3">():</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">out</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s1">out</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
    <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">_factorialx_array_approx</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Calculate approximation to multifactorial for array n and integer k. 
 
    Ensure we only call _factorialx_approx_core where necessary/required. 
    &quot;&quot;&quot;</span>
    <span class="s1">result </span><span class="s3">= </span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s0"># keep nans as nans</span>
    <span class="s1">place</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">n</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">)</span>
    <span class="s0"># only compute where n &gt;= 0 (excludes nans), everything else is 0</span>
    <span class="s1">cond </span><span class="s3">= (</span><span class="s1">n </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">n_to_compute </span><span class="s3">= </span><span class="s1">extract</span><span class="s3">(</span><span class="s1">cond</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">place</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">cond</span><span class="s3">, </span><span class="s1">_factorialx_approx_core</span><span class="s3">(</span><span class="s1">n_to_compute</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s1">k</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">_factorialx_approx_core</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Core approximation to multifactorial for array n and integer k. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">k </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s0"># shortcut for k=1</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">gamma</span><span class="s3">(</span><span class="s1">n </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
            <span class="s0"># gamma does not maintain 0-dim arrays</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">n_mod_k </span><span class="s3">= </span><span class="s1">n </span><span class="s3">% </span><span class="s1">k</span>
    <span class="s0"># scalar case separately, unified handling would be inefficient for arrays;</span>
    <span class="s0"># don't use isscalar due to numpy/numpy#23574; 0-dim arrays treated below</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, (</span><span class="s1">n </span><span class="s3">- </span><span class="s1">n_mod_k</span><span class="s3">) / </span><span class="s1">k</span><span class="s3">)</span>
            <span class="s3">* </span><span class="s1">gamma</span><span class="s3">(</span><span class="s1">n </span><span class="s3">/ </span><span class="s1">k </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">) / </span><span class="s1">gamma</span><span class="s3">(</span><span class="s1">n_mod_k </span><span class="s3">/ </span><span class="s1">k </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
            <span class="s3">* </span><span class="s1">max</span><span class="s3">(</span><span class="s1">n_mod_k</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
        <span class="s3">)</span>

    <span class="s0"># factor that's independent of the residue class (see factorialk docstring)</span>
    <span class="s1">result </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">n </span><span class="s3">/ </span><span class="s1">k</span><span class="s3">) * </span><span class="s1">gamma</span><span class="s3">(</span><span class="s1">n </span><span class="s3">/ </span><span class="s1">k </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s0"># factor dependent on residue r (for `r=0` it's 1, so we skip `r=0`</span>
    <span class="s0"># below and thus also avoid evaluating `max(r, 1)`)</span>
    <span class="s2">def </span><span class="s1">corr</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">r</span><span class="s3">): </span><span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, -</span><span class="s1">r </span><span class="s3">/ </span><span class="s1">k</span><span class="s3">) / </span><span class="s1">gamma</span><span class="s3">(</span><span class="s1">r </span><span class="s3">/ </span><span class="s1">k </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">) * </span><span class="s1">r</span>
    <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">n_mod_k</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">r </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s0"># cast to int because uint types break on `-r`</span>
        <span class="s1">result</span><span class="s3">[</span><span class="s1">n_mod_k </span><span class="s3">== </span><span class="s1">r</span><span class="s3">] *= </span><span class="s1">corr</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">int</span><span class="s3">(</span><span class="s1">r</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">factorial</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">exact</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    The factorial of a number or array of numbers. 
 
    The factorial of non-negative integer `n` is the product of all 
    positive integers less than or equal to `n`:: 
 
        n! = n * (n - 1) * (n - 2) * ... * 1 
 
    Parameters 
    ---------- 
    n : int or array_like of ints 
        Input values.  If ``n &lt; 0``, the return value is 0. 
    exact : bool, optional 
        If True, calculate the answer exactly using long integer arithmetic. 
        If False, result is approximated in floating point rapidly using the 
        `gamma` function. 
        Default is False. 
 
    Returns 
    ------- 
    nf : float or int or ndarray 
        Factorial of `n`, as integer or float depending on `exact`. 
 
    Notes 
    ----- 
    For arrays with ``exact=True``, the factorial is computed only once, for 
    the largest input, with each other result computed in the process. 
    The output dtype is increased to ``int64`` or ``object`` if necessary. 
 
    With ``exact=False`` the factorial is approximated using the gamma 
    function: 
 
    .. math:: n! = \\Gamma(n+1) 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import factorial 
    &gt;&gt;&gt; arr = np.array([3, 4, 5]) 
    &gt;&gt;&gt; factorial(arr, exact=False) 
    array([   6.,   24.,  120.]) 
    &gt;&gt;&gt; factorial(arr, exact=True) 
    array([  6,  24, 120]) 
    &gt;&gt;&gt; factorial(5, exact=True) 
    120 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># don't use isscalar due to numpy/numpy#23574; 0-dim arrays treated below</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) == </span><span class="s5">0 </span><span class="s2">and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s0"># scalar cases</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s2">is None or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
        <span class="s2">elif not </span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">n</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">)</span>
                  <span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">n</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">floating</span><span class="s3">)):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">f&quot;Unsupported datatype for factorial: </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span><span class="s2">}\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;Permitted data types are integers and floating point numbers&quot;</span>
            <span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s5">0</span>
        <span class="s2">elif </span><span class="s1">exact </span><span class="s2">and </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">n</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">math</span><span class="s3">.</span><span class="s1">factorial</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">exact</span><span class="s3">:</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;Non-integer values of `n` together with `exact=True` are &quot;</span>
                   <span class="s4">&quot;deprecated. Either ensure integer `n` or use `exact=False`.&quot;</span><span class="s3">)</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_factorialx_approx_core</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>

    <span class="s0"># arrays &amp; array-likes</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">n</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s0"># return empty arrays unchanged</span>
        <span class="s2">return </span><span class="s1">n</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">n</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">)</span>
            <span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">n</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">floating</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
            <span class="s4">f&quot;Unsupported datatype for factorial: </span><span class="s2">{</span><span class="s1">n</span><span class="s3">.</span><span class="s1">dtype</span><span class="s2">}\n</span><span class="s4">&quot;</span>
            <span class="s4">&quot;Permitted data types are integers and floating point numbers&quot;</span>
        <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">exact </span><span class="s2">and not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">n</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;factorial with `exact=True` does not &quot;</span>
               <span class="s4">&quot;support non-integral arrays&quot;</span><span class="s3">)</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">exact</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_factorialx_array_exact</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_factorialx_array_approx</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">factorial2</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">exact</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Double factorial. 
 
    This is the factorial with every second value skipped.  E.g., ``7!! = 7 * 5 
    * 3 * 1``.  It can be approximated numerically as:: 
 
      n!! = 2 ** (n / 2) * gamma(n / 2 + 1) * sqrt(2 / pi)  n odd 
          = 2 ** (n / 2) * gamma(n / 2 + 1)                 n even 
          = 2 ** (n / 2) * (n / 2)!                         n even 
 
    Parameters 
    ---------- 
    n : int or array_like 
        Calculate ``n!!``.  If ``n &lt; 0``, the return value is 0. 
    exact : bool, optional 
        The result can be approximated rapidly using the gamma-formula 
        above (default).  If `exact` is set to True, calculate the 
        answer exactly using integer arithmetic. 
 
    Returns 
    ------- 
    nff : float or int 
        Double factorial of `n`, as an int or a float depending on 
        `exact`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import factorial2 
    &gt;&gt;&gt; factorial2(7, exact=False) 
    array(105.00000000000001) 
    &gt;&gt;&gt; factorial2(7, exact=True) 
    105 
 
    &quot;&quot;&quot;</span>

    <span class="s0"># don't use isscalar due to numpy/numpy#23574; 0-dim arrays treated below</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) == </span><span class="s5">0 </span><span class="s2">and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s0"># scalar cases</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s2">is None or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
        <span class="s2">elif not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">n</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;factorial2 does not support non-integral scalar arguments&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s5">0</span>
        <span class="s2">elif </span><span class="s1">n </span><span class="s2">in </span><span class="s3">{</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">}:</span>
            <span class="s2">return </span><span class="s5">1</span>
        <span class="s0"># general integer case</span>
        <span class="s2">if </span><span class="s1">exact</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_range_prod</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_factorialx_approx_core</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s0"># arrays &amp; array-likes</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">n</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s0"># return empty arrays unchanged</span>
        <span class="s2">return </span><span class="s1">n</span>
    <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">n</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;factorial2 does not support non-integral arrays&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">exact</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_factorialx_array_exact</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_factorialx_array_approx</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">factorialk</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">exact</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Multifactorial of n of order k, n(!!...!). 
 
    This is the multifactorial of n skipping k values.  For example, 
 
      factorialk(17, 4) = 17!!!! = 17 * 13 * 9 * 5 * 1 
 
    In particular, for any integer ``n``, we have 
 
      factorialk(n, 1) = factorial(n) 
 
      factorialk(n, 2) = factorial2(n) 
 
    Parameters 
    ---------- 
    n : int or array_like 
        Calculate multifactorial. If ``n &lt; 0``, the return value is 0. 
    k : int 
        Order of multifactorial. 
    exact : bool, optional 
        If exact is set to True, calculate the answer exactly using 
        integer arithmetic, otherwise use an approximation (faster, 
        but yields floats instead of integers) 
 
        .. warning:: 
           The default value for ``exact`` will be changed to 
           ``False`` in SciPy 1.15.0. 
 
    Returns 
    ------- 
    val : int 
        Multifactorial of `n`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.special import factorialk 
    &gt;&gt;&gt; factorialk(5, k=1, exact=True) 
    120 
    &gt;&gt;&gt; factorialk(5, k=3, exact=True) 
    10 
    &gt;&gt;&gt; factorialk([5, 7, 9], k=3, exact=True) 
    array([ 10,  28, 162]) 
    &gt;&gt;&gt; factorialk([5, 7, 9], k=3, exact=False) 
    array([ 10.,  28., 162.]) 
 
    Notes 
    ----- 
    While less straight-forward than for the double-factorial, it's possible to 
    calculate a general approximation formula of n!(k) by studying ``n`` for a given 
    remainder ``r &lt; k`` (thus ``n = m * k + r``, resp. ``r = n % k``), which can be 
    put together into something valid for all integer values ``n &gt;= 0`` &amp; ``k &gt; 0``:: 
 
      n!(k) = k ** ((n - r)/k) * gamma(n/k + 1) / gamma(r/k + 1) * max(r, 1) 
 
    This is the basis of the approximation when ``exact=False``. Compare also [1]. 
 
    References 
    ---------- 
    .. [1] Complex extension to multifactorial 
            https://en.wikipedia.org/wiki/Double_factorial#Alternative_extension_of_the_multifactorial 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">k</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">) </span><span class="s2">or </span><span class="s1">k </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;k must be a positive integer, received: </span><span class="s2">{</span><span class="s1">k</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">exact </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">msg </span><span class="s3">= (</span>
            <span class="s4">&quot;factorialk will default to `exact=False` starting from SciPy &quot;</span>
            <span class="s4">&quot;1.15.0. To avoid behaviour changes due to this, explicitly &quot;</span>
            <span class="s4">&quot;specify either `exact=False` (faster, returns floats), or the &quot;</span>
            <span class="s4">&quot;past default `exact=True` (slower, lossless result as integer).&quot;</span>
        <span class="s3">)</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
        <span class="s1">exact </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s1">helpmsg </span><span class="s3">= </span><span class="s4">&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">k </span><span class="s2">in </span><span class="s3">{</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">}:</span>
        <span class="s1">func </span><span class="s3">= </span><span class="s4">&quot;factorial&quot; </span><span class="s2">if </span><span class="s1">k </span><span class="s3">== </span><span class="s5">1 </span><span class="s2">else </span><span class="s4">&quot;factorial2&quot;</span>
        <span class="s1">helpmsg </span><span class="s3">= </span><span class="s4">f&quot;</span><span class="s2">\n</span><span class="s4">You can try to use </span><span class="s2">{</span><span class="s1">func</span><span class="s2">} </span><span class="s4">instead&quot;</span>

    <span class="s0"># don't use isscalar due to numpy/numpy#23574; 0-dim arrays treated below</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) == </span><span class="s5">0 </span><span class="s2">and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s0"># scalar cases</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s2">is None or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
        <span class="s2">elif not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">n</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;factorialk does not support non-integral scalar arguments!&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">+ </span><span class="s1">helpmsg</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s5">0</span>
        <span class="s2">elif </span><span class="s1">n </span><span class="s2">in </span><span class="s3">{</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">}:</span>
            <span class="s2">return </span><span class="s5">1</span>
        <span class="s0"># general integer case</span>
        <span class="s2">if </span><span class="s1">exact</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_range_prod</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s1">k</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_factorialx_approx_core</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s1">k</span><span class="s3">)</span>
    <span class="s0"># arrays &amp; array-likes</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">n</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s0"># return empty arrays unchanged</span>
        <span class="s2">return </span><span class="s1">n</span>
    <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">n</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">):</span>
        <span class="s1">msg </span><span class="s3">= </span><span class="s4">&quot;factorialk does not support non-integral arrays!&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg </span><span class="s3">+ </span><span class="s1">helpmsg</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">exact</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_factorialx_array_exact</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s1">k</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_factorialx_array_approx</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s1">k</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">stirling2</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">K</span><span class="s3">, *, </span><span class="s1">exact</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot;Generate Stirling number(s) of the second kind. 
 
    Stirling numbers of the second kind count the number of ways to 
    partition a set with N elements into K non-empty subsets. 
 
    The values this function returns are calculated using a dynamic 
    program which avoids redundant computation across the subproblems 
    in the solution. For array-like input, this implementation also 
    avoids redundant computation across the different Stirling number 
    calculations. 
 
    The numbers are sometimes denoted 
 
    .. math:: 
 
        {N \brace{K}} 
 
    see [1]_ for details. This is often expressed-verbally-as 
    &quot;N subset K&quot;. 
 
    Parameters 
    ---------- 
    N : int, ndarray 
        Number of things. 
    K : int, ndarray 
        Number of non-empty subsets taken. 
    exact : bool, optional 
        Uses dynamic programming (DP) with floating point 
        numbers for smaller arrays and uses a second order approximation due to 
        Temme for larger entries  of `N` and `K` that allows trading speed for 
        accuracy. See [2]_ for a description. Temme approximation is used for 
        values `n&gt;50`. The max error from the DP has max relative error 
        `4.5*10^-16` for `n&lt;=50` and the max error from the Temme approximation 
        has max relative error `5*10^-5` for `51 &lt;= n &lt; 70` and 
        `9*10^-6` for `70 &lt;= n &lt; 101`. Note that these max relative errors will 
        decrease further as `n` increases. 
 
    Returns 
    ------- 
    val : int, float, ndarray 
        The number of partitions. 
 
    See Also 
    -------- 
    comb : The number of combinations of N things taken k at a time. 
 
    Notes 
    ----- 
    - If N &lt; 0, or K &lt; 0, then 0 is returned. 
    - If K &gt; N, then 0 is returned. 
 
    The output type will always be `int` or ndarray of `object`. 
    The input must contain either numpy or python integers otherwise a 
    TypeError is raised. 
 
    References 
    ---------- 
    .. [1] R. L. Graham, D. E. Knuth and O. Patashnik, &quot;Concrete 
        Mathematics: A Foundation for Computer Science,&quot; Addison-Wesley 
        Publishing Company, Boston, 1989. Chapter 6, page 258. 
 
    .. [2] Temme, Nico M. &quot;Asymptotic estimates of Stirling numbers.&quot; 
        Studies in Applied Mathematics 89.3 (1993): 233-243. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import stirling2 
    &gt;&gt;&gt; k = np.array([3, -1, 3]) 
    &gt;&gt;&gt; n = np.array([10, 10, 9]) 
    &gt;&gt;&gt; stirling2(n, k) 
    array([9330, 0, 3025], dtype=object) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">output_is_scalar </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">N</span><span class="s3">) </span><span class="s2">and </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isscalar</span><span class="s3">(</span><span class="s1">K</span><span class="s3">)</span>
    <span class="s0"># make a min-heap of unique (n,k) pairs</span>
    <span class="s1">N</span><span class="s3">, </span><span class="s1">K </span><span class="s3">= </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">N</span><span class="s3">), </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">K</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">N</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;Argument `N` must contain only integers&quot;</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">K</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;Argument `K` must contain only integers&quot;</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">exact</span><span class="s3">:</span>
        <span class="s0"># NOTE: here we allow np.uint via casting to double types prior to</span>
        <span class="s0"># passing to private ufunc dispatcher. All dispatched functions</span>
        <span class="s0"># take double type for (n,k) arguments and return double.</span>
        <span class="s2">return </span><span class="s1">_stirling2_inexact</span><span class="s3">(</span><span class="s1">N</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">), </span><span class="s1">K</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">))</span>
    <span class="s1">nk_pairs </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span>
        <span class="s1">set</span><span class="s3">([(</span><span class="s1">n</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s5">0</span><span class="s3">), </span><span class="s1">k</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s5">0</span><span class="s3">))</span>
             <span class="s2">for </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">([</span><span class="s1">N</span><span class="s3">, </span><span class="s1">K</span><span class="s3">], [</span><span class="s4">'refs_ok'</span><span class="s3">])])</span>
    <span class="s3">)</span>
    <span class="s1">heapify</span><span class="s3">(</span><span class="s1">nk_pairs</span><span class="s3">)</span>
    <span class="s0"># base mapping for small values</span>
    <span class="s1">snsk_vals </span><span class="s3">= </span><span class="s1">defaultdict</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">pair </span><span class="s2">in </span><span class="s3">[(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">), (</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), (</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), (</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)]:</span>
        <span class="s1">snsk_vals</span><span class="s3">[</span><span class="s1">pair</span><span class="s3">] = </span><span class="s5">1</span>
    <span class="s0"># for each pair in the min-heap, calculate the value, store for later</span>
    <span class="s1">n_old</span><span class="s3">, </span><span class="s1">n_row </span><span class="s3">= </span><span class="s5">2</span><span class="s3">, [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]</span>
    <span class="s2">while </span><span class="s1">nk_pairs</span><span class="s3">:</span>
        <span class="s1">n</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">heappop</span><span class="s3">(</span><span class="s1">nk_pairs</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s5">2 </span><span class="s2">or </span><span class="s1">k </span><span class="s3">&gt; </span><span class="s1">n </span><span class="s2">or </span><span class="s1">k </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s2">elif </span><span class="s1">k </span><span class="s3">== </span><span class="s1">n </span><span class="s2">or </span><span class="s1">k </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">snsk_vals</span><span class="s3">[(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)] = </span><span class="s5">1</span>
            <span class="s2">continue</span>
        <span class="s2">elif </span><span class="s1">n </span><span class="s3">!= </span><span class="s1">n_old</span><span class="s3">:</span>
            <span class="s1">num_iters </span><span class="s3">= </span><span class="s1">n </span><span class="s3">- </span><span class="s1">n_old</span>
            <span class="s2">while </span><span class="s1">num_iters </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s1">n_row</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s5">1</span><span class="s3">)</span>
                <span class="s0"># traverse from back to remove second row</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">n_row</span><span class="s3">)-</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">):</span>
                    <span class="s1">n_row</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">n_row</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]*</span><span class="s1">j </span><span class="s3">+ </span><span class="s1">n_row</span><span class="s3">[</span><span class="s1">j</span><span class="s3">-</span><span class="s5">1</span><span class="s3">]</span>
                <span class="s1">num_iters </span><span class="s3">-= </span><span class="s5">1</span>
            <span class="s1">snsk_vals</span><span class="s3">[(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)] = </span><span class="s1">n_row</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">snsk_vals</span><span class="s3">[(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)] = </span><span class="s1">n_row</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
        <span class="s1">n_old</span><span class="s3">, </span><span class="s1">n_row </span><span class="s3">= </span><span class="s1">n</span><span class="s3">, </span><span class="s1">n_row</span>
    <span class="s1">out_types </span><span class="s3">= [</span><span class="s1">object</span><span class="s3">, </span><span class="s1">object</span><span class="s3">, </span><span class="s1">object</span><span class="s3">] </span><span class="s2">if </span><span class="s1">exact </span><span class="s2">else </span><span class="s3">[</span><span class="s1">float</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">float</span><span class="s3">]</span>
    <span class="s0"># for each pair in the map, fetch the value, and populate the array</span>
    <span class="s1">it </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">(</span>
        <span class="s3">[</span><span class="s1">N</span><span class="s3">, </span><span class="s1">K</span><span class="s3">, </span><span class="s2">None</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s4">'buffered'</span><span class="s3">, </span><span class="s4">'refs_ok'</span><span class="s3">],</span>
        <span class="s3">[[</span><span class="s4">'readonly'</span><span class="s3">], [</span><span class="s4">'readonly'</span><span class="s3">], [</span><span class="s4">'writeonly'</span><span class="s3">, </span><span class="s4">'allocate'</span><span class="s3">]],</span>
        <span class="s1">op_dtypes</span><span class="s3">=</span><span class="s1">out_types</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">with </span><span class="s1">it</span><span class="s3">:</span>
        <span class="s2">while not </span><span class="s1">it</span><span class="s3">.</span><span class="s1">finished</span><span class="s3">:</span>
            <span class="s1">it</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">snsk_vals</span><span class="s3">[(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">it</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]), </span><span class="s1">int</span><span class="s3">(</span><span class="s1">it</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]))]</span>
            <span class="s1">it</span><span class="s3">.</span><span class="s1">iternext</span><span class="s3">()</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">it</span><span class="s3">.</span><span class="s1">operands</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]</span>
        <span class="s0"># If N and K were both scalars, convert output to scalar.</span>
        <span class="s2">if </span><span class="s1">output_is_scalar</span><span class="s3">:</span>
            <span class="s1">output </span><span class="s3">= </span><span class="s1">output</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s2">def </span><span class="s1">zeta</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">q</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot; 
    Riemann or Hurwitz zeta function. 
 
    Parameters 
    ---------- 
    x : array_like of float 
        Input data, must be real 
    q : array_like of float, optional 
        Input data, must be real.  Defaults to Riemann zeta. 
    out : ndarray, optional 
        Output array for the computed values. 
 
    Returns 
    ------- 
    out : array_like 
        Values of zeta(x). 
 
    See Also 
    -------- 
    zetac 
 
    Notes 
    ----- 
    The two-argument version is the Hurwitz zeta function 
 
    .. math:: 
 
        \zeta(x, q) = \sum_{k=0}^{\infty} \frac{1}{(k + q)^x}; 
 
    see [dlmf]_ for details. The Riemann zeta function corresponds to 
    the case when ``q = 1``. 
 
    References 
    ---------- 
    .. [dlmf] NIST, Digital Library of Mathematical Functions, 
        https://dlmf.nist.gov/25.11#i 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import zeta, polygamma, factorial 
 
    Some specific values: 
 
    &gt;&gt;&gt; zeta(2), np.pi**2/6 
    (1.6449340668482266, 1.6449340668482264) 
 
    &gt;&gt;&gt; zeta(4), np.pi**4/90 
    (1.0823232337111381, 1.082323233711138) 
 
    Relation to the `polygamma` function: 
 
    &gt;&gt;&gt; m = 3 
    &gt;&gt;&gt; x = 1.25 
    &gt;&gt;&gt; polygamma(m, x) 
    array(2.782144009188397) 
    &gt;&gt;&gt; (-1)**(m+1) * factorial(m) * zeta(m+1, x) 
    2.7821440091883969 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">q </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_ufuncs</span><span class="s3">.</span><span class="s1">_riemann_zeta</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_ufuncs</span><span class="s3">.</span><span class="s1">_zeta</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">out</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_sph_harm_all</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Private function. This may be removed or modified at any time.&quot;&quot;&quot;</span>

    <span class="s1">theta </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">theta</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">theta</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inexact</span><span class="s3">)):</span>
        <span class="s1">theta </span><span class="s3">= </span><span class="s1">theta</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s1">phi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">phi</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">phi</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inexact</span><span class="s3">)):</span>
        <span class="s1">phi </span><span class="s3">= </span><span class="s1">phi</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">m </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">n </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">) + </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_shapes</span><span class="s3">(</span><span class="s1">theta</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">),</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">result_type</span><span class="s3">(</span><span class="s5">1j</span><span class="s3">, </span><span class="s1">theta</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">))</span>
    <span class="s1">_sph_harm_all_gufunc</span><span class="s3">(</span><span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), (-</span><span class="s5">2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)))</span>

    <span class="s2">return </span><span class="s1">out</span>
</pre>
</body>
</html>