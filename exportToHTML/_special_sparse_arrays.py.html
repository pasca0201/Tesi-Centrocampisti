<html>
<head>
<title>_special_sparse_arrays.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #7a7e85;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_special_sparse_arrays.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">linalg </span><span class="s0">import </span><span class="s1">LinearOperator</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">sparse </span><span class="s0">import </span><span class="s1">kron</span><span class="s2">, </span><span class="s1">eye</span><span class="s2">, </span><span class="s1">dia_array</span>

<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">'LaplacianNd'</span><span class="s2">]</span>
<span class="s4"># Sakurai and Mikota classes are intended for tests and benchmarks</span>
<span class="s4"># and explicitly not included in the public API of this module.</span>


<span class="s0">class </span><span class="s1">LaplacianNd</span><span class="s2">(</span><span class="s1">LinearOperator</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    The grid Laplacian in ``N`` dimensions and its eigenvalues/eigenvectors. 
 
    Construct Laplacian on a uniform rectangular grid in `N` dimensions 
    and output its eigenvalues and eigenvectors. 
    The Laplacian ``L`` is square, negative definite, real symmetric array 
    with signed integer entries and zeros otherwise. 
 
    Parameters 
    ---------- 
    grid_shape : tuple 
        A tuple of integers of length ``N`` (corresponding to the dimension of 
        the Lapacian), where each entry gives the size of that dimension. The 
        Laplacian matrix is square of the size ``np.prod(grid_shape)``. 
    boundary_conditions : {'neumann', 'dirichlet', 'periodic'}, optional 
        The type of the boundary conditions on the boundaries of the grid. 
        Valid values are ``'dirichlet'`` or ``'neumann'``(default) or 
        ``'periodic'``. 
    dtype : dtype 
        Numerical type of the array. Default is ``np.int8``. 
 
    Methods 
    ------- 
    toarray() 
        Construct a dense array from Laplacian data 
    tosparse() 
        Construct a sparse array from Laplacian data 
    eigenvalues(m=None) 
        Construct a 1D array of `m` largest (smallest in absolute value) 
        eigenvalues of the Laplacian matrix in ascending order. 
    eigenvectors(m=None): 
        Construct the array with columns made of `m` eigenvectors (``float``) 
        of the ``Nd`` Laplacian corresponding to the `m` ordered eigenvalues. 
 
    .. versionadded:: 1.12.0 
 
    Notes 
    ----- 
    Compared to the MATLAB/Octave implementation [1] of 1-, 2-, and 3-D 
    Laplacian, this code allows the arbitrary N-D case and the matrix-free 
    callable option, but is currently limited to pure Dirichlet, Neumann or 
    Periodic boundary conditions only. 
 
    The Laplacian matrix of a graph (`scipy.sparse.csgraph.laplacian`) of a 
    rectangular grid corresponds to the negative Laplacian with the Neumann 
    conditions, i.e., ``boundary_conditions = 'neumann'``. 
 
    All eigenvalues and eigenvectors of the discrete Laplacian operator for 
    an ``N``-dimensional  regular grid of shape `grid_shape` with the grid 
    step size ``h=1`` are analytically known [2]. 
 
    References 
    ---------- 
    .. [1] https://github.com/lobpcg/blopex/blob/master/blopex_\ 
tools/matlab/laplacian/laplacian.m 
    .. [2] &quot;Eigenvalues and eigenvectors of the second derivative&quot;, Wikipedia 
           https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors_\ 
of_the_second_derivative 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse.linalg import LaplacianNd 
    &gt;&gt;&gt; from scipy.sparse import diags, csgraph 
    &gt;&gt;&gt; from scipy.linalg import eigvalsh 
 
    The one-dimensional Laplacian demonstrated below for pure Neumann boundary 
    conditions on a regular grid with ``n=6`` grid points is exactly the 
    negative graph Laplacian for the undirected linear graph with ``n`` 
    vertices using the sparse adjacency matrix ``G`` represented by the 
    famous tri-diagonal matrix: 
 
    &gt;&gt;&gt; n = 6 
    &gt;&gt;&gt; G = diags(np.ones(n - 1), 1, format='csr') 
    &gt;&gt;&gt; Lf = csgraph.laplacian(G, symmetrized=True, form='function') 
    &gt;&gt;&gt; grid_shape = (n, ) 
    &gt;&gt;&gt; lap = LaplacianNd(grid_shape, boundary_conditions='neumann') 
    &gt;&gt;&gt; np.array_equal(lap.matmat(np.eye(n)), -Lf(np.eye(n))) 
    True 
 
    Since all matrix entries of the Laplacian are integers, ``'int8'`` is 
    the default dtype for storing matrix representations. 
 
    &gt;&gt;&gt; lap.tosparse() 
    &lt;DIAgonal sparse array of dtype 'int8' 
        with 16 stored elements (3 diagonals) and shape (6, 6)&gt; 
    &gt;&gt;&gt; lap.toarray() 
    array([[-1,  1,  0,  0,  0,  0], 
           [ 1, -2,  1,  0,  0,  0], 
           [ 0,  1, -2,  1,  0,  0], 
           [ 0,  0,  1, -2,  1,  0], 
           [ 0,  0,  0,  1, -2,  1], 
           [ 0,  0,  0,  0,  1, -1]], dtype=int8) 
    &gt;&gt;&gt; np.array_equal(lap.matmat(np.eye(n)), lap.toarray()) 
    True 
    &gt;&gt;&gt; np.array_equal(lap.tosparse().toarray(), lap.toarray()) 
    True 
 
    Any number of extreme eigenvalues and/or eigenvectors can be computed. 
     
    &gt;&gt;&gt; lap = LaplacianNd(grid_shape, boundary_conditions='periodic') 
    &gt;&gt;&gt; lap.eigenvalues() 
    array([-4., -3., -3., -1., -1.,  0.]) 
    &gt;&gt;&gt; lap.eigenvalues()[-2:] 
    array([-1.,  0.]) 
    &gt;&gt;&gt; lap.eigenvalues(2) 
    array([-1.,  0.]) 
    &gt;&gt;&gt; lap.eigenvectors(1) 
    array([[0.40824829], 
           [0.40824829], 
           [0.40824829], 
           [0.40824829], 
           [0.40824829], 
           [0.40824829]]) 
    &gt;&gt;&gt; lap.eigenvectors(2) 
    array([[ 0.5       ,  0.40824829], 
           [ 0.        ,  0.40824829], 
           [-0.5       ,  0.40824829], 
           [-0.5       ,  0.40824829], 
           [ 0.        ,  0.40824829], 
           [ 0.5       ,  0.40824829]]) 
    &gt;&gt;&gt; lap.eigenvectors() 
    array([[ 0.40824829,  0.28867513,  0.28867513,  0.5       ,  0.5       , 
             0.40824829], 
           [-0.40824829, -0.57735027, -0.57735027,  0.        ,  0.        , 
             0.40824829], 
           [ 0.40824829,  0.28867513,  0.28867513, -0.5       , -0.5       , 
             0.40824829], 
           [-0.40824829,  0.28867513,  0.28867513, -0.5       , -0.5       , 
             0.40824829], 
           [ 0.40824829, -0.57735027, -0.57735027,  0.        ,  0.        , 
             0.40824829], 
           [-0.40824829,  0.28867513,  0.28867513,  0.5       ,  0.5       , 
             0.40824829]]) 
 
    The two-dimensional Laplacian is illustrated on a regular grid with 
    ``grid_shape = (2, 3)`` points in each dimension. 
 
    &gt;&gt;&gt; grid_shape = (2, 3) 
    &gt;&gt;&gt; n = np.prod(grid_shape) 
 
    Numeration of grid points is as follows: 
 
    &gt;&gt;&gt; np.arange(n).reshape(grid_shape + (-1,)) 
    array([[[0], 
            [1], 
            [2]], 
    &lt;BLANKLINE&gt; 
           [[3], 
            [4], 
            [5]]]) 
 
    Each of the boundary conditions ``'dirichlet'``, ``'periodic'``, and 
    ``'neumann'`` is illustrated separately; with ``'dirichlet'`` 
 
    &gt;&gt;&gt; lap = LaplacianNd(grid_shape, boundary_conditions='dirichlet') 
    &gt;&gt;&gt; lap.tosparse() 
    &lt;Compressed Sparse Row sparse array of dtype 'int8' 
        with 20 stored elements and shape (6, 6)&gt; 
    &gt;&gt;&gt; lap.toarray() 
    array([[-4,  1,  0,  1,  0,  0], 
           [ 1, -4,  1,  0,  1,  0], 
           [ 0,  1, -4,  0,  0,  1], 
           [ 1,  0,  0, -4,  1,  0], 
           [ 0,  1,  0,  1, -4,  1], 
           [ 0,  0,  1,  0,  1, -4]], dtype=int8) 
    &gt;&gt;&gt; np.array_equal(lap.matmat(np.eye(n)), lap.toarray()) 
    True 
    &gt;&gt;&gt; np.array_equal(lap.tosparse().toarray(), lap.toarray()) 
    True 
    &gt;&gt;&gt; lap.eigenvalues() 
    array([-6.41421356, -5.        , -4.41421356, -3.58578644, -3.        , 
           -1.58578644]) 
    &gt;&gt;&gt; eigvals = eigvalsh(lap.toarray().astype(np.float64)) 
    &gt;&gt;&gt; np.allclose(lap.eigenvalues(), eigvals) 
    True 
    &gt;&gt;&gt; np.allclose(lap.toarray() @ lap.eigenvectors(), 
    ...             lap.eigenvectors() @ np.diag(lap.eigenvalues())) 
    True 
 
    with ``'periodic'`` 
 
    &gt;&gt;&gt; lap = LaplacianNd(grid_shape, boundary_conditions='periodic') 
    &gt;&gt;&gt; lap.tosparse() 
    &lt;Compressed Sparse Row sparse array of dtype 'int8' 
        with 24 stored elements and shape (6, 6)&gt; 
    &gt;&gt;&gt; lap.toarray() 
        array([[-4,  1,  1,  2,  0,  0], 
               [ 1, -4,  1,  0,  2,  0], 
               [ 1,  1, -4,  0,  0,  2], 
               [ 2,  0,  0, -4,  1,  1], 
               [ 0,  2,  0,  1, -4,  1], 
               [ 0,  0,  2,  1,  1, -4]], dtype=int8) 
    &gt;&gt;&gt; np.array_equal(lap.matmat(np.eye(n)), lap.toarray()) 
    True 
    &gt;&gt;&gt; np.array_equal(lap.tosparse().toarray(), lap.toarray()) 
    True 
    &gt;&gt;&gt; lap.eigenvalues() 
    array([-7., -7., -4., -3., -3.,  0.]) 
    &gt;&gt;&gt; eigvals = eigvalsh(lap.toarray().astype(np.float64)) 
    &gt;&gt;&gt; np.allclose(lap.eigenvalues(), eigvals) 
    True 
    &gt;&gt;&gt; np.allclose(lap.toarray() @ lap.eigenvectors(), 
    ...             lap.eigenvectors() @ np.diag(lap.eigenvalues())) 
    True 
 
    and with ``'neumann'`` 
 
    &gt;&gt;&gt; lap = LaplacianNd(grid_shape, boundary_conditions='neumann') 
    &gt;&gt;&gt; lap.tosparse() 
    &lt;Compressed Sparse Row sparse array of dtype 'int8' 
        with 20 stored elements and shape (6, 6)&gt; 
    &gt;&gt;&gt; lap.toarray() 
    array([[-2,  1,  0,  1,  0,  0], 
           [ 1, -3,  1,  0,  1,  0], 
           [ 0,  1, -2,  0,  0,  1], 
           [ 1,  0,  0, -2,  1,  0], 
           [ 0,  1,  0,  1, -3,  1], 
           [ 0,  0,  1,  0,  1, -2]]) 
    &gt;&gt;&gt; np.array_equal(lap.matmat(np.eye(n)), lap.toarray()) 
    True 
    &gt;&gt;&gt; np.array_equal(lap.tosparse().toarray(), lap.toarray()) 
    True 
    &gt;&gt;&gt; lap.eigenvalues() 
    array([-5., -3., -3., -2., -1.,  0.]) 
    &gt;&gt;&gt; eigvals = eigvalsh(lap.toarray().astype(np.float64)) 
    &gt;&gt;&gt; np.allclose(lap.eigenvalues(), eigvals) 
    True 
    &gt;&gt;&gt; np.allclose(lap.toarray() @ lap.eigenvectors(), 
    ...             lap.eigenvectors() @ np.diag(lap.eigenvalues())) 
    True 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">grid_shape</span><span class="s2">, *,</span>
                 <span class="s1">boundary_conditions</span><span class="s2">=</span><span class="s3">'neumann'</span><span class="s2">,</span>
                 <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span><span class="s2">):</span>

        <span class="s0">if </span><span class="s1">boundary_conditions </span><span class="s0">not in </span><span class="s2">(</span><span class="s3">'dirichlet'</span><span class="s2">, </span><span class="s3">'neumann'</span><span class="s2">, </span><span class="s3">'periodic'</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s3">f&quot;Unknown value </span><span class="s0">{</span><span class="s1">boundary_conditions</span><span class="s0">!r} </span><span class="s3">is given for &quot;</span>
                <span class="s3">&quot;'boundary_conditions' parameter. The valid options are &quot;</span>
                <span class="s3">&quot;'dirichlet', 'periodic', and 'neumann' (default).&quot;</span>
            <span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">grid_shape </span><span class="s2">= </span><span class="s1">grid_shape</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">boundary_conditions </span><span class="s2">= </span><span class="s1">boundary_conditions</span>
        <span class="s4"># LaplacianNd folds all dimensions in `grid_shape` into a single one</span>
        <span class="s1">N </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">prod</span><span class="s2">(</span><span class="s1">grid_shape</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=(</span><span class="s1">N</span><span class="s2">, </span><span class="s1">N</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">_eigenvalue_ordering</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Compute `m` largest eigenvalues in each of the ``N`` directions, 
        i.e., up to ``m * N`` total, order them and return `m` largest. 
        &quot;&quot;&quot;</span>
        <span class="s1">grid_shape </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">grid_shape</span>
        <span class="s0">if </span><span class="s1">m </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">(</span><span class="s1">grid_shape</span><span class="s2">)</span>
            <span class="s1">Leig </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">grid_shape</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">grid_shape_min </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">grid_shape</span><span class="s2">,</span>
                                 <span class="s1">tuple</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones_like</span><span class="s2">(</span><span class="s1">grid_shape</span><span class="s2">) * </span><span class="s1">m</span><span class="s2">))</span>
            <span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">(</span><span class="s1">grid_shape_min</span><span class="s2">)</span>
            <span class="s1">Leig </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">grid_shape_min</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">n </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">grid_shape</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">boundary_conditions </span><span class="s2">== </span><span class="s3">'dirichlet'</span><span class="s2">:</span>
                <span class="s1">Leig </span><span class="s2">+= -</span><span class="s6">4 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">* (</span><span class="s1">j </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">) / (</span><span class="s6">2 </span><span class="s2">* (</span><span class="s1">n </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">))) ** </span><span class="s6">2</span>
            <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">boundary_conditions </span><span class="s2">== </span><span class="s3">'neumann'</span><span class="s2">:</span>
                <span class="s1">Leig </span><span class="s2">+= -</span><span class="s6">4 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">* </span><span class="s1">j </span><span class="s2">/ (</span><span class="s6">2 </span><span class="s2">* </span><span class="s1">n</span><span class="s2">)) ** </span><span class="s6">2</span>
            <span class="s0">else</span><span class="s2">:  </span><span class="s4"># boundary_conditions == 'periodic'</span>
                <span class="s1">Leig </span><span class="s2">+= -</span><span class="s6">4 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">floor</span><span class="s2">((</span><span class="s1">j </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">) / </span><span class="s6">2</span><span class="s2">) / </span><span class="s1">n</span><span class="s2">) ** </span><span class="s6">2</span>

        <span class="s1">Leig_ravel </span><span class="s2">= </span><span class="s1">Leig</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">()</span>
        <span class="s1">ind </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argsort</span><span class="s2">(</span><span class="s1">Leig_ravel</span><span class="s2">)</span>
        <span class="s1">eigenvalues </span><span class="s2">= </span><span class="s1">Leig_ravel</span><span class="s2">[</span><span class="s1">ind</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">m </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">eigenvalues </span><span class="s2">= </span><span class="s1">eigenvalues</span><span class="s2">[-</span><span class="s1">m</span><span class="s2">:]</span>
            <span class="s1">ind </span><span class="s2">= </span><span class="s1">ind</span><span class="s2">[-</span><span class="s1">m</span><span class="s2">:]</span>

        <span class="s0">return </span><span class="s1">eigenvalues</span><span class="s2">, </span><span class="s1">ind</span>

    <span class="s0">def </span><span class="s1">eigenvalues</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Return the requested number of eigenvalues. 
         
        Parameters 
        ---------- 
        m : int, optional 
            The positive number of smallest eigenvalues to return. 
            If not provided, then all eigenvalues will be returned. 
             
        Returns 
        ------- 
        eigenvalues : float array 
            The requested `m` smallest or all eigenvalues, in ascending order. 
        &quot;&quot;&quot;</span>
        <span class="s1">eigenvalues</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_eigenvalue_ordering</span><span class="s2">(</span><span class="s1">m</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">eigenvalues</span>

    <span class="s0">def </span><span class="s1">_ev1d</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">n</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Return 1 eigenvector in 1d with index `j` 
        and number of grid points `n` where ``j &lt; n``.  
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">boundary_conditions </span><span class="s2">== </span><span class="s3">'dirichlet'</span><span class="s2">:</span>
            <span class="s1">i </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">* (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n</span><span class="s2">) + </span><span class="s6">1</span><span class="s2">) / (</span><span class="s1">n </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">)</span>
            <span class="s1">ev </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s6">2. </span><span class="s2">/ (</span><span class="s1">n </span><span class="s2">+ </span><span class="s6">1.</span><span class="s2">)) * </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">i </span><span class="s2">* (</span><span class="s1">j </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">))</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">boundary_conditions </span><span class="s2">== </span><span class="s3">'neumann'</span><span class="s2">:</span>
            <span class="s1">i </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">* (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n</span><span class="s2">) + </span><span class="s6">0.5</span><span class="s2">) / </span><span class="s1">n</span>
            <span class="s1">ev </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">((</span><span class="s6">1. </span><span class="s0">if </span><span class="s1">j </span><span class="s2">== </span><span class="s6">0 </span><span class="s0">else </span><span class="s6">2.</span><span class="s2">) / </span><span class="s1">n</span><span class="s2">) * </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">i </span><span class="s2">* </span><span class="s1">j</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:  </span><span class="s4"># boundary_conditions == 'periodic'</span>
            <span class="s0">if </span><span class="s1">j </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s1">ev </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s6">1. </span><span class="s2">/ </span><span class="s1">n</span><span class="s2">) * </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">j </span><span class="s2">+ </span><span class="s6">1 </span><span class="s2">== </span><span class="s1">n </span><span class="s0">and </span><span class="s1">n </span><span class="s2">% </span><span class="s6">2 </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s1">ev </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s6">1. </span><span class="s2">/ </span><span class="s1">n</span><span class="s2">) * </span><span class="s1">np</span><span class="s2">.</span><span class="s1">tile</span><span class="s2">([</span><span class="s6">1</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">], </span><span class="s1">n</span><span class="s2">//</span><span class="s6">2</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">i </span><span class="s2">= </span><span class="s6">2. </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">* (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n</span><span class="s2">) + </span><span class="s6">0.5</span><span class="s2">) / </span><span class="s1">n</span>
                <span class="s1">ev </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s6">2. </span><span class="s2">/ </span><span class="s1">n</span><span class="s2">) * </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">i </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">floor</span><span class="s2">((</span><span class="s1">j </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">) / </span><span class="s6">2</span><span class="s2">))</span>
        <span class="s4"># make small values exact zeros correcting round-off errors</span>
        <span class="s4"># due to symmetry of eigenvectors the exact 0. is correct </span>
        <span class="s1">ev</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">ev</span><span class="s2">) &lt; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">).</span><span class="s1">eps</span><span class="s2">] = </span><span class="s6">0.</span>
        <span class="s0">return </span><span class="s1">ev</span>

    <span class="s0">def </span><span class="s1">_one_eve</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Return 1 eigenvector in Nd with multi-index `j` 
        as a tensor product of the corresponding 1d eigenvectors.  
        &quot;&quot;&quot;</span>
        <span class="s1">phi </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ev1d</span><span class="s2">(</span><span class="s1">j</span><span class="s2">, </span><span class="s1">n</span><span class="s2">) </span><span class="s0">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">n </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">grid_shape</span><span class="s2">)]</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">phi</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s0">for </span><span class="s1">phi </span><span class="s0">in </span><span class="s1">phi</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:]:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">tensordot</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">phi</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">=</span><span class="s6">0</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">result</span><span class="s2">).</span><span class="s1">ravel</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">eigenvectors</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Return the requested number of eigenvectors for ordered eigenvalues. 
         
        Parameters 
        ---------- 
        m : int, optional 
            The positive number of eigenvectors to return. If not provided, 
            then all eigenvectors will be returned. 
             
        Returns 
        ------- 
        eigenvectors : float array 
            An array with columns made of the requested `m` or all eigenvectors. 
            The columns are ordered according to the `m` ordered eigenvalues.  
        &quot;&quot;&quot;</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">ind </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_eigenvalue_ordering</span><span class="s2">(</span><span class="s1">m</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">m </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">grid_shape_min </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">grid_shape</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">grid_shape_min </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">grid_shape</span><span class="s2">,</span>
                                <span class="s1">tuple</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones_like</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">grid_shape</span><span class="s2">) * </span><span class="s1">m</span><span class="s2">))</span>

        <span class="s1">N_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">unravel_index</span><span class="s2">(</span><span class="s1">ind</span><span class="s2">, </span><span class="s1">grid_shape_min</span><span class="s2">)</span>
        <span class="s1">N_indices </span><span class="s2">= [</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(*</span><span class="s1">N_indices</span><span class="s2">)]</span>
        <span class="s1">eigenvectors_list </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_one_eve</span><span class="s2">(</span><span class="s1">k</span><span class="s2">) </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">N_indices</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">column_stack</span><span class="s2">(</span><span class="s1">eigenvectors_list</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">toarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Converts the Laplacian data to a dense array. 
 
        Returns 
        ------- 
        L : ndarray 
            The shape is ``(N, N)`` where ``N = np.prod(grid_shape)``. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">grid_shape </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">grid_shape</span>
        <span class="s1">n </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">prod</span><span class="s2">(</span><span class="s1">grid_shape</span><span class="s2">)</span>
        <span class="s1">L </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">([</span><span class="s1">n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span><span class="s2">)</span>
        <span class="s4"># Scratch arrays</span>
        <span class="s1">L_i </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">L</span><span class="s2">)</span>
        <span class="s1">Ltemp </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">L</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">dim </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">grid_shape</span><span class="s2">):</span>
            <span class="s4"># Start zeroing out L_i</span>
            <span class="s1">L_i</span><span class="s2">[:] = </span><span class="s6">0</span>
            <span class="s4"># Allocate the top left corner with the kernel of L_i</span>
            <span class="s4"># Einsum returns writable view of arrays</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">einsum</span><span class="s2">(</span><span class="s3">&quot;ii-&gt;i&quot;</span><span class="s2">, </span><span class="s1">L_i</span><span class="s2">[:</span><span class="s1">dim</span><span class="s2">, :</span><span class="s1">dim</span><span class="s2">])[:] = -</span><span class="s6">2</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">einsum</span><span class="s2">(</span><span class="s3">&quot;ii-&gt;i&quot;</span><span class="s2">, </span><span class="s1">L_i</span><span class="s2">[: </span><span class="s1">dim </span><span class="s2">- </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">:</span><span class="s1">dim</span><span class="s2">])[:] = </span><span class="s6">1</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">einsum</span><span class="s2">(</span><span class="s3">&quot;ii-&gt;i&quot;</span><span class="s2">, </span><span class="s1">L_i</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:</span><span class="s1">dim</span><span class="s2">, : </span><span class="s1">dim </span><span class="s2">- </span><span class="s6">1</span><span class="s2">])[:] = </span><span class="s6">1</span>

            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">boundary_conditions </span><span class="s2">== </span><span class="s3">'neumann'</span><span class="s2">:</span>
                <span class="s1">L_i</span><span class="s2">[</span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">] = -</span><span class="s6">1</span>
                <span class="s1">L_i</span><span class="s2">[</span><span class="s1">dim </span><span class="s2">- </span><span class="s6">1</span><span class="s2">, </span><span class="s1">dim </span><span class="s2">- </span><span class="s6">1</span><span class="s2">] = -</span><span class="s6">1</span>
            <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">boundary_conditions </span><span class="s2">== </span><span class="s3">'periodic'</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">dim </span><span class="s2">&gt; </span><span class="s6">1</span><span class="s2">:</span>
                    <span class="s1">L_i</span><span class="s2">[</span><span class="s6">0</span><span class="s2">, </span><span class="s1">dim </span><span class="s2">- </span><span class="s6">1</span><span class="s2">] += </span><span class="s6">1</span>
                    <span class="s1">L_i</span><span class="s2">[</span><span class="s1">dim </span><span class="s2">- </span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">] += </span><span class="s6">1</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">L_i</span><span class="s2">[</span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">] += </span><span class="s6">1</span>

            <span class="s4"># kron is too slow for large matrices hence the next two tricks</span>
            <span class="s4"># 1- kron(eye, mat) is block_diag(mat, mat, ...)</span>
            <span class="s4"># 2- kron(mat, eye) can be performed by 4d stride trick</span>

            <span class="s4"># 1-</span>
            <span class="s1">new_dim </span><span class="s2">= </span><span class="s1">dim</span>
            <span class="s4"># for block_diag we tile the top left portion on the diagonal</span>
            <span class="s0">if </span><span class="s1">ind </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s1">tiles </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">prod</span><span class="s2">(</span><span class="s1">grid_shape</span><span class="s2">[:</span><span class="s1">ind</span><span class="s2">])</span>
                <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s1">tiles</span><span class="s2">):</span>
                    <span class="s1">L_i</span><span class="s2">[</span><span class="s1">j</span><span class="s2">*</span><span class="s1">dim</span><span class="s2">:(</span><span class="s1">j</span><span class="s2">+</span><span class="s6">1</span><span class="s2">)*</span><span class="s1">dim</span><span class="s2">, </span><span class="s1">j</span><span class="s2">*</span><span class="s1">dim</span><span class="s2">:(</span><span class="s1">j</span><span class="s2">+</span><span class="s6">1</span><span class="s2">)*</span><span class="s1">dim</span><span class="s2">] = </span><span class="s1">L_i</span><span class="s2">[:</span><span class="s1">dim</span><span class="s2">, :</span><span class="s1">dim</span><span class="s2">]</span>
                    <span class="s1">new_dim </span><span class="s2">+= </span><span class="s1">dim</span>
            <span class="s4"># 2-</span>
            <span class="s4"># we need the keep L_i, but reset the array</span>
            <span class="s1">Ltemp</span><span class="s2">[:</span><span class="s1">new_dim</span><span class="s2">, :</span><span class="s1">new_dim</span><span class="s2">] = </span><span class="s1">L_i</span><span class="s2">[:</span><span class="s1">new_dim</span><span class="s2">, :</span><span class="s1">new_dim</span><span class="s2">]</span>
            <span class="s1">tiles </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">prod</span><span class="s2">(</span><span class="s1">grid_shape</span><span class="s2">[</span><span class="s1">ind</span><span class="s2">+</span><span class="s6">1</span><span class="s2">:]))</span>
            <span class="s4"># Zero out the top left, the rest is already 0</span>
            <span class="s1">L_i</span><span class="s2">[:</span><span class="s1">new_dim</span><span class="s2">, :</span><span class="s1">new_dim</span><span class="s2">] = </span><span class="s6">0</span>
            <span class="s1">idx </span><span class="s2">= [</span><span class="s1">x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">tiles</span><span class="s2">)]</span>
            <span class="s1">L_i</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span>
                <span class="s2">(</span><span class="s1">new_dim</span><span class="s2">, </span><span class="s1">tiles</span><span class="s2">,</span>
                 <span class="s1">new_dim</span><span class="s2">, </span><span class="s1">tiles</span><span class="s2">)</span>
                <span class="s2">)[:, </span><span class="s1">idx</span><span class="s2">, :, </span><span class="s1">idx</span><span class="s2">] = </span><span class="s1">Ltemp</span><span class="s2">[:</span><span class="s1">new_dim</span><span class="s2">, :</span><span class="s1">new_dim</span><span class="s2">]</span>

            <span class="s1">L </span><span class="s2">+= </span><span class="s1">L_i</span>

        <span class="s0">return </span><span class="s1">L</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">tosparse</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Constructs a sparse array from the Laplacian data. The returned sparse 
        array format is dependent on the selected boundary conditions. 
 
        Returns 
        ------- 
        L : scipy.sparse.sparray 
            The shape is ``(N, N)`` where ``N = np.prod(grid_shape)``. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">N </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">grid_shape</span><span class="s2">)</span>
        <span class="s1">p </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">prod</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">grid_shape</span><span class="s2">)</span>
        <span class="s1">L </span><span class="s2">= </span><span class="s1">dia_array</span><span class="s2">((</span><span class="s1">p</span><span class="s2">, </span><span class="s1">p</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">N</span><span class="s2">):</span>
            <span class="s1">dim </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">grid_shape</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">([</span><span class="s6">3</span><span class="s2">, </span><span class="s1">dim</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span><span class="s2">)</span>
            <span class="s1">data</span><span class="s2">[</span><span class="s6">1</span><span class="s2">, :] *= -</span><span class="s6">2</span>

            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">boundary_conditions </span><span class="s2">== </span><span class="s3">'neumann'</span><span class="s2">:</span>
                <span class="s1">data</span><span class="s2">[</span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">] = -</span><span class="s6">1</span>
                <span class="s1">data</span><span class="s2">[</span><span class="s6">1</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">] = -</span><span class="s6">1</span>

            <span class="s1">L_i </span><span class="s2">= </span><span class="s1">dia_array</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, [-</span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">]), </span><span class="s1">shape</span><span class="s2">=(</span><span class="s1">dim</span><span class="s2">, </span><span class="s1">dim</span><span class="s2">),</span>
                            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span>
                            <span class="s2">)</span>

            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">boundary_conditions </span><span class="s2">== </span><span class="s3">'periodic'</span><span class="s2">:</span>
                <span class="s1">t </span><span class="s2">= </span><span class="s1">dia_array</span><span class="s2">((</span><span class="s1">dim</span><span class="s2">, </span><span class="s1">dim</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span><span class="s2">)</span>
                <span class="s1">t</span><span class="s2">.</span><span class="s1">setdiag</span><span class="s2">([</span><span class="s6">1</span><span class="s2">], </span><span class="s1">k</span><span class="s2">=-</span><span class="s1">dim</span><span class="s2">+</span><span class="s6">1</span><span class="s2">)</span>
                <span class="s1">t</span><span class="s2">.</span><span class="s1">setdiag</span><span class="s2">([</span><span class="s6">1</span><span class="s2">], </span><span class="s1">k</span><span class="s2">=</span><span class="s1">dim</span><span class="s2">-</span><span class="s6">1</span><span class="s2">)</span>
                <span class="s1">L_i </span><span class="s2">+= </span><span class="s1">t</span>

            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">i</span><span class="s2">):</span>
                <span class="s1">L_i </span><span class="s2">= </span><span class="s1">kron</span><span class="s2">(</span><span class="s1">eye</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">grid_shape</span><span class="s2">[</span><span class="s1">j</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span><span class="s2">), </span><span class="s1">L_i</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">i </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">, </span><span class="s1">N</span><span class="s2">):</span>
                <span class="s1">L_i </span><span class="s2">= </span><span class="s1">kron</span><span class="s2">(</span><span class="s1">L_i</span><span class="s2">, </span><span class="s1">eye</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">grid_shape</span><span class="s2">[</span><span class="s1">j</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span><span class="s2">))</span>
            <span class="s1">L </span><span class="s2">+= </span><span class="s1">L_i</span>
        <span class="s0">return </span><span class="s1">L</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_matvec</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s1">grid_shape </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">grid_shape</span>
        <span class="s1">N </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">grid_shape</span><span class="s2">)</span>
        <span class="s1">X </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">grid_shape </span><span class="s2">+ (-</span><span class="s6">1</span><span class="s2">,))</span>
        <span class="s1">Y </span><span class="s2">= -</span><span class="s6">2 </span><span class="s2">* </span><span class="s1">N </span><span class="s2">* </span><span class="s1">X</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">N</span><span class="s2">):</span>
            <span class="s1">Y </span><span class="s2">+= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">roll</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">i</span><span class="s2">)</span>
            <span class="s1">Y </span><span class="s2">+= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">roll</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">i</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">boundary_conditions </span><span class="s0">in </span><span class="s2">(</span><span class="s3">'neumann'</span><span class="s2">, </span><span class="s3">'dirichlet'</span><span class="s2">):</span>
                <span class="s1">Y</span><span class="s2">[(</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),)*</span><span class="s1">i </span><span class="s2">+ (</span><span class="s6">0</span><span class="s2">,) + (</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),)*(</span><span class="s1">N</span><span class="s2">-</span><span class="s1">i</span><span class="s2">-</span><span class="s6">1</span><span class="s2">)</span>
                  <span class="s2">] -= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">roll</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">i</span><span class="s2">)[</span>
                    <span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),) * </span><span class="s1">i </span><span class="s2">+ (</span><span class="s6">0</span><span class="s2">,) + (</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),) * (</span><span class="s1">N</span><span class="s2">-</span><span class="s1">i</span><span class="s2">-</span><span class="s6">1</span><span class="s2">)</span>
                <span class="s2">]</span>
                <span class="s1">Y</span><span class="s2">[</span>
                    <span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),) * </span><span class="s1">i </span><span class="s2">+ (-</span><span class="s6">1</span><span class="s2">,) + (</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),) * (</span><span class="s1">N</span><span class="s2">-</span><span class="s1">i</span><span class="s2">-</span><span class="s6">1</span><span class="s2">)</span>
                <span class="s2">] -= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">roll</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">i</span><span class="s2">)[</span>
                    <span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),) * </span><span class="s1">i </span><span class="s2">+ (-</span><span class="s6">1</span><span class="s2">,) + (</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),) * (</span><span class="s1">N</span><span class="s2">-</span><span class="s1">i</span><span class="s2">-</span><span class="s6">1</span><span class="s2">)</span>
                <span class="s2">]</span>

                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">boundary_conditions </span><span class="s2">== </span><span class="s3">'neumann'</span><span class="s2">:</span>
                    <span class="s1">Y</span><span class="s2">[</span>
                        <span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),) * </span><span class="s1">i </span><span class="s2">+ (</span><span class="s6">0</span><span class="s2">,) + (</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),) * (</span><span class="s1">N</span><span class="s2">-</span><span class="s1">i</span><span class="s2">-</span><span class="s6">1</span><span class="s2">)</span>
                    <span class="s2">] += </span><span class="s1">np</span><span class="s2">.</span><span class="s1">roll</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">i</span><span class="s2">)[</span>
                        <span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),) * </span><span class="s1">i </span><span class="s2">+ (</span><span class="s6">0</span><span class="s2">,) + (</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),) * (</span><span class="s1">N</span><span class="s2">-</span><span class="s1">i</span><span class="s2">-</span><span class="s6">1</span><span class="s2">)</span>
                    <span class="s2">]</span>
                    <span class="s1">Y</span><span class="s2">[</span>
                        <span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),) * </span><span class="s1">i </span><span class="s2">+ (-</span><span class="s6">1</span><span class="s2">,) + (</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),) * (</span><span class="s1">N</span><span class="s2">-</span><span class="s1">i</span><span class="s2">-</span><span class="s6">1</span><span class="s2">)</span>
                    <span class="s2">] += </span><span class="s1">np</span><span class="s2">.</span><span class="s1">roll</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">i</span><span class="s2">)[</span>
                        <span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),) * </span><span class="s1">i </span><span class="s2">+ (-</span><span class="s6">1</span><span class="s2">,) + (</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),) * (</span><span class="s1">N</span><span class="s2">-</span><span class="s1">i</span><span class="s2">-</span><span class="s6">1</span><span class="s2">)</span>
                    <span class="s2">]</span>

        <span class="s0">return </span><span class="s1">Y</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s6">1</span><span class="s2">, </span><span class="s1">X</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">])</span>

    <span class="s0">def </span><span class="s1">_matmat</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_matvec</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_adjoint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">_transpose</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span>


<span class="s0">class </span><span class="s1">Sakurai</span><span class="s2">(</span><span class="s1">LinearOperator</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Construct a Sakurai matrix in various formats and its eigenvalues. 
 
    Constructs the &quot;Sakurai&quot; matrix motivated by reference [1]_: 
    square real symmetric positive definite and 5-diagonal 
    with the main digonal ``[5, 6, 6, ..., 6, 6, 5], the ``+1`` and ``-1`` 
    diagonals filled with ``-4``, and the ``+2`` and ``-2`` diagonals 
    made of ``1``. Its eigenvalues are analytically known to be 
    ``16. * np.power(np.cos(0.5 * k * np.pi / (n + 1)), 4)``. 
    The matrix gets ill-conditioned with its size growing. 
    It is useful for testing and benchmarking sparse eigenvalue solvers 
    especially those taking advantage of its banded 5-diagonal structure. 
    See the notes below for details. 
 
    Parameters 
    ---------- 
    n : int 
        The size of the matrix. 
    dtype : dtype 
        Numerical type of the array. Default is ``np.int8``. 
 
    Methods 
    ------- 
    toarray() 
        Construct a dense array from Laplacian data 
    tosparse() 
        Construct a sparse array from Laplacian data 
    tobanded() 
        The Sakurai matrix in the format for banded symmetric matrices, 
        i.e., (3, n) ndarray with 3 upper diagonals 
        placing the main diagonal at the bottom. 
    eigenvalues 
        All eigenvalues of the Sakurai matrix ordered ascending. 
 
    Notes 
    ----- 
    Reference [1]_ introduces a generalized eigenproblem for the matrix pair 
    `A` and `B` where `A` is the identity so we turn it into an eigenproblem 
    just for the matrix `B` that this function outputs in various formats 
    together with its eigenvalues. 
     
    .. versionadded:: 1.12.0 
 
    References 
    ---------- 
    .. [1] T. Sakurai, H. Tadano, Y. Inadomi, and U. Nagashima, 
       &quot;A moment-based method for large-scale generalized 
       eigenvalue problems&quot;, 
       Appl. Num. Anal. Comp. Math. Vol. 1 No. 2 (2004). 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse.linalg._special_sparse_arrays import Sakurai 
    &gt;&gt;&gt; from scipy.linalg import eig_banded 
    &gt;&gt;&gt; n = 6 
    &gt;&gt;&gt; sak = Sakurai(n) 
 
    Since all matrix entries are small integers, ``'int8'`` is 
    the default dtype for storing matrix representations. 
 
    &gt;&gt;&gt; sak.toarray() 
    array([[ 5, -4,  1,  0,  0,  0], 
           [-4,  6, -4,  1,  0,  0], 
           [ 1, -4,  6, -4,  1,  0], 
           [ 0,  1, -4,  6, -4,  1], 
           [ 0,  0,  1, -4,  6, -4], 
           [ 0,  0,  0,  1, -4,  5]], dtype=int8) 
    &gt;&gt;&gt; sak.tobanded() 
    array([[ 1,  1,  1,  1,  1,  1], 
           [-4, -4, -4, -4, -4, -4], 
           [ 5,  6,  6,  6,  6,  5]], dtype=int8) 
    &gt;&gt;&gt; sak.tosparse() 
    &lt;DIAgonal sparse array of dtype 'int8' 
        with 24 stored elements (5 diagonals) and shape (6, 6)&gt; 
    &gt;&gt;&gt; np.array_equal(sak.dot(np.eye(n)), sak.tosparse().toarray()) 
    True 
    &gt;&gt;&gt; sak.eigenvalues() 
    array([0.03922866, 0.56703972, 2.41789479, 5.97822974, 
           10.54287655, 14.45473055]) 
    &gt;&gt;&gt; sak.eigenvalues(2) 
    array([0.03922866, 0.56703972]) 
 
    The banded form can be used in scipy functions for banded matrices, e.g., 
 
    &gt;&gt;&gt; e = eig_banded(sak.tobanded(), eigvals_only=True) 
    &gt;&gt;&gt; np.allclose(sak.eigenvalues, e, atol= n * n * n * np.finfo(float).eps) 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int8</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">n </span><span class="s2">= </span><span class="s1">n</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">= </span><span class="s1">dtype</span>
        <span class="s1">shape </span><span class="s2">= (</span><span class="s1">n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">eigenvalues</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Return the requested number of eigenvalues. 
         
        Parameters 
        ---------- 
        m : int, optional 
            The positive number of smallest eigenvalues to return. 
            If not provided, then all eigenvalues will be returned. 
             
        Returns 
        ------- 
        eigenvalues : `np.float64` array 
            The requested `m` smallest or all eigenvalues, in ascending order. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">m </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">m </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">n</span>
        <span class="s1">k </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">n </span><span class="s2">+ </span><span class="s6">1 </span><span class="s2">-</span><span class="s1">m</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">n </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">flip</span><span class="s2">(</span><span class="s6">16. </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">power</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s6">0.5 </span><span class="s2">* </span><span class="s1">k </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">/ (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">n </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">)), </span><span class="s6">4</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">tobanded</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Construct the Sakurai matrix as a banded array. 
        &quot;&quot;&quot;</span>
        <span class="s1">d0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">r_</span><span class="s2">[</span><span class="s6">5</span><span class="s2">, </span><span class="s6">6 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">n </span><span class="s2">- </span><span class="s6">2</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">), </span><span class="s6">5</span><span class="s2">]</span>
        <span class="s1">d1 </span><span class="s2">= -</span><span class="s6">4 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">d2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">d2</span><span class="s2">, </span><span class="s1">d1</span><span class="s2">, </span><span class="s1">d0</span><span class="s2">]).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">tosparse</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Construct the Sakurai matrix is a sparse format. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">sparse </span><span class="s0">import </span><span class="s1">spdiags</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tobanded</span><span class="s2">()</span>
        <span class="s4"># the banded format has the main diagonal at the bottom</span>
        <span class="s4"># `spdiags` has no `dtype` parameter so inherits dtype from banded</span>
        <span class="s0">return </span><span class="s1">spdiags</span><span class="s2">([</span><span class="s1">d</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">d</span><span class="s2">[</span><span class="s6">1</span><span class="s2">], </span><span class="s1">d</span><span class="s2">[</span><span class="s6">2</span><span class="s2">], </span><span class="s1">d</span><span class="s2">[</span><span class="s6">1</span><span class="s2">], </span><span class="s1">d</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]], [-</span><span class="s6">2</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">2</span><span class="s2">],</span>
                       <span class="s1">self</span><span class="s2">.</span><span class="s1">n</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">n</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">toarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tosparse</span><span class="s2">().</span><span class="s1">toarray</span><span class="s2">()</span>
    
    <span class="s0">def </span><span class="s1">_matvec</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Construct matrix-free callable banded-matrix-vector multiplication by 
        the Sakurai matrix without constructing or storing the matrix itself 
        using the knowledge of its entries and the 5-diagonal format. 
        &quot;&quot;&quot;</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">n</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">)</span>
        <span class="s1">result_dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">promote_types</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">sx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">result_dtype</span><span class="s2">)</span>
        <span class="s1">sx</span><span class="s2">[</span><span class="s6">0</span><span class="s2">, :] = </span><span class="s6">5 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[</span><span class="s6">0</span><span class="s2">, :] - </span><span class="s6">4 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">, :] + </span><span class="s1">x</span><span class="s2">[</span><span class="s6">2</span><span class="s2">, :]</span>
        <span class="s1">sx</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">, :] = </span><span class="s6">5 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">, :] - </span><span class="s6">4 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[-</span><span class="s6">2</span><span class="s2">, :] + </span><span class="s1">x</span><span class="s2">[-</span><span class="s6">3</span><span class="s2">, :]</span>
        <span class="s1">sx</span><span class="s2">[</span><span class="s6">1</span><span class="s2">: -</span><span class="s6">1</span><span class="s2">, :] = (</span><span class="s6">6 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">: -</span><span class="s6">1</span><span class="s2">, :] - </span><span class="s6">4 </span><span class="s2">* (</span><span class="s1">x</span><span class="s2">[:-</span><span class="s6">2</span><span class="s2">, :] + </span><span class="s1">x</span><span class="s2">[</span><span class="s6">2</span><span class="s2">:, :])</span>
                      <span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pad</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[:-</span><span class="s6">3</span><span class="s2">, :], ((</span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">), (</span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)))</span>
                      <span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pad</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[</span><span class="s6">3</span><span class="s2">:, :], ((</span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">), (</span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">))))</span>
        <span class="s0">return </span><span class="s1">sx</span>

    <span class="s0">def </span><span class="s1">_matmat</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Construct matrix-free callable matrix-matrix multiplication by 
        the Sakurai matrix without constructing or storing the matrix itself 
        by reusing the ``_matvec(x)`` that supports both 1D and 2D arrays ``x``. 
        &quot;&quot;&quot;        </span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_matvec</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_adjoint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">_transpose</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span>


<span class="s0">class </span><span class="s1">MikotaM</span><span class="s2">(</span><span class="s1">LinearOperator</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Construct a mass matrix in various formats of Mikota pair. 
 
    The mass matrix `M` is square real diagonal 
    positive definite with entries that are reciprocal to integers. 
 
    Parameters 
    ---------- 
    shape : tuple of int 
        The shape of the matrix. 
    dtype : dtype 
        Numerical type of the array. Default is ``np.float64``. 
 
    Methods 
    ------- 
    toarray() 
        Construct a dense array from Mikota data 
    tosparse() 
        Construct a sparse array from Mikota data 
    tobanded() 
        The format for banded symmetric matrices, 
        i.e., (1, n) ndarray with the main diagonal. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">shape</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">= </span><span class="s1">dtype</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_diag</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># The matrix is constructed from its diagonal 1 / [1, ..., N+1];</span>
        <span class="s4"># compute in a function to avoid duplicated code &amp; storage footprint</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s6">1. </span><span class="s2">/ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] + </span><span class="s6">1</span><span class="s2">)).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">tobanded</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_diag</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">tosparse</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">sparse </span><span class="s0">import </span><span class="s1">diags</span>
        <span class="s0">return </span><span class="s1">diags</span><span class="s2">([</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_diag</span><span class="s2">()], [</span><span class="s6">0</span><span class="s2">], </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">toarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diag</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_diag</span><span class="s2">()).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_matvec</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Construct matrix-free callable banded-matrix-vector multiplication by 
        the Mikota mass matrix without constructing or storing the matrix itself 
        using the knowledge of its entries and the diagonal format. 
        &quot;&quot;&quot;</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], -</span><span class="s6">1</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_diag</span><span class="s2">()[:, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">] * </span><span class="s1">x</span>

    <span class="s0">def </span><span class="s1">_matmat</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Construct matrix-free callable matrix-matrix multiplication by 
        the Mikota mass matrix without constructing or storing the matrix itself 
        by reusing the ``_matvec(x)`` that supports both 1D and 2D arrays ``x``. 
        &quot;&quot;&quot;     </span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_matvec</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_adjoint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">_transpose</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span>


<span class="s0">class </span><span class="s1">MikotaK</span><span class="s2">(</span><span class="s1">LinearOperator</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Construct a stiffness matrix in various formats of Mikota pair. 
 
    The stiffness matrix `K` is square real tri-diagonal symmetric 
    positive definite with integer entries.  
 
    Parameters 
    ---------- 
    shape : tuple of int 
        The shape of the matrix. 
    dtype : dtype 
        Numerical type of the array. Default is ``np.int32``. 
 
    Methods 
    ------- 
    toarray() 
        Construct a dense array from Mikota data 
    tosparse() 
        Construct a sparse array from Mikota data 
    tobanded() 
        The format for banded symmetric matrices, 
        i.e., (2, n) ndarray with 2 upper diagonals 
        placing the main diagonal at the bottom. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int32</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">shape</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">= </span><span class="s1">dtype</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s4"># The matrix is constructed from its diagonals;</span>
        <span class="s4"># we precompute these to avoid duplicating the computation</span>
        <span class="s1">n </span><span class="s2">= </span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_diag0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s6">2 </span><span class="s2">* </span><span class="s1">n </span><span class="s2">- </span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, -</span><span class="s6">2</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_diag1 </span><span class="s2">= - </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n </span><span class="s2">- </span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">tobanded</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">np</span><span class="s2">.</span><span class="s1">pad</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_diag1</span><span class="s2">, (</span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">), </span><span class="s3">'constant'</span><span class="s2">), </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_diag0</span><span class="s2">])</span>

    <span class="s0">def </span><span class="s1">tosparse</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">sparse </span><span class="s0">import </span><span class="s1">diags</span>
        <span class="s0">return </span><span class="s1">diags</span><span class="s2">([</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_diag1</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_diag0</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_diag1</span><span class="s2">], [-</span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">],</span>
                     <span class="s1">shape</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">toarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tosparse</span><span class="s2">().</span><span class="s1">toarray</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">_matvec</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Construct matrix-free callable banded-matrix-vector multiplication by 
        the Mikota stiffness matrix without constructing or storing the matrix 
        itself using the knowledge of its entries and the 3-diagonal format. 
        &quot;&quot;&quot;</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], -</span><span class="s6">1</span><span class="s2">)</span>
        <span class="s1">result_dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">promote_types</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">kx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">result_dtype</span><span class="s2">)</span>
        <span class="s1">d1 </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_diag1</span>
        <span class="s1">d0 </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_diag0</span>
        <span class="s1">kx</span><span class="s2">[</span><span class="s6">0</span><span class="s2">, :] = </span><span class="s1">d0</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] * </span><span class="s1">x</span><span class="s2">[</span><span class="s6">0</span><span class="s2">, :] + </span><span class="s1">d1</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] * </span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">, :]</span>
        <span class="s1">kx</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">, :] = </span><span class="s1">d1</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] * </span><span class="s1">x</span><span class="s2">[-</span><span class="s6">2</span><span class="s2">, :] + </span><span class="s1">d0</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] * </span><span class="s1">x</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">, :]</span>
        <span class="s1">kx</span><span class="s2">[</span><span class="s6">1</span><span class="s2">: -</span><span class="s6">1</span><span class="s2">, :] = (</span><span class="s1">d1</span><span class="s2">[:-</span><span class="s6">1</span><span class="s2">, </span><span class="s0">None</span><span class="s2">] * </span><span class="s1">x</span><span class="s2">[: -</span><span class="s6">2</span><span class="s2">, :]</span>
                        <span class="s2">+ </span><span class="s1">d0</span><span class="s2">[</span><span class="s6">1</span><span class="s2">: -</span><span class="s6">1</span><span class="s2">, </span><span class="s0">None</span><span class="s2">] * </span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">: -</span><span class="s6">1</span><span class="s2">, :]</span>
                        <span class="s2">+ </span><span class="s1">d1</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:, </span><span class="s0">None</span><span class="s2">] * </span><span class="s1">x</span><span class="s2">[</span><span class="s6">2</span><span class="s2">:, :])</span>
        <span class="s0">return </span><span class="s1">kx</span>

    <span class="s0">def </span><span class="s1">_matmat</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Construct matrix-free callable matrix-matrix multiplication by 
        the Stiffness mass matrix without constructing or storing the matrix itself 
        by reusing the ``_matvec(x)`` that supports both 1D and 2D arrays ``x``. 
        &quot;&quot;&quot;  </span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_matvec</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_adjoint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">_transpose</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span>


<span class="s0">class </span><span class="s1">MikotaPair</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Construct the Mikota pair of matrices in various formats and 
    eigenvalues of the generalized eigenproblem with them. 
 
    The Mikota pair of matrices [1, 2]_ models a vibration problem 
    of a linear mass-spring system with the ends attached where 
    the stiffness of the springs and the masses increase along 
    the system length such that vibration frequencies are subsequent 
    integers 1, 2, ..., `n` where `n` is the number of the masses. Thus, 
    eigenvalues of the generalized eigenvalue problem for 
    the matrix pair `K` and `M` where `K` is the system stiffness matrix 
    and `M` is the system mass matrix are the squares of the integers, 
    i.e., 1, 4, 9, ..., ``n * n``. 
 
    The stiffness matrix `K` is square real tri-diagonal symmetric 
    positive definite. The mass matrix `M` is diagonal with diagonal 
    entries 1, 1/2, 1/3, ...., ``1/n``. Both matrices get 
    ill-conditioned with `n` growing. 
 
    Parameters 
    ---------- 
    n : int 
        The size of the matrices of the Mikota pair. 
    dtype : dtype 
        Numerical type of the array. Default is ``np.float64``. 
 
    Attributes 
    ---------- 
    eigenvalues : 1D ndarray, ``np.uint64`` 
        All eigenvalues of the Mikota pair ordered ascending. 
 
    Methods 
    ------- 
    MikotaK() 
        A `LinearOperator` custom object for the stiffness matrix. 
    MikotaM() 
        A `LinearOperator` custom object for the mass matrix. 
     
    .. versionadded:: 1.12.0 
 
    References 
    ---------- 
    .. [1] J. Mikota, &quot;Frequency tuning of chain structure multibody oscillators 
       to place the natural frequencies at omega1 and N-1 integer multiples 
       omega2,..., omegaN&quot;, Z. Angew. Math. Mech. 81 (2001), S2, S201-S202. 
       Appl. Num. Anal. Comp. Math. Vol. 1 No. 2 (2004). 
    .. [2] Peter C. Muller and Metin Gurgoze, 
       &quot;Natural frequencies of a multi-degree-of-freedom vibration system&quot;, 
       Proc. Appl. Math. Mech. 6, 319-320 (2006). 
       http://dx.doi.org/10.1002/pamm.200610141. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse.linalg._special_sparse_arrays import MikotaPair 
    &gt;&gt;&gt; n = 6 
    &gt;&gt;&gt; mik = MikotaPair(n) 
    &gt;&gt;&gt; mik_k = mik.k 
    &gt;&gt;&gt; mik_m = mik.m 
    &gt;&gt;&gt; mik_k.toarray() 
    array([[11., -5.,  0.,  0.,  0.,  0.], 
           [-5.,  9., -4.,  0.,  0.,  0.], 
           [ 0., -4.,  7., -3.,  0.,  0.], 
           [ 0.,  0., -3.,  5., -2.,  0.], 
           [ 0.,  0.,  0., -2.,  3., -1.], 
           [ 0.,  0.,  0.,  0., -1.,  1.]]) 
    &gt;&gt;&gt; mik_k.tobanded() 
    array([[ 0., -5., -4., -3., -2., -1.], 
           [11.,  9.,  7.,  5.,  3.,  1.]]) 
    &gt;&gt;&gt; mik_m.tobanded() 
    array([1.        , 0.5       , 0.33333333, 0.25      , 0.2       , 
        0.16666667]) 
    &gt;&gt;&gt; mik_k.tosparse() 
    &lt;DIAgonal sparse array of dtype 'float64' 
        with 20 stored elements (3 diagonals) and shape (6, 6)&gt; 
    &gt;&gt;&gt; mik_m.tosparse() 
    &lt;DIAgonal sparse array of dtype 'float64' 
        with 6 stored elements (1 diagonals) and shape (6, 6)&gt; 
    &gt;&gt;&gt; np.array_equal(mik_k(np.eye(n)), mik_k.toarray()) 
    True 
    &gt;&gt;&gt; np.array_equal(mik_m(np.eye(n)), mik_m.toarray()) 
    True 
    &gt;&gt;&gt; mik.eigenvalues() 
    array([ 1,  4,  9, 16, 25, 36])   
    &gt;&gt;&gt; mik.eigenvalues(2) 
    array([ 1,  4]) 
 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">n </span><span class="s2">= </span><span class="s1">n</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">= </span><span class="s1">dtype</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= (</span><span class="s1">n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">m </span><span class="s2">= </span><span class="s1">MikotaM</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">k </span><span class="s2">= </span><span class="s1">MikotaK</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">eigenvalues</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Return the requested number of eigenvalues. 
         
        Parameters 
        ---------- 
        m : int, optional 
            The positive number of smallest eigenvalues to return. 
            If not provided, then all eigenvalues will be returned. 
             
        Returns 
        ------- 
        eigenvalues : `np.uint64` array 
            The requested `m` smallest or all eigenvalues, in ascending order. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">m </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">m </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">n</span>
        <span class="s1">arange_plus1 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s1">m </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint64</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">arange_plus1 </span><span class="s2">* </span><span class="s1">arange_plus1</span>
</pre>
</body>
</html>