<html>
<head>
<title>resample.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
resample.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">copy</span>
<span class="s0">from </span><span class="s1">textwrap </span><span class="s0">import </span><span class="s1">dedent</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">Literal</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
    <span class="s1">final</span><span class="s2">,</span>
    <span class="s1">no_type_check</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs </span><span class="s0">import </span><span class="s1">lib</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs</span><span class="s2">.</span><span class="s1">tslibs </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">BaseOffset</span><span class="s2">,</span>
    <span class="s1">IncompatibleFrequency</span><span class="s2">,</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">Period</span><span class="s2">,</span>
    <span class="s1">Timedelta</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">to_offset</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs</span><span class="s2">.</span><span class="s1">tslibs</span><span class="s2">.</span><span class="s1">dtypes </span><span class="s0">import </span><span class="s1">freq_to_period_freqstr</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_typing </span><span class="s0">import </span><span class="s1">NDFrameT</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">compat</span><span class="s2">.</span><span class="s1">numpy </span><span class="s0">import </span><span class="s1">function </span><span class="s0">as </span><span class="s1">nv</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">errors </span><span class="s0">import </span><span class="s1">AbstractMethodError</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">util</span><span class="s2">.</span><span class="s1">_decorators </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">Appender</span><span class="s2">,</span>
    <span class="s1">Substitution</span><span class="s2">,</span>
    <span class="s1">doc</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">util</span><span class="s2">.</span><span class="s1">_exceptions </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">find_stack_level</span><span class="s2">,</span>
    <span class="s1">rewrite_warning</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">dtypes </span><span class="s0">import </span><span class="s1">ArrowDtype</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">generic </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">ABCDataFrame</span><span class="s2">,</span>
    <span class="s1">ABCSeries</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s0">import </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">algorithms </span><span class="s0">as </span><span class="s1">algos</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">apply </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">ResamplerWindowApply</span><span class="s2">,</span>
    <span class="s1">warn_alias_replacement</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays </span><span class="s0">import </span><span class="s1">ArrowExtensionArray</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">base </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">PandasObject</span><span class="s2">,</span>
    <span class="s1">SelectionMixin</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">import </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">common </span><span class="s0">as </span><span class="s1">com</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">generic </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">NDFrame</span><span class="s2">,</span>
    <span class="s1">_shared_docs</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">groupby</span><span class="s2">.</span><span class="s1">generic </span><span class="s0">import </span><span class="s1">SeriesGroupBy</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">groupby</span><span class="s2">.</span><span class="s1">groupby </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">BaseGroupBy</span><span class="s2">,</span>
    <span class="s1">GroupBy</span><span class="s2">,</span>
    <span class="s1">_apply_groupings_depr</span><span class="s2">,</span>
    <span class="s1">_pipe_template</span><span class="s2">,</span>
    <span class="s1">get_groupby</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">groupby</span><span class="s2">.</span><span class="s1">grouper </span><span class="s0">import </span><span class="s1">Grouper</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">groupby</span><span class="s2">.</span><span class="s1">ops </span><span class="s0">import </span><span class="s1">BinGrouper</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">indexes</span><span class="s2">.</span><span class="s1">api </span><span class="s0">import </span><span class="s1">MultiIndex</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">indexes</span><span class="s2">.</span><span class="s1">base </span><span class="s0">import </span><span class="s1">Index</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">indexes</span><span class="s2">.</span><span class="s1">datetimes </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">DatetimeIndex</span><span class="s2">,</span>
    <span class="s1">date_range</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">indexes</span><span class="s2">.</span><span class="s1">period </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">PeriodIndex</span><span class="s2">,</span>
    <span class="s1">period_range</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">indexes</span><span class="s2">.</span><span class="s1">timedeltas </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">TimedeltaIndex</span><span class="s2">,</span>
    <span class="s1">timedelta_range</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">tseries</span><span class="s2">.</span><span class="s1">frequencies </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">is_subperiod</span><span class="s2">,</span>
    <span class="s1">is_superperiod</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">tseries</span><span class="s2">.</span><span class="s1">offsets </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">Day</span><span class="s2">,</span>
    <span class="s1">Tick</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s1">Hashable</span>

    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_typing </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">AnyArrayLike</span><span class="s2">,</span>
        <span class="s1">Axis</span><span class="s2">,</span>
        <span class="s1">AxisInt</span><span class="s2">,</span>
        <span class="s1">Frequency</span><span class="s2">,</span>
        <span class="s1">IndexLabel</span><span class="s2">,</span>
        <span class="s1">InterpolateOptions</span><span class="s2">,</span>
        <span class="s1">T</span><span class="s2">,</span>
        <span class="s1">TimedeltaConvertibleTypes</span><span class="s2">,</span>
        <span class="s1">TimeGrouperOrigin</span><span class="s2">,</span>
        <span class="s1">TimestampConvertibleTypes</span><span class="s2">,</span>
        <span class="s1">npt</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">DataFrame</span><span class="s2">,</span>
        <span class="s1">Series</span><span class="s2">,</span>
    <span class="s2">)</span>

<span class="s1">_shared_docs_kwargs</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">] = {}</span>


<span class="s0">class </span><span class="s1">Resampler</span><span class="s2">(</span><span class="s1">BaseGroupBy</span><span class="s2">, </span><span class="s1">PandasObject</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Class for resampling datetimelike data, a groupby-like operation. 
    See aggregate, transform, and apply functions on this object. 
 
    It's easiest to use obj.resample(...) to use Resampler. 
 
    Parameters 
    ---------- 
    obj : Series or DataFrame 
    groupby : TimeGrouper 
    axis : int, default 0 
    kind : str or None 
        'period', 'timestamp' to override default index treatment 
 
    Returns 
    ------- 
    a Resampler of the appropriate type 
 
    Notes 
    ----- 
    After resampling, see aggregate, apply, and transform functions. 
    &quot;&quot;&quot;</span>

    <span class="s1">_grouper</span><span class="s2">: </span><span class="s1">BinGrouper</span>
    <span class="s1">_timegrouper</span><span class="s2">: </span><span class="s1">TimeGrouper</span>
    <span class="s1">binner</span><span class="s2">: </span><span class="s1">DatetimeIndex </span><span class="s2">| </span><span class="s1">TimedeltaIndex </span><span class="s2">| </span><span class="s1">PeriodIndex  </span><span class="s4"># depends on subclass</span>
    <span class="s1">exclusions</span><span class="s2">: </span><span class="s1">frozenset</span><span class="s2">[</span><span class="s1">Hashable</span><span class="s2">] = </span><span class="s1">frozenset</span><span class="s2">()  </span><span class="s4"># for SelectionMixin compat</span>
    <span class="s1">_internal_names_set </span><span class="s2">= </span><span class="s1">set</span><span class="s2">({</span><span class="s5">&quot;obj&quot;</span><span class="s2">, </span><span class="s5">&quot;ax&quot;</span><span class="s2">, </span><span class="s5">&quot;_indexer&quot;</span><span class="s2">})</span>

    <span class="s4"># to the groupby descriptor</span>
    <span class="s1">_attributes </span><span class="s2">= [</span>
        <span class="s5">&quot;freq&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;axis&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;closed&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;label&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;convention&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;kind&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;origin&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;offset&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">obj</span><span class="s2">: </span><span class="s1">NDFrame</span><span class="s2">,</span>
        <span class="s1">timegrouper</span><span class="s2">: </span><span class="s1">TimeGrouper</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">: </span><span class="s1">Axis </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">kind</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">gpr_index</span><span class="s2">: </span><span class="s1">Index</span><span class="s2">,</span>
        <span class="s1">group_keys</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">selection</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">include_groups</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper </span><span class="s2">= </span><span class="s1">timegrouper</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">keys </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">sort </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">axis </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_get_axis_number</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">= </span><span class="s1">kind</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">group_keys </span><span class="s2">= </span><span class="s1">group_keys</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">as_index </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">include_groups </span><span class="s2">= </span><span class="s1">include_groups</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ax</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_indexer </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper</span><span class="s2">.</span><span class="s1">_set_grouper</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_convert_obj</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">), </span><span class="s1">sort</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">gpr_index</span><span class="s2">=</span><span class="s1">gpr_index</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">binner</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_grouper </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_binner</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_selection </span><span class="s2">= </span><span class="s1">selection</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper</span><span class="s2">.</span><span class="s1">key </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">exclusions </span><span class="s2">= </span><span class="s1">frozenset</span><span class="s2">([</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper</span><span class="s2">.</span><span class="s1">key</span><span class="s2">])</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">exclusions </span><span class="s2">= </span><span class="s1">frozenset</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">__str__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Provide a nice str repr of our rolling object. 
        &quot;&quot;&quot;</span>
        <span class="s1">attrs </span><span class="s2">= (</span>
            <span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s5">=</span><span class="s0">{</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper</span><span class="s2">, </span><span class="s1">k</span><span class="s2">)</span><span class="s0">}</span><span class="s5">&quot;</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_attributes</span>
            <span class="s0">if </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s0">None</span><span class="s2">) </span><span class="s0">is not None</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">} </span><span class="s5">[</span><span class="s0">{</span><span class="s5">', '</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">)</span><span class="s0">}</span><span class="s5">]&quot;</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">__getattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">: </span><span class="s1">str</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_internal_names_set</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">object</span><span class="s2">.</span><span class="s1">__getattribute__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_attributes</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">[</span><span class="s1">attr</span><span class="s2">]</span>

        <span class="s0">return </span><span class="s1">object</span><span class="s2">.</span><span class="s1">__getattribute__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">_from_selection</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Is the resampling from a DataFrame column or MultiIndex level. 
        &quot;&quot;&quot;</span>
        <span class="s4"># upsampling and PeriodIndex resampling do not work</span>
        <span class="s4"># with selection, this state used to catch and raise an error</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper </span><span class="s0">is not None and </span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper</span><span class="s2">.</span><span class="s1">key </span><span class="s0">is not None or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper</span><span class="s2">.</span><span class="s1">level </span><span class="s0">is not None</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_convert_obj</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">: </span><span class="s1">NDFrameT</span><span class="s2">) </span><span class="s1">-&gt; NDFrameT</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Provide any conversions for the object in order to correctly handle. 
 
        Parameters 
        ---------- 
        obj : Series or DataFrame 
 
        Returns 
        ------- 
        Series or DataFrame 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_consolidate</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">_get_binner_for_time</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">AbstractMethodError</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">_get_binner</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Create the BinGrouper, assume that self.set_grouper(obj) 
        has already been called. 
        &quot;&quot;&quot;</span>
        <span class="s1">binner</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">, </span><span class="s1">binlabels </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_binner_for_time</span><span class="s2">()</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">bins</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">binlabels</span><span class="s2">)</span>
        <span class="s1">bin_grouper </span><span class="s2">= </span><span class="s1">BinGrouper</span><span class="s2">(</span><span class="s1">bins</span><span class="s2">, </span><span class="s1">binlabels</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_indexer</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">binner</span><span class="s2">, </span><span class="s1">bin_grouper</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">Substitution</span><span class="s2">(</span>
        <span class="s1">klass</span><span class="s2">=</span><span class="s5">&quot;Resampler&quot;</span><span class="s2">,</span>
        <span class="s1">examples</span><span class="s2">=</span><span class="s5">&quot;&quot;&quot; 
    &gt;&gt;&gt; df = pd.DataFrame({'A': [1, 2, 3, 4]}, 
    ...                   index=pd.date_range('2012-08-02', periods=4)) 
    &gt;&gt;&gt; df 
                A 
    2012-08-02  1 
    2012-08-03  2 
    2012-08-04  3 
    2012-08-05  4 
 
    To get the difference between each 2-day period's maximum and minimum 
    value in one pass, you can do 
 
    &gt;&gt;&gt; df.resample('2D').pipe(lambda x: x.max() - x.min()) 
                A 
    2012-08-02  1 
    2012-08-04  1&quot;&quot;&quot;</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s2">@</span><span class="s1">Appender</span><span class="s2">(</span><span class="s1">_pipe_template</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">pipe</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">func</span><span class="s2">: </span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">T</span><span class="s2">] | </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Callable</span><span class="s2">[..., </span><span class="s1">T</span><span class="s2">], </span><span class="s1">str</span><span class="s2">],</span>
        <span class="s2">*</span><span class="s1">args</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; T</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">pipe</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s1">_agg_see_also_doc </span><span class="s2">= </span><span class="s1">dedent</span><span class="s2">(</span>
        <span class="s5">&quot;&quot;&quot; 
    See Also 
    -------- 
    DataFrame.groupby.aggregate : Aggregate using callable, string, dict, 
        or list of string/callables. 
    DataFrame.resample.transform : Transforms the Series on each group 
        based on the given function. 
    DataFrame.aggregate: Aggregate using one or more 
        operations over the specified axis. 
    &quot;&quot;&quot;</span>
    <span class="s2">)</span>

    <span class="s1">_agg_examples_doc </span><span class="s2">= </span><span class="s1">dedent</span><span class="s2">(</span>
        <span class="s5">&quot;&quot;&quot; 
    Examples 
    -------- 
    &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4, 5], 
    ...               index=pd.date_range('20130101', periods=5, freq='s')) 
    &gt;&gt;&gt; s 
    2013-01-01 00:00:00    1 
    2013-01-01 00:00:01    2 
    2013-01-01 00:00:02    3 
    2013-01-01 00:00:03    4 
    2013-01-01 00:00:04    5 
    Freq: s, dtype: int64 
 
    &gt;&gt;&gt; r = s.resample('2s') 
 
    &gt;&gt;&gt; r.agg(&quot;sum&quot;) 
    2013-01-01 00:00:00    3 
    2013-01-01 00:00:02    7 
    2013-01-01 00:00:04    5 
    Freq: 2s, dtype: int64 
 
    &gt;&gt;&gt; r.agg(['sum', 'mean', 'max']) 
                         sum  mean  max 
    2013-01-01 00:00:00    3   1.5    2 
    2013-01-01 00:00:02    7   3.5    4 
    2013-01-01 00:00:04    5   5.0    5 
 
    &gt;&gt;&gt; r.agg({'result': lambda x: x.mean() / x.std(), 
    ...        'total': &quot;sum&quot;}) 
                           result  total 
    2013-01-01 00:00:00  2.121320      3 
    2013-01-01 00:00:02  4.949747      7 
    2013-01-01 00:00:04       NaN      5 
 
    &gt;&gt;&gt; r.agg(average=&quot;mean&quot;, total=&quot;sum&quot;) 
                             average  total 
    2013-01-01 00:00:00      1.5      3 
    2013-01-01 00:00:02      3.5      7 
    2013-01-01 00:00:04      5.0      5 
    &quot;&quot;&quot;</span>
    <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span>
        <span class="s1">_shared_docs</span><span class="s2">[</span><span class="s5">&quot;aggregate&quot;</span><span class="s2">],</span>
        <span class="s1">see_also</span><span class="s2">=</span><span class="s1">_agg_see_also_doc</span><span class="s2">,</span>
        <span class="s1">examples</span><span class="s2">=</span><span class="s1">_agg_examples_doc</span><span class="s2">,</span>
        <span class="s1">klass</span><span class="s2">=</span><span class="s5">&quot;DataFrame&quot;</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">=</span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s0">def </span><span class="s1">aggregate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">ResamplerWindowApply</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">=</span><span class="s1">kwargs</span><span class="s2">).</span><span class="s1">agg</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">result </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">how </span><span class="s2">= </span><span class="s1">func</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_groupby_and_aggregate</span><span class="s2">(</span><span class="s1">how</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s1">agg </span><span class="s2">= </span><span class="s1">aggregate</span>
    <span class="s1">apply </span><span class="s2">= </span><span class="s1">aggregate</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Call function producing a like-indexed Series on each group. 
 
        Return a Series with the transformed values. 
 
        Parameters 
        ---------- 
        arg : function 
            To apply to each group. Should return a Series with the same index. 
 
        Returns 
        ------- 
        Series 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([1, 2], 
        ...               index=pd.date_range('20180101', 
        ...                                   periods=2, 
        ...                                   freq='1h')) 
        &gt;&gt;&gt; s 
        2018-01-01 00:00:00    1 
        2018-01-01 01:00:00    2 
        Freq: h, dtype: int64 
 
        &gt;&gt;&gt; resampled = s.resample('15min') 
        &gt;&gt;&gt; resampled.transform(lambda x: (x - x.mean()) / x.std()) 
        2018-01-01 00:00:00   NaN 
        2018-01-01 01:00:00   NaN 
        Freq: h, dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_selected_obj</span><span class="s2">.</span><span class="s1">groupby</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper</span><span class="s2">).</span><span class="s1">transform</span><span class="s2">(</span>
            <span class="s1">arg</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_downsample</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">AbstractMethodError</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_upsample</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">AbstractMethodError</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_gotitem</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">: </span><span class="s1">int</span><span class="s2">, </span><span class="s1">subset</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Sub-classes to define. Return a sliced object. 
 
        Parameters 
        ---------- 
        key : string / list of selections 
        ndim : {1, 2} 
            requested ndim of result 
        subset : object, default None 
            subset to act on 
        &quot;&quot;&quot;</span>
        <span class="s1">grouper </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_grouper</span>
        <span class="s0">if </span><span class="s1">subset </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">subset </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">subset </span><span class="s2">= </span><span class="s1">subset</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s4"># reached via Apply.agg_dict_like with selection=None and ndim=1</span>
                <span class="s0">assert </span><span class="s1">subset</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span>
        <span class="s0">if </span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">subset</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span>

        <span class="s1">grouped </span><span class="s2">= </span><span class="s1">get_groupby</span><span class="s2">(</span>
            <span class="s1">subset</span><span class="s2">, </span><span class="s1">by</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">grouper</span><span class="s2">=</span><span class="s1">grouper</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">group_keys</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">group_keys</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">grouped</span>

    <span class="s0">def </span><span class="s1">_groupby_and_aggregate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">how</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Re-evaluate the obj with a groupby aggregation. 
        &quot;&quot;&quot;</span>
        <span class="s1">grouper </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_grouper</span>

        <span class="s4"># Excludes `on` column when provided</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_obj_with_exclusions</span>

        <span class="s1">grouped </span><span class="s2">= </span><span class="s1">get_groupby</span><span class="s2">(</span>
            <span class="s1">obj</span><span class="s2">, </span><span class="s1">by</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">grouper</span><span class="s2">=</span><span class="s1">grouper</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">group_keys</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">group_keys</span>
        <span class="s2">)</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">how</span><span class="s2">):</span>
                <span class="s4"># TODO: test_resample_apply_with_additional_args fails if we go</span>
                <span class="s4">#  through the non-lambda path, not clear that it should.</span>
                <span class="s1">func </span><span class="s2">= </span><span class="s0">lambda </span><span class="s1">x</span><span class="s2">: </span><span class="s1">how</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">grouped</span><span class="s2">.</span><span class="s1">aggregate</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">grouped</span><span class="s2">.</span><span class="s1">aggregate</span><span class="s2">(</span><span class="s1">how</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s2">(</span><span class="s1">AttributeError</span><span class="s2">, </span><span class="s1">KeyError</span><span class="s2">):</span>
            <span class="s4"># we have a non-reducing function; try to evaluate</span>
            <span class="s4"># alternatively we want to evaluate only a column of the input</span>

            <span class="s4"># test_apply_to_one_column_of_df the function being applied references</span>
            <span class="s4">#  a DataFrame column, but aggregate_item_by_item operates column-wise</span>
            <span class="s4">#  on Series, raising AttributeError or KeyError</span>
            <span class="s4">#  (depending on whether the column lookup uses getattr/__getitem__)</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">_apply</span><span class="s2">(</span>
                <span class="s1">grouped</span><span class="s2">, </span><span class="s1">how</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, </span><span class="s1">include_groups</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">include_groups</span><span class="s2">, **</span><span class="s1">kwargs</span>
            <span class="s2">)</span>

        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">err</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s5">&quot;Must produce aggregated value&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">err</span><span class="s2">):</span>
                <span class="s4"># raised in _aggregate_named</span>
                <span class="s4"># see test_apply_without_aggregation, test_apply_with_mutated_index</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">raise</span>

            <span class="s4"># we have a non-reducing function</span>
            <span class="s4"># try to evaluate</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">_apply</span><span class="s2">(</span>
                <span class="s1">grouped</span><span class="s2">, </span><span class="s1">how</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, </span><span class="s1">include_groups</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">include_groups</span><span class="s2">, **</span><span class="s1">kwargs</span>
            <span class="s2">)</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wrap_result</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">_get_resampler_for_grouping</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">groupby</span><span class="s2">: </span><span class="s1">GroupBy</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">include_groups</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the correct class for resampling with groupby. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_resampler_for_grouping</span><span class="s2">(</span>
            <span class="s1">groupby</span><span class="s2">=</span><span class="s1">groupby</span><span class="s2">, </span><span class="s1">key</span><span class="s2">=</span><span class="s1">key</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">=</span><span class="s1">self</span><span class="s2">, </span><span class="s1">include_groups</span><span class="s2">=</span><span class="s1">include_groups</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_wrap_result</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">result</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Potentially wrap any results. 
        &quot;&quot;&quot;</span>
        <span class="s4"># GH 47705</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">ABCDataFrame</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">result</span><span class="s2">) == </span><span class="s6">0</span>
            <span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">PeriodIndex</span><span class="s2">)</span>
        <span class="s2">):</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">set_index</span><span class="s2">(</span>
                <span class="s1">_asfreq_compat</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">[:</span><span class="s6">0</span><span class="s2">], </span><span class="s1">freq</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">), </span><span class="s1">append</span><span class="s2">=</span><span class="s0">True</span>
            <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">ABCSeries</span><span class="s2">) </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_selection </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">result</span><span class="s2">.</span><span class="s1">name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_selection</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">ABCSeries</span><span class="s2">) </span><span class="s0">and </span><span class="s1">result</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">:</span>
            <span class="s4"># When index is all NaT, result is empty but index is not</span>
            <span class="s1">result</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">_asfreq_compat</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">[:</span><span class="s6">0</span><span class="s2">], </span><span class="s1">freq</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">)</span>
            <span class="s1">result</span><span class="s2">.</span><span class="s1">name </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s5">&quot;name&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper</span><span class="s2">.</span><span class="s1">_arrow_dtype </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">result</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper</span><span class="s2">.</span><span class="s1">_arrow_dtype</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">ffill</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Forward fill the values. 
 
        Parameters 
        ---------- 
        limit : int, optional 
            Limit of how many values to fill. 
 
        Returns 
        ------- 
        An upsampled Series. 
 
        See Also 
        -------- 
        Series.fillna: Fill NA/NaN values using the specified method. 
        DataFrame.fillna: Fill NA/NaN values using the specified method. 
 
        Examples 
        -------- 
        Here we only create a ``Series``. 
 
        &gt;&gt;&gt; ser = pd.Series([1, 2, 3, 4], index=pd.DatetimeIndex( 
        ...                 ['2023-01-01', '2023-01-15', '2023-02-01', '2023-02-15'])) 
        &gt;&gt;&gt; ser 
        2023-01-01    1 
        2023-01-15    2 
        2023-02-01    3 
        2023-02-15    4 
        dtype: int64 
 
        Example for ``ffill`` with downsampling (we have fewer dates after resampling): 
 
        &gt;&gt;&gt; ser.resample('MS').ffill() 
        2023-01-01    1 
        2023-02-01    3 
        Freq: MS, dtype: int64 
 
        Example for ``ffill`` with upsampling (fill the new dates with 
        the previous value): 
 
        &gt;&gt;&gt; ser.resample('W').ffill() 
        2023-01-01    1 
        2023-01-08    1 
        2023-01-15    2 
        2023-01-22    2 
        2023-01-29    2 
        2023-02-05    3 
        2023-02-12    3 
        2023-02-19    4 
        Freq: W-SUN, dtype: int64 
 
        With upsampling and limiting (only fill the first new date with the 
        previous value): 
 
        &gt;&gt;&gt; ser.resample('W').ffill(limit=1) 
        2023-01-01    1.0 
        2023-01-08    1.0 
        2023-01-15    2.0 
        2023-01-22    2.0 
        2023-01-29    NaN 
        2023-02-05    3.0 
        2023-02-12    NaN 
        2023-02-19    4.0 
        Freq: W-SUN, dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_upsample</span><span class="s2">(</span><span class="s5">&quot;ffill&quot;</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">nearest</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Resample by using the nearest value. 
 
        When resampling data, missing values may appear (e.g., when the 
        resampling frequency is higher than the original frequency). 
        The `nearest` method will replace ``NaN`` values that appeared in 
        the resampled data with the value from the nearest member of the 
        sequence, based on the index value. 
        Missing values that existed in the original data will not be modified. 
        If `limit` is given, fill only this many values in each direction for 
        each of the original values. 
 
        Parameters 
        ---------- 
        limit : int, optional 
            Limit of how many values to fill. 
 
        Returns 
        ------- 
        Series or DataFrame 
            An upsampled Series or DataFrame with ``NaN`` values filled with 
            their nearest value. 
 
        See Also 
        -------- 
        backfill : Backward fill the new missing values in the resampled data. 
        pad : Forward fill ``NaN`` values. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; s = pd.Series([1, 2], 
        ...               index=pd.date_range('20180101', 
        ...                                   periods=2, 
        ...                                   freq='1h')) 
        &gt;&gt;&gt; s 
        2018-01-01 00:00:00    1 
        2018-01-01 01:00:00    2 
        Freq: h, dtype: int64 
 
        &gt;&gt;&gt; s.resample('15min').nearest() 
        2018-01-01 00:00:00    1 
        2018-01-01 00:15:00    1 
        2018-01-01 00:30:00    2 
        2018-01-01 00:45:00    2 
        2018-01-01 01:00:00    2 
        Freq: 15min, dtype: int64 
 
        Limit the number of upsampled values imputed by the nearest: 
 
        &gt;&gt;&gt; s.resample('15min').nearest(limit=1) 
        2018-01-01 00:00:00    1.0 
        2018-01-01 00:15:00    1.0 
        2018-01-01 00:30:00    NaN 
        2018-01-01 00:45:00    2.0 
        2018-01-01 01:00:00    2.0 
        Freq: 15min, dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_upsample</span><span class="s2">(</span><span class="s5">&quot;nearest&quot;</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">bfill</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Backward fill the new missing values in the resampled data. 
 
        In statistics, imputation is the process of replacing missing data with 
        substituted values [1]_. When resampling data, missing values may 
        appear (e.g., when the resampling frequency is higher than the original 
        frequency). The backward fill will replace NaN values that appeared in 
        the resampled data with the next value in the original sequence. 
        Missing values that existed in the original data will not be modified. 
 
        Parameters 
        ---------- 
        limit : int, optional 
            Limit of how many values to fill. 
 
        Returns 
        ------- 
        Series, DataFrame 
            An upsampled Series or DataFrame with backward filled NaN values. 
 
        See Also 
        -------- 
        bfill : Alias of backfill. 
        fillna : Fill NaN values using the specified method, which can be 
            'backfill'. 
        nearest : Fill NaN values with nearest neighbor starting from center. 
        ffill : Forward fill NaN values. 
        Series.fillna : Fill NaN values in the Series using the 
            specified method, which can be 'backfill'. 
        DataFrame.fillna : Fill NaN values in the DataFrame using the 
            specified method, which can be 'backfill'. 
 
        References 
        ---------- 
        .. [1] https://en.wikipedia.org/wiki/Imputation_(statistics) 
 
        Examples 
        -------- 
        Resampling a Series: 
 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3], 
        ...               index=pd.date_range('20180101', periods=3, freq='h')) 
        &gt;&gt;&gt; s 
        2018-01-01 00:00:00    1 
        2018-01-01 01:00:00    2 
        2018-01-01 02:00:00    3 
        Freq: h, dtype: int64 
 
        &gt;&gt;&gt; s.resample('30min').bfill() 
        2018-01-01 00:00:00    1 
        2018-01-01 00:30:00    2 
        2018-01-01 01:00:00    2 
        2018-01-01 01:30:00    3 
        2018-01-01 02:00:00    3 
        Freq: 30min, dtype: int64 
 
        &gt;&gt;&gt; s.resample('15min').bfill(limit=2) 
        2018-01-01 00:00:00    1.0 
        2018-01-01 00:15:00    NaN 
        2018-01-01 00:30:00    2.0 
        2018-01-01 00:45:00    2.0 
        2018-01-01 01:00:00    2.0 
        2018-01-01 01:15:00    NaN 
        2018-01-01 01:30:00    3.0 
        2018-01-01 01:45:00    3.0 
        2018-01-01 02:00:00    3.0 
        Freq: 15min, dtype: float64 
 
        Resampling a DataFrame that has missing values: 
 
        &gt;&gt;&gt; df = pd.DataFrame({'a': [2, np.nan, 6], 'b': [1, 3, 5]}, 
        ...                   index=pd.date_range('20180101', periods=3, 
        ...                                       freq='h')) 
        &gt;&gt;&gt; df 
                               a  b 
        2018-01-01 00:00:00  2.0  1 
        2018-01-01 01:00:00  NaN  3 
        2018-01-01 02:00:00  6.0  5 
 
        &gt;&gt;&gt; df.resample('30min').bfill() 
                               a  b 
        2018-01-01 00:00:00  2.0  1 
        2018-01-01 00:30:00  NaN  3 
        2018-01-01 01:00:00  NaN  3 
        2018-01-01 01:30:00  6.0  5 
        2018-01-01 02:00:00  6.0  5 
 
        &gt;&gt;&gt; df.resample('15min').bfill(limit=2) 
                               a    b 
        2018-01-01 00:00:00  2.0  1.0 
        2018-01-01 00:15:00  NaN  NaN 
        2018-01-01 00:30:00  NaN  3.0 
        2018-01-01 00:45:00  NaN  3.0 
        2018-01-01 01:00:00  NaN  3.0 
        2018-01-01 01:15:00  NaN  NaN 
        2018-01-01 01:30:00  6.0  5.0 
        2018-01-01 01:45:00  6.0  5.0 
        2018-01-01 02:00:00  6.0  5.0 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_upsample</span><span class="s2">(</span><span class="s5">&quot;bfill&quot;</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">fillna</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Fill missing values introduced by upsampling. 
 
        In statistics, imputation is the process of replacing missing data with 
        substituted values [1]_. When resampling data, missing values may 
        appear (e.g., when the resampling frequency is higher than the original 
        frequency). 
 
        Missing values that existed in the original data will 
        not be modified. 
 
        Parameters 
        ---------- 
        method : {'pad', 'backfill', 'ffill', 'bfill', 'nearest'} 
            Method to use for filling holes in resampled data 
 
            * 'pad' or 'ffill': use previous valid observation to fill gap 
              (forward fill). 
            * 'backfill' or 'bfill': use next valid observation to fill gap. 
            * 'nearest': use nearest valid observation to fill gap. 
 
        limit : int, optional 
            Limit of how many consecutive missing values to fill. 
 
        Returns 
        ------- 
        Series or DataFrame 
            An upsampled Series or DataFrame with missing values filled. 
 
        See Also 
        -------- 
        bfill : Backward fill NaN values in the resampled data. 
        ffill : Forward fill NaN values in the resampled data. 
        nearest : Fill NaN values in the resampled data 
            with nearest neighbor starting from center. 
        interpolate : Fill NaN values using interpolation. 
        Series.fillna : Fill NaN values in the Series using the 
            specified method, which can be 'bfill' and 'ffill'. 
        DataFrame.fillna : Fill NaN values in the DataFrame using the 
            specified method, which can be 'bfill' and 'ffill'. 
 
        References 
        ---------- 
        .. [1] https://en.wikipedia.org/wiki/Imputation_(statistics) 
 
        Examples 
        -------- 
        Resampling a Series: 
 
        &gt;&gt;&gt; s = pd.Series([1, 2, 3], 
        ...               index=pd.date_range('20180101', periods=3, freq='h')) 
        &gt;&gt;&gt; s 
        2018-01-01 00:00:00    1 
        2018-01-01 01:00:00    2 
        2018-01-01 02:00:00    3 
        Freq: h, dtype: int64 
 
        Without filling the missing values you get: 
 
        &gt;&gt;&gt; s.resample(&quot;30min&quot;).asfreq() 
        2018-01-01 00:00:00    1.0 
        2018-01-01 00:30:00    NaN 
        2018-01-01 01:00:00    2.0 
        2018-01-01 01:30:00    NaN 
        2018-01-01 02:00:00    3.0 
        Freq: 30min, dtype: float64 
 
        &gt;&gt;&gt; s.resample('30min').fillna(&quot;backfill&quot;) 
        2018-01-01 00:00:00    1 
        2018-01-01 00:30:00    2 
        2018-01-01 01:00:00    2 
        2018-01-01 01:30:00    3 
        2018-01-01 02:00:00    3 
        Freq: 30min, dtype: int64 
 
        &gt;&gt;&gt; s.resample('15min').fillna(&quot;backfill&quot;, limit=2) 
        2018-01-01 00:00:00    1.0 
        2018-01-01 00:15:00    NaN 
        2018-01-01 00:30:00    2.0 
        2018-01-01 00:45:00    2.0 
        2018-01-01 01:00:00    2.0 
        2018-01-01 01:15:00    NaN 
        2018-01-01 01:30:00    3.0 
        2018-01-01 01:45:00    3.0 
        2018-01-01 02:00:00    3.0 
        Freq: 15min, dtype: float64 
 
        &gt;&gt;&gt; s.resample('30min').fillna(&quot;pad&quot;) 
        2018-01-01 00:00:00    1 
        2018-01-01 00:30:00    1 
        2018-01-01 01:00:00    2 
        2018-01-01 01:30:00    2 
        2018-01-01 02:00:00    3 
        Freq: 30min, dtype: int64 
 
        &gt;&gt;&gt; s.resample('30min').fillna(&quot;nearest&quot;) 
        2018-01-01 00:00:00    1 
        2018-01-01 00:30:00    2 
        2018-01-01 01:00:00    2 
        2018-01-01 01:30:00    3 
        2018-01-01 02:00:00    3 
        Freq: 30min, dtype: int64 
 
        Missing values present before the upsampling are not affected. 
 
        &gt;&gt;&gt; sm = pd.Series([1, None, 3], 
        ...                index=pd.date_range('20180101', periods=3, freq='h')) 
        &gt;&gt;&gt; sm 
        2018-01-01 00:00:00    1.0 
        2018-01-01 01:00:00    NaN 
        2018-01-01 02:00:00    3.0 
        Freq: h, dtype: float64 
 
        &gt;&gt;&gt; sm.resample('30min').fillna('backfill') 
        2018-01-01 00:00:00    1.0 
        2018-01-01 00:30:00    NaN 
        2018-01-01 01:00:00    NaN 
        2018-01-01 01:30:00    3.0 
        2018-01-01 02:00:00    3.0 
        Freq: 30min, dtype: float64 
 
        &gt;&gt;&gt; sm.resample('30min').fillna('pad') 
        2018-01-01 00:00:00    1.0 
        2018-01-01 00:30:00    1.0 
        2018-01-01 01:00:00    NaN 
        2018-01-01 01:30:00    NaN 
        2018-01-01 02:00:00    3.0 
        Freq: 30min, dtype: float64 
 
        &gt;&gt;&gt; sm.resample('30min').fillna('nearest') 
        2018-01-01 00:00:00    1.0 
        2018-01-01 00:30:00    NaN 
        2018-01-01 01:00:00    NaN 
        2018-01-01 01:30:00    3.0 
        2018-01-01 02:00:00    3.0 
        Freq: 30min, dtype: float64 
 
        DataFrame resampling is done column-wise. All the same options are 
        available. 
 
        &gt;&gt;&gt; df = pd.DataFrame({'a': [2, np.nan, 6], 'b': [1, 3, 5]}, 
        ...                   index=pd.date_range('20180101', periods=3, 
        ...                                       freq='h')) 
        &gt;&gt;&gt; df 
                               a  b 
        2018-01-01 00:00:00  2.0  1 
        2018-01-01 01:00:00  NaN  3 
        2018-01-01 02:00:00  6.0  5 
 
        &gt;&gt;&gt; df.resample('30min').fillna(&quot;bfill&quot;) 
                               a  b 
        2018-01-01 00:00:00  2.0  1 
        2018-01-01 00:30:00  NaN  3 
        2018-01-01 01:00:00  NaN  3 
        2018-01-01 01:30:00  6.0  5 
        2018-01-01 02:00:00  6.0  5 
        &quot;&quot;&quot;</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
            <span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">}</span><span class="s5">.fillna is deprecated and will be removed &quot;</span>
            <span class="s5">&quot;in a future version. Use obj.ffill(), obj.bfill(), &quot;</span>
            <span class="s5">&quot;or obj.nearest() instead.&quot;</span><span class="s2">,</span>
            <span class="s1">FutureWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_upsample</span><span class="s2">(</span><span class="s1">method</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">interpolate</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">method</span><span class="s2">: </span><span class="s1">InterpolateOptions </span><span class="s2">= </span><span class="s5">&quot;linear&quot;</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">axis</span><span class="s2">: </span><span class="s1">Axis </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">limit</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">inplace</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">limit_direction</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;forward&quot;</span><span class="s2">, </span><span class="s5">&quot;backward&quot;</span><span class="s2">, </span><span class="s5">&quot;both&quot;</span><span class="s2">] = </span><span class="s5">&quot;forward&quot;</span><span class="s2">,</span>
        <span class="s1">limit_area</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">downcast</span><span class="s2">=</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Interpolate values between target timestamps according to different methods. 
 
        The original index is first reindexed to target timestamps 
        (see :meth:`core.resample.Resampler.asfreq`), 
        then the interpolation of ``NaN`` values via :meth:`DataFrame.interpolate` 
        happens. 
 
        Parameters 
        ---------- 
        method : str, default 'linear' 
            Interpolation technique to use. One of: 
 
            * 'linear': Ignore the index and treat the values as equally 
              spaced. This is the only method supported on MultiIndexes. 
            * 'time': Works on daily and higher resolution data to interpolate 
              given length of interval. 
            * 'index', 'values': use the actual numerical values of the index. 
            * 'pad': Fill in NaNs using existing values. 
            * 'nearest', 'zero', 'slinear', 'quadratic', 'cubic', 
              'barycentric', 'polynomial': Passed to 
              `scipy.interpolate.interp1d`, whereas 'spline' is passed to 
              `scipy.interpolate.UnivariateSpline`. These methods use the numerical 
              values of the index.  Both 'polynomial' and 'spline' require that 
              you also specify an `order` (int), e.g. 
              ``df.interpolate(method='polynomial', order=5)``. Note that, 
              `slinear` method in Pandas refers to the Scipy first order `spline` 
              instead of Pandas first order `spline`. 
            * 'krogh', 'piecewise_polynomial', 'spline', 'pchip', 'akima', 
              'cubicspline': Wrappers around the SciPy interpolation methods of 
              similar names. See `Notes`. 
            * 'from_derivatives': Refers to 
              `scipy.interpolate.BPoly.from_derivatives`. 
 
        axis : {{0 or 'index', 1 or 'columns', None}}, default None 
            Axis to interpolate along. For `Series` this parameter is unused 
            and defaults to 0. 
        limit : int, optional 
            Maximum number of consecutive NaNs to fill. Must be greater than 
            0. 
        inplace : bool, default False 
            Update the data in place if possible. 
        limit_direction : {{'forward', 'backward', 'both'}}, Optional 
            Consecutive NaNs will be filled in this direction. 
 
            If limit is specified: 
                * If 'method' is 'pad' or 'ffill', 'limit_direction' must be 'forward'. 
                * If 'method' is 'backfill' or 'bfill', 'limit_direction' must be 
                  'backwards'. 
 
            If 'limit' is not specified: 
                * If 'method' is 'backfill' or 'bfill', the default is 'backward' 
                * else the default is 'forward' 
 
                raises ValueError if `limit_direction` is 'forward' or 'both' and 
                    method is 'backfill' or 'bfill'. 
                raises ValueError if `limit_direction` is 'backward' or 'both' and 
                    method is 'pad' or 'ffill'. 
 
        limit_area : {{`None`, 'inside', 'outside'}}, default None 
            If limit is specified, consecutive NaNs will be filled with this 
            restriction. 
 
            * ``None``: No fill restriction. 
            * 'inside': Only fill NaNs surrounded by valid values 
              (interpolate). 
            * 'outside': Only fill NaNs outside valid values (extrapolate). 
 
        downcast : optional, 'infer' or None, defaults to None 
            Downcast dtypes if possible. 
 
            .. deprecated:: 2.1.0 
 
        ``**kwargs`` : optional 
            Keyword arguments to pass on to the interpolating function. 
 
        Returns 
        ------- 
        DataFrame or Series 
            Interpolated values at the specified freq. 
 
        See Also 
        -------- 
        core.resample.Resampler.asfreq: Return the values at the new freq, 
            essentially a reindex. 
        DataFrame.interpolate: Fill NaN values using an interpolation method. 
 
        Notes 
        ----- 
        For high-frequent or non-equidistant time-series with timestamps 
        the reindexing followed by interpolation may lead to information loss 
        as shown in the last example. 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; start = &quot;2023-03-01T07:00:00&quot; 
        &gt;&gt;&gt; timesteps = pd.date_range(start, periods=5, freq=&quot;s&quot;) 
        &gt;&gt;&gt; series = pd.Series(data=[1, -1, 2, 1, 3], index=timesteps) 
        &gt;&gt;&gt; series 
        2023-03-01 07:00:00    1 
        2023-03-01 07:00:01   -1 
        2023-03-01 07:00:02    2 
        2023-03-01 07:00:03    1 
        2023-03-01 07:00:04    3 
        Freq: s, dtype: int64 
 
        Upsample the dataframe to 0.5Hz by providing the period time of 2s. 
 
        &gt;&gt;&gt; series.resample(&quot;2s&quot;).interpolate(&quot;linear&quot;) 
        2023-03-01 07:00:00    1 
        2023-03-01 07:00:02    2 
        2023-03-01 07:00:04    3 
        Freq: 2s, dtype: int64 
 
        Downsample the dataframe to 2Hz by providing the period time of 500ms. 
 
        &gt;&gt;&gt; series.resample(&quot;500ms&quot;).interpolate(&quot;linear&quot;) 
        2023-03-01 07:00:00.000    1.0 
        2023-03-01 07:00:00.500    0.0 
        2023-03-01 07:00:01.000   -1.0 
        2023-03-01 07:00:01.500    0.5 
        2023-03-01 07:00:02.000    2.0 
        2023-03-01 07:00:02.500    1.5 
        2023-03-01 07:00:03.000    1.0 
        2023-03-01 07:00:03.500    2.0 
        2023-03-01 07:00:04.000    3.0 
        Freq: 500ms, dtype: float64 
 
        Internal reindexing with ``asfreq()`` prior to interpolation leads to 
        an interpolated timeseries on the basis the reindexed timestamps (anchors). 
        Since not all datapoints from original series become anchors, 
        it can lead to misleading interpolation results as in the following example: 
 
        &gt;&gt;&gt; series.resample(&quot;400ms&quot;).interpolate(&quot;linear&quot;) 
        2023-03-01 07:00:00.000    1.0 
        2023-03-01 07:00:00.400    1.2 
        2023-03-01 07:00:00.800    1.4 
        2023-03-01 07:00:01.200    1.6 
        2023-03-01 07:00:01.600    1.8 
        2023-03-01 07:00:02.000    2.0 
        2023-03-01 07:00:02.400    2.2 
        2023-03-01 07:00:02.800    2.4 
        2023-03-01 07:00:03.200    2.6 
        2023-03-01 07:00:03.600    2.8 
        2023-03-01 07:00:04.000    3.0 
        Freq: 400ms, dtype: float64 
 
        Note that the series erroneously increases between two anchors 
        ``07:00:00`` and ``07:00:02``. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">downcast </span><span class="s0">is </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default  </span><span class="s4"># just checking coverage</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_upsample</span><span class="s2">(</span><span class="s5">&quot;asfreq&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">result</span><span class="s2">.</span><span class="s1">interpolate</span><span class="s2">(</span>
            <span class="s1">method</span><span class="s2">=</span><span class="s1">method</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
            <span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">,</span>
            <span class="s1">inplace</span><span class="s2">=</span><span class="s1">inplace</span><span class="s2">,</span>
            <span class="s1">limit_direction</span><span class="s2">=</span><span class="s1">limit_direction</span><span class="s2">,</span>
            <span class="s1">limit_area</span><span class="s2">=</span><span class="s1">limit_area</span><span class="s2">,</span>
            <span class="s1">downcast</span><span class="s2">=</span><span class="s1">downcast</span><span class="s2">,</span>
            <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">asfreq</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the values at the new freq, essentially a reindex. 
 
        Parameters 
        ---------- 
        fill_value : scalar, optional 
            Value to use for missing values, applied during upsampling (note 
            this does not fill NaNs that already were present). 
 
        Returns 
        ------- 
        DataFrame or Series 
            Values at the specified freq. 
 
        See Also 
        -------- 
        Series.asfreq: Convert TimeSeries to specified frequency. 
        DataFrame.asfreq: Convert TimeSeries to specified frequency. 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; ser = pd.Series([1, 2, 3, 4], index=pd.DatetimeIndex( 
        ...                 ['2023-01-01', '2023-01-31', '2023-02-01', '2023-02-28'])) 
        &gt;&gt;&gt; ser 
        2023-01-01    1 
        2023-01-31    2 
        2023-02-01    3 
        2023-02-28    4 
        dtype: int64 
        &gt;&gt;&gt; ser.resample('MS').asfreq() 
        2023-01-01    1 
        2023-02-01    3 
        Freq: MS, dtype: int64 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_upsample</span><span class="s2">(</span><span class="s5">&quot;asfreq&quot;</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s1">fill_value</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">sum</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">numeric_only</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">min_count</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s2">*</span><span class="s1">args</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute sum of group values. 
 
        Parameters 
        ---------- 
        numeric_only : bool, default False 
            Include only float, int, boolean columns. 
 
            .. versionchanged:: 2.0.0 
 
                numeric_only no longer accepts ``None``. 
 
        min_count : int, default 0 
            The required number of valid values to perform the operation. If fewer 
            than ``min_count`` non-NA values are present the result will be NA. 
 
        Returns 
        ------- 
        Series or DataFrame 
            Computed sum of values within each group. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; ser = pd.Series([1, 2, 3, 4], index=pd.DatetimeIndex( 
        ...                 ['2023-01-01', '2023-01-15', '2023-02-01', '2023-02-15'])) 
        &gt;&gt;&gt; ser 
        2023-01-01    1 
        2023-01-15    2 
        2023-02-01    3 
        2023-02-15    4 
        dtype: int64 
        &gt;&gt;&gt; ser.resample('MS').sum() 
        2023-01-01    3 
        2023-02-01    7 
        Freq: MS, dtype: int64 
        &quot;&quot;&quot;</span>
        <span class="s1">maybe_warn_args_and_kwargs</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s5">&quot;sum&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_resampler_func</span><span class="s2">(</span><span class="s5">&quot;sum&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_downsample</span><span class="s2">(</span><span class="s5">&quot;sum&quot;</span><span class="s2">, </span><span class="s1">numeric_only</span><span class="s2">=</span><span class="s1">numeric_only</span><span class="s2">, </span><span class="s1">min_count</span><span class="s2">=</span><span class="s1">min_count</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">prod</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">numeric_only</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">min_count</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s2">*</span><span class="s1">args</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute prod of group values. 
 
        Parameters 
        ---------- 
        numeric_only : bool, default False 
            Include only float, int, boolean columns. 
 
            .. versionchanged:: 2.0.0 
 
                numeric_only no longer accepts ``None``. 
 
        min_count : int, default 0 
            The required number of valid values to perform the operation. If fewer 
            than ``min_count`` non-NA values are present the result will be NA. 
 
        Returns 
        ------- 
        Series or DataFrame 
            Computed prod of values within each group. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; ser = pd.Series([1, 2, 3, 4], index=pd.DatetimeIndex( 
        ...                 ['2023-01-01', '2023-01-15', '2023-02-01', '2023-02-15'])) 
        &gt;&gt;&gt; ser 
        2023-01-01    1 
        2023-01-15    2 
        2023-02-01    3 
        2023-02-15    4 
        dtype: int64 
        &gt;&gt;&gt; ser.resample('MS').prod() 
        2023-01-01    2 
        2023-02-01   12 
        Freq: MS, dtype: int64 
        &quot;&quot;&quot;</span>
        <span class="s1">maybe_warn_args_and_kwargs</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s5">&quot;prod&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_resampler_func</span><span class="s2">(</span><span class="s5">&quot;prod&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_downsample</span><span class="s2">(</span><span class="s5">&quot;prod&quot;</span><span class="s2">, </span><span class="s1">numeric_only</span><span class="s2">=</span><span class="s1">numeric_only</span><span class="s2">, </span><span class="s1">min_count</span><span class="s2">=</span><span class="s1">min_count</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">min</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">numeric_only</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">min_count</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s2">*</span><span class="s1">args</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute min value of group. 
 
        Returns 
        ------- 
        Series or DataFrame 
 
        Examples 
        -------- 
        &gt;&gt;&gt; ser = pd.Series([1, 2, 3, 4], index=pd.DatetimeIndex( 
        ...                 ['2023-01-01', '2023-01-15', '2023-02-01', '2023-02-15'])) 
        &gt;&gt;&gt; ser 
        2023-01-01    1 
        2023-01-15    2 
        2023-02-01    3 
        2023-02-15    4 
        dtype: int64 
        &gt;&gt;&gt; ser.resample('MS').min() 
        2023-01-01    1 
        2023-02-01    3 
        Freq: MS, dtype: int64 
        &quot;&quot;&quot;</span>

        <span class="s1">maybe_warn_args_and_kwargs</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s5">&quot;min&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_resampler_func</span><span class="s2">(</span><span class="s5">&quot;min&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_downsample</span><span class="s2">(</span><span class="s5">&quot;min&quot;</span><span class="s2">, </span><span class="s1">numeric_only</span><span class="s2">=</span><span class="s1">numeric_only</span><span class="s2">, </span><span class="s1">min_count</span><span class="s2">=</span><span class="s1">min_count</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">max</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">numeric_only</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">min_count</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s2">*</span><span class="s1">args</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute max value of group. 
 
        Returns 
        ------- 
        Series or DataFrame 
 
        Examples 
        -------- 
        &gt;&gt;&gt; ser = pd.Series([1, 2, 3, 4], index=pd.DatetimeIndex( 
        ...                 ['2023-01-01', '2023-01-15', '2023-02-01', '2023-02-15'])) 
        &gt;&gt;&gt; ser 
        2023-01-01    1 
        2023-01-15    2 
        2023-02-01    3 
        2023-02-15    4 
        dtype: int64 
        &gt;&gt;&gt; ser.resample('MS').max() 
        2023-01-01    2 
        2023-02-01    4 
        Freq: MS, dtype: int64 
        &quot;&quot;&quot;</span>
        <span class="s1">maybe_warn_args_and_kwargs</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s5">&quot;max&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_resampler_func</span><span class="s2">(</span><span class="s5">&quot;max&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_downsample</span><span class="s2">(</span><span class="s5">&quot;max&quot;</span><span class="s2">, </span><span class="s1">numeric_only</span><span class="s2">=</span><span class="s1">numeric_only</span><span class="s2">, </span><span class="s1">min_count</span><span class="s2">=</span><span class="s1">min_count</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">GroupBy</span><span class="s2">.</span><span class="s1">first</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">first</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">numeric_only</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">min_count</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">skipna</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s2">*</span><span class="s1">args</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">maybe_warn_args_and_kwargs</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s5">&quot;first&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_resampler_func</span><span class="s2">(</span><span class="s5">&quot;first&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_downsample</span><span class="s2">(</span>
            <span class="s5">&quot;first&quot;</span><span class="s2">, </span><span class="s1">numeric_only</span><span class="s2">=</span><span class="s1">numeric_only</span><span class="s2">, </span><span class="s1">min_count</span><span class="s2">=</span><span class="s1">min_count</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">GroupBy</span><span class="s2">.</span><span class="s1">last</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">last</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">numeric_only</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">min_count</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">skipna</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s2">*</span><span class="s1">args</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">maybe_warn_args_and_kwargs</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s5">&quot;last&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_resampler_func</span><span class="s2">(</span><span class="s5">&quot;last&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_downsample</span><span class="s2">(</span>
            <span class="s5">&quot;last&quot;</span><span class="s2">, </span><span class="s1">numeric_only</span><span class="s2">=</span><span class="s1">numeric_only</span><span class="s2">, </span><span class="s1">min_count</span><span class="s2">=</span><span class="s1">min_count</span><span class="s2">, </span><span class="s1">skipna</span><span class="s2">=</span><span class="s1">skipna</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">GroupBy</span><span class="s2">.</span><span class="s1">median</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">median</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">numeric_only</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">maybe_warn_args_and_kwargs</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s5">&quot;median&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_resampler_func</span><span class="s2">(</span><span class="s5">&quot;median&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_downsample</span><span class="s2">(</span><span class="s5">&quot;median&quot;</span><span class="s2">, </span><span class="s1">numeric_only</span><span class="s2">=</span><span class="s1">numeric_only</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">mean</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">numeric_only</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s2">*</span><span class="s1">args</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute mean of groups, excluding missing values. 
 
        Parameters 
        ---------- 
        numeric_only : bool, default False 
            Include only `float`, `int` or `boolean` data. 
 
            .. versionchanged:: 2.0.0 
 
                numeric_only now defaults to ``False``. 
 
        Returns 
        ------- 
        DataFrame or Series 
            Mean of values within each group. 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; ser = pd.Series([1, 2, 3, 4], index=pd.DatetimeIndex( 
        ...                 ['2023-01-01', '2023-01-15', '2023-02-01', '2023-02-15'])) 
        &gt;&gt;&gt; ser 
        2023-01-01    1 
        2023-01-15    2 
        2023-02-01    3 
        2023-02-15    4 
        dtype: int64 
        &gt;&gt;&gt; ser.resample('MS').mean() 
        2023-01-01    1.5 
        2023-02-01    3.5 
        Freq: MS, dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">maybe_warn_args_and_kwargs</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s5">&quot;mean&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_resampler_func</span><span class="s2">(</span><span class="s5">&quot;mean&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_downsample</span><span class="s2">(</span><span class="s5">&quot;mean&quot;</span><span class="s2">, </span><span class="s1">numeric_only</span><span class="s2">=</span><span class="s1">numeric_only</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">std</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">ddof</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">numeric_only</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s2">*</span><span class="s1">args</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute standard deviation of groups, excluding missing values. 
 
        Parameters 
        ---------- 
        ddof : int, default 1 
            Degrees of freedom. 
        numeric_only : bool, default False 
            Include only `float`, `int` or `boolean` data. 
 
            .. versionadded:: 1.5.0 
 
            .. versionchanged:: 2.0.0 
 
                numeric_only now defaults to ``False``. 
 
        Returns 
        ------- 
        DataFrame or Series 
            Standard deviation of values within each group. 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; ser = pd.Series([1, 3, 2, 4, 3, 8], 
        ...                 index=pd.DatetimeIndex(['2023-01-01', 
        ...                                         '2023-01-10', 
        ...                                         '2023-01-15', 
        ...                                         '2023-02-01', 
        ...                                         '2023-02-10', 
        ...                                         '2023-02-15'])) 
        &gt;&gt;&gt; ser.resample('MS').std() 
        2023-01-01    1.000000 
        2023-02-01    2.645751 
        Freq: MS, dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">maybe_warn_args_and_kwargs</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s5">&quot;std&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_resampler_func</span><span class="s2">(</span><span class="s5">&quot;std&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_downsample</span><span class="s2">(</span><span class="s5">&quot;std&quot;</span><span class="s2">, </span><span class="s1">ddof</span><span class="s2">=</span><span class="s1">ddof</span><span class="s2">, </span><span class="s1">numeric_only</span><span class="s2">=</span><span class="s1">numeric_only</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">var</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">ddof</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">numeric_only</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s2">*</span><span class="s1">args</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute variance of groups, excluding missing values. 
 
        Parameters 
        ---------- 
        ddof : int, default 1 
            Degrees of freedom. 
 
        numeric_only : bool, default False 
            Include only `float`, `int` or `boolean` data. 
 
            .. versionadded:: 1.5.0 
 
            .. versionchanged:: 2.0.0 
 
                numeric_only now defaults to ``False``. 
 
        Returns 
        ------- 
        DataFrame or Series 
            Variance of values within each group. 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; ser = pd.Series([1, 3, 2, 4, 3, 8], 
        ...                 index=pd.DatetimeIndex(['2023-01-01', 
        ...                                         '2023-01-10', 
        ...                                         '2023-01-15', 
        ...                                         '2023-02-01', 
        ...                                         '2023-02-10', 
        ...                                         '2023-02-15'])) 
        &gt;&gt;&gt; ser.resample('MS').var() 
        2023-01-01    1.0 
        2023-02-01    7.0 
        Freq: MS, dtype: float64 
 
        &gt;&gt;&gt; ser.resample('MS').var(ddof=0) 
        2023-01-01    0.666667 
        2023-02-01    4.666667 
        Freq: MS, dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s1">maybe_warn_args_and_kwargs</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s5">&quot;var&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_resampler_func</span><span class="s2">(</span><span class="s5">&quot;var&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_downsample</span><span class="s2">(</span><span class="s5">&quot;var&quot;</span><span class="s2">, </span><span class="s1">ddof</span><span class="s2">=</span><span class="s1">ddof</span><span class="s2">, </span><span class="s1">numeric_only</span><span class="s2">=</span><span class="s1">numeric_only</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">GroupBy</span><span class="s2">.</span><span class="s1">sem</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">sem</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">ddof</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">numeric_only</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s2">*</span><span class="s1">args</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">maybe_warn_args_and_kwargs</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s5">&quot;sem&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_resampler_func</span><span class="s2">(</span><span class="s5">&quot;sem&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_downsample</span><span class="s2">(</span><span class="s5">&quot;sem&quot;</span><span class="s2">, </span><span class="s1">ddof</span><span class="s2">=</span><span class="s1">ddof</span><span class="s2">, </span><span class="s1">numeric_only</span><span class="s2">=</span><span class="s1">numeric_only</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">GroupBy</span><span class="s2">.</span><span class="s1">ohlc</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">ohlc</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s2">*</span><span class="s1">args</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">maybe_warn_args_and_kwargs</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s5">&quot;ohlc&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_resampler_func</span><span class="s2">(</span><span class="s5">&quot;ohlc&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s1">ax </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ax</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_obj_with_exclusions</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">) == </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s4"># GH#42902</span>
            <span class="s1">obj </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s1">obj</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">_asfreq_compat</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s1">obj </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">to_frame</span><span class="s2">()</span>
                <span class="s1">obj </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">reindex</span><span class="s2">([</span><span class="s5">&quot;open&quot;</span><span class="s2">, </span><span class="s5">&quot;high&quot;</span><span class="s2">, </span><span class="s5">&quot;low&quot;</span><span class="s2">, </span><span class="s5">&quot;close&quot;</span><span class="s2">], </span><span class="s1">axis</span><span class="s2">=</span><span class="s6">1</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">mi </span><span class="s2">= </span><span class="s1">MultiIndex</span><span class="s2">.</span><span class="s1">from_product</span><span class="s2">(</span>
                    <span class="s2">[</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">, [</span><span class="s5">&quot;open&quot;</span><span class="s2">, </span><span class="s5">&quot;high&quot;</span><span class="s2">, </span><span class="s5">&quot;low&quot;</span><span class="s2">, </span><span class="s5">&quot;close&quot;</span><span class="s2">]]</span>
                <span class="s2">)</span>
                <span class="s1">obj </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">reindex</span><span class="s2">(</span><span class="s1">mi</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s6">1</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">obj</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_downsample</span><span class="s2">(</span><span class="s5">&quot;ohlc&quot;</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">SeriesGroupBy</span><span class="s2">.</span><span class="s1">nunique</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">nunique</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s2">*</span><span class="s1">args</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">maybe_warn_args_and_kwargs</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s5">&quot;nunique&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">nv</span><span class="s2">.</span><span class="s1">validate_resampler_func</span><span class="s2">(</span><span class="s5">&quot;nunique&quot;</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_downsample</span><span class="s2">(</span><span class="s5">&quot;nunique&quot;</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">GroupBy</span><span class="s2">.</span><span class="s1">size</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">size</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_downsample</span><span class="s2">(</span><span class="s5">&quot;size&quot;</span><span class="s2">)</span>

        <span class="s4"># If the result is a non-empty DataFrame we stack to get a Series</span>
        <span class="s4"># GH 46826</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">ABCDataFrame</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">result</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">stack</span><span class="s2">(</span><span class="s1">future_stack</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s0">if not </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ax</span><span class="s2">):</span>
            <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>

            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_selected_obj</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s1">name </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_selected_obj</span><span class="s2">.</span><span class="s1">name</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">name </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">Series</span><span class="s2">([], </span><span class="s1">index</span><span class="s2">=</span><span class="s1">result</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s5">&quot;int64&quot;</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">GroupBy</span><span class="s2">.</span><span class="s1">count</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">count</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_downsample</span><span class="s2">(</span><span class="s5">&quot;count&quot;</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ax</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_selected_obj</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_selected_obj</span><span class="s2">)(</span>
                    <span class="s2">[], </span><span class="s1">index</span><span class="s2">=</span><span class="s1">result</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s5">&quot;int64&quot;</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_selected_obj</span><span class="s2">.</span><span class="s1">name</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">DataFrame</span>

                <span class="s1">result </span><span class="s2">= </span><span class="s1">DataFrame</span><span class="s2">(</span>
                    <span class="s2">[], </span><span class="s1">index</span><span class="s2">=</span><span class="s1">result</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">=</span><span class="s1">result</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s5">&quot;int64&quot;</span>
                <span class="s2">)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">quantile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">: </span><span class="s1">float </span><span class="s2">| </span><span class="s1">list</span><span class="s2">[</span><span class="s1">float</span><span class="s2">] | </span><span class="s1">AnyArrayLike </span><span class="s2">= </span><span class="s6">0.5</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return value at the given quantile. 
 
        Parameters 
        ---------- 
        q : float or array-like, default 0.5 (50% quantile) 
 
        Returns 
        ------- 
        DataFrame or Series 
            Quantile of values within each group. 
 
        See Also 
        -------- 
        Series.quantile 
            Return a series, where the index is q and the values are the quantiles. 
        DataFrame.quantile 
            Return a DataFrame, where the columns are the columns of self, 
            and the values are the quantiles. 
        DataFrameGroupBy.quantile 
            Return a DataFrame, where the columns are groupby columns, 
            and the values are its quantiles. 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; ser = pd.Series([1, 3, 2, 4, 3, 8], 
        ...                 index=pd.DatetimeIndex(['2023-01-01', 
        ...                                         '2023-01-10', 
        ...                                         '2023-01-15', 
        ...                                         '2023-02-01', 
        ...                                         '2023-02-10', 
        ...                                         '2023-02-15'])) 
        &gt;&gt;&gt; ser.resample('MS').quantile() 
        2023-01-01    2.0 
        2023-02-01    4.0 
        Freq: MS, dtype: float64 
 
        &gt;&gt;&gt; ser.resample('MS').quantile(.25) 
        2023-01-01    1.5 
        2023-02-01    3.5 
        Freq: MS, dtype: float64 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_downsample</span><span class="s2">(</span><span class="s5">&quot;quantile&quot;</span><span class="s2">, </span><span class="s1">q</span><span class="s2">=</span><span class="s1">q</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">_GroupByMixin</span><span class="s2">(</span><span class="s1">PandasObject</span><span class="s2">, </span><span class="s1">SelectionMixin</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Provide the groupby facilities. 
    &quot;&quot;&quot;</span>

    <span class="s1">_attributes</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">str</span><span class="s2">]  </span><span class="s4"># in practice the same as Resampler._attributes</span>
    <span class="s1">_selection</span><span class="s2">: </span><span class="s1">IndexLabel </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s1">_groupby</span><span class="s2">: </span><span class="s1">GroupBy</span>
    <span class="s1">_timegrouper</span><span class="s2">: </span><span class="s1">TimeGrouper</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">parent</span><span class="s2">: </span><span class="s1">Resampler</span><span class="s2">,</span>
        <span class="s1">groupby</span><span class="s2">: </span><span class="s1">GroupBy</span><span class="s2">,</span>
        <span class="s1">key</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">selection</span><span class="s2">: </span><span class="s1">IndexLabel </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">include_groups</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4"># reached via ._gotitem and _get_resampler_for_grouping</span>

        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">groupby</span><span class="s2">, </span><span class="s1">GroupBy</span><span class="s2">), </span><span class="s1">type</span><span class="s2">(</span><span class="s1">groupby</span><span class="s2">)</span>

        <span class="s4"># parent is always a Resampler, sometimes a _GroupByMixin</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">, </span><span class="s1">Resampler</span><span class="s2">), </span><span class="s1">type</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">)</span>

        <span class="s4"># initialize our GroupByMixin object with</span>
        <span class="s4"># the resampler attributes</span>
        <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_attributes</span><span class="s2">:</span>
            <span class="s1">setattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_selection </span><span class="s2">= </span><span class="s1">selection</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">binner </span><span class="s2">= </span><span class="s1">parent</span><span class="s2">.</span><span class="s1">binner</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">key </span><span class="s2">= </span><span class="s1">key</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_groupby </span><span class="s2">= </span><span class="s1">groupby</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper </span><span class="s2">= </span><span class="s1">copy</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">.</span><span class="s1">_timegrouper</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">ax </span><span class="s2">= </span><span class="s1">parent</span><span class="s2">.</span><span class="s1">ax</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">obj </span><span class="s2">= </span><span class="s1">parent</span><span class="s2">.</span><span class="s1">obj</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">include_groups </span><span class="s2">= </span><span class="s1">include_groups</span>

    <span class="s2">@</span><span class="s1">no_type_check</span>
    <span class="s0">def </span><span class="s1">_apply</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Dispatch to _upsample; we are stripping all of the _upsample kwargs and 
        performing the original function call on the grouped object. 
        &quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_resampler_cls</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">timegrouper</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper</span><span class="s2">, </span><span class="s1">gpr_index</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ax</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">f</span><span class="s2">)(**</span><span class="s1">kwargs</span><span class="s2">)</span>

            <span class="s0">return </span><span class="s1">x</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s1">result </span><span class="s2">= </span><span class="s1">_apply</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_groupby</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">include_groups</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">include_groups</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wrap_result</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>

    <span class="s1">_upsample </span><span class="s2">= </span><span class="s1">_apply</span>
    <span class="s1">_downsample </span><span class="s2">= </span><span class="s1">_apply</span>
    <span class="s1">_groupby_and_aggregate </span><span class="s2">= </span><span class="s1">_apply</span>

    <span class="s2">@</span><span class="s1">final</span>
    <span class="s0">def </span><span class="s1">_gotitem</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">subset</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Sub-classes to define. Return a sliced object. 
 
        Parameters 
        ---------- 
        key : string / list of selections 
        ndim : {1, 2} 
            requested ndim of result 
        subset : object, default None 
            subset to act on 
        &quot;&quot;&quot;</span>
        <span class="s4"># create a new object to prevent aliasing</span>
        <span class="s0">if </span><span class="s1">subset </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">subset </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">subset </span><span class="s2">= </span><span class="s1">subset</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s4"># reached via Apply.agg_dict_like with selection=None, ndim=1</span>
                <span class="s0">assert </span><span class="s1">subset</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span>

        <span class="s4"># Try to select from a DataFrame, falling back to a Series</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">list</span><span class="s2">) </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">key </span><span class="s0">not in </span><span class="s1">key </span><span class="s0">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">key </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">key</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">key</span><span class="s2">)</span>
            <span class="s1">groupby </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_groupby</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s1">IndexError</span><span class="s2">:</span>
            <span class="s1">groupby </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_groupby</span>

        <span class="s1">selection </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_infer_selection</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">subset</span><span class="s2">)</span>

        <span class="s1">new_rs </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span>
            <span class="s1">groupby</span><span class="s2">=</span><span class="s1">groupby</span><span class="s2">,</span>
            <span class="s1">parent</span><span class="s2">=</span><span class="s1">cast</span><span class="s2">(</span><span class="s1">Resampler</span><span class="s2">, </span><span class="s1">self</span><span class="s2">),</span>
            <span class="s1">selection</span><span class="s2">=</span><span class="s1">selection</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">new_rs</span>


<span class="s0">class </span><span class="s1">DatetimeIndexResampler</span><span class="s2">(</span><span class="s1">Resampler</span><span class="s2">):</span>
    <span class="s1">ax</span><span class="s2">: </span><span class="s1">DatetimeIndex</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">_resampler_for_grouping</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">DatetimeIndexResamplerGroupby</span>

    <span class="s0">def </span><span class="s1">_get_binner_for_time</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># this is how we are actually creating the bins</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;period&quot;</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper</span><span class="s2">.</span><span class="s1">_get_time_period_bins</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ax</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper</span><span class="s2">.</span><span class="s1">_get_time_bins</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ax</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_downsample</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">how</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Downsample the cython defined function. 
 
        Parameters 
        ---------- 
        how : string / cython mapped function 
        **kwargs : kw args passed to how function 
        &quot;&quot;&quot;</span>
        <span class="s1">orig_how </span><span class="s2">= </span><span class="s1">how</span>
        <span class="s1">how </span><span class="s2">= </span><span class="s1">com</span><span class="s2">.</span><span class="s1">get_cython_func</span><span class="s2">(</span><span class="s1">how</span><span class="s2">) </span><span class="s0">or </span><span class="s1">how</span>
        <span class="s0">if </span><span class="s1">orig_how </span><span class="s2">!= </span><span class="s1">how</span><span class="s2">:</span>
            <span class="s1">warn_alias_replacement</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">orig_how</span><span class="s2">, </span><span class="s1">how</span><span class="s2">)</span>
        <span class="s1">ax </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ax</span>

        <span class="s4"># Excludes `on` column when provided</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_obj_with_exclusions</span>

        <span class="s0">if not </span><span class="s1">len</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">):</span>
            <span class="s4"># reset to the new freq</span>
            <span class="s1">obj </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s1">obj</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">_with_freq</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">)</span>
            <span class="s0">assert </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">freq </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">, (</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">obj</span>

        <span class="s4"># do we have a regular frequency</span>

        <span class="s4"># error: Item &quot;None&quot; of &quot;Optional[Any]&quot; has no attribute &quot;binlabels&quot;</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s2">(</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">freq </span><span class="s0">is not None or </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">inferred_freq </span><span class="s0">is not None</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_grouper</span><span class="s2">.</span><span class="s1">binlabels</span><span class="s2">) &gt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">how </span><span class="s0">is None</span>
        <span class="s2">):</span>
            <span class="s4"># let's do an asfreq</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">asfreq</span><span class="s2">()</span>

        <span class="s4"># we are downsampling</span>
        <span class="s4"># we want to call the actual grouper method here</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">groupby</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_grouper</span><span class="s2">).</span><span class="s1">aggregate</span><span class="s2">(</span><span class="s1">how</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># test_resample_axis1</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">T</span><span class="s2">.</span><span class="s1">groupby</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_grouper</span><span class="s2">).</span><span class="s1">aggregate</span><span class="s2">(</span><span class="s1">how</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">).</span><span class="s1">T</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wrap_result</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_adjust_binner_for_upsample</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">binner</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Adjust our binner when upsampling. 
 
        The range of a new index should not be outside specified range 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">closed </span><span class="s2">== </span><span class="s5">&quot;right&quot;</span><span class="s2">:</span>
            <span class="s1">binner </span><span class="s2">= </span><span class="s1">binner</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">binner </span><span class="s2">= </span><span class="s1">binner</span><span class="s2">[:-</span><span class="s6">1</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">binner</span>

    <span class="s0">def </span><span class="s1">_upsample</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        method : string {'backfill', 'bfill', 'pad', 
            'ffill', 'asfreq'} method for upsampling 
        limit : int, default None 
            Maximum size gap to fill when reindexing 
        fill_value : scalar, default None 
            Value to use for missing values 
 
        See Also 
        -------- 
        .fillna: Fill NA/NaN values using the specified method. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">AssertionError</span><span class="s2">(</span><span class="s5">&quot;axis must be 0&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_from_selection</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s5">&quot;Upsampling from level= or on= selection &quot;</span>
                <span class="s5">&quot;is not supported, use .set_index(...) &quot;</span>
                <span class="s5">&quot;to explicitly set index to datetime-like&quot;</span>
            <span class="s2">)</span>

        <span class="s1">ax </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ax</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_selected_obj</span>
        <span class="s1">binner </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">binner</span>
        <span class="s1">res_index </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_adjust_binner_for_upsample</span><span class="s2">(</span><span class="s1">binner</span><span class="s2">)</span>

        <span class="s4"># if we have the same frequency as our axis, then we are equal sampling</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">limit </span><span class="s0">is None</span>
            <span class="s0">and </span><span class="s1">to_offset</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">inferred_freq</span><span class="s2">) == </span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span>
            <span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">res_index</span><span class="s2">)</span>
        <span class="s2">):</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s1">result</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">res_index</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">method </span><span class="s2">== </span><span class="s5">&quot;asfreq&quot;</span><span class="s2">:</span>
                <span class="s1">method </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">reindex</span><span class="s2">(</span>
                <span class="s1">res_index</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s1">method</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s1">fill_value</span>
            <span class="s2">)</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wrap_result</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_wrap_result</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">result</span><span class="s2">):</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">_wrap_result</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>

        <span class="s4"># we may have a different kind that we were asked originally</span>
        <span class="s4"># convert if needed</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;period&quot; </span><span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">PeriodIndex</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">MultiIndex</span><span class="s2">):</span>
                <span class="s4"># GH 24103 - e.g. groupby resample</span>
                <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">levels</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">], </span><span class="s1">PeriodIndex</span><span class="s2">):</span>
                    <span class="s1">new_level </span><span class="s2">= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">levels</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">].</span><span class="s1">to_period</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">)</span>
                    <span class="s1">result</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">set_levels</span><span class="s2">(</span><span class="s1">new_level</span><span class="s2">, </span><span class="s1">level</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">result</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">to_period</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">result</span>


<span class="s4"># error: Definition of &quot;ax&quot; in base class &quot;_GroupByMixin&quot; is incompatible</span>
<span class="s4"># with definition in base class &quot;DatetimeIndexResampler&quot;</span>
<span class="s0">class </span><span class="s1">DatetimeIndexResamplerGroupby</span><span class="s2">(  </span><span class="s4"># type: ignore[misc]</span>
    <span class="s1">_GroupByMixin</span><span class="s2">, </span><span class="s1">DatetimeIndexResampler</span>
<span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Provides a resample of a groupby implementation 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">_resampler_cls</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">DatetimeIndexResampler</span>


<span class="s0">class </span><span class="s1">PeriodIndexResampler</span><span class="s2">(</span><span class="s1">DatetimeIndexResampler</span><span class="s2">):</span>
    <span class="s4"># error: Incompatible types in assignment (expression has type &quot;PeriodIndex&quot;, base</span>
    <span class="s4"># class &quot;DatetimeIndexResampler&quot; defined the type as &quot;DatetimeIndex&quot;)</span>
    <span class="s1">ax</span><span class="s2">: </span><span class="s1">PeriodIndex  </span><span class="s4"># type: ignore[assignment]</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">_resampler_for_grouping</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
            <span class="s5">&quot;Resampling a groupby with a PeriodIndex is deprecated. &quot;</span>
            <span class="s5">&quot;Cast to DatetimeIndex before resampling instead.&quot;</span><span class="s2">,</span>
            <span class="s1">FutureWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">PeriodIndexResamplerGroupby</span>

    <span class="s0">def </span><span class="s1">_get_binner_for_time</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;timestamp&quot;</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">_get_binner_for_time</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper</span><span class="s2">.</span><span class="s1">_get_period_bins</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ax</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_convert_obj</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">: </span><span class="s1">NDFrameT</span><span class="s2">) </span><span class="s1">-&gt; NDFrameT</span><span class="s2">:</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">_convert_obj</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_from_selection</span><span class="s2">:</span>
            <span class="s4"># see GH 14008, GH 12871</span>
            <span class="s1">msg </span><span class="s2">= (</span>
                <span class="s5">&quot;Resampling from level= or on= selection &quot;</span>
                <span class="s5">&quot;with a PeriodIndex is not currently supported, &quot;</span>
                <span class="s5">&quot;use .set_index(...) to explicitly set index&quot;</span>
            <span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

        <span class="s4"># convert to timestamp</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;timestamp&quot;</span><span class="s2">:</span>
            <span class="s1">obj </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">to_timestamp</span><span class="s2">(</span><span class="s1">how</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">convention</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">obj</span>

    <span class="s0">def </span><span class="s1">_downsample</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">how</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Downsample the cython defined function. 
 
        Parameters 
        ---------- 
        how : string / cython mapped function 
        **kwargs : kw args passed to how function 
        &quot;&quot;&quot;</span>
        <span class="s4"># we may need to actually resample as if we are timestamps</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;timestamp&quot;</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">_downsample</span><span class="s2">(</span><span class="s1">how</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

        <span class="s1">orig_how </span><span class="s2">= </span><span class="s1">how</span>
        <span class="s1">how </span><span class="s2">= </span><span class="s1">com</span><span class="s2">.</span><span class="s1">get_cython_func</span><span class="s2">(</span><span class="s1">how</span><span class="s2">) </span><span class="s0">or </span><span class="s1">how</span>
        <span class="s0">if </span><span class="s1">orig_how </span><span class="s2">!= </span><span class="s1">how</span><span class="s2">:</span>
            <span class="s1">warn_alias_replacement</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">orig_how</span><span class="s2">, </span><span class="s1">how</span><span class="s2">)</span>
        <span class="s1">ax </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ax</span>

        <span class="s0">if </span><span class="s1">is_subperiod</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">):</span>
            <span class="s4"># Downsampling</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_groupby_and_aggregate</span><span class="s2">(</span><span class="s1">how</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">is_superperiod</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">how </span><span class="s2">== </span><span class="s5">&quot;ohlc&quot;</span><span class="s2">:</span>
                <span class="s4"># GH #13083</span>
                <span class="s4"># upsampling to subperiods is handled as an asfreq, which works</span>
                <span class="s4"># for pure aggregating/reducing methods</span>
                <span class="s4"># OHLC reduces along the time dimension, but creates multiple</span>
                <span class="s4"># values for each period -&gt; handle by _groupby_and_aggregate()</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_groupby_and_aggregate</span><span class="s2">(</span><span class="s1">how</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">asfreq</span><span class="s2">()</span>
        <span class="s0">elif </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">freq </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">asfreq</span><span class="s2">()</span>

        <span class="s0">raise </span><span class="s1">IncompatibleFrequency</span><span class="s2">(</span>
            <span class="s5">f&quot;Frequency </span><span class="s0">{</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">freq</span><span class="s0">} </span><span class="s5">cannot be resampled to </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s0">}</span><span class="s5">, &quot;</span>
            <span class="s5">&quot;as they are not sub or super periods&quot;</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_upsample</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        method : {'backfill', 'bfill', 'pad', 'ffill'} 
            Method for upsampling. 
        limit : int, default None 
            Maximum size gap to fill when reindexing. 
        fill_value : scalar, default None 
            Value to use for missing values. 
 
        See Also 
        -------- 
        .fillna: Fill NA/NaN values using the specified method. 
 
        &quot;&quot;&quot;</span>
        <span class="s4"># we may need to actually resample as if we are timestamps</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;timestamp&quot;</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">_upsample</span><span class="s2">(</span><span class="s1">method</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s1">fill_value</span><span class="s2">)</span>

        <span class="s1">ax </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ax</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">obj</span>
        <span class="s1">new_index </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">binner</span>

        <span class="s4"># Start vs. end of period</span>
        <span class="s1">memb </span><span class="s2">= </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">asfreq</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">how</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">convention</span><span class="s2">)</span>

        <span class="s4"># Get the fill indexer</span>
        <span class="s0">if </span><span class="s1">method </span><span class="s2">== </span><span class="s5">&quot;asfreq&quot;</span><span class="s2">:</span>
            <span class="s1">method </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">indexer </span><span class="s2">= </span><span class="s1">memb</span><span class="s2">.</span><span class="s1">get_indexer</span><span class="s2">(</span><span class="s1">new_index</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s1">method</span><span class="s2">, </span><span class="s1">limit</span><span class="s2">=</span><span class="s1">limit</span><span class="s2">)</span>
        <span class="s1">new_obj </span><span class="s2">= </span><span class="s1">_take_new_index</span><span class="s2">(</span>
            <span class="s1">obj</span><span class="s2">,</span>
            <span class="s1">indexer</span><span class="s2">,</span>
            <span class="s1">new_index</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_wrap_result</span><span class="s2">(</span><span class="s1">new_obj</span><span class="s2">)</span>


<span class="s4"># error: Definition of &quot;ax&quot; in base class &quot;_GroupByMixin&quot; is incompatible with</span>
<span class="s4"># definition in base class &quot;PeriodIndexResampler&quot;</span>
<span class="s0">class </span><span class="s1">PeriodIndexResamplerGroupby</span><span class="s2">(  </span><span class="s4"># type: ignore[misc]</span>
    <span class="s1">_GroupByMixin</span><span class="s2">, </span><span class="s1">PeriodIndexResampler</span>
<span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Provides a resample of a groupby implementation. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">_resampler_cls</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">PeriodIndexResampler</span>


<span class="s0">class </span><span class="s1">TimedeltaIndexResampler</span><span class="s2">(</span><span class="s1">DatetimeIndexResampler</span><span class="s2">):</span>
    <span class="s4"># error: Incompatible types in assignment (expression has type &quot;TimedeltaIndex&quot;,</span>
    <span class="s4"># base class &quot;DatetimeIndexResampler&quot; defined the type as &quot;DatetimeIndex&quot;)</span>
    <span class="s1">ax</span><span class="s2">: </span><span class="s1">TimedeltaIndex  </span><span class="s4"># type: ignore[assignment]</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">_resampler_for_grouping</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">TimedeltaIndexResamplerGroupby</span>

    <span class="s0">def </span><span class="s1">_get_binner_for_time</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_timegrouper</span><span class="s2">.</span><span class="s1">_get_time_delta_bins</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ax</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_adjust_binner_for_upsample</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">binner</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Adjust our binner when upsampling. 
 
        The range of a new index is allowed to be greater than original range 
        so we don't need to change the length of a binner, GH 13022 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">binner</span>


<span class="s4"># error: Definition of &quot;ax&quot; in base class &quot;_GroupByMixin&quot; is incompatible with</span>
<span class="s4"># definition in base class &quot;DatetimeIndexResampler&quot;</span>
<span class="s0">class </span><span class="s1">TimedeltaIndexResamplerGroupby</span><span class="s2">(  </span><span class="s4"># type: ignore[misc]</span>
    <span class="s1">_GroupByMixin</span><span class="s2">, </span><span class="s1">TimedeltaIndexResampler</span>
<span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Provides a resample of a groupby implementation. 
    &quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">_resampler_cls</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">TimedeltaIndexResampler</span>


<span class="s0">def </span><span class="s1">get_resampler</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">: </span><span class="s1">Series </span><span class="s2">| </span><span class="s1">DataFrame</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, **</span><span class="s1">kwds</span><span class="s2">) </span><span class="s1">-&gt; Resampler</span><span class="s2">:</span>
    <span class="s3">&quot;&quot;&quot; 
    Create a TimeGrouper and return our resampler. 
    &quot;&quot;&quot;</span>
    <span class="s1">tg </span><span class="s2">= </span><span class="s1">TimeGrouper</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, **</span><span class="s1">kwds</span><span class="s2">)  </span><span class="s4"># type: ignore[arg-type]</span>
    <span class="s0">return </span><span class="s1">tg</span><span class="s2">.</span><span class="s1">_get_resampler</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">=</span><span class="s1">kind</span><span class="s2">)</span>


<span class="s1">get_resampler</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">Resampler</span><span class="s2">.</span><span class="s1">__doc__</span>


<span class="s0">def </span><span class="s1">get_resampler_for_grouping</span><span class="s2">(</span>
    <span class="s1">groupby</span><span class="s2">: </span><span class="s1">GroupBy</span><span class="s2">,</span>
    <span class="s1">rule</span><span class="s2">,</span>
    <span class="s1">how</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">fill_method</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">limit</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">kind</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">on</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">include_groups</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; Resampler</span><span class="s2">:</span>
    <span class="s3">&quot;&quot;&quot; 
    Return our appropriate resampler when grouping as well. 
    &quot;&quot;&quot;</span>
    <span class="s4"># .resample uses 'on' similar to how .groupby uses 'key'</span>
    <span class="s1">tg </span><span class="s2">= </span><span class="s1">TimeGrouper</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">=</span><span class="s1">rule</span><span class="s2">, </span><span class="s1">key</span><span class="s2">=</span><span class="s1">on</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
    <span class="s1">resampler </span><span class="s2">= </span><span class="s1">tg</span><span class="s2">.</span><span class="s1">_get_resampler</span><span class="s2">(</span><span class="s1">groupby</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">=</span><span class="s1">kind</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">resampler</span><span class="s2">.</span><span class="s1">_get_resampler_for_grouping</span><span class="s2">(</span>
        <span class="s1">groupby</span><span class="s2">=</span><span class="s1">groupby</span><span class="s2">, </span><span class="s1">include_groups</span><span class="s2">=</span><span class="s1">include_groups</span><span class="s2">, </span><span class="s1">key</span><span class="s2">=</span><span class="s1">tg</span><span class="s2">.</span><span class="s1">key</span>
    <span class="s2">)</span>


<span class="s0">class </span><span class="s1">TimeGrouper</span><span class="s2">(</span><span class="s1">Grouper</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Custom groupby class for time-interval grouping. 
 
    Parameters 
    ---------- 
    freq : pandas date offset or offset alias for identifying bin edges 
    closed : closed end of interval; 'left' or 'right' 
    label : interval boundary to use for labeling; 'left' or 'right' 
    convention : {'start', 'end', 'e', 's'} 
        If axis is PeriodIndex 
    &quot;&quot;&quot;</span>

    <span class="s1">_attributes </span><span class="s2">= </span><span class="s1">Grouper</span><span class="s2">.</span><span class="s1">_attributes </span><span class="s2">+ (</span>
        <span class="s5">&quot;closed&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;label&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;how&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;kind&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;convention&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;origin&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;offset&quot;</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s1">origin</span><span class="s2">: </span><span class="s1">TimeGrouperOrigin</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">obj</span><span class="s2">: </span><span class="s1">Grouper </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">freq</span><span class="s2">: </span><span class="s1">Frequency </span><span class="s2">= </span><span class="s5">&quot;Min&quot;</span><span class="s2">,</span>
        <span class="s1">key</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">closed</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;left&quot;</span><span class="s2">, </span><span class="s5">&quot;right&quot;</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">label</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;left&quot;</span><span class="s2">, </span><span class="s5">&quot;right&quot;</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">how</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s5">&quot;mean&quot;</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">: </span><span class="s1">Axis </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">fill_method</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">limit</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">convention</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;start&quot;</span><span class="s2">, </span><span class="s5">&quot;end&quot;</span><span class="s2">, </span><span class="s5">&quot;e&quot;</span><span class="s2">, </span><span class="s5">&quot;s&quot;</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">origin</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;epoch&quot;</span><span class="s2">, </span><span class="s5">&quot;start&quot;</span><span class="s2">, </span><span class="s5">&quot;start_day&quot;</span><span class="s2">, </span><span class="s5">&quot;end&quot;</span><span class="s2">, </span><span class="s5">&quot;end_day&quot;</span><span class="s2">]</span>
        <span class="s2">| </span><span class="s1">TimestampConvertibleTypes </span><span class="s2">= </span><span class="s5">&quot;start_day&quot;</span><span class="s2">,</span>
        <span class="s1">offset</span><span class="s2">: </span><span class="s1">TimedeltaConvertibleTypes </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">group_keys</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4"># Check for correctness of the keyword arguments which would</span>
        <span class="s4"># otherwise silently use the default if misspelled</span>
        <span class="s0">if </span><span class="s1">label </span><span class="s0">not in </span><span class="s2">{</span><span class="s0">None</span><span class="s2">, </span><span class="s5">&quot;left&quot;</span><span class="s2">, </span><span class="s5">&quot;right&quot;</span><span class="s2">}:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">f&quot;Unsupported value </span><span class="s0">{</span><span class="s1">label</span><span class="s0">} </span><span class="s5">for `label`&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">closed </span><span class="s0">not in </span><span class="s2">{</span><span class="s0">None</span><span class="s2">, </span><span class="s5">&quot;left&quot;</span><span class="s2">, </span><span class="s5">&quot;right&quot;</span><span class="s2">}:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">f&quot;Unsupported value </span><span class="s0">{</span><span class="s1">closed</span><span class="s0">} </span><span class="s5">for `closed`&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">convention </span><span class="s0">not in </span><span class="s2">{</span><span class="s0">None</span><span class="s2">, </span><span class="s5">&quot;start&quot;</span><span class="s2">, </span><span class="s5">&quot;end&quot;</span><span class="s2">, </span><span class="s5">&quot;e&quot;</span><span class="s2">, </span><span class="s5">&quot;s&quot;</span><span class="s2">}:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">f&quot;Unsupported value </span><span class="s0">{</span><span class="s1">convention</span><span class="s0">} </span><span class="s5">for `convention`&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">key </span><span class="s0">is None</span>
            <span class="s0">and </span><span class="s1">obj </span><span class="s0">is not None</span>
            <span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">PeriodIndex</span><span class="s2">)  </span><span class="s4"># type: ignore[attr-defined]</span>
            <span class="s0">or </span><span class="s2">(</span>
                <span class="s1">key </span><span class="s0">is not None</span>
                <span class="s0">and </span><span class="s1">obj </span><span class="s0">is not None</span>
                <span class="s0">and </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">[</span><span class="s1">key</span><span class="s2">], </span><span class="s5">&quot;dtype&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">) == </span><span class="s5">&quot;period&quot;  </span><span class="s4"># type: ignore[index]</span>
            <span class="s2">)</span>
        <span class="s2">):</span>
            <span class="s1">freq </span><span class="s2">= </span><span class="s1">to_offset</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">is_period</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">freq </span><span class="s2">= </span><span class="s1">to_offset</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">)</span>

        <span class="s1">end_types </span><span class="s2">= {</span><span class="s5">&quot;ME&quot;</span><span class="s2">, </span><span class="s5">&quot;YE&quot;</span><span class="s2">, </span><span class="s5">&quot;QE&quot;</span><span class="s2">, </span><span class="s5">&quot;BME&quot;</span><span class="s2">, </span><span class="s5">&quot;BYE&quot;</span><span class="s2">, </span><span class="s5">&quot;BQE&quot;</span><span class="s2">, </span><span class="s5">&quot;W&quot;</span><span class="s2">}</span>
        <span class="s1">rule </span><span class="s2">= </span><span class="s1">freq</span><span class="s2">.</span><span class="s1">rule_code</span>
        <span class="s0">if </span><span class="s1">rule </span><span class="s0">in </span><span class="s1">end_types </span><span class="s0">or </span><span class="s2">(</span><span class="s5">&quot;-&quot; </span><span class="s0">in </span><span class="s1">rule </span><span class="s0">and </span><span class="s1">rule</span><span class="s2">[: </span><span class="s1">rule</span><span class="s2">.</span><span class="s1">find</span><span class="s2">(</span><span class="s5">&quot;-&quot;</span><span class="s2">)] </span><span class="s0">in </span><span class="s1">end_types</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">closed </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s1">closed </span><span class="s2">= </span><span class="s5">&quot;right&quot;</span>
            <span class="s0">if </span><span class="s1">label </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s1">label </span><span class="s2">= </span><span class="s5">&quot;right&quot;</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># The backward resample sets ``closed`` to ``'right'`` by default</span>
            <span class="s4"># since the last value should be considered as the edge point for</span>
            <span class="s4"># the last bin. When origin in &quot;end&quot; or &quot;end_day&quot;, the value for a</span>
            <span class="s4"># specific ``Timestamp`` index stands for the resample result from</span>
            <span class="s4"># the current ``Timestamp`` minus ``freq`` to the current</span>
            <span class="s4"># ``Timestamp`` with a right close.</span>
            <span class="s0">if </span><span class="s1">origin </span><span class="s0">in </span><span class="s2">[</span><span class="s5">&quot;end&quot;</span><span class="s2">, </span><span class="s5">&quot;end_day&quot;</span><span class="s2">]:</span>
                <span class="s0">if </span><span class="s1">closed </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s1">closed </span><span class="s2">= </span><span class="s5">&quot;right&quot;</span>
                <span class="s0">if </span><span class="s1">label </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s1">label </span><span class="s2">= </span><span class="s5">&quot;right&quot;</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">closed </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s1">closed </span><span class="s2">= </span><span class="s5">&quot;left&quot;</span>
                <span class="s0">if </span><span class="s1">label </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s1">label </span><span class="s2">= </span><span class="s5">&quot;left&quot;</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">closed </span><span class="s2">= </span><span class="s1">closed</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">label </span><span class="s2">= </span><span class="s1">label</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">= </span><span class="s1">kind</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">convention </span><span class="s2">= </span><span class="s1">convention </span><span class="s0">if </span><span class="s1">convention </span><span class="s0">is not None else </span><span class="s5">&quot;e&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">how </span><span class="s2">= </span><span class="s1">how</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">fill_method </span><span class="s2">= </span><span class="s1">fill_method</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">limit </span><span class="s2">= </span><span class="s1">limit</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">group_keys </span><span class="s2">= </span><span class="s1">group_keys</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_arrow_dtype</span><span class="s2">: </span><span class="s1">ArrowDtype </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">origin </span><span class="s0">in </span><span class="s2">(</span><span class="s5">&quot;epoch&quot;</span><span class="s2">, </span><span class="s5">&quot;start&quot;</span><span class="s2">, </span><span class="s5">&quot;start_day&quot;</span><span class="s2">, </span><span class="s5">&quot;end&quot;</span><span class="s2">, </span><span class="s5">&quot;end_day&quot;</span><span class="s2">):</span>
            <span class="s4"># error: Incompatible types in assignment (expression has type &quot;Union[Union[</span>
            <span class="s4"># Timestamp, datetime, datetime64, signedinteger[_64Bit], float, str],</span>
            <span class="s4"># Literal['epoch', 'start', 'start_day', 'end', 'end_day']]&quot;, variable has</span>
            <span class="s4"># type &quot;Union[Timestamp, Literal['epoch', 'start', 'start_day', 'end',</span>
            <span class="s4"># 'end_day']]&quot;)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">origin </span><span class="s2">= </span><span class="s1">origin  </span><span class="s4"># type: ignore[assignment]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">origin </span><span class="s2">= </span><span class="s1">Timestamp</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">err</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s5">&quot;'origin' should be equal to 'epoch', 'start', 'start_day', &quot;</span>
                    <span class="s5">&quot;'end', 'end_day' or &quot;</span>
                    <span class="s5">f&quot;should be a Timestamp convertible type. Got '</span><span class="s0">{</span><span class="s1">origin</span><span class="s0">}</span><span class="s5">' instead.&quot;</span>
                <span class="s2">) </span><span class="s0">from </span><span class="s1">err</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">offset </span><span class="s2">= </span><span class="s1">Timedelta</span><span class="s2">(</span><span class="s1">offset</span><span class="s2">) </span><span class="s0">if </span><span class="s1">offset </span><span class="s0">is not None else None</span>
        <span class="s0">except </span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">err</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s5">&quot;'offset' should be a Timedelta convertible type. &quot;</span>
                <span class="s5">f&quot;Got '</span><span class="s0">{</span><span class="s1">offset</span><span class="s0">}</span><span class="s5">' instead.&quot;</span>
            <span class="s2">) </span><span class="s0">from </span><span class="s1">err</span>

        <span class="s4"># always sort time groupers</span>
        <span class="s1">kwargs</span><span class="s2">[</span><span class="s5">&quot;sort&quot;</span><span class="s2">] = </span><span class="s0">True</span>

        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">=</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">key</span><span class="s2">=</span><span class="s1">key</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_get_resampler</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">: </span><span class="s1">NDFrame</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">=</span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; Resampler</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return my resampler or raise if we have an invalid axis. 
 
        Parameters 
        ---------- 
        obj : Series or DataFrame 
        kind : string, optional 
            'period','timestamp','timedelta' are valid 
 
        Returns 
        ------- 
        Resampler 
 
        Raises 
        ------ 
        TypeError if incompatible axis 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_set_grouper</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">gpr_index</span><span class="s2">=</span><span class="s0">None</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">, </span><span class="s1">DatetimeIndex</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">DatetimeIndexResampler</span><span class="s2">(</span>
                <span class="s1">obj</span><span class="s2">,</span>
                <span class="s1">timegrouper</span><span class="s2">=</span><span class="s1">self</span><span class="s2">,</span>
                <span class="s1">kind</span><span class="s2">=</span><span class="s1">kind</span><span class="s2">,</span>
                <span class="s1">axis</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">,</span>
                <span class="s1">group_keys</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">group_keys</span><span class="s2">,</span>
                <span class="s1">gpr_index</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">, </span><span class="s1">PeriodIndex</span><span class="s2">) </span><span class="s0">or </span><span class="s1">kind </span><span class="s2">== </span><span class="s5">&quot;period&quot;</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">, </span><span class="s1">PeriodIndex</span><span class="s2">):</span>
                <span class="s4"># GH#53481</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                    <span class="s5">&quot;Resampling with a PeriodIndex is deprecated. &quot;</span>
                    <span class="s5">&quot;Cast index to DatetimeIndex before resampling instead.&quot;</span><span class="s2">,</span>
                    <span class="s1">FutureWarning</span><span class="s2">,</span>
                    <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                    <span class="s5">&quot;Resampling with kind='period' is deprecated.  &quot;</span>
                    <span class="s5">&quot;Use datetime paths instead.&quot;</span><span class="s2">,</span>
                    <span class="s1">FutureWarning</span><span class="s2">,</span>
                    <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
                <span class="s2">)</span>
            <span class="s0">return </span><span class="s1">PeriodIndexResampler</span><span class="s2">(</span>
                <span class="s1">obj</span><span class="s2">,</span>
                <span class="s1">timegrouper</span><span class="s2">=</span><span class="s1">self</span><span class="s2">,</span>
                <span class="s1">kind</span><span class="s2">=</span><span class="s1">kind</span><span class="s2">,</span>
                <span class="s1">axis</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">,</span>
                <span class="s1">group_keys</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">group_keys</span><span class="s2">,</span>
                <span class="s1">gpr_index</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">, </span><span class="s1">TimedeltaIndex</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">TimedeltaIndexResampler</span><span class="s2">(</span>
                <span class="s1">obj</span><span class="s2">,</span>
                <span class="s1">timegrouper</span><span class="s2">=</span><span class="s1">self</span><span class="s2">,</span>
                <span class="s1">axis</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axis</span><span class="s2">,</span>
                <span class="s1">group_keys</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">group_keys</span><span class="s2">,</span>
                <span class="s1">gpr_index</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">,</span>
            <span class="s2">)</span>

        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
            <span class="s5">&quot;Only valid with DatetimeIndex, &quot;</span>
            <span class="s5">&quot;TimedeltaIndex or PeriodIndex, &quot;</span>
            <span class="s5">f&quot;but got an instance of '</span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">}</span><span class="s5">'&quot;</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_get_grouper</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">: </span><span class="s1">NDFrameT</span><span class="s2">, </span><span class="s1">validate</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">BinGrouper</span><span class="s2">, </span><span class="s1">NDFrameT</span><span class="s2">]:</span>
        <span class="s4"># create the resampler and return our binner</span>
        <span class="s1">r </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_resampler</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">r</span><span class="s2">.</span><span class="s1">_grouper</span><span class="s2">, </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">NDFrameT</span><span class="s2">, </span><span class="s1">r</span><span class="s2">.</span><span class="s1">obj</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_get_time_bins</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">: </span><span class="s1">DatetimeIndex</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">, </span><span class="s1">DatetimeIndex</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s5">&quot;axis must be a DatetimeIndex, but got &quot;</span>
                <span class="s5">f&quot;an instance of </span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">}</span><span class="s5">&quot;</span>
            <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">) == </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">binner </span><span class="s2">= </span><span class="s1">labels </span><span class="s2">= </span><span class="s1">DatetimeIndex</span><span class="s2">(</span>
                <span class="s1">data</span><span class="s2">=[], </span><span class="s1">freq</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">dtype</span>
            <span class="s2">)</span>
            <span class="s0">return </span><span class="s1">binner</span><span class="s2">, [], </span><span class="s1">labels</span>

        <span class="s1">first</span><span class="s2">, </span><span class="s1">last </span><span class="s2">= </span><span class="s1">_get_timestamp_range_edges</span><span class="s2">(</span>
            <span class="s1">ax</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(),</span>
            <span class="s1">ax</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(),</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">,</span>
            <span class="s1">unit</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">unit</span><span class="s2">,</span>
            <span class="s1">closed</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">closed</span><span class="s2">,</span>
            <span class="s1">origin</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">origin</span><span class="s2">,</span>
            <span class="s1">offset</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offset</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s4"># GH #12037</span>
        <span class="s4"># use first/last directly instead of call replace() on them</span>
        <span class="s4"># because replace() will swallow the nanosecond part</span>
        <span class="s4"># thus last bin maybe slightly before the end if the end contains</span>
        <span class="s4"># nanosecond part and lead to `Values falls after last bin` error</span>
        <span class="s4"># GH 25758: If DST lands at midnight (e.g. 'America/Havana'), user feedback</span>
        <span class="s4"># has noted that ambiguous=True provides the most sensible result</span>
        <span class="s1">binner </span><span class="s2">= </span><span class="s1">labels </span><span class="s2">= </span><span class="s1">date_range</span><span class="s2">(</span>
            <span class="s1">freq</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">,</span>
            <span class="s1">start</span><span class="s2">=</span><span class="s1">first</span><span class="s2">,</span>
            <span class="s1">end</span><span class="s2">=</span><span class="s1">last</span><span class="s2">,</span>
            <span class="s1">tz</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">tz</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
            <span class="s1">ambiguous</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
            <span class="s1">nonexistent</span><span class="s2">=</span><span class="s5">&quot;shift_forward&quot;</span><span class="s2">,</span>
            <span class="s1">unit</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">unit</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s1">ax_values </span><span class="s2">= </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">asi8</span>
        <span class="s1">binner</span><span class="s2">, </span><span class="s1">bin_edges </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_adjust_bin_edges</span><span class="s2">(</span><span class="s1">binner</span><span class="s2">, </span><span class="s1">ax_values</span><span class="s2">)</span>

        <span class="s4"># general version, knowing nothing about relative frequencies</span>
        <span class="s1">bins </span><span class="s2">= </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">generate_bins_dt64</span><span class="s2">(</span>
            <span class="s1">ax_values</span><span class="s2">, </span><span class="s1">bin_edges</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">closed</span><span class="s2">, </span><span class="s1">hasnans</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">hasnans</span>
        <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">closed </span><span class="s2">== </span><span class="s5">&quot;right&quot;</span><span class="s2">:</span>
            <span class="s1">labels </span><span class="s2">= </span><span class="s1">binner</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">label </span><span class="s2">== </span><span class="s5">&quot;right&quot;</span><span class="s2">:</span>
                <span class="s1">labels </span><span class="s2">= </span><span class="s1">labels</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:]</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">label </span><span class="s2">== </span><span class="s5">&quot;right&quot;</span><span class="s2">:</span>
            <span class="s1">labels </span><span class="s2">= </span><span class="s1">labels</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:]</span>

        <span class="s0">if </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">hasnans</span><span class="s2">:</span>
            <span class="s1">binner </span><span class="s2">= </span><span class="s1">binner</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">)</span>
            <span class="s1">labels </span><span class="s2">= </span><span class="s1">labels</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">)</span>

        <span class="s4"># if we end up with more labels than bins</span>
        <span class="s4"># adjust the labels</span>
        <span class="s4"># GH4076</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">bins</span><span class="s2">) &lt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">labels</span><span class="s2">):</span>
            <span class="s1">labels </span><span class="s2">= </span><span class="s1">labels</span><span class="s2">[: </span><span class="s1">len</span><span class="s2">(</span><span class="s1">bins</span><span class="s2">)]</span>

        <span class="s0">return </span><span class="s1">binner</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">, </span><span class="s1">labels</span>

    <span class="s0">def </span><span class="s1">_adjust_bin_edges</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">binner</span><span class="s2">: </span><span class="s1">DatetimeIndex</span><span class="s2">, </span><span class="s1">ax_values</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">]</span>
    <span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">DatetimeIndex</span><span class="s2">, </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">]]:</span>
        <span class="s4"># Some hacks for &gt; daily data, see #1471, #1458, #1483</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">.</span><span class="s1">name </span><span class="s0">in </span><span class="s2">(</span><span class="s5">&quot;BME&quot;</span><span class="s2">, </span><span class="s5">&quot;ME&quot;</span><span class="s2">, </span><span class="s5">&quot;W&quot;</span><span class="s2">) </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">.</span><span class="s1">name</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s5">&quot;-&quot;</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">] </span><span class="s0">in </span><span class="s2">(</span>
            <span class="s5">&quot;BQE&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;BYE&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;QE&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;YE&quot;</span><span class="s2">,</span>
            <span class="s5">&quot;W&quot;</span><span class="s2">,</span>
        <span class="s2">):</span>
            <span class="s4"># If the right end-point is on the last day of the month, roll forwards</span>
            <span class="s4"># until the last moment of that day. Note that we only do this for offsets</span>
            <span class="s4"># which correspond to the end of a super-daily period - &quot;month start&quot;, for</span>
            <span class="s4"># example, is excluded.</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">closed </span><span class="s2">== </span><span class="s5">&quot;right&quot;</span><span class="s2">:</span>
                <span class="s4"># GH 21459, GH 9119: Adjust the bins relative to the wall time</span>
                <span class="s1">edges_dti </span><span class="s2">= </span><span class="s1">binner</span><span class="s2">.</span><span class="s1">tz_localize</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
                <span class="s1">edges_dti </span><span class="s2">= (</span>
                    <span class="s1">edges_dti</span>
                    <span class="s2">+ </span><span class="s1">Timedelta</span><span class="s2">(</span><span class="s1">days</span><span class="s2">=</span><span class="s6">1</span><span class="s2">, </span><span class="s1">unit</span><span class="s2">=</span><span class="s1">edges_dti</span><span class="s2">.</span><span class="s1">unit</span><span class="s2">).</span><span class="s1">as_unit</span><span class="s2">(</span><span class="s1">edges_dti</span><span class="s2">.</span><span class="s1">unit</span><span class="s2">)</span>
                    <span class="s2">- </span><span class="s1">Timedelta</span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s1">unit</span><span class="s2">=</span><span class="s1">edges_dti</span><span class="s2">.</span><span class="s1">unit</span><span class="s2">).</span><span class="s1">as_unit</span><span class="s2">(</span><span class="s1">edges_dti</span><span class="s2">.</span><span class="s1">unit</span><span class="s2">)</span>
                <span class="s2">)</span>
                <span class="s1">bin_edges </span><span class="s2">= </span><span class="s1">edges_dti</span><span class="s2">.</span><span class="s1">tz_localize</span><span class="s2">(</span><span class="s1">binner</span><span class="s2">.</span><span class="s1">tz</span><span class="s2">).</span><span class="s1">asi8</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">bin_edges </span><span class="s2">= </span><span class="s1">binner</span><span class="s2">.</span><span class="s1">asi8</span>

            <span class="s4"># intraday values on last day</span>
            <span class="s0">if </span><span class="s1">bin_edges</span><span class="s2">[-</span><span class="s6">2</span><span class="s2">] &gt; </span><span class="s1">ax_values</span><span class="s2">.</span><span class="s1">max</span><span class="s2">():</span>
                <span class="s1">bin_edges </span><span class="s2">= </span><span class="s1">bin_edges</span><span class="s2">[:-</span><span class="s6">1</span><span class="s2">]</span>
                <span class="s1">binner </span><span class="s2">= </span><span class="s1">binner</span><span class="s2">[:-</span><span class="s6">1</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">bin_edges </span><span class="s2">= </span><span class="s1">binner</span><span class="s2">.</span><span class="s1">asi8</span>
        <span class="s0">return </span><span class="s1">binner</span><span class="s2">, </span><span class="s1">bin_edges</span>

    <span class="s0">def </span><span class="s1">_get_time_delta_bins</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">: </span><span class="s1">TimedeltaIndex</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">, </span><span class="s1">TimedeltaIndex</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s5">&quot;axis must be a TimedeltaIndex, but got &quot;</span>
                <span class="s5">f&quot;an instance of </span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">}</span><span class="s5">&quot;</span>
            <span class="s2">)</span>

        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">Tick</span><span class="s2">):</span>
            <span class="s4"># GH#51896</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s5">&quot;Resampling on a TimedeltaIndex requires fixed-duration `freq`, &quot;</span>
                <span class="s5">f&quot;e.g. '24h' or '3D', not </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s0">}</span><span class="s5">&quot;</span>
            <span class="s2">)</span>

        <span class="s0">if not </span><span class="s1">len</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">):</span>
            <span class="s1">binner </span><span class="s2">= </span><span class="s1">labels </span><span class="s2">= </span><span class="s1">TimedeltaIndex</span><span class="s2">(</span><span class="s1">data</span><span class="s2">=[], </span><span class="s1">freq</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">binner</span><span class="s2">, [], </span><span class="s1">labels</span>

        <span class="s1">start</span><span class="s2">, </span><span class="s1">end </span><span class="s2">= </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(), </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">max</span><span class="s2">()</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">closed </span><span class="s2">== </span><span class="s5">&quot;right&quot;</span><span class="s2">:</span>
            <span class="s1">end </span><span class="s2">+= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span>

        <span class="s1">labels </span><span class="s2">= </span><span class="s1">binner </span><span class="s2">= </span><span class="s1">timedelta_range</span><span class="s2">(</span>
            <span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">=</span><span class="s1">end</span><span class="s2">, </span><span class="s1">freq</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">name</span>
        <span class="s2">)</span>

        <span class="s1">end_stamps </span><span class="s2">= </span><span class="s1">labels</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">closed </span><span class="s2">== </span><span class="s5">&quot;left&quot;</span><span class="s2">:</span>
            <span class="s1">end_stamps </span><span class="s2">+= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span>

        <span class="s1">bins </span><span class="s2">= </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">searchsorted</span><span class="s2">(</span><span class="s1">end_stamps</span><span class="s2">, </span><span class="s1">side</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">closed</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">offset</span><span class="s2">:</span>
            <span class="s4"># GH 10530 &amp; 31809</span>
            <span class="s1">labels </span><span class="s2">+= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">offset</span>

        <span class="s0">return </span><span class="s1">binner</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">, </span><span class="s1">labels</span>

    <span class="s0">def </span><span class="s1">_get_time_period_bins</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">: </span><span class="s1">DatetimeIndex</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">, </span><span class="s1">DatetimeIndex</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s5">&quot;axis must be a DatetimeIndex, but got &quot;</span>
                <span class="s5">f&quot;an instance of </span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">}</span><span class="s5">&quot;</span>
            <span class="s2">)</span>

        <span class="s1">freq </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">) == </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">binner </span><span class="s2">= </span><span class="s1">labels </span><span class="s2">= </span><span class="s1">PeriodIndex</span><span class="s2">(</span>
                <span class="s1">data</span><span class="s2">=[], </span><span class="s1">freq</span><span class="s2">=</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">dtype</span>
            <span class="s2">)</span>
            <span class="s0">return </span><span class="s1">binner</span><span class="s2">, [], </span><span class="s1">labels</span>

        <span class="s1">labels </span><span class="s2">= </span><span class="s1">binner </span><span class="s2">= </span><span class="s1">period_range</span><span class="s2">(</span><span class="s1">start</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">end</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">], </span><span class="s1">freq</span><span class="s2">=</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>

        <span class="s1">end_stamps </span><span class="s2">= (</span><span class="s1">labels </span><span class="s2">+ </span><span class="s1">freq</span><span class="s2">).</span><span class="s1">asfreq</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">, </span><span class="s5">&quot;s&quot;</span><span class="s2">).</span><span class="s1">to_timestamp</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">tz</span><span class="s2">:</span>
            <span class="s1">end_stamps </span><span class="s2">= </span><span class="s1">end_stamps</span><span class="s2">.</span><span class="s1">tz_localize</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">tz</span><span class="s2">)</span>
        <span class="s1">bins </span><span class="s2">= </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">searchsorted</span><span class="s2">(</span><span class="s1">end_stamps</span><span class="s2">, </span><span class="s1">side</span><span class="s2">=</span><span class="s5">&quot;left&quot;</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">binner</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">, </span><span class="s1">labels</span>

    <span class="s0">def </span><span class="s1">_get_period_bins</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">: </span><span class="s1">PeriodIndex</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">, </span><span class="s1">PeriodIndex</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s5">&quot;axis must be a PeriodIndex, but got &quot;</span>
                <span class="s5">f&quot;an instance of </span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">}</span><span class="s5">&quot;</span>
            <span class="s2">)</span>

        <span class="s1">memb </span><span class="s2">= </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">asfreq</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">how</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">convention</span><span class="s2">)</span>

        <span class="s4"># NaT handling as in pandas._lib.lib.generate_bins_dt64()</span>
        <span class="s1">nat_count </span><span class="s2">= </span><span class="s6">0</span>
        <span class="s0">if </span><span class="s1">memb</span><span class="s2">.</span><span class="s1">hasnans</span><span class="s2">:</span>
            <span class="s4"># error: Incompatible types in assignment (expression has type</span>
            <span class="s4"># &quot;bool_&quot;, variable has type &quot;int&quot;)  [assignment]</span>
            <span class="s1">nat_count </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">memb</span><span class="s2">.</span><span class="s1">_isnan</span><span class="s2">)  </span><span class="s4"># type: ignore[assignment]</span>
            <span class="s1">memb </span><span class="s2">= </span><span class="s1">memb</span><span class="s2">[~</span><span class="s1">memb</span><span class="s2">.</span><span class="s1">_isnan</span><span class="s2">]</span>

        <span class="s0">if not </span><span class="s1">len</span><span class="s2">(</span><span class="s1">memb</span><span class="s2">):</span>
            <span class="s4"># index contains no valid (non-NaT) values</span>
            <span class="s1">bins </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">)</span>
            <span class="s1">binner </span><span class="s2">= </span><span class="s1">labels </span><span class="s2">= </span><span class="s1">PeriodIndex</span><span class="s2">(</span><span class="s1">data</span><span class="s2">=[], </span><span class="s1">freq</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">) &gt; </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s4"># index is all NaT</span>
                <span class="s1">binner</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">, </span><span class="s1">labels </span><span class="s2">= </span><span class="s1">_insert_nat_bin</span><span class="s2">(</span><span class="s1">binner</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">, </span><span class="s1">labels</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">))</span>
            <span class="s0">return </span><span class="s1">binner</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">, </span><span class="s1">labels</span>

        <span class="s1">freq_mult </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">.</span><span class="s1">n</span>

        <span class="s1">start </span><span class="s2">= </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">min</span><span class="s2">().</span><span class="s1">asfreq</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">how</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">convention</span><span class="s2">)</span>
        <span class="s1">end </span><span class="s2">= </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">max</span><span class="s2">().</span><span class="s1">asfreq</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">how</span><span class="s2">=</span><span class="s5">&quot;end&quot;</span><span class="s2">)</span>
        <span class="s1">bin_shift </span><span class="s2">= </span><span class="s6">0</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">Tick</span><span class="s2">):</span>
            <span class="s4"># GH 23882 &amp; 31809: get adjusted bin edge labels with 'origin'</span>
            <span class="s4"># and 'origin' support. This call only makes sense if the freq is a</span>
            <span class="s4"># Tick since offset and origin are only used in those cases.</span>
            <span class="s4"># Not doing this check could create an extra empty bin.</span>
            <span class="s1">p_start</span><span class="s2">, </span><span class="s1">end </span><span class="s2">= </span><span class="s1">_get_period_range_edges</span><span class="s2">(</span>
                <span class="s1">start</span><span class="s2">,</span>
                <span class="s1">end</span><span class="s2">,</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">,</span>
                <span class="s1">closed</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">closed</span><span class="s2">,</span>
                <span class="s1">origin</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">origin</span><span class="s2">,</span>
                <span class="s1">offset</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offset</span><span class="s2">,</span>
            <span class="s2">)</span>

            <span class="s4"># Get offset for bin edge (not label edge) adjustment</span>
            <span class="s1">start_offset </span><span class="s2">= </span><span class="s1">Period</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">) - </span><span class="s1">Period</span><span class="s2">(</span><span class="s1">p_start</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">)</span>
            <span class="s4"># error: Item &quot;Period&quot; of &quot;Union[Period, Any]&quot; has no attribute &quot;n&quot;</span>
            <span class="s1">bin_shift </span><span class="s2">= </span><span class="s1">start_offset</span><span class="s2">.</span><span class="s1">n </span><span class="s2">% </span><span class="s1">freq_mult  </span><span class="s4"># type: ignore[union-attr]</span>
            <span class="s1">start </span><span class="s2">= </span><span class="s1">p_start</span>

        <span class="s1">labels </span><span class="s2">= </span><span class="s1">binner </span><span class="s2">= </span><span class="s1">period_range</span><span class="s2">(</span>
            <span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">=</span><span class="s1">end</span><span class="s2">, </span><span class="s1">freq</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">name</span>
        <span class="s2">)</span>

        <span class="s1">i8 </span><span class="s2">= </span><span class="s1">memb</span><span class="s2">.</span><span class="s1">asi8</span>

        <span class="s4"># when upsampling to subperiods, we need to generate enough bins</span>
        <span class="s1">expected_bins_count </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">binner</span><span class="s2">) * </span><span class="s1">freq_mult</span>
        <span class="s1">i8_extend </span><span class="s2">= </span><span class="s1">expected_bins_count </span><span class="s2">- (</span><span class="s1">i8</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] - </span><span class="s1">i8</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>
        <span class="s1">rng </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">i8</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">i8</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] + </span><span class="s1">i8_extend</span><span class="s2">, </span><span class="s1">freq_mult</span><span class="s2">)</span>
        <span class="s1">rng </span><span class="s2">+= </span><span class="s1">freq_mult</span>
        <span class="s4"># adjust bin edge indexes to account for base</span>
        <span class="s1">rng </span><span class="s2">-= </span><span class="s1">bin_shift</span>

        <span class="s4"># Wrap in PeriodArray for PeriodArray.searchsorted</span>
        <span class="s1">prng </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">memb</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">)(</span><span class="s1">rng</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">memb</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">bins </span><span class="s2">= </span><span class="s1">memb</span><span class="s2">.</span><span class="s1">searchsorted</span><span class="s2">(</span><span class="s1">prng</span><span class="s2">, </span><span class="s1">side</span><span class="s2">=</span><span class="s5">&quot;left&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">nat_count </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">binner</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">, </span><span class="s1">labels </span><span class="s2">= </span><span class="s1">_insert_nat_bin</span><span class="s2">(</span><span class="s1">binner</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">, </span><span class="s1">labels</span><span class="s2">, </span><span class="s1">nat_count</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">binner</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">, </span><span class="s1">labels</span>

    <span class="s0">def </span><span class="s1">_set_grouper</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">: </span><span class="s1">NDFrameT</span><span class="s2">, </span><span class="s1">sort</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">, *, </span><span class="s1">gpr_index</span><span class="s2">: </span><span class="s1">Index </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">NDFrameT</span><span class="s2">, </span><span class="s1">Index</span><span class="s2">, </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">] | </span><span class="s0">None</span><span class="s2">]:</span>
        <span class="s1">obj</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">indexer </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">_set_grouper</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">sort</span><span class="s2">, </span><span class="s1">gpr_index</span><span class="s2">=</span><span class="s1">gpr_index</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ArrowDtype</span><span class="s2">) </span><span class="s0">and </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">in </span><span class="s5">&quot;Mm&quot;</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_arrow_dtype </span><span class="s2">= </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">dtype</span>
            <span class="s1">ax </span><span class="s2">= </span><span class="s1">Index</span><span class="s2">(</span>
                <span class="s1">cast</span><span class="s2">(</span><span class="s1">ArrowExtensionArray</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">array</span><span class="s2">).</span><span class="s1">_maybe_convert_datelike_array</span><span class="s2">()</span>
            <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">indexer</span>


<span class="s0">def </span><span class="s1">_take_new_index</span><span class="s2">(</span>
    <span class="s1">obj</span><span class="s2">: </span><span class="s1">NDFrameT</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">], </span><span class="s1">new_index</span><span class="s2">: </span><span class="s1">Index</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">= </span><span class="s6">0</span>
<span class="s2">) </span><span class="s1">-&gt; NDFrameT</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">ABCSeries</span><span class="s2">):</span>
        <span class="s1">new_values </span><span class="s2">= </span><span class="s1">algos</span><span class="s2">.</span><span class="s1">take_nd</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_values</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">)</span>
        <span class="s4"># error: Incompatible return value type (got &quot;Series&quot;, expected &quot;NDFrameT&quot;)</span>
        <span class="s0">return </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor</span><span class="s2">(  </span><span class="s4"># type: ignore[return-value]</span>
            <span class="s1">new_values</span><span class="s2">, </span><span class="s1">index</span><span class="s2">=</span><span class="s1">new_index</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">name</span>
        <span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">ABCDataFrame</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s5">&quot;axis 1 is not supported&quot;</span><span class="s2">)</span>
        <span class="s1">new_mgr </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_mgr</span><span class="s2">.</span><span class="s1">reindex_indexer</span><span class="s2">(</span><span class="s1">new_axis</span><span class="s2">=</span><span class="s1">new_index</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">=</span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s6">1</span><span class="s2">)</span>
        <span class="s4"># error: Incompatible return value type (got &quot;DataFrame&quot;, expected &quot;NDFrameT&quot;)</span>
        <span class="s0">return </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">_constructor_from_mgr</span><span class="s2">(</span><span class="s1">new_mgr</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">=</span><span class="s1">new_mgr</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">)  </span><span class="s4"># type: ignore[return-value]</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;'obj' should be either a Series or a DataFrame&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_get_timestamp_range_edges</span><span class="s2">(</span>
    <span class="s1">first</span><span class="s2">: </span><span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">last</span><span class="s2">: </span><span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">freq</span><span class="s2">: </span><span class="s1">BaseOffset</span><span class="s2">,</span>
    <span class="s1">unit</span><span class="s2">: </span><span class="s1">str</span><span class="s2">,</span>
    <span class="s1">closed</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;right&quot;</span><span class="s2">, </span><span class="s5">&quot;left&quot;</span><span class="s2">] = </span><span class="s5">&quot;left&quot;</span><span class="s2">,</span>
    <span class="s1">origin</span><span class="s2">: </span><span class="s1">TimeGrouperOrigin </span><span class="s2">= </span><span class="s5">&quot;start_day&quot;</span><span class="s2">,</span>
    <span class="s1">offset</span><span class="s2">: </span><span class="s1">Timedelta </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">Timestamp</span><span class="s2">, </span><span class="s1">Timestamp</span><span class="s2">]:</span>
    <span class="s3">&quot;&quot;&quot; 
    Adjust the `first` Timestamp to the preceding Timestamp that resides on 
    the provided offset. Adjust the `last` Timestamp to the following 
    Timestamp that resides on the provided offset. Input Timestamps that 
    already reside on the offset will be adjusted depending on the type of 
    offset and the `closed` parameter. 
 
    Parameters 
    ---------- 
    first : pd.Timestamp 
        The beginning Timestamp of the range to be adjusted. 
    last : pd.Timestamp 
        The ending Timestamp of the range to be adjusted. 
    freq : pd.DateOffset 
        The dateoffset to which the Timestamps will be adjusted. 
    closed : {'right', 'left'}, default &quot;left&quot; 
        Which side of bin interval is closed. 
    origin : {'epoch', 'start', 'start_day'} or Timestamp, default 'start_day' 
        The timestamp on which to adjust the grouping. The timezone of origin must 
        match the timezone of the index. 
        If a timestamp is not used, these values are also supported: 
 
        - 'epoch': `origin` is 1970-01-01 
        - 'start': `origin` is the first value of the timeseries 
        - 'start_day': `origin` is the first day at midnight of the timeseries 
    offset : pd.Timedelta, default is None 
        An offset timedelta added to the origin. 
 
    Returns 
    ------- 
    A tuple of length 2, containing the adjusted pd.Timestamp objects. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">Tick</span><span class="s2">):</span>
        <span class="s1">index_tz </span><span class="s2">= </span><span class="s1">first</span><span class="s2">.</span><span class="s1">tz</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">Timestamp</span><span class="s2">) </span><span class="s0">and </span><span class="s2">(</span><span class="s1">origin</span><span class="s2">.</span><span class="s1">tz </span><span class="s0">is None</span><span class="s2">) != (</span><span class="s1">index_tz </span><span class="s0">is None</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s5">&quot;The origin must have the same timezone as the index.&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">origin </span><span class="s2">== </span><span class="s5">&quot;epoch&quot;</span><span class="s2">:</span>
            <span class="s4"># set the epoch based on the timezone to have similar bins results when</span>
            <span class="s4"># resampling on the same kind of indexes on different timezones</span>
            <span class="s1">origin </span><span class="s2">= </span><span class="s1">Timestamp</span><span class="s2">(</span><span class="s5">&quot;1970-01-01&quot;</span><span class="s2">, </span><span class="s1">tz</span><span class="s2">=</span><span class="s1">index_tz</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">Day</span><span class="s2">):</span>
            <span class="s4"># _adjust_dates_anchored assumes 'D' means 24h, but first/last</span>
            <span class="s4"># might contain a DST transition (23h, 24h, or 25h).</span>
            <span class="s4"># So &quot;pretend&quot; the dates are naive when adjusting the endpoints</span>
            <span class="s1">first </span><span class="s2">= </span><span class="s1">first</span><span class="s2">.</span><span class="s1">tz_localize</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
            <span class="s1">last </span><span class="s2">= </span><span class="s1">last</span><span class="s2">.</span><span class="s1">tz_localize</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">Timestamp</span><span class="s2">):</span>
                <span class="s1">origin </span><span class="s2">= </span><span class="s1">origin</span><span class="s2">.</span><span class="s1">tz_localize</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>

        <span class="s1">first</span><span class="s2">, </span><span class="s1">last </span><span class="s2">= </span><span class="s1">_adjust_dates_anchored</span><span class="s2">(</span>
            <span class="s1">first</span><span class="s2">, </span><span class="s1">last</span><span class="s2">, </span><span class="s1">freq</span><span class="s2">, </span><span class="s1">closed</span><span class="s2">=</span><span class="s1">closed</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">=</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">=</span><span class="s1">offset</span><span class="s2">, </span><span class="s1">unit</span><span class="s2">=</span><span class="s1">unit</span>
        <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">Day</span><span class="s2">):</span>
            <span class="s1">first </span><span class="s2">= </span><span class="s1">first</span><span class="s2">.</span><span class="s1">tz_localize</span><span class="s2">(</span><span class="s1">index_tz</span><span class="s2">)</span>
            <span class="s1">last </span><span class="s2">= </span><span class="s1">last</span><span class="s2">.</span><span class="s1">tz_localize</span><span class="s2">(</span><span class="s1">index_tz</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">first </span><span class="s2">= </span><span class="s1">first</span><span class="s2">.</span><span class="s1">normalize</span><span class="s2">()</span>
        <span class="s1">last </span><span class="s2">= </span><span class="s1">last</span><span class="s2">.</span><span class="s1">normalize</span><span class="s2">()</span>

        <span class="s0">if </span><span class="s1">closed </span><span class="s2">== </span><span class="s5">&quot;left&quot;</span><span class="s2">:</span>
            <span class="s1">first </span><span class="s2">= </span><span class="s1">Timestamp</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">.</span><span class="s1">rollback</span><span class="s2">(</span><span class="s1">first</span><span class="s2">))</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">first </span><span class="s2">= </span><span class="s1">Timestamp</span><span class="s2">(</span><span class="s1">first </span><span class="s2">- </span><span class="s1">freq</span><span class="s2">)</span>

        <span class="s1">last </span><span class="s2">= </span><span class="s1">Timestamp</span><span class="s2">(</span><span class="s1">last </span><span class="s2">+ </span><span class="s1">freq</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">first</span><span class="s2">, </span><span class="s1">last</span>


<span class="s0">def </span><span class="s1">_get_period_range_edges</span><span class="s2">(</span>
    <span class="s1">first</span><span class="s2">: </span><span class="s1">Period</span><span class="s2">,</span>
    <span class="s1">last</span><span class="s2">: </span><span class="s1">Period</span><span class="s2">,</span>
    <span class="s1">freq</span><span class="s2">: </span><span class="s1">BaseOffset</span><span class="s2">,</span>
    <span class="s1">closed</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;right&quot;</span><span class="s2">, </span><span class="s5">&quot;left&quot;</span><span class="s2">] = </span><span class="s5">&quot;left&quot;</span><span class="s2">,</span>
    <span class="s1">origin</span><span class="s2">: </span><span class="s1">TimeGrouperOrigin </span><span class="s2">= </span><span class="s5">&quot;start_day&quot;</span><span class="s2">,</span>
    <span class="s1">offset</span><span class="s2">: </span><span class="s1">Timedelta </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">Period</span><span class="s2">, </span><span class="s1">Period</span><span class="s2">]:</span>
    <span class="s3">&quot;&quot;&quot; 
    Adjust the provided `first` and `last` Periods to the respective Period of 
    the given offset that encompasses them. 
 
    Parameters 
    ---------- 
    first : pd.Period 
        The beginning Period of the range to be adjusted. 
    last : pd.Period 
        The ending Period of the range to be adjusted. 
    freq : pd.DateOffset 
        The freq to which the Periods will be adjusted. 
    closed : {'right', 'left'}, default &quot;left&quot; 
        Which side of bin interval is closed. 
    origin : {'epoch', 'start', 'start_day'}, Timestamp, default 'start_day' 
        The timestamp on which to adjust the grouping. The timezone of origin must 
        match the timezone of the index. 
 
        If a timestamp is not used, these values are also supported: 
 
        - 'epoch': `origin` is 1970-01-01 
        - 'start': `origin` is the first value of the timeseries 
        - 'start_day': `origin` is the first day at midnight of the timeseries 
    offset : pd.Timedelta, default is None 
        An offset timedelta added to the origin. 
 
    Returns 
    ------- 
    A tuple of length 2, containing the adjusted pd.Period objects. 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">all</span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">Period</span><span class="s2">) </span><span class="s0">for </span><span class="s1">obj </span><span class="s0">in </span><span class="s2">[</span><span class="s1">first</span><span class="s2">, </span><span class="s1">last</span><span class="s2">]):</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;'first' and 'last' must be instances of type Period&quot;</span><span class="s2">)</span>

    <span class="s4"># GH 23882</span>
    <span class="s1">first_ts </span><span class="s2">= </span><span class="s1">first</span><span class="s2">.</span><span class="s1">to_timestamp</span><span class="s2">()</span>
    <span class="s1">last_ts </span><span class="s2">= </span><span class="s1">last</span><span class="s2">.</span><span class="s1">to_timestamp</span><span class="s2">()</span>
    <span class="s1">adjust_first </span><span class="s2">= </span><span class="s0">not </span><span class="s1">freq</span><span class="s2">.</span><span class="s1">is_on_offset</span><span class="s2">(</span><span class="s1">first_ts</span><span class="s2">)</span>
    <span class="s1">adjust_last </span><span class="s2">= </span><span class="s1">freq</span><span class="s2">.</span><span class="s1">is_on_offset</span><span class="s2">(</span><span class="s1">last_ts</span><span class="s2">)</span>

    <span class="s1">first_ts</span><span class="s2">, </span><span class="s1">last_ts </span><span class="s2">= </span><span class="s1">_get_timestamp_range_edges</span><span class="s2">(</span>
        <span class="s1">first_ts</span><span class="s2">, </span><span class="s1">last_ts</span><span class="s2">, </span><span class="s1">freq</span><span class="s2">, </span><span class="s1">unit</span><span class="s2">=</span><span class="s5">&quot;ns&quot;</span><span class="s2">, </span><span class="s1">closed</span><span class="s2">=</span><span class="s1">closed</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">=</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">=</span><span class="s1">offset</span>
    <span class="s2">)</span>

    <span class="s1">first </span><span class="s2">= (</span><span class="s1">first_ts </span><span class="s2">+ </span><span class="s1">int</span><span class="s2">(</span><span class="s1">adjust_first</span><span class="s2">) * </span><span class="s1">freq</span><span class="s2">).</span><span class="s1">to_period</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">)</span>
    <span class="s1">last </span><span class="s2">= (</span><span class="s1">last_ts </span><span class="s2">- </span><span class="s1">int</span><span class="s2">(</span><span class="s1">adjust_last</span><span class="s2">) * </span><span class="s1">freq</span><span class="s2">).</span><span class="s1">to_period</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">first</span><span class="s2">, </span><span class="s1">last</span>


<span class="s0">def </span><span class="s1">_insert_nat_bin</span><span class="s2">(</span>
    <span class="s1">binner</span><span class="s2">: </span><span class="s1">PeriodIndex</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">labels</span><span class="s2">: </span><span class="s1">PeriodIndex</span><span class="s2">, </span><span class="s1">nat_count</span><span class="s2">: </span><span class="s1">int</span>
<span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">PeriodIndex</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">PeriodIndex</span><span class="s2">]:</span>
    <span class="s4"># NaT handling as in pandas._lib.lib.generate_bins_dt64()</span>
    <span class="s4"># shift bins by the number of NaT</span>
    <span class="s0">assert </span><span class="s1">nat_count </span><span class="s2">&gt; </span><span class="s6">0</span>
    <span class="s1">bins </span><span class="s2">+= </span><span class="s1">nat_count</span>
    <span class="s1">bins </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s1">bins</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s1">nat_count</span><span class="s2">)</span>

    <span class="s4"># Incompatible types in assignment (expression has type &quot;Index&quot;, variable</span>
    <span class="s4"># has type &quot;PeriodIndex&quot;)</span>
    <span class="s1">binner </span><span class="s2">= </span><span class="s1">binner</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">)  </span><span class="s4"># type: ignore[assignment]</span>
    <span class="s4"># Incompatible types in assignment (expression has type &quot;Index&quot;, variable</span>
    <span class="s4"># has type &quot;PeriodIndex&quot;)</span>
    <span class="s1">labels </span><span class="s2">= </span><span class="s1">labels</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">)  </span><span class="s4"># type: ignore[assignment]</span>
    <span class="s0">return </span><span class="s1">binner</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">, </span><span class="s1">labels</span>


<span class="s0">def </span><span class="s1">_adjust_dates_anchored</span><span class="s2">(</span>
    <span class="s1">first</span><span class="s2">: </span><span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">last</span><span class="s2">: </span><span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">freq</span><span class="s2">: </span><span class="s1">Tick</span><span class="s2">,</span>
    <span class="s1">closed</span><span class="s2">: </span><span class="s1">Literal</span><span class="s2">[</span><span class="s5">&quot;right&quot;</span><span class="s2">, </span><span class="s5">&quot;left&quot;</span><span class="s2">] = </span><span class="s5">&quot;right&quot;</span><span class="s2">,</span>
    <span class="s1">origin</span><span class="s2">: </span><span class="s1">TimeGrouperOrigin </span><span class="s2">= </span><span class="s5">&quot;start_day&quot;</span><span class="s2">,</span>
    <span class="s1">offset</span><span class="s2">: </span><span class="s1">Timedelta </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">unit</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s5">&quot;ns&quot;</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">Timestamp</span><span class="s2">, </span><span class="s1">Timestamp</span><span class="s2">]:</span>
    <span class="s4"># First and last offsets should be calculated from the start day to fix an</span>
    <span class="s4"># error cause by resampling across multiple days when a one day period is</span>
    <span class="s4"># not a multiple of the frequency. See GH 8683</span>
    <span class="s4"># To handle frequencies that are not multiple or divisible by a day we let</span>
    <span class="s4"># the possibility to define a fixed origin timestamp. See GH 31809</span>
    <span class="s1">first </span><span class="s2">= </span><span class="s1">first</span><span class="s2">.</span><span class="s1">as_unit</span><span class="s2">(</span><span class="s1">unit</span><span class="s2">)</span>
    <span class="s1">last </span><span class="s2">= </span><span class="s1">last</span><span class="s2">.</span><span class="s1">as_unit</span><span class="s2">(</span><span class="s1">unit</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">offset </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">offset </span><span class="s2">= </span><span class="s1">offset</span><span class="s2">.</span><span class="s1">as_unit</span><span class="s2">(</span><span class="s1">unit</span><span class="s2">)</span>

    <span class="s1">freq_value </span><span class="s2">= </span><span class="s1">Timedelta</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">).</span><span class="s1">as_unit</span><span class="s2">(</span><span class="s1">unit</span><span class="s2">).</span><span class="s1">_value</span>

    <span class="s1">origin_timestamp </span><span class="s2">= </span><span class="s6">0  </span><span class="s4"># origin == &quot;epoch&quot;</span>
    <span class="s0">if </span><span class="s1">origin </span><span class="s2">== </span><span class="s5">&quot;start_day&quot;</span><span class="s2">:</span>
        <span class="s1">origin_timestamp </span><span class="s2">= </span><span class="s1">first</span><span class="s2">.</span><span class="s1">normalize</span><span class="s2">().</span><span class="s1">_value</span>
    <span class="s0">elif </span><span class="s1">origin </span><span class="s2">== </span><span class="s5">&quot;start&quot;</span><span class="s2">:</span>
        <span class="s1">origin_timestamp </span><span class="s2">= </span><span class="s1">first</span><span class="s2">.</span><span class="s1">_value</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">origin</span><span class="s2">, </span><span class="s1">Timestamp</span><span class="s2">):</span>
        <span class="s1">origin_timestamp </span><span class="s2">= </span><span class="s1">origin</span><span class="s2">.</span><span class="s1">as_unit</span><span class="s2">(</span><span class="s1">unit</span><span class="s2">).</span><span class="s1">_value</span>
    <span class="s0">elif </span><span class="s1">origin </span><span class="s0">in </span><span class="s2">[</span><span class="s5">&quot;end&quot;</span><span class="s2">, </span><span class="s5">&quot;end_day&quot;</span><span class="s2">]:</span>
        <span class="s1">origin_last </span><span class="s2">= </span><span class="s1">last </span><span class="s0">if </span><span class="s1">origin </span><span class="s2">== </span><span class="s5">&quot;end&quot; </span><span class="s0">else </span><span class="s1">last</span><span class="s2">.</span><span class="s1">ceil</span><span class="s2">(</span><span class="s5">&quot;D&quot;</span><span class="s2">)</span>
        <span class="s1">sub_freq_times </span><span class="s2">= (</span><span class="s1">origin_last</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">- </span><span class="s1">first</span><span class="s2">.</span><span class="s1">_value</span><span class="s2">) // </span><span class="s1">freq_value</span>
        <span class="s0">if </span><span class="s1">closed </span><span class="s2">== </span><span class="s5">&quot;left&quot;</span><span class="s2">:</span>
            <span class="s1">sub_freq_times </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s1">first </span><span class="s2">= </span><span class="s1">origin_last </span><span class="s2">- </span><span class="s1">sub_freq_times </span><span class="s2">* </span><span class="s1">freq</span>
        <span class="s1">origin_timestamp </span><span class="s2">= </span><span class="s1">first</span><span class="s2">.</span><span class="s1">_value</span>
    <span class="s1">origin_timestamp </span><span class="s2">+= </span><span class="s1">offset</span><span class="s2">.</span><span class="s1">_value </span><span class="s0">if </span><span class="s1">offset </span><span class="s0">else </span><span class="s6">0</span>

    <span class="s4"># GH 10117 &amp; GH 19375. If first and last contain timezone information,</span>
    <span class="s4"># Perform the calculation in UTC in order to avoid localizing on an</span>
    <span class="s4"># Ambiguous or Nonexistent time.</span>
    <span class="s1">first_tzinfo </span><span class="s2">= </span><span class="s1">first</span><span class="s2">.</span><span class="s1">tzinfo</span>
    <span class="s1">last_tzinfo </span><span class="s2">= </span><span class="s1">last</span><span class="s2">.</span><span class="s1">tzinfo</span>
    <span class="s0">if </span><span class="s1">first_tzinfo </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">first </span><span class="s2">= </span><span class="s1">first</span><span class="s2">.</span><span class="s1">tz_convert</span><span class="s2">(</span><span class="s5">&quot;UTC&quot;</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">last_tzinfo </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">last </span><span class="s2">= </span><span class="s1">last</span><span class="s2">.</span><span class="s1">tz_convert</span><span class="s2">(</span><span class="s5">&quot;UTC&quot;</span><span class="s2">)</span>

    <span class="s1">foffset </span><span class="s2">= (</span><span class="s1">first</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">- </span><span class="s1">origin_timestamp</span><span class="s2">) % </span><span class="s1">freq_value</span>
    <span class="s1">loffset </span><span class="s2">= (</span><span class="s1">last</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">- </span><span class="s1">origin_timestamp</span><span class="s2">) % </span><span class="s1">freq_value</span>

    <span class="s0">if </span><span class="s1">closed </span><span class="s2">== </span><span class="s5">&quot;right&quot;</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">foffset </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s4"># roll back</span>
            <span class="s1">fresult_int </span><span class="s2">= </span><span class="s1">first</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">- </span><span class="s1">foffset</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">fresult_int </span><span class="s2">= </span><span class="s1">first</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">- </span><span class="s1">freq_value</span>

        <span class="s0">if </span><span class="s1">loffset </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s4"># roll forward</span>
            <span class="s1">lresult_int </span><span class="s2">= </span><span class="s1">last</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">+ (</span><span class="s1">freq_value </span><span class="s2">- </span><span class="s1">loffset</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># already the end of the road</span>
            <span class="s1">lresult_int </span><span class="s2">= </span><span class="s1">last</span><span class="s2">.</span><span class="s1">_value</span>
    <span class="s0">else</span><span class="s2">:  </span><span class="s4"># closed == 'left'</span>
        <span class="s0">if </span><span class="s1">foffset </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">fresult_int </span><span class="s2">= </span><span class="s1">first</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">- </span><span class="s1">foffset</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># start of the road</span>
            <span class="s1">fresult_int </span><span class="s2">= </span><span class="s1">first</span><span class="s2">.</span><span class="s1">_value</span>

        <span class="s0">if </span><span class="s1">loffset </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s4"># roll forward</span>
            <span class="s1">lresult_int </span><span class="s2">= </span><span class="s1">last</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">+ (</span><span class="s1">freq_value </span><span class="s2">- </span><span class="s1">loffset</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">lresult_int </span><span class="s2">= </span><span class="s1">last</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">+ </span><span class="s1">freq_value</span>
    <span class="s1">fresult </span><span class="s2">= </span><span class="s1">Timestamp</span><span class="s2">(</span><span class="s1">fresult_int</span><span class="s2">, </span><span class="s1">unit</span><span class="s2">=</span><span class="s1">unit</span><span class="s2">)</span>
    <span class="s1">lresult </span><span class="s2">= </span><span class="s1">Timestamp</span><span class="s2">(</span><span class="s1">lresult_int</span><span class="s2">, </span><span class="s1">unit</span><span class="s2">=</span><span class="s1">unit</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">first_tzinfo </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">fresult </span><span class="s2">= </span><span class="s1">fresult</span><span class="s2">.</span><span class="s1">tz_localize</span><span class="s2">(</span><span class="s5">&quot;UTC&quot;</span><span class="s2">).</span><span class="s1">tz_convert</span><span class="s2">(</span><span class="s1">first_tzinfo</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">last_tzinfo </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">lresult </span><span class="s2">= </span><span class="s1">lresult</span><span class="s2">.</span><span class="s1">tz_localize</span><span class="s2">(</span><span class="s5">&quot;UTC&quot;</span><span class="s2">).</span><span class="s1">tz_convert</span><span class="s2">(</span><span class="s1">last_tzinfo</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">fresult</span><span class="s2">, </span><span class="s1">lresult</span>


<span class="s0">def </span><span class="s1">asfreq</span><span class="s2">(</span>
    <span class="s1">obj</span><span class="s2">: </span><span class="s1">NDFrameT</span><span class="s2">,</span>
    <span class="s1">freq</span><span class="s2">,</span>
    <span class="s1">method</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">how</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">normalize</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">fill_value</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; NDFrameT</span><span class="s2">:</span>
    <span class="s3">&quot;&quot;&quot; 
    Utility frequency conversion method for Series/DataFrame. 
 
    See :meth:`pandas.NDFrame.asfreq` for full documentation. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">PeriodIndex</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">method </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s5">&quot;'method' argument is not supported&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">how </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">how </span><span class="s2">= </span><span class="s5">&quot;E&quot;</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">BaseOffset</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">, </span><span class="s5">&quot;_period_dtype_code&quot;</span><span class="s2">):</span>
                <span class="s1">freq </span><span class="s2">= </span><span class="s1">freq_to_period_freqstr</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">.</span><span class="s1">n</span><span class="s2">, </span><span class="s1">freq</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s5">f&quot;Invalid offset: '</span><span class="s0">{</span><span class="s1">freq</span><span class="s2">.</span><span class="s1">base</span><span class="s0">}</span><span class="s5">' for converting time series &quot;</span>
                    <span class="s5">f&quot;with PeriodIndex.&quot;</span>
                <span class="s2">)</span>

        <span class="s1">new_obj </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s1">new_obj</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">asfreq</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">how</span><span class="s2">=</span><span class="s1">how</span><span class="s2">)</span>

    <span class="s0">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">) == </span><span class="s6">0</span><span class="s2">:</span>
        <span class="s1">new_obj </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

        <span class="s1">new_obj</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">_asfreq_compat</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">freq</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">unit </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">DatetimeIndex</span><span class="s2">):</span>
            <span class="s4"># TODO: should we disallow non-DatetimeIndex?</span>
            <span class="s1">unit </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">unit</span>
        <span class="s1">dti </span><span class="s2">= </span><span class="s1">date_range</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(), </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(), </span><span class="s1">freq</span><span class="s2">=</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">unit</span><span class="s2">=</span><span class="s1">unit</span><span class="s2">)</span>
        <span class="s1">dti</span><span class="s2">.</span><span class="s1">name </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">name</span>
        <span class="s1">new_obj </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">reindex</span><span class="s2">(</span><span class="s1">dti</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s1">method</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s1">fill_value</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">normalize</span><span class="s2">:</span>
            <span class="s1">new_obj</span><span class="s2">.</span><span class="s1">index </span><span class="s2">= </span><span class="s1">new_obj</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">normalize</span><span class="s2">()</span>

    <span class="s0">return </span><span class="s1">new_obj</span>


<span class="s0">def </span><span class="s1">_asfreq_compat</span><span class="s2">(</span><span class="s1">index</span><span class="s2">: </span><span class="s1">DatetimeIndex </span><span class="s2">| </span><span class="s1">PeriodIndex </span><span class="s2">| </span><span class="s1">TimedeltaIndex</span><span class="s2">, </span><span class="s1">freq</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Helper to mimic asfreq on (empty) DatetimeIndex and TimedeltaIndex. 
 
    Parameters 
    ---------- 
    index : PeriodIndex, DatetimeIndex, or TimedeltaIndex 
    freq : DateOffset 
 
    Returns 
    ------- 
    same type as index 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">index</span><span class="s2">) != </span><span class="s6">0</span><span class="s2">:</span>
        <span class="s4"># This should never be reached, always checked by the caller</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s5">&quot;Can only set arbitrary freq for empty DatetimeIndex or TimedeltaIndex&quot;</span>
        <span class="s2">)</span>
    <span class="s1">new_index</span><span class="s2">: </span><span class="s1">Index</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">index</span><span class="s2">, </span><span class="s1">PeriodIndex</span><span class="s2">):</span>
        <span class="s1">new_index </span><span class="s2">= </span><span class="s1">index</span><span class="s2">.</span><span class="s1">asfreq</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">=</span><span class="s1">freq</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">index</span><span class="s2">, </span><span class="s1">DatetimeIndex</span><span class="s2">):</span>
        <span class="s1">new_index </span><span class="s2">= </span><span class="s1">DatetimeIndex</span><span class="s2">([], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">index</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">freq</span><span class="s2">=</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">index</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">index</span><span class="s2">, </span><span class="s1">TimedeltaIndex</span><span class="s2">):</span>
        <span class="s1">new_index </span><span class="s2">= </span><span class="s1">TimedeltaIndex</span><span class="s2">([], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">index</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">freq</span><span class="s2">=</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">index</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:  </span><span class="s4"># pragma: no cover</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">index</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s1">new_index</span>


<span class="s0">def </span><span class="s1">maybe_warn_args_and_kwargs</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">kernel</span><span class="s2">: </span><span class="s1">str</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
    <span class="s3">&quot;&quot;&quot; 
    Warn for deprecation of args and kwargs in resample functions. 
 
    Parameters 
    ---------- 
    cls : type 
        Class to warn about. 
    kernel : str 
        Operation name. 
    args : tuple or None 
        args passed by user. Will be None if and only if kernel does not have args. 
    kwargs : dict or None 
        kwargs passed by user. Will be None if and only if kernel does not have kwargs. 
    &quot;&quot;&quot;</span>
    <span class="s1">warn_args </span><span class="s2">= </span><span class="s1">args </span><span class="s0">is not None and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) &gt; </span><span class="s6">0</span>
    <span class="s1">warn_kwargs </span><span class="s2">= </span><span class="s1">kwargs </span><span class="s0">is not None and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">kwargs</span><span class="s2">) &gt; </span><span class="s6">0</span>
    <span class="s0">if </span><span class="s1">warn_args </span><span class="s0">and </span><span class="s1">warn_kwargs</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s5">&quot;args and kwargs&quot;</span>
    <span class="s0">elif </span><span class="s1">warn_args</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s5">&quot;args&quot;</span>
    <span class="s0">elif </span><span class="s1">warn_kwargs</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s5">&quot;kwargs&quot;</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return</span>
    <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
        <span class="s5">f&quot;Passing additional </span><span class="s0">{</span><span class="s1">msg</span><span class="s0">} </span><span class="s5">to </span><span class="s0">{</span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">}</span><span class="s5">.</span><span class="s0">{</span><span class="s1">kernel</span><span class="s0">} </span><span class="s5">has &quot;</span>
        <span class="s5">&quot;no impact on the result and is deprecated. This will &quot;</span>
        <span class="s5">&quot;raise a TypeError in a future version of pandas.&quot;</span><span class="s2">,</span>
        <span class="s1">category</span><span class="s2">=</span><span class="s1">FutureWarning</span><span class="s2">,</span>
        <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">_apply</span><span class="s2">(</span>
    <span class="s1">grouped</span><span class="s2">: </span><span class="s1">GroupBy</span><span class="s2">, </span><span class="s1">how</span><span class="s2">: </span><span class="s1">Callable</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, </span><span class="s1">include_groups</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">, **</span><span class="s1">kwargs</span>
<span class="s2">) </span><span class="s1">-&gt; DataFrame</span><span class="s2">:</span>
    <span class="s4"># GH#7155 - rewrite warning to appear as if it came from `.resample`</span>
    <span class="s1">target_message </span><span class="s2">= </span><span class="s5">&quot;DataFrameGroupBy.apply operated on the grouping columns&quot;</span>
    <span class="s1">new_message </span><span class="s2">= </span><span class="s1">_apply_groupings_depr</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s5">&quot;DataFrameGroupBy&quot;</span><span class="s2">, </span><span class="s5">&quot;resample&quot;</span><span class="s2">)</span>
    <span class="s0">with </span><span class="s1">rewrite_warning</span><span class="s2">(</span>
        <span class="s1">target_message</span><span class="s2">=</span><span class="s1">target_message</span><span class="s2">,</span>
        <span class="s1">target_category</span><span class="s2">=</span><span class="s1">DeprecationWarning</span><span class="s2">,</span>
        <span class="s1">new_message</span><span class="s2">=</span><span class="s1">new_message</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">grouped</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s1">how</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, </span><span class="s1">include_groups</span><span class="s2">=</span><span class="s1">include_groups</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">result</span>
</pre>
</body>
</html>