<html>
<head>
<title>session.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
session.py</font>
</center></td></tr></table>
<pre><span class="s0"># orm/session.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">&quot;&quot;&quot;Provides the Session class and related utilities.&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">import </span><span class="s1">contextlib</span>
<span class="s3">from </span><span class="s1">enum </span><span class="s3">import </span><span class="s1">Enum</span>
<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">typing</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Dict</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Generic</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterator</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">NoReturn</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">overload</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Sequence</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Set</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Tuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Type</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TypeVar</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>
<span class="s3">import </span><span class="s1">weakref</span>

<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">attributes</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">bulk_persistence</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">context</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">descriptor_props</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">exc</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">identity</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">loading</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">query</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">state </span><span class="s3">as </span><span class="s1">statelib</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_O</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">insp_is_mapper</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">is_composite_class</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">is_orm_option</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">is_user_defined_option</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_class_to_mapper</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_none_set</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_state_mapper</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">instance_str</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">LoaderCallableStatus</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">object_mapper</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">object_state</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">PassiveFlag</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">state_str</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">context </span><span class="s3">import </span><span class="s1">FromStatement</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">context </span><span class="s3">import </span><span class="s1">ORMCompileState</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">identity </span><span class="s3">import </span><span class="s1">IdentityMap</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">query </span><span class="s3">import </span><span class="s1">Query</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">state </span><span class="s3">import </span><span class="s1">InstanceState</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">state_changes </span><span class="s3">import </span><span class="s1">_StateChange</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">state_changes </span><span class="s3">import </span><span class="s1">_StateChangeState</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">state_changes </span><span class="s3">import </span><span class="s1">_StateChangeStates</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">unitofwork </span><span class="s3">import </span><span class="s1">UOWTransaction</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">engine</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">exc </span><span class="s3">as </span><span class="s1">sa_exc</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">sql</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">Connection</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">Engine</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">util </span><span class="s3">import </span><span class="s1">TransactionalContext</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">event </span><span class="s3">import </span><span class="s1">dispatcher</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">event </span><span class="s3">import </span><span class="s1">EventTarget</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">inspection </span><span class="s3">import </span><span class="s1">inspect</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">inspection </span><span class="s3">import </span><span class="s1">Inspectable</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">coercions</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">dml</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">roles</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">Select</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">TableClause</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">visitors</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_NoArg</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">CompileState</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">Table</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">ForUpdateArg</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">LABEL_STYLE_TABLENAME_PLUS_COL</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util </span><span class="s3">import </span><span class="s1">IdentitySet</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Literal</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Protocol</span>

<span class="s3">if </span><span class="s1">typing</span><span class="s4">.</span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_EntityType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_IdentityKeyType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_InstanceDict</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">OrmExecuteOptionsParameter</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">ORMOption</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">UserDefinedOption</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">mapper </span><span class="s3">import </span><span class="s1">Mapper</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">path_registry </span><span class="s3">import </span><span class="s1">PathRegistry</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">query </span><span class="s3">import </span><span class="s1">RowReturningQuery</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">CursorResult</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">Result</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">Row</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">RowMapping</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">Transaction</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">TwoPhaseTransaction</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">_CoreAnyExecuteParams</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">_CoreSingleExecuteParams</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">_ExecuteOptions</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">CoreExecuteOptionsParameter</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">result </span><span class="s3">import </span><span class="s1">ScalarResult</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">event </span><span class="s3">import </span><span class="s1">_InstanceLevelDispatch</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_ColumnsClauseArgument</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_InfoType</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T0</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T1</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T2</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T3</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T4</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T5</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T6</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T7</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_TypedColumnClauseArgument </span><span class="s3">as </span><span class="s1">_TCCA</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">Executable</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">ExecutableOption</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">dml </span><span class="s3">import </span><span class="s1">UpdateBase</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">ClauseElement</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">roles </span><span class="s3">import </span><span class="s1">TypedColumnsClauseRole</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">ForUpdateParameter</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">TypedReturnsRows</span>

<span class="s1">_T </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_T&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s1">Any</span><span class="s4">)</span>

<span class="s1">__all__ </span><span class="s4">= [</span>
    <span class="s5">&quot;Session&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;SessionTransaction&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;sessionmaker&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;ORMExecuteState&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;close_all_sessions&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;make_transient&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;make_transient_to_detached&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;object_session&quot;</span><span class="s4">,</span>
<span class="s4">]</span>

<span class="s1">_sessions</span><span class="s4">: </span><span class="s1">weakref</span><span class="s4">.</span><span class="s1">WeakValueDictionary</span><span class="s4">[</span><span class="s1">int</span><span class="s4">, </span><span class="s1">Session</span><span class="s4">] = (</span>
    <span class="s1">weakref</span><span class="s4">.</span><span class="s1">WeakValueDictionary</span><span class="s4">()</span>
<span class="s4">)</span>
<span class="s5">&quot;&quot;&quot;Weak-referencing dictionary of :class:`.Session` objects. 
&quot;&quot;&quot;</span>

<span class="s1">statelib</span><span class="s4">.</span><span class="s1">_sessions </span><span class="s4">= </span><span class="s1">_sessions</span>

<span class="s1">_PKIdentityArgument </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, ...]]</span>

<span class="s1">_BindArguments </span><span class="s4">= </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]</span>

<span class="s1">_EntityBindKey </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">], </span><span class="s5">&quot;Mapper[_O]&quot;</span><span class="s4">]</span>
<span class="s1">_SessionBindKey </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s5">&quot;Mapper[Any]&quot;</span><span class="s4">, </span><span class="s5">&quot;TableClause&quot;</span><span class="s4">, </span><span class="s1">str</span><span class="s4">]</span>
<span class="s1">_SessionBind </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span><span class="s5">&quot;Engine&quot;</span><span class="s4">, </span><span class="s5">&quot;Connection&quot;</span><span class="s4">]</span>

<span class="s1">JoinTransactionMode </span><span class="s4">= </span><span class="s1">Literal</span><span class="s4">[</span>
    <span class="s5">&quot;conditional_savepoint&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;rollback_only&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;control_fully&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;create_savepoint&quot;</span><span class="s4">,</span>
<span class="s4">]</span>


<span class="s3">class </span><span class="s1">_ConnectionCallableProto</span><span class="s4">(</span><span class="s1">Protocol</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;a callable that returns a :class:`.Connection` given an instance. 
 
    This callable, when present on a :class:`.Session`, is called only from the 
    ORM's persistence mechanism (i.e. the unit of work flush process) to allow 
    for connection-per-instance schemes (i.e. horizontal sharding) to be used 
    as persistence time. 
 
    This callable is not present on a plain :class:`.Session`, however 
    is established when using the horizontal sharding extension. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">mapper</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Mapper</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">instance</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">object</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Connection</span><span class="s4">: ...</span>


<span class="s3">def </span><span class="s1">_state_session</span><span class="s4">(</span><span class="s1">state</span><span class="s4">: </span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">Session</span><span class="s4">]:</span>
    <span class="s2">&quot;&quot;&quot;Given an :class:`.InstanceState`, return the :class:`.Session` 
    associated, if any. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">state</span><span class="s4">.</span><span class="s1">session</span>


<span class="s3">class </span><span class="s1">_SessionClassMethods</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Class-level methods for :class:`.Session`, :class:`.sessionmaker`.&quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">deprecated</span><span class="s4">(</span>
        <span class="s5">&quot;1.3&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;The :meth:`.Session.close_all` method is deprecated and will be &quot;</span>
        <span class="s5">&quot;removed in a future release.  Please refer to &quot;</span>
        <span class="s5">&quot;:func:`.session.close_all_sessions`.&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">close_all</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Close *all* sessions in memory.&quot;&quot;&quot;</span>

        <span class="s1">close_all_sessions</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.orm.util&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">identity_key</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">class_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">ident</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, ...]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">instance</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">row</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Row</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">RowMapping</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">identity_token</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; _IdentityKeyType</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return an identity key. 
 
        This is an alias of :func:`.util.identity_key`. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">orm_util</span><span class="s4">.</span><span class="s1">identity_key</span><span class="s4">(</span>
            <span class="s1">class_</span><span class="s4">,</span>
            <span class="s1">ident</span><span class="s4">,</span>
            <span class="s1">instance</span><span class="s4">=</span><span class="s1">instance</span><span class="s4">,</span>
            <span class="s1">row</span><span class="s4">=</span><span class="s1">row</span><span class="s4">,</span>
            <span class="s1">identity_token</span><span class="s4">=</span><span class="s1">identity_token</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">object_session</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">object</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">Session</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the :class:`.Session` to which an object belongs. 
 
        This is an alias of :func:`.object_session`. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">object_session</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">SessionTransactionState</span><span class="s4">(</span><span class="s1">_StateChangeState</span><span class="s4">):</span>
    <span class="s1">ACTIVE </span><span class="s4">= </span><span class="s6">1</span>
    <span class="s1">PREPARED </span><span class="s4">= </span><span class="s6">2</span>
    <span class="s1">COMMITTED </span><span class="s4">= </span><span class="s6">3</span>
    <span class="s1">DEACTIVE </span><span class="s4">= </span><span class="s6">4</span>
    <span class="s1">CLOSED </span><span class="s4">= </span><span class="s6">5</span>
    <span class="s1">PROVISIONING_CONNECTION </span><span class="s4">= </span><span class="s6">6</span>


<span class="s0"># backwards compatibility</span>
<span class="s1">ACTIVE</span><span class="s4">, </span><span class="s1">PREPARED</span><span class="s4">, </span><span class="s1">COMMITTED</span><span class="s4">, </span><span class="s1">DEACTIVE</span><span class="s4">, </span><span class="s1">CLOSED</span><span class="s4">, </span><span class="s1">PROVISIONING_CONNECTION </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span>
    <span class="s1">SessionTransactionState</span>
<span class="s4">)</span>


<span class="s3">class </span><span class="s1">ORMExecuteState</span><span class="s4">(</span><span class="s1">util</span><span class="s4">.</span><span class="s1">MemoizedSlots</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represents a call to the :meth:`_orm.Session.execute` method, as passed 
    to the :meth:`.SessionEvents.do_orm_execute` event hook. 
 
    .. versionadded:: 1.4 
 
    .. seealso:: 
 
        :ref:`session_execute_events` - top level documentation on how 
        to use :meth:`_orm.SessionEvents.do_orm_execute` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s4">= (</span>
        <span class="s5">&quot;session&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;statement&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;parameters&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;execution_options&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;local_execution_options&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;bind_arguments&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;identity_token&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;_compile_state_cls&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;_starting_event_idx&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;_events_todo&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;_update_execution_options&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>

    <span class="s1">session</span><span class="s4">: </span><span class="s1">Session</span>
    <span class="s5">&quot;&quot;&quot;The :class:`_orm.Session` in use.&quot;&quot;&quot;</span>

    <span class="s1">statement</span><span class="s4">: </span><span class="s1">Executable</span>
    <span class="s5">&quot;&quot;&quot;The SQL statement being invoked. 
 
    For an ORM selection as would 
    be retrieved from :class:`_orm.Query`, this is an instance of 
    :class:`_sql.select` that was generated from the ORM query. 
    &quot;&quot;&quot;</span>

    <span class="s1">parameters</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;Dictionary of parameters that was passed to 
    :meth:`_orm.Session.execute`.&quot;&quot;&quot;</span>

    <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">_ExecuteOptions</span>
    <span class="s5">&quot;&quot;&quot;The complete dictionary of current execution options. 
 
    This is a merge of the statement level options with the 
    locally passed execution options. 
 
    .. seealso:: 
 
        :attr:`_orm.ORMExecuteState.local_execution_options` 
 
        :meth:`_sql.Executable.execution_options` 
 
        :ref:`orm_queryguide_execution_options` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">local_execution_options</span><span class="s4">: </span><span class="s1">_ExecuteOptions</span>
    <span class="s5">&quot;&quot;&quot;Dictionary view of the execution options passed to the 
    :meth:`.Session.execute` method. 
 
    This does not include options that may be associated with the statement 
    being invoked. 
 
    .. seealso:: 
 
        :attr:`_orm.ORMExecuteState.execution_options` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">_BindArguments</span>
    <span class="s5">&quot;&quot;&quot;The dictionary passed as the 
    :paramref:`_orm.Session.execute.bind_arguments` dictionary. 
 
    This dictionary may be used by extensions to :class:`_orm.Session` to pass 
    arguments that will assist in determining amongst a set of database 
    connections which one should be used to invoke this statement. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_compile_state_cls</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">ORMCompileState</span><span class="s4">]]</span>
    <span class="s1">_starting_event_idx</span><span class="s4">: </span><span class="s1">int</span>
    <span class="s1">_events_todo</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s1">_update_execution_options</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_ExecuteOptions</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">session</span><span class="s4">: </span><span class="s1">Session</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">Executable</span><span class="s4">,</span>
        <span class="s1">parameters</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s4">],</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">_ExecuteOptions</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">_BindArguments</span><span class="s4">,</span>
        <span class="s1">compile_state_cls</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">ORMCompileState</span><span class="s4">]],</span>
        <span class="s1">events_todo</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">_InstanceLevelDispatch</span><span class="s4">[</span><span class="s1">Session</span><span class="s4">]],</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Construct a new :class:`_orm.ORMExecuteState`. 
 
        this object is constructed internally. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">session </span><span class="s4">= </span><span class="s1">session</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">statement </span><span class="s4">= </span><span class="s1">statement</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">parameters </span><span class="s4">= </span><span class="s1">parameters</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">local_execution_options </span><span class="s4">= </span><span class="s1">execution_options</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">execution_options </span><span class="s4">= </span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_execution_options</span><span class="s4">.</span><span class="s1">union</span><span class="s4">(</span>
            <span class="s1">execution_options</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">bind_arguments </span><span class="s4">= </span><span class="s1">bind_arguments</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_state_cls </span><span class="s4">= </span><span class="s1">compile_state_cls</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_events_todo </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">events_todo</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_remaining_events</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">_InstanceLevelDispatch</span><span class="s4">[</span><span class="s1">Session</span><span class="s4">]]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_events_todo</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_starting_event_idx </span><span class="s4">+ </span><span class="s6">1 </span><span class="s4">:]</span>

    <span class="s3">def </span><span class="s1">invoke_statement</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Executable</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OrmExecuteOptionsParameter</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Result</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Execute the statement represented by this 
        :class:`.ORMExecuteState`, without re-invoking events that have 
        already proceeded. 
 
        This method essentially performs a re-entrant execution of the current 
        statement for which the :meth:`.SessionEvents.do_orm_execute` event is 
        being currently invoked.    The use case for this is for event handlers 
        that want to override how the ultimate 
        :class:`_engine.Result` object is returned, such as for schemes that 
        retrieve results from an offline cache or which concatenate results 
        from multiple executions. 
 
        When the :class:`_engine.Result` object is returned by the actual 
        handler function within :meth:`_orm.SessionEvents.do_orm_execute` and 
        is propagated to the calling 
        :meth:`_orm.Session.execute` method, the remainder of the 
        :meth:`_orm.Session.execute` method is preempted and the 
        :class:`_engine.Result` object is returned to the caller of 
        :meth:`_orm.Session.execute` immediately. 
 
        :param statement: optional statement to be invoked, in place of the 
         statement currently represented by :attr:`.ORMExecuteState.statement`. 
 
        :param params: optional dictionary of parameters or list of parameters 
         which will be merged into the existing 
         :attr:`.ORMExecuteState.parameters` of this :class:`.ORMExecuteState`. 
 
         .. versionchanged:: 2.0 a list of parameter dictionaries is accepted 
            for executemany executions. 
 
        :param execution_options: optional dictionary of execution options 
         will be merged into the existing 
         :attr:`.ORMExecuteState.execution_options` of this 
         :class:`.ORMExecuteState`. 
 
        :param bind_arguments: optional dictionary of bind_arguments 
         which will be merged amongst the current 
         :attr:`.ORMExecuteState.bind_arguments` 
         of this :class:`.ORMExecuteState`. 
 
        :return: a :class:`_engine.Result` object with ORM-level results. 
 
        .. seealso:: 
 
            :ref:`do_orm_execute_re_executing` - background and examples on the 
            appropriate usage of :meth:`_orm.ORMExecuteState.invoke_statement`. 
 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">statement </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">statement </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span>

        <span class="s1">_bind_arguments </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">bind_arguments</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">bind_arguments</span><span class="s4">:</span>
            <span class="s1">_bind_arguments</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">bind_arguments</span><span class="s4">)</span>
        <span class="s1">_bind_arguments</span><span class="s4">[</span><span class="s5">&quot;_sa_skip_events&quot;</span><span class="s4">] = </span><span class="s3">True</span>

        <span class="s1">_params</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">params</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">is_executemany</span><span class="s4">:</span>
                <span class="s1">_params </span><span class="s4">= []</span>
                <span class="s1">exec_many_parameters </span><span class="s4">= </span><span class="s1">cast</span><span class="s4">(</span>
                    <span class="s5">&quot;List[Dict[str, Any]]&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">parameters</span>
                <span class="s4">)</span>
                <span class="s3">for </span><span class="s1">_existing_params</span><span class="s4">, </span><span class="s1">_new_params </span><span class="s3">in </span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">zip_longest</span><span class="s4">(</span>
                    <span class="s1">exec_many_parameters</span><span class="s4">,</span>
                    <span class="s1">cast</span><span class="s4">(</span><span class="s5">&quot;List[Dict[str, Any]]&quot;</span><span class="s4">, </span><span class="s1">params</span><span class="s4">),</span>
                <span class="s4">):</span>
                    <span class="s3">if </span><span class="s1">_existing_params </span><span class="s3">is None or </span><span class="s1">_new_params </span><span class="s3">is None</span><span class="s4">:</span>
                        <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                            <span class="s5">f&quot;Can't apply executemany parameters to &quot;</span>
                            <span class="s5">f&quot;statement; number of parameter sets passed to &quot;</span>
                            <span class="s5">f&quot;Session.execute() (</span><span class="s3">{</span><span class="s1">len</span><span class="s4">(</span><span class="s1">exec_many_parameters</span><span class="s4">)</span><span class="s3">}</span><span class="s5">) &quot;</span>
                            <span class="s5">f&quot;does not match number of parameter sets given &quot;</span>
                            <span class="s5">f&quot;to ORMExecuteState.invoke_statement() &quot;</span>
                            <span class="s5">f&quot;(</span><span class="s3">{</span><span class="s1">len</span><span class="s4">(</span><span class="s1">params</span><span class="s4">)</span><span class="s3">}</span><span class="s5">)&quot;</span>
                        <span class="s4">)</span>
                    <span class="s1">_existing_params </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">_existing_params</span><span class="s4">)</span>
                    <span class="s1">_existing_params</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">_new_params</span><span class="s4">)</span>
                    <span class="s1">_params</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">_existing_params</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">_params </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">cast</span><span class="s4">(</span><span class="s5">&quot;Dict[str, Any]&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">parameters</span><span class="s4">))</span>
                <span class="s1">_params</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">cast</span><span class="s4">(</span><span class="s5">&quot;Dict[str, Any]&quot;</span><span class="s4">, </span><span class="s1">params</span><span class="s4">))</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">_params </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">parameters</span>

        <span class="s1">_execution_options </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">local_execution_options</span>
        <span class="s3">if </span><span class="s1">execution_options</span><span class="s4">:</span>
            <span class="s1">_execution_options </span><span class="s4">= </span><span class="s1">_execution_options</span><span class="s4">.</span><span class="s1">union</span><span class="s4">(</span><span class="s1">execution_options</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">_execute_internal</span><span class="s4">(</span>
            <span class="s1">statement</span><span class="s4">,</span>
            <span class="s1">_params</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">=</span><span class="s1">_execution_options</span><span class="s4">,</span>
            <span class="s1">bind_arguments</span><span class="s4">=</span><span class="s1">_bind_arguments</span><span class="s4">,</span>
            <span class="s1">_parent_execute_state</span><span class="s4">=</span><span class="s1">self</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">bind_mapper</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">Mapper</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;Return the :class:`_orm.Mapper` that is the primary &quot;bind&quot; mapper. 
 
        For an :class:`_orm.ORMExecuteState` object invoking an ORM 
        statement, that is, the :attr:`_orm.ORMExecuteState.is_orm_statement` 
        attribute is ``True``, this attribute will return the 
        :class:`_orm.Mapper` that is considered to be the &quot;primary&quot; mapper 
        of the statement.   The term &quot;bind mapper&quot; refers to the fact that 
        a :class:`_orm.Session` object may be &quot;bound&quot; to multiple 
        :class:`_engine.Engine` objects keyed to mapped classes, and the 
        &quot;bind mapper&quot; determines which of those :class:`_engine.Engine` objects 
        would be selected. 
 
        For a statement that is invoked against a single mapped class, 
        :attr:`_orm.ORMExecuteState.bind_mapper` is intended to be a reliable 
        way of getting this mapper. 
 
        .. versionadded:: 1.4.0b2 
 
        .. seealso:: 
 
            :attr:`_orm.ORMExecuteState.all_mappers` 
 
 
        &quot;&quot;&quot;</span>
        <span class="s1">mp</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Mapper</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">bind_arguments</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;mapper&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">mp</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">all_mappers</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Sequence</span><span class="s4">[</span><span class="s1">Mapper</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;Return a sequence of all :class:`_orm.Mapper` objects that are 
        involved at the top level of this statement. 
 
        By &quot;top level&quot; we mean those :class:`_orm.Mapper` objects that would 
        be represented in the result set rows for a :func:`_sql.select` 
        query, or for a :func:`_dml.update` or :func:`_dml.delete` query, 
        the mapper that is the main subject of the UPDATE or DELETE. 
 
        .. versionadded:: 1.4.0b2 
 
        .. seealso:: 
 
            :attr:`_orm.ORMExecuteState.bind_mapper` 
 
 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">is_orm_statement</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">[]</span>
        <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">, (</span><span class="s1">Select</span><span class="s4">, </span><span class="s1">FromStatement</span><span class="s4">)):</span>
            <span class="s1">result </span><span class="s4">= []</span>
            <span class="s1">seen </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()</span>
            <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">column_descriptions</span><span class="s4">:</span>
                <span class="s1">ent </span><span class="s4">= </span><span class="s1">d</span><span class="s4">[</span><span class="s5">&quot;entity&quot;</span><span class="s4">]</span>
                <span class="s3">if </span><span class="s1">ent</span><span class="s4">:</span>
                    <span class="s1">insp </span><span class="s4">= </span><span class="s1">inspect</span><span class="s4">(</span><span class="s1">ent</span><span class="s4">, </span><span class="s1">raiseerr</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">insp </span><span class="s3">and </span><span class="s1">insp</span><span class="s4">.</span><span class="s1">mapper </span><span class="s3">and </span><span class="s1">insp</span><span class="s4">.</span><span class="s1">mapper </span><span class="s3">not in </span><span class="s1">seen</span><span class="s4">:</span>
                        <span class="s1">seen</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">insp</span><span class="s4">.</span><span class="s1">mapper</span><span class="s4">)</span>
                        <span class="s1">result</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">insp</span><span class="s4">.</span><span class="s1">mapper</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">result</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">is_dml </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">bind_mapper</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">bind_mapper</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">[]</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">is_orm_statement</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;return True if the operation is an ORM statement. 
 
        This indicates that the select(), insert(), update(), or delete() 
        being invoked contains ORM entities as subjects.   For a statement 
        that does not have ORM entities and instead refers only to 
        :class:`.Table` metadata, it is invoked as a Core SQL statement 
        and no ORM-level automation takes place. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_state_cls </span><span class="s3">is not None</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">is_executemany</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;return True if the parameters are a multi-element list of 
        dictionaries with more than one dictionary. 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">parameters</span><span class="s4">, </span><span class="s1">list</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">is_select</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;return True if this is a SELECT operation. 
 
        .. versionchanged:: 2.0.30 - the attribute is also True for a 
           :meth:`_sql.Select.from_statement` construct that is itself against 
           a :class:`_sql.Select` construct, such as 
           ``select(Entity).from_statement(select(..))`` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">is_select</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">is_from_statement</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;return True if this operation is a 
        :meth:`_sql.Select.from_statement` operation. 
 
        This is independent from :attr:`_orm.ORMExecuteState.is_select`, as a 
        ``select().from_statement()`` construct can be used with 
        INSERT/UPDATE/DELETE RETURNING types of statements as well. 
        :attr:`_orm.ORMExecuteState.is_select` will only be set if the 
        :meth:`_sql.Select.from_statement` is itself against a 
        :class:`_sql.Select` construct. 
 
        .. versionadded:: 2.0.30 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">is_from_statement</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">is_insert</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;return True if this is an INSERT operation. 
 
        .. versionchanged:: 2.0.30 - the attribute is also True for a 
           :meth:`_sql.Select.from_statement` construct that is itself against 
           a :class:`_sql.Insert` construct, such as 
           ``select(Entity).from_statement(insert(..))`` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">is_dml </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">is_insert</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">is_update</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;return True if this is an UPDATE operation. 
 
        .. versionchanged:: 2.0.30 - the attribute is also True for a 
           :meth:`_sql.Select.from_statement` construct that is itself against 
           a :class:`_sql.Update` construct, such as 
           ``select(Entity).from_statement(update(..))`` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">is_dml </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">is_update</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">is_delete</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;return True if this is a DELETE operation. 
 
        .. versionchanged:: 2.0.30 - the attribute is also True for a 
           :meth:`_sql.Select.from_statement` construct that is itself against 
           a :class:`_sql.Delete` construct, such as 
           ``select(Entity).from_statement(delete(..))`` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">is_dml </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">is_delete</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_is_crud</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">, (</span><span class="s1">dml</span><span class="s4">.</span><span class="s1">Update</span><span class="s4">, </span><span class="s1">dml</span><span class="s4">.</span><span class="s1">Delete</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">update_execution_options</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">opts</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Update the local execution options with new values.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">local_execution_options </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">local_execution_options</span><span class="s4">.</span><span class="s1">union</span><span class="s4">(</span><span class="s1">opts</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_orm_compile_options</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span>
        <span class="s1">Union</span><span class="s4">[</span>
            <span class="s1">context</span><span class="s4">.</span><span class="s1">ORMCompileState</span><span class="s4">.</span><span class="s1">default_compile_options</span><span class="s4">,</span>
            <span class="s1">Type</span><span class="s4">[</span><span class="s1">context</span><span class="s4">.</span><span class="s1">ORMCompileState</span><span class="s4">.</span><span class="s1">default_compile_options</span><span class="s4">],</span>
        <span class="s4">]</span>
    <span class="s4">]:</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">is_select</span><span class="s4">:</span>
            <span class="s3">return None</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">opts </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_compile_options</span>
        <span class="s3">except </span><span class="s1">AttributeError</span><span class="s4">:</span>
            <span class="s3">return None</span>

        <span class="s3">if </span><span class="s1">opts </span><span class="s3">is not None and </span><span class="s1">opts</span><span class="s4">.</span><span class="s1">isinstance</span><span class="s4">(</span>
            <span class="s1">context</span><span class="s4">.</span><span class="s1">ORMCompileState</span><span class="s4">.</span><span class="s1">default_compile_options</span>
        <span class="s4">):</span>
            <span class="s3">return </span><span class="s1">opts  </span><span class="s0"># type: ignore</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return None</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">lazy_loaded_from</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;An :class:`.InstanceState` that is using this statement execution 
        for a lazy load operation. 
 
        The primary rationale for this attribute is to support the horizontal 
        sharding extension, where it is available within specific query 
        execution time hooks created by this extension.   To that end, the 
        attribute is only intended to be meaningful at **query execution 
        time**, and importantly not any time prior to that, including query 
        compilation time. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">load_options</span><span class="s4">.</span><span class="s1">_lazy_loaded_from</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">loader_strategy_path</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">PathRegistry</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the :class:`.PathRegistry` for the current load path. 
 
        This object represents the &quot;path&quot; in a query along relationships 
        when a particular object or collection is being loaded. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">opts </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_orm_compile_options</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">opts </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">opts</span><span class="s4">.</span><span class="s1">_current_path</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return None</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">is_column_load</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return True if the operation is refreshing column-oriented 
        attributes on an existing ORM object. 
 
        This occurs during operations such as :meth:`_orm.Session.refresh`, 
        as well as when an attribute deferred by :func:`_orm.defer` is 
        being loaded, or an attribute that was expired either directly 
        by :meth:`_orm.Session.expire` or via a commit operation is being 
        loaded. 
 
        Handlers will very likely not want to add any options to queries 
        when such an operation is occurring as the query should be a straight 
        primary key fetch which should not have any additional WHERE criteria, 
        and loader options travelling with the instance 
        will have already been added to the query. 
 
        .. versionadded:: 1.4.0b2 
 
        .. seealso:: 
 
            :attr:`_orm.ORMExecuteState.is_relationship_load` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">opts </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_orm_compile_options</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">opts </span><span class="s3">is not None and </span><span class="s1">opts</span><span class="s4">.</span><span class="s1">_for_refresh_state</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">is_relationship_load</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return True if this load is loading objects on behalf of a 
        relationship. 
 
        This means, the loader in effect is either a LazyLoader, 
        SelectInLoader, SubqueryLoader, or similar, and the entire 
        SELECT statement being emitted is on behalf of a relationship 
        load. 
 
        Handlers will very likely not want to add any options to queries 
        when such an operation is occurring, as loader options are already 
        capable of being propagated to relationship loaders and should 
        be already present. 
 
        .. seealso:: 
 
            :attr:`_orm.ORMExecuteState.is_column_load` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">opts </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_orm_compile_options</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">opts </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return False</span>
        <span class="s1">path </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">loader_strategy_path</span>
        <span class="s3">return </span><span class="s1">path </span><span class="s3">is not None and not </span><span class="s1">path</span><span class="s4">.</span><span class="s1">is_root</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">load_options</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span>
        <span class="s1">context</span><span class="s4">.</span><span class="s1">QueryContext</span><span class="s4">.</span><span class="s1">default_load_options</span><span class="s4">,</span>
        <span class="s1">Type</span><span class="s4">[</span><span class="s1">context</span><span class="s4">.</span><span class="s1">QueryContext</span><span class="s4">.</span><span class="s1">default_load_options</span><span class="s4">],</span>
    <span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the load_options that will be used for this execution.&quot;&quot;&quot;</span>

        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">is_select</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;This ORM execution is not against a SELECT statement &quot;</span>
                <span class="s5">&quot;so there are no load options.&quot;</span>
            <span class="s4">)</span>

        <span class="s1">lo</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
            <span class="s1">context</span><span class="s4">.</span><span class="s1">QueryContext</span><span class="s4">.</span><span class="s1">default_load_options</span><span class="s4">,</span>
            <span class="s1">Type</span><span class="s4">[</span><span class="s1">context</span><span class="s4">.</span><span class="s1">QueryContext</span><span class="s4">.</span><span class="s1">default_load_options</span><span class="s4">],</span>
        <span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">execution_options</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span>
            <span class="s5">&quot;_sa_orm_load_options&quot;</span><span class="s4">, </span><span class="s1">context</span><span class="s4">.</span><span class="s1">QueryContext</span><span class="s4">.</span><span class="s1">default_load_options</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">lo</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">update_delete_options</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span>
        <span class="s1">bulk_persistence</span><span class="s4">.</span><span class="s1">BulkUDCompileState</span><span class="s4">.</span><span class="s1">default_update_options</span><span class="s4">,</span>
        <span class="s1">Type</span><span class="s4">[</span><span class="s1">bulk_persistence</span><span class="s4">.</span><span class="s1">BulkUDCompileState</span><span class="s4">.</span><span class="s1">default_update_options</span><span class="s4">],</span>
    <span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the update_delete_options that will be used for this 
        execution.&quot;&quot;&quot;</span>

        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_crud</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;This ORM execution is not against an UPDATE or DELETE &quot;</span>
                <span class="s5">&quot;statement so there are no update options.&quot;</span>
            <span class="s4">)</span>
        <span class="s1">uo</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
            <span class="s1">bulk_persistence</span><span class="s4">.</span><span class="s1">BulkUDCompileState</span><span class="s4">.</span><span class="s1">default_update_options</span><span class="s4">,</span>
            <span class="s1">Type</span><span class="s4">[</span><span class="s1">bulk_persistence</span><span class="s4">.</span><span class="s1">BulkUDCompileState</span><span class="s4">.</span><span class="s1">default_update_options</span><span class="s4">],</span>
        <span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">execution_options</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span>
            <span class="s5">&quot;_sa_orm_update_options&quot;</span><span class="s4">,</span>
            <span class="s1">bulk_persistence</span><span class="s4">.</span><span class="s1">BulkUDCompileState</span><span class="s4">.</span><span class="s1">default_update_options</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">uo</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_non_compile_orm_options</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Sequence</span><span class="s4">[</span><span class="s1">ORMOption</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s4">[</span>
            <span class="s1">opt</span>
            <span class="s3">for </span><span class="s1">opt </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_with_options</span>
            <span class="s3">if </span><span class="s1">is_orm_option</span><span class="s4">(</span><span class="s1">opt</span><span class="s4">) </span><span class="s3">and not </span><span class="s1">opt</span><span class="s4">.</span><span class="s1">_is_compile_state</span>
        <span class="s4">]</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">user_defined_options</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Sequence</span><span class="s4">[</span><span class="s1">UserDefinedOption</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;The sequence of :class:`.UserDefinedOptions` that have been 
        associated with the statement being invoked. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s4">[</span>
            <span class="s1">opt</span>
            <span class="s3">for </span><span class="s1">opt </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">_with_options</span>
            <span class="s3">if </span><span class="s1">is_user_defined_option</span><span class="s4">(</span><span class="s1">opt</span><span class="s4">)</span>
        <span class="s4">]</span>


<span class="s3">class </span><span class="s1">SessionTransactionOrigin</span><span class="s4">(</span><span class="s1">Enum</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;indicates the origin of a :class:`.SessionTransaction`. 
 
    This enumeration is present on the 
    :attr:`.SessionTransaction.origin` attribute of any 
    :class:`.SessionTransaction` object. 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">AUTOBEGIN </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s5">&quot;&quot;&quot;transaction were started by autobegin&quot;&quot;&quot;</span>

    <span class="s1">BEGIN </span><span class="s4">= </span><span class="s6">1</span>
    <span class="s5">&quot;&quot;&quot;transaction were started by calling :meth:`_orm.Session.begin`&quot;&quot;&quot;</span>

    <span class="s1">BEGIN_NESTED </span><span class="s4">= </span><span class="s6">2</span>
    <span class="s5">&quot;&quot;&quot;tranaction were started by :meth:`_orm.Session.begin_nested`&quot;&quot;&quot;</span>

    <span class="s1">SUBTRANSACTION </span><span class="s4">= </span><span class="s6">3</span>
    <span class="s5">&quot;&quot;&quot;transaction is an internal &quot;subtransaction&quot; &quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">SessionTransaction</span><span class="s4">(</span><span class="s1">_StateChange</span><span class="s4">, </span><span class="s1">TransactionalContext</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A :class:`.Session`-level transaction. 
 
    :class:`.SessionTransaction` is produced from the 
    :meth:`_orm.Session.begin` 
    and :meth:`_orm.Session.begin_nested` methods.   It's largely an internal 
    object that in modern use provides a context manager for session 
    transactions. 
 
    Documentation on interacting with :class:`_orm.SessionTransaction` is 
    at: :ref:`unitofwork_transaction`. 
 
 
    .. versionchanged:: 1.4  The scoping and API methods to work with the 
       :class:`_orm.SessionTransaction` object directly have been simplified. 
 
    .. seealso:: 
 
        :ref:`unitofwork_transaction` 
 
        :meth:`.Session.begin` 
 
        :meth:`.Session.begin_nested` 
 
        :meth:`.Session.rollback` 
 
        :meth:`.Session.commit` 
 
        :meth:`.Session.in_transaction` 
 
        :meth:`.Session.in_nested_transaction` 
 
        :meth:`.Session.get_transaction` 
 
        :meth:`.Session.get_nested_transaction` 
 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_rollback_exception</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">BaseException</span><span class="s4">] = </span><span class="s3">None</span>

    <span class="s1">_connections</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span>
        <span class="s1">Union</span><span class="s4">[</span><span class="s1">Engine</span><span class="s4">, </span><span class="s1">Connection</span><span class="s4">], </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Connection</span><span class="s4">, </span><span class="s1">Transaction</span><span class="s4">, </span><span class="s1">bool</span><span class="s4">, </span><span class="s1">bool</span><span class="s4">]</span>
    <span class="s4">]</span>
    <span class="s1">session</span><span class="s4">: </span><span class="s1">Session</span>
    <span class="s1">_parent</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">SessionTransaction</span><span class="s4">]</span>

    <span class="s1">_state</span><span class="s4">: </span><span class="s1">SessionTransactionState</span>

    <span class="s1">_new</span><span class="s4">: </span><span class="s1">weakref</span><span class="s4">.</span><span class="s1">WeakKeyDictionary</span><span class="s4">[</span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">object</span><span class="s4">]</span>
    <span class="s1">_deleted</span><span class="s4">: </span><span class="s1">weakref</span><span class="s4">.</span><span class="s1">WeakKeyDictionary</span><span class="s4">[</span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">object</span><span class="s4">]</span>
    <span class="s1">_dirty</span><span class="s4">: </span><span class="s1">weakref</span><span class="s4">.</span><span class="s1">WeakKeyDictionary</span><span class="s4">[</span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">object</span><span class="s4">]</span>
    <span class="s1">_key_switches</span><span class="s4">: </span><span class="s1">weakref</span><span class="s4">.</span><span class="s1">WeakKeyDictionary</span><span class="s4">[</span>
        <span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s4">]</span>

    <span class="s1">origin</span><span class="s4">: </span><span class="s1">SessionTransactionOrigin</span>
    <span class="s5">&quot;&quot;&quot;Origin of this :class:`_orm.SessionTransaction`. 
 
    Refers to a :class:`.SessionTransactionOrigin` instance which is an 
    enumeration indicating the source event that led to constructing 
    this :class:`_orm.SessionTransaction`. 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">nested</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s5">&quot;&quot;&quot;Indicates if this is a nested, or SAVEPOINT, transaction. 
 
    When :attr:`.SessionTransaction.nested` is True, it is expected 
    that :attr:`.SessionTransaction.parent` will be present as well, 
    linking to the enclosing :class:`.SessionTransaction`. 
 
    .. seealso:: 
 
        :attr:`.SessionTransaction.origin` 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">session</span><span class="s4">: </span><span class="s1">Session</span><span class="s4">,</span>
        <span class="s1">origin</span><span class="s4">: </span><span class="s1">SessionTransactionOrigin</span><span class="s4">,</span>
        <span class="s1">parent</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">SessionTransaction</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">TransactionalContext</span><span class="s4">.</span><span class="s1">_trans_ctx_check</span><span class="s4">(</span><span class="s1">session</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">session </span><span class="s4">= </span><span class="s1">session</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_connections </span><span class="s4">= {}</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_parent </span><span class="s4">= </span><span class="s1">parent</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">nested </span><span class="s4">= </span><span class="s1">nested </span><span class="s4">= </span><span class="s1">origin </span><span class="s3">is </span><span class="s1">SessionTransactionOrigin</span><span class="s4">.</span><span class="s1">BEGIN_NESTED</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">origin </span><span class="s4">= </span><span class="s1">origin</span>

        <span class="s3">if </span><span class="s1">session</span><span class="s4">.</span><span class="s1">_close_state </span><span class="s3">is </span><span class="s1">_SessionCloseState</span><span class="s4">.</span><span class="s1">CLOSED</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;This Session has been permanently closed and is unable &quot;</span>
                <span class="s5">&quot;to handle any more transaction requests.&quot;</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">nested</span><span class="s4">:</span>
            <span class="s3">if not </span><span class="s1">parent</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                    <span class="s5">&quot;Can't start a SAVEPOINT transaction when no existing &quot;</span>
                    <span class="s5">&quot;transaction is in progress&quot;</span>
                <span class="s4">)</span>

            <span class="s1">self</span><span class="s4">.</span><span class="s1">_previous_nested_transaction </span><span class="s4">= </span><span class="s1">session</span><span class="s4">.</span><span class="s1">_nested_transaction</span>
        <span class="s3">elif </span><span class="s1">origin </span><span class="s3">is </span><span class="s1">SessionTransactionOrigin</span><span class="s4">.</span><span class="s1">SUBTRANSACTION</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">parent </span><span class="s3">is not None</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">parent </span><span class="s3">is None</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_state </span><span class="s4">= </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">ACTIVE</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_take_snapshot</span><span class="s4">()</span>

        <span class="s0"># make sure transaction is assigned before we call the</span>
        <span class="s0"># dispatch</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">_transaction </span><span class="s4">= </span><span class="s1">self</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">after_transaction_create</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">, </span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_raise_for_prerequisite_state</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">operation_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">state</span><span class="s4">: </span><span class="s1">_StateChangeState</span>
    <span class="s4">) </span><span class="s1">-&gt; NoReturn</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">state </span><span class="s3">is </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">DEACTIVE</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_rollback_exception</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">PendingRollbackError</span><span class="s4">(</span>
                    <span class="s5">&quot;This Session's transaction has been rolled back &quot;</span>
                    <span class="s5">&quot;due to a previous exception during flush.&quot;</span>
                    <span class="s5">&quot; To begin a new transaction with this Session, &quot;</span>
                    <span class="s5">&quot;first issue Session.rollback().&quot;</span>
                    <span class="s5">f&quot; Original exception was: </span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_rollback_exception</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s4">,</span>
                    <span class="s1">code</span><span class="s4">=</span><span class="s5">&quot;7s2a&quot;</span><span class="s4">,</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                    <span class="s5">&quot;This session is in 'inactive' state, due to the &quot;</span>
                    <span class="s5">&quot;SQL transaction being rolled back; no further SQL &quot;</span>
                    <span class="s5">&quot;can be emitted within this transaction.&quot;</span>
                <span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">state </span><span class="s3">is </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">CLOSED</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">ResourceClosedError</span><span class="s4">(</span><span class="s5">&quot;This transaction is closed&quot;</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">state </span><span class="s3">is </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">PROVISIONING_CONNECTION</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;This session is provisioning a new connection; concurrent &quot;</span>
                <span class="s5">&quot;operations are not permitted&quot;</span><span class="s4">,</span>
                <span class="s1">code</span><span class="s4">=</span><span class="s5">&quot;isce&quot;</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">f&quot;This session is in '</span><span class="s3">{</span><span class="s1">state</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">()</span><span class="s3">}</span><span class="s5">' state; no &quot;</span>
                <span class="s5">&quot;further SQL can be emitted within this transaction.&quot;</span>
            <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">parent</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">SessionTransaction</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;The parent :class:`.SessionTransaction` of this 
        :class:`.SessionTransaction`. 
 
        If this attribute is ``None``, indicates this 
        :class:`.SessionTransaction` is at the top of the stack, and 
        corresponds to a real &quot;COMMIT&quot;/&quot;ROLLBACK&quot; 
        block.  If non-``None``, then this is either a &quot;subtransaction&quot; 
        (an internal marker object used by the flush process) or a 
        &quot;nested&quot; / SAVEPOINT transaction.  If the 
        :attr:`.SessionTransaction.nested` attribute is ``True``, then 
        this is a SAVEPOINT, and if ``False``, indicates this a subtransaction. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parent</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">is_active</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">session </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_state </span><span class="s3">is </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">ACTIVE</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_is_transaction_boundary</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nested </span><span class="s3">or not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parent</span>

    <span class="s4">@</span><span class="s1">_StateChange</span><span class="s4">.</span><span class="s1">declare_states</span><span class="s4">(</span>
        <span class="s4">(</span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">ACTIVE</span><span class="s4">,), </span><span class="s1">_StateChangeStates</span><span class="s4">.</span><span class="s1">NO_CHANGE</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">connection</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">bindkey</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Mapper</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_ExecuteOptions</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Connection</span><span class="s4">:</span>
        <span class="s1">bind </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">get_bind</span><span class="s4">(</span><span class="s1">bindkey</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_connection_for_bind</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">, </span><span class="s1">execution_options</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_StateChange</span><span class="s4">.</span><span class="s1">declare_states</span><span class="s4">(</span>
        <span class="s4">(</span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">ACTIVE</span><span class="s4">,), </span><span class="s1">_StateChangeStates</span><span class="s4">.</span><span class="s1">NO_CHANGE</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">_begin</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">nested</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">) </span><span class="s1">-&gt; SessionTransaction</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">SessionTransaction</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">,</span>
            <span class="s4">(</span>
                <span class="s1">SessionTransactionOrigin</span><span class="s4">.</span><span class="s1">BEGIN_NESTED</span>
                <span class="s3">if </span><span class="s1">nested</span>
                <span class="s3">else </span><span class="s1">SessionTransactionOrigin</span><span class="s4">.</span><span class="s1">SUBTRANSACTION</span>
            <span class="s4">),</span>
            <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_iterate_self_and_parents</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">upto</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">SessionTransaction</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">SessionTransaction</span><span class="s4">]:</span>
        <span class="s1">current </span><span class="s4">= </span><span class="s1">self</span>
        <span class="s1">result</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">SessionTransaction</span><span class="s4">, ...] = ()</span>
        <span class="s3">while </span><span class="s1">current</span><span class="s4">:</span>
            <span class="s1">result </span><span class="s4">+= (</span><span class="s1">current</span><span class="s4">,)</span>
            <span class="s3">if </span><span class="s1">current</span><span class="s4">.</span><span class="s1">_parent </span><span class="s3">is </span><span class="s1">upto</span><span class="s4">:</span>
                <span class="s3">break</span>
            <span class="s3">elif </span><span class="s1">current</span><span class="s4">.</span><span class="s1">_parent </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                    <span class="s5">&quot;Transaction %s is not on the active transaction list&quot;</span>
                    <span class="s4">% (</span><span class="s1">upto</span><span class="s4">)</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">current </span><span class="s4">= </span><span class="s1">current</span><span class="s4">.</span><span class="s1">_parent</span>

        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">_take_snapshot</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_transaction_boundary</span><span class="s4">:</span>
            <span class="s1">parent </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parent</span>
            <span class="s3">assert </span><span class="s1">parent </span><span class="s3">is not None</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_new </span><span class="s4">= </span><span class="s1">parent</span><span class="s4">.</span><span class="s1">_new</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted </span><span class="s4">= </span><span class="s1">parent</span><span class="s4">.</span><span class="s1">_deleted</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_dirty </span><span class="s4">= </span><span class="s1">parent</span><span class="s4">.</span><span class="s1">_dirty</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_key_switches </span><span class="s4">= </span><span class="s1">parent</span><span class="s4">.</span><span class="s1">_key_switches</span>
            <span class="s3">return</span>

        <span class="s1">is_begin </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">origin </span><span class="s3">in </span><span class="s4">(</span>
            <span class="s1">SessionTransactionOrigin</span><span class="s4">.</span><span class="s1">BEGIN</span><span class="s4">,</span>
            <span class="s1">SessionTransactionOrigin</span><span class="s4">.</span><span class="s1">AUTOBEGIN</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">is_begin </span><span class="s3">and not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">_flushing</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">flush</span><span class="s4">()</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_new </span><span class="s4">= </span><span class="s1">weakref</span><span class="s4">.</span><span class="s1">WeakKeyDictionary</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted </span><span class="s4">= </span><span class="s1">weakref</span><span class="s4">.</span><span class="s1">WeakKeyDictionary</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_dirty </span><span class="s4">= </span><span class="s1">weakref</span><span class="s4">.</span><span class="s1">WeakKeyDictionary</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_key_switches </span><span class="s4">= </span><span class="s1">weakref</span><span class="s4">.</span><span class="s1">WeakKeyDictionary</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_restore_snapshot</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dirty_only</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Restore the restoration state taken before a transaction began. 
 
        Corresponds to a rollback. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_transaction_boundary</span>

        <span class="s1">to_expunge </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">).</span><span class="s1">union</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">_expunge_states</span><span class="s4">(</span><span class="s1">to_expunge</span><span class="s4">, </span><span class="s1">to_transient</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

        <span class="s3">for </span><span class="s1">s</span><span class="s4">, (</span><span class="s1">oldkey</span><span class="s4">, </span><span class="s1">newkey</span><span class="s4">) </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_key_switches</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
            <span class="s0"># we probably can do this conditionally based on</span>
            <span class="s0"># if we expunged or not, but safe_discard does that anyway</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">safe_discard</span><span class="s4">(</span><span class="s1">s</span><span class="s4">)</span>

            <span class="s0"># restore the old key</span>
            <span class="s1">s</span><span class="s4">.</span><span class="s1">key </span><span class="s4">= </span><span class="s1">oldkey</span>

            <span class="s0"># now restore the object, but only if we didn't expunge</span>
            <span class="s3">if </span><span class="s1">s </span><span class="s3">not in </span><span class="s1">to_expunge</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s1">s</span><span class="s4">)</span>

        <span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">set</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">).</span><span class="s1">union</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">_update_impl</span><span class="s4">(</span><span class="s1">s</span><span class="s4">, </span><span class="s1">revert_deletion</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

        <span class="s3">assert not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">_deleted</span>

        <span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">all_states</span><span class="s4">():</span>
            <span class="s3">if not </span><span class="s1">dirty_only </span><span class="s3">or </span><span class="s1">s</span><span class="s4">.</span><span class="s1">modified </span><span class="s3">or </span><span class="s1">s </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dirty</span><span class="s4">:</span>
                <span class="s1">s</span><span class="s4">.</span><span class="s1">_expire</span><span class="s4">(</span><span class="s1">s</span><span class="s4">.</span><span class="s1">dict</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">_modified</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_remove_snapshot</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Remove the restoration state taken before a transaction began. 
 
        Corresponds to a commit. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_transaction_boundary</span>

        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nested </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">expire_on_commit</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">all_states</span><span class="s4">():</span>
                <span class="s1">s</span><span class="s4">.</span><span class="s1">_expire</span><span class="s4">(</span><span class="s1">s</span><span class="s4">.</span><span class="s1">dict</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">_modified</span><span class="s4">)</span>

            <span class="s1">statelib</span><span class="s4">.</span><span class="s1">InstanceState</span><span class="s4">.</span><span class="s1">_detach_states</span><span class="s4">(</span>
                <span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">), </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span>
            <span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">.</span><span class="s1">clear</span><span class="s4">()</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nested</span><span class="s4">:</span>
            <span class="s1">parent </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parent</span>
            <span class="s3">assert </span><span class="s1">parent </span><span class="s3">is not None</span>
            <span class="s1">parent</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">)</span>
            <span class="s1">parent</span><span class="s4">.</span><span class="s1">_dirty</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dirty</span><span class="s4">)</span>
            <span class="s1">parent</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">)</span>
            <span class="s1">parent</span><span class="s4">.</span><span class="s1">_key_switches</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_key_switches</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_StateChange</span><span class="s4">.</span><span class="s1">declare_states</span><span class="s4">(</span>
        <span class="s4">(</span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">ACTIVE</span><span class="s4">,), </span><span class="s1">_StateChangeStates</span><span class="s4">.</span><span class="s1">NO_CHANGE</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">_connection_for_bind</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">bind</span><span class="s4">: </span><span class="s1">_SessionBind</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">CoreExecuteOptionsParameter</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; Connection</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">bind </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_connections</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">execution_options</span><span class="s4">:</span>
                <span class="s1">util</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                    <span class="s5">&quot;Connection is already established for the &quot;</span>
                    <span class="s5">&quot;given bind; execution_options ignored&quot;</span>
                <span class="s4">)</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_connections</span><span class="s4">[</span><span class="s1">bind</span><span class="s4">][</span><span class="s6">0</span><span class="s4">]</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_state </span><span class="s4">= </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">PROVISIONING_CONNECTION</span>

        <span class="s1">local_connect </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s1">should_commit </span><span class="s4">= </span><span class="s3">True</span>

        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parent</span><span class="s4">:</span>
                <span class="s1">conn </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parent</span><span class="s4">.</span><span class="s1">_connection_for_bind</span><span class="s4">(</span>
                    <span class="s1">bind</span><span class="s4">, </span><span class="s1">execution_options</span>
                <span class="s4">)</span>
                <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nested</span><span class="s4">:</span>
                    <span class="s3">return </span><span class="s1">conn</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">, </span><span class="s1">engine</span><span class="s4">.</span><span class="s1">Connection</span><span class="s4">):</span>
                    <span class="s1">conn </span><span class="s4">= </span><span class="s1">bind</span>
                    <span class="s3">if </span><span class="s1">conn</span><span class="s4">.</span><span class="s1">engine </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_connections</span><span class="s4">:</span>
                        <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                            <span class="s5">&quot;Session already has a Connection associated &quot;</span>
                            <span class="s5">&quot;for the given Connection's Engine&quot;</span>
                        <span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">conn </span><span class="s4">= </span><span class="s1">bind</span><span class="s4">.</span><span class="s1">connect</span><span class="s4">()</span>
                    <span class="s1">local_connect </span><span class="s4">= </span><span class="s3">True</span>

            <span class="s3">try</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">execution_options</span><span class="s4">:</span>
                    <span class="s1">conn </span><span class="s4">= </span><span class="s1">conn</span><span class="s4">.</span><span class="s1">execution_options</span><span class="s4">(**</span><span class="s1">execution_options</span><span class="s4">)</span>

                <span class="s1">transaction</span><span class="s4">: </span><span class="s1">Transaction</span>
                <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">twophase </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parent </span><span class="s3">is None</span><span class="s4">:</span>
                    <span class="s0"># TODO: shouldn't we only be here if not</span>
                    <span class="s0"># conn.in_transaction() ?</span>
                    <span class="s0"># if twophase is set and conn.in_transaction(), validate</span>
                    <span class="s0"># that it is in fact twophase.</span>
                    <span class="s1">transaction </span><span class="s4">= </span><span class="s1">conn</span><span class="s4">.</span><span class="s1">begin_twophase</span><span class="s4">()</span>
                <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nested</span><span class="s4">:</span>
                    <span class="s1">transaction </span><span class="s4">= </span><span class="s1">conn</span><span class="s4">.</span><span class="s1">begin_nested</span><span class="s4">()</span>
                <span class="s3">elif </span><span class="s1">conn</span><span class="s4">.</span><span class="s1">in_transaction</span><span class="s4">():</span>
                    <span class="s1">join_transaction_mode </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">join_transaction_mode</span>

                    <span class="s3">if </span><span class="s1">join_transaction_mode </span><span class="s4">== </span><span class="s5">&quot;conditional_savepoint&quot;</span><span class="s4">:</span>
                        <span class="s3">if </span><span class="s1">conn</span><span class="s4">.</span><span class="s1">in_nested_transaction</span><span class="s4">():</span>
                            <span class="s1">join_transaction_mode </span><span class="s4">= </span><span class="s5">&quot;create_savepoint&quot;</span>
                        <span class="s3">else</span><span class="s4">:</span>
                            <span class="s1">join_transaction_mode </span><span class="s4">= </span><span class="s5">&quot;rollback_only&quot;</span>

                        <span class="s3">if </span><span class="s1">local_connect</span><span class="s4">:</span>
                            <span class="s1">util</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                                <span class="s5">&quot;The engine provided as bind produced a &quot;</span>
                                <span class="s5">&quot;connection that is already in a transaction. &quot;</span>
                                <span class="s5">&quot;This is usually caused by a core event, &quot;</span>
                                <span class="s5">&quot;such as 'engine_connect', that has left a &quot;</span>
                                <span class="s5">&quot;transaction open. The effective join &quot;</span>
                                <span class="s5">&quot;transaction mode used by this session is &quot;</span>
                                <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">join_transaction_mode</span><span class="s3">!r}</span><span class="s5">. To silence this &quot;</span>
                                <span class="s5">&quot;warning, do not leave transactions open&quot;</span>
                            <span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">join_transaction_mode </span><span class="s3">in </span><span class="s4">(</span>
                        <span class="s5">&quot;control_fully&quot;</span><span class="s4">,</span>
                        <span class="s5">&quot;rollback_only&quot;</span><span class="s4">,</span>
                    <span class="s4">):</span>
                        <span class="s3">if </span><span class="s1">conn</span><span class="s4">.</span><span class="s1">in_nested_transaction</span><span class="s4">():</span>
                            <span class="s1">transaction </span><span class="s4">= (</span>
                                <span class="s1">conn</span><span class="s4">.</span><span class="s1">_get_required_nested_transaction</span><span class="s4">()</span>
                            <span class="s4">)</span>
                        <span class="s3">else</span><span class="s4">:</span>
                            <span class="s1">transaction </span><span class="s4">= </span><span class="s1">conn</span><span class="s4">.</span><span class="s1">_get_required_transaction</span><span class="s4">()</span>
                        <span class="s3">if </span><span class="s1">join_transaction_mode </span><span class="s4">== </span><span class="s5">&quot;rollback_only&quot;</span><span class="s4">:</span>
                            <span class="s1">should_commit </span><span class="s4">= </span><span class="s3">False</span>
                    <span class="s3">elif </span><span class="s1">join_transaction_mode </span><span class="s4">== </span><span class="s5">&quot;create_savepoint&quot;</span><span class="s4">:</span>
                        <span class="s1">transaction </span><span class="s4">= </span><span class="s1">conn</span><span class="s4">.</span><span class="s1">begin_nested</span><span class="s4">()</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s3">assert False</span><span class="s4">, </span><span class="s1">join_transaction_mode</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">transaction </span><span class="s4">= </span><span class="s1">conn</span><span class="s4">.</span><span class="s1">begin</span><span class="s4">()</span>
            <span class="s3">except</span><span class="s4">:</span>
                <span class="s0"># connection will not not be associated with this Session;</span>
                <span class="s0"># close it immediately so that it isn't closed under GC</span>
                <span class="s3">if </span><span class="s1">local_connect</span><span class="s4">:</span>
                    <span class="s1">conn</span><span class="s4">.</span><span class="s1">close</span><span class="s4">()</span>
                <span class="s3">raise</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">bind_is_connection </span><span class="s4">= </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">, </span><span class="s1">engine</span><span class="s4">.</span><span class="s1">Connection</span><span class="s4">)</span>

                <span class="s1">self</span><span class="s4">.</span><span class="s1">_connections</span><span class="s4">[</span><span class="s1">conn</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_connections</span><span class="s4">[</span><span class="s1">conn</span><span class="s4">.</span><span class="s1">engine</span><span class="s4">] = (</span>
                    <span class="s1">conn</span><span class="s4">,</span>
                    <span class="s1">transaction</span><span class="s4">,</span>
                    <span class="s1">should_commit</span><span class="s4">,</span>
                    <span class="s3">not </span><span class="s1">bind_is_connection</span><span class="s4">,</span>
                <span class="s4">)</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">after_begin</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, </span><span class="s1">conn</span><span class="s4">)</span>
                <span class="s3">return </span><span class="s1">conn</span>
        <span class="s3">finally</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_state </span><span class="s4">= </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">ACTIVE</span>

    <span class="s3">def </span><span class="s1">prepare</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parent </span><span class="s3">is not None or not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">twophase</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;'twophase' mode not enabled, or not root transaction; &quot;</span>
                <span class="s5">&quot;can't prepare.&quot;</span>
            <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_prepare_impl</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">_StateChange</span><span class="s4">.</span><span class="s1">declare_states</span><span class="s4">(</span>
        <span class="s4">(</span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">ACTIVE</span><span class="s4">,), </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">PREPARED</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">_prepare_impl</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parent </span><span class="s3">is None or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nested</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">before_commit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">)</span>

        <span class="s1">stx </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">_transaction</span>
        <span class="s3">assert </span><span class="s1">stx </span><span class="s3">is not None</span>
        <span class="s3">if </span><span class="s1">stx </span><span class="s3">is not </span><span class="s1">self</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">subtransaction </span><span class="s3">in </span><span class="s1">stx</span><span class="s4">.</span><span class="s1">_iterate_self_and_parents</span><span class="s4">(</span><span class="s1">upto</span><span class="s4">=</span><span class="s1">self</span><span class="s4">):</span>
                <span class="s1">subtransaction</span><span class="s4">.</span><span class="s1">commit</span><span class="s4">()</span>

        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">_flushing</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">_flush_guard </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s6">100</span><span class="s4">):</span>
                <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">_is_clean</span><span class="s4">():</span>
                    <span class="s3">break</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">flush</span><span class="s4">()</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">FlushError</span><span class="s4">(</span>
                    <span class="s5">&quot;Over 100 subsequent flushes have occurred within &quot;</span>
                    <span class="s5">&quot;session.commit() - is an after_flush() hook &quot;</span>
                    <span class="s5">&quot;creating new objects?&quot;</span>
                <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parent </span><span class="s3">is None and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">twophase</span><span class="s4">:</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">set</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_connections</span><span class="s4">.</span><span class="s1">values</span><span class="s4">()):</span>
                    <span class="s1">cast</span><span class="s4">(</span><span class="s5">&quot;TwoPhaseTransaction&quot;</span><span class="s4">, </span><span class="s1">t</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]).</span><span class="s1">prepare</span><span class="s4">()</span>
            <span class="s3">except</span><span class="s4">:</span>
                <span class="s3">with </span><span class="s1">util</span><span class="s4">.</span><span class="s1">safe_reraise</span><span class="s4">():</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">rollback</span><span class="s4">()</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_state </span><span class="s4">= </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">PREPARED</span>

    <span class="s4">@</span><span class="s1">_StateChange</span><span class="s4">.</span><span class="s1">declare_states</span><span class="s4">(</span>
        <span class="s4">(</span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">ACTIVE</span><span class="s4">, </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">PREPARED</span><span class="s4">),</span>
        <span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">CLOSED</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">commit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">_to_root</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_state </span><span class="s3">is not </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">PREPARED</span><span class="s4">:</span>
            <span class="s3">with </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_expect_state</span><span class="s4">(</span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">PREPARED</span><span class="s4">):</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_prepare_impl</span><span class="s4">()</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parent </span><span class="s3">is None or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nested</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">conn</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">should_commit</span><span class="s4">, </span><span class="s1">autoclose </span><span class="s3">in </span><span class="s1">set</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_connections</span><span class="s4">.</span><span class="s1">values</span><span class="s4">()</span>
            <span class="s4">):</span>
                <span class="s3">if </span><span class="s1">should_commit</span><span class="s4">:</span>
                    <span class="s1">trans</span><span class="s4">.</span><span class="s1">commit</span><span class="s4">()</span>

            <span class="s1">self</span><span class="s4">.</span><span class="s1">_state </span><span class="s4">= </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">COMMITTED</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">after_commit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">)</span>

            <span class="s1">self</span><span class="s4">.</span><span class="s1">_remove_snapshot</span><span class="s4">()</span>

        <span class="s3">with </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_expect_state</span><span class="s4">(</span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">CLOSED</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">close</span><span class="s4">()</span>

        <span class="s3">if </span><span class="s1">_to_root </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parent</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_parent</span><span class="s4">.</span><span class="s1">commit</span><span class="s4">(</span><span class="s1">_to_root</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_StateChange</span><span class="s4">.</span><span class="s1">declare_states</span><span class="s4">(</span>
        <span class="s4">(</span>
            <span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">ACTIVE</span><span class="s4">,</span>
            <span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">DEACTIVE</span><span class="s4">,</span>
            <span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">PREPARED</span><span class="s4">,</span>
        <span class="s4">),</span>
        <span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">CLOSED</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">rollback</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">_capture_exception</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">, </span><span class="s1">_to_root</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">stx </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">_transaction</span>
        <span class="s3">assert </span><span class="s1">stx </span><span class="s3">is not None</span>
        <span class="s3">if </span><span class="s1">stx </span><span class="s3">is not </span><span class="s1">self</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">subtransaction </span><span class="s3">in </span><span class="s1">stx</span><span class="s4">.</span><span class="s1">_iterate_self_and_parents</span><span class="s4">(</span><span class="s1">upto</span><span class="s4">=</span><span class="s1">self</span><span class="s4">):</span>
                <span class="s1">subtransaction</span><span class="s4">.</span><span class="s1">close</span><span class="s4">()</span>

        <span class="s1">boundary </span><span class="s4">= </span><span class="s1">self</span>
        <span class="s1">rollback_err </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_state </span><span class="s3">in </span><span class="s4">(</span>
            <span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">ACTIVE</span><span class="s4">,</span>
            <span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">PREPARED</span><span class="s4">,</span>
        <span class="s4">):</span>
            <span class="s3">for </span><span class="s1">transaction </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iterate_self_and_parents</span><span class="s4">():</span>
                <span class="s3">if </span><span class="s1">transaction</span><span class="s4">.</span><span class="s1">_parent </span><span class="s3">is None or </span><span class="s1">transaction</span><span class="s4">.</span><span class="s1">nested</span><span class="s4">:</span>
                    <span class="s3">try</span><span class="s4">:</span>
                        <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">set</span><span class="s4">(</span><span class="s1">transaction</span><span class="s4">.</span><span class="s1">_connections</span><span class="s4">.</span><span class="s1">values</span><span class="s4">()):</span>
                            <span class="s1">t</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">rollback</span><span class="s4">()</span>

                        <span class="s1">transaction</span><span class="s4">.</span><span class="s1">_state </span><span class="s4">= </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">DEACTIVE</span>
                        <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">after_rollback</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">)</span>
                    <span class="s3">except</span><span class="s4">:</span>
                        <span class="s1">rollback_err </span><span class="s4">= </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">exc_info</span><span class="s4">()</span>
                    <span class="s3">finally</span><span class="s4">:</span>
                        <span class="s1">transaction</span><span class="s4">.</span><span class="s1">_state </span><span class="s4">= </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">DEACTIVE</span>
                        <span class="s1">transaction</span><span class="s4">.</span><span class="s1">_restore_snapshot</span><span class="s4">(</span>
                            <span class="s1">dirty_only</span><span class="s4">=</span><span class="s1">transaction</span><span class="s4">.</span><span class="s1">nested</span>
                        <span class="s4">)</span>
                    <span class="s1">boundary </span><span class="s4">= </span><span class="s1">transaction</span>
                    <span class="s3">break</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">transaction</span><span class="s4">.</span><span class="s1">_state </span><span class="s4">= </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">DEACTIVE</span>

        <span class="s1">sess </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span>

        <span class="s3">if not </span><span class="s1">rollback_err </span><span class="s3">and not </span><span class="s1">sess</span><span class="s4">.</span><span class="s1">_is_clean</span><span class="s4">():</span>
            <span class="s0"># if items were added, deleted, or mutated</span>
            <span class="s0"># here, we need to re-restore the snapshot</span>
            <span class="s1">util</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                <span class="s5">&quot;Session's state has been changed on &quot;</span>
                <span class="s5">&quot;a non-active transaction - this state &quot;</span>
                <span class="s5">&quot;will be discarded.&quot;</span>
            <span class="s4">)</span>
            <span class="s1">boundary</span><span class="s4">.</span><span class="s1">_restore_snapshot</span><span class="s4">(</span><span class="s1">dirty_only</span><span class="s4">=</span><span class="s1">boundary</span><span class="s4">.</span><span class="s1">nested</span><span class="s4">)</span>

        <span class="s3">with </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_expect_state</span><span class="s4">(</span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">CLOSED</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">close</span><span class="s4">()</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parent </span><span class="s3">and </span><span class="s1">_capture_exception</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_parent</span><span class="s4">.</span><span class="s1">_rollback_exception </span><span class="s4">= </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">exc_info</span><span class="s4">()[</span><span class="s6">1</span><span class="s4">]</span>

        <span class="s3">if </span><span class="s1">rollback_err </span><span class="s3">and </span><span class="s1">rollback_err</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]:</span>
            <span class="s3">raise </span><span class="s1">rollback_err</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">with_traceback</span><span class="s4">(</span><span class="s1">rollback_err</span><span class="s4">[</span><span class="s6">2</span><span class="s4">])</span>

        <span class="s1">sess</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">after_soft_rollback</span><span class="s4">(</span><span class="s1">sess</span><span class="s4">, </span><span class="s1">self</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">_to_root </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parent</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_parent</span><span class="s4">.</span><span class="s1">rollback</span><span class="s4">(</span><span class="s1">_to_root</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_StateChange</span><span class="s4">.</span><span class="s1">declare_states</span><span class="s4">(</span>
        <span class="s1">_StateChangeStates</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">, </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">CLOSED</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">close</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">invalidate</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nested</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">_nested_transaction </span><span class="s4">= (</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_previous_nested_transaction</span>
            <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">_transaction </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parent</span>

        <span class="s3">for </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">transaction</span><span class="s4">, </span><span class="s1">should_commit</span><span class="s4">, </span><span class="s1">autoclose </span><span class="s3">in </span><span class="s1">set</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_connections</span><span class="s4">.</span><span class="s1">values</span><span class="s4">()</span>
        <span class="s4">):</span>
            <span class="s3">if </span><span class="s1">invalidate </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parent </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">connection</span><span class="s4">.</span><span class="s1">invalidate</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s1">should_commit </span><span class="s3">and </span><span class="s1">transaction</span><span class="s4">.</span><span class="s1">is_active</span><span class="s4">:</span>
                <span class="s1">transaction</span><span class="s4">.</span><span class="s1">close</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s1">autoclose </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parent </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">connection</span><span class="s4">.</span><span class="s1">close</span><span class="s4">()</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_state </span><span class="s4">= </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">CLOSED</span>
        <span class="s1">sess </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span>

        <span class="s0"># TODO: these two None sets were historically after the</span>
        <span class="s0"># event hook below, and in 2.0 I changed it this way for some reason,</span>
        <span class="s0"># and I remember there being a reason, but not what it was.</span>
        <span class="s0"># Why do we need to get rid of them at all?  test_memusage::CycleTest</span>
        <span class="s0"># passes with these commented out.</span>
        <span class="s0"># self.session = None  # type: ignore</span>
        <span class="s0"># self._connections = None  # type: ignore</span>

        <span class="s1">sess</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">after_transaction_end</span><span class="s4">(</span><span class="s1">sess</span><span class="s4">, </span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_get_subject</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Session</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span>

    <span class="s3">def </span><span class="s1">_transaction_is_active</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_state </span><span class="s3">is </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">ACTIVE</span>

    <span class="s3">def </span><span class="s1">_transaction_is_closed</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_state </span><span class="s3">is </span><span class="s1">SessionTransactionState</span><span class="s4">.</span><span class="s1">CLOSED</span>

    <span class="s3">def </span><span class="s1">_rollback_can_be_called</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_state </span><span class="s3">not in </span><span class="s4">(</span><span class="s1">COMMITTED</span><span class="s4">, </span><span class="s1">CLOSED</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">_SessionCloseState</span><span class="s4">(</span><span class="s1">Enum</span><span class="s4">):</span>
    <span class="s1">ACTIVE </span><span class="s4">= </span><span class="s6">1</span>
    <span class="s1">CLOSED </span><span class="s4">= </span><span class="s6">2</span>
    <span class="s1">CLOSE_IS_RESET </span><span class="s4">= </span><span class="s6">3</span>


<span class="s3">class </span><span class="s1">Session</span><span class="s4">(</span><span class="s1">_SessionClassMethods</span><span class="s4">, </span><span class="s1">EventTarget</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Manages persistence operations for ORM-mapped objects. 
 
    The :class:`_orm.Session` is **not safe for use in concurrent threads.**. 
    See :ref:`session_faq_threadsafe` for background. 
 
    The Session's usage paradigm is described at :doc:`/orm/session`. 
 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_is_asyncio </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s1">dispatch</span><span class="s4">: </span><span class="s1">dispatcher</span><span class="s4">[</span><span class="s1">Session</span><span class="s4">]</span>

    <span class="s1">identity_map</span><span class="s4">: </span><span class="s1">IdentityMap</span>
    <span class="s5">&quot;&quot;&quot;A mapping of object identities to objects themselves. 
 
    Iterating through ``Session.identity_map.values()`` provides 
    access to the full set of persistent objects (i.e., those 
    that have row identity) currently in the session. 
 
    .. seealso:: 
 
        :func:`.identity_key` - helper function to produce the keys used 
        in this dictionary. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_new</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s1">_deleted</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s1">bind</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Engine</span><span class="s4">, </span><span class="s1">Connection</span><span class="s4">]]</span>
    <span class="s1">__binds</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">_SessionBindKey</span><span class="s4">, </span><span class="s1">_SessionBind</span><span class="s4">]</span>
    <span class="s1">_flushing</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s1">_warn_on_events</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s1">_transaction</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">SessionTransaction</span><span class="s4">]</span>
    <span class="s1">_nested_transaction</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">SessionTransaction</span><span class="s4">]</span>
    <span class="s1">hash_key</span><span class="s4">: </span><span class="s1">int</span>
    <span class="s1">autoflush</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s1">expire_on_commit</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s1">enable_baked_queries</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s1">twophase</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s1">join_transaction_mode</span><span class="s4">: </span><span class="s1">JoinTransactionMode</span>
    <span class="s1">_query_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>
    <span class="s1">_close_state</span><span class="s4">: </span><span class="s1">_SessionCloseState</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">bind</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_SessionBind</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">autoflush</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">future</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">True</span><span class="s4">] = </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">expire_on_commit</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">autobegin</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">twophase</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">binds</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">_SessionBindKey</span><span class="s4">, </span><span class="s1">_SessionBind</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">enable_baked_queries</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">info</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_InfoType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">query_cls</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">autocommit</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">False</span><span class="s4">] = </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">join_transaction_mode</span><span class="s4">: </span><span class="s1">JoinTransactionMode </span><span class="s4">= </span><span class="s5">&quot;conditional_savepoint&quot;</span><span class="s4">,</span>
        <span class="s1">close_resets_only</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">, </span><span class="s1">_NoArg</span><span class="s4">] = </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s5">r&quot;&quot;&quot;Construct a new :class:`_orm.Session`. 
 
        See also the :class:`.sessionmaker` function which is used to 
        generate a :class:`.Session`-producing callable with a given 
        set of arguments. 
 
        :param autoflush: When ``True``, all query operations will issue a 
           :meth:`~.Session.flush` call to this ``Session`` before proceeding. 
           This is a convenience feature so that :meth:`~.Session.flush` need 
           not be called repeatedly in order for database queries to retrieve 
           results. 
 
           .. seealso:: 
 
               :ref:`session_flushing` - additional background on autoflush 
 
        :param autobegin: Automatically start transactions (i.e. equivalent to 
           invoking :meth:`_orm.Session.begin`) when database access is 
           requested by an operation.   Defaults to ``True``.    Set to 
           ``False`` to prevent a :class:`_orm.Session` from implicitly 
           beginning transactions after construction, as well as after any of 
           the :meth:`_orm.Session.rollback`, :meth:`_orm.Session.commit`, 
           or :meth:`_orm.Session.close` methods are called. 
 
           .. versionadded:: 2.0 
 
           .. seealso:: 
 
                :ref:`session_autobegin_disable` 
 
        :param bind: An optional :class:`_engine.Engine` or 
           :class:`_engine.Connection` to 
           which this ``Session`` should be bound. When specified, all SQL 
           operations performed by this session will execute via this 
           connectable. 
 
        :param binds: A dictionary which may specify any number of 
           :class:`_engine.Engine` or :class:`_engine.Connection` 
           objects as the source of 
           connectivity for SQL operations on a per-entity basis.   The keys 
           of the dictionary consist of any series of mapped classes, 
           arbitrary Python classes that are bases for mapped classes, 
           :class:`_schema.Table` objects and :class:`_orm.Mapper` objects. 
           The 
           values of the dictionary are then instances of 
           :class:`_engine.Engine` 
           or less commonly :class:`_engine.Connection` objects. 
           Operations which 
           proceed relative to a particular mapped class will consult this 
           dictionary for the closest matching entity in order to determine 
           which :class:`_engine.Engine` should be used for a particular SQL 
           operation.    The complete heuristics for resolution are 
           described at :meth:`.Session.get_bind`.  Usage looks like:: 
 
            Session = sessionmaker(binds={ 
                SomeMappedClass: create_engine('postgresql+psycopg2://engine1'), 
                SomeDeclarativeBase: create_engine('postgresql+psycopg2://engine2'), 
                some_mapper: create_engine('postgresql+psycopg2://engine3'), 
                some_table: create_engine('postgresql+psycopg2://engine4'), 
                }) 
 
           .. seealso:: 
 
                :ref:`session_partitioning` 
 
                :meth:`.Session.bind_mapper` 
 
                :meth:`.Session.bind_table` 
 
                :meth:`.Session.get_bind` 
 
 
        :param \class_: Specify an alternate class other than 
           ``sqlalchemy.orm.session.Session`` which should be used by the 
           returned class. This is the only argument that is local to the 
           :class:`.sessionmaker` function, and is not sent directly to the 
           constructor for ``Session``. 
 
        :param enable_baked_queries: legacy; defaults to ``True``. 
           A parameter consumed 
           by the :mod:`sqlalchemy.ext.baked` extension to determine if 
           &quot;baked queries&quot; should be cached, as is the normal operation 
           of this extension.  When set to ``False``, caching as used by 
           this particular extension is disabled. 
 
           .. versionchanged:: 1.4 The ``sqlalchemy.ext.baked`` extension is 
              legacy and is not used by any of SQLAlchemy's internals. This 
              flag therefore only affects applications that are making explicit 
              use of this extension within their own code. 
 
        :param expire_on_commit:  Defaults to ``True``. When ``True``, all 
           instances will be fully expired after each :meth:`~.commit`, 
           so that all attribute/object access subsequent to a completed 
           transaction will load from the most recent database state. 
 
            .. seealso:: 
 
                :ref:`session_committing` 
 
        :param future: Deprecated; this flag is always True. 
 
          .. seealso:: 
 
            :ref:`migration_20_toplevel` 
 
        :param info: optional dictionary of arbitrary data to be associated 
           with this :class:`.Session`.  Is available via the 
           :attr:`.Session.info` attribute.  Note the dictionary is copied at 
           construction time so that modifications to the per- 
           :class:`.Session` dictionary will be local to that 
           :class:`.Session`. 
 
        :param query_cls:  Class which should be used to create new Query 
          objects, as returned by the :meth:`~.Session.query` method. 
          Defaults to :class:`_query.Query`. 
 
        :param twophase:  When ``True``, all transactions will be started as 
            a &quot;two phase&quot; transaction, i.e. using the &quot;two phase&quot; semantics 
            of the database in use along with an XID.  During a 
            :meth:`~.commit`, after :meth:`~.flush` has been issued for all 
            attached databases, the :meth:`~.TwoPhaseTransaction.prepare` 
            method on each database's :class:`.TwoPhaseTransaction` will be 
            called. This allows each database to roll back the entire 
            transaction, before each transaction is committed. 
 
        :param autocommit: the &quot;autocommit&quot; keyword is present for backwards 
            compatibility but must remain at its default value of ``False``. 
 
        :param join_transaction_mode: Describes the transactional behavior to 
          take when a given bind is a :class:`_engine.Connection` that 
          has already begun a transaction outside the scope of this 
          :class:`_orm.Session`; in other words the 
          :meth:`_engine.Connection.in_transaction()` method returns True. 
 
          The following behaviors only take effect when the :class:`_orm.Session` 
          **actually makes use of the connection given**; that is, a method 
          such as :meth:`_orm.Session.execute`, :meth:`_orm.Session.connection`, 
          etc. are actually invoked: 
 
          * ``&quot;conditional_savepoint&quot;`` - this is the default.  if the given 
            :class:`_engine.Connection` is begun within a transaction but 
            does not have a SAVEPOINT, then ``&quot;rollback_only&quot;`` is used. 
            If the :class:`_engine.Connection` is additionally within 
            a SAVEPOINT, in other words 
            :meth:`_engine.Connection.in_nested_transaction()` method returns 
            True, then ``&quot;create_savepoint&quot;`` is used. 
 
            ``&quot;conditional_savepoint&quot;`` behavior attempts to make use of 
            savepoints in order to keep the state of the existing transaction 
            unchanged, but only if there is already a savepoint in progress; 
            otherwise, it is not assumed that the backend in use has adequate 
            support for SAVEPOINT, as availability of this feature varies. 
            ``&quot;conditional_savepoint&quot;`` also seeks to establish approximate 
            backwards compatibility with previous :class:`_orm.Session` 
            behavior, for applications that are not setting a specific mode. It 
            is recommended that one of the explicit settings be used. 
 
          * ``&quot;create_savepoint&quot;`` - the :class:`_orm.Session` will use 
            :meth:`_engine.Connection.begin_nested()` in all cases to create 
            its own transaction.  This transaction by its nature rides 
            &quot;on top&quot; of any existing transaction that's opened on the given 
            :class:`_engine.Connection`; if the underlying database and 
            the driver in use has full, non-broken support for SAVEPOINT, the 
            external transaction will remain unaffected throughout the 
            lifespan of the :class:`_orm.Session`. 
 
            The ``&quot;create_savepoint&quot;`` mode is the most useful for integrating 
            a :class:`_orm.Session` into a test suite where an externally 
            initiated transaction should remain unaffected; however, it relies 
            on proper SAVEPOINT support from the underlying driver and 
            database. 
 
            .. tip:: When using SQLite, the SQLite driver included through 
               Python 3.11 does not handle SAVEPOINTs correctly in all cases 
               without workarounds. See the sections 
               :ref:`pysqlite_serializable` and :ref:`aiosqlite_serializable` 
               for details on current workarounds. 
 
          * ``&quot;control_fully&quot;`` - the :class:`_orm.Session` will take 
            control of the given transaction as its own; 
            :meth:`_orm.Session.commit` will call ``.commit()`` on the 
            transaction, :meth:`_orm.Session.rollback` will call 
            ``.rollback()`` on the transaction, :meth:`_orm.Session.close` will 
            call ``.rollback`` on the transaction. 
 
            .. tip:: This mode of use is equivalent to how SQLAlchemy 1.4 would 
               handle a :class:`_engine.Connection` given with an existing 
               SAVEPOINT (i.e. :meth:`_engine.Connection.begin_nested`); the 
               :class:`_orm.Session` would take full control of the existing 
               SAVEPOINT. 
 
          * ``&quot;rollback_only&quot;`` - the :class:`_orm.Session` will take control 
            of the given transaction for ``.rollback()`` calls only; 
            ``.commit()`` calls will not be propagated to the given 
            transaction.  ``.close()`` calls will have no effect on the 
            given transaction. 
 
            .. tip:: This mode of use is equivalent to how SQLAlchemy 1.4 would 
               handle a :class:`_engine.Connection` given with an existing 
               regular database transaction (i.e. 
               :meth:`_engine.Connection.begin`); the :class:`_orm.Session` 
               would propagate :meth:`_orm.Session.rollback` calls to the 
               underlying transaction, but not :meth:`_orm.Session.commit` or 
               :meth:`_orm.Session.close` calls. 
 
          .. versionadded:: 2.0.0rc1 
 
        :param close_resets_only: Defaults to ``True``. Determines if 
          the session should reset itself after calling ``.close()`` 
          or should pass in a no longer usable state, disabling re-use. 
 
          .. versionadded:: 2.0.22 added flag ``close_resets_only``. 
            A future SQLAlchemy version may change the default value of 
            this flag to ``False``. 
 
          .. seealso:: 
 
            :ref:`session_closing` - Detail on the semantics of 
            :meth:`_orm.Session.close` and :meth:`_orm.Session.reset`. 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa</span>

        <span class="s0"># considering allowing the &quot;autocommit&quot; keyword to still be accepted</span>
        <span class="s0"># as long as it's False, so that external test suites, oslo.db etc</span>
        <span class="s0"># continue to function as the argument appears to be passed in lots</span>
        <span class="s0"># of cases including in our own test suite</span>
        <span class="s3">if </span><span class="s1">autocommit</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                <span class="s5">&quot;autocommit=True is no longer supported&quot;</span>
            <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map </span><span class="s4">= </span><span class="s1">identity</span><span class="s4">.</span><span class="s1">WeakInstanceDict</span><span class="s4">()</span>

        <span class="s3">if not </span><span class="s1">future</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                <span class="s5">&quot;The 'future' parameter passed to &quot;</span>
                <span class="s5">&quot;Session() may only be set to True.&quot;</span>
            <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_new </span><span class="s4">= {}  </span><span class="s0"># InstanceState-&gt;object, strong refs object</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted </span><span class="s4">= {}  </span><span class="s0"># same</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">bind </span><span class="s4">= </span><span class="s1">bind</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">__binds </span><span class="s4">= {}</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_flushing </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_warn_on_events </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_nested_transaction </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">hash_key </span><span class="s4">= </span><span class="s1">_new_sessionid</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">autobegin </span><span class="s4">= </span><span class="s1">autobegin</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">autoflush </span><span class="s4">= </span><span class="s1">autoflush</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">expire_on_commit </span><span class="s4">= </span><span class="s1">expire_on_commit</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">enable_baked_queries </span><span class="s4">= </span><span class="s1">enable_baked_queries</span>

        <span class="s0"># the idea is that at some point NO_ARG will warn that in the future</span>
        <span class="s0"># the default will switch to close_resets_only=False.</span>
        <span class="s3">if </span><span class="s1">close_resets_only </span><span class="s3">or </span><span class="s1">close_resets_only </span><span class="s3">is </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_close_state </span><span class="s4">= </span><span class="s1">_SessionCloseState</span><span class="s4">.</span><span class="s1">CLOSE_IS_RESET</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_close_state </span><span class="s4">= </span><span class="s1">_SessionCloseState</span><span class="s4">.</span><span class="s1">ACTIVE</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">join_transaction_mode</span>
            <span class="s3">and </span><span class="s1">join_transaction_mode</span>
            <span class="s3">not in </span><span class="s1">JoinTransactionMode</span><span class="s4">.</span><span class="s1">__args__  </span><span class="s0"># type: ignore</span>
        <span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                <span class="s5">f&quot;invalid selection for join_transaction_mode: &quot;</span>
                <span class="s5">f'&quot;</span><span class="s3">{</span><span class="s1">join_transaction_mode</span><span class="s3">}</span><span class="s5">&quot;'</span>
            <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">join_transaction_mode </span><span class="s4">= </span><span class="s1">join_transaction_mode</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">twophase </span><span class="s4">= </span><span class="s1">twophase</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_query_cls </span><span class="s4">= </span><span class="s1">query_cls </span><span class="s3">if </span><span class="s1">query_cls </span><span class="s3">else </span><span class="s1">query</span><span class="s4">.</span><span class="s1">Query</span>
        <span class="s3">if </span><span class="s1">info</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">info</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">info</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">binds </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">bind </span><span class="s3">in </span><span class="s1">binds</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_add_bind</span><span class="s4">(</span><span class="s1">key</span><span class="s4">, </span><span class="s1">bind</span><span class="s4">)</span>

        <span class="s1">_sessions</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">hash_key</span><span class="s4">] = </span><span class="s1">self</span>

    <span class="s0"># used by sqlalchemy.engine.util.TransactionalContext</span>
    <span class="s1">_trans_context_manager</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">TransactionalContext</span><span class="s4">] = </span><span class="s3">None</span>

    <span class="s1">connection_callable</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_ConnectionCallableProto</span><span class="s4">] = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__enter__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">_S</span><span class="s4">) </span><span class="s1">-&gt; _S</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__exit__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">traceback</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">close</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">contextlib</span><span class="s4">.</span><span class="s1">contextmanager</span>
    <span class="s3">def </span><span class="s1">_maker_context_manager</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">_S</span><span class="s4">) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">_S</span><span class="s4">]:</span>
        <span class="s3">with </span><span class="s1">self</span><span class="s4">:</span>
            <span class="s3">with </span><span class="s1">self</span><span class="s4">.</span><span class="s1">begin</span><span class="s4">():</span>
                <span class="s3">yield </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">in_transaction</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return True if this :class:`_orm.Session` has begun a transaction. 
 
        .. versionadded:: 1.4 
 
        .. seealso:: 
 
            :attr:`_orm.Session.is_active` 
 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction </span><span class="s3">is not None</span>

    <span class="s3">def </span><span class="s1">in_nested_transaction</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return True if this :class:`_orm.Session` has begun a nested 
        transaction, e.g. SAVEPOINT. 
 
        .. versionadded:: 1.4 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_nested_transaction </span><span class="s3">is not None</span>

    <span class="s3">def </span><span class="s1">get_transaction</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">SessionTransaction</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the current root transaction in progress, if any. 
 
        .. versionadded:: 1.4 
 
        &quot;&quot;&quot;</span>
        <span class="s1">trans </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction</span>
        <span class="s3">while </span><span class="s1">trans </span><span class="s3">is not None and </span><span class="s1">trans</span><span class="s4">.</span><span class="s1">_parent </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">trans </span><span class="s4">= </span><span class="s1">trans</span><span class="s4">.</span><span class="s1">_parent</span>
        <span class="s3">return </span><span class="s1">trans</span>

    <span class="s3">def </span><span class="s1">get_nested_transaction</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">SessionTransaction</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the current nested transaction in progress, if any. 
 
        .. versionadded:: 1.4 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_nested_transaction</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">info</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _InfoType</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;A user-modifiable dictionary. 
 
        The initial value of this dictionary can be populated using the 
        ``info`` argument to the :class:`.Session` constructor or 
        :class:`.sessionmaker` constructor or factory methods.  The dictionary 
        here is always local to this :class:`.Session` and can be modified 
        independently of all other :class:`.Session` objects. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s4">{}</span>

    <span class="s3">def </span><span class="s1">_autobegin_t</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">begin</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">) </span><span class="s1">-&gt; SessionTransaction</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if not </span><span class="s1">begin </span><span class="s3">and not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">autobegin</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                    <span class="s5">&quot;Autobegin is disabled on this Session; please call &quot;</span>
                    <span class="s5">&quot;session.begin() to start a new transaction&quot;</span>
                <span class="s4">)</span>
            <span class="s1">trans </span><span class="s4">= </span><span class="s1">SessionTransaction</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">,</span>
                <span class="s4">(</span>
                    <span class="s1">SessionTransactionOrigin</span><span class="s4">.</span><span class="s1">BEGIN</span>
                    <span class="s3">if </span><span class="s1">begin</span>
                    <span class="s3">else </span><span class="s1">SessionTransactionOrigin</span><span class="s4">.</span><span class="s1">AUTOBEGIN</span>
                <span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction </span><span class="s3">is </span><span class="s1">trans</span>
            <span class="s3">return </span><span class="s1">trans</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction</span>

    <span class="s3">def </span><span class="s1">begin</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">nested</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">) </span><span class="s1">-&gt; SessionTransaction</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Begin a transaction, or nested transaction, 
        on this :class:`.Session`, if one is not already begun. 
 
        The :class:`_orm.Session` object features **autobegin** behavior, 
        so that normally it is not necessary to call the 
        :meth:`_orm.Session.begin` 
        method explicitly. However, it may be used in order to control 
        the scope of when the transactional state is begun. 
 
        When used to begin the outermost transaction, an error is raised 
        if this :class:`.Session` is already inside of a transaction. 
 
        :param nested: if True, begins a SAVEPOINT transaction and is 
         equivalent to calling :meth:`~.Session.begin_nested`. For 
         documentation on SAVEPOINT transactions, please see 
         :ref:`session_begin_nested`. 
 
        :return: the :class:`.SessionTransaction` object.  Note that 
         :class:`.SessionTransaction` 
         acts as a Python context manager, allowing :meth:`.Session.begin` 
         to be used in a &quot;with&quot; block.  See :ref:`session_explicit_begin` for 
         an example. 
 
        .. seealso:: 
 
            :ref:`session_autobegin` 
 
            :ref:`unitofwork_transaction` 
 
            :meth:`.Session.begin_nested` 
 
 
        &quot;&quot;&quot;</span>

        <span class="s1">trans </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction</span>
        <span class="s3">if </span><span class="s1">trans </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">trans </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_autobegin_t</span><span class="s4">(</span><span class="s1">begin</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

            <span class="s3">if not </span><span class="s1">nested</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">trans</span>

        <span class="s3">assert </span><span class="s1">trans </span><span class="s3">is not None</span>

        <span class="s3">if </span><span class="s1">nested</span><span class="s4">:</span>
            <span class="s1">trans </span><span class="s4">= </span><span class="s1">trans</span><span class="s4">.</span><span class="s1">_begin</span><span class="s4">(</span><span class="s1">nested</span><span class="s4">=</span><span class="s1">nested</span><span class="s4">)</span>
            <span class="s3">assert </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction </span><span class="s3">is </span><span class="s1">trans</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_nested_transaction </span><span class="s4">= </span><span class="s1">trans</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;A transaction is already begun on this Session.&quot;</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">trans  </span><span class="s0"># needed for __enter__/__exit__ hook</span>

    <span class="s3">def </span><span class="s1">begin_nested</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; SessionTransaction</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Begin a &quot;nested&quot; transaction on this Session, e.g. SAVEPOINT. 
 
        The target database(s) and associated drivers must support SQL 
        SAVEPOINT for this method to function correctly. 
 
        For documentation on SAVEPOINT 
        transactions, please see :ref:`session_begin_nested`. 
 
        :return: the :class:`.SessionTransaction` object.  Note that 
         :class:`.SessionTransaction` acts as a context manager, allowing 
         :meth:`.Session.begin_nested` to be used in a &quot;with&quot; block. 
         See :ref:`session_begin_nested` for a usage example. 
 
        .. seealso:: 
 
            :ref:`session_begin_nested` 
 
            :ref:`pysqlite_serializable` - special workarounds required 
            with the SQLite driver in order for SAVEPOINT to work 
            correctly. For asyncio use cases, see the section 
            :ref:`aiosqlite_serializable`. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">begin</span><span class="s4">(</span><span class="s1">nested</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">rollback</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Rollback the current transaction in progress. 
 
        If no transaction is in progress, this method is a pass-through. 
 
        The method always rolls back 
        the topmost database transaction, discarding any nested 
        transactions that may be in progress. 
 
        .. seealso:: 
 
            :ref:`session_rollback` 
 
            :ref:`unitofwork_transaction` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">pass</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction</span><span class="s4">.</span><span class="s1">rollback</span><span class="s4">(</span><span class="s1">_to_root</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">commit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Flush pending changes and commit the current transaction. 
 
        When the COMMIT operation is complete, all objects are fully 
        :term:`expired`, erasing their internal contents, which will be 
        automatically re-loaded when the objects are next accessed. In the 
        interim, these objects are in an expired state and will not function if 
        they are :term:`detached` from the :class:`.Session`. Additionally, 
        this re-load operation is not supported when using asyncio-oriented 
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used 
        to disable this behavior. 
 
        When there is no transaction in place for the :class:`.Session`, 
        indicating that no operations were invoked on this :class:`.Session` 
        since the previous call to :meth:`.Session.commit`, the method will 
        begin and commit an internal-only &quot;logical&quot; transaction, that does not 
        normally affect the database unless pending flush changes were 
        detected, but will still invoke event handlers and object expiration 
        rules. 
 
        The outermost database transaction is committed unconditionally, 
        automatically releasing any SAVEPOINTs in effect. 
 
        .. seealso:: 
 
            :ref:`session_committing` 
 
            :ref:`unitofwork_transaction` 
 
            :ref:`asyncio_orm_avoid_lazyloads` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">trans </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction</span>
        <span class="s3">if </span><span class="s1">trans </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">trans </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_autobegin_t</span><span class="s4">()</span>

        <span class="s1">trans</span><span class="s4">.</span><span class="s1">commit</span><span class="s4">(</span><span class="s1">_to_root</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">prepare</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Prepare the current transaction in progress for two phase commit. 
 
        If no transaction is in progress, this method raises an 
        :exc:`~sqlalchemy.exc.InvalidRequestError`. 
 
        Only root transactions of two phase sessions can be prepared. If the 
        current transaction is not such, an 
        :exc:`~sqlalchemy.exc.InvalidRequestError` is raised. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">trans </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction</span>
        <span class="s3">if </span><span class="s1">trans </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">trans </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_autobegin_t</span><span class="s4">()</span>

        <span class="s1">trans</span><span class="s4">.</span><span class="s1">prepare</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">connection</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">CoreExecuteOptionsParameter</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Connection</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a :class:`_engine.Connection` object corresponding to this 
        :class:`.Session` object's transactional state. 
 
        Either the :class:`_engine.Connection` corresponding to the current 
        transaction is returned, or if no transaction is in progress, a new 
        one is begun and the :class:`_engine.Connection` 
        returned (note that no 
        transactional state is established with the DBAPI until the first 
        SQL statement is emitted). 
 
        Ambiguity in multi-bind or unbound :class:`.Session` objects can be 
        resolved through any of the optional keyword arguments.   This 
        ultimately makes usage of the :meth:`.get_bind` method for resolution. 
 
        :param bind_arguments: dictionary of bind arguments.  May include 
         &quot;mapper&quot;, &quot;bind&quot;, &quot;clause&quot;, other custom arguments that are passed 
         to :meth:`.Session.get_bind`. 
 
        :param execution_options: a dictionary of execution options that will 
         be passed to :meth:`_engine.Connection.execution_options`, **when the 
         connection is first procured only**.   If the connection is already 
         present within the :class:`.Session`, a warning is emitted and 
         the arguments are ignored. 
 
         .. seealso:: 
 
            :ref:`session_transaction_isolation` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">bind_arguments</span><span class="s4">:</span>
            <span class="s1">bind </span><span class="s4">= </span><span class="s1">bind_arguments</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;bind&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">bind </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">bind </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_bind</span><span class="s4">(**</span><span class="s1">bind_arguments</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">bind </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_bind</span><span class="s4">()</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_connection_for_bind</span><span class="s4">(</span>
            <span class="s1">bind</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">=</span><span class="s1">execution_options</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_connection_for_bind</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">engine</span><span class="s4">: </span><span class="s1">_SessionBind</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">CoreExecuteOptionsParameter</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Connection</span><span class="s4">:</span>
        <span class="s1">TransactionalContext</span><span class="s4">.</span><span class="s1">_trans_ctx_check</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

        <span class="s1">trans </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction</span>
        <span class="s3">if </span><span class="s1">trans </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">trans </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_autobegin_t</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">trans</span><span class="s4">.</span><span class="s1">_connection_for_bind</span><span class="s4">(</span><span class="s1">engine</span><span class="s4">, </span><span class="s1">execution_options</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">_execute_internal</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">Executable</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_CoreSingleExecuteParams</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_parent_execute_state</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_add_event</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_scalar_result</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">True</span><span class="s4">] = ...,</span>
    <span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">_execute_internal</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">Executable</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_parent_execute_state</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_add_event</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_scalar_result</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= ...,</span>
    <span class="s4">) </span><span class="s1">-&gt; Result</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">_execute_internal</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">Executable</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_parent_execute_state</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_add_event</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_scalar_result</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s1">statement </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">StatementRole</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">bind_arguments</span><span class="s4">:</span>
            <span class="s1">bind_arguments </span><span class="s4">= {}</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">bind_arguments </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">bind_arguments</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">statement</span><span class="s4">.</span><span class="s1">_propagate_attrs</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;compile_state_plugin&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
            <span class="s4">== </span><span class="s5">&quot;orm&quot;</span>
        <span class="s4">):</span>
            <span class="s1">compile_state_cls </span><span class="s4">= </span><span class="s1">CompileState</span><span class="s4">.</span><span class="s1">_get_plugin_class_for_plugin</span><span class="s4">(</span>
                <span class="s1">statement</span><span class="s4">, </span><span class="s5">&quot;orm&quot;</span>
            <span class="s4">)</span>
            <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
                <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span>
                    <span class="s1">compile_state_cls</span><span class="s4">, </span><span class="s1">context</span><span class="s4">.</span><span class="s1">AbstractORMCompileState</span>
                <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">compile_state_cls </span><span class="s4">= </span><span class="s3">None</span>
            <span class="s1">bind_arguments</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s5">&quot;clause&quot;</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">)</span>

        <span class="s1">execution_options </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">coerce_to_immutabledict</span><span class="s4">(</span><span class="s1">execution_options</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">_parent_execute_state</span><span class="s4">:</span>
            <span class="s1">events_todo </span><span class="s4">= </span><span class="s1">_parent_execute_state</span><span class="s4">.</span><span class="s1">_remaining_events</span><span class="s4">()</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">events_todo </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">do_orm_execute</span>
            <span class="s3">if </span><span class="s1">_add_event</span><span class="s4">:</span>
                <span class="s1">events_todo </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">events_todo</span><span class="s4">) + [</span><span class="s1">_add_event</span><span class="s4">]</span>

        <span class="s3">if </span><span class="s1">events_todo</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">compile_state_cls </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s0"># for event handlers, do the orm_pre_session_exec</span>
                <span class="s0"># pass ahead of the event handlers, so that things like</span>
                <span class="s0"># .load_options, .update_delete_options etc. are populated.</span>
                <span class="s0"># is_pre_event=True allows the hook to hold off on things</span>
                <span class="s0"># it doesn't want to do twice, including autoflush as well</span>
                <span class="s0"># as &quot;pre fetch&quot; for DML, etc.</span>
                <span class="s4">(</span>
                    <span class="s1">statement</span><span class="s4">,</span>
                    <span class="s1">execution_options</span><span class="s4">,</span>
                <span class="s4">) = </span><span class="s1">compile_state_cls</span><span class="s4">.</span><span class="s1">orm_pre_session_exec</span><span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">,</span>
                    <span class="s1">statement</span><span class="s4">,</span>
                    <span class="s1">params</span><span class="s4">,</span>
                    <span class="s1">execution_options</span><span class="s4">,</span>
                    <span class="s1">bind_arguments</span><span class="s4">,</span>
                    <span class="s3">True</span><span class="s4">,</span>
                <span class="s4">)</span>

            <span class="s1">orm_exec_state </span><span class="s4">= </span><span class="s1">ORMExecuteState</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">,</span>
                <span class="s1">statement</span><span class="s4">,</span>
                <span class="s1">params</span><span class="s4">,</span>
                <span class="s1">execution_options</span><span class="s4">,</span>
                <span class="s1">bind_arguments</span><span class="s4">,</span>
                <span class="s1">compile_state_cls</span><span class="s4">,</span>
                <span class="s1">events_todo</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">events_todo</span><span class="s4">):</span>
                <span class="s1">orm_exec_state</span><span class="s4">.</span><span class="s1">_starting_event_idx </span><span class="s4">= </span><span class="s1">idx</span>
                <span class="s1">fn_result</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Result</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s1">fn</span><span class="s4">(</span><span class="s1">orm_exec_state</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">fn_result</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">_scalar_result</span><span class="s4">:</span>
                        <span class="s3">return </span><span class="s1">fn_result</span><span class="s4">.</span><span class="s1">scalar</span><span class="s4">()</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s3">return </span><span class="s1">fn_result</span>

            <span class="s1">statement </span><span class="s4">= </span><span class="s1">orm_exec_state</span><span class="s4">.</span><span class="s1">statement</span>
            <span class="s1">execution_options </span><span class="s4">= </span><span class="s1">orm_exec_state</span><span class="s4">.</span><span class="s1">local_execution_options</span>

        <span class="s3">if </span><span class="s1">compile_state_cls </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s0"># now run orm_pre_session_exec() &quot;for real&quot;.   if there were</span>
            <span class="s0"># event hooks, this will re-run the steps that interpret</span>
            <span class="s0"># new execution_options into load_options / update_delete_options,</span>
            <span class="s0"># which we assume the event hook might have updated.</span>
            <span class="s0"># autoflush will also be invoked in this step if enabled.</span>
            <span class="s4">(</span>
                <span class="s1">statement</span><span class="s4">,</span>
                <span class="s1">execution_options</span><span class="s4">,</span>
            <span class="s4">) = </span><span class="s1">compile_state_cls</span><span class="s4">.</span><span class="s1">orm_pre_session_exec</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">,</span>
                <span class="s1">statement</span><span class="s4">,</span>
                <span class="s1">params</span><span class="s4">,</span>
                <span class="s1">execution_options</span><span class="s4">,</span>
                <span class="s1">bind_arguments</span><span class="s4">,</span>
                <span class="s3">False</span><span class="s4">,</span>
            <span class="s4">)</span>

        <span class="s1">bind </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_bind</span><span class="s4">(**</span><span class="s1">bind_arguments</span><span class="s4">)</span>

        <span class="s1">conn </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_connection_for_bind</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">_scalar_result </span><span class="s3">and not </span><span class="s1">compile_state_cls</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
                <span class="s1">params </span><span class="s4">= </span><span class="s1">cast</span><span class="s4">(</span><span class="s1">_CoreSingleExecuteParams</span><span class="s4">, </span><span class="s1">params</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">conn</span><span class="s4">.</span><span class="s1">scalar</span><span class="s4">(</span>
                <span class="s1">statement</span><span class="s4">, </span><span class="s1">params </span><span class="s3">or </span><span class="s4">{}, </span><span class="s1">execution_options</span><span class="s4">=</span><span class="s1">execution_options</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">compile_state_cls</span><span class="s4">:</span>
            <span class="s1">result</span><span class="s4">: </span><span class="s1">Result</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s1">compile_state_cls</span><span class="s4">.</span><span class="s1">orm_execute_statement</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">,</span>
                <span class="s1">statement</span><span class="s4">,</span>
                <span class="s1">params </span><span class="s3">or </span><span class="s4">{},</span>
                <span class="s1">execution_options</span><span class="s4">,</span>
                <span class="s1">bind_arguments</span><span class="s4">,</span>
                <span class="s1">conn</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">result </span><span class="s4">= </span><span class="s1">conn</span><span class="s4">.</span><span class="s1">execute</span><span class="s4">(</span>
                <span class="s1">statement</span><span class="s4">, </span><span class="s1">params </span><span class="s3">or </span><span class="s4">{}, </span><span class="s1">execution_options</span><span class="s4">=</span><span class="s1">execution_options</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">_scalar_result</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">result</span><span class="s4">.</span><span class="s1">scalar</span><span class="s4">()</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">result</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">execute</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">TypedReturnsRows</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
        <span class="s1">params</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_parent_execute_state</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_add_event</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Result</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">execute</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">UpdateBase</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_parent_execute_state</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_add_event</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; CursorResult</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">execute</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">Executable</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_parent_execute_state</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_add_event</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Result</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">execute</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">Executable</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_parent_execute_state</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_add_event</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Result</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">r&quot;&quot;&quot;Execute a SQL expression construct. 
 
        Returns a :class:`_engine.Result` object representing 
        results of the statement execution. 
 
        E.g.:: 
 
            from sqlalchemy import select 
            result = session.execute( 
                select(User).where(User.id == 5) 
            ) 
 
        The API contract of :meth:`_orm.Session.execute` is similar to that 
        of :meth:`_engine.Connection.execute`, the :term:`2.0 style` version 
        of :class:`_engine.Connection`. 
 
        .. versionchanged:: 1.4 the :meth:`_orm.Session.execute` method is 
           now the primary point of ORM statement execution when using 
           :term:`2.0 style` ORM usage. 
 
        :param statement: 
            An executable statement (i.e. an :class:`.Executable` expression 
            such as :func:`_expression.select`). 
 
        :param params: 
            Optional dictionary, or list of dictionaries, containing 
            bound parameter values.   If a single dictionary, single-row 
            execution occurs; if a list of dictionaries, an 
            &quot;executemany&quot; will be invoked.  The keys in each dictionary 
            must correspond to parameter names present in the statement. 
 
        :param execution_options: optional dictionary of execution options, 
         which will be associated with the statement execution.  This 
         dictionary can provide a subset of the options that are accepted 
         by :meth:`_engine.Connection.execution_options`, and may also 
         provide additional options understood only in an ORM context. 
 
         .. seealso:: 
 
            :ref:`orm_queryguide_execution_options` - ORM-specific execution 
            options 
 
        :param bind_arguments: dictionary of additional arguments to determine 
         the bind.  May include &quot;mapper&quot;, &quot;bind&quot;, or other custom arguments. 
         Contents of this dictionary are passed to the 
         :meth:`.Session.get_bind` method. 
 
        :return: a :class:`_engine.Result` object. 
 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_execute_internal</span><span class="s4">(</span>
            <span class="s1">statement</span><span class="s4">,</span>
            <span class="s1">params</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">=</span><span class="s1">execution_options</span><span class="s4">,</span>
            <span class="s1">bind_arguments</span><span class="s4">=</span><span class="s1">bind_arguments</span><span class="s4">,</span>
            <span class="s1">_parent_execute_state</span><span class="s4">=</span><span class="s1">_parent_execute_state</span><span class="s4">,</span>
            <span class="s1">_add_event</span><span class="s4">=</span><span class="s1">_add_event</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">scalar</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">TypedReturnsRows</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]],</span>
        <span class="s1">params</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_CoreSingleExecuteParams</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">scalar</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">Executable</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_CoreSingleExecuteParams</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">: ...</span>

    <span class="s3">def </span><span class="s1">scalar</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">Executable</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_CoreSingleExecuteParams</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Execute a statement and return a scalar result. 
 
        Usage and parameters are the same as that of 
        :meth:`_orm.Session.execute`; the return result is a scalar Python 
        value. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_execute_internal</span><span class="s4">(</span>
            <span class="s1">statement</span><span class="s4">,</span>
            <span class="s1">params</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">=</span><span class="s1">execution_options</span><span class="s4">,</span>
            <span class="s1">bind_arguments</span><span class="s4">=</span><span class="s1">bind_arguments</span><span class="s4">,</span>
            <span class="s1">_scalar_result</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s4">**</span><span class="s1">kw</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">scalars</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">TypedReturnsRows</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]],</span>
        <span class="s1">params</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ScalarResult</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">scalars</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">Executable</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ScalarResult</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">scalars</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">statement</span><span class="s4">: </span><span class="s1">Executable</span><span class="s4">,</span>
        <span class="s1">params</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ScalarResult</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Execute a statement and return the results as scalars. 
 
        Usage and parameters are the same as that of 
        :meth:`_orm.Session.execute`; the return result is a 
        :class:`_result.ScalarResult` filtering object which 
        will return single elements rather than :class:`_row.Row` objects. 
 
        :return:  a :class:`_result.ScalarResult` object 
 
        .. versionadded:: 1.4.24 Added :meth:`_orm.Session.scalars` 
 
        .. versionadded:: 1.4.26 Added :meth:`_orm.scoped_session.scalars` 
 
        .. seealso:: 
 
            :ref:`orm_queryguide_select_orm_entities` - contrasts the behavior 
            of :meth:`_orm.Session.execute` to :meth:`_orm.Session.scalars` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_execute_internal</span><span class="s4">(</span>
            <span class="s1">statement</span><span class="s4">,</span>
            <span class="s1">params</span><span class="s4">=</span><span class="s1">params</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">=</span><span class="s1">execution_options</span><span class="s4">,</span>
            <span class="s1">bind_arguments</span><span class="s4">=</span><span class="s1">bind_arguments</span><span class="s4">,</span>
            <span class="s1">_scalar_result</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,  </span><span class="s0"># mypy appreciates this</span>
            <span class="s4">**</span><span class="s1">kw</span><span class="s4">,</span>
        <span class="s4">).</span><span class="s1">scalars</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">close</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Close out the transactional resources and ORM objects used by this 
        :class:`_orm.Session`. 
 
        This expunges all ORM objects associated with this 
        :class:`_orm.Session`, ends any transaction in progress and 
        :term:`releases` any :class:`_engine.Connection` objects which this 
        :class:`_orm.Session` itself has checked out from associated 
        :class:`_engine.Engine` objects. The operation then leaves the 
        :class:`_orm.Session` in a state which it may be used again. 
 
        .. tip:: 
 
            In the default running mode the :meth:`_orm.Session.close` 
            method **does not prevent the Session from being used again**. 
            The :class:`_orm.Session` itself does not actually have a 
            distinct &quot;closed&quot; state; it merely means 
            the :class:`_orm.Session` will release all database connections 
            and ORM objects. 
 
            Setting the parameter :paramref:`_orm.Session.close_resets_only` 
            to ``False`` will instead make the ``close`` final, meaning that 
            any further action on the session will be forbidden. 
 
        .. versionchanged:: 1.4  The :meth:`.Session.close` method does not 
           immediately create a new :class:`.SessionTransaction` object; 
           instead, the new :class:`.SessionTransaction` is created only if 
           the :class:`.Session` is used again for a database operation. 
 
        .. seealso:: 
 
            :ref:`session_closing` - detail on the semantics of 
            :meth:`_orm.Session.close` and :meth:`_orm.Session.reset`. 
 
            :meth:`_orm.Session.reset` - a similar method that behaves like 
            ``close()`` with  the parameter 
            :paramref:`_orm.Session.close_resets_only` set to ``True``. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_close_impl</span><span class="s4">(</span><span class="s1">invalidate</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">reset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Close out the transactional resources and ORM objects used by this 
        :class:`_orm.Session`, resetting the session to its initial state. 
 
        This method provides for same &quot;reset-only&quot; behavior that the 
        :meth:`_orm.Session.close` method has provided historically, where the 
        state of the :class:`_orm.Session` is reset as though the object were 
        brand new, and ready to be used again. 
        This method may then be useful for :class:`_orm.Session` objects 
        which set :paramref:`_orm.Session.close_resets_only` to ``False``, 
        so that &quot;reset only&quot; behavior is still available. 
 
        .. versionadded:: 2.0.22 
 
        .. seealso:: 
 
            :ref:`session_closing` - detail on the semantics of 
            :meth:`_orm.Session.close` and :meth:`_orm.Session.reset`. 
 
            :meth:`_orm.Session.close` - a similar method will additionally 
            prevent re-use of the Session when the parameter 
            :paramref:`_orm.Session.close_resets_only` is set to ``False``. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_close_impl</span><span class="s4">(</span><span class="s1">invalidate</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">is_reset</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">invalidate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Close this Session, using connection invalidation. 
 
        This is a variant of :meth:`.Session.close` that will additionally 
        ensure that the :meth:`_engine.Connection.invalidate` 
        method will be called on each :class:`_engine.Connection` object 
        that is currently in use for a transaction (typically there is only 
        one connection unless the :class:`_orm.Session` is used with 
        multiple engines). 
 
        This can be called when the database is known to be in a state where 
        the connections are no longer safe to be used. 
 
        Below illustrates a scenario when using `gevent 
        &lt;https://www.gevent.org/&gt;`_, which can produce ``Timeout`` exceptions 
        that may mean the underlying connection should be discarded:: 
 
            import gevent 
 
            try: 
                sess = Session() 
                sess.add(User()) 
                sess.commit() 
            except gevent.Timeout: 
                sess.invalidate() 
                raise 
            except: 
                sess.rollback() 
                raise 
 
        The method additionally does everything that :meth:`_orm.Session.close` 
        does, including that all ORM objects are expunged. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_close_impl</span><span class="s4">(</span><span class="s1">invalidate</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_close_impl</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">invalidate</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">, </span><span class="s1">is_reset</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if not </span><span class="s1">is_reset </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_close_state </span><span class="s3">is </span><span class="s1">_SessionCloseState</span><span class="s4">.</span><span class="s1">ACTIVE</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_close_state </span><span class="s4">= </span><span class="s1">_SessionCloseState</span><span class="s4">.</span><span class="s1">CLOSED</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">expunge_all</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">transaction </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction</span><span class="s4">.</span><span class="s1">_iterate_self_and_parents</span><span class="s4">():</span>
                <span class="s1">transaction</span><span class="s4">.</span><span class="s1">close</span><span class="s4">(</span><span class="s1">invalidate</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">expunge_all</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Remove all object instances from this ``Session``. 
 
        This is equivalent to calling ``expunge(obj)`` on all objects in this 
        ``Session``. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">all_states </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">all_states</span><span class="s4">() + </span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">_kill</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map </span><span class="s4">= </span><span class="s1">identity</span><span class="s4">.</span><span class="s1">WeakInstanceDict</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_new </span><span class="s4">= {}</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted </span><span class="s4">= {}</span>

        <span class="s1">statelib</span><span class="s4">.</span><span class="s1">InstanceState</span><span class="s4">.</span><span class="s1">_detach_states</span><span class="s4">(</span><span class="s1">all_states</span><span class="s4">, </span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_add_bind</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">: </span><span class="s1">_SessionBindKey</span><span class="s4">, </span><span class="s1">bind</span><span class="s4">: </span><span class="s1">_SessionBind</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">insp </span><span class="s4">= </span><span class="s1">inspect</span><span class="s4">(</span><span class="s1">key</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">NoInspectionAvailable </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
            <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">key</span><span class="s4">, </span><span class="s1">type</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                    <span class="s5">&quot;Not an acceptable bind target: %s&quot; </span><span class="s4">% </span><span class="s1">key</span>
                <span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">__binds</span><span class="s4">[</span><span class="s1">key</span><span class="s4">] = </span><span class="s1">bind</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
                <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">insp</span><span class="s4">, </span><span class="s1">Inspectable</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">insp</span><span class="s4">, </span><span class="s1">TableClause</span><span class="s4">):</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">__binds</span><span class="s4">[</span><span class="s1">insp</span><span class="s4">] = </span><span class="s1">bind</span>
            <span class="s3">elif </span><span class="s1">insp_is_mapper</span><span class="s4">(</span><span class="s1">insp</span><span class="s4">):</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">__binds</span><span class="s4">[</span><span class="s1">insp</span><span class="s4">.</span><span class="s1">class_</span><span class="s4">] = </span><span class="s1">bind</span>
                <span class="s3">for </span><span class="s1">_selectable </span><span class="s3">in </span><span class="s1">insp</span><span class="s4">.</span><span class="s1">_all_tables</span><span class="s4">:</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">__binds</span><span class="s4">[</span><span class="s1">_selectable</span><span class="s4">] = </span><span class="s1">bind</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                    <span class="s5">&quot;Not an acceptable bind target: %s&quot; </span><span class="s4">% </span><span class="s1">key</span>
                <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">bind_mapper</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">mapper</span><span class="s4">: </span><span class="s1">_EntityBindKey</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">], </span><span class="s1">bind</span><span class="s4">: </span><span class="s1">_SessionBind</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Associate a :class:`_orm.Mapper` or arbitrary Python class with a 
        &quot;bind&quot;, e.g. an :class:`_engine.Engine` or 
        :class:`_engine.Connection`. 
 
        The given entity is added to a lookup used by the 
        :meth:`.Session.get_bind` method. 
 
        :param mapper: a :class:`_orm.Mapper` object, 
         or an instance of a mapped 
         class, or any Python class that is the base of a set of mapped 
         classes. 
 
        :param bind: an :class:`_engine.Engine` or :class:`_engine.Connection` 
                    object. 
 
        .. seealso:: 
 
            :ref:`session_partitioning` 
 
            :paramref:`.Session.binds` 
 
            :meth:`.Session.bind_table` 
 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_add_bind</span><span class="s4">(</span><span class="s1">mapper</span><span class="s4">, </span><span class="s1">bind</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">bind_table</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">table</span><span class="s4">: </span><span class="s1">TableClause</span><span class="s4">, </span><span class="s1">bind</span><span class="s4">: </span><span class="s1">_SessionBind</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Associate a :class:`_schema.Table` with a &quot;bind&quot;, e.g. an 
        :class:`_engine.Engine` 
        or :class:`_engine.Connection`. 
 
        The given :class:`_schema.Table` is added to a lookup used by the 
        :meth:`.Session.get_bind` method. 
 
        :param table: a :class:`_schema.Table` object, 
         which is typically the target 
         of an ORM mapping, or is present within a selectable that is 
         mapped. 
 
        :param bind: an :class:`_engine.Engine` or :class:`_engine.Connection` 
         object. 
 
        .. seealso:: 
 
            :ref:`session_partitioning` 
 
            :paramref:`.Session.binds` 
 
            :meth:`.Session.bind_mapper` 
 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_add_bind</span><span class="s4">(</span><span class="s1">table</span><span class="s4">, </span><span class="s1">bind</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_bind</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">mapper</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_EntityBindKey</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">clause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ClauseElement</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">bind</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_SessionBind</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_sa_skip_events</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_sa_skip_for_implicit_returning</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">Engine</span><span class="s4">, </span><span class="s1">Connection</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a &quot;bind&quot; to which this :class:`.Session` is bound. 
 
        The &quot;bind&quot; is usually an instance of :class:`_engine.Engine`, 
        except in the case where the :class:`.Session` has been 
        explicitly bound directly to a :class:`_engine.Connection`. 
 
        For a multiply-bound or unbound :class:`.Session`, the 
        ``mapper`` or ``clause`` arguments are used to determine the 
        appropriate bind to return. 
 
        Note that the &quot;mapper&quot; argument is usually present 
        when :meth:`.Session.get_bind` is called via an ORM 
        operation such as a :meth:`.Session.query`, each 
        individual INSERT/UPDATE/DELETE operation within a 
        :meth:`.Session.flush`, call, etc. 
 
        The order of resolution is: 
 
        1. if mapper given and :paramref:`.Session.binds` is present, 
           locate a bind based first on the mapper in use, then 
           on the mapped class in use, then on any base classes that are 
           present in the ``__mro__`` of the mapped class, from more specific 
           superclasses to more general. 
        2. if clause given and ``Session.binds`` is present, 
           locate a bind based on :class:`_schema.Table` objects 
           found in the given clause present in ``Session.binds``. 
        3. if ``Session.binds`` is present, return that. 
        4. if clause given, attempt to return a bind 
           linked to the :class:`_schema.MetaData` ultimately 
           associated with the clause. 
        5. if mapper given, attempt to return a bind 
           linked to the :class:`_schema.MetaData` ultimately 
           associated with the :class:`_schema.Table` or other 
           selectable to which the mapper is mapped. 
        6. No bind can be found, :exc:`~sqlalchemy.exc.UnboundExecutionError` 
           is raised. 
 
        Note that the :meth:`.Session.get_bind` method can be overridden on 
        a user-defined subclass of :class:`.Session` to provide any kind 
        of bind resolution scheme.  See the example at 
        :ref:`session_custom_partitioning`. 
 
        :param mapper: 
          Optional mapped class or corresponding :class:`_orm.Mapper` instance. 
          The bind can be derived from a :class:`_orm.Mapper` first by 
          consulting the &quot;binds&quot; map associated with this :class:`.Session`, 
          and secondly by consulting the :class:`_schema.MetaData` associated 
          with the :class:`_schema.Table` to which the :class:`_orm.Mapper` is 
          mapped for a bind. 
 
        :param clause: 
            A :class:`_expression.ClauseElement` (i.e. 
            :func:`_expression.select`, 
            :func:`_expression.text`, 
            etc.).  If the ``mapper`` argument is not present or could not 
            produce a bind, the given expression construct will be searched 
            for a bound element, typically a :class:`_schema.Table` 
            associated with 
            bound :class:`_schema.MetaData`. 
 
        .. seealso:: 
 
             :ref:`session_partitioning` 
 
             :paramref:`.Session.binds` 
 
             :meth:`.Session.bind_mapper` 
 
             :meth:`.Session.bind_table` 
 
        &quot;&quot;&quot;</span>

        <span class="s0"># this function is documented as a subclassing hook, so we have</span>
        <span class="s0"># to call this method even if the return is simple</span>
        <span class="s3">if </span><span class="s1">bind</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">bind</span>
        <span class="s3">elif not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__binds </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">bind</span><span class="s4">:</span>
            <span class="s0"># simplest and most common case, we have a bind and no</span>
            <span class="s0"># per-mapper/table binds, we're done</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">bind</span>

        <span class="s0"># we don't have self.bind and either have self.__binds</span>
        <span class="s0"># or we don't have self.__binds (which is legacy).  Look at the</span>
        <span class="s0"># mapper and the clause</span>
        <span class="s3">if </span><span class="s1">mapper </span><span class="s3">is None and </span><span class="s1">clause </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">bind</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">bind</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">UnboundExecutionError</span><span class="s4">(</span>
                    <span class="s5">&quot;This session is not bound to a single Engine or &quot;</span>
                    <span class="s5">&quot;Connection, and no context was provided to locate &quot;</span>
                    <span class="s5">&quot;a binding.&quot;</span>
                <span class="s4">)</span>

        <span class="s0"># look more closely at the mapper.</span>
        <span class="s3">if </span><span class="s1">mapper </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">inspected_mapper </span><span class="s4">= </span><span class="s1">inspect</span><span class="s4">(</span><span class="s1">mapper</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">NoInspectionAvailable </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">mapper</span><span class="s4">, </span><span class="s1">type</span><span class="s4">):</span>
                    <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">UnmappedClassError</span><span class="s4">(</span><span class="s1">mapper</span><span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s3">raise</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">inspected_mapper </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s0"># match up the mapper or clause in the __binds</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__binds</span><span class="s4">:</span>
            <span class="s0"># matching mappers and selectables to entries in the</span>
            <span class="s0"># binds dictionary; supported use case.</span>
            <span class="s3">if </span><span class="s1">inspected_mapper</span><span class="s4">:</span>
                <span class="s3">for </span><span class="s1">cls </span><span class="s3">in </span><span class="s1">inspected_mapper</span><span class="s4">.</span><span class="s1">class_</span><span class="s4">.</span><span class="s1">__mro__</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">cls </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__binds</span><span class="s4">:</span>
                        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__binds</span><span class="s4">[</span><span class="s1">cls</span><span class="s4">]</span>
                <span class="s3">if </span><span class="s1">clause </span><span class="s3">is None</span><span class="s4">:</span>
                    <span class="s1">clause </span><span class="s4">= </span><span class="s1">inspected_mapper</span><span class="s4">.</span><span class="s1">persist_selectable</span>

            <span class="s3">if </span><span class="s1">clause </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">plugin_subject </span><span class="s4">= </span><span class="s1">clause</span><span class="s4">.</span><span class="s1">_propagate_attrs</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span>
                    <span class="s5">&quot;plugin_subject&quot;</span><span class="s4">, </span><span class="s3">None</span>
                <span class="s4">)</span>

                <span class="s3">if </span><span class="s1">plugin_subject </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s3">for </span><span class="s1">cls </span><span class="s3">in </span><span class="s1">plugin_subject</span><span class="s4">.</span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">class_</span><span class="s4">.</span><span class="s1">__mro__</span><span class="s4">:</span>
                        <span class="s3">if </span><span class="s1">cls </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__binds</span><span class="s4">:</span>
                            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__binds</span><span class="s4">[</span><span class="s1">cls</span><span class="s4">]</span>

                <span class="s3">for </span><span class="s1">obj </span><span class="s3">in </span><span class="s1">visitors</span><span class="s4">.</span><span class="s1">iterate</span><span class="s4">(</span><span class="s1">clause</span><span class="s4">):</span>
                    <span class="s3">if </span><span class="s1">obj </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__binds</span><span class="s4">:</span>
                        <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
                            <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">Table</span><span class="s4">)</span>
                        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__binds</span><span class="s4">[</span><span class="s1">obj</span><span class="s4">]</span>

        <span class="s0"># none of the __binds matched, but we have a fallback bind.</span>
        <span class="s0"># return that</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">bind</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">bind</span>

        <span class="s1">context </span><span class="s4">= []</span>
        <span class="s3">if </span><span class="s1">inspected_mapper </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">context</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">f&quot;mapper </span><span class="s3">{</span><span class="s1">inspected_mapper</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">clause </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">context</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">&quot;SQL expression&quot;</span><span class="s4">)</span>

        <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">UnboundExecutionError</span><span class="s4">(</span>
            <span class="s5">f&quot;Could not locate a bind configured on &quot;</span>
            <span class="s5">f'</span><span class="s3">{</span><span class="s5">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">context</span><span class="s4">)</span><span class="s3">} </span><span class="s5">or this Session.'</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">query</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">_entity</span><span class="s4">: </span><span class="s1">_EntityType</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">]) </span><span class="s1">-&gt; Query</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">query</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">_colexpr</span><span class="s4">: </span><span class="s1">TypedColumnsClauseRole</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]: ...</span>

    <span class="s0"># START OVERLOADED FUNCTIONS self.query RowReturningQuery 2-8</span>

    <span class="s0"># code within this block is **programmatically,</span>
    <span class="s0"># statically generated** by tools/generate_tuple_map_overloads.py</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">query</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">], </span><span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">query</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">], </span><span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">], </span><span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">query</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">],</span>
        <span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">],</span>
        <span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">],</span>
        <span class="s1">__ent3</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T3</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">, </span><span class="s1">_T3</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">query</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">],</span>
        <span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">],</span>
        <span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">],</span>
        <span class="s1">__ent3</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T3</span><span class="s4">],</span>
        <span class="s1">__ent4</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T4</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">, </span><span class="s1">_T3</span><span class="s4">, </span><span class="s1">_T4</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">query</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">],</span>
        <span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">],</span>
        <span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">],</span>
        <span class="s1">__ent3</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T3</span><span class="s4">],</span>
        <span class="s1">__ent4</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T4</span><span class="s4">],</span>
        <span class="s1">__ent5</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T5</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">, </span><span class="s1">_T3</span><span class="s4">, </span><span class="s1">_T4</span><span class="s4">, </span><span class="s1">_T5</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">query</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">],</span>
        <span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">],</span>
        <span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">],</span>
        <span class="s1">__ent3</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T3</span><span class="s4">],</span>
        <span class="s1">__ent4</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T4</span><span class="s4">],</span>
        <span class="s1">__ent5</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T5</span><span class="s4">],</span>
        <span class="s1">__ent6</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T6</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">, </span><span class="s1">_T3</span><span class="s4">, </span><span class="s1">_T4</span><span class="s4">, </span><span class="s1">_T5</span><span class="s4">, </span><span class="s1">_T6</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">query</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">],</span>
        <span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">],</span>
        <span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">],</span>
        <span class="s1">__ent3</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T3</span><span class="s4">],</span>
        <span class="s1">__ent4</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T4</span><span class="s4">],</span>
        <span class="s1">__ent5</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T5</span><span class="s4">],</span>
        <span class="s1">__ent6</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T6</span><span class="s4">],</span>
        <span class="s1">__ent7</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T7</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">, </span><span class="s1">_T3</span><span class="s4">, </span><span class="s1">_T4</span><span class="s4">, </span><span class="s1">_T5</span><span class="s4">, </span><span class="s1">_T6</span><span class="s4">, </span><span class="s1">_T7</span><span class="s4">]]: ...</span>

    <span class="s0"># END OVERLOADED FUNCTIONS self.query</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">query</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *</span><span class="s1">entities</span><span class="s4">: </span><span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], **</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">query</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *</span><span class="s1">entities</span><span class="s4">: </span><span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], **</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a new :class:`_query.Query` object corresponding to this 
        :class:`_orm.Session`. 
 
        Note that the :class:`_query.Query` object is legacy as of 
        SQLAlchemy 2.0; the :func:`_sql.select` construct is now used 
        to construct ORM queries. 
 
        .. seealso:: 
 
            :ref:`unified_tutorial` 
 
            :ref:`queryguide_toplevel` 
 
            :ref:`query_api_toplevel` - legacy API doc 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_query_cls</span><span class="s4">(</span><span class="s1">entities</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_identity_lookup</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">mapper</span><span class="s4">: </span><span class="s1">Mapper</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">],</span>
        <span class="s1">primary_key_identity</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, ...]],</span>
        <span class="s1">identity_token</span><span class="s4">: </span><span class="s1">Any </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">passive</span><span class="s4">: </span><span class="s1">PassiveFlag </span><span class="s4">= </span><span class="s1">PassiveFlag</span><span class="s4">.</span><span class="s1">PASSIVE_OFF</span><span class="s4">,</span>
        <span class="s1">lazy_loaded_from</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">], </span><span class="s1">LoaderCallableStatus</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Locate an object in the identity map. 
 
        Given a primary key identity, constructs an identity key and then 
        looks in the session's identity map.  If present, the object may 
        be run through unexpiration rules (e.g. load unloaded attributes, 
        check if was deleted). 
 
        e.g.:: 
 
            obj = session._identity_lookup(inspect(SomeClass), (1, )) 
 
        :param mapper: mapper in use 
        :param primary_key_identity: the primary key we are searching for, as 
         a tuple. 
        :param identity_token: identity token that should be used to create 
         the identity key.  Used as is, however overriding subclasses can 
         repurpose this in order to interpret the value in a special way, 
         such as if None then look among multiple target tokens. 
        :param passive: passive load flag passed to 
         :func:`.loading.get_from_identity`, which impacts the behavior if 
         the object is found; the object may be validated and/or unexpired 
         if the flag allows for SQL to be emitted. 
        :param lazy_loaded_from: an :class:`.InstanceState` that is 
         specifically asking for this identity as a related identity.  Used 
         for sharding schemes where there is a correspondence between an object 
         and a related object being lazy-loaded (or otherwise 
         relationship-loaded). 
 
        :return: None if the object is not found in the identity map, *or* 
         if the object was unexpired and found to have been deleted. 
         if passive flags disallow SQL and the object is expired, returns 
         PASSIVE_NO_RESULT.   In all other cases the instance is returned. 
 
        .. versionchanged:: 1.4.0 - the :meth:`.Session._identity_lookup` 
           method was moved from :class:`_query.Query` to 
           :class:`.Session`, to avoid having to instantiate the 
           :class:`_query.Query` object. 
 
 
        &quot;&quot;&quot;</span>

        <span class="s1">key </span><span class="s4">= </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">identity_key_from_primary_key</span><span class="s4">(</span>
            <span class="s1">primary_key_identity</span><span class="s4">, </span><span class="s1">identity_token</span><span class="s4">=</span><span class="s1">identity_token</span>
        <span class="s4">)</span>

        <span class="s0"># work around: https://github.com/python/typing/discussions/1143</span>
        <span class="s1">return_value </span><span class="s4">= </span><span class="s1">loading</span><span class="s4">.</span><span class="s1">get_from_identity</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">mapper</span><span class="s4">, </span><span class="s1">key</span><span class="s4">, </span><span class="s1">passive</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">return_value</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">non_memoized_property</span>
    <span class="s4">@</span><span class="s1">contextlib</span><span class="s4">.</span><span class="s1">contextmanager</span>
    <span class="s3">def </span><span class="s1">no_autoflush</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">Session</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a context manager that disables autoflush. 
 
        e.g.:: 
 
            with session.no_autoflush: 
 
                some_object = SomeClass() 
                session.add(some_object) 
                # won't autoflush 
                some_object.related_thing = session.query(SomeRelated).first() 
 
        Operations that proceed within the ``with:`` block 
        will not be subject to flushes occurring upon query 
        access.  This is useful when initializing a series 
        of objects which involve existing database queries, 
        where the uncompleted object should not yet be flushed. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">autoflush </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">autoflush</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">autoflush </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">yield </span><span class="s1">self</span>
        <span class="s3">finally</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">autoflush </span><span class="s4">= </span><span class="s1">autoflush</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">langhelpers</span><span class="s4">.</span><span class="s1">tag_method_for_warnings</span><span class="s4">(</span>
        <span class="s5">&quot;This warning originated from the Session 'autoflush' process, &quot;</span>
        <span class="s5">&quot;which was invoked automatically in response to a user-initiated &quot;</span>
        <span class="s5">&quot;operation.&quot;</span><span class="s4">,</span>
        <span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">SAWarning</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">_autoflush</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">autoflush </span><span class="s3">and not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_flushing</span><span class="s4">:</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">flush</span><span class="s4">()</span>
            <span class="s3">except </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">StatementError </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
                <span class="s0"># note we are reraising StatementError as opposed to</span>
                <span class="s0"># raising FlushError with &quot;chaining&quot; to remain compatible</span>
                <span class="s0"># with code that catches StatementError, IntegrityError,</span>
                <span class="s0"># etc.</span>
                <span class="s1">e</span><span class="s4">.</span><span class="s1">add_detail</span><span class="s4">(</span>
                    <span class="s5">&quot;raised as a result of Query-invoked autoflush; &quot;</span>
                    <span class="s5">&quot;consider using a session.no_autoflush block if this &quot;</span>
                    <span class="s5">&quot;flush is occurring prematurely&quot;</span>
                <span class="s4">)</span>
                <span class="s3">raise </span><span class="s1">e</span><span class="s4">.</span><span class="s1">with_traceback</span><span class="s4">(</span><span class="s1">sys</span><span class="s4">.</span><span class="s1">exc_info</span><span class="s4">()[</span><span class="s6">2</span><span class="s4">])</span>

    <span class="s3">def </span><span class="s1">refresh</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">instance</span><span class="s4">: </span><span class="s1">object</span><span class="s4">,</span>
        <span class="s1">attribute_names</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">with_for_update</span><span class="s4">: </span><span class="s1">ForUpdateParameter </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Expire and refresh attributes on the given instance. 
 
        The selected attributes will first be expired as they would when using 
        :meth:`_orm.Session.expire`; then a SELECT statement will be issued to 
        the database to refresh column-oriented attributes with the current 
        value available in the current transaction. 
 
        :func:`_orm.relationship` oriented attributes will also be immediately 
        loaded if they were already eagerly loaded on the object, using the 
        same eager loading strategy that they were loaded with originally. 
 
        .. versionadded:: 1.4 - the :meth:`_orm.Session.refresh` method 
           can also refresh eagerly loaded attributes. 
 
        :func:`_orm.relationship` oriented attributes that would normally 
        load using the ``select`` (or &quot;lazy&quot;) loader strategy will also 
        load **if they are named explicitly in the attribute_names 
        collection**, emitting a SELECT statement for the attribute using the 
        ``immediate`` loader strategy.  If lazy-loaded relationships are not 
        named in :paramref:`_orm.Session.refresh.attribute_names`, then 
        they remain as &quot;lazy loaded&quot; attributes and are not implicitly 
        refreshed. 
 
        .. versionchanged:: 2.0.4  The :meth:`_orm.Session.refresh` method 
           will now refresh lazy-loaded :func:`_orm.relationship` oriented 
           attributes for those which are named explicitly in the 
           :paramref:`_orm.Session.refresh.attribute_names` collection. 
 
        .. tip:: 
 
            While the :meth:`_orm.Session.refresh` method is capable of 
            refreshing both column and relationship oriented attributes, its 
            primary focus is on refreshing of local column-oriented attributes 
            on a single instance. For more open ended &quot;refresh&quot; functionality, 
            including the ability to refresh the attributes on many objects at 
            once while having explicit control over relationship loader 
            strategies, use the 
            :ref:`populate existing &lt;orm_queryguide_populate_existing&gt;` feature 
            instead. 
 
        Note that a highly isolated transaction will return the same values as 
        were previously read in that same transaction, regardless of changes 
        in database state outside of that transaction.   Refreshing 
        attributes usually only makes sense at the start of a transaction 
        where database rows have not yet been accessed. 
 
        :param attribute_names: optional.  An iterable collection of 
          string attribute names indicating a subset of attributes to 
          be refreshed. 
 
        :param with_for_update: optional boolean ``True`` indicating FOR UPDATE 
          should be used, or may be a dictionary containing flags to 
          indicate a more specific set of FOR UPDATE flags for the SELECT; 
          flags should match the parameters of 
          :meth:`_query.Query.with_for_update`. 
          Supersedes the :paramref:`.Session.refresh.lockmode` parameter. 
 
        .. seealso:: 
 
            :ref:`session_expire` - introductory material 
 
            :meth:`.Session.expire` 
 
            :meth:`.Session.expire_all` 
 
            :ref:`orm_queryguide_populate_existing` - allows any ORM query 
            to refresh objects as they would be loaded normally. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">state </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_state</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">NO_STATE </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">UnmappedInstanceError</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_expire_state</span><span class="s4">(</span><span class="s1">state</span><span class="s4">, </span><span class="s1">attribute_names</span><span class="s4">)</span>

        <span class="s0"># this autoflush previously used to occur as a secondary effect</span>
        <span class="s0"># of the load_on_ident below.   Meaning we'd organize the SELECT</span>
        <span class="s0"># based on current DB pks, then flush, then if pks changed in that</span>
        <span class="s0"># flush, crash.  this was unticketed but discovered as part of</span>
        <span class="s0"># #8703.  So here, autoflush up front, dont autoflush inside</span>
        <span class="s0"># load_on_ident.</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_autoflush</span><span class="s4">()</span>

        <span class="s3">if </span><span class="s1">with_for_update </span><span class="s4">== {}:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                <span class="s5">&quot;with_for_update should be the boolean value &quot;</span>
                <span class="s5">&quot;True, or a dictionary with options.  &quot;</span>
                <span class="s5">&quot;A blank dictionary is ambiguous.&quot;</span>
            <span class="s4">)</span>

        <span class="s1">with_for_update </span><span class="s4">= </span><span class="s1">ForUpdateArg</span><span class="s4">.</span><span class="s1">_from_argument</span><span class="s4">(</span><span class="s1">with_for_update</span><span class="s4">)</span>

        <span class="s1">stmt</span><span class="s4">: </span><span class="s1">Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s1">sql</span><span class="s4">.</span><span class="s1">select</span><span class="s4">(</span><span class="s1">object_mapper</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">))</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">loading</span><span class="s4">.</span><span class="s1">load_on_ident</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">,</span>
                <span class="s1">stmt</span><span class="s4">,</span>
                <span class="s1">state</span><span class="s4">.</span><span class="s1">key</span><span class="s4">,</span>
                <span class="s1">refresh_state</span><span class="s4">=</span><span class="s1">state</span><span class="s4">,</span>
                <span class="s1">with_for_update</span><span class="s4">=</span><span class="s1">with_for_update</span><span class="s4">,</span>
                <span class="s1">only_load_props</span><span class="s4">=</span><span class="s1">attribute_names</span><span class="s4">,</span>
                <span class="s1">require_pk_cols</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                <span class="s0"># technically unnecessary as we just did autoflush</span>
                <span class="s0"># above, however removes the additional unnecessary</span>
                <span class="s0"># call to _autoflush()</span>
                <span class="s1">no_autoflush</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                <span class="s1">is_user_refresh</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s3">is None</span>
        <span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;Could not refresh instance '%s'&quot; </span><span class="s4">% </span><span class="s1">instance_str</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">expire_all</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Expires all persistent instances within this Session. 
 
        When any attributes on a persistent instance is next accessed, 
        a query will be issued using the 
        :class:`.Session` object's current transactional context in order to 
        load all expired attributes for the given instance.   Note that 
        a highly isolated transaction will return the same values as were 
        previously read in that same transaction, regardless of changes 
        in database state outside of that transaction. 
 
        To expire individual objects and individual attributes 
        on those objects, use :meth:`Session.expire`. 
 
        The :class:`.Session` object's default behavior is to 
        expire all state whenever the :meth:`Session.rollback` 
        or :meth:`Session.commit` methods are called, so that new 
        state can be loaded for the new transaction.   For this reason, 
        calling :meth:`Session.expire_all` is not usually needed, 
        assuming the transaction is isolated. 
 
        .. seealso:: 
 
            :ref:`session_expire` - introductory material 
 
            :meth:`.Session.expire` 
 
            :meth:`.Session.refresh` 
 
            :meth:`_orm.Query.populate_existing` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">state </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">all_states</span><span class="s4">():</span>
            <span class="s1">state</span><span class="s4">.</span><span class="s1">_expire</span><span class="s4">(</span><span class="s1">state</span><span class="s4">.</span><span class="s1">dict</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">_modified</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">expire</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">object</span><span class="s4">, </span><span class="s1">attribute_names</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Expire the attributes on an instance. 
 
        Marks the attributes of an instance as out of date. When an expired 
        attribute is next accessed, a query will be issued to the 
        :class:`.Session` object's current transactional context in order to 
        load all expired attributes for the given instance.   Note that 
        a highly isolated transaction will return the same values as were 
        previously read in that same transaction, regardless of changes 
        in database state outside of that transaction. 
 
        To expire all objects in the :class:`.Session` simultaneously, 
        use :meth:`Session.expire_all`. 
 
        The :class:`.Session` object's default behavior is to 
        expire all state whenever the :meth:`Session.rollback` 
        or :meth:`Session.commit` methods are called, so that new 
        state can be loaded for the new transaction.   For this reason, 
        calling :meth:`Session.expire` only makes sense for the specific 
        case that a non-ORM SQL statement was emitted in the current 
        transaction. 
 
        :param instance: The instance to be refreshed. 
        :param attribute_names: optional list of string attribute names 
          indicating a subset of attributes to be expired. 
 
        .. seealso:: 
 
            :ref:`session_expire` - introductory material 
 
            :meth:`.Session.expire` 
 
            :meth:`.Session.refresh` 
 
            :meth:`_orm.Query.populate_existing` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">state </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_state</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">NO_STATE </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">UnmappedInstanceError</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_expire_state</span><span class="s4">(</span><span class="s1">state</span><span class="s4">, </span><span class="s1">attribute_names</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_expire_state</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">state</span><span class="s4">: </span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">attribute_names</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]],</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_persistent</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">attribute_names</span><span class="s4">:</span>
            <span class="s1">state</span><span class="s4">.</span><span class="s1">_expire_attributes</span><span class="s4">(</span><span class="s1">state</span><span class="s4">.</span><span class="s1">dict</span><span class="s4">, </span><span class="s1">attribute_names</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s0"># pre-fetch the full cascade since the expire is going to</span>
            <span class="s0"># remove associations</span>
            <span class="s1">cascaded </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span>
                <span class="s1">state</span><span class="s4">.</span><span class="s1">manager</span><span class="s4">.</span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">cascade_iterator</span><span class="s4">(</span><span class="s5">&quot;refresh-expire&quot;</span><span class="s4">, </span><span class="s1">state</span><span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_conditional_expire</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
            <span class="s3">for </span><span class="s1">o</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">st_</span><span class="s4">, </span><span class="s1">dct_ </span><span class="s3">in </span><span class="s1">cascaded</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_conditional_expire</span><span class="s4">(</span><span class="s1">st_</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_conditional_expire</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">: </span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">autoflush</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Expire a state if persistent, else expunge if pending&quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">key</span><span class="s4">:</span>
            <span class="s1">state</span><span class="s4">.</span><span class="s1">_expire</span><span class="s4">(</span><span class="s1">state</span><span class="s4">.</span><span class="s1">dict</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">_modified</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">state </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
            <span class="s1">state</span><span class="s4">.</span><span class="s1">_detach</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">expunge</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">object</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Remove the `instance` from this ``Session``. 
 
        This will free all internal references to the instance.  Cascading 
        will be applied according to the *expunge* cascade rule. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">state </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_state</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">NO_STATE </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">UnmappedInstanceError</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>
        <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">session_id </span><span class="s3">is not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hash_key</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;Instance %s is not present in this Session&quot; </span><span class="s4">% </span><span class="s1">state_str</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
            <span class="s4">)</span>

        <span class="s1">cascaded </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span>
            <span class="s1">state</span><span class="s4">.</span><span class="s1">manager</span><span class="s4">.</span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">cascade_iterator</span><span class="s4">(</span><span class="s5">&quot;expunge&quot;</span><span class="s4">, </span><span class="s1">state</span><span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_expunge_states</span><span class="s4">([</span><span class="s1">state</span><span class="s4">] + [</span><span class="s1">st_ </span><span class="s3">for </span><span class="s1">o</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">st_</span><span class="s4">, </span><span class="s1">dct_ </span><span class="s3">in </span><span class="s1">cascaded</span><span class="s4">])</span>

    <span class="s3">def </span><span class="s1">_expunge_states</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">states</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]], </span><span class="s1">to_transient</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">state </span><span class="s3">in </span><span class="s1">states</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">state </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">contains_state</span><span class="s4">(</span><span class="s1">state</span><span class="s4">):</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">safe_discard</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">state</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction</span><span class="s4">:</span>
                <span class="s0"># state is &quot;detached&quot; from being deleted, but still present</span>
                <span class="s0"># in the transaction snapshot</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">state</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s1">statelib</span><span class="s4">.</span><span class="s1">InstanceState</span><span class="s4">.</span><span class="s1">_detach_states</span><span class="s4">(</span>
            <span class="s1">states</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, </span><span class="s1">to_transient</span><span class="s4">=</span><span class="s1">to_transient</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_register_persistent</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">states</span><span class="s4">: </span><span class="s1">Set</span><span class="s4">[</span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Register all persistent objects from a flush. 
 
        This is used both for pending objects moving to the persistent 
        state as well as already persistent objects. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">pending_to_persistent </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">pending_to_persistent </span><span class="s3">or None</span>
        <span class="s3">for </span><span class="s1">state </span><span class="s3">in </span><span class="s1">states</span><span class="s4">:</span>
            <span class="s1">mapper </span><span class="s4">= </span><span class="s1">_state_mapper</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>

            <span class="s0"># prevent against last minute dereferences of the object</span>
            <span class="s1">obj </span><span class="s4">= </span><span class="s1">state</span><span class="s4">.</span><span class="s1">obj</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s1">obj </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">instance_key </span><span class="s4">= </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">_identity_key_from_state</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>

                <span class="s3">if </span><span class="s4">(</span>
                    <span class="s1">_none_set</span><span class="s4">.</span><span class="s1">intersection</span><span class="s4">(</span><span class="s1">instance_key</span><span class="s4">[</span><span class="s6">1</span><span class="s4">])</span>
                    <span class="s3">and not </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">allow_partial_pks</span>
                    <span class="s3">or </span><span class="s1">_none_set</span><span class="s4">.</span><span class="s1">issuperset</span><span class="s4">(</span><span class="s1">instance_key</span><span class="s4">[</span><span class="s6">1</span><span class="s4">])</span>
                <span class="s4">):</span>
                    <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">FlushError</span><span class="s4">(</span>
                        <span class="s5">&quot;Instance %s has a NULL identity key.  If this is an &quot;</span>
                        <span class="s5">&quot;auto-generated value, check that the database table &quot;</span>
                        <span class="s5">&quot;allows generation of new primary key values, and &quot;</span>
                        <span class="s5">&quot;that the mapped Column object is configured to &quot;</span>
                        <span class="s5">&quot;expect these generated values.  Ensure also that &quot;</span>
                        <span class="s5">&quot;this flush() is not occurring at an inappropriate &quot;</span>
                        <span class="s5">&quot;time, such as within a load() event.&quot;</span>
                        <span class="s4">% </span><span class="s1">state_str</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
                    <span class="s4">)</span>

                <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">key </span><span class="s3">is None</span><span class="s4">:</span>
                    <span class="s1">state</span><span class="s4">.</span><span class="s1">key </span><span class="s4">= </span><span class="s1">instance_key</span>
                <span class="s3">elif </span><span class="s1">state</span><span class="s4">.</span><span class="s1">key </span><span class="s4">!= </span><span class="s1">instance_key</span><span class="s4">:</span>
                    <span class="s0"># primary key switch. use safe_discard() in case another</span>
                    <span class="s0"># state has already replaced this one in the identity</span>
                    <span class="s0"># map (see test/orm/test_naturalpks.py ReversePKsTest)</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">safe_discard</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
                    <span class="s1">trans </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction</span>
                    <span class="s3">assert </span><span class="s1">trans </span><span class="s3">is not None</span>
                    <span class="s3">if </span><span class="s1">state </span><span class="s3">in </span><span class="s1">trans</span><span class="s4">.</span><span class="s1">_key_switches</span><span class="s4">:</span>
                        <span class="s1">orig_key </span><span class="s4">= </span><span class="s1">trans</span><span class="s4">.</span><span class="s1">_key_switches</span><span class="s4">[</span><span class="s1">state</span><span class="s4">][</span><span class="s6">0</span><span class="s4">]</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">orig_key </span><span class="s4">= </span><span class="s1">state</span><span class="s4">.</span><span class="s1">key</span>
                    <span class="s1">trans</span><span class="s4">.</span><span class="s1">_key_switches</span><span class="s4">[</span><span class="s1">state</span><span class="s4">] = (</span>
                        <span class="s1">orig_key</span><span class="s4">,</span>
                        <span class="s1">instance_key</span><span class="s4">,</span>
                    <span class="s4">)</span>
                    <span class="s1">state</span><span class="s4">.</span><span class="s1">key </span><span class="s4">= </span><span class="s1">instance_key</span>

                <span class="s0"># there can be an existing state in the identity map</span>
                <span class="s0"># that is replaced when the primary keys of two instances</span>
                <span class="s0"># are swapped; see test/orm/test_naturalpks.py -&gt; test_reverse</span>
                <span class="s1">old </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s4">(</span>
                    <span class="s1">old </span><span class="s3">is not None</span>
                    <span class="s3">and </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">_identity_key_from_state</span><span class="s4">(</span><span class="s1">old</span><span class="s4">) == </span><span class="s1">instance_key</span>
                    <span class="s3">and </span><span class="s1">old</span><span class="s4">.</span><span class="s1">obj</span><span class="s4">() </span><span class="s3">is not None</span>
                <span class="s4">):</span>
                    <span class="s1">util</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                        <span class="s5">&quot;Identity map already had an identity for %s, &quot;</span>
                        <span class="s5">&quot;replacing it with newly flushed object.   Are there &quot;</span>
                        <span class="s5">&quot;load operations occurring inside of an event handler &quot;</span>
                        <span class="s5">&quot;within the flush?&quot; </span><span class="s4">% (</span><span class="s1">instance_key</span><span class="s4">,)</span>
                    <span class="s4">)</span>
                <span class="s1">state</span><span class="s4">.</span><span class="s1">_orphaned_outside_of_session </span><span class="s4">= </span><span class="s3">False</span>

        <span class="s1">statelib</span><span class="s4">.</span><span class="s1">InstanceState</span><span class="s4">.</span><span class="s1">_commit_all_states</span><span class="s4">(</span>
            <span class="s4">((</span><span class="s1">state</span><span class="s4">, </span><span class="s1">state</span><span class="s4">.</span><span class="s1">dict</span><span class="s4">) </span><span class="s3">for </span><span class="s1">state </span><span class="s3">in </span><span class="s1">states</span><span class="s4">), </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span>
        <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_register_altered</span><span class="s4">(</span><span class="s1">states</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">pending_to_persistent </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">state </span><span class="s3">in </span><span class="s1">states</span><span class="s4">.</span><span class="s1">intersection</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">):</span>
                <span class="s1">pending_to_persistent</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">)</span>

        <span class="s0"># remove from new last, might be the last strong ref</span>
        <span class="s3">for </span><span class="s1">state </span><span class="s3">in </span><span class="s1">set</span><span class="s4">(</span><span class="s1">states</span><span class="s4">).</span><span class="s1">intersection</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_register_altered</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">states</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">state </span><span class="s3">in </span><span class="s1">states</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">state </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">:</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">[</span><span class="s1">state</span><span class="s4">] = </span><span class="s3">True</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction</span><span class="s4">.</span><span class="s1">_dirty</span><span class="s4">[</span><span class="s1">state</span><span class="s4">] = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">_remove_newly_deleted</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">states</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">persistent_to_deleted </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">persistent_to_deleted </span><span class="s3">or None</span>
        <span class="s3">for </span><span class="s1">state </span><span class="s3">in </span><span class="s1">states</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">[</span><span class="s1">state</span><span class="s4">] = </span><span class="s3">True</span>

            <span class="s3">if </span><span class="s1">persistent_to_deleted </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s0"># get a strong reference before we pop out of</span>
                <span class="s0"># self._deleted</span>
                <span class="s1">obj </span><span class="s4">= </span><span class="s1">state</span><span class="s4">.</span><span class="s1">obj</span><span class="s4">()  </span><span class="s0"># noqa</span>

            <span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">safe_discard</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">state</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
            <span class="s1">state</span><span class="s4">.</span><span class="s1">_deleted </span><span class="s4">= </span><span class="s3">True</span>
            <span class="s0"># can't call state._detach() here, because this state</span>
            <span class="s0"># is still in the transaction snapshot and needs to be</span>
            <span class="s0"># tracked as part of that</span>
            <span class="s3">if </span><span class="s1">persistent_to_deleted </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">persistent_to_deleted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">add</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">object</span><span class="s4">, </span><span class="s1">_warn</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Place an object into this :class:`_orm.Session`. 
 
        Objects that are in the :term:`transient` state when passed to the 
        :meth:`_orm.Session.add` method will move to the 
        :term:`pending` state, until the next flush, at which point they 
        will move to the :term:`persistent` state. 
 
        Objects that are in the :term:`detached` state when passed to the 
        :meth:`_orm.Session.add` method will move to the :term:`persistent` 
        state directly. 
 
        If the transaction used by the :class:`_orm.Session` is rolled back, 
        objects which were transient when they were passed to 
        :meth:`_orm.Session.add` will be moved back to the 
        :term:`transient` state, and will no longer be present within this 
        :class:`_orm.Session`. 
 
        .. seealso:: 
 
            :meth:`_orm.Session.add_all` 
 
            :ref:`session_adding` - at :ref:`session_basics` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">_warn </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_warn_on_events</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_flush_warning</span><span class="s4">(</span><span class="s5">&quot;Session.add()&quot;</span><span class="s4">)</span>

        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">state </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_state</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">NO_STATE </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">UnmappedInstanceError</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_save_or_update_state</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">add_all</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">instances</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">object</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Add the given collection of instances to this :class:`_orm.Session`. 
 
        See the documentation for :meth:`_orm.Session.add` for a general 
        behavioral description. 
 
        .. seealso:: 
 
            :meth:`_orm.Session.add` 
 
            :ref:`session_adding` - at :ref:`session_basics` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_warn_on_events</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_flush_warning</span><span class="s4">(</span><span class="s5">&quot;Session.add_all()&quot;</span><span class="s4">)</span>

        <span class="s3">for </span><span class="s1">instance </span><span class="s3">in </span><span class="s1">instances</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">, </span><span class="s1">_warn</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_save_or_update_state</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">: </span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">state</span><span class="s4">.</span><span class="s1">_orphaned_outside_of_session </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_save_or_update_impl</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>

        <span class="s1">mapper </span><span class="s4">= </span><span class="s1">_state_mapper</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">o</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">st_</span><span class="s4">, </span><span class="s1">dct_ </span><span class="s3">in </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">cascade_iterator</span><span class="s4">(</span>
            <span class="s5">&quot;save-update&quot;</span><span class="s4">, </span><span class="s1">state</span><span class="s4">, </span><span class="s1">halt_on</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_contains_state</span>
        <span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_save_or_update_impl</span><span class="s4">(</span><span class="s1">st_</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">delete</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">object</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Mark an instance as deleted. 
 
        The object is assumed to be either :term:`persistent` or 
        :term:`detached` when passed; after the method is called, the 
        object will remain in the :term:`persistent` state until the next 
        flush proceeds.  During this time, the object will also be a member 
        of the :attr:`_orm.Session.deleted` collection. 
 
        When the next flush proceeds, the object will move to the 
        :term:`deleted` state, indicating a ``DELETE`` statement was emitted 
        for its row within the current transaction.   When the transaction 
        is successfully committed, 
        the deleted object is moved to the :term:`detached` state and is 
        no longer present within this :class:`_orm.Session`. 
 
        .. seealso:: 
 
            :ref:`session_deleting` - at :ref:`session_basics` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_warn_on_events</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_flush_warning</span><span class="s4">(</span><span class="s5">&quot;Session.delete()&quot;</span><span class="s4">)</span>

        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">state </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_state</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">NO_STATE </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">UnmappedInstanceError</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_delete_impl</span><span class="s4">(</span><span class="s1">state</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">, </span><span class="s1">head</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_delete_impl</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">: </span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">obj</span><span class="s4">: </span><span class="s1">object</span><span class="s4">, </span><span class="s1">head</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">key </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">head</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                    <span class="s5">&quot;Instance '%s' is not persisted&quot; </span><span class="s4">% </span><span class="s1">state_str</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return</span>

        <span class="s1">to_attach </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_before_attach</span><span class="s4">(</span><span class="s1">state</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">state </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">:</span>
            <span class="s3">return</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">to_attach</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_after_attach</span><span class="s4">(</span><span class="s1">state</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">head</span><span class="s4">:</span>
            <span class="s0"># grab the cascades before adding the item to the deleted list</span>
            <span class="s0"># so that autoflush does not delete the item</span>
            <span class="s0"># the strong reference to the instance itself is significant here</span>
            <span class="s1">cascade_states </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span>
                <span class="s1">state</span><span class="s4">.</span><span class="s1">manager</span><span class="s4">.</span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">cascade_iterator</span><span class="s4">(</span><span class="s5">&quot;delete&quot;</span><span class="s4">, </span><span class="s1">state</span><span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">cascade_states </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">[</span><span class="s1">state</span><span class="s4">] = </span><span class="s1">obj</span>

        <span class="s3">if </span><span class="s1">head</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
                <span class="s3">assert </span><span class="s1">cascade_states </span><span class="s3">is not None</span>
            <span class="s3">for </span><span class="s1">o</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">st_</span><span class="s4">, </span><span class="s1">dct_ </span><span class="s3">in </span><span class="s1">cascade_states</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_delete_impl</span><span class="s4">(</span><span class="s1">st_</span><span class="s4">, </span><span class="s1">o</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">entity</span><span class="s4">: </span><span class="s1">_EntityBindKey</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">],</span>
        <span class="s1">ident</span><span class="s4">: </span><span class="s1">_PKIdentityArgument</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">options</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ORMOption</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">populate_existing</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">with_for_update</span><span class="s4">: </span><span class="s1">ForUpdateParameter </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">identity_token</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return an instance based on the given primary key identifier, 
        or ``None`` if not found. 
 
        E.g.:: 
 
            my_user = session.get(User, 5) 
 
            some_object = session.get(VersionedFoo, (5, 10)) 
 
            some_object = session.get( 
                VersionedFoo, 
                {&quot;id&quot;: 5, &quot;version_id&quot;: 10} 
            ) 
 
        .. versionadded:: 1.4 Added :meth:`_orm.Session.get`, which is moved 
           from the now legacy :meth:`_orm.Query.get` method. 
 
        :meth:`_orm.Session.get` is special in that it provides direct 
        access to the identity map of the :class:`.Session`. 
        If the given primary key identifier is present 
        in the local identity map, the object is returned 
        directly from this collection and no SQL is emitted, 
        unless the object has been marked fully expired. 
        If not present, 
        a SELECT is performed in order to locate the object. 
 
        :meth:`_orm.Session.get` also will perform a check if 
        the object is present in the identity map and 
        marked as expired - a SELECT 
        is emitted to refresh the object as well as to 
        ensure that the row is still present. 
        If not, :class:`~sqlalchemy.orm.exc.ObjectDeletedError` is raised. 
 
        :param entity: a mapped class or :class:`.Mapper` indicating the 
         type of entity to be loaded. 
 
        :param ident: A scalar, tuple, or dictionary representing the 
         primary key.  For a composite (e.g. multiple column) primary key, 
         a tuple or dictionary should be passed. 
 
         For a single-column primary key, the scalar calling form is typically 
         the most expedient.  If the primary key of a row is the value &quot;5&quot;, 
         the call looks like:: 
 
            my_object = session.get(SomeClass, 5) 
 
         The tuple form contains primary key values typically in 
         the order in which they correspond to the mapped 
         :class:`_schema.Table` 
         object's primary key columns, or if the 
         :paramref:`_orm.Mapper.primary_key` configuration parameter were 
         used, in 
         the order used for that parameter. For example, if the primary key 
         of a row is represented by the integer 
         digits &quot;5, 10&quot; the call would look like:: 
 
             my_object = session.get(SomeClass, (5, 10)) 
 
         The dictionary form should include as keys the mapped attribute names 
         corresponding to each element of the primary key.  If the mapped class 
         has the attributes ``id``, ``version_id`` as the attributes which 
         store the object's primary key value, the call would look like:: 
 
            my_object = session.get(SomeClass, {&quot;id&quot;: 5, &quot;version_id&quot;: 10}) 
 
        :param options: optional sequence of loader options which will be 
         applied to the query, if one is emitted. 
 
        :param populate_existing: causes the method to unconditionally emit 
         a SQL query and refresh the object with the newly loaded data, 
         regardless of whether or not the object is already present. 
 
        :param with_for_update: optional boolean ``True`` indicating FOR UPDATE 
          should be used, or may be a dictionary containing flags to 
          indicate a more specific set of FOR UPDATE flags for the SELECT; 
          flags should match the parameters of 
          :meth:`_query.Query.with_for_update`. 
          Supersedes the :paramref:`.Session.refresh.lockmode` parameter. 
 
        :param execution_options: optional dictionary of execution options, 
         which will be associated with the query execution if one is emitted. 
         This dictionary can provide a subset of the options that are 
         accepted by :meth:`_engine.Connection.execution_options`, and may 
         also provide additional options understood only in an ORM context. 
 
         .. versionadded:: 1.4.29 
 
         .. seealso:: 
 
            :ref:`orm_queryguide_execution_options` - ORM-specific execution 
            options 
 
        :param bind_arguments: dictionary of additional arguments to determine 
         the bind.  May include &quot;mapper&quot;, &quot;bind&quot;, or other custom arguments. 
         Contents of this dictionary are passed to the 
         :meth:`.Session.get_bind` method. 
 
         .. versionadded: 2.0.0rc1 
 
        :return: The object instance, or ``None``. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_impl</span><span class="s4">(</span>
            <span class="s1">entity</span><span class="s4">,</span>
            <span class="s1">ident</span><span class="s4">,</span>
            <span class="s1">loading</span><span class="s4">.</span><span class="s1">load_on_pk_identity</span><span class="s4">,</span>
            <span class="s1">options</span><span class="s4">=</span><span class="s1">options</span><span class="s4">,</span>
            <span class="s1">populate_existing</span><span class="s4">=</span><span class="s1">populate_existing</span><span class="s4">,</span>
            <span class="s1">with_for_update</span><span class="s4">=</span><span class="s1">with_for_update</span><span class="s4">,</span>
            <span class="s1">identity_token</span><span class="s4">=</span><span class="s1">identity_token</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">=</span><span class="s1">execution_options</span><span class="s4">,</span>
            <span class="s1">bind_arguments</span><span class="s4">=</span><span class="s1">bind_arguments</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_one</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">entity</span><span class="s4">: </span><span class="s1">_EntityBindKey</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">],</span>
        <span class="s1">ident</span><span class="s4">: </span><span class="s1">_PKIdentityArgument</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">options</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ORMOption</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">populate_existing</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">with_for_update</span><span class="s4">: </span><span class="s1">ForUpdateParameter </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">identity_token</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; _O</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return exactly one instance based on the given primary key 
        identifier, or raise an exception if not found. 
 
        Raises ``sqlalchemy.orm.exc.NoResultFound`` if the query 
        selects no rows. 
 
        For a detailed documentation of the arguments see the 
        method :meth:`.Session.get`. 
 
        .. versionadded:: 2.0.22 
 
        :return: The object instance. 
 
        .. seealso:: 
 
            :meth:`.Session.get` - equivalent method that instead 
              returns ``None`` if no row was found with the provided primary 
              key 
 
        &quot;&quot;&quot;</span>

        <span class="s1">instance </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span>
            <span class="s1">entity</span><span class="s4">,</span>
            <span class="s1">ident</span><span class="s4">,</span>
            <span class="s1">options</span><span class="s4">=</span><span class="s1">options</span><span class="s4">,</span>
            <span class="s1">populate_existing</span><span class="s4">=</span><span class="s1">populate_existing</span><span class="s4">,</span>
            <span class="s1">with_for_update</span><span class="s4">=</span><span class="s1">with_for_update</span><span class="s4">,</span>
            <span class="s1">identity_token</span><span class="s4">=</span><span class="s1">identity_token</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">=</span><span class="s1">execution_options</span><span class="s4">,</span>
            <span class="s1">bind_arguments</span><span class="s4">=</span><span class="s1">bind_arguments</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">instance </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">NoResultFound</span><span class="s4">(</span>
                <span class="s5">&quot;No row was found when one was required&quot;</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">instance</span>

    <span class="s3">def </span><span class="s1">_get_impl</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">entity</span><span class="s4">: </span><span class="s1">_EntityBindKey</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">],</span>
        <span class="s1">primary_key_identity</span><span class="s4">: </span><span class="s1">_PKIdentityArgument</span><span class="s4">,</span>
        <span class="s1">db_load_fn</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">_O</span><span class="s4">],</span>
        <span class="s4">*,</span>
        <span class="s1">options</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ExecutableOption</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">populate_existing</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">with_for_update</span><span class="s4">: </span><span class="s1">ForUpdateParameter </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">identity_token</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
        <span class="s1">bind_arguments</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_BindArguments</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">]:</span>
        <span class="s0"># convert composite types to individual args</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">is_composite_class</span><span class="s4">(</span><span class="s1">primary_key_identity</span><span class="s4">)</span>
            <span class="s3">and </span><span class="s1">type</span><span class="s4">(</span><span class="s1">primary_key_identity</span><span class="s4">)</span>
            <span class="s3">in </span><span class="s1">descriptor_props</span><span class="s4">.</span><span class="s1">_composite_getters</span>
        <span class="s4">):</span>
            <span class="s1">getter </span><span class="s4">= </span><span class="s1">descriptor_props</span><span class="s4">.</span><span class="s1">_composite_getters</span><span class="s4">[</span>
                <span class="s1">type</span><span class="s4">(</span><span class="s1">primary_key_identity</span><span class="s4">)</span>
            <span class="s4">]</span>
            <span class="s1">primary_key_identity </span><span class="s4">= </span><span class="s1">getter</span><span class="s4">(</span><span class="s1">primary_key_identity</span><span class="s4">)</span>

        <span class="s1">mapper</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Mapper</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">]] = </span><span class="s1">inspect</span><span class="s4">(</span><span class="s1">entity</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">mapper </span><span class="s3">is None or not </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">is_mapper</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                <span class="s5">&quot;Expected mapped class or mapper, got: %r&quot; </span><span class="s4">% </span><span class="s1">entity</span>
            <span class="s4">)</span>

        <span class="s1">is_dict </span><span class="s4">= </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">primary_key_identity</span><span class="s4">, </span><span class="s1">dict</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">is_dict</span><span class="s4">:</span>
            <span class="s1">primary_key_identity </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">to_list</span><span class="s4">(</span>
                <span class="s1">primary_key_identity</span><span class="s4">, </span><span class="s1">default</span><span class="s4">=[</span><span class="s3">None</span><span class="s4">]</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">primary_key_identity</span><span class="s4">) != </span><span class="s1">len</span><span class="s4">(</span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">primary_key</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;Incorrect number of values in identifier to formulate &quot;</span>
                <span class="s5">&quot;primary key for session.get(); primary key columns &quot;</span>
                <span class="s5">&quot;are %s&quot; </span><span class="s4">% </span><span class="s5">&quot;,&quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s5">&quot;'%s'&quot; </span><span class="s4">% </span><span class="s1">c </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">primary_key</span><span class="s4">)</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">is_dict</span><span class="s4">:</span>
            <span class="s1">pk_synonyms </span><span class="s4">= </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">_pk_synonyms</span>

            <span class="s3">if </span><span class="s1">pk_synonyms</span><span class="s4">:</span>
                <span class="s1">correct_keys </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">pk_synonyms</span><span class="s4">).</span><span class="s1">intersection</span><span class="s4">(</span>
                    <span class="s1">primary_key_identity</span>
                <span class="s4">)</span>

                <span class="s3">if </span><span class="s1">correct_keys</span><span class="s4">:</span>
                    <span class="s1">primary_key_identity </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">primary_key_identity</span><span class="s4">)</span>
                    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">correct_keys</span><span class="s4">:</span>
                        <span class="s1">primary_key_identity</span><span class="s4">[</span><span class="s1">pk_synonyms</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]] = (</span>
                            <span class="s1">primary_key_identity</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>
                        <span class="s4">)</span>

            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">primary_key_identity </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span>
                    <span class="s1">primary_key_identity</span><span class="s4">[</span><span class="s1">prop</span><span class="s4">.</span><span class="s1">key</span><span class="s4">]</span>
                    <span class="s3">for </span><span class="s1">prop </span><span class="s3">in </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">_identity_key_props</span>
                <span class="s4">)</span>

            <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                    <span class="s5">&quot;Incorrect names of values in identifier to formulate &quot;</span>
                    <span class="s5">&quot;primary key for session.get(); primary key attribute &quot;</span>
                    <span class="s5">&quot;names are %s (synonym names are also accepted)&quot;</span>
                    <span class="s4">% </span><span class="s5">&quot;,&quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
                        <span class="s5">&quot;'%s'&quot; </span><span class="s4">% </span><span class="s1">prop</span><span class="s4">.</span><span class="s1">key</span>
                        <span class="s3">for </span><span class="s1">prop </span><span class="s3">in </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">_identity_key_props</span>
                    <span class="s4">)</span>
                <span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>

        <span class="s3">if </span><span class="s4">(</span>
            <span class="s3">not </span><span class="s1">populate_existing</span>
            <span class="s3">and not </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">always_refresh</span>
            <span class="s3">and </span><span class="s1">with_for_update </span><span class="s3">is None</span>
        <span class="s4">):</span>
            <span class="s1">instance </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_identity_lookup</span><span class="s4">(</span>
                <span class="s1">mapper</span><span class="s4">,</span>
                <span class="s1">primary_key_identity</span><span class="s4">,</span>
                <span class="s1">identity_token</span><span class="s4">=</span><span class="s1">identity_token</span><span class="s4">,</span>
                <span class="s1">execution_options</span><span class="s4">=</span><span class="s1">execution_options</span><span class="s4">,</span>
                <span class="s1">bind_arguments</span><span class="s4">=</span><span class="s1">bind_arguments</span><span class="s4">,</span>
            <span class="s4">)</span>

            <span class="s3">if </span><span class="s1">instance </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s0"># reject calls for id in identity map but class</span>
                <span class="s0"># mismatch.</span>
                <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">, </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">class_</span><span class="s4">):</span>
                    <span class="s3">return None</span>
                <span class="s3">return </span><span class="s1">instance</span>

            <span class="s0"># TODO: this was being tested before, but this is not possible</span>
            <span class="s3">assert </span><span class="s1">instance </span><span class="s3">is not </span><span class="s1">LoaderCallableStatus</span><span class="s4">.</span><span class="s1">PASSIVE_CLASS_MISMATCH</span>

        <span class="s0"># set_label_style() not strictly necessary, however this will ensure</span>
        <span class="s0"># that tablename_colname style is used which at the moment is</span>
        <span class="s0"># asserted in a lot of unit tests :)</span>

        <span class="s1">load_options </span><span class="s4">= </span><span class="s1">context</span><span class="s4">.</span><span class="s1">QueryContext</span><span class="s4">.</span><span class="s1">default_load_options</span>

        <span class="s3">if </span><span class="s1">populate_existing</span><span class="s4">:</span>
            <span class="s1">load_options </span><span class="s4">+= {</span><span class="s5">&quot;_populate_existing&quot;</span><span class="s4">: </span><span class="s1">populate_existing</span><span class="s4">}</span>
        <span class="s1">statement </span><span class="s4">= </span><span class="s1">sql</span><span class="s4">.</span><span class="s1">select</span><span class="s4">(</span><span class="s1">mapper</span><span class="s4">).</span><span class="s1">set_label_style</span><span class="s4">(</span>
            <span class="s1">LABEL_STYLE_TABLENAME_PLUS_COL</span>
        <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">with_for_update </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">statement</span><span class="s4">.</span><span class="s1">_for_update_arg </span><span class="s4">= </span><span class="s1">ForUpdateArg</span><span class="s4">.</span><span class="s1">_from_argument</span><span class="s4">(</span>
                <span class="s1">with_for_update</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">options</span><span class="s4">:</span>
            <span class="s1">statement </span><span class="s4">= </span><span class="s1">statement</span><span class="s4">.</span><span class="s1">options</span><span class="s4">(*</span><span class="s1">options</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">db_load_fn</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">statement</span><span class="s4">,</span>
            <span class="s1">primary_key_identity</span><span class="s4">,</span>
            <span class="s1">load_options</span><span class="s4">=</span><span class="s1">load_options</span><span class="s4">,</span>
            <span class="s1">identity_token</span><span class="s4">=</span><span class="s1">identity_token</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">=</span><span class="s1">execution_options</span><span class="s4">,</span>
            <span class="s1">bind_arguments</span><span class="s4">=</span><span class="s1">bind_arguments</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">merge</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">instance</span><span class="s4">: </span><span class="s1">_O</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">load</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">options</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ORMOption</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; _O</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Copy the state of a given instance into a corresponding instance 
        within this :class:`.Session`. 
 
        :meth:`.Session.merge` examines the primary key attributes of the 
        source instance, and attempts to reconcile it with an instance of the 
        same primary key in the session.   If not found locally, it attempts 
        to load the object from the database based on primary key, and if 
        none can be located, creates a new instance.  The state of each 
        attribute on the source instance is then copied to the target 
        instance.  The resulting target instance is then returned by the 
        method; the original source instance is left unmodified, and 
        un-associated with the :class:`.Session` if not already. 
 
        This operation cascades to associated instances if the association is 
        mapped with ``cascade=&quot;merge&quot;``. 
 
        See :ref:`unitofwork_merging` for a detailed discussion of merging. 
 
        :param instance: Instance to be merged. 
        :param load: Boolean, when False, :meth:`.merge` switches into 
         a &quot;high performance&quot; mode which causes it to forego emitting history 
         events as well as all database access.  This flag is used for 
         cases such as transferring graphs of objects into a :class:`.Session` 
         from a second level cache, or to transfer just-loaded objects 
         into the :class:`.Session` owned by a worker thread or process 
         without re-querying the database. 
 
         The ``load=False`` use case adds the caveat that the given 
         object has to be in a &quot;clean&quot; state, that is, has no pending changes 
         to be flushed - even if the incoming object is detached from any 
         :class:`.Session`.   This is so that when 
         the merge operation populates local attributes and 
         cascades to related objects and 
         collections, the values can be &quot;stamped&quot; onto the 
         target object as is, without generating any history or attribute 
         events, and without the need to reconcile the incoming data with 
         any existing related objects or collections that might not 
         be loaded.  The resulting objects from ``load=False`` are always 
         produced as &quot;clean&quot;, so it is only appropriate that the given objects 
         should be &quot;clean&quot; as well, else this suggests a mis-use of the 
         method. 
        :param options: optional sequence of loader options which will be 
         applied to the :meth:`_orm.Session.get` method when the merge 
         operation loads the existing version of the object from the database. 
 
         .. versionadded:: 1.4.24 
 
 
        .. seealso:: 
 
            :func:`.make_transient_to_detached` - provides for an alternative 
            means of &quot;merging&quot; a single object into the :class:`.Session` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_warn_on_events</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_flush_warning</span><span class="s4">(</span><span class="s5">&quot;Session.merge()&quot;</span><span class="s4">)</span>

        <span class="s1">_recursive</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">object</span><span class="s4">] = {}</span>
        <span class="s1">_resolve_conflict_map</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">_IdentityKeyType</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">object</span><span class="s4">] = {}</span>

        <span class="s3">if </span><span class="s1">load</span><span class="s4">:</span>
            <span class="s0"># flush current contents if we expect to load data</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_autoflush</span><span class="s4">()</span>

        <span class="s1">object_mapper</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)  </span><span class="s0"># verify mapped</span>
        <span class="s1">autoflush </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">autoflush</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">autoflush </span><span class="s4">= </span><span class="s3">False</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_merge</span><span class="s4">(</span>
                <span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_state</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">),</span>
                <span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_dict</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">),</span>
                <span class="s1">load</span><span class="s4">=</span><span class="s1">load</span><span class="s4">,</span>
                <span class="s1">options</span><span class="s4">=</span><span class="s1">options</span><span class="s4">,</span>
                <span class="s1">_recursive</span><span class="s4">=</span><span class="s1">_recursive</span><span class="s4">,</span>
                <span class="s1">_resolve_conflict_map</span><span class="s4">=</span><span class="s1">_resolve_conflict_map</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">finally</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">autoflush </span><span class="s4">= </span><span class="s1">autoflush</span>

    <span class="s3">def </span><span class="s1">_merge</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">state</span><span class="s4">: </span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">],</span>
        <span class="s1">state_dict</span><span class="s4">: </span><span class="s1">_InstanceDict</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">options</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ORMOption</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">load</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
        <span class="s1">_recursive</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">object</span><span class="s4">],</span>
        <span class="s1">_resolve_conflict_map</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">_IdentityKeyType</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">object</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; _O</span><span class="s4">:</span>
        <span class="s1">mapper</span><span class="s4">: </span><span class="s1">Mapper</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">] = </span><span class="s1">_state_mapper</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">state </span><span class="s3">in </span><span class="s1">_recursive</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">cast</span><span class="s4">(</span><span class="s1">_O</span><span class="s4">, </span><span class="s1">_recursive</span><span class="s4">[</span><span class="s1">state</span><span class="s4">])</span>

        <span class="s1">new_instance </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s1">key </span><span class="s4">= </span><span class="s1">state</span><span class="s4">.</span><span class="s1">key</span>

        <span class="s1">merged</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">]</span>

        <span class="s3">if </span><span class="s1">key </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">state </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">:</span>
                <span class="s1">util</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                    <span class="s5">&quot;Instance %s is already pending in this Session yet is &quot;</span>
                    <span class="s5">&quot;being merged again; this is probably not what you want &quot;</span>
                    <span class="s5">&quot;to do&quot; </span><span class="s4">% </span><span class="s1">state_str</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
                <span class="s4">)</span>

            <span class="s3">if not </span><span class="s1">load</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                    <span class="s5">&quot;merge() with load=False option does not support &quot;</span>
                    <span class="s5">&quot;objects transient (i.e. unpersisted) objects.  flush() &quot;</span>
                    <span class="s5">&quot;all changes on mapped instances before merging with &quot;</span>
                    <span class="s5">&quot;load=False.&quot;</span>
                <span class="s4">)</span>
            <span class="s1">key </span><span class="s4">= </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">_identity_key_from_state</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
            <span class="s1">key_is_persistent </span><span class="s4">= </span><span class="s1">LoaderCallableStatus</span><span class="s4">.</span><span class="s1">NEVER_SET </span><span class="s3">not in </span><span class="s1">key</span><span class="s4">[</span>
                <span class="s6">1</span>
            <span class="s4">] </span><span class="s3">and </span><span class="s4">(</span>
                <span class="s3">not </span><span class="s1">_none_set</span><span class="s4">.</span><span class="s1">intersection</span><span class="s4">(</span><span class="s1">key</span><span class="s4">[</span><span class="s6">1</span><span class="s4">])</span>
                <span class="s3">or </span><span class="s4">(</span>
                    <span class="s1">mapper</span><span class="s4">.</span><span class="s1">allow_partial_pks</span>
                    <span class="s3">and not </span><span class="s1">_none_set</span><span class="s4">.</span><span class="s1">issuperset</span><span class="s4">(</span><span class="s1">key</span><span class="s4">[</span><span class="s6">1</span><span class="s4">])</span>
                <span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">key_is_persistent </span><span class="s4">= </span><span class="s3">True</span>

        <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">:</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">merged </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">[</span><span class="s1">key</span><span class="s4">]</span>
            <span class="s3">except </span><span class="s1">KeyError</span><span class="s4">:</span>
                <span class="s0"># object was GC'ed right as we checked for it</span>
                <span class="s1">merged </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">merged </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">merged </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">key_is_persistent </span><span class="s3">and </span><span class="s1">key </span><span class="s3">in </span><span class="s1">_resolve_conflict_map</span><span class="s4">:</span>
                <span class="s1">merged </span><span class="s4">= </span><span class="s1">cast</span><span class="s4">(</span><span class="s1">_O</span><span class="s4">, </span><span class="s1">_resolve_conflict_map</span><span class="s4">[</span><span class="s1">key</span><span class="s4">])</span>

            <span class="s3">elif not </span><span class="s1">load</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">modified</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                        <span class="s5">&quot;merge() with load=False option does not support &quot;</span>
                        <span class="s5">&quot;objects marked as 'dirty'.  flush() all changes on &quot;</span>
                        <span class="s5">&quot;mapped instances before merging with load=False.&quot;</span>
                    <span class="s4">)</span>
                <span class="s1">merged </span><span class="s4">= </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">class_manager</span><span class="s4">.</span><span class="s1">new_instance</span><span class="s4">()</span>
                <span class="s1">merged_state </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_state</span><span class="s4">(</span><span class="s1">merged</span><span class="s4">)</span>
                <span class="s1">merged_state</span><span class="s4">.</span><span class="s1">key </span><span class="s4">= </span><span class="s1">key</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_update_impl</span><span class="s4">(</span><span class="s1">merged_state</span><span class="s4">)</span>
                <span class="s1">new_instance </span><span class="s4">= </span><span class="s3">True</span>

            <span class="s3">elif </span><span class="s1">key_is_persistent</span><span class="s4">:</span>
                <span class="s1">merged </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span>
                    <span class="s1">mapper</span><span class="s4">.</span><span class="s1">class_</span><span class="s4">,</span>
                    <span class="s1">key</span><span class="s4">[</span><span class="s6">1</span><span class="s4">],</span>
                    <span class="s1">identity_token</span><span class="s4">=</span><span class="s1">key</span><span class="s4">[</span><span class="s6">2</span><span class="s4">],</span>
                    <span class="s1">options</span><span class="s4">=</span><span class="s1">options</span><span class="s4">,</span>
                <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">merged </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">merged </span><span class="s4">= </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">class_manager</span><span class="s4">.</span><span class="s1">new_instance</span><span class="s4">()</span>
            <span class="s1">merged_state </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_state</span><span class="s4">(</span><span class="s1">merged</span><span class="s4">)</span>
            <span class="s1">merged_dict </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_dict</span><span class="s4">(</span><span class="s1">merged</span><span class="s4">)</span>
            <span class="s1">new_instance </span><span class="s4">= </span><span class="s3">True</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_save_or_update_state</span><span class="s4">(</span><span class="s1">merged_state</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">merged_state </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_state</span><span class="s4">(</span><span class="s1">merged</span><span class="s4">)</span>
            <span class="s1">merged_dict </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_dict</span><span class="s4">(</span><span class="s1">merged</span><span class="s4">)</span>

        <span class="s1">_recursive</span><span class="s4">[</span><span class="s1">state</span><span class="s4">] = </span><span class="s1">merged</span>
        <span class="s1">_resolve_conflict_map</span><span class="s4">[</span><span class="s1">key</span><span class="s4">] = </span><span class="s1">merged</span>

        <span class="s0"># check that we didn't just pull the exact same</span>
        <span class="s0"># state out.</span>
        <span class="s3">if </span><span class="s1">state </span><span class="s3">is not </span><span class="s1">merged_state</span><span class="s4">:</span>
            <span class="s0"># version check if applicable</span>
            <span class="s3">if </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">version_id_col </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">existing_version </span><span class="s4">= </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">_get_state_attr_by_column</span><span class="s4">(</span>
                    <span class="s1">state</span><span class="s4">,</span>
                    <span class="s1">state_dict</span><span class="s4">,</span>
                    <span class="s1">mapper</span><span class="s4">.</span><span class="s1">version_id_col</span><span class="s4">,</span>
                    <span class="s1">passive</span><span class="s4">=</span><span class="s1">PassiveFlag</span><span class="s4">.</span><span class="s1">PASSIVE_NO_INITIALIZE</span><span class="s4">,</span>
                <span class="s4">)</span>

                <span class="s1">merged_version </span><span class="s4">= </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">_get_state_attr_by_column</span><span class="s4">(</span>
                    <span class="s1">merged_state</span><span class="s4">,</span>
                    <span class="s1">merged_dict</span><span class="s4">,</span>
                    <span class="s1">mapper</span><span class="s4">.</span><span class="s1">version_id_col</span><span class="s4">,</span>
                    <span class="s1">passive</span><span class="s4">=</span><span class="s1">PassiveFlag</span><span class="s4">.</span><span class="s1">PASSIVE_NO_INITIALIZE</span><span class="s4">,</span>
                <span class="s4">)</span>

                <span class="s3">if </span><span class="s4">(</span>
                    <span class="s1">existing_version</span>
                    <span class="s3">is not </span><span class="s1">LoaderCallableStatus</span><span class="s4">.</span><span class="s1">PASSIVE_NO_RESULT</span>
                    <span class="s3">and </span><span class="s1">merged_version</span>
                    <span class="s3">is not </span><span class="s1">LoaderCallableStatus</span><span class="s4">.</span><span class="s1">PASSIVE_NO_RESULT</span>
                    <span class="s3">and </span><span class="s1">existing_version </span><span class="s4">!= </span><span class="s1">merged_version</span>
                <span class="s4">):</span>
                    <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">StaleDataError</span><span class="s4">(</span>
                        <span class="s5">&quot;Version id '%s' on merged state %s &quot;</span>
                        <span class="s5">&quot;does not match existing version '%s'. &quot;</span>
                        <span class="s5">&quot;Leave the version attribute unset when &quot;</span>
                        <span class="s5">&quot;merging to update the most recent version.&quot;</span>
                        <span class="s4">% (</span>
                            <span class="s1">existing_version</span><span class="s4">,</span>
                            <span class="s1">state_str</span><span class="s4">(</span><span class="s1">merged_state</span><span class="s4">),</span>
                            <span class="s1">merged_version</span><span class="s4">,</span>
                        <span class="s4">)</span>
                    <span class="s4">)</span>

            <span class="s1">merged_state</span><span class="s4">.</span><span class="s1">load_path </span><span class="s4">= </span><span class="s1">state</span><span class="s4">.</span><span class="s1">load_path</span>
            <span class="s1">merged_state</span><span class="s4">.</span><span class="s1">load_options </span><span class="s4">= </span><span class="s1">state</span><span class="s4">.</span><span class="s1">load_options</span>

            <span class="s0"># since we are copying load_options, we need to copy</span>
            <span class="s0"># the callables_ that would have been generated by those</span>
            <span class="s0"># load_options.</span>
            <span class="s0"># assumes that the callables we put in state.callables_</span>
            <span class="s0"># are not instance-specific (which they should not be)</span>
            <span class="s1">merged_state</span><span class="s4">.</span><span class="s1">_copy_callables</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>

            <span class="s3">for </span><span class="s1">prop </span><span class="s3">in </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">iterate_properties</span><span class="s4">:</span>
                <span class="s1">prop</span><span class="s4">.</span><span class="s1">merge</span><span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">,</span>
                    <span class="s1">state</span><span class="s4">,</span>
                    <span class="s1">state_dict</span><span class="s4">,</span>
                    <span class="s1">merged_state</span><span class="s4">,</span>
                    <span class="s1">merged_dict</span><span class="s4">,</span>
                    <span class="s1">load</span><span class="s4">,</span>
                    <span class="s1">_recursive</span><span class="s4">,</span>
                    <span class="s1">_resolve_conflict_map</span><span class="s4">,</span>
                <span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">load</span><span class="s4">:</span>
            <span class="s0"># remove any history</span>
            <span class="s1">merged_state</span><span class="s4">.</span><span class="s1">_commit_all</span><span class="s4">(</span><span class="s1">merged_dict</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">)</span>
            <span class="s1">merged_state</span><span class="s4">.</span><span class="s1">manager</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">_sa_event_merge_wo_load</span><span class="s4">(</span>
                <span class="s1">merged_state</span><span class="s4">, </span><span class="s3">None</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">new_instance</span><span class="s4">:</span>
            <span class="s1">merged_state</span><span class="s4">.</span><span class="s1">manager</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">load</span><span class="s4">(</span><span class="s1">merged_state</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">merged</span>

    <span class="s3">def </span><span class="s1">_validate_persistent</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">: </span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">contains_state</span><span class="s4">(</span><span class="s1">state</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;Instance '%s' is not persistent within this Session&quot;</span>
                <span class="s4">% </span><span class="s1">state_str</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_save_impl</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">: </span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">key </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;Object '%s' already has an identity - &quot;</span>
                <span class="s5">&quot;it can't be registered as pending&quot; </span><span class="s4">% </span><span class="s1">state_str</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
            <span class="s4">)</span>

        <span class="s1">obj </span><span class="s4">= </span><span class="s1">state</span><span class="s4">.</span><span class="s1">obj</span><span class="s4">()</span>
        <span class="s1">to_attach </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_before_attach</span><span class="s4">(</span><span class="s1">state</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">state </span><span class="s3">not in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">[</span><span class="s1">state</span><span class="s4">] = </span><span class="s1">obj</span>
            <span class="s1">state</span><span class="s4">.</span><span class="s1">insert_order </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">to_attach</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_after_attach</span><span class="s4">(</span><span class="s1">state</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_update_impl</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">: </span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">revert_deletion</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">key </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;Instance '%s' is not persisted&quot; </span><span class="s4">% </span><span class="s1">state_str</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">revert_deletion</span><span class="s4">:</span>
                <span class="s3">if not </span><span class="s1">state</span><span class="s4">.</span><span class="s1">_attached</span><span class="s4">:</span>
                    <span class="s3">return</span>
                <span class="s3">del </span><span class="s1">state</span><span class="s4">.</span><span class="s1">_deleted</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                    <span class="s5">&quot;Instance '%s' has been deleted.  &quot;</span>
                    <span class="s5">&quot;Use the make_transient() &quot;</span>
                    <span class="s5">&quot;function to send this object back &quot;</span>
                    <span class="s5">&quot;to the transient state.&quot; </span><span class="s4">% </span><span class="s1">state_str</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
                <span class="s4">)</span>

        <span class="s1">obj </span><span class="s4">= </span><span class="s1">state</span><span class="s4">.</span><span class="s1">obj</span><span class="s4">()</span>

        <span class="s0"># check for late gc</span>
        <span class="s3">if </span><span class="s1">obj </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return</span>

        <span class="s1">to_attach </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_before_attach</span><span class="s4">(</span><span class="s1">state</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">state</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">revert_deletion</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">to_attach</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_after_attach</span><span class="s4">(</span><span class="s1">state</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">revert_deletion</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">deleted_to_persistent</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_save_or_update_impl</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">: </span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">key </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_save_impl</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_update_impl</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">enable_relationship_loading</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">: </span><span class="s1">object</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Associate an object with this :class:`.Session` for related 
        object loading. 
 
        .. warning:: 
 
            :meth:`.enable_relationship_loading` exists to serve special 
            use cases and is not recommended for general use. 
 
        Accesses of attributes mapped with :func:`_orm.relationship` 
        will attempt to load a value from the database using this 
        :class:`.Session` as the source of connectivity.  The values 
        will be loaded based on foreign key and primary key values 
        present on this object - if not present, then those relationships 
        will be unavailable. 
 
        The object will be attached to this session, but will 
        **not** participate in any persistence operations; its state 
        for almost all purposes will remain either &quot;transient&quot; or 
        &quot;detached&quot;, except for the case of relationship loading. 
 
        Also note that backrefs will often not work as expected. 
        Altering a relationship-bound attribute on the target object 
        may not fire off a backref event, if the effective value 
        is what was already loaded from a foreign-key-holding value. 
 
        The :meth:`.Session.enable_relationship_loading` method is 
        similar to the ``load_on_pending`` flag on :func:`_orm.relationship`. 
        Unlike that flag, :meth:`.Session.enable_relationship_loading` allows 
        an object to remain transient while still being able to load 
        related items. 
 
        To make a transient object associated with a :class:`.Session` 
        via :meth:`.Session.enable_relationship_loading` pending, add 
        it to the :class:`.Session` using :meth:`.Session.add` normally. 
        If the object instead represents an existing identity in the database, 
        it should be merged using :meth:`.Session.merge`. 
 
        :meth:`.Session.enable_relationship_loading` does not improve 
        behavior when the ORM is used normally - object references should be 
        constructed at the object level, not at the foreign key level, so 
        that they are present in an ordinary way before flush() 
        proceeds.  This method is not intended for general use. 
 
        .. seealso:: 
 
            :paramref:`_orm.relationship.load_on_pending` - this flag 
            allows per-relationship loading of many-to-ones on items that 
            are pending. 
 
            :func:`.make_transient_to_detached` - allows for an object to 
            be added to a :class:`.Session` without SQL emitted, which then 
            will unexpire attributes on access. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">state </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_state</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">NO_STATE </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">UnmappedInstanceError</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>

        <span class="s1">to_attach </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_before_attach</span><span class="s4">(</span><span class="s1">state</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">)</span>
        <span class="s1">state</span><span class="s4">.</span><span class="s1">_load_pending </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s3">if </span><span class="s1">to_attach</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_after_attach</span><span class="s4">(</span><span class="s1">state</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_before_attach</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">: </span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">obj</span><span class="s4">: </span><span class="s1">object</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_autobegin_t</span><span class="s4">()</span>

        <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">session_id </span><span class="s4">== </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hash_key</span><span class="s4">:</span>
            <span class="s3">return False</span>

        <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">session_id </span><span class="s3">and </span><span class="s1">state</span><span class="s4">.</span><span class="s1">session_id </span><span class="s3">in </span><span class="s1">_sessions</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;Object '%s' is already attached to session '%s' &quot;</span>
                <span class="s5">&quot;(this is '%s')&quot;</span>
                <span class="s4">% (</span><span class="s1">state_str</span><span class="s4">(</span><span class="s1">state</span><span class="s4">), </span><span class="s1">state</span><span class="s4">.</span><span class="s1">session_id</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hash_key</span><span class="s4">)</span>
            <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">before_attach</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">)</span>

        <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">_after_attach</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">: </span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">obj</span><span class="s4">: </span><span class="s1">object</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">state</span><span class="s4">.</span><span class="s1">session_id </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hash_key</span>
        <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">modified </span><span class="s3">and </span><span class="s1">state</span><span class="s4">.</span><span class="s1">_strong_obj </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">state</span><span class="s4">.</span><span class="s1">_strong_obj </span><span class="s4">= </span><span class="s1">obj</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">after_attach</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">key</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">detached_to_persistent</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">transient_to_pending</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__contains__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">object</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return True if the instance is associated with this session. 
 
        The instance may be pending or persistent within the Session for a 
        result of True. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">state </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_state</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">NO_STATE </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">UnmappedInstanceError</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_contains_state</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__iter__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">object</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Iterate over all pending or persistent instances within this 
        Session. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">iter</span><span class="s4">(</span>
            <span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">.</span><span class="s1">values</span><span class="s4">()) + </span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">values</span><span class="s4">())</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_contains_state</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">: </span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">state </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_new </span><span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">contains_state</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">flush</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">objects</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Flush all the object changes to the database. 
 
        Writes out all pending object creations, deletions and modifications 
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are 
        automatically ordered by the Session's unit of work dependency 
        solver. 
 
        Database operations will be issued in the current transactional 
        context and do not affect the state of the transaction, unless an 
        error occurs, in which case the entire transaction is rolled back. 
        You may flush() as often as you like within a transaction to move 
        changes from Python to the database's transaction buffer. 
 
        :param objects: Optional; restricts the flush operation to operate 
          only on elements that are in the given collection. 
 
          This feature is for an extremely narrow set of use cases where 
          particular objects may need to be operated upon before the 
          full flush() occurs.  It is not intended for general use. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_flushing</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span><span class="s5">&quot;Session is already flushing&quot;</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_clean</span><span class="s4">():</span>
            <span class="s3">return</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_flushing </span><span class="s4">= </span><span class="s3">True</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_flush</span><span class="s4">(</span><span class="s1">objects</span><span class="s4">)</span>
        <span class="s3">finally</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_flushing </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">_flush_warning</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">method</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">util</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
            <span class="s5">&quot;Usage of the '%s' operation is not currently supported &quot;</span>
            <span class="s5">&quot;within the execution stage of the flush process. &quot;</span>
            <span class="s5">&quot;Results may not be consistent.  Consider using alternative &quot;</span>
            <span class="s5">&quot;event listeners or connection-level operations instead.&quot; </span><span class="s4">% </span><span class="s1">method</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_is_clean</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s3">not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">check_modified</span><span class="s4">()</span>
            <span class="s3">and not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted</span>
            <span class="s3">and not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_flush</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">objects</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">object</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">dirty </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dirty_states</span>
        <span class="s3">if not </span><span class="s1">dirty </span><span class="s3">and not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted </span><span class="s3">and not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">_modified</span><span class="s4">.</span><span class="s1">clear</span><span class="s4">()</span>
            <span class="s3">return</span>

        <span class="s1">flush_context </span><span class="s4">= </span><span class="s1">UOWTransaction</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">before_flush</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">before_flush</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">flush_context</span><span class="s4">, </span><span class="s1">objects</span><span class="s4">)</span>
            <span class="s0"># re-establish &quot;dirty states&quot; in case the listeners</span>
            <span class="s0"># added</span>
            <span class="s1">dirty </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dirty_states</span>

        <span class="s1">deleted </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">)</span>
        <span class="s1">new </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">)</span>

        <span class="s1">dirty </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">dirty</span><span class="s4">).</span><span class="s1">difference</span><span class="s4">(</span><span class="s1">deleted</span><span class="s4">)</span>

        <span class="s0"># create the set of all objects we want to operate upon</span>
        <span class="s3">if </span><span class="s1">objects</span><span class="s4">:</span>
            <span class="s0"># specific list passed in</span>
            <span class="s1">objset </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()</span>
            <span class="s3">for </span><span class="s1">o </span><span class="s3">in </span><span class="s1">objects</span><span class="s4">:</span>
                <span class="s3">try</span><span class="s4">:</span>
                    <span class="s1">state </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_state</span><span class="s4">(</span><span class="s1">o</span><span class="s4">)</span>

                <span class="s3">except </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">NO_STATE </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">UnmappedInstanceError</span><span class="s4">(</span><span class="s1">o</span><span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>
                <span class="s1">objset</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">objset </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s0"># store objects whose fate has been decided</span>
        <span class="s1">processed </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()</span>

        <span class="s0"># put all saves/updates into the flush context.  detect top-level</span>
        <span class="s0"># orphans and throw them into deleted.</span>
        <span class="s3">if </span><span class="s1">objset</span><span class="s4">:</span>
            <span class="s1">proc </span><span class="s4">= </span><span class="s1">new</span><span class="s4">.</span><span class="s1">union</span><span class="s4">(</span><span class="s1">dirty</span><span class="s4">).</span><span class="s1">intersection</span><span class="s4">(</span><span class="s1">objset</span><span class="s4">).</span><span class="s1">difference</span><span class="s4">(</span><span class="s1">deleted</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">proc </span><span class="s4">= </span><span class="s1">new</span><span class="s4">.</span><span class="s1">union</span><span class="s4">(</span><span class="s1">dirty</span><span class="s4">).</span><span class="s1">difference</span><span class="s4">(</span><span class="s1">deleted</span><span class="s4">)</span>

        <span class="s3">for </span><span class="s1">state </span><span class="s3">in </span><span class="s1">proc</span><span class="s4">:</span>
            <span class="s1">is_orphan </span><span class="s4">= </span><span class="s1">_state_mapper</span><span class="s4">(</span><span class="s1">state</span><span class="s4">).</span><span class="s1">_is_orphan</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>

            <span class="s1">is_persistent_orphan </span><span class="s4">= </span><span class="s1">is_orphan </span><span class="s3">and </span><span class="s1">state</span><span class="s4">.</span><span class="s1">has_identity</span>

            <span class="s3">if </span><span class="s4">(</span>
                <span class="s1">is_orphan</span>
                <span class="s3">and not </span><span class="s1">is_persistent_orphan</span>
                <span class="s3">and </span><span class="s1">state</span><span class="s4">.</span><span class="s1">_orphaned_outside_of_session</span>
            <span class="s4">):</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_expunge_states</span><span class="s4">([</span><span class="s1">state</span><span class="s4">])</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">_reg </span><span class="s4">= </span><span class="s1">flush_context</span><span class="s4">.</span><span class="s1">register_object</span><span class="s4">(</span>
                    <span class="s1">state</span><span class="s4">, </span><span class="s1">isdelete</span><span class="s4">=</span><span class="s1">is_persistent_orphan</span>
                <span class="s4">)</span>
                <span class="s3">assert </span><span class="s1">_reg</span><span class="s4">, </span><span class="s5">&quot;Failed to add object to the flush context!&quot;</span>
                <span class="s1">processed</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>

        <span class="s0"># put all remaining deletes into the flush context.</span>
        <span class="s3">if </span><span class="s1">objset</span><span class="s4">:</span>
            <span class="s1">proc </span><span class="s4">= </span><span class="s1">deleted</span><span class="s4">.</span><span class="s1">intersection</span><span class="s4">(</span><span class="s1">objset</span><span class="s4">).</span><span class="s1">difference</span><span class="s4">(</span><span class="s1">processed</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">proc </span><span class="s4">= </span><span class="s1">deleted</span><span class="s4">.</span><span class="s1">difference</span><span class="s4">(</span><span class="s1">processed</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">state </span><span class="s3">in </span><span class="s1">proc</span><span class="s4">:</span>
            <span class="s1">_reg </span><span class="s4">= </span><span class="s1">flush_context</span><span class="s4">.</span><span class="s1">register_object</span><span class="s4">(</span><span class="s1">state</span><span class="s4">, </span><span class="s1">isdelete</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
            <span class="s3">assert </span><span class="s1">_reg</span><span class="s4">, </span><span class="s5">&quot;Failed to add object to the flush context!&quot;</span>

        <span class="s3">if not </span><span class="s1">flush_context</span><span class="s4">.</span><span class="s1">has_work</span><span class="s4">:</span>
            <span class="s3">return</span>

        <span class="s1">flush_context</span><span class="s4">.</span><span class="s1">transaction </span><span class="s4">= </span><span class="s1">transaction </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_autobegin_t</span><span class="s4">().</span><span class="s1">_begin</span><span class="s4">()</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_warn_on_events </span><span class="s4">= </span><span class="s3">True</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">flush_context</span><span class="s4">.</span><span class="s1">execute</span><span class="s4">()</span>
            <span class="s3">finally</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_warn_on_events </span><span class="s4">= </span><span class="s3">False</span>

            <span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">after_flush</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">flush_context</span><span class="s4">)</span>

            <span class="s1">flush_context</span><span class="s4">.</span><span class="s1">finalize_flush_changes</span><span class="s4">()</span>

            <span class="s3">if not </span><span class="s1">objects </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">_modified</span><span class="s4">:</span>
                <span class="s1">len_ </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">_modified</span><span class="s4">)</span>

                <span class="s1">statelib</span><span class="s4">.</span><span class="s1">InstanceState</span><span class="s4">.</span><span class="s1">_commit_all_states</span><span class="s4">(</span>
                    <span class="s4">[</span>
                        <span class="s4">(</span><span class="s1">state</span><span class="s4">, </span><span class="s1">state</span><span class="s4">.</span><span class="s1">dict</span><span class="s4">)</span>
                        <span class="s3">for </span><span class="s1">state </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">_modified</span>
                    <span class="s4">],</span>
                    <span class="s1">instance_dict</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">,</span>
                <span class="s4">)</span>
                <span class="s1">util</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                    <span class="s5">&quot;Attribute history events accumulated on %d &quot;</span>
                    <span class="s5">&quot;previously clean instances &quot;</span>
                    <span class="s5">&quot;within inner-flush event handlers have been &quot;</span>
                    <span class="s5">&quot;reset, and will not result in database updates. &quot;</span>
                    <span class="s5">&quot;Consider using set_committed_value() within &quot;</span>
                    <span class="s5">&quot;inner-flush event handlers to avoid this warning.&quot; </span><span class="s4">% </span><span class="s1">len_</span>
                <span class="s4">)</span>

            <span class="s0"># useful assertions:</span>
            <span class="s0"># if not objects:</span>
            <span class="s0">#    assert not self.identity_map._modified</span>
            <span class="s0"># else:</span>
            <span class="s0">#    assert self.identity_map._modified == \</span>
            <span class="s0">#            self.identity_map._modified.difference(objects)</span>

            <span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">after_flush_postexec</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">flush_context</span><span class="s4">)</span>

            <span class="s1">transaction</span><span class="s4">.</span><span class="s1">commit</span><span class="s4">()</span>

        <span class="s3">except</span><span class="s4">:</span>
            <span class="s3">with </span><span class="s1">util</span><span class="s4">.</span><span class="s1">safe_reraise</span><span class="s4">():</span>
                <span class="s1">transaction</span><span class="s4">.</span><span class="s1">rollback</span><span class="s4">(</span><span class="s1">_capture_exception</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">bulk_save_objects</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">objects</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">object</span><span class="s4">],</span>
        <span class="s1">return_defaults</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">update_changed_only</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">preserve_order</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Perform a bulk save of the given list of objects. 
 
        .. legacy:: 
 
            This method is a legacy feature as of the 2.0 series of 
            SQLAlchemy.   For modern bulk INSERT and UPDATE, see 
            the sections :ref:`orm_queryguide_bulk_insert` and 
            :ref:`orm_queryguide_bulk_update`. 
 
            For general INSERT and UPDATE of existing ORM mapped objects, 
            prefer standard :term:`unit of work` data management patterns, 
            introduced in the :ref:`unified_tutorial` at 
            :ref:`tutorial_orm_data_manipulation`.  SQLAlchemy 2.0 
            now uses :ref:`engine_insertmanyvalues` with modern dialects 
            which solves previous issues of bulk INSERT slowness. 
 
        :param objects: a sequence of mapped object instances.  The mapped 
         objects are persisted as is, and are **not** associated with the 
         :class:`.Session` afterwards. 
 
         For each object, whether the object is sent as an INSERT or an 
         UPDATE is dependent on the same rules used by the :class:`.Session` 
         in traditional operation; if the object has the 
         :attr:`.InstanceState.key` 
         attribute set, then the object is assumed to be &quot;detached&quot; and 
         will result in an UPDATE.  Otherwise, an INSERT is used. 
 
         In the case of an UPDATE, statements are grouped based on which 
         attributes have changed, and are thus to be the subject of each 
         SET clause.  If ``update_changed_only`` is False, then all 
         attributes present within each object are applied to the UPDATE 
         statement, which may help in allowing the statements to be grouped 
         together into a larger executemany(), and will also reduce the 
         overhead of checking history on attributes. 
 
        :param return_defaults: when True, rows that are missing values which 
         generate defaults, namely integer primary key defaults and sequences, 
         will be inserted **one at a time**, so that the primary key value 
         is available.  In particular this will allow joined-inheritance 
         and other multi-table mappings to insert correctly without the need 
         to provide primary key values ahead of time; however, 
         :paramref:`.Session.bulk_save_objects.return_defaults` **greatly 
         reduces the performance gains** of the method overall.  It is strongly 
         advised to please use the standard :meth:`_orm.Session.add_all` 
         approach. 
 
        :param update_changed_only: when True, UPDATE statements are rendered 
         based on those attributes in each state that have logged changes. 
         When False, all attributes present are rendered into the SET clause 
         with the exception of primary key attributes. 
 
        :param preserve_order: when True, the order of inserts and updates 
         matches exactly the order in which the objects are given.   When 
         False, common types of objects are grouped into inserts 
         and updates, to allow for more batching opportunities. 
 
        .. seealso:: 
 
            :doc:`queryguide/dml` 
 
            :meth:`.Session.bulk_insert_mappings` 
 
            :meth:`.Session.bulk_update_mappings` 
 
        &quot;&quot;&quot;</span>

        <span class="s1">obj_states</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>

        <span class="s1">obj_states </span><span class="s4">= (</span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_state</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">) </span><span class="s3">for </span><span class="s1">obj </span><span class="s3">in </span><span class="s1">objects</span><span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">preserve_order</span><span class="s4">:</span>
            <span class="s0"># the purpose of this sort is just so that common mappers</span>
            <span class="s0"># and persistence states are grouped together, so that groupby</span>
            <span class="s0"># will return a single group for a particular type of mapper.</span>
            <span class="s0"># it's not trying to be deterministic beyond that.</span>
            <span class="s1">obj_states </span><span class="s4">= </span><span class="s1">sorted</span><span class="s4">(</span>
                <span class="s1">obj_states</span><span class="s4">,</span>
                <span class="s1">key</span><span class="s4">=</span><span class="s3">lambda </span><span class="s1">state</span><span class="s4">: (</span><span class="s1">id</span><span class="s4">(</span><span class="s1">state</span><span class="s4">.</span><span class="s1">mapper</span><span class="s4">), </span><span class="s1">state</span><span class="s4">.</span><span class="s1">key </span><span class="s3">is not None</span><span class="s4">),</span>
            <span class="s4">)</span>

        <span class="s3">def </span><span class="s1">grouping_key</span><span class="s4">(</span>
            <span class="s1">state</span><span class="s4">: </span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">],</span>
        <span class="s4">) </span><span class="s1">-&gt; Tuple</span><span class="s4">[</span><span class="s1">Mapper</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">], </span><span class="s1">bool</span><span class="s4">]:</span>
            <span class="s3">return </span><span class="s4">(</span><span class="s1">state</span><span class="s4">.</span><span class="s1">mapper</span><span class="s4">, </span><span class="s1">state</span><span class="s4">.</span><span class="s1">key </span><span class="s3">is not None</span><span class="s4">)</span>

        <span class="s3">for </span><span class="s4">(</span><span class="s1">mapper</span><span class="s4">, </span><span class="s1">isupdate</span><span class="s4">), </span><span class="s1">states </span><span class="s3">in </span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">groupby</span><span class="s4">(</span>
            <span class="s1">obj_states</span><span class="s4">, </span><span class="s1">grouping_key</span>
        <span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_bulk_save_mappings</span><span class="s4">(</span>
                <span class="s1">mapper</span><span class="s4">,</span>
                <span class="s1">states</span><span class="s4">,</span>
                <span class="s1">isupdate</span><span class="s4">=</span><span class="s1">isupdate</span><span class="s4">,</span>
                <span class="s1">isstates</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                <span class="s1">return_defaults</span><span class="s4">=</span><span class="s1">return_defaults</span><span class="s4">,</span>
                <span class="s1">update_changed_only</span><span class="s4">=</span><span class="s1">update_changed_only</span><span class="s4">,</span>
                <span class="s1">render_nulls</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">bulk_insert_mappings</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">mapper</span><span class="s4">: </span><span class="s1">Mapper</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">mappings</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]],</span>
        <span class="s1">return_defaults</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">render_nulls</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Perform a bulk insert of the given list of mapping dictionaries. 
 
        .. legacy:: 
 
            This method is a legacy feature as of the 2.0 series of 
            SQLAlchemy.   For modern bulk INSERT and UPDATE, see 
            the sections :ref:`orm_queryguide_bulk_insert` and 
            :ref:`orm_queryguide_bulk_update`.  The 2.0 API shares 
            implementation details with this method and adds new features 
            as well. 
 
        :param mapper: a mapped class, or the actual :class:`_orm.Mapper` 
         object, 
         representing the single kind of object represented within the mapping 
         list. 
 
        :param mappings: a sequence of dictionaries, each one containing the 
         state of the mapped row to be inserted, in terms of the attribute 
         names on the mapped class.   If the mapping refers to multiple tables, 
         such as a joined-inheritance mapping, each dictionary must contain all 
         keys to be populated into all tables. 
 
        :param return_defaults: when True, the INSERT process will be altered 
         to ensure that newly generated primary key values will be fetched. 
         The rationale for this parameter is typically to enable 
         :ref:`Joined Table Inheritance &lt;joined_inheritance&gt;` mappings to 
         be bulk inserted. 
 
         .. note:: for backends that don't support RETURNING, the 
            :paramref:`_orm.Session.bulk_insert_mappings.return_defaults` 
            parameter can significantly decrease performance as INSERT 
            statements can no longer be batched.   See 
            :ref:`engine_insertmanyvalues` 
            for background on which backends are affected. 
 
        :param render_nulls: When True, a value of ``None`` will result 
         in a NULL value being included in the INSERT statement, rather 
         than the column being omitted from the INSERT.   This allows all 
         the rows being INSERTed to have the identical set of columns which 
         allows the full set of rows to be batched to the DBAPI.  Normally, 
         each column-set that contains a different combination of NULL values 
         than the previous row must omit a different series of columns from 
         the rendered INSERT statement, which means it must be emitted as a 
         separate statement.   By passing this flag, the full set of rows 
         are guaranteed to be batchable into one batch; the cost however is 
         that server-side defaults which are invoked by an omitted column will 
         be skipped, so care must be taken to ensure that these are not 
         necessary. 
 
         .. warning:: 
 
            When this flag is set, **server side default SQL values will 
            not be invoked** for those columns that are inserted as NULL; 
            the NULL value will be sent explicitly.   Care must be taken 
            to ensure that no server-side default functions need to be 
            invoked for the operation as a whole. 
 
        .. seealso:: 
 
            :doc:`queryguide/dml` 
 
            :meth:`.Session.bulk_save_objects` 
 
            :meth:`.Session.bulk_update_mappings` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_bulk_save_mappings</span><span class="s4">(</span>
            <span class="s1">mapper</span><span class="s4">,</span>
            <span class="s1">mappings</span><span class="s4">,</span>
            <span class="s1">isupdate</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">isstates</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">return_defaults</span><span class="s4">=</span><span class="s1">return_defaults</span><span class="s4">,</span>
            <span class="s1">update_changed_only</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">render_nulls</span><span class="s4">=</span><span class="s1">render_nulls</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">bulk_update_mappings</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">mapper</span><span class="s4">: </span><span class="s1">Mapper</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">mappings</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]]</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Perform a bulk update of the given list of mapping dictionaries. 
 
        .. legacy:: 
 
            This method is a legacy feature as of the 2.0 series of 
            SQLAlchemy.   For modern bulk INSERT and UPDATE, see 
            the sections :ref:`orm_queryguide_bulk_insert` and 
            :ref:`orm_queryguide_bulk_update`.  The 2.0 API shares 
            implementation details with this method and adds new features 
            as well. 
 
        :param mapper: a mapped class, or the actual :class:`_orm.Mapper` 
         object, 
         representing the single kind of object represented within the mapping 
         list. 
 
        :param mappings: a sequence of dictionaries, each one containing the 
         state of the mapped row to be updated, in terms of the attribute names 
         on the mapped class.   If the mapping refers to multiple tables, such 
         as a joined-inheritance mapping, each dictionary may contain keys 
         corresponding to all tables.   All those keys which are present and 
         are not part of the primary key are applied to the SET clause of the 
         UPDATE statement; the primary key values, which are required, are 
         applied to the WHERE clause. 
 
 
        .. seealso:: 
 
            :doc:`queryguide/dml` 
 
            :meth:`.Session.bulk_insert_mappings` 
 
            :meth:`.Session.bulk_save_objects` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_bulk_save_mappings</span><span class="s4">(</span>
            <span class="s1">mapper</span><span class="s4">,</span>
            <span class="s1">mappings</span><span class="s4">,</span>
            <span class="s1">isupdate</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s1">isstates</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">return_defaults</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">update_changed_only</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">render_nulls</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_bulk_save_mappings</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">mapper</span><span class="s4">: </span><span class="s1">Mapper</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">],</span>
        <span class="s1">mappings</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">]], </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]]],</span>
        <span class="s4">*,</span>
        <span class="s1">isupdate</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
        <span class="s1">isstates</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
        <span class="s1">return_defaults</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
        <span class="s1">update_changed_only</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
        <span class="s1">render_nulls</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">mapper </span><span class="s4">= </span><span class="s1">_class_to_mapper</span><span class="s4">(</span><span class="s1">mapper</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_flushing </span><span class="s4">= </span><span class="s3">True</span>

        <span class="s1">transaction </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_autobegin_t</span><span class="s4">().</span><span class="s1">_begin</span><span class="s4">()</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">isupdate</span><span class="s4">:</span>
                <span class="s1">bulk_persistence</span><span class="s4">.</span><span class="s1">_bulk_update</span><span class="s4">(</span>
                    <span class="s1">mapper</span><span class="s4">,</span>
                    <span class="s1">mappings</span><span class="s4">,</span>
                    <span class="s1">transaction</span><span class="s4">,</span>
                    <span class="s1">isstates</span><span class="s4">=</span><span class="s1">isstates</span><span class="s4">,</span>
                    <span class="s1">update_changed_only</span><span class="s4">=</span><span class="s1">update_changed_only</span><span class="s4">,</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">bulk_persistence</span><span class="s4">.</span><span class="s1">_bulk_insert</span><span class="s4">(</span>
                    <span class="s1">mapper</span><span class="s4">,</span>
                    <span class="s1">mappings</span><span class="s4">,</span>
                    <span class="s1">transaction</span><span class="s4">,</span>
                    <span class="s1">isstates</span><span class="s4">=</span><span class="s1">isstates</span><span class="s4">,</span>
                    <span class="s1">return_defaults</span><span class="s4">=</span><span class="s1">return_defaults</span><span class="s4">,</span>
                    <span class="s1">render_nulls</span><span class="s4">=</span><span class="s1">render_nulls</span><span class="s4">,</span>
                <span class="s4">)</span>
            <span class="s1">transaction</span><span class="s4">.</span><span class="s1">commit</span><span class="s4">()</span>

        <span class="s3">except</span><span class="s4">:</span>
            <span class="s3">with </span><span class="s1">util</span><span class="s4">.</span><span class="s1">safe_reraise</span><span class="s4">():</span>
                <span class="s1">transaction</span><span class="s4">.</span><span class="s1">rollback</span><span class="s4">(</span><span class="s1">_capture_exception</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
        <span class="s3">finally</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_flushing </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">is_modified</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">object</span><span class="s4">, </span><span class="s1">include_collections</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return ``True`` if the given instance has locally 
        modified attributes. 
 
        This method retrieves the history for each instrumented 
        attribute on the instance and performs a comparison of the current 
        value to its previously flushed or committed value, if any. 
 
        It is in effect a more expensive and accurate 
        version of checking for the given instance in the 
        :attr:`.Session.dirty` collection; a full test for 
        each attribute's net &quot;dirty&quot; status is performed. 
 
        E.g.:: 
 
            return session.is_modified(someobject) 
 
        A few caveats to this method apply: 
 
        * Instances present in the :attr:`.Session.dirty` collection may 
          report ``False`` when tested with this method.  This is because 
          the object may have received change events via attribute mutation, 
          thus placing it in :attr:`.Session.dirty`, but ultimately the state 
          is the same as that loaded from the database, resulting in no net 
          change here. 
        * Scalar attributes may not have recorded the previously set 
          value when a new value was applied, if the attribute was not loaded, 
          or was expired, at the time the new value was received - in these 
          cases, the attribute is assumed to have a change, even if there is 
          ultimately no net change against its database value. SQLAlchemy in 
          most cases does not need the &quot;old&quot; value when a set event occurs, so 
          it skips the expense of a SQL call if the old value isn't present, 
          based on the assumption that an UPDATE of the scalar value is 
          usually needed, and in those few cases where it isn't, is less 
          expensive on average than issuing a defensive SELECT. 
 
          The &quot;old&quot; value is fetched unconditionally upon set only if the 
          attribute container has the ``active_history`` flag set to ``True``. 
          This flag is set typically for primary key attributes and scalar 
          object references that are not a simple many-to-one.  To set this 
          flag for any arbitrary mapped column, use the ``active_history`` 
          argument with :func:`.column_property`. 
 
        :param instance: mapped instance to be tested for pending changes. 
        :param include_collections: Indicates if multivalued collections 
         should be included in the operation.  Setting this to ``False`` is a 
         way to detect only local-column based properties (i.e. scalar columns 
         or many-to-one foreign keys) that would result in an UPDATE for this 
         instance upon flush. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">state </span><span class="s4">= </span><span class="s1">object_state</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">state</span><span class="s4">.</span><span class="s1">modified</span><span class="s4">:</span>
            <span class="s3">return False</span>

        <span class="s1">dict_ </span><span class="s4">= </span><span class="s1">state</span><span class="s4">.</span><span class="s1">dict</span>

        <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">state</span><span class="s4">.</span><span class="s1">manager</span><span class="s4">.</span><span class="s1">attributes</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s4">(</span>
                <span class="s3">not </span><span class="s1">include_collections</span>
                <span class="s3">and </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">.</span><span class="s1">impl</span><span class="s4">, </span><span class="s5">&quot;get_collection&quot;</span><span class="s4">)</span>
            <span class="s4">) </span><span class="s3">or not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">.</span><span class="s1">impl</span><span class="s4">, </span><span class="s5">&quot;get_history&quot;</span><span class="s4">):</span>
                <span class="s3">continue</span>

            <span class="s4">(</span><span class="s1">added</span><span class="s4">, </span><span class="s1">unchanged</span><span class="s4">, </span><span class="s1">deleted</span><span class="s4">) = </span><span class="s1">attr</span><span class="s4">.</span><span class="s1">impl</span><span class="s4">.</span><span class="s1">get_history</span><span class="s4">(</span>
                <span class="s1">state</span><span class="s4">, </span><span class="s1">dict_</span><span class="s4">, </span><span class="s1">passive</span><span class="s4">=</span><span class="s1">PassiveFlag</span><span class="s4">.</span><span class="s1">NO_CHANGE</span>
            <span class="s4">)</span>

            <span class="s3">if </span><span class="s1">added </span><span class="s3">or </span><span class="s1">deleted</span><span class="s4">:</span>
                <span class="s3">return True</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return False</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">is_active</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;True if this :class:`.Session` not in &quot;partial rollback&quot; state. 
 
        .. versionchanged:: 1.4 The :class:`_orm.Session` no longer begins 
           a new transaction immediately, so this attribute will be False 
           when the :class:`_orm.Session` is first instantiated. 
 
        &quot;partial rollback&quot; state typically indicates that the flush process 
        of the :class:`_orm.Session` has failed, and that the 
        :meth:`_orm.Session.rollback` method must be emitted in order to 
        fully roll back the transaction. 
 
        If this :class:`_orm.Session` is not in a transaction at all, the 
        :class:`_orm.Session` will autobegin when it is first used, so in this 
        case :attr:`_orm.Session.is_active` will return True. 
 
        Otherwise, if this :class:`_orm.Session` is within a transaction, 
        and that transaction has not been rolled back internally, the 
        :attr:`_orm.Session.is_active` will also return True. 
 
        .. seealso:: 
 
            :ref:`faq_session_rollback` 
 
            :meth:`_orm.Session.in_transaction` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction </span><span class="s3">is None or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transaction</span><span class="s4">.</span><span class="s1">is_active</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_dirty_states</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;The set of all persistent states considered dirty. 
 
        This method returns all states that were modified including 
        those that were possibly deleted. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identity_map</span><span class="s4">.</span><span class="s1">_dirty_states</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">dirty</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; IdentitySet</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;The set of all persistent instances considered dirty. 
 
        E.g.:: 
 
            some_mapped_object in session.dirty 
 
        Instances are considered dirty when they were modified but not 
        deleted. 
 
        Note that this 'dirty' calculation is 'optimistic'; most 
        attribute-setting or collection modification operations will 
        mark an instance as 'dirty' and place it in this set, even if 
        there is no net change to the attribute's value.  At flush 
        time, the value of each attribute is compared to its 
        previously saved value, and if there's no net change, no SQL 
        operation will occur (this is a more expensive operation so 
        it's only done at flush time). 
 
        To check if an instance has actionable net changes to its 
        attributes, use the :meth:`.Session.is_modified` method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">IdentitySet</span><span class="s4">(</span>
            <span class="s4">[</span>
                <span class="s1">state</span><span class="s4">.</span><span class="s1">obj</span><span class="s4">()</span>
                <span class="s3">for </span><span class="s1">state </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dirty_states</span>
                <span class="s3">if </span><span class="s1">state </span><span class="s3">not in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted</span>
            <span class="s4">]</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">deleted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; IdentitySet</span><span class="s4">:</span>
        <span class="s2">&quot;The set of all instances marked as 'deleted' within this ``Session``&quot;</span>

        <span class="s3">return </span><span class="s1">util</span><span class="s4">.</span><span class="s1">IdentitySet</span><span class="s4">(</span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">.</span><span class="s1">values</span><span class="s4">()))</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">new</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; IdentitySet</span><span class="s4">:</span>
        <span class="s2">&quot;The set of all instances marked as 'new' within this ``Session``.&quot;</span>

        <span class="s3">return </span><span class="s1">util</span><span class="s4">.</span><span class="s1">IdentitySet</span><span class="s4">(</span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_new</span><span class="s4">.</span><span class="s1">values</span><span class="s4">()))</span>


<span class="s1">_S </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_S&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s5">&quot;Session&quot;</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">sessionmaker</span><span class="s4">(</span><span class="s1">_SessionClassMethods</span><span class="s4">, </span><span class="s1">Generic</span><span class="s4">[</span><span class="s1">_S</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;A configurable :class:`.Session` factory. 
 
    The :class:`.sessionmaker` factory generates new 
    :class:`.Session` objects when called, creating them given 
    the configurational arguments established here. 
 
    e.g.:: 
 
        from sqlalchemy import create_engine 
        from sqlalchemy.orm import sessionmaker 
 
        # an Engine, which the Session will use for connection 
        # resources 
        engine = create_engine('postgresql+psycopg2://scott:tiger@localhost/') 
 
        Session = sessionmaker(engine) 
 
        with Session() as session: 
            session.add(some_object) 
            session.add(some_other_object) 
            session.commit() 
 
    Context manager use is optional; otherwise, the returned 
    :class:`_orm.Session` object may be closed explicitly via the 
    :meth:`_orm.Session.close` method.   Using a 
    ``try:/finally:`` block is optional, however will ensure that the close 
    takes place even if there are database errors:: 
 
        session = Session() 
        try: 
            session.add(some_object) 
            session.add(some_other_object) 
            session.commit() 
        finally: 
            session.close() 
 
    :class:`.sessionmaker` acts as a factory for :class:`_orm.Session` 
    objects in the same way as an :class:`_engine.Engine` acts as a factory 
    for :class:`_engine.Connection` objects.  In this way it also includes 
    a :meth:`_orm.sessionmaker.begin` method, that provides a context 
    manager which both begins and commits a transaction, as well as closes 
    out the :class:`_orm.Session` when complete, rolling back the transaction 
    if any errors occur:: 
 
        Session = sessionmaker(engine) 
 
        with Session.begin() as session: 
            session.add(some_object) 
            session.add(some_other_object) 
        # commits transaction, closes session 
 
    .. versionadded:: 1.4 
 
    When calling upon :class:`_orm.sessionmaker` to construct a 
    :class:`_orm.Session`, keyword arguments may also be passed to the 
    method; these arguments will override that of the globally configured 
    parameters.  Below we use a :class:`_orm.sessionmaker` bound to a certain 
    :class:`_engine.Engine` to produce a :class:`_orm.Session` that is instead 
    bound to a specific :class:`_engine.Connection` procured from that engine:: 
 
        Session = sessionmaker(engine) 
 
        # bind an individual session to a connection 
 
        with engine.connect() as connection: 
            with Session(bind=connection) as session: 
                # work with session 
 
    The class also includes a method :meth:`_orm.sessionmaker.configure`, which 
    can be used to specify additional keyword arguments to the factory, which 
    will take effect for subsequent :class:`.Session` objects generated. This 
    is usually used to associate one or more :class:`_engine.Engine` objects 
    with an existing 
    :class:`.sessionmaker` factory before it is first used:: 
 
        # application starts, sessionmaker does not have 
        # an engine bound yet 
        Session = sessionmaker() 
 
        # ... later, when an engine URL is read from a configuration 
        # file or other events allow the engine to be created 
        engine = create_engine('sqlite:///foo.db') 
        Session.configure(bind=engine) 
 
        sess = Session() 
        # work with session 
 
    .. seealso:: 
 
        :ref:`session_getting` - introductory text on creating 
        sessions using :class:`.sessionmaker`. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">class_</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">_S</span><span class="s4">]</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">bind</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_SessionBind</span><span class="s4">] = ...,</span>
        <span class="s4">*,</span>
        <span class="s1">class_</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">_S</span><span class="s4">],</span>
        <span class="s1">autoflush</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= ...,</span>
        <span class="s1">expire_on_commit</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= ...,</span>
        <span class="s1">info</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_InfoType</span><span class="s4">] = ...,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">): ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">: </span><span class="s5">&quot;sessionmaker[Session]&quot;</span><span class="s4">,</span>
        <span class="s1">bind</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_SessionBind</span><span class="s4">] = ...,</span>
        <span class="s4">*,</span>
        <span class="s1">autoflush</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= ...,</span>
        <span class="s1">expire_on_commit</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= ...,</span>
        <span class="s1">info</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_InfoType</span><span class="s4">] = ...,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">): ...</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">bind</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_SessionBind</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">class_</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">_S</span><span class="s4">] = </span><span class="s1">Session</span><span class="s4">,  </span><span class="s0"># type: ignore</span>
        <span class="s1">autoflush</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">expire_on_commit</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">info</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_InfoType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">r&quot;&quot;&quot;Construct a new :class:`.sessionmaker`. 
 
        All arguments here except for ``class_`` correspond to arguments 
        accepted by :class:`.Session` directly.  See the 
        :meth:`.Session.__init__` docstring for more details on parameters. 
 
        :param bind: a :class:`_engine.Engine` or other :class:`.Connectable` 
         with 
         which newly created :class:`.Session` objects will be associated. 
        :param class\_: class to use in order to create new :class:`.Session` 
         objects.  Defaults to :class:`.Session`. 
        :param autoflush: The autoflush setting to use with newly created 
         :class:`.Session` objects. 
 
         .. seealso:: 
 
            :ref:`session_flushing` - additional background on autoflush 
 
        :param expire_on_commit=True: the 
         :paramref:`_orm.Session.expire_on_commit` setting to use 
         with newly created :class:`.Session` objects. 
 
        :param info: optional dictionary of information that will be available 
         via :attr:`.Session.info`.  Note this dictionary is *updated*, not 
         replaced, when the ``info`` parameter is specified to the specific 
         :class:`.Session` construction operation. 
 
        :param \**kw: all other keyword arguments are passed to the 
         constructor of newly created :class:`.Session` objects. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">kw</span><span class="s4">[</span><span class="s5">&quot;bind&quot;</span><span class="s4">] = </span><span class="s1">bind</span>
        <span class="s1">kw</span><span class="s4">[</span><span class="s5">&quot;autoflush&quot;</span><span class="s4">] = </span><span class="s1">autoflush</span>
        <span class="s1">kw</span><span class="s4">[</span><span class="s5">&quot;expire_on_commit&quot;</span><span class="s4">] = </span><span class="s1">expire_on_commit</span>
        <span class="s3">if </span><span class="s1">info </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">kw</span><span class="s4">[</span><span class="s5">&quot;info&quot;</span><span class="s4">] = </span><span class="s1">info</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">kw </span><span class="s4">= </span><span class="s1">kw</span>
        <span class="s0"># make our own subclass of the given class, so that</span>
        <span class="s0"># events can be associated with it specifically.</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">class_ </span><span class="s4">= </span><span class="s1">type</span><span class="s4">(</span><span class="s1">class_</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">, (</span><span class="s1">class_</span><span class="s4">,), {})</span>

    <span class="s3">def </span><span class="s1">begin</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; contextlib</span><span class="s4">.</span><span class="s1">AbstractContextManager</span><span class="s4">[</span><span class="s1">_S</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Produce a context manager that both provides a new 
        :class:`_orm.Session` as well as a transaction that commits. 
 
 
        e.g.:: 
 
            Session = sessionmaker(some_engine) 
 
            with Session.begin() as session: 
                session.add(some_object) 
 
            # commits transaction, closes session 
 
        .. versionadded:: 1.4 
 
 
        &quot;&quot;&quot;</span>

        <span class="s1">session </span><span class="s4">= </span><span class="s1">self</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">session</span><span class="s4">.</span><span class="s1">_maker_context_manager</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">local_kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; _S</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Produce a new :class:`.Session` object using the configuration 
        established in this :class:`.sessionmaker`. 
 
        In Python, the ``__call__`` method is invoked on an object when 
        it is &quot;called&quot; in the same way as a function:: 
 
            Session = sessionmaker(some_engine) 
            session = Session()  # invokes sessionmaker.__call__() 
 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kw</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
            <span class="s3">if </span><span class="s1">k </span><span class="s4">== </span><span class="s5">&quot;info&quot; </span><span class="s3">and </span><span class="s5">&quot;info&quot; </span><span class="s3">in </span><span class="s1">local_kw</span><span class="s4">:</span>
                <span class="s1">d </span><span class="s4">= </span><span class="s1">v</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">()</span>
                <span class="s1">d</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">local_kw</span><span class="s4">[</span><span class="s5">&quot;info&quot;</span><span class="s4">])</span>
                <span class="s1">local_kw</span><span class="s4">[</span><span class="s5">&quot;info&quot;</span><span class="s4">] = </span><span class="s1">d</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">local_kw</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s1">k</span><span class="s4">, </span><span class="s1">v</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">class_</span><span class="s4">(**</span><span class="s1">local_kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">configure</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">new_kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;(Re)configure the arguments for this sessionmaker. 
 
        e.g.:: 
 
            Session = sessionmaker() 
 
            Session.configure(bind=create_engine('sqlite://')) 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">kw</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">new_kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__repr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s5">&quot;%s(class_=%r, %s)&quot; </span><span class="s4">% (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">class_</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">,</span>
            <span class="s5">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s5">&quot;%s=%r&quot; </span><span class="s4">% (</span><span class="s1">k</span><span class="s4">, </span><span class="s1">v</span><span class="s4">) </span><span class="s3">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kw</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()),</span>
        <span class="s4">)</span>


<span class="s3">def </span><span class="s1">close_all_sessions</span><span class="s4">() </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Close all sessions in memory. 
 
    This function consults a global registry of all :class:`.Session` objects 
    and calls :meth:`.Session.close` on them, which resets them to a clean 
    state. 
 
    This function is not for general use but may be useful for test suites 
    within the teardown scheme. 
 
    .. versionadded:: 1.3 
 
    &quot;&quot;&quot;</span>

    <span class="s3">for </span><span class="s1">sess </span><span class="s3">in </span><span class="s1">_sessions</span><span class="s4">.</span><span class="s1">values</span><span class="s4">():</span>
        <span class="s1">sess</span><span class="s4">.</span><span class="s1">close</span><span class="s4">()</span>


<span class="s3">def </span><span class="s1">make_transient</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">: </span><span class="s1">object</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Alter the state of the given instance so that it is :term:`transient`. 
 
    .. note:: 
 
        :func:`.make_transient` is a special-case function for 
        advanced use cases only. 
 
    The given mapped instance is assumed to be in the :term:`persistent` or 
    :term:`detached` state.   The function will remove its association with any 
    :class:`.Session` as well as its :attr:`.InstanceState.identity`. The 
    effect is that the object will behave as though it were newly constructed, 
    except retaining any attribute / collection values that were loaded at the 
    time of the call.   The :attr:`.InstanceState.deleted` flag is also reset 
    if this object had been deleted as a result of using 
    :meth:`.Session.delete`. 
 
    .. warning:: 
 
        :func:`.make_transient` does **not** &quot;unexpire&quot; or otherwise eagerly 
        load ORM-mapped attributes that are not currently loaded at the time 
        the function is called.   This includes attributes which: 
 
        * were expired via :meth:`.Session.expire` 
 
        * were expired as the natural effect of committing a session 
          transaction, e.g. :meth:`.Session.commit` 
 
        * are normally :term:`lazy loaded` but are not currently loaded 
 
        * are &quot;deferred&quot; (see :ref:`orm_queryguide_column_deferral`) and are 
          not yet loaded 
 
        * were not present in the query which loaded this object, such as that 
          which is common in joined table inheritance and other scenarios. 
 
        After :func:`.make_transient` is called, unloaded attributes such 
        as those above will normally resolve to the value ``None`` when 
        accessed, or an empty collection for a collection-oriented attribute. 
        As the object is transient and un-associated with any database 
        identity, it will no longer retrieve these values. 
 
    .. seealso:: 
 
        :func:`.make_transient_to_detached` 
 
    &quot;&quot;&quot;</span>
    <span class="s1">state </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_state</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>
    <span class="s1">s </span><span class="s4">= </span><span class="s1">_state_session</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">s</span><span class="s4">:</span>
        <span class="s1">s</span><span class="s4">.</span><span class="s1">_expunge_states</span><span class="s4">([</span><span class="s1">state</span><span class="s4">])</span>

    <span class="s0"># remove expired state</span>
    <span class="s1">state</span><span class="s4">.</span><span class="s1">expired_attributes</span><span class="s4">.</span><span class="s1">clear</span><span class="s4">()</span>

    <span class="s0"># remove deferred callables</span>
    <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">callables</span><span class="s4">:</span>
        <span class="s3">del </span><span class="s1">state</span><span class="s4">.</span><span class="s1">callables</span>

    <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">key</span><span class="s4">:</span>
        <span class="s3">del </span><span class="s1">state</span><span class="s4">.</span><span class="s1">key</span>
    <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">:</span>
        <span class="s3">del </span><span class="s1">state</span><span class="s4">.</span><span class="s1">_deleted</span>


<span class="s3">def </span><span class="s1">make_transient_to_detached</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">: </span><span class="s1">object</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Make the given transient instance :term:`detached`. 
 
    .. note:: 
 
        :func:`.make_transient_to_detached` is a special-case function for 
        advanced use cases only. 
 
    All attribute history on the given instance 
    will be reset as though the instance were freshly loaded 
    from a query.  Missing attributes will be marked as expired. 
    The primary key attributes of the object, which are required, will be made 
    into the &quot;key&quot; of the instance. 
 
    The object can then be added to a session, or merged 
    possibly with the load=False flag, at which point it will look 
    as if it were loaded that way, without emitting SQL. 
 
    This is a special use case function that differs from a normal 
    call to :meth:`.Session.merge` in that a given persistent state 
    can be manufactured without any SQL calls. 
 
    .. seealso:: 
 
        :func:`.make_transient` 
 
        :meth:`.Session.enable_relationship_loading` 
 
    &quot;&quot;&quot;</span>
    <span class="s1">state </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_state</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">session_id </span><span class="s3">or </span><span class="s1">state</span><span class="s4">.</span><span class="s1">key</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span><span class="s5">&quot;Given object must be transient&quot;</span><span class="s4">)</span>
    <span class="s1">state</span><span class="s4">.</span><span class="s1">key </span><span class="s4">= </span><span class="s1">state</span><span class="s4">.</span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">_identity_key_from_state</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">_deleted</span><span class="s4">:</span>
        <span class="s3">del </span><span class="s1">state</span><span class="s4">.</span><span class="s1">_deleted</span>
    <span class="s1">state</span><span class="s4">.</span><span class="s1">_commit_all</span><span class="s4">(</span><span class="s1">state</span><span class="s4">.</span><span class="s1">dict</span><span class="s4">)</span>
    <span class="s1">state</span><span class="s4">.</span><span class="s1">_expire_attributes</span><span class="s4">(</span><span class="s1">state</span><span class="s4">.</span><span class="s1">dict</span><span class="s4">, </span><span class="s1">state</span><span class="s4">.</span><span class="s1">unloaded</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">object_session</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">: </span><span class="s1">object</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">Session</span><span class="s4">]:</span>
    <span class="s2">&quot;&quot;&quot;Return the :class:`.Session` to which the given instance belongs. 
 
    This is essentially the same as the :attr:`.InstanceState.session` 
    accessor.  See that attribute for details. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">try</span><span class="s4">:</span>
        <span class="s1">state </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">instance_state</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>
    <span class="s3">except </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">NO_STATE </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">UnmappedInstanceError</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">_state_session</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>


<span class="s1">_new_sessionid </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">counter</span><span class="s4">()</span>
</pre>
</body>
</html>