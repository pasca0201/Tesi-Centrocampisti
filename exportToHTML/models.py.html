<html>
<head>
<title>models.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
models.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Variation fonts interpolation models.&quot;&quot;&quot;</span>

<span class="s1">__all__ </span><span class="s2">= [</span>
    <span class="s3">&quot;normalizeValue&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;normalizeLocation&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;supportScalar&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;piecewiseLinearMap&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;VariationModel&quot;</span><span class="s2">,</span>
<span class="s2">]</span>

<span class="s4">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">misc</span><span class="s2">.</span><span class="s1">roundTools </span><span class="s4">import </span><span class="s1">noRound</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">errors </span><span class="s4">import </span><span class="s1">VariationModelError</span>


<span class="s4">def </span><span class="s1">nonNone</span><span class="s2">(</span><span class="s1">lst</span><span class="s2">):</span>
    <span class="s4">return </span><span class="s2">[</span><span class="s1">l </span><span class="s4">for </span><span class="s1">l </span><span class="s4">in </span><span class="s1">lst </span><span class="s4">if </span><span class="s1">l </span><span class="s4">is not None</span><span class="s2">]</span>


<span class="s4">def </span><span class="s1">allNone</span><span class="s2">(</span><span class="s1">lst</span><span class="s2">):</span>
    <span class="s4">return </span><span class="s1">all</span><span class="s2">(</span><span class="s1">l </span><span class="s4">is None for </span><span class="s1">l </span><span class="s4">in </span><span class="s1">lst</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">allEqualTo</span><span class="s2">(</span><span class="s1">ref</span><span class="s2">, </span><span class="s1">lst</span><span class="s2">, </span><span class="s1">mapper</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s4">if </span><span class="s1">mapper </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">all</span><span class="s2">(</span><span class="s1">ref </span><span class="s2">== </span><span class="s1">item </span><span class="s4">for </span><span class="s1">item </span><span class="s4">in </span><span class="s1">lst</span><span class="s2">)</span>

    <span class="s1">mapped </span><span class="s2">= </span><span class="s1">mapper</span><span class="s2">(</span><span class="s1">ref</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">all</span><span class="s2">(</span><span class="s1">mapped </span><span class="s2">== </span><span class="s1">mapper</span><span class="s2">(</span><span class="s1">item</span><span class="s2">) </span><span class="s4">for </span><span class="s1">item </span><span class="s4">in </span><span class="s1">lst</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">allEqual</span><span class="s2">(</span><span class="s1">lst</span><span class="s2">, </span><span class="s1">mapper</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s4">if not </span><span class="s1">lst</span><span class="s2">:</span>
        <span class="s4">return True</span>
    <span class="s1">it </span><span class="s2">= </span><span class="s1">iter</span><span class="s2">(</span><span class="s1">lst</span><span class="s2">)</span>
    <span class="s4">try</span><span class="s2">:</span>
        <span class="s1">first </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">it</span><span class="s2">)</span>
    <span class="s4">except </span><span class="s1">StopIteration</span><span class="s2">:</span>
        <span class="s4">return True</span>
    <span class="s4">return </span><span class="s1">allEqualTo</span><span class="s2">(</span><span class="s1">first</span><span class="s2">, </span><span class="s1">it</span><span class="s2">, </span><span class="s1">mapper</span><span class="s2">=</span><span class="s1">mapper</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">subList</span><span class="s2">(</span><span class="s1">truth</span><span class="s2">, </span><span class="s1">lst</span><span class="s2">):</span>
    <span class="s4">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">truth</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">lst</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s2">[</span><span class="s1">l </span><span class="s4">for </span><span class="s1">l</span><span class="s2">, </span><span class="s1">t </span><span class="s4">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">lst</span><span class="s2">, </span><span class="s1">truth</span><span class="s2">) </span><span class="s4">if </span><span class="s1">t</span><span class="s2">]</span>


<span class="s4">def </span><span class="s1">normalizeValue</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">triple</span><span class="s2">, </span><span class="s1">extrapolate</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Normalizes value based on a min/default/max triple. 
 
    &gt;&gt;&gt; normalizeValue(400, (100, 400, 900)) 
    0.0 
    &gt;&gt;&gt; normalizeValue(100, (100, 400, 900)) 
    -1.0 
    &gt;&gt;&gt; normalizeValue(650, (100, 400, 900)) 
    0.5 
    &quot;&quot;&quot;</span>
    <span class="s1">lower</span><span class="s2">, </span><span class="s1">default</span><span class="s2">, </span><span class="s1">upper </span><span class="s2">= </span><span class="s1">triple</span>
    <span class="s4">if not </span><span class="s2">(</span><span class="s1">lower </span><span class="s2">&lt;= </span><span class="s1">default </span><span class="s2">&lt;= </span><span class="s1">upper</span><span class="s2">):</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s3">f&quot;Invalid axis values, must be minimum, default, maximum: &quot;</span>
            <span class="s3">f&quot;</span><span class="s4">{</span><span class="s1">lower</span><span class="s4">:</span><span class="s3">3.3f</span><span class="s4">}</span><span class="s3">, </span><span class="s4">{</span><span class="s1">default</span><span class="s4">:</span><span class="s3">3.3f</span><span class="s4">}</span><span class="s3">, </span><span class="s4">{</span><span class="s1">upper</span><span class="s4">:</span><span class="s3">3.3f</span><span class="s4">}</span><span class="s3">&quot;</span>
        <span class="s2">)</span>
    <span class="s4">if not </span><span class="s1">extrapolate</span><span class="s2">:</span>
        <span class="s1">v </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">min</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">upper</span><span class="s2">), </span><span class="s1">lower</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">v </span><span class="s2">== </span><span class="s1">default </span><span class="s4">or </span><span class="s1">lower </span><span class="s2">== </span><span class="s1">upper</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s5">0.0</span>

    <span class="s4">if </span><span class="s2">(</span><span class="s1">v </span><span class="s2">&lt; </span><span class="s1">default </span><span class="s4">and </span><span class="s1">lower </span><span class="s2">!= </span><span class="s1">default</span><span class="s2">) </span><span class="s4">or </span><span class="s2">(</span><span class="s1">v </span><span class="s2">&gt; </span><span class="s1">default </span><span class="s4">and </span><span class="s1">upper </span><span class="s2">== </span><span class="s1">default</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s2">(</span><span class="s1">v </span><span class="s2">- </span><span class="s1">default</span><span class="s2">) / (</span><span class="s1">default </span><span class="s2">- </span><span class="s1">lower</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">assert </span><span class="s2">(</span><span class="s1">v </span><span class="s2">&gt; </span><span class="s1">default </span><span class="s4">and </span><span class="s1">upper </span><span class="s2">!= </span><span class="s1">default</span><span class="s2">) </span><span class="s4">or </span><span class="s2">(</span>
            <span class="s1">v </span><span class="s2">&lt; </span><span class="s1">default </span><span class="s4">and </span><span class="s1">lower </span><span class="s2">== </span><span class="s1">default</span>
        <span class="s2">), </span><span class="s3">f&quot;Ooops... v=</span><span class="s4">{</span><span class="s1">v</span><span class="s4">}</span><span class="s3">, triple=(</span><span class="s4">{</span><span class="s1">lower</span><span class="s4">}</span><span class="s3">, </span><span class="s4">{</span><span class="s1">default</span><span class="s4">}</span><span class="s3">, </span><span class="s4">{</span><span class="s1">upper</span><span class="s4">}</span><span class="s3">)&quot;</span>
        <span class="s4">return </span><span class="s2">(</span><span class="s1">v </span><span class="s2">- </span><span class="s1">default</span><span class="s2">) / (</span><span class="s1">upper </span><span class="s2">- </span><span class="s1">default</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">normalizeLocation</span><span class="s2">(</span><span class="s1">location</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">extrapolate</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, *, </span><span class="s1">validate</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Normalizes location based on axis min/default/max values from axes. 
 
    &gt;&gt;&gt; axes = {&quot;wght&quot;: (100, 400, 900)} 
    &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 400}, axes) 
    {'wght': 0.0} 
    &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 100}, axes) 
    {'wght': -1.0} 
    &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 900}, axes) 
    {'wght': 1.0} 
    &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 650}, axes) 
    {'wght': 0.5} 
    &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 1000}, axes) 
    {'wght': 1.0} 
    &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 0}, axes) 
    {'wght': -1.0} 
    &gt;&gt;&gt; axes = {&quot;wght&quot;: (0, 0, 1000)} 
    &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 0}, axes) 
    {'wght': 0.0} 
    &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: -1}, axes) 
    {'wght': 0.0} 
    &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 1000}, axes) 
    {'wght': 1.0} 
    &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 500}, axes) 
    {'wght': 0.5} 
    &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 1001}, axes) 
    {'wght': 1.0} 
    &gt;&gt;&gt; axes = {&quot;wght&quot;: (0, 1000, 1000)} 
    &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 0}, axes) 
    {'wght': -1.0} 
    &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: -1}, axes) 
    {'wght': -1.0} 
    &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 500}, axes) 
    {'wght': -0.5} 
    &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 1000}, axes) 
    {'wght': 0.0} 
    &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 1001}, axes) 
    {'wght': 0.0} 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">validate</span><span class="s2">:</span>
        <span class="s4">assert </span><span class="s1">set</span><span class="s2">(</span><span class="s1">location</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()) &lt;= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">axes</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()), </span><span class="s1">set</span><span class="s2">(</span><span class="s1">location</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()) - </span><span class="s1">set</span><span class="s2">(</span>
            <span class="s1">axes</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()</span>
        <span class="s2">)</span>
    <span class="s1">out </span><span class="s2">= {}</span>
    <span class="s4">for </span><span class="s1">tag</span><span class="s2">, </span><span class="s1">triple </span><span class="s4">in </span><span class="s1">axes</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
        <span class="s1">v </span><span class="s2">= </span><span class="s1">location</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">tag</span><span class="s2">, </span><span class="s1">triple</span><span class="s2">[</span><span class="s5">1</span><span class="s2">])</span>
        <span class="s1">out</span><span class="s2">[</span><span class="s1">tag</span><span class="s2">] = </span><span class="s1">normalizeValue</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">triple</span><span class="s2">, </span><span class="s1">extrapolate</span><span class="s2">=</span><span class="s1">extrapolate</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">out</span>


<span class="s4">def </span><span class="s1">supportScalar</span><span class="s2">(</span><span class="s1">location</span><span class="s2">, </span><span class="s1">support</span><span class="s2">, </span><span class="s1">ot</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">extrapolate</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">axisRanges</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Returns the scalar multiplier at location, for a master 
    with support.  If ot is True, then a peak value of zero 
    for support of an axis means &quot;axis does not participate&quot;.  That 
    is how OpenType Variation Font technology works. 
 
    If extrapolate is True, axisRanges must be a dict that maps axis 
    names to (axisMin, axisMax) tuples. 
 
      &gt;&gt;&gt; supportScalar({}, {}) 
      1.0 
      &gt;&gt;&gt; supportScalar({'wght':.2}, {}) 
      1.0 
      &gt;&gt;&gt; supportScalar({'wght':.2}, {'wght':(0,2,3)}) 
      0.1 
      &gt;&gt;&gt; supportScalar({'wght':2.5}, {'wght':(0,2,4)}) 
      0.75 
      &gt;&gt;&gt; supportScalar({'wght':2.5, 'wdth':0}, {'wght':(0,2,4), 'wdth':(-1,0,+1)}) 
      0.75 
      &gt;&gt;&gt; supportScalar({'wght':2.5, 'wdth':.5}, {'wght':(0,2,4), 'wdth':(-1,0,+1)}, ot=False) 
      0.375 
      &gt;&gt;&gt; supportScalar({'wght':2.5, 'wdth':0}, {'wght':(0,2,4), 'wdth':(-1,0,+1)}) 
      0.75 
      &gt;&gt;&gt; supportScalar({'wght':2.5, 'wdth':.5}, {'wght':(0,2,4), 'wdth':(-1,0,+1)}) 
      0.75 
      &gt;&gt;&gt; supportScalar({'wght':3}, {'wght':(0,1,2)}, extrapolate=True, axisRanges={'wght':(0, 2)}) 
      -1.0 
      &gt;&gt;&gt; supportScalar({'wght':-1}, {'wght':(0,1,2)}, extrapolate=True, axisRanges={'wght':(0, 2)}) 
      -1.0 
      &gt;&gt;&gt; supportScalar({'wght':3}, {'wght':(0,2,2)}, extrapolate=True, axisRanges={'wght':(0, 2)}) 
      1.5 
      &gt;&gt;&gt; supportScalar({'wght':-1}, {'wght':(0,2,2)}, extrapolate=True, axisRanges={'wght':(0, 2)}) 
      -0.5 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">extrapolate </span><span class="s4">and </span><span class="s1">axisRanges </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;axisRanges must be passed when extrapolate is True&quot;</span><span class="s2">)</span>
    <span class="s1">scalar </span><span class="s2">= </span><span class="s5">1.0</span>
    <span class="s4">for </span><span class="s1">axis</span><span class="s2">, (</span><span class="s1">lower</span><span class="s2">, </span><span class="s1">peak</span><span class="s2">, </span><span class="s1">upper</span><span class="s2">) </span><span class="s4">in </span><span class="s1">support</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
        <span class="s4">if </span><span class="s1">ot</span><span class="s2">:</span>
            <span class="s6"># OpenType-specific case handling</span>
            <span class="s4">if </span><span class="s1">peak </span><span class="s2">== </span><span class="s5">0.0</span><span class="s2">:</span>
                <span class="s4">continue</span>
            <span class="s4">if </span><span class="s1">lower </span><span class="s2">&gt; </span><span class="s1">peak </span><span class="s4">or </span><span class="s1">peak </span><span class="s2">&gt; </span><span class="s1">upper</span><span class="s2">:</span>
                <span class="s4">continue</span>
            <span class="s4">if </span><span class="s1">lower </span><span class="s2">&lt; </span><span class="s5">0.0 </span><span class="s4">and </span><span class="s1">upper </span><span class="s2">&gt; </span><span class="s5">0.0</span><span class="s2">:</span>
                <span class="s4">continue</span>
            <span class="s1">v </span><span class="s2">= </span><span class="s1">location</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">assert </span><span class="s1">axis </span><span class="s4">in </span><span class="s1">location</span>
            <span class="s1">v </span><span class="s2">= </span><span class="s1">location</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
        <span class="s4">if </span><span class="s1">v </span><span class="s2">== </span><span class="s1">peak</span><span class="s2">:</span>
            <span class="s4">continue</span>

        <span class="s4">if </span><span class="s1">extrapolate</span><span class="s2">:</span>
            <span class="s1">axisMin</span><span class="s2">, </span><span class="s1">axisMax </span><span class="s2">= </span><span class="s1">axisRanges</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
            <span class="s4">if </span><span class="s1">v </span><span class="s2">&lt; </span><span class="s1">axisMin </span><span class="s4">and </span><span class="s1">lower </span><span class="s2">&lt;= </span><span class="s1">axisMin</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">peak </span><span class="s2">&lt;= </span><span class="s1">axisMin </span><span class="s4">and </span><span class="s1">peak </span><span class="s2">&lt; </span><span class="s1">upper</span><span class="s2">:</span>
                    <span class="s1">scalar </span><span class="s2">*= (</span><span class="s1">v </span><span class="s2">- </span><span class="s1">upper</span><span class="s2">) / (</span><span class="s1">peak </span><span class="s2">- </span><span class="s1">upper</span><span class="s2">)</span>
                    <span class="s4">continue</span>
                <span class="s4">elif </span><span class="s1">axisMin </span><span class="s2">&lt; </span><span class="s1">peak</span><span class="s2">:</span>
                    <span class="s1">scalar </span><span class="s2">*= (</span><span class="s1">v </span><span class="s2">- </span><span class="s1">lower</span><span class="s2">) / (</span><span class="s1">peak </span><span class="s2">- </span><span class="s1">lower</span><span class="s2">)</span>
                    <span class="s4">continue</span>
            <span class="s4">elif </span><span class="s1">axisMax </span><span class="s2">&lt; </span><span class="s1">v </span><span class="s4">and </span><span class="s1">axisMax </span><span class="s2">&lt;= </span><span class="s1">upper</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">axisMax </span><span class="s2">&lt;= </span><span class="s1">peak </span><span class="s4">and </span><span class="s1">lower </span><span class="s2">&lt; </span><span class="s1">peak</span><span class="s2">:</span>
                    <span class="s1">scalar </span><span class="s2">*= (</span><span class="s1">v </span><span class="s2">- </span><span class="s1">lower</span><span class="s2">) / (</span><span class="s1">peak </span><span class="s2">- </span><span class="s1">lower</span><span class="s2">)</span>
                    <span class="s4">continue</span>
                <span class="s4">elif </span><span class="s1">peak </span><span class="s2">&lt; </span><span class="s1">axisMax</span><span class="s2">:</span>
                    <span class="s1">scalar </span><span class="s2">*= (</span><span class="s1">v </span><span class="s2">- </span><span class="s1">upper</span><span class="s2">) / (</span><span class="s1">peak </span><span class="s2">- </span><span class="s1">upper</span><span class="s2">)</span>
                    <span class="s4">continue</span>

        <span class="s4">if </span><span class="s1">v </span><span class="s2">&lt;= </span><span class="s1">lower </span><span class="s4">or </span><span class="s1">upper </span><span class="s2">&lt;= </span><span class="s1">v</span><span class="s2">:</span>
            <span class="s1">scalar </span><span class="s2">= </span><span class="s5">0.0</span>
            <span class="s4">break</span>

        <span class="s4">if </span><span class="s1">v </span><span class="s2">&lt; </span><span class="s1">peak</span><span class="s2">:</span>
            <span class="s1">scalar </span><span class="s2">*= (</span><span class="s1">v </span><span class="s2">- </span><span class="s1">lower</span><span class="s2">) / (</span><span class="s1">peak </span><span class="s2">- </span><span class="s1">lower</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:  </span><span class="s6"># v &gt; peak</span>
            <span class="s1">scalar </span><span class="s2">*= (</span><span class="s1">v </span><span class="s2">- </span><span class="s1">upper</span><span class="s2">) / (</span><span class="s1">peak </span><span class="s2">- </span><span class="s1">upper</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">scalar</span>


<span class="s4">class </span><span class="s1">VariationModel</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Locations must have the base master at the origin (ie. 0). 
 
    If axis-ranges are not provided, values are assumed to be normalized to 
    the range [-1, 1]. 
 
    If the extrapolate argument is set to True, then values are extrapolated 
    outside the axis range. 
 
      &gt;&gt;&gt; from pprint import pprint 
      &gt;&gt;&gt; axisRanges = {'wght': (-180, +180), 'wdth': (-1, +1)} 
      &gt;&gt;&gt; locations = [ \ 
      {'wght':100}, \ 
      {'wght':-100}, \ 
      {'wght':-180}, \ 
      {'wdth':+.3}, \ 
      {'wght':+120,'wdth':.3}, \ 
      {'wght':+120,'wdth':.2}, \ 
      {}, \ 
      {'wght':+180,'wdth':.3}, \ 
      {'wght':+180}, \ 
      ] 
      &gt;&gt;&gt; model = VariationModel(locations, axisOrder=['wght'], axisRanges=axisRanges) 
      &gt;&gt;&gt; pprint(model.locations) 
      [{}, 
       {'wght': -100}, 
       {'wght': -180}, 
       {'wght': 100}, 
       {'wght': 180}, 
       {'wdth': 0.3}, 
       {'wdth': 0.3, 'wght': 180}, 
       {'wdth': 0.3, 'wght': 120}, 
       {'wdth': 0.2, 'wght': 120}] 
      &gt;&gt;&gt; pprint(model.deltaWeights) 
      [{}, 
       {0: 1.0}, 
       {0: 1.0}, 
       {0: 1.0}, 
       {0: 1.0}, 
       {0: 1.0}, 
       {0: 1.0, 4: 1.0, 5: 1.0}, 
       {0: 1.0, 3: 0.75, 4: 0.25, 5: 1.0, 6: 0.6666666666666666}, 
       {0: 1.0, 
        3: 0.75, 
        4: 0.25, 
        5: 0.6666666666666667, 
        6: 0.4444444444444445, 
        7: 0.6666666666666667}] 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">locations</span><span class="s2">, </span><span class="s1">axisOrder</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">extrapolate</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, *, </span><span class="s1">axisRanges</span><span class="s2">=</span><span class="s4">None</span>
    <span class="s2">):</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">l</span><span class="s2">.</span><span class="s1">items</span><span class="s2">())) </span><span class="s4">for </span><span class="s1">l </span><span class="s4">in </span><span class="s1">locations</span><span class="s2">)) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">locations</span><span class="s2">):</span>
            <span class="s4">raise </span><span class="s1">VariationModelError</span><span class="s2">(</span><span class="s3">&quot;Locations must be unique.&quot;</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">origLocations </span><span class="s2">= </span><span class="s1">locations</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">axisOrder </span><span class="s2">= </span><span class="s1">axisOrder </span><span class="s4">if </span><span class="s1">axisOrder </span><span class="s4">is not None else </span><span class="s2">[]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">extrapolate </span><span class="s2">= </span><span class="s1">extrapolate</span>
        <span class="s4">if </span><span class="s1">axisRanges </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">extrapolate</span><span class="s2">:</span>
                <span class="s1">axisRanges </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">computeAxisRanges</span><span class="s2">(</span><span class="s1">locations</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">allAxes </span><span class="s2">= {</span><span class="s1">axis </span><span class="s4">for </span><span class="s1">loc </span><span class="s4">in </span><span class="s1">locations </span><span class="s4">for </span><span class="s1">axis </span><span class="s4">in </span><span class="s1">loc</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()}</span>
                <span class="s1">axisRanges </span><span class="s2">= {</span><span class="s1">axis</span><span class="s2">: (-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">) </span><span class="s4">for </span><span class="s1">axis </span><span class="s4">in </span><span class="s1">allAxes</span><span class="s2">}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">axisRanges </span><span class="s2">= </span><span class="s1">axisRanges</span>

        <span class="s1">locations </span><span class="s2">= [{</span><span class="s1">k</span><span class="s2">: </span><span class="s1">v </span><span class="s4">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">loc</span><span class="s2">.</span><span class="s1">items</span><span class="s2">() </span><span class="s4">if </span><span class="s1">v </span><span class="s2">!= </span><span class="s5">0.0</span><span class="s2">} </span><span class="s4">for </span><span class="s1">loc </span><span class="s4">in </span><span class="s1">locations</span><span class="s2">]</span>
        <span class="s1">keyFunc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getMasterLocationsSortKeyFunc</span><span class="s2">(</span>
            <span class="s1">locations</span><span class="s2">, </span><span class="s1">axisOrder</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axisOrder</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">locations </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">locations</span><span class="s2">, </span><span class="s1">key</span><span class="s2">=</span><span class="s1">keyFunc</span><span class="s2">)</span>

        <span class="s6"># Mapping from user's master order to our master order</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">mapping </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">locations</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">l</span><span class="s2">) </span><span class="s4">for </span><span class="s1">l </span><span class="s4">in </span><span class="s1">locations</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">reverseMapping </span><span class="s2">= [</span><span class="s1">locations</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">l</span><span class="s2">) </span><span class="s4">for </span><span class="s1">l </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">locations</span><span class="s2">]</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_computeMasterSupports</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_subModels </span><span class="s2">= {}</span>

    <span class="s4">def </span><span class="s1">getSubModel</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">items</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Return a sub-model and the items that are not None. 
 
        The sub-model is necessary for working with the subset 
        of items when some are None. 
 
        The sub-model is cached.&quot;&quot;&quot;</span>
        <span class="s4">if None not in </span><span class="s1">items</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">, </span><span class="s1">items</span>
        <span class="s1">key </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">v </span><span class="s4">is not None for </span><span class="s1">v </span><span class="s4">in </span><span class="s1">items</span><span class="s2">)</span>
        <span class="s1">subModel </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_subModels</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">subModel </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">subModel </span><span class="s2">= </span><span class="s1">VariationModel</span><span class="s2">(</span><span class="s1">subList</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">origLocations</span><span class="s2">), </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axisOrder</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_subModels</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s1">subModel</span>
        <span class="s4">return </span><span class="s1">subModel</span><span class="s2">, </span><span class="s1">subList</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">items</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s4">def </span><span class="s1">computeAxisRanges</span><span class="s2">(</span><span class="s1">locations</span><span class="s2">):</span>
        <span class="s1">axisRanges </span><span class="s2">= {}</span>
        <span class="s1">allAxes </span><span class="s2">= {</span><span class="s1">axis </span><span class="s4">for </span><span class="s1">loc </span><span class="s4">in </span><span class="s1">locations </span><span class="s4">for </span><span class="s1">axis </span><span class="s4">in </span><span class="s1">loc</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()}</span>
        <span class="s4">for </span><span class="s1">loc </span><span class="s4">in </span><span class="s1">locations</span><span class="s2">:</span>
            <span class="s4">for </span><span class="s1">axis </span><span class="s4">in </span><span class="s1">allAxes</span><span class="s2">:</span>
                <span class="s1">value </span><span class="s2">= </span><span class="s1">loc</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)</span>
                <span class="s1">axisMin</span><span class="s2">, </span><span class="s1">axisMax </span><span class="s2">= </span><span class="s1">axisRanges</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, (</span><span class="s1">value</span><span class="s2">, </span><span class="s1">value</span><span class="s2">))</span>
                <span class="s1">axisRanges</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">min</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">axisMin</span><span class="s2">), </span><span class="s1">max</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">axisMax</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">axisRanges</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s4">def </span><span class="s1">getMasterLocationsSortKeyFunc</span><span class="s2">(</span><span class="s1">locations</span><span class="s2">, </span><span class="s1">axisOrder</span><span class="s2">=[]):</span>
        <span class="s4">if </span><span class="s2">{} </span><span class="s4">not in </span><span class="s1">locations</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">VariationModelError</span><span class="s2">(</span><span class="s3">&quot;Base master not found.&quot;</span><span class="s2">)</span>
        <span class="s1">axisPoints </span><span class="s2">= {}</span>
        <span class="s4">for </span><span class="s1">loc </span><span class="s4">in </span><span class="s1">locations</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">) != </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s4">continue</span>
            <span class="s1">axis </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">))</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">loc</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
            <span class="s4">if </span><span class="s1">axis </span><span class="s4">not in </span><span class="s1">axisPoints</span><span class="s2">:</span>
                <span class="s1">axisPoints</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = {</span><span class="s5">0.0</span><span class="s2">}</span>
            <span class="s4">assert </span><span class="s2">(</span>
                <span class="s1">value </span><span class="s4">not in </span><span class="s1">axisPoints</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
            <span class="s2">), </span><span class="s3">'Value &quot;%s&quot; in axisPoints[&quot;%s&quot;] --&gt;  %s' </span><span class="s2">% (</span><span class="s1">value</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">axisPoints</span><span class="s2">)</span>
            <span class="s1">axisPoints</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">].</span><span class="s1">add</span><span class="s2">(</span><span class="s1">value</span><span class="s2">)</span>

        <span class="s4">def </span><span class="s1">getKey</span><span class="s2">(</span><span class="s1">axisPoints</span><span class="s2">, </span><span class="s1">axisOrder</span><span class="s2">):</span>
            <span class="s4">def </span><span class="s1">sign</span><span class="s2">(</span><span class="s1">v</span><span class="s2">):</span>
                <span class="s4">return </span><span class="s2">-</span><span class="s5">1 </span><span class="s4">if </span><span class="s1">v </span><span class="s2">&lt; </span><span class="s5">0 </span><span class="s4">else </span><span class="s2">+</span><span class="s5">1 </span><span class="s4">if </span><span class="s1">v </span><span class="s2">&gt; </span><span class="s5">0 </span><span class="s4">else </span><span class="s5">0</span>

            <span class="s4">def </span><span class="s1">key</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">):</span>
                <span class="s1">rank </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">)</span>
                <span class="s1">onPointAxes </span><span class="s2">= [</span>
                    <span class="s1">axis</span>
                    <span class="s4">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">value </span><span class="s4">in </span><span class="s1">loc</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()</span>
                    <span class="s4">if </span><span class="s1">axis </span><span class="s4">in </span><span class="s1">axisPoints </span><span class="s4">and </span><span class="s1">value </span><span class="s4">in </span><span class="s1">axisPoints</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
                <span class="s2">]</span>
                <span class="s1">orderedAxes </span><span class="s2">= [</span><span class="s1">axis </span><span class="s4">for </span><span class="s1">axis </span><span class="s4">in </span><span class="s1">axisOrder </span><span class="s4">if </span><span class="s1">axis </span><span class="s4">in </span><span class="s1">loc</span><span class="s2">]</span>
                <span class="s1">orderedAxes</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span>
                    <span class="s2">[</span><span class="s1">axis </span><span class="s4">for </span><span class="s1">axis </span><span class="s4">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()) </span><span class="s4">if </span><span class="s1">axis </span><span class="s4">not in </span><span class="s1">axisOrder</span><span class="s2">]</span>
                <span class="s2">)</span>
                <span class="s4">return </span><span class="s2">(</span>
                    <span class="s1">rank</span><span class="s2">,  </span><span class="s6"># First, order by increasing rank</span>
                    <span class="s2">-</span><span class="s1">len</span><span class="s2">(</span><span class="s1">onPointAxes</span><span class="s2">),  </span><span class="s6"># Next, by decreasing number of onPoint axes</span>
                    <span class="s1">tuple</span><span class="s2">(</span>
                        <span class="s1">axisOrder</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">) </span><span class="s4">if </span><span class="s1">axis </span><span class="s4">in </span><span class="s1">axisOrder </span><span class="s4">else </span><span class="s5">0x10000</span>
                        <span class="s4">for </span><span class="s1">axis </span><span class="s4">in </span><span class="s1">orderedAxes</span>
                    <span class="s2">),  </span><span class="s6"># Next, by known axes</span>
                    <span class="s1">tuple</span><span class="s2">(</span><span class="s1">orderedAxes</span><span class="s2">),  </span><span class="s6"># Next, by all axes</span>
                    <span class="s1">tuple</span><span class="s2">(</span>
                        <span class="s1">sign</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]) </span><span class="s4">for </span><span class="s1">axis </span><span class="s4">in </span><span class="s1">orderedAxes</span>
                    <span class="s2">),  </span><span class="s6"># Next, by signs of axis values</span>
                    <span class="s1">tuple</span><span class="s2">(</span>
                        <span class="s1">abs</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]) </span><span class="s4">for </span><span class="s1">axis </span><span class="s4">in </span><span class="s1">orderedAxes</span>
                    <span class="s2">),  </span><span class="s6"># Next, by absolute value of axis values</span>
                <span class="s2">)</span>

            <span class="s4">return </span><span class="s1">key</span>

        <span class="s1">ret </span><span class="s2">= </span><span class="s1">getKey</span><span class="s2">(</span><span class="s1">axisPoints</span><span class="s2">, </span><span class="s1">axisOrder</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">ret</span>

    <span class="s4">def </span><span class="s1">reorderMasters</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">master_list</span><span class="s2">, </span><span class="s1">mapping</span><span class="s2">):</span>
        <span class="s6"># For changing the master data order without</span>
        <span class="s6"># recomputing supports and deltaWeights.</span>
        <span class="s1">new_list </span><span class="s2">= [</span><span class="s1">master_list</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">] </span><span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">mapping</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">origLocations </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">origLocations</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">] </span><span class="s4">for </span><span class="s1">idx </span><span class="s4">in </span><span class="s1">mapping</span><span class="s2">]</span>
        <span class="s1">locations </span><span class="s2">= [</span>
            <span class="s2">{</span><span class="s1">k</span><span class="s2">: </span><span class="s1">v </span><span class="s4">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s4">in </span><span class="s1">loc</span><span class="s2">.</span><span class="s1">items</span><span class="s2">() </span><span class="s4">if </span><span class="s1">v </span><span class="s2">!= </span><span class="s5">0.0</span><span class="s2">} </span><span class="s4">for </span><span class="s1">loc </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">origLocations</span>
        <span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">mapping </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">locations</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">l</span><span class="s2">) </span><span class="s4">for </span><span class="s1">l </span><span class="s4">in </span><span class="s1">locations</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">reverseMapping </span><span class="s2">= [</span><span class="s1">locations</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">l</span><span class="s2">) </span><span class="s4">for </span><span class="s1">l </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">locations</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_subModels </span><span class="s2">= {}</span>
        <span class="s4">return </span><span class="s1">new_list</span>

    <span class="s4">def </span><span class="s1">_computeMasterSupports</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">supports </span><span class="s2">= []</span>
        <span class="s1">regions </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_locationsToRegions</span><span class="s2">()</span>
        <span class="s4">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">region </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">regions</span><span class="s2">):</span>
            <span class="s1">locAxes </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">region</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
            <span class="s6"># Walk over previous masters now</span>
            <span class="s4">for </span><span class="s1">prev_region </span><span class="s4">in </span><span class="s1">regions</span><span class="s2">[:</span><span class="s1">i</span><span class="s2">]:</span>
                <span class="s6"># Master with different axes do not participte</span>
                <span class="s4">if </span><span class="s1">set</span><span class="s2">(</span><span class="s1">prev_region</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()) != </span><span class="s1">locAxes</span><span class="s2">:</span>
                    <span class="s4">continue</span>
                <span class="s6"># If it's NOT in the current box, it does not participate</span>
                <span class="s1">relevant </span><span class="s2">= </span><span class="s4">True</span>
                <span class="s4">for </span><span class="s1">axis</span><span class="s2">, (</span><span class="s1">lower</span><span class="s2">, </span><span class="s1">peak</span><span class="s2">, </span><span class="s1">upper</span><span class="s2">) </span><span class="s4">in </span><span class="s1">region</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                    <span class="s4">if not </span><span class="s2">(</span>
                        <span class="s1">prev_region</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">][</span><span class="s5">1</span><span class="s2">] == </span><span class="s1">peak</span>
                        <span class="s4">or </span><span class="s1">lower </span><span class="s2">&lt; </span><span class="s1">prev_region</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">][</span><span class="s5">1</span><span class="s2">] &lt; </span><span class="s1">upper</span>
                    <span class="s2">):</span>
                        <span class="s1">relevant </span><span class="s2">= </span><span class="s4">False</span>
                        <span class="s4">break</span>
                <span class="s4">if not </span><span class="s1">relevant</span><span class="s2">:</span>
                    <span class="s4">continue</span>

                <span class="s6"># Split the box for new master; split in whatever direction</span>
                <span class="s6"># that has largest range ratio.</span>
                <span class="s6">#</span>
                <span class="s6"># For symmetry, we actually cut across multiple axes</span>
                <span class="s6"># if they have the largest, equal, ratio.</span>
                <span class="s6"># https://github.com/fonttools/fonttools/commit/7ee81c8821671157968b097f3e55309a1faa511e#commitcomment-31054804</span>

                <span class="s1">bestAxes </span><span class="s2">= {}</span>
                <span class="s1">bestRatio </span><span class="s2">= -</span><span class="s5">1</span>
                <span class="s4">for </span><span class="s1">axis </span><span class="s4">in </span><span class="s1">prev_region</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">():</span>
                    <span class="s1">val </span><span class="s2">= </span><span class="s1">prev_region</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">][</span><span class="s5">1</span><span class="s2">]</span>
                    <span class="s4">assert </span><span class="s1">axis </span><span class="s4">in </span><span class="s1">region</span>
                    <span class="s1">lower</span><span class="s2">, </span><span class="s1">locV</span><span class="s2">, </span><span class="s1">upper </span><span class="s2">= </span><span class="s1">region</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
                    <span class="s1">newLower</span><span class="s2">, </span><span class="s1">newUpper </span><span class="s2">= </span><span class="s1">lower</span><span class="s2">, </span><span class="s1">upper</span>
                    <span class="s4">if </span><span class="s1">val </span><span class="s2">&lt; </span><span class="s1">locV</span><span class="s2">:</span>
                        <span class="s1">newLower </span><span class="s2">= </span><span class="s1">val</span>
                        <span class="s1">ratio </span><span class="s2">= (</span><span class="s1">val </span><span class="s2">- </span><span class="s1">locV</span><span class="s2">) / (</span><span class="s1">lower </span><span class="s2">- </span><span class="s1">locV</span><span class="s2">)</span>
                    <span class="s4">elif </span><span class="s1">locV </span><span class="s2">&lt; </span><span class="s1">val</span><span class="s2">:</span>
                        <span class="s1">newUpper </span><span class="s2">= </span><span class="s1">val</span>
                        <span class="s1">ratio </span><span class="s2">= (</span><span class="s1">val </span><span class="s2">- </span><span class="s1">locV</span><span class="s2">) / (</span><span class="s1">upper </span><span class="s2">- </span><span class="s1">locV</span><span class="s2">)</span>
                    <span class="s4">else</span><span class="s2">:  </span><span class="s6"># val == locV</span>
                        <span class="s6"># Can't split box in this direction.</span>
                        <span class="s4">continue</span>
                    <span class="s4">if </span><span class="s1">ratio </span><span class="s2">&gt; </span><span class="s1">bestRatio</span><span class="s2">:</span>
                        <span class="s1">bestAxes </span><span class="s2">= {}</span>
                        <span class="s1">bestRatio </span><span class="s2">= </span><span class="s1">ratio</span>
                    <span class="s4">if </span><span class="s1">ratio </span><span class="s2">== </span><span class="s1">bestRatio</span><span class="s2">:</span>
                        <span class="s1">bestAxes</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = (</span><span class="s1">newLower</span><span class="s2">, </span><span class="s1">locV</span><span class="s2">, </span><span class="s1">newUpper</span><span class="s2">)</span>

                <span class="s4">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">triple </span><span class="s4">in </span><span class="s1">bestAxes</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                    <span class="s1">region</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">triple</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">supports</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">region</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_computeDeltaWeights</span><span class="s2">()</span>

    <span class="s4">def </span><span class="s1">_locationsToRegions</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">locations </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">locations</span>
        <span class="s1">axisRanges </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axisRanges</span>

        <span class="s1">regions </span><span class="s2">= []</span>
        <span class="s4">for </span><span class="s1">loc </span><span class="s4">in </span><span class="s1">locations</span><span class="s2">:</span>
            <span class="s1">region </span><span class="s2">= {}</span>
            <span class="s4">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">locV </span><span class="s4">in </span><span class="s1">loc</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s4">if </span><span class="s1">locV </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
                    <span class="s1">region</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s1">locV</span><span class="s2">, </span><span class="s1">axisRanges</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">][</span><span class="s5">1</span><span class="s2">])</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">region</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = (</span><span class="s1">axisRanges</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">][</span><span class="s5">0</span><span class="s2">], </span><span class="s1">locV</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)</span>
            <span class="s1">regions</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">region</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">regions</span>

    <span class="s4">def </span><span class="s1">_computeDeltaWeights</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">deltaWeights </span><span class="s2">= []</span>
        <span class="s4">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">loc </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">locations</span><span class="s2">):</span>
            <span class="s1">deltaWeight </span><span class="s2">= {}</span>
            <span class="s6"># Walk over previous masters now, populate deltaWeight</span>
            <span class="s4">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">support </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">supports</span><span class="s2">[:</span><span class="s1">i</span><span class="s2">]):</span>
                <span class="s1">scalar </span><span class="s2">= </span><span class="s1">supportScalar</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">, </span><span class="s1">support</span><span class="s2">)</span>
                <span class="s4">if </span><span class="s1">scalar</span><span class="s2">:</span>
                    <span class="s1">deltaWeight</span><span class="s2">[</span><span class="s1">j</span><span class="s2">] = </span><span class="s1">scalar</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">deltaWeights</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">deltaWeight</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">getDeltas</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">masterValues</span><span class="s2">, *, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">noRound</span><span class="s2">):</span>
        <span class="s4">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">masterValues</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">deltaWeights</span><span class="s2">), (</span>
            <span class="s1">len</span><span class="s2">(</span><span class="s1">masterValues</span><span class="s2">),</span>
            <span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">deltaWeights</span><span class="s2">),</span>
        <span class="s2">)</span>
        <span class="s1">mapping </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">reverseMapping</span>
        <span class="s1">out </span><span class="s2">= []</span>
        <span class="s4">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">weights </span><span class="s4">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">deltaWeights</span><span class="s2">):</span>
            <span class="s1">delta </span><span class="s2">= </span><span class="s1">masterValues</span><span class="s2">[</span><span class="s1">mapping</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]]</span>
            <span class="s4">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">weight </span><span class="s4">in </span><span class="s1">weights</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s4">if </span><span class="s1">weight </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
                    <span class="s1">delta </span><span class="s2">-= </span><span class="s1">out</span><span class="s2">[</span><span class="s1">j</span><span class="s2">]</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">delta </span><span class="s2">-= </span><span class="s1">out</span><span class="s2">[</span><span class="s1">j</span><span class="s2">] * </span><span class="s1">weight</span>
            <span class="s1">out</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">round</span><span class="s2">(</span><span class="s1">delta</span><span class="s2">))</span>
        <span class="s4">return </span><span class="s1">out</span>

    <span class="s4">def </span><span class="s1">getDeltasAndSupports</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">items</span><span class="s2">, *, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">noRound</span><span class="s2">):</span>
        <span class="s1">model</span><span class="s2">, </span><span class="s1">items </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getSubModel</span><span class="s2">(</span><span class="s1">items</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">model</span><span class="s2">.</span><span class="s1">getDeltas</span><span class="s2">(</span><span class="s1">items</span><span class="s2">, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">round</span><span class="s2">), </span><span class="s1">model</span><span class="s2">.</span><span class="s1">supports</span>

    <span class="s4">def </span><span class="s1">getScalars</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Return scalars for each delta, for the given location. 
        If interpolating many master-values at the same location, 
        this function allows speed up by fetching the scalars once 
        and using them with interpolateFromMastersAndScalars().&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s2">[</span>
            <span class="s1">supportScalar</span><span class="s2">(</span>
                <span class="s1">loc</span><span class="s2">, </span><span class="s1">support</span><span class="s2">, </span><span class="s1">extrapolate</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">extrapolate</span><span class="s2">, </span><span class="s1">axisRanges</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axisRanges</span>
            <span class="s2">)</span>
            <span class="s4">for </span><span class="s1">support </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">supports</span>
        <span class="s2">]</span>

    <span class="s4">def </span><span class="s1">getMasterScalars</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">targetLocation</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Return multipliers for each master, for the given location. 
        If interpolating many master-values at the same location, 
        this function allows speed up by fetching the scalars once 
        and using them with interpolateFromValuesAndScalars(). 
 
        Note that the scalars used in interpolateFromMastersAndScalars(), 
        are *not* the same as the ones returned here. They are the result 
        of getScalars().&quot;&quot;&quot;</span>
        <span class="s1">out </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getScalars</span><span class="s2">(</span><span class="s1">targetLocation</span><span class="s2">)</span>
        <span class="s4">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">weights </span><span class="s4">in </span><span class="s1">reversed</span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">deltaWeights</span><span class="s2">))):</span>
            <span class="s4">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">weight </span><span class="s4">in </span><span class="s1">weights</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                <span class="s1">out</span><span class="s2">[</span><span class="s1">j</span><span class="s2">] -= </span><span class="s1">out</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] * </span><span class="s1">weight</span>

        <span class="s1">out </span><span class="s2">= [</span><span class="s1">out</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">mapping</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]] </span><span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">out</span><span class="s2">))]</span>
        <span class="s4">return </span><span class="s1">out</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s4">def </span><span class="s1">interpolateFromValuesAndScalars</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">scalars</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Interpolate from values and scalars coefficients. 
 
        If the values are master-values, then the scalars should be 
        fetched from getMasterScalars(). 
 
        If the values are deltas, then the scalars should be fetched 
        from getScalars(); in which case this is the same as 
        interpolateFromDeltasAndScalars(). 
        &quot;&quot;&quot;</span>
        <span class="s1">v </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s4">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">values</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">scalars</span><span class="s2">)</span>
        <span class="s4">for </span><span class="s1">value</span><span class="s2">, </span><span class="s1">scalar </span><span class="s4">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">scalars</span><span class="s2">):</span>
            <span class="s4">if not </span><span class="s1">scalar</span><span class="s2">:</span>
                <span class="s4">continue</span>
            <span class="s1">contribution </span><span class="s2">= </span><span class="s1">value </span><span class="s2">* </span><span class="s1">scalar</span>
            <span class="s4">if </span><span class="s1">v </span><span class="s4">is None</span><span class="s2">:</span>
                <span class="s1">v </span><span class="s2">= </span><span class="s1">contribution</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">v </span><span class="s2">+= </span><span class="s1">contribution</span>
        <span class="s4">return </span><span class="s1">v</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s4">def </span><span class="s1">interpolateFromDeltasAndScalars</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">scalars</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Interpolate from deltas and scalars fetched from getScalars().&quot;&quot;&quot;</span>
        <span class="s4">return </span><span class="s1">VariationModel</span><span class="s2">.</span><span class="s1">interpolateFromValuesAndScalars</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">scalars</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">interpolateFromDeltas</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Interpolate from deltas, at location loc.&quot;&quot;&quot;</span>
        <span class="s1">scalars </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getScalars</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">interpolateFromDeltasAndScalars</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">scalars</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">interpolateFromMasters</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">masterValues</span><span class="s2">, *, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">noRound</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Interpolate from master-values, at location loc.&quot;&quot;&quot;</span>
        <span class="s1">scalars </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getMasterScalars</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">interpolateFromValuesAndScalars</span><span class="s2">(</span><span class="s1">masterValues</span><span class="s2">, </span><span class="s1">scalars</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">interpolateFromMastersAndScalars</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">masterValues</span><span class="s2">, </span><span class="s1">scalars</span><span class="s2">, *, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">noRound</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Interpolate from master-values, and scalars fetched from 
        getScalars(), which is useful when you want to interpolate 
        multiple master-values with the same location.&quot;&quot;&quot;</span>
        <span class="s1">deltas </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getDeltas</span><span class="s2">(</span><span class="s1">masterValues</span><span class="s2">, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">round</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">interpolateFromDeltasAndScalars</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">scalars</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">piecewiseLinearMap</span><span class="s2">(</span><span class="s1">v</span><span class="s2">, </span><span class="s1">mapping</span><span class="s2">):</span>
    <span class="s1">keys </span><span class="s2">= </span><span class="s1">mapping</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()</span>
    <span class="s4">if not </span><span class="s1">keys</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">v</span>
    <span class="s4">if </span><span class="s1">v </span><span class="s4">in </span><span class="s1">keys</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">mapping</span><span class="s2">[</span><span class="s1">v</span><span class="s2">]</span>
    <span class="s1">k </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">keys</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">v </span><span class="s2">&lt; </span><span class="s1">k</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">v </span><span class="s2">+ </span><span class="s1">mapping</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] - </span><span class="s1">k</span>
    <span class="s1">k </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">keys</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">v </span><span class="s2">&gt; </span><span class="s1">k</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">v </span><span class="s2">+ </span><span class="s1">mapping</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] - </span><span class="s1">k</span>
    <span class="s6"># Interpolate</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">k </span><span class="s4">for </span><span class="s1">k </span><span class="s4">in </span><span class="s1">keys </span><span class="s4">if </span><span class="s1">k </span><span class="s2">&lt; </span><span class="s1">v</span><span class="s2">)</span>
    <span class="s1">b </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">k </span><span class="s4">for </span><span class="s1">k </span><span class="s4">in </span><span class="s1">keys </span><span class="s4">if </span><span class="s1">k </span><span class="s2">&gt; </span><span class="s1">v</span><span class="s2">)</span>
    <span class="s1">va </span><span class="s2">= </span><span class="s1">mapping</span><span class="s2">[</span><span class="s1">a</span><span class="s2">]</span>
    <span class="s1">vb </span><span class="s2">= </span><span class="s1">mapping</span><span class="s2">[</span><span class="s1">b</span><span class="s2">]</span>
    <span class="s4">return </span><span class="s1">va </span><span class="s2">+ (</span><span class="s1">vb </span><span class="s2">- </span><span class="s1">va</span><span class="s2">) * (</span><span class="s1">v </span><span class="s2">- </span><span class="s1">a</span><span class="s2">) / (</span><span class="s1">b </span><span class="s2">- </span><span class="s1">a</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">main</span><span class="s2">(</span><span class="s1">args</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Normalize locations on a given designspace&quot;&quot;&quot;</span>
    <span class="s4">from </span><span class="s1">fontTools </span><span class="s4">import </span><span class="s1">configLogger</span>
    <span class="s4">import </span><span class="s1">argparse</span>

    <span class="s1">parser </span><span class="s2">= </span><span class="s1">argparse</span><span class="s2">.</span><span class="s1">ArgumentParser</span><span class="s2">(</span>
        <span class="s3">&quot;fonttools varLib.models&quot;</span><span class="s2">,</span>
        <span class="s1">description</span><span class="s2">=</span><span class="s1">main</span><span class="s2">.</span><span class="s1">__doc__</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s1">parser</span><span class="s2">.</span><span class="s1">add_argument</span><span class="s2">(</span>
        <span class="s3">&quot;--loglevel&quot;</span><span class="s2">,</span>
        <span class="s1">metavar</span><span class="s2">=</span><span class="s3">&quot;LEVEL&quot;</span><span class="s2">,</span>
        <span class="s1">default</span><span class="s2">=</span><span class="s3">&quot;INFO&quot;</span><span class="s2">,</span>
        <span class="s1">help</span><span class="s2">=</span><span class="s3">&quot;Logging level (defaults to INFO)&quot;</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s1">group </span><span class="s2">= </span><span class="s1">parser</span><span class="s2">.</span><span class="s1">add_mutually_exclusive_group</span><span class="s2">(</span><span class="s1">required</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
    <span class="s1">group</span><span class="s2">.</span><span class="s1">add_argument</span><span class="s2">(</span><span class="s3">&quot;-d&quot;</span><span class="s2">, </span><span class="s3">&quot;--designspace&quot;</span><span class="s2">, </span><span class="s1">metavar</span><span class="s2">=</span><span class="s3">&quot;DESIGNSPACE&quot;</span><span class="s2">, </span><span class="s1">type</span><span class="s2">=</span><span class="s1">str</span><span class="s2">)</span>
    <span class="s1">group</span><span class="s2">.</span><span class="s1">add_argument</span><span class="s2">(</span>
        <span class="s3">&quot;-l&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;--locations&quot;</span><span class="s2">,</span>
        <span class="s1">metavar</span><span class="s2">=</span><span class="s3">&quot;LOCATION&quot;</span><span class="s2">,</span>
        <span class="s1">nargs</span><span class="s2">=</span><span class="s3">&quot;+&quot;</span><span class="s2">,</span>
        <span class="s1">help</span><span class="s2">=</span><span class="s3">&quot;Master locations as comma-separate coordinates. One must be all zeros.&quot;</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s1">args </span><span class="s2">= </span><span class="s1">parser</span><span class="s2">.</span><span class="s1">parse_args</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>

    <span class="s1">configLogger</span><span class="s2">(</span><span class="s1">level</span><span class="s2">=</span><span class="s1">args</span><span class="s2">.</span><span class="s1">loglevel</span><span class="s2">)</span>
    <span class="s4">from </span><span class="s1">pprint </span><span class="s4">import </span><span class="s1">pprint</span>

    <span class="s4">if </span><span class="s1">args</span><span class="s2">.</span><span class="s1">designspace</span><span class="s2">:</span>
        <span class="s4">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">designspaceLib </span><span class="s4">import </span><span class="s1">DesignSpaceDocument</span>

        <span class="s1">doc </span><span class="s2">= </span><span class="s1">DesignSpaceDocument</span><span class="s2">()</span>
        <span class="s1">doc</span><span class="s2">.</span><span class="s1">read</span><span class="s2">(</span><span class="s1">args</span><span class="s2">.</span><span class="s1">designspace</span><span class="s2">)</span>
        <span class="s1">locs </span><span class="s2">= [</span><span class="s1">s</span><span class="s2">.</span><span class="s1">location </span><span class="s4">for </span><span class="s1">s </span><span class="s4">in </span><span class="s1">doc</span><span class="s2">.</span><span class="s1">sources</span><span class="s2">]</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;Original locations:&quot;</span><span class="s2">)</span>
        <span class="s1">pprint</span><span class="s2">(</span><span class="s1">locs</span><span class="s2">)</span>
        <span class="s1">doc</span><span class="s2">.</span><span class="s1">normalize</span><span class="s2">()</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;Normalized locations:&quot;</span><span class="s2">)</span>
        <span class="s1">locs </span><span class="s2">= [</span><span class="s1">s</span><span class="s2">.</span><span class="s1">location </span><span class="s4">for </span><span class="s1">s </span><span class="s4">in </span><span class="s1">doc</span><span class="s2">.</span><span class="s1">sources</span><span class="s2">]</span>
        <span class="s1">pprint</span><span class="s2">(</span><span class="s1">locs</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">axes </span><span class="s2">= [</span><span class="s1">chr</span><span class="s2">(</span><span class="s1">c</span><span class="s2">) </span><span class="s4">for </span><span class="s1">c </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">ord</span><span class="s2">(</span><span class="s3">&quot;A&quot;</span><span class="s2">), </span><span class="s1">ord</span><span class="s2">(</span><span class="s3">&quot;Z&quot;</span><span class="s2">) + </span><span class="s5">1</span><span class="s2">)]</span>
        <span class="s1">locs </span><span class="s2">= [</span>
            <span class="s1">dict</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">axes</span><span class="s2">, (</span><span class="s1">float</span><span class="s2">(</span><span class="s1">v</span><span class="s2">) </span><span class="s4">for </span><span class="s1">v </span><span class="s4">in </span><span class="s1">s</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s3">&quot;,&quot;</span><span class="s2">)))) </span><span class="s4">for </span><span class="s1">s </span><span class="s4">in </span><span class="s1">args</span><span class="s2">.</span><span class="s1">locations</span>
        <span class="s2">]</span>

    <span class="s1">model </span><span class="s2">= </span><span class="s1">VariationModel</span><span class="s2">(</span><span class="s1">locs</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;Sorted locations:&quot;</span><span class="s2">)</span>
    <span class="s1">pprint</span><span class="s2">(</span><span class="s1">model</span><span class="s2">.</span><span class="s1">locations</span><span class="s2">)</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;Supports:&quot;</span><span class="s2">)</span>
    <span class="s1">pprint</span><span class="s2">(</span><span class="s1">model</span><span class="s2">.</span><span class="s1">supports</span><span class="s2">)</span>


<span class="s4">if </span><span class="s1">__name__ </span><span class="s2">== </span><span class="s3">&quot;__main__&quot;</span><span class="s2">:</span>
    <span class="s4">import </span><span class="s1">doctest</span><span class="s2">, </span><span class="s1">sys</span>

    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">argv</span><span class="s2">) &gt; </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s1">sys</span><span class="s2">.</span><span class="s1">exit</span><span class="s2">(</span><span class="s1">main</span><span class="s2">())</span>

    <span class="s1">sys</span><span class="s2">.</span><span class="s1">exit</span><span class="s2">(</span><span class="s1">doctest</span><span class="s2">.</span><span class="s1">testmod</span><span class="s2">().</span><span class="s1">failed</span><span class="s2">)</span>
</pre>
</body>
</html>