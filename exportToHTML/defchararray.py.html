<html>
<head>
<title>defchararray.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
defchararray.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
This module contains a set of functions for vectorized string 
operations and methods. 
 
.. note:: 
   The `chararray` class exists for backwards compatibility with 
   Numarray, it is not recommended for new development. Starting from numpy 
   1.4, if one needs arrays of strings, it is recommended to use arrays of 
   `dtype` `object_`, `bytes_` or `str_`, and use the free functions 
   in the `numpy.char` module for fast vectorized string operations. 
 
Some methods will only be available if the corresponding string method is 
available in your version of Python. 
 
The preferred alias for `defchararray` is `numpy.char`. 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">functools</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">_utils </span><span class="s2">import </span><span class="s1">set_module</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">numerictypes </span><span class="s2">import </span><span class="s1">bytes_</span><span class="s3">, </span><span class="s1">str_</span><span class="s3">, </span><span class="s1">character</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">numeric </span><span class="s2">import </span><span class="s1">ndarray</span><span class="s3">, </span><span class="s1">array </span><span class="s2">as </span><span class="s1">narray</span><span class="s3">, </span><span class="s1">asarray </span><span class="s2">as </span><span class="s1">asnarray</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">_core</span><span class="s3">.</span><span class="s1">multiarray </span><span class="s2">import </span><span class="s1">compare_chararrays</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">_core </span><span class="s2">import </span><span class="s1">overrides</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">strings </span><span class="s2">import </span><span class="s3">*</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">strings </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">multiply </span><span class="s2">as </span><span class="s1">strings_multiply</span><span class="s3">,</span>
    <span class="s1">partition </span><span class="s2">as </span><span class="s1">strings_partition</span><span class="s3">,</span>
    <span class="s1">rpartition </span><span class="s2">as </span><span class="s1">strings_rpartition</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">_core</span><span class="s3">.</span><span class="s1">strings </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">_split </span><span class="s2">as </span><span class="s1">split</span><span class="s3">,</span>
    <span class="s1">_rsplit </span><span class="s2">as </span><span class="s1">rsplit</span><span class="s3">,</span>
    <span class="s1">_splitlines </span><span class="s2">as </span><span class="s1">splitlines</span><span class="s3">,</span>
    <span class="s1">_join </span><span class="s2">as </span><span class="s1">join</span><span class="s3">,</span>
<span class="s3">)</span>

<span class="s1">__all__ </span><span class="s3">= [</span>
    <span class="s4">'equal'</span><span class="s3">, </span><span class="s4">'not_equal'</span><span class="s3">, </span><span class="s4">'greater_equal'</span><span class="s3">, </span><span class="s4">'less_equal'</span><span class="s3">,</span>
    <span class="s4">'greater'</span><span class="s3">, </span><span class="s4">'less'</span><span class="s3">, </span><span class="s4">'str_len'</span><span class="s3">, </span><span class="s4">'add'</span><span class="s3">, </span><span class="s4">'multiply'</span><span class="s3">, </span><span class="s4">'mod'</span><span class="s3">, </span><span class="s4">'capitalize'</span><span class="s3">,</span>
    <span class="s4">'center'</span><span class="s3">, </span><span class="s4">'count'</span><span class="s3">, </span><span class="s4">'decode'</span><span class="s3">, </span><span class="s4">'encode'</span><span class="s3">, </span><span class="s4">'endswith'</span><span class="s3">, </span><span class="s4">'expandtabs'</span><span class="s3">,</span>
    <span class="s4">'find'</span><span class="s3">, </span><span class="s4">'index'</span><span class="s3">, </span><span class="s4">'isalnum'</span><span class="s3">, </span><span class="s4">'isalpha'</span><span class="s3">, </span><span class="s4">'isdigit'</span><span class="s3">, </span><span class="s4">'islower'</span><span class="s3">, </span><span class="s4">'isspace'</span><span class="s3">,</span>
    <span class="s4">'istitle'</span><span class="s3">, </span><span class="s4">'isupper'</span><span class="s3">, </span><span class="s4">'join'</span><span class="s3">, </span><span class="s4">'ljust'</span><span class="s3">, </span><span class="s4">'lower'</span><span class="s3">, </span><span class="s4">'lstrip'</span><span class="s3">, </span><span class="s4">'partition'</span><span class="s3">,</span>
    <span class="s4">'replace'</span><span class="s3">, </span><span class="s4">'rfind'</span><span class="s3">, </span><span class="s4">'rindex'</span><span class="s3">, </span><span class="s4">'rjust'</span><span class="s3">, </span><span class="s4">'rpartition'</span><span class="s3">, </span><span class="s4">'rsplit'</span><span class="s3">,</span>
    <span class="s4">'rstrip'</span><span class="s3">, </span><span class="s4">'split'</span><span class="s3">, </span><span class="s4">'splitlines'</span><span class="s3">, </span><span class="s4">'startswith'</span><span class="s3">, </span><span class="s4">'strip'</span><span class="s3">, </span><span class="s4">'swapcase'</span><span class="s3">,</span>
    <span class="s4">'title'</span><span class="s3">, </span><span class="s4">'translate'</span><span class="s3">, </span><span class="s4">'upper'</span><span class="s3">, </span><span class="s4">'zfill'</span><span class="s3">, </span><span class="s4">'isnumeric'</span><span class="s3">, </span><span class="s4">'isdecimal'</span><span class="s3">,</span>
    <span class="s4">'array'</span><span class="s3">, </span><span class="s4">'asarray'</span><span class="s3">, </span><span class="s4">'compare_chararrays'</span><span class="s3">, </span><span class="s4">'chararray'</span>
    <span class="s3">]</span>


<span class="s1">array_function_dispatch </span><span class="s3">= </span><span class="s1">functools</span><span class="s3">.</span><span class="s1">partial</span><span class="s3">(</span>
    <span class="s1">overrides</span><span class="s3">.</span><span class="s1">array_function_dispatch</span><span class="s3">, </span><span class="s1">module</span><span class="s3">=</span><span class="s4">'numpy.char'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_binary_op_dispatcher</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">array_function_dispatch</span><span class="s3">(</span><span class="s1">_binary_op_dispatcher</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">equal</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (x1 == x2) element-wise. 
 
    Unlike `numpy.equal`, this comparison is performed by first 
    stripping whitespace characters from the end of the string.  This 
    behavior is provided for backward-compatibility with numarray. 
 
    Parameters 
    ---------- 
    x1, x2 : array_like of str or unicode 
        Input arrays of the same shape. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; y = &quot;aa &quot; 
    &gt;&gt;&gt; x = &quot;aa&quot; 
    &gt;&gt;&gt; np.char.equal(x, y) 
    array(True) 
 
    See Also 
    -------- 
    not_equal, greater_equal, less_equal, greater, less 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">compare_chararrays</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s4">'=='</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">array_function_dispatch</span><span class="s3">(</span><span class="s1">_binary_op_dispatcher</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">not_equal</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (x1 != x2) element-wise. 
 
    Unlike `numpy.not_equal`, this comparison is performed by first 
    stripping whitespace characters from the end of the string.  This 
    behavior is provided for backward-compatibility with numarray. 
 
    Parameters 
    ---------- 
    x1, x2 : array_like of str or unicode 
        Input arrays of the same shape. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools. 
 
    See Also 
    -------- 
    equal, greater_equal, less_equal, greater, less 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x1 = np.array(['a', 'b', 'c']) 
    &gt;&gt;&gt; np.char.not_equal(x1, 'b') 
    array([ True, False,  True]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">compare_chararrays</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s4">'!='</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">array_function_dispatch</span><span class="s3">(</span><span class="s1">_binary_op_dispatcher</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">greater_equal</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (x1 &gt;= x2) element-wise. 
 
    Unlike `numpy.greater_equal`, this comparison is performed by 
    first stripping whitespace characters from the end of the string. 
    This behavior is provided for backward-compatibility with 
    numarray. 
 
    Parameters 
    ---------- 
    x1, x2 : array_like of str or unicode 
        Input arrays of the same shape. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools. 
 
    See Also 
    -------- 
    equal, not_equal, less_equal, greater, less 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x1 = np.array(['a', 'b', 'c']) 
    &gt;&gt;&gt; np.char.greater_equal(x1, 'b') 
    array([False,  True,  True]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">compare_chararrays</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s4">'&gt;='</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">array_function_dispatch</span><span class="s3">(</span><span class="s1">_binary_op_dispatcher</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">less_equal</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (x1 &lt;= x2) element-wise. 
 
    Unlike `numpy.less_equal`, this comparison is performed by first 
    stripping whitespace characters from the end of the string.  This 
    behavior is provided for backward-compatibility with numarray. 
 
    Parameters 
    ---------- 
    x1, x2 : array_like of str or unicode 
        Input arrays of the same shape. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools. 
 
    See Also 
    -------- 
    equal, not_equal, greater_equal, greater, less 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x1 = np.array(['a', 'b', 'c']) 
    &gt;&gt;&gt; np.char.less_equal(x1, 'b') 
    array([ True,  True, False]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">compare_chararrays</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s4">'&lt;='</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">array_function_dispatch</span><span class="s3">(</span><span class="s1">_binary_op_dispatcher</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">greater</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (x1 &gt; x2) element-wise. 
 
    Unlike `numpy.greater`, this comparison is performed by first 
    stripping whitespace characters from the end of the string.  This 
    behavior is provided for backward-compatibility with numarray. 
 
    Parameters 
    ---------- 
    x1, x2 : array_like of str or unicode 
        Input arrays of the same shape. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools. 
 
    See Also 
    -------- 
    equal, not_equal, greater_equal, less_equal, less 
     
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x1 = np.array(['a', 'b', 'c']) 
    &gt;&gt;&gt; np.char.greater(x1, 'b') 
    array([False, False,  True]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">compare_chararrays</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s4">'&gt;'</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">array_function_dispatch</span><span class="s3">(</span><span class="s1">_binary_op_dispatcher</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">less</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (x1 &lt; x2) element-wise. 
 
    Unlike `numpy.greater`, this comparison is performed by first 
    stripping whitespace characters from the end of the string.  This 
    behavior is provided for backward-compatibility with numarray. 
 
    Parameters 
    ---------- 
    x1, x2 : array_like of str or unicode 
        Input arrays of the same shape. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of bools. 
 
    See Also 
    -------- 
    equal, not_equal, greater_equal, less_equal, greater 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x1 = np.array(['a', 'b', 'c']) 
    &gt;&gt;&gt; np.char.less(x1, 'b') 
    array([True, False, False]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">compare_chararrays</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s4">'&lt;'</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">i</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (a * i), that is string multiple concatenation, 
    element-wise. 
 
    Values in ``i`` of less than 0 are treated as 0 (which yields an 
    empty string). 
 
    Parameters 
    ---------- 
    a : array_like, with `np.bytes_` or `np.str_` dtype 
 
    i : array_like, with any integer dtype 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of str or unicode, depending on input types 
 
    Notes 
    ----- 
    This is a thin wrapper around np.strings.multiply that raises 
    `ValueError` when ``i`` is not an integer. It only 
    exists for backwards-compatibility. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) 
    &gt;&gt;&gt; np.strings.multiply(a, 3) 
    array(['aaa', 'bbb', 'ccc'], dtype='&lt;U3') 
    &gt;&gt;&gt; i = np.array([1, 2, 3]) 
    &gt;&gt;&gt; np.strings.multiply(a, i) 
    array(['a', 'bb', 'ccc'], dtype='&lt;U3') 
    &gt;&gt;&gt; np.strings.multiply(np.array(['a']), i) 
    array(['a', 'aa', 'aaa'], dtype='&lt;U3') 
    &gt;&gt;&gt; a = np.array(['a', 'b', 'c', 'd', 'e', 'f']).reshape((2, 3)) 
    &gt;&gt;&gt; np.strings.multiply(a, 3) 
    array([['aaa', 'bbb', 'ccc'], 
           ['ddd', 'eee', 'fff']], dtype='&lt;U3') 
    &gt;&gt;&gt; np.strings.multiply(a, i) 
    array([['a', 'bb', 'ccc'], 
           ['d', 'ee', 'fff']], dtype='&lt;U3') 
 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">strings_multiply</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">TypeError</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Can only multiply by integers&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">partition</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Partition each element in `a` around `sep`. 
 
    Calls :meth:`str.partition` element-wise. 
 
    For each element in `a`, split the element as the first 
    occurrence of `sep`, and return 3 strings containing the part 
    before the separator, the separator itself, and the part after 
    the separator. If the separator is not found, return 3 strings 
    containing the string itself, followed by two empty strings. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
        Input array 
    sep : {str, unicode} 
        Separator to split each string element in `a`. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input types. The output array will have an extra 
        dimension with 3 elements per input element. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.array([&quot;Numpy is nice!&quot;]) 
    &gt;&gt;&gt; np.char.partition(x, &quot; &quot;) 
    array([['Numpy', ' ', 'is nice!']], dtype='&lt;U8') 
 
    See Also 
    -------- 
    str.partition 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">stack</span><span class="s3">(</span><span class="s1">strings_partition</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">rpartition</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Partition (split) each element around the right-most separator. 
 
    Calls :meth:`str.rpartition` element-wise. 
 
    For each element in `a`, split the element as the last 
    occurrence of `sep`, and return 3 strings containing the part 
    before the separator, the separator itself, and the part after 
    the separator. If the separator is not found, return 3 strings 
    containing the string itself, followed by two empty strings. 
 
    Parameters 
    ---------- 
    a : array-like, with ``StringDType``, ``bytes_``, or ``str_`` dtype 
        Input array 
    sep : str or unicode 
        Right-most separator to split each element in array. 
 
    Returns 
    ------- 
    out : ndarray 
        Output array of ``StringDType``, ``bytes_`` or ``str_`` dtype, 
        depending on input types. The output array will have an extra 
        dimension with 3 elements per input element. 
 
    See Also 
    -------- 
    str.rpartition 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array(['aAaAaA', '  aA  ', 'abBABba']) 
    &gt;&gt;&gt; np.char.rpartition(a, 'A') 
    array([['aAaAa', 'A', ''], 
       ['  a', 'A', '  '], 
       ['abB', 'A', 'Bba']], dtype='&lt;U5') 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">stack</span><span class="s3">(</span><span class="s1">strings_rpartition</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">set_module</span><span class="s3">(</span><span class="s4">&quot;numpy.char&quot;</span><span class="s3">)</span>
<span class="s2">class </span><span class="s1">chararray</span><span class="s3">(</span><span class="s1">ndarray</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    chararray(shape, itemsize=1, unicode=False, buffer=None, offset=0, 
              strides=None, order=None) 
 
    Provides a convenient view on arrays of string and unicode values. 
 
    .. note:: 
       The `chararray` class exists for backwards compatibility with 
       Numarray, it is not recommended for new development. Starting from numpy 
       1.4, if one needs arrays of strings, it is recommended to use arrays of 
       `dtype` `~numpy.object_`, `~numpy.bytes_` or `~numpy.str_`, and use 
       the free functions in the `numpy.char` module for fast vectorized 
       string operations. 
 
    Versus a NumPy array of dtype `~numpy.bytes_` or `~numpy.str_`, this 
    class adds the following functionality: 
 
    1) values automatically have whitespace removed from the end 
       when indexed 
 
    2) comparison operators automatically remove whitespace from the 
       end when comparing values 
 
    3) vectorized string operations are provided as methods 
       (e.g. `.endswith`) and infix operators (e.g. ``&quot;+&quot;, &quot;*&quot;, &quot;%&quot;``) 
 
    chararrays should be created using `numpy.char.array` or 
    `numpy.char.asarray`, rather than this constructor directly. 
 
    This constructor creates the array, using `buffer` (with `offset` 
    and `strides`) if it is not ``None``. If `buffer` is ``None``, then 
    constructs a new array with `strides` in &quot;C order&quot;, unless both 
    ``len(shape) &gt;= 2`` and ``order='F'``, in which case `strides` 
    is in &quot;Fortran order&quot;. 
 
    Methods 
    ------- 
    astype 
    argsort 
    copy 
    count 
    decode 
    dump 
    dumps 
    encode 
    endswith 
    expandtabs 
    fill 
    find 
    flatten 
    getfield 
    index 
    isalnum 
    isalpha 
    isdecimal 
    isdigit 
    islower 
    isnumeric 
    isspace 
    istitle 
    isupper 
    item 
    join 
    ljust 
    lower 
    lstrip 
    nonzero 
    put 
    ravel 
    repeat 
    replace 
    reshape 
    resize 
    rfind 
    rindex 
    rjust 
    rsplit 
    rstrip 
    searchsorted 
    setfield 
    setflags 
    sort 
    split 
    splitlines 
    squeeze 
    startswith 
    strip 
    swapaxes 
    swapcase 
    take 
    title 
    tofile 
    tolist 
    tostring 
    translate 
    transpose 
    upper 
    view 
    zfill 
 
    Parameters 
    ---------- 
    shape : tuple 
        Shape of the array. 
    itemsize : int, optional 
        Length of each array element, in number of characters. Default is 1. 
    unicode : bool, optional 
        Are the array elements of type unicode (True) or string (False). 
        Default is False. 
    buffer : object exposing the buffer interface or str, optional 
        Memory address of the start of the array data.  Default is None, 
        in which case a new array is created. 
    offset : int, optional 
        Fixed stride displacement from the beginning of an axis? 
        Default is 0. Needs to be &gt;=0. 
    strides : array_like of ints, optional 
        Strides for the array (see `~numpy.ndarray.strides` for 
        full description). Default is None. 
    order : {'C', 'F'}, optional 
        The order in which the array data is stored in memory: 'C' -&gt; 
        &quot;row major&quot; order (the default), 'F' -&gt; &quot;column major&quot; 
        (Fortran) order. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; charar = np.char.chararray((3, 3)) 
    &gt;&gt;&gt; charar[:] = 'a' 
    &gt;&gt;&gt; charar 
    chararray([[b'a', b'a', b'a'], 
               [b'a', b'a', b'a'], 
               [b'a', b'a', b'a']], dtype='|S1') 
 
    &gt;&gt;&gt; charar = np.char.chararray(charar.shape, itemsize=5) 
    &gt;&gt;&gt; charar[:] = 'abc' 
    &gt;&gt;&gt; charar 
    chararray([[b'abc', b'abc', b'abc'], 
               [b'abc', b'abc', b'abc'], 
               [b'abc', b'abc', b'abc']], dtype='|S5') 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__new__</span><span class="s3">(</span><span class="s1">subtype</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">unicode</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">buffer</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s1">offset</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s4">'C'</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">unicode</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">str_</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">bytes_</span>

        <span class="s6"># force itemsize to be a Python int, since using NumPy integer</span>
        <span class="s6"># types results in itemsize.itemsize being used as the size of</span>
        <span class="s6"># strings in the new array.</span>
        <span class="s1">itemsize </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">itemsize</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">buffer</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s6"># unicode objects do not have the buffer interface</span>
            <span class="s1">filler </span><span class="s3">= </span><span class="s1">buffer</span>
            <span class="s1">buffer </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">filler </span><span class="s3">= </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">buffer </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">self </span><span class="s3">= </span><span class="s1">ndarray</span><span class="s3">.</span><span class="s1">__new__</span><span class="s3">(</span><span class="s1">subtype</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, (</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">),</span>
                                   <span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self </span><span class="s3">= </span><span class="s1">ndarray</span><span class="s3">.</span><span class="s1">__new__</span><span class="s3">(</span><span class="s1">subtype</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, (</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">),</span>
                                   <span class="s1">buffer</span><span class="s3">=</span><span class="s1">buffer</span><span class="s3">,</span>
                                   <span class="s1">offset</span><span class="s3">=</span><span class="s1">offset</span><span class="s3">, </span><span class="s1">strides</span><span class="s3">=</span><span class="s1">strides</span><span class="s3">,</span>
                                   <span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">filler </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">[...] = </span><span class="s1">filler</span>

        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__array_wrap__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">context</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">return_scalar</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s6"># When calling a ufunc (and some other functions), we return a</span>
        <span class="s6"># chararray if the ufunc output is a string-like array,</span>
        <span class="s6"># or an ndarray otherwise</span>
        <span class="s2">if </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char </span><span class="s2">in </span><span class="s4">&quot;SUbc&quot;</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">view</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">arr</span>

    <span class="s2">def </span><span class="s1">__array_finalize__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">):</span>
        <span class="s6"># The b is a special case because it is used for reconstructing.</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char </span><span class="s2">not in </span><span class="s4">'VSUbc'</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Can only create a chararray from string data.&quot;</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">):</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s1">ndarray</span><span class="s3">.</span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">val</span><span class="s3">, </span><span class="s1">character</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">val</span><span class="s3">.</span><span class="s1">rstrip</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">val</span>

    <span class="s6"># IMPLEMENTATION NOTE: Most of the methods of this class are</span>
    <span class="s6"># direct delegations to the free functions in this module.</span>
    <span class="s6"># However, those that return an array of strings should instead</span>
    <span class="s6"># return a chararray, so some extra wrapping is required.</span>

    <span class="s2">def </span><span class="s1">__eq__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self == other) element-wise. 
 
        See Also 
        -------- 
        equal 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">equal</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__ne__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self != other) element-wise. 
 
        See Also 
        -------- 
        not_equal 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">not_equal</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__ge__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self &gt;= other) element-wise. 
 
        See Also 
        -------- 
        greater_equal 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">greater_equal</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__le__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self &lt;= other) element-wise. 
 
        See Also 
        -------- 
        less_equal 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">less_equal</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__gt__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self &gt; other) element-wise. 
 
        See Also 
        -------- 
        greater 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">greater</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__lt__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self &lt; other) element-wise. 
 
        See Also 
        -------- 
        less 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">less</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__add__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self + other), that is string concatenation, 
        element-wise for a pair of array_likes of str or unicode. 
 
        See Also 
        -------- 
        add 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">add</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__radd__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (other + self), that is string concatenation, 
        element-wise for a pair of array_likes of `bytes_` or `str_`. 
 
        See Also 
        -------- 
        add 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">add</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__mul__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">i</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self * i), that is string multiple concatenation, 
        element-wise. 
 
        See Also 
        -------- 
        multiply 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">i</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">__rmul__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">i</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self * i), that is string multiple concatenation, 
        element-wise. 
 
        See Also 
        -------- 
        multiply 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">i</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">__mod__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">i</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return (self % i), that is pre-Python 2.6 string formatting 
        (interpolation), element-wise for a pair of array_likes of `bytes_` 
        or `str_`. 
 
        See Also 
        -------- 
        mod 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">mod</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">i</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">__rmod__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">def </span><span class="s1">argsort</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the indices that sort the array lexicographically. 
 
        For full documentation see `numpy.argsort`, for which this method is 
        in fact merely a &quot;thin wrapper.&quot; 
 
        Examples 
        -------- 
        &gt;&gt;&gt; c = np.array(['a1b c', '1b ca', 'b ca1', 'Ca1b'], 'S5') 
        &gt;&gt;&gt; c = c.view(np.char.chararray); c 
        chararray(['a1b c', '1b ca', 'b ca1', 'Ca1b'], 
              dtype='|S5') 
        &gt;&gt;&gt; c[c.argsort()] 
        chararray(['1b ca', 'Ca1b', 'a1b c', 'b ca1'], 
              dtype='|S5') 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__array__</span><span class="s3">().</span><span class="s1">argsort</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">, </span><span class="s1">order</span><span class="s3">)</span>
    <span class="s1">argsort</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= </span><span class="s1">ndarray</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">.</span><span class="s1">__doc__</span>

    <span class="s2">def </span><span class="s1">capitalize</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of `self` with only the first character of each element 
        capitalized. 
 
        See Also 
        -------- 
        char.capitalize 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">capitalize</span><span class="s3">(</span><span class="s1">self</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">center</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">=</span><span class="s4">' '</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of `self` with its elements centered in a 
        string of length `width`. 
 
        See Also 
        -------- 
        center 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">center</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">count</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns an array with the number of non-overlapping occurrences of 
        substring `sub` in the range [`start`, `end`]. 
 
        See Also 
        -------- 
        char.count 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">count</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">decode</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">errors</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calls ``bytes.decode`` element-wise. 
 
        See Also 
        -------- 
        char.decode 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">decode</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">, </span><span class="s1">errors</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">encode</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">errors</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calls :meth:`str.encode` element-wise. 
 
        See Also 
        -------- 
        char.encode 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">encode</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">, </span><span class="s1">errors</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">endswith</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">suffix</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a boolean array which is `True` where the string element 
        in `self` ends with `suffix`, otherwise `False`. 
 
        See Also 
        -------- 
        char.endswith 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">endswith</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">suffix</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">expandtabs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tabsize</span><span class="s3">=</span><span class="s5">8</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of each string element where all tab characters are 
        replaced by one or more spaces. 
 
        See Also 
        -------- 
        char.expandtabs 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">expandtabs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tabsize</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">find</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element, return the lowest index in the string where 
        substring `sub` is found. 
 
        See Also 
        -------- 
        char.find 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">find</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">index</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Like `find`, but raises :exc:`ValueError` when the substring is not 
        found. 
 
        See Also 
        -------- 
        char.index 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">index</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">isalnum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns true for each element if all characters in the string 
        are alphanumeric and there is at least one character, false 
        otherwise. 
 
        See Also 
        -------- 
        char.isalnum 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isalnum</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">isalpha</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns true for each element if all characters in the string 
        are alphabetic and there is at least one character, false 
        otherwise. 
 
        See Also 
        -------- 
        char.isalpha 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isalpha</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">isdigit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns true for each element if all characters in the string are 
        digits and there is at least one character, false otherwise. 
 
        See Also 
        -------- 
        char.isdigit 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isdigit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">islower</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns true for each element if all cased characters in the 
        string are lowercase and there is at least one cased character, 
        false otherwise. 
 
        See Also 
        -------- 
        char.islower 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">islower</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">isspace</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns true for each element if there are only whitespace 
        characters in the string and there is at least one character, 
        false otherwise. 
 
        See Also 
        -------- 
        char.isspace 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isspace</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">istitle</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns true for each element if the element is a titlecased 
        string and there is at least one character, false otherwise. 
 
        See Also 
        -------- 
        char.istitle 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">istitle</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">isupper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns true for each element if all cased characters in the 
        string are uppercase and there is at least one character, false 
        otherwise. 
 
        See Also 
        -------- 
        char.isupper 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isupper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">join</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a string which is the concatenation of the strings in the 
        sequence `seq`. 
 
        See Also 
        -------- 
        char.join 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">join</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">seq</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">ljust</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">=</span><span class="s4">' '</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return an array with the elements of `self` left-justified in a 
        string of length `width`. 
 
        See Also 
        -------- 
        char.ljust 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">ljust</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">lower</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return an array with the elements of `self` converted to 
        lowercase. 
 
        See Also 
        -------- 
        char.lower 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">lower</span><span class="s3">(</span><span class="s1">self</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">lstrip</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">chars</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a copy with the leading characters 
        removed. 
 
        See Also 
        -------- 
        char.lstrip 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">lstrip</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">chars</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">partition</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Partition each element in `self` around `sep`. 
 
        See Also 
        -------- 
        partition 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">partition</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">replace</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">old</span><span class="s3">, </span><span class="s1">new</span><span class="s3">, </span><span class="s1">count</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a copy of the string with all 
        occurrences of substring `old` replaced by `new`. 
 
        See Also 
        -------- 
        char.replace 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">replace</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">old</span><span class="s3">, </span><span class="s1">new</span><span class="s3">, </span><span class="s1">count </span><span class="s2">if </span><span class="s1">count </span><span class="s2">is not None else </span><span class="s3">-</span><span class="s5">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">rfind</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return the highest index in the string 
        where substring `sub` is found, such that `sub` is contained 
        within [`start`, `end`]. 
 
        See Also 
        -------- 
        char.rfind 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">rfind</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">rindex</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Like `rfind`, but raises :exc:`ValueError` when the substring `sub` is 
        not found. 
 
        See Also 
        -------- 
        char.rindex 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">rindex</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sub</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">rjust</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">=</span><span class="s4">' '</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return an array with the elements of `self` 
        right-justified in a string of length `width`. 
 
        See Also 
        -------- 
        char.rjust 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">rjust</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">fillchar</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">rpartition</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Partition each element in `self` around `sep`. 
 
        See Also 
        -------- 
        rpartition 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">rpartition</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">rsplit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">maxsplit</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a list of the words in 
        the string, using `sep` as the delimiter string. 
 
        See Also 
        -------- 
        char.rsplit 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">rsplit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">, </span><span class="s1">maxsplit</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">rstrip</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">chars</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a copy with the trailing 
        characters removed. 
 
        See Also 
        -------- 
        char.rstrip 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">rstrip</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">chars</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">split</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">maxsplit</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a list of the words in the 
        string, using `sep` as the delimiter string. 
 
        See Also 
        -------- 
        char.split 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">split</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">sep</span><span class="s3">, </span><span class="s1">maxsplit</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">splitlines</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">keepends</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a list of the lines in the 
        element, breaking at line boundaries. 
 
        See Also 
        -------- 
        char.splitlines 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">splitlines</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">keepends</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">startswith</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a boolean array which is `True` where the string element 
        in `self` starts with `prefix`, otherwise `False`. 
 
        See Also 
        -------- 
        char.startswith 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">startswith</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">strip</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">chars</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a copy with the leading and 
        trailing characters removed. 
 
        See Also 
        -------- 
        char.strip 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">strip</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">chars</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">swapcase</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a copy of the string with 
        uppercase characters converted to lowercase and vice versa. 
 
        See Also 
        -------- 
        char.swapcase 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">swapcase</span><span class="s3">(</span><span class="s1">self</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">title</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a titlecased version of the 
        string: words start with uppercase characters, all remaining cased 
        characters are lowercase. 
 
        See Also 
        -------- 
        char.title 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">title</span><span class="s3">(</span><span class="s1">self</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">translate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">table</span><span class="s3">, </span><span class="s1">deletechars</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return a copy of the string where 
        all characters occurring in the optional argument 
        `deletechars` are removed, and the remaining characters have 
        been mapped through the given translation table. 
 
        See Also 
        -------- 
        char.translate 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">translate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">table</span><span class="s3">, </span><span class="s1">deletechars</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">upper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return an array with the elements of `self` converted to 
        uppercase. 
 
        See Also 
        -------- 
        char.upper 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">upper</span><span class="s3">(</span><span class="s1">self</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">zfill</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">width</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the numeric string left-filled with zeros in a string of 
        length `width`. 
 
        See Also 
        -------- 
        char.zfill 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">zfill</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">width</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">isnumeric</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return True if there are only 
        numeric characters in the element. 
 
        See Also 
        -------- 
        char.isnumeric 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isnumeric</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">isdecimal</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        For each element in `self`, return True if there are only 
        decimal characters in the element. 
 
        See Also 
        -------- 
        char.isdecimal 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isdecimal</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">set_module</span><span class="s3">(</span><span class="s4">&quot;numpy.char&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">array</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">unicode</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a `~numpy.char.chararray`. 
 
    .. note:: 
       This class is provided for numarray backward-compatibility. 
       New code (not concerned with numarray compatibility) should use 
       arrays of type `bytes_` or `str_` and use the free functions 
       in :mod:`numpy.char` for fast vectorized string operations instead. 
 
    Versus a NumPy array of dtype `bytes_` or `str_`, this 
    class adds the following functionality: 
 
    1) values automatically have whitespace removed from the end 
       when indexed 
 
    2) comparison operators automatically remove whitespace from the 
       end when comparing values 
 
    3) vectorized string operations are provided as methods 
       (e.g. `chararray.endswith &lt;numpy.char.chararray.endswith&gt;`) 
       and infix operators (e.g. ``+, *, %``) 
 
    Parameters 
    ---------- 
    obj : array of str or unicode-like 
 
    itemsize : int, optional 
        `itemsize` is the number of characters per scalar in the 
        resulting array.  If `itemsize` is None, and `obj` is an 
        object array or a Python list, the `itemsize` will be 
        automatically determined.  If `itemsize` is provided and `obj` 
        is of type str or unicode, then the `obj` string will be 
        chunked into `itemsize` pieces. 
 
    copy : bool, optional 
        If true (default), then the object is copied.  Otherwise, a copy 
        will only be made if ``__array__`` returns a copy, if obj is a 
        nested sequence, or if a copy is needed to satisfy any of the other 
        requirements (`itemsize`, unicode, `order`, etc.). 
 
    unicode : bool, optional 
        When true, the resulting `~numpy.char.chararray` can contain Unicode 
        characters, when false only 8-bit characters.  If unicode is 
        None and `obj` is one of the following: 
 
        - a `~numpy.char.chararray`, 
        - an ndarray of type :class:`str_` or :class:`bytes_` 
        - a Python :class:`str` or :class:`bytes` object, 
 
        then the unicode setting of the output array will be 
        automatically determined. 
 
    order : {'C', 'F', 'A'}, optional 
        Specify the order of the array.  If order is 'C' (default), then the 
        array will be in C-contiguous order (last-index varies the 
        fastest).  If order is 'F', then the returned array 
        will be in Fortran-contiguous order (first-index varies the 
        fastest).  If order is 'A', then the returned array may 
        be in any order (either C-, Fortran-contiguous, or even 
        discontiguous). 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, (</span><span class="s1">bytes</span><span class="s3">, </span><span class="s1">str</span><span class="s3">)):</span>
        <span class="s2">if </span><span class="s1">unicode </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                <span class="s1">unicode </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">unicode </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">itemsize </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">itemsize </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
        <span class="s1">shape </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) // </span><span class="s1">itemsize</span>

        <span class="s2">return </span><span class="s1">chararray</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">=</span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">unicode</span><span class="s3">=</span><span class="s1">unicode</span><span class="s3">,</span>
                         <span class="s1">buffer</span><span class="s3">=</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">)):</span>
        <span class="s1">obj </span><span class="s3">= </span><span class="s1">asnarray</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">ndarray</span><span class="s3">) </span><span class="s2">and </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">character</span><span class="s3">):</span>
        <span class="s6"># If we just have a vanilla chararray, create a chararray</span>
        <span class="s6"># view around it.</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">chararray</span><span class="s3">):</span>
            <span class="s1">obj </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">view</span><span class="s3">(</span><span class="s1">chararray</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">itemsize </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">itemsize </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">itemsize</span>
            <span class="s6"># itemsize is in 8-bit chars, so for Unicode, we need</span>
            <span class="s6"># to divide by the size of a single Unicode character,</span>
            <span class="s6"># which for NumPy is always 4</span>
            <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">str_</span><span class="s3">):</span>
                <span class="s1">itemsize </span><span class="s3">//= </span><span class="s5">4</span>

        <span class="s2">if </span><span class="s1">unicode </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">str_</span><span class="s3">):</span>
                <span class="s1">unicode </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">unicode </span><span class="s3">= </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">unicode</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">str_</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">bytes_</span>

        <span class="s2">if </span><span class="s1">order </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">obj </span><span class="s3">= </span><span class="s1">asnarray</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">copy </span><span class="s2">or</span>
                <span class="s3">(</span><span class="s1">itemsize </span><span class="s3">!= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">) </span><span class="s2">or</span>
                <span class="s3">(</span><span class="s2">not </span><span class="s1">unicode </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">str_</span><span class="s3">)) </span><span class="s2">or</span>
                <span class="s3">(</span><span class="s1">unicode </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">bytes_</span><span class="s3">))):</span>
            <span class="s1">obj </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">((</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">int</span><span class="s3">(</span><span class="s1">itemsize</span><span class="s3">)))</span>
        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">ndarray</span><span class="s3">) </span><span class="s2">and </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">object</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">itemsize </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s6"># Since no itemsize was specified, convert the input array to</span>
            <span class="s6"># a list so the ndarray constructor will automatically</span>
            <span class="s6"># determine the itemsize for us.</span>
            <span class="s1">obj </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">()</span>
            <span class="s6"># Fall through to the default case</span>

    <span class="s2">if </span><span class="s1">unicode</span><span class="s3">:</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">str_</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">bytes_</span>

    <span class="s2">if </span><span class="s1">itemsize </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s1">narray</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">, </span><span class="s1">subok</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s1">narray</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">), </span><span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">, </span><span class="s1">subok</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">val</span><span class="s3">.</span><span class="s1">view</span><span class="s3">(</span><span class="s1">chararray</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">set_module</span><span class="s3">(</span><span class="s4">&quot;numpy.char&quot;</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">unicode</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert the input to a `~numpy.char.chararray`, copying the data only if 
    necessary. 
 
    Versus a NumPy array of dtype `bytes_` or `str_`, this 
    class adds the following functionality: 
 
    1) values automatically have whitespace removed from the end 
       when indexed 
 
    2) comparison operators automatically remove whitespace from the 
       end when comparing values 
 
    3) vectorized string operations are provided as methods 
       (e.g. `chararray.endswith &lt;numpy.char.chararray.endswith&gt;`) 
       and infix operators (e.g. ``+``, ``*``, ``%``) 
 
    Parameters 
    ---------- 
    obj : array of str or unicode-like 
 
    itemsize : int, optional 
        `itemsize` is the number of characters per scalar in the 
        resulting array.  If `itemsize` is None, and `obj` is an 
        object array or a Python list, the `itemsize` will be 
        automatically determined.  If `itemsize` is provided and `obj` 
        is of type str or unicode, then the `obj` string will be 
        chunked into `itemsize` pieces. 
 
    unicode : bool, optional 
        When true, the resulting `~numpy.char.chararray` can contain Unicode 
        characters, when false only 8-bit characters.  If unicode is 
        None and `obj` is one of the following: 
 
        - a `~numpy.char.chararray`, 
        - an ndarray of type `str_` or `unicode_` 
        - a Python str or unicode object, 
 
        then the unicode setting of the output array will be 
        automatically determined. 
 
    order : {'C', 'F'}, optional 
        Specify the order of the array.  If order is 'C' (default), then the 
        array will be in C-contiguous order (last-index varies the 
        fastest).  If order is 'F', then the returned array 
        will be in Fortran-contiguous order (first-index varies the 
        fastest). 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; np.char.asarray(['hello', 'world']) 
    chararray(['hello', 'world'], dtype='&lt;U5') 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">array</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">itemsize</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                 <span class="s1">unicode</span><span class="s3">=</span><span class="s1">unicode</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">)</span>
</pre>
</body>
</html>