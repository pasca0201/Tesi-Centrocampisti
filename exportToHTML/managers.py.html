<html>
<head>
<title>managers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #7a7e85;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
managers.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">Hashable</span><span class="s2">,</span>
    <span class="s1">Sequence</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">Literal</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_config </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">using_copy_on_write</span><span class="s2">,</span>
    <span class="s1">warn_copy_on_write</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">internals </span><span class="s0">as </span><span class="s1">libinternals</span><span class="s2">,</span>
    <span class="s1">lib</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs</span><span class="s2">.</span><span class="s1">internals </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">BlockPlacement</span><span class="s2">,</span>
    <span class="s1">BlockValuesRefs</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs</span><span class="s2">.</span><span class="s1">tslibs </span><span class="s0">import </span><span class="s1">Timestamp</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">errors </span><span class="s0">import </span><span class="s1">PerformanceWarning</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">util</span><span class="s2">.</span><span class="s1">_decorators </span><span class="s0">import </span><span class="s1">cache_readonly</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">util</span><span class="s2">.</span><span class="s1">_exceptions </span><span class="s0">import </span><span class="s1">find_stack_level</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">cast </span><span class="s0">import </span><span class="s1">infer_dtype_from_scalar</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">common </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">ensure_platform_int</span><span class="s2">,</span>
    <span class="s1">is_1d_only_ea_dtype</span><span class="s2">,</span>
    <span class="s1">is_list_like</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">dtypes </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">DatetimeTZDtype</span><span class="s2">,</span>
    <span class="s1">ExtensionDtype</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">generic </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">ABCDataFrame</span><span class="s2">,</span>
    <span class="s1">ABCSeries</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">missing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">array_equals</span><span class="s2">,</span>
    <span class="s1">isna</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s0">import </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">algorithms </span><span class="s0">as </span><span class="s1">algos</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">ArrowExtensionArray</span><span class="s2">,</span>
    <span class="s1">ArrowStringArray</span><span class="s2">,</span>
    <span class="s1">DatetimeArray</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays</span><span class="s2">.</span><span class="s1">_mixins </span><span class="s0">import </span><span class="s1">NDArrayBackedExtensionArray</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">construction </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">ensure_wrapped_if_datetimelike</span><span class="s2">,</span>
    <span class="s1">extract_array</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">indexers </span><span class="s0">import </span><span class="s1">maybe_convert_indices</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">indexes</span><span class="s2">.</span><span class="s1">api </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">ensure_index</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">internals</span><span class="s2">.</span><span class="s1">base </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">DataManager</span><span class="s2">,</span>
    <span class="s1">SingleDataManager</span><span class="s2">,</span>
    <span class="s1">ensure_np_dtype</span><span class="s2">,</span>
    <span class="s1">interleaved_dtype</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">internals</span><span class="s2">.</span><span class="s1">blocks </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">COW_WARNING_GENERAL_MSG</span><span class="s2">,</span>
    <span class="s1">COW_WARNING_SETITEM_MSG</span><span class="s2">,</span>
    <span class="s1">Block</span><span class="s2">,</span>
    <span class="s1">NumpyBlock</span><span class="s2">,</span>
    <span class="s1">ensure_block_shape</span><span class="s2">,</span>
    <span class="s1">extend_blocks</span><span class="s2">,</span>
    <span class="s1">get_block_type</span><span class="s2">,</span>
    <span class="s1">maybe_coerce_values</span><span class="s2">,</span>
    <span class="s1">new_block</span><span class="s2">,</span>
    <span class="s1">new_block_2d</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">internals</span><span class="s2">.</span><span class="s1">ops </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">blockwise_all</span><span class="s2">,</span>
    <span class="s1">operate_blockwise</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_typing </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">ArrayLike</span><span class="s2">,</span>
        <span class="s1">AxisInt</span><span class="s2">,</span>
        <span class="s1">DtypeObj</span><span class="s2">,</span>
        <span class="s1">QuantileInterpolation</span><span class="s2">,</span>
        <span class="s1">Self</span><span class="s2">,</span>
        <span class="s1">Shape</span><span class="s2">,</span>
        <span class="s1">npt</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">api</span><span class="s2">.</span><span class="s1">extensions </span><span class="s0">import </span><span class="s1">ExtensionArray</span>


<span class="s0">class </span><span class="s1">BaseBlockManager</span><span class="s2">(</span><span class="s1">DataManager</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Core internal data structure to implement DataFrame, Series, etc. 
 
    Manage a bunch of labeled 2D mixed-type ndarrays. Essentially it's a 
    lightweight blocked set of labeled data to be manipulated by the DataFrame 
    public API class 
 
    Attributes 
    ---------- 
    shape 
    ndim 
    axes 
    values 
    items 
 
    Methods 
    ------- 
    set_axis(axis, new_labels) 
    copy(deep=True) 
 
    get_dtypes 
 
    apply(func, axes, block_filter_fn) 
 
    get_bool_data 
    get_numeric_data 
 
    get_slice(slice_like, axis) 
    get(label) 
    iget(loc) 
 
    take(indexer, axis) 
    reindex_axis(new_labels, axis) 
    reindex_indexer(new_labels, indexer, axis) 
 
    delete(label) 
    insert(loc, label, value) 
    set(label, value) 
 
    Parameters 
    ---------- 
    blocks: Sequence of Block 
    axes: Sequence of Index 
    verify_integrity: bool, default True 
 
    Notes 
    ----- 
    This is *not* a public API class 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s2">= ()</span>

    <span class="s1">_blknos</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">]</span>
    <span class="s1">_blklocs</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">]</span>
    <span class="s1">blocks</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">, ...]</span>
    <span class="s1">axes</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Index</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">ndim</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">_known_consolidated</span><span class="s2">: </span><span class="s1">bool</span>
    <span class="s1">_is_consolidated</span><span class="s2">: </span><span class="s1">bool</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">verify_integrity</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">from_blocks</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">], </span><span class="s1">axes</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Index</span><span class="s2">]) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">blknos</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Suppose we want to find the array corresponding to our i'th column. 
 
        blknos[i] identifies the block from self.blocks that contains this column. 
 
        blklocs[i] identifies the column of interest within 
        self.blocks[self.blknos[i]] 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_blknos </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s4"># Note: these can be altered by other BlockManager methods.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_rebuild_blknos_and_blklocs</span><span class="s2">()</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_blknos</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">blklocs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">]:</span>
        <span class="s3">&quot;&quot;&quot; 
        See blknos.__doc__ 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_blklocs </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s4"># Note: these can be altered by other BlockManager methods.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_rebuild_blknos_and_blklocs</span><span class="s2">()</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_blklocs</span>

    <span class="s0">def </span><span class="s1">make_empty</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">=</span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot;return an empty BlockManager with the items axis of len 0&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">axes </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">axes </span><span class="s2">= [</span><span class="s1">Index</span><span class="s2">([])] + </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]</span>

        <span class="s4"># preserve dtype if possible</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">SingleBlockManager</span><span class="s2">)  </span><span class="s4"># for mypy</span>
            <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s1">arr </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">values</span><span class="s2">[:</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s1">bp </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">))</span>
            <span class="s1">nb </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">make_block_same_class</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">bp</span><span class="s2">)</span>
            <span class="s1">blocks </span><span class="s2">= [</span><span class="s1">nb</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">blocks </span><span class="s2">= []</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">from_blocks</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__nonzero__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s0">return True</span>

    <span class="s4"># Python3 compat</span>
    <span class="s1">__bool__ </span><span class="s2">= </span><span class="s1">__nonzero__</span>

    <span class="s0">def </span><span class="s1">_normalize_axis</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
        <span class="s4"># switch axis to follow BlockManager logic</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s1">axis </span><span class="s2">= </span><span class="s5">1 </span><span class="s0">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s5">0 </span><span class="s0">else </span><span class="s5">0</span>
        <span class="s0">return </span><span class="s1">axis</span>

    <span class="s0">def </span><span class="s1">set_axis</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt</span><span class="s2">, </span><span class="s1">new_labels</span><span class="s2">: </span><span class="s1">Index</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4"># Caller is responsible for ensuring we have an Index object.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_validate_set_axis</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">new_labels</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">new_labels</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">is_single_block</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s4"># Assumes we are 2D; overridden by SingleBlockManager</span>
        <span class="s0">return </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">) == </span><span class="s5">1</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">items</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Index</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">_has_no_reference</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">i</span><span class="s2">: </span><span class="s1">int</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Check for column `i` if it has references. 
        (whether it references another array or is itself being referenced) 
        Returns True if the column has no references. 
        &quot;&quot;&quot;</span>
        <span class="s1">blkno </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blknos</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_has_no_reference_block</span><span class="s2">(</span><span class="s1">blkno</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_has_no_reference_block</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">blkno</span><span class="s2">: </span><span class="s1">int</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Check for block `i` if it has references. 
        (whether it references another array or is itself being referenced) 
        Returns True if the block has no references. 
        &quot;&quot;&quot;</span>
        <span class="s0">return not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blkno</span><span class="s2">].</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">has_reference</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">add_references</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">mgr</span><span class="s2">: </span><span class="s1">BaseBlockManager</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Adds the references from one manager to another. We assume that both 
        managers have the same block structure. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">mgr</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">):</span>
            <span class="s4"># If block structure changes, then we made a copy</span>
            <span class="s0">return</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">):</span>
            <span class="s1">blk</span><span class="s2">.</span><span class="s1">refs </span><span class="s2">= </span><span class="s1">mgr</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">refs</span>
            <span class="s1">blk</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">add_reference</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">references_same_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">mgr</span><span class="s2">: </span><span class="s1">BaseBlockManager</span><span class="s2">, </span><span class="s1">blkno</span><span class="s2">: </span><span class="s1">int</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Checks if two blocks from two different block managers reference the 
        same underlying values. 
        &quot;&quot;&quot;</span>
        <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blkno</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">any</span><span class="s2">(</span><span class="s1">blk </span><span class="s0">is </span><span class="s1">ref</span><span class="s2">() </span><span class="s0">for </span><span class="s1">ref </span><span class="s0">in </span><span class="s1">mgr</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blkno</span><span class="s2">].</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">referenced_blocks</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_dtypes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">object_</span><span class="s2">]:</span>
        <span class="s1">dtypes </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">object</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blknos</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">arrays</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">ArrayLike</span><span class="s2">]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Quick access to the backing arrays of the Blocks. 
 
        Only for compatibility with ArrayManager for testing convenience. 
        Not to be used in actual code, and return value is not the same as the 
        ArrayManager method (list of 1D arrays vs iterator of 2D ndarrays / 1D EAs). 
 
        Warning! The returned arrays don't handle Copy-on-Write, so this should 
        be used with caution (only in read-mode). 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">values </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s1">output </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">__name__</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">i </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s1">output </span><span class="s2">+= </span><span class="s6">f&quot;</span><span class="s0">\n</span><span class="s6">Items: </span><span class="s0">{</span><span class="s1">ax</span><span class="s0">}</span><span class="s6">&quot;</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">output </span><span class="s2">+= </span><span class="s6">f&quot;</span><span class="s0">\n</span><span class="s6">Axis </span><span class="s0">{</span><span class="s1">i</span><span class="s0">}</span><span class="s6">: </span><span class="s0">{</span><span class="s1">ax</span><span class="s0">}</span><span class="s6">&quot;</span>

        <span class="s0">for </span><span class="s1">block </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">:</span>
            <span class="s1">output </span><span class="s2">+= </span><span class="s6">f&quot;</span><span class="s0">\n{</span><span class="s1">block</span><span class="s0">}</span><span class="s6">&quot;</span>
        <span class="s0">return </span><span class="s1">output</span>

    <span class="s0">def </span><span class="s1">apply</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">f</span><span class="s2">,</span>
        <span class="s1">align_keys</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">str</span><span class="s2">] | </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Iterate over the blocks, collect and create a new BlockManager. 
 
        Parameters 
        ---------- 
        f : str or callable 
            Name of the Block method to apply. 
        align_keys: List[str] or None, default None 
        **kwargs 
            Keywords to pass to `f` 
 
        Returns 
        ------- 
        BlockManager 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s6">&quot;filter&quot; </span><span class="s0">not in </span><span class="s1">kwargs</span>

        <span class="s1">align_keys </span><span class="s2">= </span><span class="s1">align_keys </span><span class="s0">or </span><span class="s2">[]</span>
        <span class="s1">result_blocks</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">] = []</span>
        <span class="s4"># fillna: Series/DataFrame is responsible for making sure value is aligned</span>

        <span class="s1">aligned_args </span><span class="s2">= {</span><span class="s1">k</span><span class="s2">: </span><span class="s1">kwargs</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">align_keys</span><span class="s2">}</span>

        <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">aligned_args</span><span class="s2">:</span>
                <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">obj </span><span class="s0">in </span><span class="s1">aligned_args</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, (</span><span class="s1">ABCSeries</span><span class="s2">, </span><span class="s1">ABCDataFrame</span><span class="s2">)):</span>
                        <span class="s4"># The caller is responsible for ensuring that</span>
                        <span class="s4">#  obj.axes[-1].equals(self.items)</span>
                        <span class="s0">if </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
                            <span class="s1">kwargs</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">iloc</span><span class="s2">[</span><span class="s1">b</span><span class="s2">.</span><span class="s1">mgr_locs</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">].</span><span class="s1">_values</span>
                        <span class="s0">else</span><span class="s2">:</span>
                            <span class="s1">kwargs</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">iloc</span><span class="s2">[:, </span><span class="s1">b</span><span class="s2">.</span><span class="s1">mgr_locs</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">].</span><span class="s1">_values</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s4"># otherwise we have an ndarray</span>
                        <span class="s1">kwargs</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">obj</span><span class="s2">[</span><span class="s1">b</span><span class="s2">.</span><span class="s1">mgr_locs</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">]</span>

            <span class="s0">if </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">f</span><span class="s2">):</span>
                <span class="s1">applied </span><span class="s2">= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">applied </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">f</span><span class="s2">)(**</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s1">result_blocks </span><span class="s2">= </span><span class="s1">extend_blocks</span><span class="s2">(</span><span class="s1">applied</span><span class="s2">, </span><span class="s1">result_blocks</span><span class="s2">)</span>

        <span class="s1">out </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">from_blocks</span><span class="s2">(</span><span class="s1">result_blocks</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">out</span>

    <span class="s4"># Alias so we can share code with ArrayManager</span>
    <span class="s1">apply_with_block </span><span class="s2">= </span><span class="s1">apply</span>

    <span class="s0">def </span><span class="s1">setitem</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">warn</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Set values with indexer. 
 
        For SingleBlockManager, this backs s[indexer] = value 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s0">and </span><span class="s1">indexer</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">f&quot;Cannot set values with ndim &gt; </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s0">}</span><span class="s6">&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">warn </span><span class="s0">and </span><span class="s1">warn_copy_on_write</span><span class="s2">() </span><span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_has_no_reference</span><span class="s2">(</span><span class="s5">0</span><span class="s2">):</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s1">COW_WARNING_GENERAL_MSG</span><span class="s2">,</span>
                <span class="s1">FutureWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
            <span class="s2">)</span>

        <span class="s0">elif </span><span class="s1">using_copy_on_write</span><span class="s2">() </span><span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_has_no_reference</span><span class="s2">(</span><span class="s5">0</span><span class="s2">):</span>
            <span class="s4"># this method is only called if there is a single block -&gt; hardcoded 0</span>
            <span class="s4"># Split blocks to only copy the columns we want to modify</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2 </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s1">blk_loc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blklocs</span><span class="s2">[</span><span class="s1">indexer</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]]</span>
                <span class="s0">if </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">blk_loc</span><span class="s2">) </span><span class="s0">and </span><span class="s1">blk_loc</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2</span><span class="s2">:</span>
                    <span class="s1">blk_loc </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">squeeze</span><span class="s2">(</span><span class="s1">blk_loc</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">)</span>
                <span class="s0">elif not </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">blk_loc</span><span class="s2">):</span>
                    <span class="s4"># Keep dimension and copy data later</span>
                    <span class="s1">blk_loc </span><span class="s2">= [</span><span class="s1">blk_loc</span><span class="s2">]  </span><span class="s4"># type: ignore[assignment]</span>
                <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">blk_loc</span><span class="s2">) == </span><span class="s5">0</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

                <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">values</span>
                <span class="s0">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2</span><span class="s2">:</span>
                    <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">[</span><span class="s1">blk_loc</span><span class="s2">]</span>
                    <span class="s4"># &quot;T&quot; has no attribute &quot;_iset_split_block&quot;</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_iset_split_block</span><span class="s2">(  </span><span class="s4"># type: ignore[attr-defined]</span>
                        <span class="s5">0</span><span class="s2">, </span><span class="s1">blk_loc</span><span class="s2">, </span><span class="s1">values</span>
                    <span class="s2">)</span>
                    <span class="s4"># first block equals values</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">setitem</span><span class="s2">((</span><span class="s1">indexer</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">blk_loc</span><span class="s2">))), </span><span class="s1">value</span><span class="s2">)</span>
                    <span class="s0">return </span><span class="s1">self</span>
            <span class="s4"># No need to split if we either set all columns or on a single block</span>
            <span class="s4"># manager</span>
            <span class="s1">self </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s6">&quot;setitem&quot;</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">=</span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">value</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">diff</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">: </span><span class="s1">int</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s4"># only reached with self.ndim == 2</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s6">&quot;diff&quot;</span><span class="s2">, </span><span class="s1">n</span><span class="s2">=</span><span class="s1">n</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">astype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">False</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s6">&quot;raise&quot;</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">copy </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">using_copy_on_write</span><span class="s2">():</span>
                <span class="s1">copy </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">copy </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">using_copy_on_write</span><span class="s2">():</span>
            <span class="s1">copy </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span>
            <span class="s6">&quot;astype&quot;</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
            <span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">,</span>
            <span class="s1">errors</span><span class="s2">=</span><span class="s1">errors</span><span class="s2">,</span>
            <span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_copy_on_write</span><span class="s2">(),</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">convert</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">copy </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">using_copy_on_write</span><span class="s2">():</span>
                <span class="s1">copy </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">copy </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">using_copy_on_write</span><span class="s2">():</span>
            <span class="s1">copy </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s6">&quot;convert&quot;</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_copy_on_write</span><span class="s2">())</span>

    <span class="s0">def </span><span class="s1">convert_dtypes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">using_copy_on_write</span><span class="s2">():</span>
            <span class="s1">copy </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">copy </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span>
            <span class="s6">&quot;convert_dtypes&quot;</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">, </span><span class="s1">using_cow</span><span class="s2">=</span><span class="s1">using_copy_on_write</span><span class="s2">(), **</span><span class="s1">kwargs</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_values_for_csv</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, *, </span><span class="s1">float_format</span><span class="s2">, </span><span class="s1">date_format</span><span class="s2">, </span><span class="s1">decimal</span><span class="s2">, </span><span class="s1">na_rep</span><span class="s2">: </span><span class="s1">str </span><span class="s2">= </span><span class="s6">&quot;nan&quot;</span><span class="s2">, </span><span class="s1">quoting</span><span class="s2">=</span><span class="s0">None</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert values to native types (strings / python objects) that are used 
        in formatting (repr / csv). 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span>
            <span class="s6">&quot;get_values_for_csv&quot;</span><span class="s2">,</span>
            <span class="s1">na_rep</span><span class="s2">=</span><span class="s1">na_rep</span><span class="s2">,</span>
            <span class="s1">quoting</span><span class="s2">=</span><span class="s1">quoting</span><span class="s2">,</span>
            <span class="s1">float_format</span><span class="s2">=</span><span class="s1">float_format</span><span class="s2">,</span>
            <span class="s1">date_format</span><span class="s2">=</span><span class="s1">date_format</span><span class="s2">,</span>
            <span class="s1">decimal</span><span class="s2">=</span><span class="s1">decimal</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">any_extension_types</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot;Whether any of the blocks in this manager are extension blocks&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">any</span><span class="s2">(</span><span class="s1">block</span><span class="s2">.</span><span class="s1">is_extension </span><span class="s0">for </span><span class="s1">block </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">is_view</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot;return a boolean if we are a single block and are a view&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">) == </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">is_view</span>

        <span class="s4"># It is technically possible to figure out which blocks are views</span>
        <span class="s4"># e.g. [ b.values.base is not None for b in self.blocks ]</span>
        <span class="s4"># but then we have the case of possibly some blocks being a view</span>
        <span class="s4"># and some blocks not. setting in theory is possible on the non-view</span>
        <span class="s4"># blocks w/o causing a SettingWithCopy raise/warn. But this is a bit</span>
        <span class="s4"># complicated</span>

        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">_get_data_subset</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">predicate</span><span class="s2">: </span><span class="s1">Callable</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s1">blocks </span><span class="s2">= [</span><span class="s1">blk </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks </span><span class="s0">if </span><span class="s1">predicate</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">values</span><span class="s2">)]</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_combine</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_bool_data</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Select blocks that are bool-dtype and columns from object-dtype blocks 
        that are all-bool. 
        &quot;&quot;&quot;</span>

        <span class="s1">new_blocks </span><span class="s2">= []</span>

        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">bool</span><span class="s2">:</span>
                <span class="s1">new_blocks</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">)</span>

            <span class="s0">elif </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">is_object</span><span class="s2">:</span>
                <span class="s1">nbs </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">_split</span><span class="s2">()</span>
                <span class="s1">new_blocks</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">nb </span><span class="s0">for </span><span class="s1">nb </span><span class="s0">in </span><span class="s1">nbs </span><span class="s0">if </span><span class="s1">nb</span><span class="s2">.</span><span class="s1">is_bool</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_combine</span><span class="s2">(</span><span class="s1">new_blocks</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_numeric_data</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s1">numeric_blocks </span><span class="s2">= [</span><span class="s1">blk </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks </span><span class="s0">if </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">is_numeric</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">numeric_blocks</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">):</span>
            <span class="s4"># Avoid somewhat expensive _combine</span>
            <span class="s0">return </span><span class="s1">self</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_combine</span><span class="s2">(</span><span class="s1">numeric_blocks</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_combine</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">], </span><span class="s1">index</span><span class="s2">: </span><span class="s1">Index </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot;return a new manager with the blocks&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">) == </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2</span><span class="s2">:</span>
                <span class="s4"># retain our own Index dtype</span>
                <span class="s0">if </span><span class="s1">index </span><span class="s0">is not None</span><span class="s2">:</span>
                    <span class="s1">axes </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">[:</span><span class="s5">0</span><span class="s2">], </span><span class="s1">index</span><span class="s2">]</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">axes </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">[:</span><span class="s5">0</span><span class="s2">]] + </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_empty</span><span class="s2">(</span><span class="s1">axes</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_empty</span><span class="s2">()</span>

        <span class="s4"># FIXME: optimization potential</span>
        <span class="s1">indexer </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">([</span><span class="s1">b</span><span class="s2">.</span><span class="s1">mgr_locs</span><span class="s2">.</span><span class="s1">as_array </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">blocks</span><span class="s2">]))</span>
        <span class="s1">inv_indexer </span><span class="s2">= </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">get_reverse_indexer</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>

        <span class="s1">new_blocks</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">] = []</span>
        <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">blocks</span><span class="s2">:</span>
            <span class="s1">nb </span><span class="s2">= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
            <span class="s1">nb</span><span class="s2">.</span><span class="s1">mgr_locs </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">inv_indexer</span><span class="s2">[</span><span class="s1">nb</span><span class="s2">.</span><span class="s1">mgr_locs</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">])</span>
            <span class="s1">new_blocks</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">nb</span><span class="s2">)</span>

        <span class="s1">axes </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">index </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">axes</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] = </span><span class="s1">index</span>
        <span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">from_blocks</span><span class="s2">(</span><span class="s1">new_blocks</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">nblocks</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">copy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">deep</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">| </span><span class="s1">Literal</span><span class="s2">[</span><span class="s6">&quot;all&quot;</span><span class="s2">] = </span><span class="s0">True</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Make deep or shallow copy of BlockManager 
 
        Parameters 
        ---------- 
        deep : bool, string or None, default True 
            If False or None, return a shallow copy (do not copy data) 
            If 'all', copy data and a deep copy of the index 
 
        Returns 
        ------- 
        BlockManager 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">deep </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">using_copy_on_write</span><span class="s2">():</span>
                <span class="s4"># use shallow copy</span>
                <span class="s1">deep </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s4"># preserve deep copy for BlockManager with copy=None</span>
                <span class="s1">deep </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s4"># this preserves the notion of view copying of axes</span>
        <span class="s0">if </span><span class="s1">deep</span><span class="s2">:</span>
            <span class="s4"># hit in e.g. tests.io.json.test_pandas</span>

            <span class="s0">def </span><span class="s1">copy_func</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">True</span><span class="s2">) </span><span class="s0">if </span><span class="s1">deep </span><span class="s2">== </span><span class="s6">&quot;all&quot; </span><span class="s0">else </span><span class="s1">ax</span><span class="s2">.</span><span class="s1">view</span><span class="s2">()</span>

            <span class="s1">new_axes </span><span class="s2">= [</span><span class="s1">copy_func</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">) </span><span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">using_copy_on_write</span><span class="s2">():</span>
                <span class="s1">new_axes </span><span class="s2">= [</span><span class="s1">ax</span><span class="s2">.</span><span class="s1">view</span><span class="s2">() </span><span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">]</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">new_axes </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">)</span>

        <span class="s1">res </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s6">&quot;copy&quot;</span><span class="s2">, </span><span class="s1">deep</span><span class="s2">=</span><span class="s1">deep</span><span class="s2">)</span>
        <span class="s1">res</span><span class="s2">.</span><span class="s1">axes </span><span class="s2">= </span><span class="s1">new_axes</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4"># Avoid needing to re-compute these</span>
            <span class="s1">blknos </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_blknos</span>
            <span class="s0">if </span><span class="s1">blknos </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">res</span><span class="s2">.</span><span class="s1">_blknos </span><span class="s2">= </span><span class="s1">blknos</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
                <span class="s1">res</span><span class="s2">.</span><span class="s1">_blklocs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_blklocs</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

        <span class="s0">if </span><span class="s1">deep</span><span class="s2">:</span>
            <span class="s1">res</span><span class="s2">.</span><span class="s1">_consolidate_inplace</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">res</span>

    <span class="s0">def </span><span class="s1">consolidate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Join together blocks having same dtype 
 
        Returns 
        ------- 
        y : BlockManager 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_consolidated</span><span class="s2">():</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s1">bm </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">, </span><span class="s1">verify_integrity</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">bm</span><span class="s2">.</span><span class="s1">_is_consolidated </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s1">bm</span><span class="s2">.</span><span class="s1">_consolidate_inplace</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">bm</span>

    <span class="s0">def </span><span class="s1">reindex_indexer</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">new_axis</span><span class="s2">: </span><span class="s1">Index</span><span class="s2">,</span>
        <span class="s1">indexer</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">] | </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt</span><span class="s2">,</span>
        <span class="s1">fill_value</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">allow_dups</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">only_slice</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">use_na_proxy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        new_axis : Index 
        indexer : ndarray[intp] or None 
        axis : int 
        fill_value : object, default None 
        allow_dups : bool, default False 
        copy : bool or None, default True 
            If None, regard as False to get shallow copy. 
        only_slice : bool, default False 
            Whether to take views, not copies, along columns. 
        use_na_proxy : bool, default False 
            Whether to use a np.void ndarray for newly introduced columns. 
 
        pandas-indexer with -1's only. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">copy </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">using_copy_on_write</span><span class="s2">():</span>
                <span class="s4"># use shallow copy</span>
                <span class="s1">copy </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s4"># preserve deep copy for BlockManager with copy=None</span>
                <span class="s1">copy </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s0">if </span><span class="s1">indexer </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">new_axis </span><span class="s0">is </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] </span><span class="s0">and not </span><span class="s1">copy</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">self</span>

            <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>
            <span class="s1">result</span><span class="s2">.</span><span class="s1">axes </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">)</span>
            <span class="s1">result</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">new_axis</span>
            <span class="s0">return </span><span class="s1">result</span>

        <span class="s4"># Should be intp, but in some cases we get int64 on 32bit builds</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">)</span>

        <span class="s4"># some axes don't allow reindexing with dups</span>
        <span class="s0">if not </span><span class="s1">allow_dups</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">].</span><span class="s1">_validate_can_reindex</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">axis </span><span class="s2">&gt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s6">&quot;Requested axis not found in manager&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">new_blocks </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_slice_take_blocks_ax0</span><span class="s2">(</span>
                <span class="s1">indexer</span><span class="s2">,</span>
                <span class="s1">fill_value</span><span class="s2">=</span><span class="s1">fill_value</span><span class="s2">,</span>
                <span class="s1">only_slice</span><span class="s2">=</span><span class="s1">only_slice</span><span class="s2">,</span>
                <span class="s1">use_na_proxy</span><span class="s2">=</span><span class="s1">use_na_proxy</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">new_blocks </span><span class="s2">= [</span>
                <span class="s1">blk</span><span class="s2">.</span><span class="s1">take_nd</span><span class="s2">(</span>
                    <span class="s1">indexer</span><span class="s2">,</span>
                    <span class="s1">axis</span><span class="s2">=</span><span class="s5">1</span><span class="s2">,</span>
                    <span class="s1">fill_value</span><span class="s2">=(</span>
                        <span class="s1">fill_value </span><span class="s0">if </span><span class="s1">fill_value </span><span class="s0">is not None else </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">fill_value</span>
                    <span class="s2">),</span>
                <span class="s2">)</span>
                <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span>
            <span class="s2">]</span>

        <span class="s1">new_axes </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">)</span>
        <span class="s1">new_axes</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">new_axis</span>

        <span class="s1">new_mgr </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">from_blocks</span><span class="s2">(</span><span class="s1">new_blocks</span><span class="s2">, </span><span class="s1">new_axes</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4"># We can avoid the need to rebuild these</span>
            <span class="s1">new_mgr</span><span class="s2">.</span><span class="s1">_blknos </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blknos</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s1">new_mgr</span><span class="s2">.</span><span class="s1">_blklocs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blklocs</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">new_mgr</span>

    <span class="s0">def </span><span class="s1">_slice_take_blocks_ax0</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">slice_or_indexer</span><span class="s2">: </span><span class="s1">slice </span><span class="s2">| </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">,</span>
        <span class="s1">fill_value</span><span class="s2">=</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">,</span>
        <span class="s1">only_slice</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">use_na_proxy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">ref_inplace_op</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Slice/take blocks along axis=0. 
 
        Overloaded for SingleBlock 
 
        Parameters 
        ---------- 
        slice_or_indexer : slice or np.ndarray[int64] 
        fill_value : scalar, default lib.no_default 
        only_slice : bool, default False 
            If True, we always return views on existing arrays, never copies. 
            This is used when called from ops.blockwise.operate_blockwise. 
        use_na_proxy : bool, default False 
            Whether to use a np.void ndarray for newly introduced columns. 
        ref_inplace_op: bool, default False 
            Don't track refs if True because we operate inplace 
 
        Returns 
        ------- 
        new_blocks : list of Block 
        &quot;&quot;&quot;</span>
        <span class="s1">allow_fill </span><span class="s2">= </span><span class="s1">fill_value </span><span class="s0">is not </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span>

        <span class="s1">sl_type</span><span class="s2">, </span><span class="s1">slobj</span><span class="s2">, </span><span class="s1">sllen </span><span class="s2">= </span><span class="s1">_preprocess_slice_or_indexer</span><span class="s2">(</span>
            <span class="s1">slice_or_indexer</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">allow_fill</span><span class="s2">=</span><span class="s1">allow_fill</span>
        <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_single_block</span><span class="s2">:</span>
            <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>

            <span class="s0">if </span><span class="s1">sl_type </span><span class="s2">== </span><span class="s6">&quot;slice&quot;</span><span class="s2">:</span>
                <span class="s4"># GH#32959 EABlock would fail since we can't make 0-width</span>
                <span class="s4"># TODO(EA2D): special casing unnecessary with 2D EAs</span>
                <span class="s0">if </span><span class="s1">sllen </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s2">[]</span>
                <span class="s1">bp </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">sllen</span><span class="s2">))</span>
                <span class="s0">return </span><span class="s2">[</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">getitem_block_columns</span><span class="s2">(</span><span class="s1">slobj</span><span class="s2">, </span><span class="s1">new_mgr_locs</span><span class="s2">=</span><span class="s1">bp</span><span class="s2">)]</span>
            <span class="s0">elif not </span><span class="s1">allow_fill </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">allow_fill </span><span class="s0">and </span><span class="s1">fill_value </span><span class="s0">is None</span><span class="s2">:</span>
                    <span class="s1">fill_value </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">fill_value</span>

                <span class="s0">if not </span><span class="s1">allow_fill </span><span class="s0">and </span><span class="s1">only_slice</span><span class="s2">:</span>
                    <span class="s4"># GH#33597 slice instead of take, so we get</span>
                    <span class="s4">#  views instead of copies</span>
                    <span class="s1">blocks </span><span class="s2">= [</span>
                        <span class="s1">blk</span><span class="s2">.</span><span class="s1">getitem_block_columns</span><span class="s2">(</span>
                            <span class="s1">slice</span><span class="s2">(</span><span class="s1">ml</span><span class="s2">, </span><span class="s1">ml </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">),</span>
                            <span class="s1">new_mgr_locs</span><span class="s2">=</span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">i</span><span class="s2">),</span>
                            <span class="s1">ref_inplace_op</span><span class="s2">=</span><span class="s1">ref_inplace_op</span><span class="s2">,</span>
                        <span class="s2">)</span>
                        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">ml </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">slobj</span><span class="s2">)</span>
                    <span class="s2">]</span>
                    <span class="s0">return </span><span class="s1">blocks</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">bp </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">sllen</span><span class="s2">))</span>
                    <span class="s0">return </span><span class="s2">[</span>
                        <span class="s1">blk</span><span class="s2">.</span><span class="s1">take_nd</span><span class="s2">(</span>
                            <span class="s1">slobj</span><span class="s2">,</span>
                            <span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">,</span>
                            <span class="s1">new_mgr_locs</span><span class="s2">=</span><span class="s1">bp</span><span class="s2">,</span>
                            <span class="s1">fill_value</span><span class="s2">=</span><span class="s1">fill_value</span><span class="s2">,</span>
                        <span class="s2">)</span>
                    <span class="s2">]</span>

        <span class="s0">if </span><span class="s1">sl_type </span><span class="s2">== </span><span class="s6">&quot;slice&quot;</span><span class="s2">:</span>
            <span class="s1">blknos </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blknos</span><span class="s2">[</span><span class="s1">slobj</span><span class="s2">]</span>
            <span class="s1">blklocs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blklocs</span><span class="s2">[</span><span class="s1">slobj</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">blknos </span><span class="s2">= </span><span class="s1">algos</span><span class="s2">.</span><span class="s1">take_nd</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">blknos</span><span class="s2">, </span><span class="s1">slobj</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">allow_fill</span><span class="s2">=</span><span class="s1">allow_fill</span>
            <span class="s2">)</span>
            <span class="s1">blklocs </span><span class="s2">= </span><span class="s1">algos</span><span class="s2">.</span><span class="s1">take_nd</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">blklocs</span><span class="s2">, </span><span class="s1">slobj</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">allow_fill</span><span class="s2">=</span><span class="s1">allow_fill</span>
            <span class="s2">)</span>

        <span class="s4"># When filling blknos, make sure blknos is updated before appending to</span>
        <span class="s4"># blocks list, that way new blkno is exactly len(blocks).</span>
        <span class="s1">blocks </span><span class="s2">= []</span>
        <span class="s1">group </span><span class="s2">= </span><span class="s0">not </span><span class="s1">only_slice</span>
        <span class="s0">for </span><span class="s1">blkno</span><span class="s2">, </span><span class="s1">mgr_locs </span><span class="s0">in </span><span class="s1">libinternals</span><span class="s2">.</span><span class="s1">get_blkno_placements</span><span class="s2">(</span><span class="s1">blknos</span><span class="s2">, </span><span class="s1">group</span><span class="s2">=</span><span class="s1">group</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">blkno </span><span class="s2">== -</span><span class="s5">1</span><span class="s2">:</span>
                <span class="s4"># If we've got here, fill_value was not lib.no_default</span>

                <span class="s1">blocks</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_make_na_block</span><span class="s2">(</span>
                        <span class="s1">placement</span><span class="s2">=</span><span class="s1">mgr_locs</span><span class="s2">,</span>
                        <span class="s1">fill_value</span><span class="s2">=</span><span class="s1">fill_value</span><span class="s2">,</span>
                        <span class="s1">use_na_proxy</span><span class="s2">=</span><span class="s1">use_na_proxy</span><span class="s2">,</span>
                    <span class="s2">)</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blkno</span><span class="s2">]</span>

                <span class="s4"># Otherwise, slicing along items axis is necessary.</span>
                <span class="s0">if not </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">_can_consolidate </span><span class="s0">and not </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">_validate_ndim</span><span class="s2">:</span>
                    <span class="s4"># i.e. we dont go through here for DatetimeTZBlock</span>
                    <span class="s4"># A non-consolidatable block, it's easy, because there's</span>
                    <span class="s4"># only one item and each mgr loc is a copy of that single</span>
                    <span class="s4"># item.</span>
                    <span class="s1">deep </span><span class="s2">= </span><span class="s0">not </span><span class="s2">(</span><span class="s1">only_slice </span><span class="s0">or </span><span class="s1">using_copy_on_write</span><span class="s2">())</span>
                    <span class="s0">for </span><span class="s1">mgr_loc </span><span class="s0">in </span><span class="s1">mgr_locs</span><span class="s2">:</span>
                        <span class="s1">newblk </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s1">deep</span><span class="s2">)</span>
                        <span class="s1">newblk</span><span class="s2">.</span><span class="s1">mgr_locs </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s1">mgr_loc</span><span class="s2">, </span><span class="s1">mgr_loc </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">))</span>
                        <span class="s1">blocks</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">newblk</span><span class="s2">)</span>

                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s4"># GH#32779 to avoid the performance penalty of copying,</span>
                    <span class="s4">#  we may try to only slice</span>
                    <span class="s1">taker </span><span class="s2">= </span><span class="s1">blklocs</span><span class="s2">[</span><span class="s1">mgr_locs</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">]</span>
                    <span class="s1">max_len </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">mgr_locs</span><span class="s2">), </span><span class="s1">taker</span><span class="s2">.</span><span class="s1">max</span><span class="s2">() + </span><span class="s5">1</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">only_slice </span><span class="s0">or </span><span class="s1">using_copy_on_write</span><span class="s2">():</span>
                        <span class="s1">taker </span><span class="s2">= </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">maybe_indices_to_slice</span><span class="s2">(</span><span class="s1">taker</span><span class="s2">, </span><span class="s1">max_len</span><span class="s2">)</span>

                    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">taker</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">):</span>
                        <span class="s1">nb </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">getitem_block_columns</span><span class="s2">(</span><span class="s1">taker</span><span class="s2">, </span><span class="s1">new_mgr_locs</span><span class="s2">=</span><span class="s1">mgr_locs</span><span class="s2">)</span>
                        <span class="s1">blocks</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">nb</span><span class="s2">)</span>
                    <span class="s0">elif </span><span class="s1">only_slice</span><span class="s2">:</span>
                        <span class="s4"># GH#33597 slice instead of take, so we get</span>
                        <span class="s4">#  views instead of copies</span>
                        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">ml </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">taker</span><span class="s2">, </span><span class="s1">mgr_locs</span><span class="s2">):</span>
                            <span class="s1">slc </span><span class="s2">= </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">i </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">)</span>
                            <span class="s1">bp </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">ml</span><span class="s2">)</span>
                            <span class="s1">nb </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">getitem_block_columns</span><span class="s2">(</span><span class="s1">slc</span><span class="s2">, </span><span class="s1">new_mgr_locs</span><span class="s2">=</span><span class="s1">bp</span><span class="s2">)</span>
                            <span class="s4"># We have np.shares_memory(nb.values, blk.values)</span>
                            <span class="s1">blocks</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">nb</span><span class="s2">)</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s1">nb </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">take_nd</span><span class="s2">(</span><span class="s1">taker</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">new_mgr_locs</span><span class="s2">=</span><span class="s1">mgr_locs</span><span class="s2">)</span>
                        <span class="s1">blocks</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">nb</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">blocks</span>

    <span class="s0">def </span><span class="s1">_make_na_block</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">: </span><span class="s1">BlockPlacement</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">use_na_proxy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s2">) </span><span class="s1">-&gt; Block</span><span class="s2">:</span>
        <span class="s4"># Note: we only get here with self.ndim == 2</span>

        <span class="s0">if </span><span class="s1">use_na_proxy</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">fill_value </span><span class="s0">is None</span>
            <span class="s1">shape </span><span class="s2">= (</span><span class="s1">len</span><span class="s2">(</span><span class="s1">placement</span><span class="s2">), </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">])</span>
            <span class="s1">vals </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">void</span><span class="s2">)</span>
            <span class="s1">nb </span><span class="s2">= </span><span class="s1">NumpyBlock</span><span class="s2">(</span><span class="s1">vals</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">nb</span>

        <span class="s0">if </span><span class="s1">fill_value </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">fill_value </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span>

        <span class="s1">shape </span><span class="s2">= (</span><span class="s1">len</span><span class="s2">(</span><span class="s1">placement</span><span class="s2">), </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">])</span>

        <span class="s1">dtype</span><span class="s2">, </span><span class="s1">fill_value </span><span class="s2">= </span><span class="s1">infer_dtype_from_scalar</span><span class="s2">(</span><span class="s1">fill_value</span><span class="s2">)</span>
        <span class="s1">block_values </span><span class="s2">= </span><span class="s1">make_na_array</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">new_block_2d</span><span class="s2">(</span><span class="s1">block_values</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">placement</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">take</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">indexer</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">],</span>
        <span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">= </span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">verify</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Take items along any axis. 
 
        indexer : np.ndarray[np.intp] 
        axis : int, default 1 
        verify : bool, default True 
            Check that all entries are between 0 and len(self) - 1, inclusive. 
            Pass verify=False if this check has been done by the caller. 
 
        Returns 
        ------- 
        BlockManager 
        &quot;&quot;&quot;</span>
        <span class="s4"># Caller is responsible for ensuring indexer annotation is accurate</span>

        <span class="s1">n </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
        <span class="s1">indexer </span><span class="s2">= </span><span class="s1">maybe_convert_indices</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">verify</span><span class="s2">=</span><span class="s1">verify</span><span class="s2">)</span>

        <span class="s1">new_labels </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">].</span><span class="s1">take</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">reindex_indexer</span><span class="s2">(</span>
            <span class="s1">new_axis</span><span class="s2">=</span><span class="s1">new_labels</span><span class="s2">,</span>
            <span class="s1">indexer</span><span class="s2">=</span><span class="s1">indexer</span><span class="s2">,</span>
            <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
            <span class="s1">allow_dups</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
            <span class="s1">copy</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s2">)</span>


<span class="s0">class </span><span class="s1">BlockManager</span><span class="s2">(</span><span class="s1">libinternals</span><span class="s2">.</span><span class="s1">BlockManager</span><span class="s2">, </span><span class="s1">BaseBlockManager</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    BaseBlockManager that holds 2D blocks. 
    &quot;&quot;&quot;</span>

    <span class="s1">ndim </span><span class="s2">= </span><span class="s5">2</span>

    <span class="s4"># ----------------------------------------------------------------</span>
    <span class="s4"># Constructors</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">blocks</span><span class="s2">: </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">],</span>
        <span class="s1">axes</span><span class="s2">: </span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">Index</span><span class="s2">],</span>
        <span class="s1">verify_integrity</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">verify_integrity</span><span class="s2">:</span>
            <span class="s4"># Assertion disabled for performance</span>
            <span class="s4"># assert all(isinstance(x, Index) for x in axes)</span>

            <span class="s0">for </span><span class="s1">block </span><span class="s0">in </span><span class="s1">blocks</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s1">block</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">AssertionError</span><span class="s2">(</span>
                        <span class="s6">f&quot;Number of Block dimensions (</span><span class="s0">{</span><span class="s1">block</span><span class="s2">.</span><span class="s1">ndim</span><span class="s0">}</span><span class="s6">) must equal &quot;</span>
                        <span class="s6">f&quot;number of axes (</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s0">}</span><span class="s6">)&quot;</span>
                    <span class="s2">)</span>
                <span class="s4"># As of 2.0, the caller is responsible for ensuring that</span>
                <span class="s4">#  DatetimeTZBlock with block.ndim == 2 has block.values.ndim ==2;</span>
                <span class="s4">#  previously there was a special check for fastparquet compat.</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">_verify_integrity</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">_verify_integrity</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s1">mgr_shape </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s1">tot_items </span><span class="s2">= </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">mgr_locs</span><span class="s2">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">block </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">block</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:] != </span><span class="s1">mgr_shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]:</span>
                <span class="s1">raise_construction_error</span><span class="s2">(</span><span class="s1">tot_items</span><span class="s2">, </span><span class="s1">block</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:], </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">) != </span><span class="s1">tot_items</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">AssertionError</span><span class="s2">(</span>
                <span class="s6">&quot;Number of manager items must equal union of &quot;</span>
                <span class="s6">f&quot;block items</span><span class="s0">\n</span><span class="s6"># manager items: </span><span class="s0">{</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">)</span><span class="s0">}</span><span class="s6">, # &quot;</span>
                <span class="s6">f&quot;tot_items: </span><span class="s0">{</span><span class="s1">tot_items</span><span class="s0">}</span><span class="s6">&quot;</span>
            <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">from_blocks</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">blocks</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">], </span><span class="s1">axes</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Index</span><span class="s2">]) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Constructor for BlockManager and SingleBlockManager with same signature. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">cls</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">verify_integrity</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s4"># ----------------------------------------------------------------</span>
    <span class="s4"># Indexing</span>

    <span class="s0">def </span><span class="s1">fast_xs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">: </span><span class="s1">int</span><span class="s2">) </span><span class="s1">-&gt; SingleBlockManager</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the array corresponding to `frame.iloc[loc]`. 
 
        Parameters 
        ---------- 
        loc : int 
 
        Returns 
        ------- 
        np.ndarray or ExtensionArray 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">) == </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4"># TODO: this could be wrong if blk.mgr_locs is not slice(None)-like;</span>
            <span class="s4">#  is this ruled out in the general case?</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">iget</span><span class="s2">((</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">), </span><span class="s1">loc</span><span class="s2">))</span>
            <span class="s4"># in the case of a single block, the new block is a view</span>
            <span class="s1">bp </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)))</span>
            <span class="s1">block </span><span class="s2">= </span><span class="s1">new_block</span><span class="s2">(</span>
                <span class="s1">result</span><span class="s2">,</span>
                <span class="s1">placement</span><span class="s2">=</span><span class="s1">bp</span><span class="s2">,</span>
                <span class="s1">ndim</span><span class="s2">=</span><span class="s5">1</span><span class="s2">,</span>
                <span class="s1">refs</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">refs</span><span class="s2">,</span>
            <span class="s2">)</span>
            <span class="s0">return </span><span class="s1">SingleBlockManager</span><span class="s2">(</span><span class="s1">block</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>

        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">interleaved_dtype</span><span class="s2">([</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">])</span>

        <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype</span><span class="s2">):</span>
            <span class="s4"># TODO: use object dtype as workaround for non-performant</span>
            <span class="s4">#  EA.__setitem__ methods. (primarily ArrowExtensionArray.__setitem__</span>
            <span class="s4">#  when iteratively setting individual values)</span>
            <span class="s4">#  https://github.com/pandas-dev/pandas/pull/54508#issuecomment-1675827918</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">object</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">ensure_wrapped_if_datetimelike</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">:</span>
            <span class="s4"># Such assignment may incorrectly coerce NaT to None</span>
            <span class="s4"># result[blk.mgr_locs] = blk._slice((slice(None), loc))</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">rl </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">mgr_locs</span><span class="s2">):</span>
                <span class="s1">result</span><span class="s2">[</span><span class="s1">rl</span><span class="s2">] = </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">iget</span><span class="s2">((</span><span class="s1">i</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">))</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype</span><span class="s2">):</span>
            <span class="s1">cls </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">construct_array_type</span><span class="s2">()</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">_from_sequence</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s1">bp </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)))</span>
        <span class="s1">block </span><span class="s2">= </span><span class="s1">new_block</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">bp</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s5">1</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">SingleBlockManager</span><span class="s2">(</span><span class="s1">block</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>

    <span class="s0">def </span><span class="s1">iget</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">i</span><span class="s2">: </span><span class="s1">int</span><span class="s2">, </span><span class="s1">track_ref</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">) </span><span class="s1">-&gt; SingleBlockManager</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the data as a SingleBlockManager. 
        &quot;&quot;&quot;</span>
        <span class="s1">block </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blknos</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]]</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">block</span><span class="s2">.</span><span class="s1">iget</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blklocs</span><span class="s2">[</span><span class="s1">i</span><span class="s2">])</span>

        <span class="s4"># shortcut for select a single-dim from a 2-dim BM</span>
        <span class="s1">bp </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">values</span><span class="s2">)))</span>
        <span class="s1">nb </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">block</span><span class="s2">)(</span>
            <span class="s1">values</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">bp</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">block</span><span class="s2">.</span><span class="s1">refs </span><span class="s0">if </span><span class="s1">track_ref </span><span class="s0">else None</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">SingleBlockManager</span><span class="s2">(</span><span class="s1">nb</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">1</span><span class="s2">])</span>

    <span class="s0">def </span><span class="s1">iget_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">i</span><span class="s2">: </span><span class="s1">int</span><span class="s2">) </span><span class="s1">-&gt; ArrayLike</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the data for column i as the values (ndarray or ExtensionArray). 
 
        Warning! The returned array is a view but doesn't handle Copy-on-Write, 
        so this should be used with caution. 
        &quot;&quot;&quot;</span>
        <span class="s4"># TODO(CoW) making the arrays read-only might make this safer to use?</span>
        <span class="s1">block </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blknos</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]]</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">block</span><span class="s2">.</span><span class="s1">iget</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blklocs</span><span class="s2">[</span><span class="s1">i</span><span class="s2">])</span>
        <span class="s0">return </span><span class="s1">values</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">column_arrays</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Used in the JSON C code to access column arrays. 
        This optimizes compared to using `iget_values` by converting each 
 
        Warning! This doesn't handle Copy-on-Write, so should be used with 
        caution (current use case of consuming this in the JSON code is fine). 
        &quot;&quot;&quot;</span>
        <span class="s4"># This is an optimized equivalent to</span>
        <span class="s4">#  result = [self.iget_values(i) for i in range(len(self.items))]</span>
        <span class="s1">result</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray </span><span class="s2">| </span><span class="s0">None</span><span class="s2">] = [</span><span class="s0">None</span><span class="s2">] * </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">:</span>
            <span class="s1">mgr_locs </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">_mgr_locs</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">array_values</span><span class="s2">.</span><span class="s1">_values_for_json</span><span class="s2">()</span>
            <span class="s0">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s4"># TODO(EA2D): special casing not needed with 2D EAs</span>
                <span class="s1">result</span><span class="s2">[</span><span class="s1">mgr_locs</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]] = </span><span class="s1">values</span>

            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">loc </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">mgr_locs</span><span class="s2">):</span>
                    <span class="s1">result</span><span class="s2">[</span><span class="s1">loc</span><span class="s2">] = </span><span class="s1">values</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>

        <span class="s4"># error: Incompatible return value type (got &quot;List[None]&quot;,</span>
        <span class="s4"># expected &quot;List[ndarray[Any, Any]]&quot;)</span>
        <span class="s0">return </span><span class="s1">result  </span><span class="s4"># type: ignore[return-value]</span>

    <span class="s0">def </span><span class="s1">iset</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">loc</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s1">slice </span><span class="s2">| </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">,</span>
        <span class="s1">value</span><span class="s2">: </span><span class="s1">ArrayLike</span><span class="s2">,</span>
        <span class="s1">inplace</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">refs</span><span class="s2">: </span><span class="s1">BlockValuesRefs </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Set new item in-place. Does not consolidate. Adds new Block if not 
        contained in the current set of items 
        &quot;&quot;&quot;</span>

        <span class="s4"># FIXME: refactor, clearly separate broadcasting &amp; zip-like assignment</span>
        <span class="s4">#        can prob also fix the various if tests for sparse/categorical</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_blklocs </span><span class="s0">is None and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_rebuild_blknos_and_blklocs</span><span class="s2">()</span>

        <span class="s4"># Note: we exclude DTA/TDA here</span>
        <span class="s1">value_is_extension_type </span><span class="s2">= </span><span class="s1">is_1d_only_ea_dtype</span><span class="s2">(</span><span class="s1">value</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">value_is_extension_type</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">value</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2</span><span class="s2">:</span>
                <span class="s1">value </span><span class="s2">= </span><span class="s1">value</span><span class="s2">.</span><span class="s1">T</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">value </span><span class="s2">= </span><span class="s1">ensure_block_shape</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">value</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:] != </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]:</span>
                <span class="s0">raise </span><span class="s1">AssertionError</span><span class="s2">(</span>
                    <span class="s6">&quot;Shape of new values must be compatible with manager shape&quot;</span>
                <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">is_integer</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">):</span>
            <span class="s4"># We have 6 tests where loc is _not_ an int.</span>
            <span class="s4"># In this case, get_blkno_placements will yield only one tuple,</span>
            <span class="s4">#  containing (self._blknos[loc], BlockPlacement(slice(0, 1, 1)))</span>

            <span class="s4"># Check if we can use _iset_single fastpath</span>
            <span class="s1">loc </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">int</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">)</span>
            <span class="s1">blkno </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blknos</span><span class="s2">[</span><span class="s1">loc</span><span class="s2">]</span>
            <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blkno</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">_mgr_locs</span><span class="s2">) == </span><span class="s5">1</span><span class="s2">:  </span><span class="s4"># TODO: fastest way to check this?</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_iset_single</span><span class="s2">(</span>
                    <span class="s1">loc</span><span class="s2">,</span>
                    <span class="s1">value</span><span class="s2">,</span>
                    <span class="s1">inplace</span><span class="s2">=</span><span class="s1">inplace</span><span class="s2">,</span>
                    <span class="s1">blkno</span><span class="s2">=</span><span class="s1">blkno</span><span class="s2">,</span>
                    <span class="s1">blk</span><span class="s2">=</span><span class="s1">blk</span><span class="s2">,</span>
                    <span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">,</span>
                <span class="s2">)</span>

            <span class="s4"># error: Incompatible types in assignment (expression has type</span>
            <span class="s4"># &quot;List[Union[int, slice, ndarray]]&quot;, variable has type &quot;Union[int,</span>
            <span class="s4"># slice, ndarray]&quot;)</span>
            <span class="s1">loc </span><span class="s2">= [</span><span class="s1">loc</span><span class="s2">]  </span><span class="s4"># type: ignore[assignment]</span>

        <span class="s4"># categorical/sparse/datetimetz</span>
        <span class="s0">if </span><span class="s1">value_is_extension_type</span><span class="s2">:</span>

            <span class="s0">def </span><span class="s1">value_getitem</span><span class="s2">(</span><span class="s1">placement</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">value</span>

        <span class="s0">else</span><span class="s2">:</span>

            <span class="s0">def </span><span class="s1">value_getitem</span><span class="s2">(</span><span class="s1">placement</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">value</span><span class="s2">[</span><span class="s1">placement</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">]</span>

        <span class="s4"># Accessing public blknos ensures the public versions are initialized</span>
        <span class="s1">blknos </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blknos</span><span class="s2">[</span><span class="s1">loc</span><span class="s2">]</span>
        <span class="s1">blklocs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blklocs</span><span class="s2">[</span><span class="s1">loc</span><span class="s2">].</span><span class="s1">copy</span><span class="s2">()</span>

        <span class="s1">unfit_mgr_locs </span><span class="s2">= []</span>
        <span class="s1">unfit_val_locs </span><span class="s2">= []</span>
        <span class="s1">removed_blknos </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">blkno_l</span><span class="s2">, </span><span class="s1">val_locs </span><span class="s0">in </span><span class="s1">libinternals</span><span class="s2">.</span><span class="s1">get_blkno_placements</span><span class="s2">(</span><span class="s1">blknos</span><span class="s2">, </span><span class="s1">group</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
            <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blkno_l</span><span class="s2">]</span>
            <span class="s1">blk_locs </span><span class="s2">= </span><span class="s1">blklocs</span><span class="s2">[</span><span class="s1">val_locs</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">inplace </span><span class="s0">and </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">should_store</span><span class="s2">(</span><span class="s1">value</span><span class="s2">):</span>
                <span class="s4"># Updating inplace -&gt; check if we need to do Copy-on-Write</span>
                <span class="s0">if </span><span class="s1">using_copy_on_write</span><span class="s2">() </span><span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_has_no_reference_block</span><span class="s2">(</span><span class="s1">blkno_l</span><span class="s2">):</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_iset_split_block</span><span class="s2">(</span>
                        <span class="s1">blkno_l</span><span class="s2">, </span><span class="s1">blk_locs</span><span class="s2">, </span><span class="s1">value_getitem</span><span class="s2">(</span><span class="s1">val_locs</span><span class="s2">), </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span>
                    <span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">blk</span><span class="s2">.</span><span class="s1">set_inplace</span><span class="s2">(</span><span class="s1">blk_locs</span><span class="s2">, </span><span class="s1">value_getitem</span><span class="s2">(</span><span class="s1">val_locs</span><span class="s2">))</span>
                    <span class="s0">continue</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">unfit_mgr_locs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">mgr_locs</span><span class="s2">.</span><span class="s1">as_array</span><span class="s2">[</span><span class="s1">blk_locs</span><span class="s2">])</span>
                <span class="s1">unfit_val_locs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">val_locs</span><span class="s2">)</span>

                <span class="s4"># If all block items are unfit, schedule the block for removal.</span>
                <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">val_locs</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">mgr_locs</span><span class="s2">):</span>
                    <span class="s1">removed_blknos</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">blkno_l</span><span class="s2">)</span>
                    <span class="s0">continue</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s4"># Defer setting the new values to enable consolidation</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_iset_split_block</span><span class="s2">(</span><span class="s1">blkno_l</span><span class="s2">, </span><span class="s1">blk_locs</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">removed_blknos</span><span class="s2">):</span>
            <span class="s4"># Remove blocks &amp; update blknos accordingly</span>
            <span class="s1">is_deleted </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nblocks</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">)</span>
            <span class="s1">is_deleted</span><span class="s2">[</span><span class="s1">removed_blknos</span><span class="s2">] = </span><span class="s0">True</span>

            <span class="s1">new_blknos </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nblocks</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">)</span>
            <span class="s1">new_blknos</span><span class="s2">.</span><span class="s1">fill</span><span class="s2">(-</span><span class="s5">1</span><span class="s2">)</span>
            <span class="s1">new_blknos</span><span class="s2">[~</span><span class="s1">is_deleted</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nblocks </span><span class="s2">- </span><span class="s1">len</span><span class="s2">(</span><span class="s1">removed_blknos</span><span class="s2">))</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_blknos </span><span class="s2">= </span><span class="s1">new_blknos</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_blknos</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span>
                <span class="s1">blk </span><span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">) </span><span class="s0">if </span><span class="s1">i </span><span class="s0">not in </span><span class="s1">set</span><span class="s2">(</span><span class="s1">removed_blknos</span><span class="s2">)</span>
            <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">unfit_val_locs</span><span class="s2">:</span>
            <span class="s1">unfit_idxr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">unfit_mgr_locs</span><span class="s2">)</span>
            <span class="s1">unfit_count </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">unfit_idxr</span><span class="s2">)</span>

            <span class="s1">new_blocks</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">] = []</span>
            <span class="s0">if </span><span class="s1">value_is_extension_type</span><span class="s2">:</span>
                <span class="s4"># This code (ab-)uses the fact that EA blocks contain only</span>
                <span class="s4"># one item.</span>
                <span class="s4"># TODO(EA2D): special casing unnecessary with 2D EAs</span>
                <span class="s1">new_blocks</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span>
                    <span class="s1">new_block_2d</span><span class="s2">(</span>
                        <span class="s1">values</span><span class="s2">=</span><span class="s1">value</span><span class="s2">,</span>
                        <span class="s1">placement</span><span class="s2">=</span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s1">mgr_loc</span><span class="s2">, </span><span class="s1">mgr_loc </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">)),</span>
                        <span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">,</span>
                    <span class="s2">)</span>
                    <span class="s0">for </span><span class="s1">mgr_loc </span><span class="s0">in </span><span class="s1">unfit_idxr</span>
                <span class="s2">)</span>

                <span class="s1">self</span><span class="s2">.</span><span class="s1">_blknos</span><span class="s2">[</span><span class="s1">unfit_idxr</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">unfit_count</span><span class="s2">) + </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_blklocs</span><span class="s2">[</span><span class="s1">unfit_idxr</span><span class="s2">] = </span><span class="s5">0</span>

            <span class="s0">else</span><span class="s2">:</span>
                <span class="s4"># unfit_val_locs contains BlockPlacement objects</span>
                <span class="s1">unfit_val_items </span><span class="s2">= </span><span class="s1">unfit_val_locs</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">append</span><span class="s2">(</span><span class="s1">unfit_val_locs</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:])</span>

                <span class="s1">new_blocks</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span>
                    <span class="s1">new_block_2d</span><span class="s2">(</span>
                        <span class="s1">values</span><span class="s2">=</span><span class="s1">value_getitem</span><span class="s2">(</span><span class="s1">unfit_val_items</span><span class="s2">),</span>
                        <span class="s1">placement</span><span class="s2">=</span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">unfit_idxr</span><span class="s2">),</span>
                        <span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">,</span>
                    <span class="s2">)</span>
                <span class="s2">)</span>

                <span class="s1">self</span><span class="s2">.</span><span class="s1">_blknos</span><span class="s2">[</span><span class="s1">unfit_idxr</span><span class="s2">] = </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_blklocs</span><span class="s2">[</span><span class="s1">unfit_idxr</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">unfit_count</span><span class="s2">)</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">+= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">new_blocks</span><span class="s2">)</span>

            <span class="s4"># Newly created block's dtype may already be present.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_known_consolidated </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">_iset_split_block</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">blkno_l</span><span class="s2">: </span><span class="s1">int</span><span class="s2">,</span>
        <span class="s1">blk_locs</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray </span><span class="s2">| </span><span class="s1">list</span><span class="s2">[</span><span class="s1">int</span><span class="s2">],</span>
        <span class="s1">value</span><span class="s2">: </span><span class="s1">ArrayLike </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">refs</span><span class="s2">: </span><span class="s1">BlockValuesRefs </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot;Removes columns from a block by splitting the block. 
 
        Avoids copying the whole block through slicing and updates the manager 
        after determinint the new block structure. Optionally adds a new block, 
        otherwise has to be done by the caller. 
 
        Parameters 
        ---------- 
        blkno_l: The block number to operate on, relevant for updating the manager 
        blk_locs: The locations of our block that should be deleted. 
        value: The value to set as a replacement. 
        refs: The reference tracking object of the value to set. 
        &quot;&quot;&quot;</span>
        <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blkno_l</span><span class="s2">]</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_blklocs </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_rebuild_blknos_and_blklocs</span><span class="s2">()</span>

        <span class="s1">nbs_tup </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">delete</span><span class="s2">(</span><span class="s1">blk_locs</span><span class="s2">))</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">locs </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">mgr_locs</span><span class="s2">.</span><span class="s1">as_array</span><span class="s2">[</span><span class="s1">blk_locs</span><span class="s2">]</span>
            <span class="s1">first_nb </span><span class="s2">= </span><span class="s1">new_block_2d</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">locs</span><span class="s2">), </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">first_nb </span><span class="s2">= </span><span class="s1">nbs_tup</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s1">nbs_tup </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">nbs_tup</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:])</span>

        <span class="s1">nr_blocks </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
        <span class="s1">blocks_tup </span><span class="s2">= (</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[:</span><span class="s1">blkno_l</span><span class="s2">] + (</span><span class="s1">first_nb</span><span class="s2">,) + </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blkno_l </span><span class="s2">+ </span><span class="s5">1 </span><span class="s2">:] + </span><span class="s1">nbs_tup</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= </span><span class="s1">blocks_tup</span>

        <span class="s0">if not </span><span class="s1">nbs_tup </span><span class="s0">and </span><span class="s1">value </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s4"># No need to update anything if split did not happen</span>
            <span class="s0">return</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_blklocs</span><span class="s2">[</span><span class="s1">first_nb</span><span class="s2">.</span><span class="s1">mgr_locs</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">first_nb</span><span class="s2">))</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">nb </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">nbs_tup</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_blklocs</span><span class="s2">[</span><span class="s1">nb</span><span class="s2">.</span><span class="s1">mgr_locs</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">nb</span><span class="s2">))</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_blknos</span><span class="s2">[</span><span class="s1">nb</span><span class="s2">.</span><span class="s1">mgr_locs</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">] = </span><span class="s1">i </span><span class="s2">+ </span><span class="s1">nr_blocks</span>

    <span class="s0">def </span><span class="s1">_iset_single</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">loc</span><span class="s2">: </span><span class="s1">int</span><span class="s2">,</span>
        <span class="s1">value</span><span class="s2">: </span><span class="s1">ArrayLike</span><span class="s2">,</span>
        <span class="s1">inplace</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">,</span>
        <span class="s1">blkno</span><span class="s2">: </span><span class="s1">int</span><span class="s2">,</span>
        <span class="s1">blk</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">,</span>
        <span class="s1">refs</span><span class="s2">: </span><span class="s1">BlockValuesRefs </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Fastpath for iset when we are only setting a single position and 
        the Block currently in that position is itself single-column. 
 
        In this case we can swap out the entire Block and blklocs and blknos 
        are unaffected. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Caller is responsible for verifying value.shape</span>

        <span class="s0">if </span><span class="s1">inplace </span><span class="s0">and </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">should_store</span><span class="s2">(</span><span class="s1">value</span><span class="s2">):</span>
            <span class="s1">copy </span><span class="s2">= </span><span class="s0">False</span>
            <span class="s0">if </span><span class="s1">using_copy_on_write</span><span class="s2">() </span><span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_has_no_reference_block</span><span class="s2">(</span><span class="s1">blkno</span><span class="s2">):</span>
                <span class="s4"># perform Copy-on-Write and clear the reference</span>
                <span class="s1">copy </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">iloc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blklocs</span><span class="s2">[</span><span class="s1">loc</span><span class="s2">]</span>
            <span class="s1">blk</span><span class="s2">.</span><span class="s1">set_inplace</span><span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s1">iloc</span><span class="s2">, </span><span class="s1">iloc </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">), </span><span class="s1">value</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>
            <span class="s0">return</span>

        <span class="s1">nb </span><span class="s2">= </span><span class="s1">new_block_2d</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">_mgr_locs</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>
        <span class="s1">old_blocks </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span>
        <span class="s1">new_blocks </span><span class="s2">= </span><span class="s1">old_blocks</span><span class="s2">[:</span><span class="s1">blkno</span><span class="s2">] + (</span><span class="s1">nb</span><span class="s2">,) + </span><span class="s1">old_blocks</span><span class="s2">[</span><span class="s1">blkno </span><span class="s2">+ </span><span class="s5">1 </span><span class="s2">:]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= </span><span class="s1">new_blocks</span>
        <span class="s0">return</span>

    <span class="s0">def </span><span class="s1">column_setitem</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">: </span><span class="s1">int</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s1">slice </span><span class="s2">| </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">inplace_only</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Set values (&quot;setitem&quot;) into a single column (not setting the full column). 
 
        This is a method on the BlockManager level, to avoid creating an 
        intermediate Series at the DataFrame level (`s = df[loc]; s[idx] = value`) 
        &quot;&quot;&quot;</span>
        <span class="s1">needs_to_warn </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">warn_copy_on_write</span><span class="s2">() </span><span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_has_no_reference</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blknos</span><span class="s2">[</span><span class="s1">loc</span><span class="s2">]].</span><span class="s1">values</span><span class="s2">,</span>
                <span class="s2">(</span><span class="s1">ArrowExtensionArray</span><span class="s2">, </span><span class="s1">ArrowStringArray</span><span class="s2">),</span>
            <span class="s2">):</span>
                <span class="s4"># We might raise if we are in an expansion case, so defer</span>
                <span class="s4"># warning till we actually updated</span>
                <span class="s1">needs_to_warn </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s0">elif </span><span class="s1">using_copy_on_write</span><span class="s2">() </span><span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_has_no_reference</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">):</span>
            <span class="s1">blkno </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blknos</span><span class="s2">[</span><span class="s1">loc</span><span class="s2">]</span>
            <span class="s4"># Split blocks to only copy the column we want to modify</span>
            <span class="s1">blk_loc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blklocs</span><span class="s2">[</span><span class="s1">loc</span><span class="s2">]</span>
            <span class="s4"># Copy our values</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blkno</span><span class="s2">].</span><span class="s1">values</span>
            <span class="s0">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s4"># Use [blk_loc] as indexer to keep ndim=2, this already results in a</span>
                <span class="s4"># copy</span>
                <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">[[</span><span class="s1">blk_loc</span><span class="s2">]]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_iset_split_block</span><span class="s2">(</span><span class="s1">blkno</span><span class="s2">, [</span><span class="s1">blk_loc</span><span class="s2">], </span><span class="s1">values</span><span class="s2">)</span>

        <span class="s4"># this manager is only created temporarily to mutate the values in place</span>
        <span class="s4"># so don't track references, otherwise the `setitem` would perform CoW again</span>
        <span class="s1">col_mgr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">iget</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">, </span><span class="s1">track_ref</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">inplace_only</span><span class="s2">:</span>
            <span class="s1">col_mgr</span><span class="s2">.</span><span class="s1">setitem_inplace</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">new_mgr </span><span class="s2">= </span><span class="s1">col_mgr</span><span class="s2">.</span><span class="s1">setitem</span><span class="s2">((</span><span class="s1">idx</span><span class="s2">,), </span><span class="s1">value</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">iset</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">, </span><span class="s1">new_mgr</span><span class="s2">.</span><span class="s1">_block</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">inplace</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">needs_to_warn</span><span class="s2">:</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s1">COW_WARNING_GENERAL_MSG</span><span class="s2">,</span>
                <span class="s1">FutureWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
            <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">insert</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">: </span><span class="s1">int</span><span class="s2">, </span><span class="s1">item</span><span class="s2">: </span><span class="s1">Hashable</span><span class="s2">, </span><span class="s1">value</span><span class="s2">: </span><span class="s1">ArrayLike</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Insert item at selected position. 
 
        Parameters 
        ---------- 
        loc : int 
        item : hashable 
        value : np.ndarray or ExtensionArray 
        refs : The reference tracking object of the value to set. 
        &quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">warnings</span><span class="s2">.</span><span class="s1">catch_warnings</span><span class="s2">():</span>
            <span class="s4"># TODO: re-issue this with setitem-specific message?</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">filterwarnings</span><span class="s2">(</span>
                <span class="s6">&quot;ignore&quot;</span><span class="s2">,</span>
                <span class="s6">&quot;The behavior of Index.insert with object-dtype is deprecated&quot;</span><span class="s2">,</span>
                <span class="s1">category</span><span class="s2">=</span><span class="s1">FutureWarning</span><span class="s2">,</span>
            <span class="s2">)</span>
            <span class="s1">new_axis </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">.</span><span class="s1">insert</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">, </span><span class="s1">item</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">value</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">value</span><span class="s2">.</span><span class="s1">T</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">value</span><span class="s2">) &gt; </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s6">f&quot;Expected a 1D array, got an array with shape </span><span class="s0">{</span><span class="s1">value</span><span class="s2">.</span><span class="s1">T</span><span class="s2">.</span><span class="s1">shape</span><span class="s0">}</span><span class="s6">&quot;</span>
                <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">value </span><span class="s2">= </span><span class="s1">ensure_block_shape</span><span class="s2">(</span><span class="s1">value</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>

        <span class="s1">bp </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">, </span><span class="s1">loc </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">))</span>
        <span class="s1">block </span><span class="s2">= </span><span class="s1">new_block_2d</span><span class="s2">(</span><span class="s1">values</span><span class="s2">=</span><span class="s1">value</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">bp</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>

        <span class="s0">if not </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">):</span>
            <span class="s4"># Fastpath</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_blklocs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">0</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_blknos </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">0</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_insert_update_mgr_locs</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_insert_update_blklocs_and_blknos</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] = </span><span class="s1">new_axis</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">+= (</span><span class="s1">block</span><span class="s2">,)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_known_consolidated </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s0">if </span><span class="s1">sum</span><span class="s2">(</span><span class="s0">not </span><span class="s1">block</span><span class="s2">.</span><span class="s1">is_extension </span><span class="s0">for </span><span class="s1">block </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">) &gt; </span><span class="s5">100</span><span class="s2">:</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s6">&quot;DataFrame is highly fragmented.  This is usually the result &quot;</span>
                <span class="s6">&quot;of calling `frame.insert` many times, which has poor performance.  &quot;</span>
                <span class="s6">&quot;Consider joining all columns at once using pd.concat(axis=1) &quot;</span>
                <span class="s6">&quot;instead. To get a de-fragmented frame, use `newframe = frame.copy()`&quot;</span><span class="s2">,</span>
                <span class="s1">PerformanceWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
            <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_insert_update_mgr_locs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        When inserting a new Block at location 'loc', we increment 
        all of the mgr_locs of blocks above that by one. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">blkno</span><span class="s2">, </span><span class="s1">count </span><span class="s0">in </span><span class="s1">_fast_count_smallints</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blknos</span><span class="s2">[</span><span class="s1">loc</span><span class="s2">:]):</span>
            <span class="s4"># .620 this way, .326 of which is in increment_above</span>
            <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s1">blkno</span><span class="s2">]</span>
            <span class="s1">blk</span><span class="s2">.</span><span class="s1">_mgr_locs </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">_mgr_locs</span><span class="s2">.</span><span class="s1">increment_above</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_insert_update_blklocs_and_blknos</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        When inserting a new Block at location 'loc', we update our 
        _blklocs and _blknos. 
        &quot;&quot;&quot;</span>

        <span class="s4"># Accessing public blklocs ensures the public versions are initialized</span>
        <span class="s0">if </span><span class="s1">loc </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blklocs</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]:</span>
            <span class="s4"># np.append is a lot faster, let's use it if we can.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_blklocs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_blklocs</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_blknos </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_blknos</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">))</span>
        <span class="s0">elif </span><span class="s1">loc </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4"># np.append is a lot faster, let's use it if we can.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_blklocs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_blklocs</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">], </span><span class="s5">0</span><span class="s2">)[::-</span><span class="s5">1</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_blknos </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_blknos</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">))[::-</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">new_blklocs</span><span class="s2">, </span><span class="s1">new_blknos </span><span class="s2">= </span><span class="s1">libinternals</span><span class="s2">.</span><span class="s1">update_blklocs_and_blknos</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">blklocs</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blknos</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
            <span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_blklocs </span><span class="s2">= </span><span class="s1">new_blklocs</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_blknos </span><span class="s2">= </span><span class="s1">new_blknos</span>

    <span class="s0">def </span><span class="s1">idelete</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">) </span><span class="s1">-&gt; BlockManager</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Delete selected locations, returning a new BlockManager. 
        &quot;&quot;&quot;</span>
        <span class="s1">is_deleted </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">)</span>
        <span class="s1">is_deleted</span><span class="s2">[</span><span class="s1">indexer</span><span class="s2">] = </span><span class="s0">True</span>
        <span class="s1">taker </span><span class="s2">= (~</span><span class="s1">is_deleted</span><span class="s2">).</span><span class="s1">nonzero</span><span class="s2">()[</span><span class="s5">0</span><span class="s2">]</span>

        <span class="s1">nbs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_slice_take_blocks_ax0</span><span class="s2">(</span><span class="s1">taker</span><span class="s2">, </span><span class="s1">only_slice</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">ref_inplace_op</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">new_columns </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">[~</span><span class="s1">is_deleted</span><span class="s2">]</span>
        <span class="s1">axes </span><span class="s2">= [</span><span class="s1">new_columns</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]]</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">nbs</span><span class="s2">), </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">verify_integrity</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s4"># ----------------------------------------------------------------</span>
    <span class="s4"># Block-wise Operation</span>

    <span class="s0">def </span><span class="s1">grouped_reduce</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">: </span><span class="s1">Callable</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Apply grouped reduction function blockwise, returning a new BlockManager. 
 
        Parameters 
        ---------- 
        func : grouped reduction function 
 
        Returns 
        ------- 
        BlockManager 
        &quot;&quot;&quot;</span>
        <span class="s1">result_blocks</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">] = []</span>

        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">is_object</span><span class="s2">:</span>
                <span class="s4"># split on object-dtype blocks bc some columns may raise</span>
                <span class="s4">#  while others do not.</span>
                <span class="s0">for </span><span class="s1">sb </span><span class="s0">in </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">_split</span><span class="s2">():</span>
                    <span class="s1">applied </span><span class="s2">= </span><span class="s1">sb</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
                    <span class="s1">result_blocks </span><span class="s2">= </span><span class="s1">extend_blocks</span><span class="s2">(</span><span class="s1">applied</span><span class="s2">, </span><span class="s1">result_blocks</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">applied </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
                <span class="s1">result_blocks </span><span class="s2">= </span><span class="s1">extend_blocks</span><span class="s2">(</span><span class="s1">applied</span><span class="s2">, </span><span class="s1">result_blocks</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">result_blocks</span><span class="s2">) == </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">nrows </span><span class="s2">= </span><span class="s5">0</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">nrows </span><span class="s2">= </span><span class="s1">result_blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">values</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s1">index </span><span class="s2">= </span><span class="s1">Index</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">nrows</span><span class="s2">))</span>

        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">from_blocks</span><span class="s2">(</span><span class="s1">result_blocks</span><span class="s2">, [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">index</span><span class="s2">])</span>

    <span class="s0">def </span><span class="s1">reduce</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">: </span><span class="s1">Callable</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Apply reduction function blockwise, returning a single-row BlockManager. 
 
        Parameters 
        ---------- 
        func : reduction function 
 
        Returns 
        ------- 
        BlockManager 
        &quot;&quot;&quot;</span>
        <span class="s4"># If 2D, we assume that we're operating column-wise</span>
        <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2</span>

        <span class="s1">res_blocks</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">] = []</span>
        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">:</span>
            <span class="s1">nbs </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">reduce</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
            <span class="s1">res_blocks</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">nbs</span><span class="s2">)</span>

        <span class="s1">index </span><span class="s2">= </span><span class="s1">Index</span><span class="s2">([</span><span class="s0">None</span><span class="s2">])  </span><span class="s4"># placeholder</span>
        <span class="s1">new_mgr </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">from_blocks</span><span class="s2">(</span><span class="s1">res_blocks</span><span class="s2">, [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">, </span><span class="s1">index</span><span class="s2">])</span>
        <span class="s0">return </span><span class="s1">new_mgr</span>

    <span class="s0">def </span><span class="s1">operate_blockwise</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">: </span><span class="s1">BlockManager</span><span class="s2">, </span><span class="s1">array_op</span><span class="s2">) </span><span class="s1">-&gt; BlockManager</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Apply array_op blockwise with another (aligned) BlockManager. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">operate_blockwise</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">array_op</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_equal_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">: </span><span class="s1">BlockManager</span><span class="s2">, </span><span class="s1">other</span><span class="s2">: </span><span class="s1">BlockManager</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Used in .equals defined in base class. Only check the column values 
        assuming shape and indexes have already been checked. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">blockwise_all</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">array_equals</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">quantile</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">qs</span><span class="s2">: </span><span class="s1">Index</span><span class="s2">,  </span><span class="s4"># with dtype float 64</span>
        <span class="s1">interpolation</span><span class="s2">: </span><span class="s1">QuantileInterpolation </span><span class="s2">= </span><span class="s6">&quot;linear&quot;</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Iterate over blocks applying quantile reduction. 
        This routine is intended for reduction type operations and 
        will do inference on the generated blocks. 
 
        Parameters 
        ---------- 
        interpolation : type of interpolation, default 'linear' 
        qs : list of the quantiles to be computed 
 
        Returns 
        ------- 
        BlockManager 
        &quot;&quot;&quot;</span>
        <span class="s4"># Series dispatches to DataFrame for quantile, which allows us to</span>
        <span class="s4">#  simplify some of the code here and in the blocks</span>
        <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt;= </span><span class="s5">2</span>
        <span class="s0">assert </span><span class="s1">is_list_like</span><span class="s2">(</span><span class="s1">qs</span><span class="s2">)  </span><span class="s4"># caller is responsible for this</span>

        <span class="s1">new_axes </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">)</span>
        <span class="s1">new_axes</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] = </span><span class="s1">Index</span><span class="s2">(</span><span class="s1">qs</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>

        <span class="s1">blocks </span><span class="s2">= [</span>
            <span class="s1">blk</span><span class="s2">.</span><span class="s1">quantile</span><span class="s2">(</span><span class="s1">qs</span><span class="s2">=</span><span class="s1">qs</span><span class="s2">, </span><span class="s1">interpolation</span><span class="s2">=</span><span class="s1">interpolation</span><span class="s2">) </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span>
        <span class="s2">]</span>

        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">new_axes</span><span class="s2">)</span>

    <span class="s4"># ----------------------------------------------------------------</span>

    <span class="s0">def </span><span class="s1">unstack</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">unstacker</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">) </span><span class="s1">-&gt; BlockManager</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return a BlockManager with all blocks unstacked. 
 
        Parameters 
        ---------- 
        unstacker : reshape._Unstacker 
        fill_value : Any 
            fill_value for newly introduced missing values. 
 
        Returns 
        ------- 
        unstacked : BlockManager 
        &quot;&quot;&quot;</span>
        <span class="s1">new_columns </span><span class="s2">= </span><span class="s1">unstacker</span><span class="s2">.</span><span class="s1">get_new_columns</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">)</span>
        <span class="s1">new_index </span><span class="s2">= </span><span class="s1">unstacker</span><span class="s2">.</span><span class="s1">new_index</span>

        <span class="s1">allow_fill </span><span class="s2">= </span><span class="s0">not </span><span class="s1">unstacker</span><span class="s2">.</span><span class="s1">mask_all</span>
        <span class="s0">if </span><span class="s1">allow_fill</span><span class="s2">:</span>
            <span class="s4"># calculating the full mask once and passing it to Block._unstack is</span>
            <span class="s4">#  faster than letting calculating it in each repeated call</span>
            <span class="s1">new_mask2D </span><span class="s2">= (~</span><span class="s1">unstacker</span><span class="s2">.</span><span class="s1">mask</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(*</span><span class="s1">unstacker</span><span class="s2">.</span><span class="s1">full_shape</span><span class="s2">)</span>
            <span class="s1">needs_masking </span><span class="s2">= </span><span class="s1">new_mask2D</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">needs_masking </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">unstacker</span><span class="s2">.</span><span class="s1">full_shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>

        <span class="s1">new_blocks</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">] = []</span>
        <span class="s1">columns_mask</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">] = []</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">) == </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">factor </span><span class="s2">= </span><span class="s5">1</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">fac </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">new_columns</span><span class="s2">) / </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">)</span>
            <span class="s0">assert </span><span class="s1">fac </span><span class="s2">== </span><span class="s1">int</span><span class="s2">(</span><span class="s1">fac</span><span class="s2">)</span>
            <span class="s1">factor </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">fac</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">:</span>
            <span class="s1">mgr_locs </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">mgr_locs</span>
            <span class="s1">new_placement </span><span class="s2">= </span><span class="s1">mgr_locs</span><span class="s2">.</span><span class="s1">tile_for_unstack</span><span class="s2">(</span><span class="s1">factor</span><span class="s2">)</span>

            <span class="s1">blocks</span><span class="s2">, </span><span class="s1">mask </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">_unstack</span><span class="s2">(</span>
                <span class="s1">unstacker</span><span class="s2">,</span>
                <span class="s1">fill_value</span><span class="s2">,</span>
                <span class="s1">new_placement</span><span class="s2">=</span><span class="s1">new_placement</span><span class="s2">,</span>
                <span class="s1">needs_masking</span><span class="s2">=</span><span class="s1">needs_masking</span><span class="s2">,</span>
            <span class="s2">)</span>

            <span class="s1">new_blocks</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">)</span>
            <span class="s1">columns_mask</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">mask</span><span class="s2">)</span>

            <span class="s4"># Block._unstack should ensure this holds,</span>
            <span class="s0">assert </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">() == </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">nb</span><span class="s2">.</span><span class="s1">_mgr_locs</span><span class="s2">) </span><span class="s0">for </span><span class="s1">nb </span><span class="s0">in </span><span class="s1">blocks</span><span class="s2">)</span>
            <span class="s4"># In turn this ensures that in the BlockManager call below</span>
            <span class="s4">#  we have len(new_columns) == sum(x.shape[0] for x in new_blocks)</span>
            <span class="s4">#  which suffices to allow us to pass verify_inegrity=False</span>

        <span class="s1">new_columns </span><span class="s2">= </span><span class="s1">new_columns</span><span class="s2">[</span><span class="s1">columns_mask</span><span class="s2">]</span>

        <span class="s1">bm </span><span class="s2">= </span><span class="s1">BlockManager</span><span class="s2">(</span><span class="s1">new_blocks</span><span class="s2">, [</span><span class="s1">new_columns</span><span class="s2">, </span><span class="s1">new_index</span><span class="s2">], </span><span class="s1">verify_integrity</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">bm</span>

    <span class="s0">def </span><span class="s1">to_dict</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">Self</span><span class="s2">]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return a dict of str(dtype) -&gt; BlockManager 
 
        Returns 
        ------- 
        values : a dict of dtype -&gt; BlockManager 
        &quot;&quot;&quot;</span>

        <span class="s1">bd</span><span class="s2">: </span><span class="s1">dict</span><span class="s2">[</span><span class="s1">str</span><span class="s2">, </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]] = {}</span>
        <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">:</span>
            <span class="s1">bd</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">str</span><span class="s2">(</span><span class="s1">b</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">), []).</span><span class="s1">append</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>

        <span class="s4"># TODO(EA2D): the combine will be unnecessary with 2D EAs</span>
        <span class="s0">return </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_combine</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">) </span><span class="s0">for </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">blocks </span><span class="s0">in </span><span class="s1">bd</span><span class="s2">.</span><span class="s1">items</span><span class="s2">()}</span>

    <span class="s0">def </span><span class="s1">as_array</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">na_value</span><span class="s2">: </span><span class="s1">object </span><span class="s2">= </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Convert the blockmanager data into an numpy array. 
 
        Parameters 
        ---------- 
        dtype : np.dtype or None, default None 
            Data type of the return array. 
        copy : bool, default False 
            If True then guarantee that a copy is returned. A value of 
            False does not guarantee that the underlying data is not 
            copied. 
        na_value : object, default lib.no_default 
            Value to be used as the missing value sentinel. 
 
        Returns 
        ------- 
        arr : ndarray 
        &quot;&quot;&quot;</span>
        <span class="s1">passed_nan </span><span class="s2">= </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">is_float</span><span class="s2">(</span><span class="s1">na_value</span><span class="s2">) </span><span class="s0">and </span><span class="s1">isna</span><span class="s2">(</span><span class="s1">na_value</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">) == </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">arr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">transpose</span><span class="s2">()</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_single_block</span><span class="s2">:</span>
            <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>

            <span class="s0">if </span><span class="s1">na_value </span><span class="s0">is not </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">:</span>
                <span class="s4"># We want to copy when na_value is provided to avoid</span>
                <span class="s4"># mutating the original object</span>
                <span class="s0">if </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">is_np_dtype</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s6">&quot;f&quot;</span><span class="s2">) </span><span class="s0">and </span><span class="s1">passed_nan</span><span class="s2">:</span>
                    <span class="s4"># We are already numpy-float and na_value=np.nan</span>
                    <span class="s0">pass</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">copy </span><span class="s2">= </span><span class="s0">True</span>

            <span class="s0">if </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">is_extension</span><span class="s2">:</span>
                <span class="s4"># Avoid implicit conversion of extension blocks to object</span>

                <span class="s4"># error: Item &quot;ndarray&quot; of &quot;Union[ndarray, ExtensionArray]&quot; has no</span>
                <span class="s4"># attribute &quot;to_numpy&quot;</span>
                <span class="s1">arr </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">to_numpy</span><span class="s2">(  </span><span class="s4"># type: ignore[union-attr]</span>
                    <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
                    <span class="s1">na_value</span><span class="s2">=</span><span class="s1">na_value</span><span class="s2">,</span>
                    <span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">,</span>
                <span class="s2">).</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
            <span class="s0">elif not </span><span class="s1">copy</span><span class="s2">:</span>
                <span class="s1">arr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">arr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">using_copy_on_write</span><span class="s2">() </span><span class="s0">and not </span><span class="s1">copy</span><span class="s2">:</span>
                <span class="s1">arr </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">view</span><span class="s2">()</span>
                <span class="s1">arr</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">writeable </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">arr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_interleave</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">=</span><span class="s1">na_value</span><span class="s2">)</span>
            <span class="s4"># The underlying data was copied within _interleave, so no need</span>
            <span class="s4"># to further copy if copy=True or setting na_value</span>

        <span class="s0">if </span><span class="s1">na_value </span><span class="s0">is </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">:</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s6">&quot;f&quot; </span><span class="s0">and </span><span class="s1">passed_nan</span><span class="s2">:</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">arr</span><span class="s2">[</span><span class="s1">isna</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">)] = </span><span class="s1">na_value</span>

        <span class="s0">return </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">transpose</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">_interleave</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">na_value</span><span class="s2">: </span><span class="s1">object </span><span class="s2">= </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return ndarray from blocks with specified item order 
        Items must be contained in the blocks 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">dtype</span><span class="s2">:</span>
            <span class="s4"># Incompatible types in assignment (expression has type</span>
            <span class="s4"># &quot;Optional[Union[dtype[Any], ExtensionDtype]]&quot;, variable has</span>
            <span class="s4"># type &quot;Optional[dtype[Any]]&quot;)</span>
            <span class="s1">dtype </span><span class="s2">= </span><span class="s1">interleaved_dtype</span><span class="s2">(  </span><span class="s4"># type: ignore[assignment]</span>
                <span class="s2">[</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">]</span>
            <span class="s2">)</span>

        <span class="s4"># error: Argument 1 to &quot;ensure_np_dtype&quot; has incompatible type</span>
        <span class="s4"># &quot;Optional[dtype[Any]]&quot;; expected &quot;Union[dtype[Any], ExtensionDtype]&quot;</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">ensure_np_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)  </span><span class="s4"># type: ignore[arg-type]</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s1">itemmask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>

        <span class="s0">if </span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s6">&quot;object&quot;</span><span class="s2">) </span><span class="s0">and </span><span class="s1">na_value </span><span class="s0">is </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">:</span>
            <span class="s4"># much more performant than using to_numpy below</span>
            <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">:</span>
                <span class="s1">rl </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">mgr_locs</span>
                <span class="s1">arr </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">get_values</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
                <span class="s1">result</span><span class="s2">[</span><span class="s1">rl</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">] = </span><span class="s1">arr</span>
                <span class="s1">itemmask</span><span class="s2">[</span><span class="s1">rl</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">] = </span><span class="s5">1</span>
            <span class="s0">return </span><span class="s1">result</span>

        <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">:</span>
            <span class="s1">rl </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">mgr_locs</span>
            <span class="s0">if </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">is_extension</span><span class="s2">:</span>
                <span class="s4"># Avoid implicit conversion of extension blocks to object</span>

                <span class="s4"># error: Item &quot;ndarray&quot; of &quot;Union[ndarray, ExtensionArray]&quot; has no</span>
                <span class="s4"># attribute &quot;to_numpy&quot;</span>
                <span class="s1">arr </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">to_numpy</span><span class="s2">(  </span><span class="s4"># type: ignore[union-attr]</span>
                    <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
                    <span class="s1">na_value</span><span class="s2">=</span><span class="s1">na_value</span><span class="s2">,</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">arr </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">get_values</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">result</span><span class="s2">[</span><span class="s1">rl</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">] = </span><span class="s1">arr</span>
            <span class="s1">itemmask</span><span class="s2">[</span><span class="s1">rl</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">] = </span><span class="s5">1</span>

        <span class="s0">if not </span><span class="s1">itemmask</span><span class="s2">.</span><span class="s1">all</span><span class="s2">():</span>
            <span class="s0">raise </span><span class="s1">AssertionError</span><span class="s2">(</span><span class="s6">&quot;Some items were not contained in blocks&quot;</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s4"># ----------------------------------------------------------------</span>
    <span class="s4"># Consolidation</span>

    <span class="s0">def </span><span class="s1">is_consolidated</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return True if more than one block with the same dtype 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_known_consolidated</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_consolidate_check</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_is_consolidated</span>

    <span class="s0">def </span><span class="s1">_consolidate_check</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">) == </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4"># fastpath</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_is_consolidated </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_known_consolidated </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">return</span>
        <span class="s1">dtypes </span><span class="s2">= [</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">dtype </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks </span><span class="s0">if </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">_can_consolidate</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_is_consolidated </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">dtypes</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">dtypes</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_known_consolidated </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">_consolidate_inplace</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4"># In general, _consolidate_inplace should only be called via</span>
        <span class="s4">#  DataFrame._consolidate_inplace, otherwise we will fail to invalidate</span>
        <span class="s4">#  the DataFrame's _item_cache. The exception is for newly-created</span>
        <span class="s4">#  BlockManager objects not yet attached to a DataFrame.</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_consolidated</span><span class="s2">():</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= </span><span class="s1">_consolidate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_is_consolidated </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_known_consolidated </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_rebuild_blknos_and_blklocs</span><span class="s2">()</span>

    <span class="s4"># ----------------------------------------------------------------</span>
    <span class="s4"># Concatenation</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">concat_horizontal</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">mgrs</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Self</span><span class="s2">], </span><span class="s1">axes</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Index</span><span class="s2">]) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Concatenate uniformly-indexed BlockManagers horizontally. 
        &quot;&quot;&quot;</span>
        <span class="s1">offset </span><span class="s2">= </span><span class="s5">0</span>
        <span class="s1">blocks</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">] = []</span>
        <span class="s0">for </span><span class="s1">mgr </span><span class="s0">in </span><span class="s1">mgrs</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">mgr</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">:</span>
                <span class="s4"># We need to do getitem_block here otherwise we would be altering</span>
                <span class="s4">#  blk.mgr_locs in place, which would render it invalid. This is only</span>
                <span class="s4">#  relevant in the copy=False case.</span>
                <span class="s1">nb </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">slice_block_columns</span><span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">))</span>
                <span class="s1">nb</span><span class="s2">.</span><span class="s1">_mgr_locs </span><span class="s2">= </span><span class="s1">nb</span><span class="s2">.</span><span class="s1">_mgr_locs</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">offset</span><span class="s2">)</span>
                <span class="s1">blocks</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">nb</span><span class="s2">)</span>

            <span class="s1">offset </span><span class="s2">+= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">mgr</span><span class="s2">.</span><span class="s1">items</span><span class="s2">)</span>

        <span class="s1">new_mgr </span><span class="s2">= </span><span class="s1">cls</span><span class="s2">(</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">), </span><span class="s1">axes</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">new_mgr</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">concat_vertical</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">mgrs</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Self</span><span class="s2">], </span><span class="s1">axes</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Index</span><span class="s2">]) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Concatenate uniformly-indexed BlockManagers vertically. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s6">&quot;This logic lives (for now) in internals.concat&quot;</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">SingleBlockManager</span><span class="s2">(</span><span class="s1">BaseBlockManager</span><span class="s2">, </span><span class="s1">SingleDataManager</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;manage a single block with&quot;&quot;&quot;</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">ndim</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Literal</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]:</span>
        <span class="s0">return </span><span class="s5">1</span>

    <span class="s1">_is_consolidated </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s1">_known_consolidated </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s1">__slots__ </span><span class="s2">= ()</span>
    <span class="s1">is_single_block </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">block</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">: </span><span class="s1">Index</span><span class="s2">,</span>
        <span class="s1">verify_integrity</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s4"># Assertions disabled for performance</span>
        <span class="s4"># assert isinstance(block, Block), type(block)</span>
        <span class="s4"># assert isinstance(axis, Index), type(axis)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">axes </span><span class="s2">= [</span><span class="s1">axis</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= (</span><span class="s1">block</span><span class="s2">,)</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">from_blocks</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">blocks</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">],</span>
        <span class="s1">axes</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Index</span><span class="s2">],</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Constructor for BlockManager and SingleBlockManager with same signature. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">) == </span><span class="s5">1</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">axes</span><span class="s2">) == </span><span class="s5">1</span>
        <span class="s0">return </span><span class="s1">cls</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">verify_integrity</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">from_array</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">, </span><span class="s1">array</span><span class="s2">: </span><span class="s1">ArrayLike</span><span class="s2">, </span><span class="s1">index</span><span class="s2">: </span><span class="s1">Index</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">: </span><span class="s1">BlockValuesRefs </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s2">) </span><span class="s1">-&gt; SingleBlockManager</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Constructor for if we have an array that is not yet a Block. 
        &quot;&quot;&quot;</span>
        <span class="s1">array </span><span class="s2">= </span><span class="s1">maybe_coerce_values</span><span class="s2">(</span><span class="s1">array</span><span class="s2">)</span>
        <span class="s1">bp </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">index</span><span class="s2">)))</span>
        <span class="s1">block </span><span class="s2">= </span><span class="s1">new_block</span><span class="s2">(</span><span class="s1">array</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">bp</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">cls</span><span class="s2">(</span><span class="s1">block</span><span class="s2">, </span><span class="s1">index</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">to_2d_mgr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">columns</span><span class="s2">: </span><span class="s1">Index</span><span class="s2">) </span><span class="s1">-&gt; BlockManager</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Manager analogue of Series.to_frame 
        &quot;&quot;&quot;</span>
        <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s1">arr </span><span class="s2">= </span><span class="s1">ensure_block_shape</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>
        <span class="s1">bp </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s5">0</span><span class="s2">)</span>
        <span class="s1">new_blk </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">)(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">bp</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">)</span>
        <span class="s1">axes </span><span class="s2">= [</span><span class="s1">columns</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]]</span>
        <span class="s0">return </span><span class="s1">BlockManager</span><span class="s2">([</span><span class="s1">new_blk</span><span class="s2">], </span><span class="s1">axes</span><span class="s2">=</span><span class="s1">axes</span><span class="s2">, </span><span class="s1">verify_integrity</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_has_no_reference</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">i</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s5">0</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Check for column `i` if it has references. 
        (whether it references another array or is itself being referenced) 
        Returns True if the column has no references. 
        &quot;&quot;&quot;</span>
        <span class="s0">return not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">refs</span><span class="s2">.</span><span class="s1">has_reference</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">__getstate__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">block_values </span><span class="s2">= [</span><span class="s1">b</span><span class="s2">.</span><span class="s1">values </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">]</span>
        <span class="s1">block_items </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">[</span><span class="s1">b</span><span class="s2">.</span><span class="s1">mgr_locs</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">] </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">]</span>
        <span class="s1">axes_array </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">)</span>

        <span class="s1">extra_state </span><span class="s2">= {</span>
            <span class="s6">&quot;0.14.1&quot;</span><span class="s2">: {</span>
                <span class="s6">&quot;axes&quot;</span><span class="s2">: </span><span class="s1">axes_array</span><span class="s2">,</span>
                <span class="s6">&quot;blocks&quot;</span><span class="s2">: [</span>
                    <span class="s2">{</span><span class="s6">&quot;values&quot;</span><span class="s2">: </span><span class="s1">b</span><span class="s2">.</span><span class="s1">values</span><span class="s2">, </span><span class="s6">&quot;mgr_locs&quot;</span><span class="s2">: </span><span class="s1">b</span><span class="s2">.</span><span class="s1">mgr_locs</span><span class="s2">.</span><span class="s1">indexer</span><span class="s2">}</span>
                    <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span>
                <span class="s2">],</span>
            <span class="s2">}</span>
        <span class="s2">}</span>

        <span class="s4"># First three elements of the state are to maintain forward</span>
        <span class="s4"># compatibility with 0.13.1.</span>
        <span class="s0">return </span><span class="s1">axes_array</span><span class="s2">, </span><span class="s1">block_values</span><span class="s2">, </span><span class="s1">block_items</span><span class="s2">, </span><span class="s1">extra_state</span>

    <span class="s0">def </span><span class="s1">__setstate__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">state</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">def </span><span class="s1">unpickle_block</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">mgr_locs</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">: </span><span class="s1">int</span><span class="s2">) </span><span class="s1">-&gt; Block</span><span class="s2">:</span>
            <span class="s4"># TODO(EA2D): ndim would be unnecessary with 2D EAs</span>
            <span class="s4"># older pickles may store e.g. DatetimeIndex instead of DatetimeArray</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">extract_array</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">extract_numpy</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">mgr_locs</span><span class="s2">, </span><span class="s1">BlockPlacement</span><span class="s2">):</span>
                <span class="s1">mgr_locs </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">mgr_locs</span><span class="s2">)</span>

            <span class="s1">values </span><span class="s2">= </span><span class="s1">maybe_coerce_values</span><span class="s2">(</span><span class="s1">values</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">new_block</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">mgr_locs</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">ndim</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">state</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">) </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">state</span><span class="s2">) &gt;= </span><span class="s5">4 </span><span class="s0">and </span><span class="s6">&quot;0.14.1&quot; </span><span class="s0">in </span><span class="s1">state</span><span class="s2">[</span><span class="s5">3</span><span class="s2">]:</span>
            <span class="s1">state </span><span class="s2">= </span><span class="s1">state</span><span class="s2">[</span><span class="s5">3</span><span class="s2">][</span><span class="s6">&quot;0.14.1&quot;</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">axes </span><span class="s2">= [</span><span class="s1">ensure_index</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">) </span><span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">state</span><span class="s2">[</span><span class="s6">&quot;axes&quot;</span><span class="s2">]]</span>
            <span class="s1">ndim </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span>
                <span class="s1">unpickle_block</span><span class="s2">(</span><span class="s1">b</span><span class="s2">[</span><span class="s6">&quot;values&quot;</span><span class="s2">], </span><span class="s1">b</span><span class="s2">[</span><span class="s6">&quot;mgr_locs&quot;</span><span class="s2">], </span><span class="s1">ndim</span><span class="s2">=</span><span class="s1">ndim</span><span class="s2">)</span>
                <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">state</span><span class="s2">[</span><span class="s6">&quot;blocks&quot;</span><span class="s2">]</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s6">&quot;pre-0.14.1 pickles are no longer supported&quot;</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_post_setstate</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">_post_setstate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">pass</span>

    <span class="s2">@</span><span class="s1">cache_readonly</span>
    <span class="s0">def </span><span class="s1">_block</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Block</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">_blknos</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;compat with BlockManager&quot;&quot;&quot;</span>
        <span class="s0">return None</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">_blklocs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;compat with BlockManager&quot;&quot;&quot;</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">get_rows_with_mask</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">]) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s4"># similar to get_slice, but not restricted to slice indexer</span>
        <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_block</span>
        <span class="s0">if </span><span class="s1">using_copy_on_write</span><span class="s2">() </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">) &gt; </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">indexer</span><span class="s2">.</span><span class="s1">all</span><span class="s2">():</span>
            <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">), </span><span class="s1">self</span><span class="s2">.</span><span class="s1">index</span><span class="s2">)</span>
        <span class="s1">array </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">values</span><span class="s2">[</span><span class="s1">indexer</span><span class="s2">]</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s0">and </span><span class="s1">indexer</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s6">&quot;b&quot;</span><span class="s2">:</span>
            <span class="s4"># boolean indexing always gives a copy with numpy</span>
            <span class="s1">refs </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># TODO(CoW) in theory only need to track reference if new_array is a view</span>
            <span class="s1">refs </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">refs</span>

        <span class="s1">bp </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">array</span><span class="s2">)))</span>
        <span class="s1">block </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">)(</span><span class="s1">array</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">bp</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>

        <span class="s1">new_idx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">index</span><span class="s2">[</span><span class="s1">indexer</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span><span class="s1">block</span><span class="s2">, </span><span class="s1">new_idx</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_slice</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">slobj</span><span class="s2">: </span><span class="s1">slice</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">: </span><span class="s1">AxisInt </span><span class="s2">= </span><span class="s5">0</span><span class="s2">) </span><span class="s1">-&gt; SingleBlockManager</span><span class="s2">:</span>
        <span class="s4"># Assertion disabled for performance</span>
        <span class="s4"># assert isinstance(slobj, slice), type(slobj)</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s2">&gt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s6">&quot;Requested axis not found in manager&quot;</span><span class="s2">)</span>

        <span class="s1">blk </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_block</span>
        <span class="s1">array </span><span class="s2">= </span><span class="s1">blk</span><span class="s2">.</span><span class="s1">values</span><span class="s2">[</span><span class="s1">slobj</span><span class="s2">]</span>
        <span class="s1">bp </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">array</span><span class="s2">)))</span>
        <span class="s4"># TODO this method is only used in groupby SeriesSplitter at the moment,</span>
        <span class="s4"># so passing refs is not yet covered by the tests</span>
        <span class="s1">block </span><span class="s2">= </span><span class="s1">type</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">)(</span><span class="s1">array</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">bp</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">refs</span><span class="s2">)</span>
        <span class="s1">new_index </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">index</span><span class="s2">.</span><span class="s1">_getitem_slice</span><span class="s2">(</span><span class="s1">slobj</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)(</span><span class="s1">block</span><span class="s2">, </span><span class="s1">new_index</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">index</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Index</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; DtypeObj</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_block</span><span class="s2">.</span><span class="s1">dtype</span>

    <span class="s0">def </span><span class="s1">get_dtypes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">object_</span><span class="s2">]:</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_block</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">object</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">external_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;The array that Series.values returns&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_block</span><span class="s2">.</span><span class="s1">external_values</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">internal_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;The array that Series._values returns&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_block</span><span class="s2">.</span><span class="s1">values</span>

    <span class="s0">def </span><span class="s1">array_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; ExtensionArray</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot;The array that Series.array returns&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_block</span><span class="s2">.</span><span class="s1">array_values</span>

    <span class="s0">def </span><span class="s1">get_numeric_data</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_block</span><span class="s2">.</span><span class="s1">is_numeric</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">deep</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">make_empty</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">_can_hold_na</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_block</span><span class="s2">.</span><span class="s1">_can_hold_na</span>

    <span class="s0">def </span><span class="s1">setitem_inplace</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">warn</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Set values with indexer. 
 
        For Single[Block/Array]Manager, this backs s[indexer] = value 
 
        This is an inplace version of `setitem()`, mutating the manager/values 
        in place, not returning a new Manager (and Block), and thus never changing 
        the dtype. 
        &quot;&quot;&quot;</span>
        <span class="s1">using_cow </span><span class="s2">= </span><span class="s1">using_copy_on_write</span><span class="s2">()</span>
        <span class="s1">warn_cow </span><span class="s2">= </span><span class="s1">warn_copy_on_write</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">using_cow </span><span class="s0">or </span><span class="s1">warn_cow</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_has_no_reference</span><span class="s2">(</span><span class="s5">0</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">using_cow</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_block</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(),)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_cache</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>
            <span class="s0">elif </span><span class="s1">warn_cow </span><span class="s0">and </span><span class="s1">warn</span><span class="s2">:</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                    <span class="s1">COW_WARNING_SETITEM_MSG</span><span class="s2">,</span>
                    <span class="s1">FutureWarning</span><span class="s2">,</span>
                    <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
                <span class="s2">)</span>

        <span class="s1">super</span><span class="s2">().</span><span class="s1">setitem_inplace</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">value</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">idelete</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">) </span><span class="s1">-&gt; SingleBlockManager</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Delete single location from SingleBlockManager. 
 
        Ensures that self.blocks doesn't become empty. 
        &quot;&quot;&quot;</span>
        <span class="s1">nb </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_block</span><span class="s2">.</span><span class="s1">delete</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">)[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">blocks </span><span class="s2">= (</span><span class="s1">nb</span><span class="s2">,)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">delete</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_cache</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">fast_xs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        fast path for getting a cross-section 
        return a view of the data 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s6">&quot;Use series._values[loc] instead&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">set_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">: </span><span class="s1">ArrayLike</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Set the values of the single block in place. 
 
        Use at your own risk! This does not check if the passed values are 
        valid for the current Block/SingleBlockManager (length, dtype, etc), 
        and this does not properly keep track of references. 
        &quot;&quot;&quot;</span>
        <span class="s4"># NOTE(CoW) Currently this is only used for FrameColumnApply.series_generator</span>
        <span class="s4"># which handles CoW by setting the refs manually if necessary</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">values </span><span class="s2">= </span><span class="s1">values</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">_mgr_locs </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">slice</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">values</span><span class="s2">)))</span>

    <span class="s0">def </span><span class="s1">_equal_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">: </span><span class="s1">Self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Used in .equals defined in base class. Only check the column values 
        assuming shape and indexes have already been checked. 
        &quot;&quot;&quot;</span>
        <span class="s4"># For SingleBlockManager (i.e.Series)</span>
        <span class="s0">if </span><span class="s1">other</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s0">return False</span>
        <span class="s1">left </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">values</span>
        <span class="s1">right </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">values</span>
        <span class="s0">return </span><span class="s1">array_equals</span><span class="s2">(</span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">)</span>


<span class="s4"># --------------------------------------------------------------------</span>
<span class="s4"># Constructor Helpers</span>


<span class="s0">def </span><span class="s1">create_block_manager_from_blocks</span><span class="s2">(</span>
    <span class="s1">blocks</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">],</span>
    <span class="s1">axes</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Index</span><span class="s2">],</span>
    <span class="s1">consolidate</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s1">verify_integrity</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; BlockManager</span><span class="s2">:</span>
    <span class="s4"># If verify_integrity=False, then caller is responsible for checking</span>
    <span class="s4">#  all(x.shape[-1] == len(axes[1]) for x in blocks)</span>
    <span class="s4">#  sum(x.shape[0] for x in blocks) == len(axes[0])</span>
    <span class="s4">#  set(x for blk in blocks for x in blk.mgr_locs) == set(range(len(axes[0])))</span>
    <span class="s4">#  all(blk.ndim == 2 for blk in blocks)</span>
    <span class="s4"># This allows us to safely pass verify_integrity=False</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">mgr </span><span class="s2">= </span><span class="s1">BlockManager</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">verify_integrity</span><span class="s2">=</span><span class="s1">verify_integrity</span><span class="s2">)</span>

    <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">err</span><span class="s2">:</span>
        <span class="s1">arrays </span><span class="s2">= [</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">values </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">blocks</span><span class="s2">]</span>
        <span class="s1">tot_items </span><span class="s2">= </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] </span><span class="s0">for </span><span class="s1">arr </span><span class="s0">in </span><span class="s1">arrays</span><span class="s2">)</span>
        <span class="s1">raise_construction_error</span><span class="s2">(</span><span class="s1">tot_items</span><span class="s2">, </span><span class="s1">arrays</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:], </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">err</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">consolidate</span><span class="s2">:</span>
        <span class="s1">mgr</span><span class="s2">.</span><span class="s1">_consolidate_inplace</span><span class="s2">()</span>
    <span class="s0">return </span><span class="s1">mgr</span>


<span class="s0">def </span><span class="s1">create_block_manager_from_column_arrays</span><span class="s2">(</span>
    <span class="s1">arrays</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">ArrayLike</span><span class="s2">],</span>
    <span class="s1">axes</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Index</span><span class="s2">],</span>
    <span class="s1">consolidate</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">,</span>
    <span class="s1">refs</span><span class="s2">: </span><span class="s1">list</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; BlockManager</span><span class="s2">:</span>
    <span class="s4"># Assertions disabled for performance (caller is responsible for verifying)</span>
    <span class="s4"># assert isinstance(axes, list)</span>
    <span class="s4"># assert all(isinstance(x, Index) for x in axes)</span>
    <span class="s4"># assert all(isinstance(x, (np.ndarray, ExtensionArray)) for x in arrays)</span>
    <span class="s4"># assert all(type(x) is not NumpyExtensionArray for x in arrays)</span>
    <span class="s4"># assert all(x.ndim == 1 for x in arrays)</span>
    <span class="s4"># assert all(len(x) == len(axes[1]) for x in arrays)</span>
    <span class="s4"># assert len(arrays) == len(axes[0])</span>
    <span class="s4"># These last three are sufficient to allow us to safely pass</span>
    <span class="s4">#  verify_integrity=False below.</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">blocks </span><span class="s2">= </span><span class="s1">_form_blocks</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">, </span><span class="s1">consolidate</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">)</span>
        <span class="s1">mgr </span><span class="s2">= </span><span class="s1">BlockManager</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">verify_integrity</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
        <span class="s1">raise_construction_error</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">), </span><span class="s1">arrays</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">e</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">consolidate</span><span class="s2">:</span>
        <span class="s1">mgr</span><span class="s2">.</span><span class="s1">_consolidate_inplace</span><span class="s2">()</span>
    <span class="s0">return </span><span class="s1">mgr</span>


<span class="s0">def </span><span class="s1">raise_construction_error</span><span class="s2">(</span>
    <span class="s1">tot_items</span><span class="s2">: </span><span class="s1">int</span><span class="s2">,</span>
    <span class="s1">block_shape</span><span class="s2">: </span><span class="s1">Shape</span><span class="s2">,</span>
    <span class="s1">axes</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Index</span><span class="s2">],</span>
    <span class="s1">e</span><span class="s2">: </span><span class="s1">ValueError </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
<span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;raise a helpful message about our construction&quot;&quot;&quot;</span>
    <span class="s1">passed </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">int</span><span class="s2">, [</span><span class="s1">tot_items</span><span class="s2">] + </span><span class="s1">list</span><span class="s2">(</span><span class="s1">block_shape</span><span class="s2">)))</span>
    <span class="s4"># Correcting the user facing error message during dataframe construction</span>
    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">passed</span><span class="s2">) &lt;= </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s1">passed </span><span class="s2">= </span><span class="s1">passed</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">]</span>

    <span class="s1">implied </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">ax</span><span class="s2">) </span><span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axes</span><span class="s2">)</span>
    <span class="s4"># Correcting the user facing error message during dataframe construction</span>
    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">implied</span><span class="s2">) &lt;= </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s1">implied </span><span class="s2">= </span><span class="s1">implied</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">]</span>

    <span class="s4"># We return the exception object instead of raising it so that we</span>
    <span class="s4">#  can raise it in the caller; mypy plays better with that</span>
    <span class="s0">if </span><span class="s1">passed </span><span class="s2">== </span><span class="s1">implied </span><span class="s0">and </span><span class="s1">e </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">e</span>
    <span class="s0">if </span><span class="s1">block_shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] == </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;Empty data passed with indices specified.&quot;</span><span class="s2">)</span>
    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">f&quot;Shape of passed values is </span><span class="s0">{</span><span class="s1">passed</span><span class="s0">}</span><span class="s6">, indices imply </span><span class="s0">{</span><span class="s1">implied</span><span class="s0">}</span><span class="s6">&quot;</span><span class="s2">)</span>


<span class="s4"># -----------------------------------------------------------------------</span>


<span class="s0">def </span><span class="s1">_grouping_func</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">ArrayLike</span><span class="s2">]) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">int</span><span class="s2">, </span><span class="s1">DtypeObj</span><span class="s2">]:</span>
    <span class="s1">dtype </span><span class="s2">= </span><span class="s1">tup</span><span class="s2">[</span><span class="s5">1</span><span class="s2">].</span><span class="s1">dtype</span>

    <span class="s0">if </span><span class="s1">is_1d_only_ea_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s4"># We know these won't be consolidated, so don't need to group these.</span>
        <span class="s4"># This avoids expensive comparisons of CategoricalDtype objects</span>
        <span class="s1">sep </span><span class="s2">= </span><span class="s1">id</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">sep </span><span class="s2">= </span><span class="s5">0</span>

    <span class="s0">return </span><span class="s1">sep</span><span class="s2">, </span><span class="s1">dtype</span>


<span class="s0">def </span><span class="s1">_form_blocks</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">ArrayLike</span><span class="s2">], </span><span class="s1">consolidate</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">: </span><span class="s1">list</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
    <span class="s1">tuples </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">))</span>

    <span class="s0">if not </span><span class="s1">consolidate</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">_tuples_to_blocks_no_consolidate</span><span class="s2">(</span><span class="s1">tuples</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">)</span>

    <span class="s4"># when consolidating, we can ignore refs (either stacking always copies,</span>
    <span class="s4"># or the EA is already copied in the calling dict_to_mgr)</span>

    <span class="s4"># group by dtype</span>
    <span class="s1">grouper </span><span class="s2">= </span><span class="s1">itertools</span><span class="s2">.</span><span class="s1">groupby</span><span class="s2">(</span><span class="s1">tuples</span><span class="s2">, </span><span class="s1">_grouping_func</span><span class="s2">)</span>

    <span class="s1">nbs</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">] = []</span>
    <span class="s0">for </span><span class="s2">(</span><span class="s1">_</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">), </span><span class="s1">tup_block </span><span class="s0">in </span><span class="s1">grouper</span><span class="s2">:</span>
        <span class="s1">block_type </span><span class="s2">= </span><span class="s1">get_block_type</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">):</span>
            <span class="s1">is_dtlike </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">in </span><span class="s6">&quot;mM&quot;</span>

            <span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, (</span><span class="s1">str</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">)):</span>
                <span class="s1">dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">object</span><span class="s2">)</span>

            <span class="s1">values</span><span class="s2">, </span><span class="s1">placement </span><span class="s2">= </span><span class="s1">_stack_arrays</span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">tup_block</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">is_dtlike</span><span class="s2">:</span>
                <span class="s1">values </span><span class="s2">= </span><span class="s1">ensure_wrapped_if_datetimelike</span><span class="s2">(</span><span class="s1">values</span><span class="s2">)</span>
            <span class="s1">blk </span><span class="s2">= </span><span class="s1">block_type</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">placement</span><span class="s2">), </span><span class="s1">ndim</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>
            <span class="s1">nbs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">blk</span><span class="s2">)</span>

        <span class="s0">elif </span><span class="s1">is_1d_only_ea_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">):</span>
            <span class="s1">dtype_blocks </span><span class="s2">= [</span>
                <span class="s1">block_type</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[</span><span class="s5">1</span><span class="s2">], </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]), </span><span class="s1">ndim</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>
                <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">tup_block</span>
            <span class="s2">]</span>
            <span class="s1">nbs</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">dtype_blocks</span><span class="s2">)</span>

        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">dtype_blocks </span><span class="s2">= [</span>
                <span class="s1">block_type</span><span class="s2">(</span>
                    <span class="s1">ensure_block_shape</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[</span><span class="s5">1</span><span class="s2">], </span><span class="s5">2</span><span class="s2">), </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]), </span><span class="s1">ndim</span><span class="s2">=</span><span class="s5">2</span>
                <span class="s2">)</span>
                <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">tup_block</span>
            <span class="s2">]</span>
            <span class="s1">nbs</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">dtype_blocks</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">nbs</span>


<span class="s0">def </span><span class="s1">_tuples_to_blocks_no_consolidate</span><span class="s2">(</span><span class="s1">tuples</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">) </span><span class="s1">-&gt; list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">]:</span>
    <span class="s4"># tuples produced within _form_blocks are of the form (placement, array)</span>
    <span class="s0">return </span><span class="s2">[</span>
        <span class="s1">new_block_2d</span><span class="s2">(</span>
            <span class="s1">ensure_block_shape</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">=</span><span class="s5">2</span><span class="s2">), </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">i</span><span class="s2">), </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">ref</span>
        <span class="s2">)</span>
        <span class="s0">for </span><span class="s2">((</span><span class="s1">i</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">), </span><span class="s1">ref</span><span class="s2">) </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">tuples</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">)</span>
    <span class="s2">]</span>


<span class="s0">def </span><span class="s1">_stack_arrays</span><span class="s2">(</span><span class="s1">tuples</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">):</span>
    <span class="s1">placement</span><span class="s2">, </span><span class="s1">arrays </span><span class="s2">= </span><span class="s1">zip</span><span class="s2">(*</span><span class="s1">tuples</span><span class="s2">)</span>

    <span class="s1">first </span><span class="s2">= </span><span class="s1">arrays</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
    <span class="s1">shape </span><span class="s2">= (</span><span class="s1">len</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">),) + </span><span class="s1">first</span><span class="s2">.</span><span class="s1">shape</span>

    <span class="s1">stacked </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">arr </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">):</span>
        <span class="s1">stacked</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">arr</span>

    <span class="s0">return </span><span class="s1">stacked</span><span class="s2">, </span><span class="s1">placement</span>


<span class="s0">def </span><span class="s1">_consolidate</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">: </span><span class="s1">tuple</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">, ...]) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">, ...]:</span>
    <span class="s3">&quot;&quot;&quot; 
    Merge blocks having same dtype, exclude non-consolidating blocks 
    &quot;&quot;&quot;</span>
    <span class="s4"># sort by _can_consolidate, dtype</span>
    <span class="s1">gkey </span><span class="s2">= </span><span class="s0">lambda </span><span class="s1">x</span><span class="s2">: </span><span class="s1">x</span><span class="s2">.</span><span class="s1">_consolidate_key</span>
    <span class="s1">grouper </span><span class="s2">= </span><span class="s1">itertools</span><span class="s2">.</span><span class="s1">groupby</span><span class="s2">(</span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">, </span><span class="s1">key</span><span class="s2">=</span><span class="s1">gkey</span><span class="s2">), </span><span class="s1">gkey</span><span class="s2">)</span>

    <span class="s1">new_blocks</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">] = []</span>
    <span class="s0">for </span><span class="s2">(</span><span class="s1">_can_consolidate</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">), </span><span class="s1">group_blocks </span><span class="s0">in </span><span class="s1">grouper</span><span class="s2">:</span>
        <span class="s1">merged_blocks</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_merge_blocks</span><span class="s2">(</span>
            <span class="s1">list</span><span class="s2">(</span><span class="s1">group_blocks</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">can_consolidate</span><span class="s2">=</span><span class="s1">_can_consolidate</span>
        <span class="s2">)</span>
        <span class="s1">new_blocks </span><span class="s2">= </span><span class="s1">extend_blocks</span><span class="s2">(</span><span class="s1">merged_blocks</span><span class="s2">, </span><span class="s1">new_blocks</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">new_blocks</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_merge_blocks</span><span class="s2">(</span>
    <span class="s1">blocks</span><span class="s2">: </span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">DtypeObj</span><span class="s2">, </span><span class="s1">can_consolidate</span><span class="s2">: </span><span class="s1">bool</span>
<span class="s2">) </span><span class="s1">-&gt; tuple</span><span class="s2">[</span><span class="s1">list</span><span class="s2">[</span><span class="s1">Block</span><span class="s2">], </span><span class="s1">bool</span><span class="s2">]:</span>
    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">) == </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">blocks</span><span class="s2">, </span><span class="s0">False</span>

    <span class="s0">if </span><span class="s1">can_consolidate</span><span class="s2">:</span>
        <span class="s4"># TODO: optimization potential in case all mgrs contain slices and</span>
        <span class="s4"># combination of those slices is a slice, too.</span>
        <span class="s1">new_mgr_locs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">([</span><span class="s1">b</span><span class="s2">.</span><span class="s1">mgr_locs</span><span class="s2">.</span><span class="s1">as_array </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">blocks</span><span class="s2">])</span>

        <span class="s1">new_values</span><span class="s2">: </span><span class="s1">ArrayLike</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">blocks</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">):</span>
            <span class="s4"># error: List comprehension has incompatible type List[Union[ndarray,</span>
            <span class="s4"># ExtensionArray]]; expected List[Union[complex, generic,</span>
            <span class="s4"># Sequence[Union[int, float, complex, str, bytes, generic]],</span>
            <span class="s4"># Sequence[Sequence[Any]], SupportsArray]]</span>
            <span class="s1">new_values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">vstack</span><span class="s2">([</span><span class="s1">b</span><span class="s2">.</span><span class="s1">values </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">blocks</span><span class="s2">])  </span><span class="s4"># type: ignore[misc]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">bvals </span><span class="s2">= [</span><span class="s1">blk</span><span class="s2">.</span><span class="s1">values </span><span class="s0">for </span><span class="s1">blk </span><span class="s0">in </span><span class="s1">blocks</span><span class="s2">]</span>
            <span class="s1">bvals2 </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">Sequence</span><span class="s2">[</span><span class="s1">NDArrayBackedExtensionArray</span><span class="s2">], </span><span class="s1">bvals</span><span class="s2">)</span>
            <span class="s1">new_values </span><span class="s2">= </span><span class="s1">bvals2</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">_concat_same_type</span><span class="s2">(</span><span class="s1">bvals2</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">)</span>

        <span class="s1">argsort </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argsort</span><span class="s2">(</span><span class="s1">new_mgr_locs</span><span class="s2">)</span>
        <span class="s1">new_values </span><span class="s2">= </span><span class="s1">new_values</span><span class="s2">[</span><span class="s1">argsort</span><span class="s2">]</span>
        <span class="s1">new_mgr_locs </span><span class="s2">= </span><span class="s1">new_mgr_locs</span><span class="s2">[</span><span class="s1">argsort</span><span class="s2">]</span>

        <span class="s1">bp </span><span class="s2">= </span><span class="s1">BlockPlacement</span><span class="s2">(</span><span class="s1">new_mgr_locs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s1">new_block_2d</span><span class="s2">(</span><span class="s1">new_values</span><span class="s2">, </span><span class="s1">placement</span><span class="s2">=</span><span class="s1">bp</span><span class="s2">)], </span><span class="s0">True</span>

    <span class="s4"># can't consolidate --&gt; no merge</span>
    <span class="s0">return </span><span class="s1">blocks</span><span class="s2">, </span><span class="s0">False</span>


<span class="s0">def </span><span class="s1">_fast_count_smallints</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">: </span><span class="s1">npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">]):</span>
    <span class="s3">&quot;&quot;&quot;Faster version of set(arr) for sequences of small numbers.&quot;&quot;&quot;</span>
    <span class="s1">counts </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">bincount</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">)</span>
    <span class="s1">nz </span><span class="s2">= </span><span class="s1">counts</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">()[</span><span class="s5">0</span><span class="s2">]</span>
    <span class="s4"># Note: list(zip(...) outperforms list(np.c_[nz, counts[nz]]) here,</span>
    <span class="s4">#  in one benchmark by a factor of 11</span>
    <span class="s0">return </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">nz</span><span class="s2">, </span><span class="s1">counts</span><span class="s2">[</span><span class="s1">nz</span><span class="s2">])</span>


<span class="s0">def </span><span class="s1">_preprocess_slice_or_indexer</span><span class="s2">(</span>
    <span class="s1">slice_or_indexer</span><span class="s2">: </span><span class="s1">slice </span><span class="s2">| </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">, </span><span class="s1">length</span><span class="s2">: </span><span class="s1">int</span><span class="s2">, </span><span class="s1">allow_fill</span><span class="s2">: </span><span class="s1">bool</span>
<span class="s2">):</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">slice_or_indexer</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">(</span>
            <span class="s6">&quot;slice&quot;</span><span class="s2">,</span>
            <span class="s1">slice_or_indexer</span><span class="s2">,</span>
            <span class="s1">libinternals</span><span class="s2">.</span><span class="s1">slice_len</span><span class="s2">(</span><span class="s1">slice_or_indexer</span><span class="s2">, </span><span class="s1">length</span><span class="s2">),</span>
        <span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s0">not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">slice_or_indexer</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">)</span>
            <span class="s0">or </span><span class="s1">slice_or_indexer</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">!= </span><span class="s6">&quot;i&quot;</span>
        <span class="s2">):</span>
            <span class="s1">dtype </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">slice_or_indexer</span><span class="s2">, </span><span class="s6">&quot;dtype&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">slice_or_indexer</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s1">indexer </span><span class="s2">= </span><span class="s1">ensure_platform_int</span><span class="s2">(</span><span class="s1">slice_or_indexer</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">allow_fill</span><span class="s2">:</span>
            <span class="s1">indexer </span><span class="s2">= </span><span class="s1">maybe_convert_indices</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">length</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s6">&quot;fancy&quot;</span><span class="s2">, </span><span class="s1">indexer</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">make_na_array</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">DtypeObj</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">: </span><span class="s1">Shape</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">) </span><span class="s1">-&gt; ArrayLike</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype</span><span class="s2">):</span>
        <span class="s4"># NB: exclude e.g. pyarrow[dt64tz] dtypes</span>
        <span class="s1">ts </span><span class="s2">= </span><span class="s1">Timestamp</span><span class="s2">(</span><span class="s1">fill_value</span><span class="s2">).</span><span class="s1">as_unit</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">unit</span><span class="s2">)</span>
        <span class="s1">i8values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">ts</span><span class="s2">.</span><span class="s1">_value</span><span class="s2">)</span>
        <span class="s1">dt64values </span><span class="s2">= </span><span class="s1">i8values</span><span class="s2">.</span><span class="s1">view</span><span class="s2">(</span><span class="s6">f&quot;M8[</span><span class="s0">{</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">unit</span><span class="s0">}</span><span class="s6">]&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">DatetimeArray</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">dt64values</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s0">elif </span><span class="s1">is_1d_only_ea_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">cast</span><span class="s2">(</span><span class="s1">ExtensionDtype</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">cls </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">construct_array_type</span><span class="s2">()</span>

        <span class="s1">missing_arr </span><span class="s2">= </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">_from_sequence</span><span class="s2">([], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">ncols</span><span class="s2">, </span><span class="s1">nrows </span><span class="s2">= </span><span class="s1">shape</span>
        <span class="s0">assert </span><span class="s1">ncols </span><span class="s2">== </span><span class="s5">1</span><span class="s2">, </span><span class="s1">ncols</span>
        <span class="s1">empty_arr </span><span class="s2">= -</span><span class="s5">1 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s1">nrows</span><span class="s2">,), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">missing_arr</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span><span class="s1">empty_arr</span><span class="s2">, </span><span class="s1">allow_fill</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">=</span><span class="s1">fill_value</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">ExtensionDtype</span><span class="s2">):</span>
        <span class="s4"># TODO: no tests get here, a handful would if we disabled</span>
        <span class="s4">#  the dt64tz special-case above (which is faster)</span>
        <span class="s1">cls </span><span class="s2">= </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">construct_array_type</span><span class="s2">()</span>
        <span class="s1">missing_arr </span><span class="s2">= </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">_empty</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">=</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">missing_arr</span><span class="s2">[:] = </span><span class="s1">fill_value</span>
        <span class="s0">return </span><span class="s1">missing_arr</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s4"># NB: we should never get here with dtype integer or bool;</span>
        <span class="s4">#  if we did, the missing_arr.fill would cast to gibberish</span>
        <span class="s1">missing_arr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">missing_arr</span><span class="s2">.</span><span class="s1">fill</span><span class="s2">(</span><span class="s1">fill_value</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">in </span><span class="s6">&quot;mM&quot;</span><span class="s2">:</span>
            <span class="s1">missing_arr </span><span class="s2">= </span><span class="s1">ensure_wrapped_if_datetimelike</span><span class="s2">(</span><span class="s1">missing_arr</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">missing_arr</span>
</pre>
</body>
</html>