<html>
<head>
<title>base.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
base.py</font>
</center></td></tr></table>
<pre><span class="s0"># dialects/postgresql/base.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>
<span class="s0"># mypy: ignore-errors</span>

<span class="s2">r&quot;&quot;&quot; 
.. dialect:: postgresql 
    :name: PostgreSQL 
    :full_support: 12, 13, 14, 15 
    :normal_support: 9.6+ 
    :best_effort: 9+ 
 
.. _postgresql_sequences: 
 
Sequences/SERIAL/IDENTITY 
------------------------- 
 
PostgreSQL supports sequences, and SQLAlchemy uses these as the default means 
of creating new primary key values for integer-based primary key columns. When 
creating tables, SQLAlchemy will issue the ``SERIAL`` datatype for 
integer-based primary key columns, which generates a sequence and server side 
default corresponding to the column. 
 
To specify a specific named sequence to be used for primary key generation, 
use the :func:`~sqlalchemy.schema.Sequence` construct:: 
 
    Table( 
        &quot;sometable&quot;, 
        metadata, 
        Column( 
            &quot;id&quot;, Integer, Sequence(&quot;some_id_seq&quot;, start=1), primary_key=True 
        ) 
    ) 
 
When SQLAlchemy issues a single INSERT statement, to fulfill the contract of 
having the &quot;last insert identifier&quot; available, a RETURNING clause is added to 
the INSERT statement which specifies the primary key columns should be 
returned after the statement completes. The RETURNING functionality only takes 
place if PostgreSQL 8.2 or later is in use. As a fallback approach, the 
sequence, whether specified explicitly or implicitly via ``SERIAL``, is 
executed independently beforehand, the returned value to be used in the 
subsequent insert. Note that when an 
:func:`~sqlalchemy.sql.expression.insert()` construct is executed using 
&quot;executemany&quot; semantics, the &quot;last inserted identifier&quot; functionality does not 
apply; no RETURNING clause is emitted nor is the sequence pre-executed in this 
case. 
 
 
PostgreSQL 10 and above IDENTITY columns 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
 
PostgreSQL 10 and above have a new IDENTITY feature that supersedes the use 
of SERIAL. The :class:`_schema.Identity` construct in a 
:class:`_schema.Column` can be used to control its behavior:: 
 
    from sqlalchemy import Table, Column, MetaData, Integer, Computed 
 
    metadata = MetaData() 
 
    data = Table( 
        &quot;data&quot;, 
        metadata, 
        Column( 
            'id', Integer, Identity(start=42, cycle=True), primary_key=True 
        ), 
        Column('data', String) 
    ) 
 
The CREATE TABLE for the above :class:`_schema.Table` object would be: 
 
.. sourcecode:: sql 
 
    CREATE TABLE data ( 
        id INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 42 CYCLE), 
        data VARCHAR, 
        PRIMARY KEY (id) 
    ) 
 
.. versionchanged::  1.4   Added :class:`_schema.Identity` construct 
   in a :class:`_schema.Column` to specify the option of an autoincrementing 
   column. 
 
.. note:: 
 
   Previous versions of SQLAlchemy did not have built-in support for rendering 
   of IDENTITY, and could use the following compilation hook to replace 
   occurrences of SERIAL with IDENTITY:: 
 
       from sqlalchemy.schema import CreateColumn 
       from sqlalchemy.ext.compiler import compiles 
 
 
       @compiles(CreateColumn, 'postgresql') 
       def use_identity(element, compiler, **kw): 
           text = compiler.visit_create_column(element, **kw) 
           text = text.replace( 
               &quot;SERIAL&quot;, &quot;INT GENERATED BY DEFAULT AS IDENTITY&quot; 
            ) 
           return text 
 
   Using the above, a table such as:: 
 
       t = Table( 
           't', m, 
           Column('id', Integer, primary_key=True), 
           Column('data', String) 
       ) 
 
   Will generate on the backing database as:: 
 
       CREATE TABLE t ( 
           id INT GENERATED BY DEFAULT AS IDENTITY, 
           data VARCHAR, 
           PRIMARY KEY (id) 
       ) 
 
.. _postgresql_ss_cursors: 
 
Server Side Cursors 
------------------- 
 
Server-side cursor support is available for the psycopg2, asyncpg 
dialects and may also be available in others. 
 
Server side cursors are enabled on a per-statement basis by using the 
:paramref:`.Connection.execution_options.stream_results` connection execution 
option:: 
 
    with engine.connect() as conn: 
        result = conn.execution_options(stream_results=True).execute(text(&quot;select * from table&quot;)) 
 
Note that some kinds of SQL statements may not be supported with 
server side cursors; generally, only SQL statements that return rows should be 
used with this option. 
 
.. deprecated:: 1.4  The dialect-level server_side_cursors flag is deprecated 
   and will be removed in a future release.  Please use the 
   :paramref:`_engine.Connection.stream_results` execution option for 
   unbuffered cursor support. 
 
.. seealso:: 
 
    :ref:`engine_stream_results` 
 
.. _postgresql_isolation_level: 
 
Transaction Isolation Level 
--------------------------- 
 
Most SQLAlchemy dialects support setting of transaction isolation level 
using the :paramref:`_sa.create_engine.isolation_level` parameter 
at the :func:`_sa.create_engine` level, and at the :class:`_engine.Connection` 
level via the :paramref:`.Connection.execution_options.isolation_level` 
parameter. 
 
For PostgreSQL dialects, this feature works either by making use of the 
DBAPI-specific features, such as psycopg2's isolation level flags which will 
embed the isolation level setting inline with the ``&quot;BEGIN&quot;`` statement, or for 
DBAPIs with no direct support by emitting ``SET SESSION CHARACTERISTICS AS 
TRANSACTION ISOLATION LEVEL &lt;level&gt;`` ahead of the ``&quot;BEGIN&quot;`` statement 
emitted by the DBAPI.   For the special AUTOCOMMIT isolation level, 
DBAPI-specific techniques are used which is typically an ``.autocommit`` 
flag on the DBAPI connection object. 
 
To set isolation level using :func:`_sa.create_engine`:: 
 
    engine = create_engine( 
        &quot;postgresql+pg8000://scott:tiger@localhost/test&quot;, 
        isolation_level = &quot;REPEATABLE READ&quot; 
    ) 
 
To set using per-connection execution options:: 
 
    with engine.connect() as conn: 
        conn = conn.execution_options( 
            isolation_level=&quot;REPEATABLE READ&quot; 
        ) 
        with conn.begin(): 
            # ... work with transaction 
 
There are also more options for isolation level configurations, such as 
&quot;sub-engine&quot; objects linked to a main :class:`_engine.Engine` which each apply 
different isolation level settings.  See the discussion at 
:ref:`dbapi_autocommit` for background. 
 
Valid values for ``isolation_level`` on most PostgreSQL dialects include: 
 
* ``READ COMMITTED`` 
* ``READ UNCOMMITTED`` 
* ``REPEATABLE READ`` 
* ``SERIALIZABLE`` 
* ``AUTOCOMMIT`` 
 
.. seealso:: 
 
    :ref:`dbapi_autocommit` 
 
    :ref:`postgresql_readonly_deferrable` 
 
    :ref:`psycopg2_isolation_level` 
 
    :ref:`pg8000_isolation_level` 
 
.. _postgresql_readonly_deferrable: 
 
Setting READ ONLY / DEFERRABLE 
------------------------------ 
 
Most PostgreSQL dialects support setting the &quot;READ ONLY&quot; and &quot;DEFERRABLE&quot; 
characteristics of the transaction, which is in addition to the isolation level 
setting. These two attributes can be established either in conjunction with or 
independently of the isolation level by passing the ``postgresql_readonly`` and 
``postgresql_deferrable`` flags with 
:meth:`_engine.Connection.execution_options`.  The example below illustrates 
passing the ``&quot;SERIALIZABLE&quot;`` isolation level at the same time as setting 
&quot;READ ONLY&quot; and &quot;DEFERRABLE&quot;:: 
 
    with engine.connect() as conn: 
        conn = conn.execution_options( 
            isolation_level=&quot;SERIALIZABLE&quot;, 
            postgresql_readonly=True, 
            postgresql_deferrable=True 
        ) 
        with conn.begin(): 
            #  ... work with transaction 
 
Note that some DBAPIs such as asyncpg only support &quot;readonly&quot; with 
SERIALIZABLE isolation. 
 
.. versionadded:: 1.4 added support for the ``postgresql_readonly`` 
   and ``postgresql_deferrable`` execution options. 
 
.. _postgresql_reset_on_return: 
 
Temporary Table / Resource Reset for Connection Pooling 
------------------------------------------------------- 
 
The :class:`.QueuePool` connection pool implementation used 
by the SQLAlchemy :class:`.Engine` object includes 
:ref:`reset on return &lt;pool_reset_on_return&gt;` behavior that will invoke 
the DBAPI ``.rollback()`` method when connections are returned to the pool. 
While this rollback will clear out the immediate state used by the previous 
transaction, it does not cover a wider range of session-level state, including 
temporary tables as well as other server state such as prepared statement 
handles and statement caches.   The PostgreSQL database includes a variety 
of commands which may be used to reset this state, including 
``DISCARD``, ``RESET``, ``DEALLOCATE``, and ``UNLISTEN``. 
 
 
To install 
one or more of these commands as the means of performing reset-on-return, 
the :meth:`.PoolEvents.reset` event hook may be used, as demonstrated 
in the example below. The implementation 
will end transactions in progress as well as discard temporary tables 
using the ``CLOSE``, ``RESET`` and ``DISCARD`` commands; see the PostgreSQL 
documentation for background on what each of these statements do. 
 
The :paramref:`_sa.create_engine.pool_reset_on_return` parameter 
is set to ``None`` so that the custom scheme can replace the default behavior 
completely.   The custom hook implementation calls ``.rollback()`` in any case, 
as it's usually important that the DBAPI's own tracking of commit/rollback 
will remain consistent with the state of the transaction:: 
 
 
    from sqlalchemy import create_engine 
    from sqlalchemy import event 
 
    postgresql_engine = create_engine( 
        &quot;postgresql+pyscopg2://scott:tiger@hostname/dbname&quot;, 
 
        # disable default reset-on-return scheme 
        pool_reset_on_return=None, 
    ) 
 
 
    @event.listens_for(postgresql_engine, &quot;reset&quot;) 
    def _reset_postgresql(dbapi_connection, connection_record, reset_state): 
        if not reset_state.terminate_only: 
            dbapi_connection.execute(&quot;CLOSE ALL&quot;) 
            dbapi_connection.execute(&quot;RESET ALL&quot;) 
            dbapi_connection.execute(&quot;DISCARD TEMP&quot;) 
 
        # so that the DBAPI itself knows that the connection has been 
        # reset 
        dbapi_connection.rollback() 
 
.. versionchanged:: 2.0.0b3  Added additional state arguments to 
   the :meth:`.PoolEvents.reset` event and additionally ensured the event 
   is invoked for all &quot;reset&quot; occurrences, so that it's appropriate 
   as a place for custom &quot;reset&quot; handlers.   Previous schemes which 
   use the :meth:`.PoolEvents.checkin` handler remain usable as well. 
 
.. seealso:: 
 
    :ref:`pool_reset_on_return` - in the :ref:`pooling_toplevel` documentation 
 
.. _postgresql_alternate_search_path: 
 
Setting Alternate Search Paths on Connect 
------------------------------------------ 
 
The PostgreSQL ``search_path`` variable refers to the list of schema names 
that will be implicitly referenced when a particular table or other 
object is referenced in a SQL statement.  As detailed in the next section 
:ref:`postgresql_schema_reflection`, SQLAlchemy is generally organized around 
the concept of keeping this variable at its default value of ``public``, 
however, in order to have it set to any arbitrary name or names when connections 
are used automatically, the &quot;SET SESSION search_path&quot; command may be invoked 
for all connections in a pool using the following event handler, as discussed 
at :ref:`schema_set_default_connections`:: 
 
    from sqlalchemy import event 
    from sqlalchemy import create_engine 
 
    engine = create_engine(&quot;postgresql+psycopg2://scott:tiger@host/dbname&quot;) 
 
    @event.listens_for(engine, &quot;connect&quot;, insert=True) 
    def set_search_path(dbapi_connection, connection_record): 
        existing_autocommit = dbapi_connection.autocommit 
        dbapi_connection.autocommit = True 
        cursor = dbapi_connection.cursor() 
        cursor.execute(&quot;SET SESSION search_path='%s'&quot; % schema_name) 
        cursor.close() 
        dbapi_connection.autocommit = existing_autocommit 
 
The reason the recipe is complicated by use of the ``.autocommit`` DBAPI 
attribute is so that when the ``SET SESSION search_path`` directive is invoked, 
it is invoked outside of the scope of any transaction and therefore will not 
be reverted when the DBAPI connection has a rollback. 
 
.. seealso:: 
 
  :ref:`schema_set_default_connections` - in the :ref:`metadata_toplevel` documentation 
 
 
 
 
.. _postgresql_schema_reflection: 
 
Remote-Schema Table Introspection and PostgreSQL search_path 
------------------------------------------------------------ 
 
.. admonition:: Section Best Practices Summarized 
 
    keep the ``search_path`` variable set to its default of ``public``, without 
    any other schema names. Ensure the username used to connect **does not** 
    match remote schemas, or ensure the ``&quot;$user&quot;`` token is **removed** from 
    ``search_path``.  For other schema names, name these explicitly 
    within :class:`_schema.Table` definitions. Alternatively, the 
    ``postgresql_ignore_search_path`` option will cause all reflected 
    :class:`_schema.Table` objects to have a :attr:`_schema.Table.schema` 
    attribute set up. 
 
The PostgreSQL dialect can reflect tables from any schema, as outlined in 
:ref:`metadata_reflection_schemas`. 
 
In all cases, the first thing SQLAlchemy does when reflecting tables is 
to **determine the default schema for the current database connection**. 
It does this using the PostgreSQL ``current_schema()`` 
function, illustated below using a PostgreSQL client session (i.e. using 
the ``psql`` tool):: 
 
    test=&gt; select current_schema(); 
    current_schema 
    ---------------- 
    public 
    (1 row) 
 
Above we see that on a plain install of PostgreSQL, the default schema name 
is the name ``public``. 
 
However, if your database username **matches the name of a schema**, PostgreSQL's 
default is to then **use that name as the default schema**.  Below, we log in 
using the username ``scott``.  When we create a schema named ``scott``, **it 
implicitly changes the default schema**:: 
 
    test=&gt; select current_schema(); 
    current_schema 
    ---------------- 
    public 
    (1 row) 
 
    test=&gt; create schema scott; 
    CREATE SCHEMA 
    test=&gt; select current_schema(); 
    current_schema 
    ---------------- 
    scott 
    (1 row) 
 
The behavior of ``current_schema()`` is derived from the 
`PostgreSQL search path 
&lt;https://www.postgresql.org/docs/current/static/ddl-schemas.html#DDL-SCHEMAS-PATH&gt;`_ 
variable ``search_path``, which in modern PostgreSQL versions defaults to this:: 
 
    test=&gt; show search_path; 
    search_path 
    ----------------- 
    &quot;$user&quot;, public 
    (1 row) 
 
Where above, the ``&quot;$user&quot;`` variable will inject the current username as the 
default schema, if one exists.   Otherwise, ``public`` is used. 
 
When a :class:`_schema.Table` object is reflected, if it is present in the 
schema indicated by the ``current_schema()`` function, **the schema name assigned 
to the &quot;.schema&quot; attribute of the Table is the Python &quot;None&quot; value**.  Otherwise, the 
&quot;.schema&quot; attribute will be assigned the string name of that schema. 
 
With regards to tables which these :class:`_schema.Table` 
objects refer to via foreign key constraint, a decision must be made as to how 
the ``.schema`` is represented in those remote tables, in the case where that 
remote schema name is also a member of the current ``search_path``. 
 
By default, the PostgreSQL dialect mimics the behavior encouraged by 
PostgreSQL's own ``pg_get_constraintdef()`` builtin procedure.  This function 
returns a sample definition for a particular foreign key constraint, 
omitting the referenced schema name from that definition when the name is 
also in the PostgreSQL schema search path.  The interaction below 
illustrates this behavior:: 
 
    test=&gt; CREATE TABLE test_schema.referred(id INTEGER PRIMARY KEY); 
    CREATE TABLE 
    test=&gt; CREATE TABLE referring( 
    test(&gt;         id INTEGER PRIMARY KEY, 
    test(&gt;         referred_id INTEGER REFERENCES test_schema.referred(id)); 
    CREATE TABLE 
    test=&gt; SET search_path TO public, test_schema; 
    test=&gt; SELECT pg_catalog.pg_get_constraintdef(r.oid, true) FROM 
    test-&gt; pg_catalog.pg_class c JOIN pg_catalog.pg_namespace n 
    test-&gt; ON n.oid = c.relnamespace 
    test-&gt; JOIN pg_catalog.pg_constraint r  ON c.oid = r.conrelid 
    test-&gt; WHERE c.relname='referring' AND r.contype = 'f' 
    test-&gt; ; 
                   pg_get_constraintdef 
    --------------------------------------------------- 
     FOREIGN KEY (referred_id) REFERENCES referred(id) 
    (1 row) 
 
Above, we created a table ``referred`` as a member of the remote schema 
``test_schema``, however when we added ``test_schema`` to the 
PG ``search_path`` and then asked ``pg_get_constraintdef()`` for the 
``FOREIGN KEY`` syntax, ``test_schema`` was not included in the output of 
the function. 
 
On the other hand, if we set the search path back to the typical default 
of ``public``:: 
 
    test=&gt; SET search_path TO public; 
    SET 
 
The same query against ``pg_get_constraintdef()`` now returns the fully 
schema-qualified name for us:: 
 
    test=&gt; SELECT pg_catalog.pg_get_constraintdef(r.oid, true) FROM 
    test-&gt; pg_catalog.pg_class c JOIN pg_catalog.pg_namespace n 
    test-&gt; ON n.oid = c.relnamespace 
    test-&gt; JOIN pg_catalog.pg_constraint r  ON c.oid = r.conrelid 
    test-&gt; WHERE c.relname='referring' AND r.contype = 'f'; 
                         pg_get_constraintdef 
    --------------------------------------------------------------- 
     FOREIGN KEY (referred_id) REFERENCES test_schema.referred(id) 
    (1 row) 
 
SQLAlchemy will by default use the return value of ``pg_get_constraintdef()`` 
in order to determine the remote schema name.  That is, if our ``search_path`` 
were set to include ``test_schema``, and we invoked a table 
reflection process as follows:: 
 
    &gt;&gt;&gt; from sqlalchemy import Table, MetaData, create_engine, text 
    &gt;&gt;&gt; engine = create_engine(&quot;postgresql+psycopg2://scott:tiger@localhost/test&quot;) 
    &gt;&gt;&gt; with engine.connect() as conn: 
    ...     conn.execute(text(&quot;SET search_path TO test_schema, public&quot;)) 
    ...     metadata_obj = MetaData() 
    ...     referring = Table('referring', metadata_obj, 
    ...                       autoload_with=conn) 
    ... 
    &lt;sqlalchemy.engine.result.CursorResult object at 0x101612ed0&gt; 
 
The above process would deliver to the :attr:`_schema.MetaData.tables` 
collection 
``referred`` table named **without** the schema:: 
 
    &gt;&gt;&gt; metadata_obj.tables['referred'].schema is None 
    True 
 
To alter the behavior of reflection such that the referred schema is 
maintained regardless of the ``search_path`` setting, use the 
``postgresql_ignore_search_path`` option, which can be specified as a 
dialect-specific argument to both :class:`_schema.Table` as well as 
:meth:`_schema.MetaData.reflect`:: 
 
    &gt;&gt;&gt; with engine.connect() as conn: 
    ...     conn.execute(text(&quot;SET search_path TO test_schema, public&quot;)) 
    ...     metadata_obj = MetaData() 
    ...     referring = Table('referring', metadata_obj, 
    ...                       autoload_with=conn, 
    ...                       postgresql_ignore_search_path=True) 
    ... 
    &lt;sqlalchemy.engine.result.CursorResult object at 0x1016126d0&gt; 
 
We will now have ``test_schema.referred`` stored as schema-qualified:: 
 
    &gt;&gt;&gt; metadata_obj.tables['test_schema.referred'].schema 
    'test_schema' 
 
.. sidebar:: Best Practices for PostgreSQL Schema reflection 
 
    The description of PostgreSQL schema reflection behavior is complex, and 
    is the product of many years of dealing with widely varied use cases and 
    user preferences. But in fact, there's no need to understand any of it if 
    you just stick to the simplest use pattern: leave the ``search_path`` set 
    to its default of ``public`` only, never refer to the name ``public`` as 
    an explicit schema name otherwise, and refer to all other schema names 
    explicitly when building up a :class:`_schema.Table` object.  The options 
    described here are only for those users who can't, or prefer not to, stay 
    within these guidelines. 
 
.. seealso:: 
 
    :ref:`reflection_schema_qualified_interaction` - discussion of the issue 
    from a backend-agnostic perspective 
 
    `The Schema Search Path 
    &lt;https://www.postgresql.org/docs/current/static/ddl-schemas.html#DDL-SCHEMAS-PATH&gt;`_ 
    - on the PostgreSQL website. 
 
INSERT/UPDATE...RETURNING 
------------------------- 
 
The dialect supports PG 8.2's ``INSERT..RETURNING``, ``UPDATE..RETURNING`` and 
``DELETE..RETURNING`` syntaxes.   ``INSERT..RETURNING`` is used by default 
for single-row INSERT statements in order to fetch newly generated 
primary key identifiers.   To specify an explicit ``RETURNING`` clause, 
use the :meth:`._UpdateBase.returning` method on a per-statement basis:: 
 
    # INSERT..RETURNING 
    result = table.insert().returning(table.c.col1, table.c.col2).\ 
        values(name='foo') 
    print(result.fetchall()) 
 
    # UPDATE..RETURNING 
    result = table.update().returning(table.c.col1, table.c.col2).\ 
        where(table.c.name=='foo').values(name='bar') 
    print(result.fetchall()) 
 
    # DELETE..RETURNING 
    result = table.delete().returning(table.c.col1, table.c.col2).\ 
        where(table.c.name=='foo') 
    print(result.fetchall()) 
 
.. _postgresql_insert_on_conflict: 
 
INSERT...ON CONFLICT (Upsert) 
------------------------------ 
 
Starting with version 9.5, PostgreSQL allows &quot;upserts&quot; (update or insert) of 
rows into a table via the ``ON CONFLICT`` clause of the ``INSERT`` statement. A 
candidate row will only be inserted if that row does not violate any unique 
constraints.  In the case of a unique constraint violation, a secondary action 
can occur which can be either &quot;DO UPDATE&quot;, indicating that the data in the 
target row should be updated, or &quot;DO NOTHING&quot;, which indicates to silently skip 
this row. 
 
Conflicts are determined using existing unique constraints and indexes.  These 
constraints may be identified either using their name as stated in DDL, 
or they may be inferred by stating the columns and conditions that comprise 
the indexes. 
 
SQLAlchemy provides ``ON CONFLICT`` support via the PostgreSQL-specific 
:func:`_postgresql.insert()` function, which provides 
the generative methods :meth:`_postgresql.Insert.on_conflict_do_update` 
and :meth:`~.postgresql.Insert.on_conflict_do_nothing`: 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; from sqlalchemy.dialects.postgresql import insert 
    &gt;&gt;&gt; insert_stmt = insert(my_table).values( 
    ...     id='some_existing_id', 
    ...     data='inserted value') 
    &gt;&gt;&gt; do_nothing_stmt = insert_stmt.on_conflict_do_nothing( 
    ...     index_elements=['id'] 
    ... ) 
    &gt;&gt;&gt; print(do_nothing_stmt) 
    {printsql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s) 
    ON CONFLICT (id) DO NOTHING 
    {stop} 
 
    &gt;&gt;&gt; do_update_stmt = insert_stmt.on_conflict_do_update( 
    ...     constraint='pk_my_table', 
    ...     set_=dict(data='updated value') 
    ... ) 
    &gt;&gt;&gt; print(do_update_stmt) 
    {printsql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s) 
    ON CONFLICT ON CONSTRAINT pk_my_table DO UPDATE SET data = %(param_1)s 
 
.. seealso:: 
 
    `INSERT .. ON CONFLICT 
    &lt;https://www.postgresql.org/docs/current/static/sql-insert.html#SQL-ON-CONFLICT&gt;`_ 
    - in the PostgreSQL documentation. 
 
Specifying the Target 
^^^^^^^^^^^^^^^^^^^^^ 
 
Both methods supply the &quot;target&quot; of the conflict using either the 
named constraint or by column inference: 
 
* The :paramref:`_postgresql.Insert.on_conflict_do_update.index_elements` argument 
  specifies a sequence containing string column names, :class:`_schema.Column` 
  objects, and/or SQL expression elements, which would identify a unique 
  index: 
 
  .. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; do_update_stmt = insert_stmt.on_conflict_do_update( 
    ...     index_elements=['id'], 
    ...     set_=dict(data='updated value') 
    ... ) 
    &gt;&gt;&gt; print(do_update_stmt) 
    {printsql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s) 
    ON CONFLICT (id) DO UPDATE SET data = %(param_1)s 
    {stop} 
 
    &gt;&gt;&gt; do_update_stmt = insert_stmt.on_conflict_do_update( 
    ...     index_elements=[my_table.c.id], 
    ...     set_=dict(data='updated value') 
    ... ) 
    &gt;&gt;&gt; print(do_update_stmt) 
    {printsql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s) 
    ON CONFLICT (id) DO UPDATE SET data = %(param_1)s 
 
* When using :paramref:`_postgresql.Insert.on_conflict_do_update.index_elements` to 
  infer an index, a partial index can be inferred by also specifying the 
  use the :paramref:`_postgresql.Insert.on_conflict_do_update.index_where` parameter: 
 
  .. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; stmt = insert(my_table).values(user_email='a@b.com', data='inserted data') 
    &gt;&gt;&gt; stmt = stmt.on_conflict_do_update( 
    ...     index_elements=[my_table.c.user_email], 
    ...     index_where=my_table.c.user_email.like('%@gmail.com'), 
    ...     set_=dict(data=stmt.excluded.data) 
    ... ) 
    &gt;&gt;&gt; print(stmt) 
    {printsql}INSERT INTO my_table (data, user_email) 
    VALUES (%(data)s, %(user_email)s) ON CONFLICT (user_email) 
    WHERE user_email LIKE %(user_email_1)s DO UPDATE SET data = excluded.data 
 
* The :paramref:`_postgresql.Insert.on_conflict_do_update.constraint` argument is 
  used to specify an index directly rather than inferring it.  This can be 
  the name of a UNIQUE constraint, a PRIMARY KEY constraint, or an INDEX: 
 
  .. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; do_update_stmt = insert_stmt.on_conflict_do_update( 
    ...     constraint='my_table_idx_1', 
    ...     set_=dict(data='updated value') 
    ... ) 
    &gt;&gt;&gt; print(do_update_stmt) 
    {printsql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s) 
    ON CONFLICT ON CONSTRAINT my_table_idx_1 DO UPDATE SET data = %(param_1)s 
    {stop} 
 
    &gt;&gt;&gt; do_update_stmt = insert_stmt.on_conflict_do_update( 
    ...     constraint='my_table_pk', 
    ...     set_=dict(data='updated value') 
    ... ) 
    &gt;&gt;&gt; print(do_update_stmt) 
    {printsql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s) 
    ON CONFLICT ON CONSTRAINT my_table_pk DO UPDATE SET data = %(param_1)s 
    {stop} 
 
* The :paramref:`_postgresql.Insert.on_conflict_do_update.constraint` argument may 
  also refer to a SQLAlchemy construct representing a constraint, 
  e.g. :class:`.UniqueConstraint`, :class:`.PrimaryKeyConstraint`, 
  :class:`.Index`, or :class:`.ExcludeConstraint`.   In this use, 
  if the constraint has a name, it is used directly.  Otherwise, if the 
  constraint is unnamed, then inference will be used, where the expressions 
  and optional WHERE clause of the constraint will be spelled out in the 
  construct.  This use is especially convenient 
  to refer to the named or unnamed primary key of a :class:`_schema.Table` 
  using the 
  :attr:`_schema.Table.primary_key` attribute: 
 
  .. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; do_update_stmt = insert_stmt.on_conflict_do_update( 
    ...     constraint=my_table.primary_key, 
    ...     set_=dict(data='updated value') 
    ... ) 
    &gt;&gt;&gt; print(do_update_stmt) 
    {printsql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s) 
    ON CONFLICT (id) DO UPDATE SET data = %(param_1)s 
 
The SET Clause 
^^^^^^^^^^^^^^^ 
 
``ON CONFLICT...DO UPDATE`` is used to perform an update of the already 
existing row, using any combination of new values as well as values 
from the proposed insertion.   These values are specified using the 
:paramref:`_postgresql.Insert.on_conflict_do_update.set_` parameter.  This 
parameter accepts a dictionary which consists of direct values 
for UPDATE: 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; stmt = insert(my_table).values(id='some_id', data='inserted value') 
    &gt;&gt;&gt; do_update_stmt = stmt.on_conflict_do_update( 
    ...     index_elements=['id'], 
    ...     set_=dict(data='updated value') 
    ... ) 
    &gt;&gt;&gt; print(do_update_stmt) 
    {printsql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s) 
    ON CONFLICT (id) DO UPDATE SET data = %(param_1)s 
 
.. warning:: 
 
    The :meth:`_expression.Insert.on_conflict_do_update` 
    method does **not** take into 
    account Python-side default UPDATE values or generation functions, e.g. 
    those specified using :paramref:`_schema.Column.onupdate`. 
    These values will not be exercised for an ON CONFLICT style of UPDATE, 
    unless they are manually specified in the 
    :paramref:`_postgresql.Insert.on_conflict_do_update.set_` dictionary. 
 
Updating using the Excluded INSERT Values 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
 
In order to refer to the proposed insertion row, the special alias 
:attr:`~.postgresql.Insert.excluded` is available as an attribute on 
the :class:`_postgresql.Insert` object; this object is a 
:class:`_expression.ColumnCollection` 
which alias contains all columns of the target 
table: 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; stmt = insert(my_table).values( 
    ...     id='some_id', 
    ...     data='inserted value', 
    ...     author='jlh' 
    ... ) 
    &gt;&gt;&gt; do_update_stmt = stmt.on_conflict_do_update( 
    ...     index_elements=['id'], 
    ...     set_=dict(data='updated value', author=stmt.excluded.author) 
    ... ) 
    &gt;&gt;&gt; print(do_update_stmt) 
    {printsql}INSERT INTO my_table (id, data, author) 
    VALUES (%(id)s, %(data)s, %(author)s) 
    ON CONFLICT (id) DO UPDATE SET data = %(param_1)s, author = excluded.author 
 
Additional WHERE Criteria 
^^^^^^^^^^^^^^^^^^^^^^^^^ 
 
The :meth:`_expression.Insert.on_conflict_do_update` method also accepts 
a WHERE clause using the :paramref:`_postgresql.Insert.on_conflict_do_update.where` 
parameter, which will limit those rows which receive an UPDATE: 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; stmt = insert(my_table).values( 
    ...     id='some_id', 
    ...     data='inserted value', 
    ...     author='jlh' 
    ... ) 
    &gt;&gt;&gt; on_update_stmt = stmt.on_conflict_do_update( 
    ...     index_elements=['id'], 
    ...     set_=dict(data='updated value', author=stmt.excluded.author), 
    ...     where=(my_table.c.status == 2) 
    ... ) 
    &gt;&gt;&gt; print(on_update_stmt) 
    {printsql}INSERT INTO my_table (id, data, author) 
    VALUES (%(id)s, %(data)s, %(author)s) 
    ON CONFLICT (id) DO UPDATE SET data = %(param_1)s, author = excluded.author 
    WHERE my_table.status = %(status_1)s 
 
Skipping Rows with DO NOTHING 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
 
``ON CONFLICT`` may be used to skip inserting a row entirely 
if any conflict with a unique or exclusion constraint occurs; below 
this is illustrated using the 
:meth:`~.postgresql.Insert.on_conflict_do_nothing` method: 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; stmt = insert(my_table).values(id='some_id', data='inserted value') 
    &gt;&gt;&gt; stmt = stmt.on_conflict_do_nothing(index_elements=['id']) 
    &gt;&gt;&gt; print(stmt) 
    {printsql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s) 
    ON CONFLICT (id) DO NOTHING 
 
If ``DO NOTHING`` is used without specifying any columns or constraint, 
it has the effect of skipping the INSERT for any unique or exclusion 
constraint violation which occurs: 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; stmt = insert(my_table).values(id='some_id', data='inserted value') 
    &gt;&gt;&gt; stmt = stmt.on_conflict_do_nothing() 
    &gt;&gt;&gt; print(stmt) 
    {printsql}INSERT INTO my_table (id, data) VALUES (%(id)s, %(data)s) 
    ON CONFLICT DO NOTHING 
 
.. _postgresql_match: 
 
Full Text Search 
---------------- 
 
PostgreSQL's full text search system is available through the use of the 
:data:`.func` namespace, combined with the use of custom operators 
via the :meth:`.Operators.bool_op` method.    For simple cases with some 
degree of cross-backend compatibility, the :meth:`.Operators.match` operator 
may also be used. 
 
.. _postgresql_simple_match: 
 
Simple plain text matching with ``match()`` 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
 
The :meth:`.Operators.match` operator provides for cross-compatible simple 
text matching.   For the PostgreSQL backend, it's hardcoded to generate 
an expression using the ``@@`` operator in conjunction with the 
``plainto_tsquery()`` PostgreSQL function. 
 
On the PostgreSQL dialect, an expression like the following:: 
 
    select(sometable.c.text.match(&quot;search string&quot;)) 
 
would emit to the database:: 
 
    SELECT text @@ plainto_tsquery('search string') FROM table 
 
Above, passing a plain string to :meth:`.Operators.match` will automatically 
make use of ``plainto_tsquery()`` to specify the type of tsquery.  This 
establishes basic database cross-compatibility for :meth:`.Operators.match` 
with other backends. 
 
.. versionchanged:: 2.0 The default tsquery generation function used by the 
   PostgreSQL dialect with :meth:`.Operators.match` is ``plainto_tsquery()``. 
 
   To render exactly what was rendered in 1.4, use the following form:: 
 
        from sqlalchemy import func 
 
        select( 
            sometable.c.text.bool_op(&quot;@@&quot;)(func.to_tsquery(&quot;search string&quot;)) 
        ) 
 
   Which would emit:: 
 
        SELECT text @@ to_tsquery('search string') FROM table 
 
Using PostgreSQL full text functions and operators directly 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
 
Text search operations beyond the simple use of :meth:`.Operators.match` 
may make use of the :data:`.func` namespace to generate PostgreSQL full-text 
functions, in combination with :meth:`.Operators.bool_op` to generate 
any boolean operator. 
 
For example, the query:: 
 
    select( 
        func.to_tsquery('cat').bool_op(&quot;@&gt;&quot;)(func.to_tsquery('cat &amp; rat')) 
    ) 
 
would generate: 
 
.. sourcecode:: sql 
 
    SELECT to_tsquery('cat') @&gt; to_tsquery('cat &amp; rat') 
 
 
The :class:`_postgresql.TSVECTOR` type can provide for explicit CAST:: 
 
    from sqlalchemy.dialects.postgresql import TSVECTOR 
    from sqlalchemy import select, cast 
    select(cast(&quot;some text&quot;, TSVECTOR)) 
 
produces a statement equivalent to:: 
 
    SELECT CAST('some text' AS TSVECTOR) AS anon_1 
 
The ``func`` namespace is augmented by the PostgreSQL dialect to set up 
correct argument and return types for most full text search functions. 
These functions are used automatically by the :attr:`_sql.func` namespace 
assuming the ``sqlalchemy.dialects.postgresql`` package has been imported, 
or :func:`_sa.create_engine` has been invoked using a ``postgresql`` 
dialect.  These functions are documented at: 
 
* :class:`_postgresql.to_tsvector` 
* :class:`_postgresql.to_tsquery` 
* :class:`_postgresql.plainto_tsquery` 
* :class:`_postgresql.phraseto_tsquery` 
* :class:`_postgresql.websearch_to_tsquery` 
* :class:`_postgresql.ts_headline` 
 
Specifying the &quot;regconfig&quot; with ``match()`` or custom operators 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
 
PostgreSQL's ``plainto_tsquery()`` function accepts an optional 
&quot;regconfig&quot; argument that is used to instruct PostgreSQL to use a 
particular pre-computed GIN or GiST index in order to perform the search. 
When using :meth:`.Operators.match`, this additional parameter may be 
specified using the ``postgresql_regconfig`` parameter, such as:: 
 
    select(mytable.c.id).where( 
        mytable.c.title.match('somestring', postgresql_regconfig='english') 
    ) 
 
Which would emit:: 
 
    SELECT mytable.id FROM mytable 
    WHERE mytable.title @@ plainto_tsquery('english', 'somestring') 
 
When using other PostgreSQL search functions with :data:`.func`, the 
&quot;regconfig&quot; parameter may be passed directly as the initial argument:: 
 
    select(mytable.c.id).where( 
        func.to_tsvector(&quot;english&quot;, mytable.c.title).bool_op(&quot;@@&quot;)( 
            func.to_tsquery(&quot;english&quot;, &quot;somestring&quot;) 
        ) 
    ) 
 
produces a statement equivalent to:: 
 
    SELECT mytable.id FROM mytable 
    WHERE to_tsvector('english', mytable.title) @@ 
        to_tsquery('english', 'somestring') 
 
It is recommended that you use the ``EXPLAIN ANALYZE...`` tool from 
PostgreSQL to ensure that you are generating queries with SQLAlchemy that 
take full advantage of any indexes you may have created for full text search. 
 
.. seealso:: 
 
    `Full Text Search &lt;https://www.postgresql.org/docs/current/textsearch-controls.html&gt;`_ - in the PostgreSQL documentation 
 
 
FROM ONLY ... 
------------- 
 
The dialect supports PostgreSQL's ONLY keyword for targeting only a particular 
table in an inheritance hierarchy. This can be used to produce the 
``SELECT ... FROM ONLY``, ``UPDATE ONLY ...``, and ``DELETE FROM ONLY ...`` 
syntaxes. It uses SQLAlchemy's hints mechanism:: 
 
    # SELECT ... FROM ONLY ... 
    result = table.select().with_hint(table, 'ONLY', 'postgresql') 
    print(result.fetchall()) 
 
    # UPDATE ONLY ... 
    table.update(values=dict(foo='bar')).with_hint('ONLY', 
                                                   dialect_name='postgresql') 
 
    # DELETE FROM ONLY ... 
    table.delete().with_hint('ONLY', dialect_name='postgresql') 
 
 
.. _postgresql_indexes: 
 
PostgreSQL-Specific Index Options 
--------------------------------- 
 
Several extensions to the :class:`.Index` construct are available, specific 
to the PostgreSQL dialect. 
 
Covering Indexes 
^^^^^^^^^^^^^^^^ 
 
The ``postgresql_include`` option renders INCLUDE(colname) for the given 
string names:: 
 
    Index(&quot;my_index&quot;, table.c.x, postgresql_include=['y']) 
 
would render the index as ``CREATE INDEX my_index ON table (x) INCLUDE (y)`` 
 
Note that this feature requires PostgreSQL 11 or later. 
 
.. versionadded:: 1.4 
 
.. _postgresql_partial_indexes: 
 
Partial Indexes 
^^^^^^^^^^^^^^^ 
 
Partial indexes add criterion to the index definition so that the index is 
applied to a subset of rows.   These can be specified on :class:`.Index` 
using the ``postgresql_where`` keyword argument:: 
 
  Index('my_index', my_table.c.id, postgresql_where=my_table.c.value &gt; 10) 
 
.. _postgresql_operator_classes: 
 
Operator Classes 
^^^^^^^^^^^^^^^^ 
 
PostgreSQL allows the specification of an *operator class* for each column of 
an index (see 
https://www.postgresql.org/docs/current/interactive/indexes-opclass.html). 
The :class:`.Index` construct allows these to be specified via the 
``postgresql_ops`` keyword argument:: 
 
    Index( 
        'my_index', my_table.c.id, my_table.c.data, 
        postgresql_ops={ 
            'data': 'text_pattern_ops', 
            'id': 'int4_ops' 
        }) 
 
Note that the keys in the ``postgresql_ops`` dictionaries are the 
&quot;key&quot; name of the :class:`_schema.Column`, i.e. the name used to access it from 
the ``.c`` collection of :class:`_schema.Table`, which can be configured to be 
different than the actual name of the column as expressed in the database. 
 
If ``postgresql_ops`` is to be used against a complex SQL expression such 
as a function call, then to apply to the column it must be given a label 
that is identified in the dictionary by name, e.g.:: 
 
    Index( 
        'my_index', my_table.c.id, 
        func.lower(my_table.c.data).label('data_lower'), 
        postgresql_ops={ 
            'data_lower': 'text_pattern_ops', 
            'id': 'int4_ops' 
        }) 
 
Operator classes are also supported by the 
:class:`_postgresql.ExcludeConstraint` construct using the 
:paramref:`_postgresql.ExcludeConstraint.ops` parameter. See that parameter for 
details. 
 
.. versionadded:: 1.3.21 added support for operator classes with 
   :class:`_postgresql.ExcludeConstraint`. 
 
 
Index Types 
^^^^^^^^^^^ 
 
PostgreSQL provides several index types: B-Tree, Hash, GiST, and GIN, as well 
as the ability for users to create their own (see 
https://www.postgresql.org/docs/current/static/indexes-types.html). These can be 
specified on :class:`.Index` using the ``postgresql_using`` keyword argument:: 
 
    Index('my_index', my_table.c.data, postgresql_using='gin') 
 
The value passed to the keyword argument will be simply passed through to the 
underlying CREATE INDEX command, so it *must* be a valid index type for your 
version of PostgreSQL. 
 
.. _postgresql_index_storage: 
 
Index Storage Parameters 
^^^^^^^^^^^^^^^^^^^^^^^^ 
 
PostgreSQL allows storage parameters to be set on indexes. The storage 
parameters available depend on the index method used by the index. Storage 
parameters can be specified on :class:`.Index` using the ``postgresql_with`` 
keyword argument:: 
 
    Index('my_index', my_table.c.data, postgresql_with={&quot;fillfactor&quot;: 50}) 
 
PostgreSQL allows to define the tablespace in which to create the index. 
The tablespace can be specified on :class:`.Index` using the 
``postgresql_tablespace`` keyword argument:: 
 
    Index('my_index', my_table.c.data, postgresql_tablespace='my_tablespace') 
 
Note that the same option is available on :class:`_schema.Table` as well. 
 
.. _postgresql_index_concurrently: 
 
Indexes with CONCURRENTLY 
^^^^^^^^^^^^^^^^^^^^^^^^^ 
 
The PostgreSQL index option CONCURRENTLY is supported by passing the 
flag ``postgresql_concurrently`` to the :class:`.Index` construct:: 
 
    tbl = Table('testtbl', m, Column('data', Integer)) 
 
    idx1 = Index('test_idx1', tbl.c.data, postgresql_concurrently=True) 
 
The above index construct will render DDL for CREATE INDEX, assuming 
PostgreSQL 8.2 or higher is detected or for a connection-less dialect, as:: 
 
    CREATE INDEX CONCURRENTLY test_idx1 ON testtbl (data) 
 
For DROP INDEX, assuming PostgreSQL 9.2 or higher is detected or for 
a connection-less dialect, it will emit:: 
 
    DROP INDEX CONCURRENTLY test_idx1 
 
When using CONCURRENTLY, the PostgreSQL database requires that the statement 
be invoked outside of a transaction block.   The Python DBAPI enforces that 
even for a single statement, a transaction is present, so to use this 
construct, the DBAPI's &quot;autocommit&quot; mode must be used:: 
 
    metadata = MetaData() 
    table = Table( 
        &quot;foo&quot;, metadata, 
        Column(&quot;id&quot;, String)) 
    index = Index( 
        &quot;foo_idx&quot;, table.c.id, postgresql_concurrently=True) 
 
    with engine.connect() as conn: 
        with conn.execution_options(isolation_level='AUTOCOMMIT'): 
            table.create(conn) 
 
.. seealso:: 
 
    :ref:`postgresql_isolation_level` 
 
.. _postgresql_index_reflection: 
 
PostgreSQL Index Reflection 
--------------------------- 
 
The PostgreSQL database creates a UNIQUE INDEX implicitly whenever the 
UNIQUE CONSTRAINT construct is used.   When inspecting a table using 
:class:`_reflection.Inspector`, the :meth:`_reflection.Inspector.get_indexes` 
and the :meth:`_reflection.Inspector.get_unique_constraints` 
will report on these 
two constructs distinctly; in the case of the index, the key 
``duplicates_constraint`` will be present in the index entry if it is 
detected as mirroring a constraint.   When performing reflection using 
``Table(..., autoload_with=engine)``, the UNIQUE INDEX is **not** returned 
in :attr:`_schema.Table.indexes` when it is detected as mirroring a 
:class:`.UniqueConstraint` in the :attr:`_schema.Table.constraints` collection 
. 
 
Special Reflection Options 
-------------------------- 
 
The :class:`_reflection.Inspector` 
used for the PostgreSQL backend is an instance 
of :class:`.PGInspector`, which offers additional methods:: 
 
    from sqlalchemy import create_engine, inspect 
 
    engine = create_engine(&quot;postgresql+psycopg2://localhost/test&quot;) 
    insp = inspect(engine)  # will be a PGInspector 
 
    print(insp.get_enums()) 
 
.. autoclass:: PGInspector 
    :members: 
 
.. _postgresql_table_options: 
 
PostgreSQL Table Options 
------------------------ 
 
Several options for CREATE TABLE are supported directly by the PostgreSQL 
dialect in conjunction with the :class:`_schema.Table` construct: 
 
* ``INHERITS``:: 
 
    Table(&quot;some_table&quot;, metadata, ..., postgresql_inherits=&quot;some_supertable&quot;) 
 
    Table(&quot;some_table&quot;, metadata, ..., postgresql_inherits=(&quot;t1&quot;, &quot;t2&quot;, ...)) 
 
* ``ON COMMIT``:: 
 
    Table(&quot;some_table&quot;, metadata, ..., postgresql_on_commit='PRESERVE ROWS') 
 
* ``PARTITION BY``:: 
 
    Table(&quot;some_table&quot;, metadata, ..., 
          postgresql_partition_by='LIST (part_column)') 
 
    .. versionadded:: 1.2.6 
 
* ``TABLESPACE``:: 
 
    Table(&quot;some_table&quot;, metadata, ..., postgresql_tablespace='some_tablespace') 
 
  The above option is also available on the :class:`.Index` construct. 
 
* ``USING``:: 
 
    Table(&quot;some_table&quot;, metadata, ..., postgresql_using='heap') 
 
    .. versionadded:: 2.0.26 
 
* ``WITH OIDS``:: 
 
    Table(&quot;some_table&quot;, metadata, ..., postgresql_with_oids=True) 
 
* ``WITHOUT OIDS``:: 
 
    Table(&quot;some_table&quot;, metadata, ..., postgresql_with_oids=False) 
 
.. seealso:: 
 
    `PostgreSQL CREATE TABLE options 
    &lt;https://www.postgresql.org/docs/current/static/sql-createtable.html&gt;`_ - 
    in the PostgreSQL documentation. 
 
.. _postgresql_constraint_options: 
 
PostgreSQL Constraint Options 
----------------------------- 
 
The following option(s) are supported by the PostgreSQL dialect in conjunction 
with selected constraint constructs: 
 
* ``NOT VALID``:  This option applies towards CHECK and FOREIGN KEY constraints 
  when the constraint is being added to an existing table via ALTER TABLE, 
  and has the effect that existing rows are not scanned during the ALTER 
  operation against the constraint being added. 
 
  When using a SQL migration tool such as `Alembic &lt;https://alembic.sqlalchemy.org&gt;`_ 
  that renders ALTER TABLE constructs, the ``postgresql_not_valid`` argument 
  may be specified as an additional keyword argument within the operation 
  that creates the constraint, as in the following Alembic example:: 
 
        def update(): 
            op.create_foreign_key( 
                &quot;fk_user_address&quot;, 
                &quot;address&quot;, 
                &quot;user&quot;, 
                [&quot;user_id&quot;], 
                [&quot;id&quot;], 
                postgresql_not_valid=True 
            ) 
 
  The keyword is ultimately accepted directly by the 
  :class:`_schema.CheckConstraint`, :class:`_schema.ForeignKeyConstraint` 
  and :class:`_schema.ForeignKey` constructs; when using a tool like 
  Alembic, dialect-specific keyword arguments are passed through to 
  these constructs from the migration operation directives:: 
 
       CheckConstraint(&quot;some_field IS NOT NULL&quot;, postgresql_not_valid=True) 
 
       ForeignKeyConstraint([&quot;some_id&quot;], [&quot;some_table.some_id&quot;], postgresql_not_valid=True) 
 
  .. versionadded:: 1.4.32 
 
  .. seealso:: 
 
      `PostgreSQL ALTER TABLE options 
      &lt;https://www.postgresql.org/docs/current/static/sql-altertable.html&gt;`_ - 
      in the PostgreSQL documentation. 
 
.. _postgresql_table_valued_overview: 
 
Table values, Table and Column valued functions, Row and Tuple objects 
----------------------------------------------------------------------- 
 
PostgreSQL makes great use of modern SQL forms such as table-valued functions, 
tables and rows as values.   These constructs are commonly used as part 
of PostgreSQL's support for complex datatypes such as JSON, ARRAY, and other 
datatypes.  SQLAlchemy's SQL expression language has native support for 
most table-valued and row-valued forms. 
 
.. _postgresql_table_valued: 
 
Table-Valued Functions 
^^^^^^^^^^^^^^^^^^^^^^^ 
 
Many PostgreSQL built-in functions are intended to be used in the FROM clause 
of a SELECT statement, and are capable of returning table rows or sets of table 
rows. A large portion of PostgreSQL's JSON functions for example such as 
``json_array_elements()``, ``json_object_keys()``, ``json_each_text()``, 
``json_each()``, ``json_to_record()``, ``json_populate_recordset()`` use such 
forms. These classes of SQL function calling forms in SQLAlchemy are available 
using the :meth:`_functions.FunctionElement.table_valued` method in conjunction 
with :class:`_functions.Function` objects generated from the :data:`_sql.func` 
namespace. 
 
Examples from PostgreSQL's reference documentation follow below: 
 
* ``json_each()``: 
 
  .. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; from sqlalchemy import select, func 
    &gt;&gt;&gt; stmt = select(func.json_each('{&quot;a&quot;:&quot;foo&quot;, &quot;b&quot;:&quot;bar&quot;}').table_valued(&quot;key&quot;, &quot;value&quot;)) 
    &gt;&gt;&gt; print(stmt) 
    {printsql}SELECT anon_1.key, anon_1.value 
    FROM json_each(:json_each_1) AS anon_1 
 
* ``json_populate_record()``: 
 
  .. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; from sqlalchemy import select, func, literal_column 
    &gt;&gt;&gt; stmt = select( 
    ...     func.json_populate_record( 
    ...         literal_column(&quot;null::myrowtype&quot;), 
    ...         '{&quot;a&quot;:1,&quot;b&quot;:2}' 
    ...     ).table_valued(&quot;a&quot;, &quot;b&quot;, name=&quot;x&quot;) 
    ... ) 
    &gt;&gt;&gt; print(stmt) 
    {printsql}SELECT x.a, x.b 
    FROM json_populate_record(null::myrowtype, :json_populate_record_1) AS x 
 
* ``json_to_record()`` - this form uses a PostgreSQL specific form of derived 
  columns in the alias, where we may make use of :func:`_sql.column` elements with 
  types to produce them.  The :meth:`_functions.FunctionElement.table_valued` 
  method produces  a :class:`_sql.TableValuedAlias` construct, and the method 
  :meth:`_sql.TableValuedAlias.render_derived` method sets up the derived 
  columns specification: 
 
  .. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; from sqlalchemy import select, func, column, Integer, Text 
    &gt;&gt;&gt; stmt = select( 
    ...     func.json_to_record('{&quot;a&quot;:1,&quot;b&quot;:[1,2,3],&quot;c&quot;:&quot;bar&quot;}').table_valued( 
    ...         column(&quot;a&quot;, Integer), column(&quot;b&quot;, Text), column(&quot;d&quot;, Text), 
    ...     ).render_derived(name=&quot;x&quot;, with_types=True) 
    ... ) 
    &gt;&gt;&gt; print(stmt) 
    {printsql}SELECT x.a, x.b, x.d 
    FROM json_to_record(:json_to_record_1) AS x(a INTEGER, b TEXT, d TEXT) 
 
* ``WITH ORDINALITY`` - part of the SQL standard, ``WITH ORDINALITY`` adds an 
  ordinal counter to the output of a function and is accepted by a limited set 
  of PostgreSQL functions including ``unnest()`` and ``generate_series()``. The 
  :meth:`_functions.FunctionElement.table_valued` method accepts a keyword 
  parameter ``with_ordinality`` for this purpose, which accepts the string name 
  that will be applied to the &quot;ordinality&quot; column: 
 
  .. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; from sqlalchemy import select, func 
    &gt;&gt;&gt; stmt = select( 
    ...     func.generate_series(4, 1, -1). 
    ...     table_valued(&quot;value&quot;, with_ordinality=&quot;ordinality&quot;). 
    ...     render_derived() 
    ... ) 
    &gt;&gt;&gt; print(stmt) 
    {printsql}SELECT anon_1.value, anon_1.ordinality 
    FROM generate_series(:generate_series_1, :generate_series_2, :generate_series_3) 
    WITH ORDINALITY AS anon_1(value, ordinality) 
 
.. versionadded:: 1.4.0b2 
 
.. seealso:: 
 
    :ref:`tutorial_functions_table_valued` - in the :ref:`unified_tutorial` 
 
.. _postgresql_column_valued: 
 
Column Valued Functions 
^^^^^^^^^^^^^^^^^^^^^^^ 
 
Similar to the table valued function, a column valued function is present 
in the FROM clause, but delivers itself to the columns clause as a single 
scalar value.  PostgreSQL functions such as ``json_array_elements()``, 
``unnest()`` and ``generate_series()`` may use this form. Column valued functions are available using the 
:meth:`_functions.FunctionElement.column_valued` method of :class:`_functions.FunctionElement`: 
 
* ``json_array_elements()``: 
 
  .. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; from sqlalchemy import select, func 
    &gt;&gt;&gt; stmt = select(func.json_array_elements('[&quot;one&quot;, &quot;two&quot;]').column_valued(&quot;x&quot;)) 
    &gt;&gt;&gt; print(stmt) 
    {printsql}SELECT x 
    FROM json_array_elements(:json_array_elements_1) AS x 
 
* ``unnest()`` - in order to generate a PostgreSQL ARRAY literal, the 
  :func:`_postgresql.array` construct may be used: 
 
  .. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; from sqlalchemy.dialects.postgresql import array 
    &gt;&gt;&gt; from sqlalchemy import select, func 
    &gt;&gt;&gt; stmt = select(func.unnest(array([1, 2])).column_valued()) 
    &gt;&gt;&gt; print(stmt) 
    {printsql}SELECT anon_1 
    FROM unnest(ARRAY[%(param_1)s, %(param_2)s]) AS anon_1 
 
  The function can of course be used against an existing table-bound column 
  that's of type :class:`_types.ARRAY`: 
 
  .. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; from sqlalchemy import table, column, ARRAY, Integer 
    &gt;&gt;&gt; from sqlalchemy import select, func 
    &gt;&gt;&gt; t = table(&quot;t&quot;, column('value', ARRAY(Integer))) 
    &gt;&gt;&gt; stmt = select(func.unnest(t.c.value).column_valued(&quot;unnested_value&quot;)) 
    &gt;&gt;&gt; print(stmt) 
    {printsql}SELECT unnested_value 
    FROM unnest(t.value) AS unnested_value 
 
.. seealso:: 
 
    :ref:`tutorial_functions_column_valued` - in the :ref:`unified_tutorial` 
 
 
Row Types 
^^^^^^^^^ 
 
Built-in support for rendering a ``ROW`` may be approximated using 
``func.ROW`` with the :attr:`_sa.func` namespace, or by using the 
:func:`_sql.tuple_` construct: 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; from sqlalchemy import table, column, func, tuple_ 
    &gt;&gt;&gt; t = table(&quot;t&quot;, column(&quot;id&quot;), column(&quot;fk&quot;)) 
    &gt;&gt;&gt; stmt = t.select().where( 
    ...     tuple_(t.c.id, t.c.fk) &gt; (1,2) 
    ... ).where( 
    ...     func.ROW(t.c.id, t.c.fk) &lt; func.ROW(3, 7) 
    ... ) 
    &gt;&gt;&gt; print(stmt) 
    {printsql}SELECT t.id, t.fk 
    FROM t 
    WHERE (t.id, t.fk) &gt; (:param_1, :param_2) AND ROW(t.id, t.fk) &lt; ROW(:ROW_1, :ROW_2) 
 
.. seealso:: 
 
    `PostgreSQL Row Constructors 
    &lt;https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS&gt;`_ 
 
    `PostgreSQL Row Constructor Comparison 
    &lt;https://www.postgresql.org/docs/current/functions-comparisons.html#ROW-WISE-COMPARISON&gt;`_ 
 
Table Types passed to Functions 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
 
PostgreSQL supports passing a table as an argument to a function, which is 
known as a &quot;record&quot; type. SQLAlchemy :class:`_sql.FromClause` objects 
such as :class:`_schema.Table` support this special form using the 
:meth:`_sql.FromClause.table_valued` method, which is comparable to the 
:meth:`_functions.FunctionElement.table_valued` method except that the collection 
of columns is already established by that of the :class:`_sql.FromClause` 
itself: 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; from sqlalchemy import table, column, func, select 
    &gt;&gt;&gt; a = table( &quot;a&quot;, column(&quot;id&quot;), column(&quot;x&quot;), column(&quot;y&quot;)) 
    &gt;&gt;&gt; stmt = select(func.row_to_json(a.table_valued())) 
    &gt;&gt;&gt; print(stmt) 
    {printsql}SELECT row_to_json(a) AS row_to_json_1 
    FROM a 
 
.. versionadded:: 1.4.0b2 
 
 
 
&quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">defaultdict</span>
<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">lru_cache</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Tuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>

<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">arraylib </span><span class="s3">as </span><span class="s1">_array</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">json </span><span class="s3">as </span><span class="s1">_json</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">pg_catalog</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">ranges </span><span class="s3">as </span><span class="s1">_ranges</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">ext </span><span class="s3">import </span><span class="s1">_regconfig_fn</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">ext </span><span class="s3">import </span><span class="s1">aggregate_order_by</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">hstore </span><span class="s3">import </span><span class="s1">HSTORE</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">named_types </span><span class="s3">import </span><span class="s1">CreateDomainType </span><span class="s3">as </span><span class="s1">CreateDomainType  </span><span class="s0"># noqa: F401</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">named_types </span><span class="s3">import </span><span class="s1">CreateEnumType </span><span class="s3">as </span><span class="s1">CreateEnumType  </span><span class="s0"># noqa: F401</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">named_types </span><span class="s3">import </span><span class="s1">DOMAIN </span><span class="s3">as </span><span class="s1">DOMAIN  </span><span class="s0"># noqa: F401</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">named_types </span><span class="s3">import </span><span class="s1">DropDomainType </span><span class="s3">as </span><span class="s1">DropDomainType  </span><span class="s0"># noqa: F401</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">named_types </span><span class="s3">import </span><span class="s1">DropEnumType </span><span class="s3">as </span><span class="s1">DropEnumType  </span><span class="s0"># noqa: F401</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">named_types </span><span class="s3">import </span><span class="s1">ENUM </span><span class="s3">as </span><span class="s1">ENUM  </span><span class="s0"># noqa: F401</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">named_types </span><span class="s3">import </span><span class="s1">NamedType </span><span class="s3">as </span><span class="s1">NamedType  </span><span class="s0"># noqa: F401</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">_DECIMAL_TYPES  </span><span class="s0"># noqa: F401</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">_FLOAT_TYPES  </span><span class="s0"># noqa: F401</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">_INT_TYPES  </span><span class="s0"># noqa: F401</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">BIT </span><span class="s3">as </span><span class="s1">BIT</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">BYTEA </span><span class="s3">as </span><span class="s1">BYTEA</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">CIDR </span><span class="s3">as </span><span class="s1">CIDR</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">CITEXT </span><span class="s3">as </span><span class="s1">CITEXT</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">INET </span><span class="s3">as </span><span class="s1">INET</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">INTERVAL </span><span class="s3">as </span><span class="s1">INTERVAL</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">MACADDR </span><span class="s3">as </span><span class="s1">MACADDR</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">MACADDR8 </span><span class="s3">as </span><span class="s1">MACADDR8</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">MONEY </span><span class="s3">as </span><span class="s1">MONEY</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">OID </span><span class="s3">as </span><span class="s1">OID</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">PGBit </span><span class="s3">as </span><span class="s1">PGBit  </span><span class="s0"># noqa: F401</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">PGCidr </span><span class="s3">as </span><span class="s1">PGCidr  </span><span class="s0"># noqa: F401</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">PGInet </span><span class="s3">as </span><span class="s1">PGInet  </span><span class="s0"># noqa: F401</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">PGInterval </span><span class="s3">as </span><span class="s1">PGInterval  </span><span class="s0"># noqa: F401</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">PGMacAddr </span><span class="s3">as </span><span class="s1">PGMacAddr  </span><span class="s0"># noqa: F401</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">PGMacAddr8 </span><span class="s3">as </span><span class="s1">PGMacAddr8  </span><span class="s0"># noqa: F401</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">PGUuid </span><span class="s3">as </span><span class="s1">PGUuid</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">REGCLASS </span><span class="s3">as </span><span class="s1">REGCLASS</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">REGCONFIG </span><span class="s3">as </span><span class="s1">REGCONFIG  </span><span class="s0"># noqa: F401</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">TIME </span><span class="s3">as </span><span class="s1">TIME</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">TIMESTAMP </span><span class="s3">as </span><span class="s1">TIMESTAMP</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">types </span><span class="s3">import </span><span class="s1">TSVECTOR </span><span class="s3">as </span><span class="s1">TSVECTOR</span>
<span class="s3">from </span><span class="s4">... </span><span class="s3">import </span><span class="s1">exc</span>
<span class="s3">from </span><span class="s4">... </span><span class="s3">import </span><span class="s1">schema</span>
<span class="s3">from </span><span class="s4">... </span><span class="s3">import </span><span class="s1">select</span>
<span class="s3">from </span><span class="s4">... </span><span class="s3">import </span><span class="s1">sql</span>
<span class="s3">from </span><span class="s4">... </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">characteristics</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">default</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">interfaces</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">ObjectKind</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">ObjectScope</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">reflection</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">URL</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">reflection </span><span class="s3">import </span><span class="s1">ReflectionDefaults</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">bindparam</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">coercions</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">compiler</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">elements</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">expression</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">roles</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">sqltypes</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">util </span><span class="s3">as </span><span class="s1">sql_util</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">compiler </span><span class="s3">import </span><span class="s1">InsertmanyvaluesSentinelOpts</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">visitors </span><span class="s3">import </span><span class="s1">InternalTraversal</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">types </span><span class="s3">import </span><span class="s1">BIGINT</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">types </span><span class="s3">import </span><span class="s1">BOOLEAN</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">types </span><span class="s3">import </span><span class="s1">CHAR</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">types </span><span class="s3">import </span><span class="s1">DATE</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">types </span><span class="s3">import </span><span class="s1">DOUBLE_PRECISION</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">types </span><span class="s3">import </span><span class="s1">FLOAT</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">types </span><span class="s3">import </span><span class="s1">INTEGER</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">types </span><span class="s3">import </span><span class="s1">NUMERIC</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">types </span><span class="s3">import </span><span class="s1">REAL</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">types </span><span class="s3">import </span><span class="s1">SMALLINT</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">types </span><span class="s3">import </span><span class="s1">TEXT</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">types </span><span class="s3">import </span><span class="s1">UUID </span><span class="s3">as </span><span class="s1">UUID</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">types </span><span class="s3">import </span><span class="s1">VARCHAR</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TypedDict</span>

<span class="s1">IDX_USING </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s2">r&quot;^(?:btree|hash|gist|gin|[\w_]+)$&quot;</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>

<span class="s1">RESERVED_WORDS </span><span class="s4">= {</span>
    <span class="s2">&quot;all&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;analyse&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;analyze&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;and&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;any&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;array&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;as&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;asc&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;asymmetric&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;both&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;case&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;cast&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;check&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;collate&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;column&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;constraint&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;create&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;current_catalog&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;current_date&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;current_role&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;current_time&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;current_timestamp&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;current_user&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;default&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;deferrable&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;desc&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;distinct&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;do&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;else&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;end&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;except&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;false&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;fetch&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;for&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;foreign&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;from&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;grant&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;group&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;having&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;in&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;initially&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;intersect&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;into&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;leading&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;limit&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;localtime&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;localtimestamp&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;new&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;not&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;null&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;of&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;off&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;offset&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;old&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;on&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;only&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;or&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;order&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;placing&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;primary&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;references&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;returning&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;select&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;session_user&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;some&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;symmetric&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;table&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;then&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;to&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;trailing&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;true&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;union&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;unique&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;user&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;using&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;variadic&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;when&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;where&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;window&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;with&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;authorization&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;between&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;binary&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;cross&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;current_schema&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;freeze&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;full&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;ilike&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;inner&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;is&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;isnull&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;join&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;left&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;like&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;natural&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;notnull&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;outer&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;over&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;overlaps&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;right&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;similar&quot;</span><span class="s4">,</span>
    <span class="s2">&quot;verbose&quot;</span><span class="s4">,</span>
<span class="s4">}</span>

<span class="s1">colspecs </span><span class="s4">= {</span>
    <span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">ARRAY</span><span class="s4">: </span><span class="s1">_array</span><span class="s4">.</span><span class="s1">ARRAY</span><span class="s4">,</span>
    <span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">Interval</span><span class="s4">: </span><span class="s1">INTERVAL</span><span class="s4">,</span>
    <span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">Enum</span><span class="s4">: </span><span class="s1">ENUM</span><span class="s4">,</span>
    <span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">JSON</span><span class="s4">.</span><span class="s1">JSONPathType</span><span class="s4">: </span><span class="s1">_json</span><span class="s4">.</span><span class="s1">JSONPATH</span><span class="s4">,</span>
    <span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">JSON</span><span class="s4">: </span><span class="s1">_json</span><span class="s4">.</span><span class="s1">JSON</span><span class="s4">,</span>
    <span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">Uuid</span><span class="s4">: </span><span class="s1">PGUuid</span><span class="s4">,</span>
<span class="s4">}</span>


<span class="s1">ischema_names </span><span class="s4">= {</span>
    <span class="s2">&quot;_array&quot;</span><span class="s4">: </span><span class="s1">_array</span><span class="s4">.</span><span class="s1">ARRAY</span><span class="s4">,</span>
    <span class="s2">&quot;hstore&quot;</span><span class="s4">: </span><span class="s1">HSTORE</span><span class="s4">,</span>
    <span class="s2">&quot;json&quot;</span><span class="s4">: </span><span class="s1">_json</span><span class="s4">.</span><span class="s1">JSON</span><span class="s4">,</span>
    <span class="s2">&quot;jsonb&quot;</span><span class="s4">: </span><span class="s1">_json</span><span class="s4">.</span><span class="s1">JSONB</span><span class="s4">,</span>
    <span class="s2">&quot;int4range&quot;</span><span class="s4">: </span><span class="s1">_ranges</span><span class="s4">.</span><span class="s1">INT4RANGE</span><span class="s4">,</span>
    <span class="s2">&quot;int8range&quot;</span><span class="s4">: </span><span class="s1">_ranges</span><span class="s4">.</span><span class="s1">INT8RANGE</span><span class="s4">,</span>
    <span class="s2">&quot;numrange&quot;</span><span class="s4">: </span><span class="s1">_ranges</span><span class="s4">.</span><span class="s1">NUMRANGE</span><span class="s4">,</span>
    <span class="s2">&quot;daterange&quot;</span><span class="s4">: </span><span class="s1">_ranges</span><span class="s4">.</span><span class="s1">DATERANGE</span><span class="s4">,</span>
    <span class="s2">&quot;tsrange&quot;</span><span class="s4">: </span><span class="s1">_ranges</span><span class="s4">.</span><span class="s1">TSRANGE</span><span class="s4">,</span>
    <span class="s2">&quot;tstzrange&quot;</span><span class="s4">: </span><span class="s1">_ranges</span><span class="s4">.</span><span class="s1">TSTZRANGE</span><span class="s4">,</span>
    <span class="s2">&quot;int4multirange&quot;</span><span class="s4">: </span><span class="s1">_ranges</span><span class="s4">.</span><span class="s1">INT4MULTIRANGE</span><span class="s4">,</span>
    <span class="s2">&quot;int8multirange&quot;</span><span class="s4">: </span><span class="s1">_ranges</span><span class="s4">.</span><span class="s1">INT8MULTIRANGE</span><span class="s4">,</span>
    <span class="s2">&quot;nummultirange&quot;</span><span class="s4">: </span><span class="s1">_ranges</span><span class="s4">.</span><span class="s1">NUMMULTIRANGE</span><span class="s4">,</span>
    <span class="s2">&quot;datemultirange&quot;</span><span class="s4">: </span><span class="s1">_ranges</span><span class="s4">.</span><span class="s1">DATEMULTIRANGE</span><span class="s4">,</span>
    <span class="s2">&quot;tsmultirange&quot;</span><span class="s4">: </span><span class="s1">_ranges</span><span class="s4">.</span><span class="s1">TSMULTIRANGE</span><span class="s4">,</span>
    <span class="s2">&quot;tstzmultirange&quot;</span><span class="s4">: </span><span class="s1">_ranges</span><span class="s4">.</span><span class="s1">TSTZMULTIRANGE</span><span class="s4">,</span>
    <span class="s2">&quot;integer&quot;</span><span class="s4">: </span><span class="s1">INTEGER</span><span class="s4">,</span>
    <span class="s2">&quot;bigint&quot;</span><span class="s4">: </span><span class="s1">BIGINT</span><span class="s4">,</span>
    <span class="s2">&quot;smallint&quot;</span><span class="s4">: </span><span class="s1">SMALLINT</span><span class="s4">,</span>
    <span class="s2">&quot;character varying&quot;</span><span class="s4">: </span><span class="s1">VARCHAR</span><span class="s4">,</span>
    <span class="s2">&quot;character&quot;</span><span class="s4">: </span><span class="s1">CHAR</span><span class="s4">,</span>
    <span class="s2">'&quot;char&quot;'</span><span class="s4">: </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">String</span><span class="s4">,</span>
    <span class="s2">&quot;name&quot;</span><span class="s4">: </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">String</span><span class="s4">,</span>
    <span class="s2">&quot;text&quot;</span><span class="s4">: </span><span class="s1">TEXT</span><span class="s4">,</span>
    <span class="s2">&quot;numeric&quot;</span><span class="s4">: </span><span class="s1">NUMERIC</span><span class="s4">,</span>
    <span class="s2">&quot;float&quot;</span><span class="s4">: </span><span class="s1">FLOAT</span><span class="s4">,</span>
    <span class="s2">&quot;real&quot;</span><span class="s4">: </span><span class="s1">REAL</span><span class="s4">,</span>
    <span class="s2">&quot;inet&quot;</span><span class="s4">: </span><span class="s1">INET</span><span class="s4">,</span>
    <span class="s2">&quot;cidr&quot;</span><span class="s4">: </span><span class="s1">CIDR</span><span class="s4">,</span>
    <span class="s2">&quot;citext&quot;</span><span class="s4">: </span><span class="s1">CITEXT</span><span class="s4">,</span>
    <span class="s2">&quot;uuid&quot;</span><span class="s4">: </span><span class="s1">UUID</span><span class="s4">,</span>
    <span class="s2">&quot;bit&quot;</span><span class="s4">: </span><span class="s1">BIT</span><span class="s4">,</span>
    <span class="s2">&quot;bit varying&quot;</span><span class="s4">: </span><span class="s1">BIT</span><span class="s4">,</span>
    <span class="s2">&quot;macaddr&quot;</span><span class="s4">: </span><span class="s1">MACADDR</span><span class="s4">,</span>
    <span class="s2">&quot;macaddr8&quot;</span><span class="s4">: </span><span class="s1">MACADDR8</span><span class="s4">,</span>
    <span class="s2">&quot;money&quot;</span><span class="s4">: </span><span class="s1">MONEY</span><span class="s4">,</span>
    <span class="s2">&quot;oid&quot;</span><span class="s4">: </span><span class="s1">OID</span><span class="s4">,</span>
    <span class="s2">&quot;regclass&quot;</span><span class="s4">: </span><span class="s1">REGCLASS</span><span class="s4">,</span>
    <span class="s2">&quot;double precision&quot;</span><span class="s4">: </span><span class="s1">DOUBLE_PRECISION</span><span class="s4">,</span>
    <span class="s2">&quot;timestamp&quot;</span><span class="s4">: </span><span class="s1">TIMESTAMP</span><span class="s4">,</span>
    <span class="s2">&quot;timestamp with time zone&quot;</span><span class="s4">: </span><span class="s1">TIMESTAMP</span><span class="s4">,</span>
    <span class="s2">&quot;timestamp without time zone&quot;</span><span class="s4">: </span><span class="s1">TIMESTAMP</span><span class="s4">,</span>
    <span class="s2">&quot;time with time zone&quot;</span><span class="s4">: </span><span class="s1">TIME</span><span class="s4">,</span>
    <span class="s2">&quot;time without time zone&quot;</span><span class="s4">: </span><span class="s1">TIME</span><span class="s4">,</span>
    <span class="s2">&quot;date&quot;</span><span class="s4">: </span><span class="s1">DATE</span><span class="s4">,</span>
    <span class="s2">&quot;time&quot;</span><span class="s4">: </span><span class="s1">TIME</span><span class="s4">,</span>
    <span class="s2">&quot;bytea&quot;</span><span class="s4">: </span><span class="s1">BYTEA</span><span class="s4">,</span>
    <span class="s2">&quot;boolean&quot;</span><span class="s4">: </span><span class="s1">BOOLEAN</span><span class="s4">,</span>
    <span class="s2">&quot;interval&quot;</span><span class="s4">: </span><span class="s1">INTERVAL</span><span class="s4">,</span>
    <span class="s2">&quot;tsvector&quot;</span><span class="s4">: </span><span class="s1">TSVECTOR</span><span class="s4">,</span>
<span class="s4">}</span>


<span class="s3">class </span><span class="s1">PGCompiler</span><span class="s4">(</span><span class="s1">compiler</span><span class="s4">.</span><span class="s1">SQLCompiler</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">visit_to_tsvector_func</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_assert_pg_ts_ext</span><span class="s4">(</span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_to_tsquery_func</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_assert_pg_ts_ext</span><span class="s4">(</span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_plainto_tsquery_func</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_assert_pg_ts_ext</span><span class="s4">(</span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_phraseto_tsquery_func</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_assert_pg_ts_ext</span><span class="s4">(</span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_websearch_to_tsquery_func</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_assert_pg_ts_ext</span><span class="s4">(</span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_ts_headline_func</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_assert_pg_ts_ext</span><span class="s4">(</span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_assert_pg_ts_ext</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">element</span><span class="s4">, </span><span class="s1">_regconfig_fn</span><span class="s4">):</span>
            <span class="s0"># other options here include trying to rewrite the function</span>
            <span class="s0"># with the correct types.  however, that means we have to</span>
            <span class="s0"># &quot;un-SQL-ize&quot; the first argument, which can't work in a</span>
            <span class="s0"># generalized way. Also, parent compiler class has already added</span>
            <span class="s0"># the incorrect return type to the result map.   So let's just</span>
            <span class="s0"># make sure the function we want is used up front.</span>

            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">CompileError</span><span class="s4">(</span>
                <span class="s2">f'Can</span><span class="s3">\'</span><span class="s2">t compile &quot;</span><span class="s3">{</span><span class="s1">element</span><span class="s4">.</span><span class="s1">name</span><span class="s3">}</span><span class="s2">()&quot; full text search '</span>
                <span class="s2">f&quot;function construct that does not originate from the &quot;</span>
                <span class="s2">f'&quot;sqlalchemy.dialects.postgresql&quot; package.  '</span>
                <span class="s2">f'Please ensure &quot;import sqlalchemy.dialects.postgresql&quot; is '</span>
                <span class="s2">f&quot;called before constructing &quot;</span>
                <span class="s2">f'&quot;sqlalchemy.func.</span><span class="s3">{</span><span class="s1">element</span><span class="s4">.</span><span class="s1">name</span><span class="s3">}</span><span class="s2">()&quot; to ensure registration '</span>
                <span class="s2">f&quot;of the correct argument and return types.&quot;</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s2">f&quot;</span><span class="s3">{</span><span class="s1">element</span><span class="s4">.</span><span class="s1">name</span><span class="s3">}{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">function_argspec</span><span class="s4">(</span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span><span class="s3">}</span><span class="s2">&quot;</span>

    <span class="s3">def </span><span class="s1">render_bind_cast</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, </span><span class="s1">dbapi_type</span><span class="s4">, </span><span class="s1">sqltext</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">dbapi_type</span><span class="s4">.</span><span class="s1">_type_affinity </span><span class="s3">is </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">String </span><span class="s3">and </span><span class="s1">dbapi_type</span><span class="s4">.</span><span class="s1">length</span><span class="s4">:</span>
            <span class="s0"># use VARCHAR with no length for VARCHAR cast.</span>
            <span class="s0"># see #9511</span>
            <span class="s1">dbapi_type </span><span class="s4">= </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">STRINGTYPE</span>
        <span class="s3">return </span><span class="s2">f&quot;&quot;&quot;</span><span class="s3">{</span><span class="s1">sqltext</span><span class="s3">}</span><span class="s2">::</span><span class="s3">{</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">type_compiler_instance</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span>
                <span class="s1">dbapi_type</span><span class="s4">, </span><span class="s1">identifier_preparer</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span>
            <span class="s4">)</span>
        <span class="s3">}</span><span class="s2">&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">visit_array</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;ARRAY[%s]&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">visit_clauselist</span><span class="s4">(</span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_slice</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;%s:%s&quot; </span><span class="s4">% (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">element</span><span class="s4">.</span><span class="s1">start</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">element</span><span class="s4">.</span><span class="s1">stop</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_bitwise_xor_op_binary</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">binary</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_generate_generic_binary</span><span class="s4">(</span><span class="s1">binary</span><span class="s4">, </span><span class="s2">&quot; # &quot;</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_json_getitem_op_binary</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">binary</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">, </span><span class="s1">_cast_applied</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, **</span><span class="s1">kw</span>
    <span class="s4">):</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s3">not </span><span class="s1">_cast_applied</span>
            <span class="s3">and </span><span class="s1">binary</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">_type_affinity </span><span class="s3">is not </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">JSON</span>
        <span class="s4">):</span>
            <span class="s1">kw</span><span class="s4">[</span><span class="s2">&quot;_cast_applied&quot;</span><span class="s4">] = </span><span class="s3">True</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">cast</span><span class="s4">(</span><span class="s1">binary</span><span class="s4">, </span><span class="s1">binary</span><span class="s4">.</span><span class="s1">type</span><span class="s4">), **</span><span class="s1">kw</span><span class="s4">)</span>

        <span class="s1">kw</span><span class="s4">[</span><span class="s2">&quot;eager_grouping&quot;</span><span class="s4">] = </span><span class="s3">True</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_generate_generic_binary</span><span class="s4">(</span>
            <span class="s1">binary</span><span class="s4">, </span><span class="s2">&quot; -&gt; &quot; </span><span class="s3">if not </span><span class="s1">_cast_applied </span><span class="s3">else </span><span class="s2">&quot; -&gt;&gt; &quot;</span><span class="s4">, **</span><span class="s1">kw</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_json_path_getitem_op_binary</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">binary</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">, </span><span class="s1">_cast_applied</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, **</span><span class="s1">kw</span>
    <span class="s4">):</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s3">not </span><span class="s1">_cast_applied</span>
            <span class="s3">and </span><span class="s1">binary</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">_type_affinity </span><span class="s3">is not </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">JSON</span>
        <span class="s4">):</span>
            <span class="s1">kw</span><span class="s4">[</span><span class="s2">&quot;_cast_applied&quot;</span><span class="s4">] = </span><span class="s3">True</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">cast</span><span class="s4">(</span><span class="s1">binary</span><span class="s4">, </span><span class="s1">binary</span><span class="s4">.</span><span class="s1">type</span><span class="s4">), **</span><span class="s1">kw</span><span class="s4">)</span>

        <span class="s1">kw</span><span class="s4">[</span><span class="s2">&quot;eager_grouping&quot;</span><span class="s4">] = </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_generate_generic_binary</span><span class="s4">(</span>
            <span class="s1">binary</span><span class="s4">, </span><span class="s2">&quot; #&gt; &quot; </span><span class="s3">if not </span><span class="s1">_cast_applied </span><span class="s3">else </span><span class="s2">&quot; #&gt;&gt; &quot;</span><span class="s4">, **</span><span class="s1">kw</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_getitem_binary</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">binary</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;%s[%s]&quot; </span><span class="s4">% (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">binary</span><span class="s4">.</span><span class="s1">left</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">binary</span><span class="s4">.</span><span class="s1">right</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_aggregate_order_by</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;%s ORDER BY %s&quot; </span><span class="s4">% (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">element</span><span class="s4">.</span><span class="s1">target</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">element</span><span class="s4">.</span><span class="s1">order_by</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_match_op_binary</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">binary</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s2">&quot;postgresql_regconfig&quot; </span><span class="s3">in </span><span class="s1">binary</span><span class="s4">.</span><span class="s1">modifiers</span><span class="s4">:</span>
            <span class="s1">regconfig </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">render_literal_value</span><span class="s4">(</span>
                <span class="s1">binary</span><span class="s4">.</span><span class="s1">modifiers</span><span class="s4">[</span><span class="s2">&quot;postgresql_regconfig&quot;</span><span class="s4">], </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">STRINGTYPE</span>
            <span class="s4">)</span>
            <span class="s3">if </span><span class="s1">regconfig</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s2">&quot;%s @@ plainto_tsquery(%s, %s)&quot; </span><span class="s4">% (</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">binary</span><span class="s4">.</span><span class="s1">left</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),</span>
                    <span class="s1">regconfig</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">binary</span><span class="s4">.</span><span class="s1">right</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),</span>
                <span class="s4">)</span>
        <span class="s3">return </span><span class="s2">&quot;%s @@ plainto_tsquery(%s)&quot; </span><span class="s4">% (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">binary</span><span class="s4">.</span><span class="s1">left</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">binary</span><span class="s4">.</span><span class="s1">right</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_ilike_case_insensitive_operand</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">element</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_compiler_dispatch</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_ilike_op_binary</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">binary</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">escape </span><span class="s4">= </span><span class="s1">binary</span><span class="s4">.</span><span class="s1">modifiers</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s2">&quot;escape&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s2">&quot;%s ILIKE %s&quot; </span><span class="s4">% (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">binary</span><span class="s4">.</span><span class="s1">left</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">binary</span><span class="s4">.</span><span class="s1">right</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),</span>
        <span class="s4">) + (</span>
            <span class="s2">&quot; ESCAPE &quot; </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">render_literal_value</span><span class="s4">(</span><span class="s1">escape</span><span class="s4">, </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">STRINGTYPE</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">escape </span><span class="s3">is not None</span>
            <span class="s3">else </span><span class="s2">&quot;&quot;</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_not_ilike_op_binary</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">binary</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">escape </span><span class="s4">= </span><span class="s1">binary</span><span class="s4">.</span><span class="s1">modifiers</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s2">&quot;escape&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s2">&quot;%s NOT ILIKE %s&quot; </span><span class="s4">% (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">binary</span><span class="s4">.</span><span class="s1">left</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">binary</span><span class="s4">.</span><span class="s1">right</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),</span>
        <span class="s4">) + (</span>
            <span class="s2">&quot; ESCAPE &quot; </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">render_literal_value</span><span class="s4">(</span><span class="s1">escape</span><span class="s4">, </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">STRINGTYPE</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">escape </span><span class="s3">is not None</span>
            <span class="s3">else </span><span class="s2">&quot;&quot;</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_regexp_match</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">base_op</span><span class="s4">, </span><span class="s1">binary</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">, </span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">flags </span><span class="s4">= </span><span class="s1">binary</span><span class="s4">.</span><span class="s1">modifiers</span><span class="s4">[</span><span class="s2">&quot;flags&quot;</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">flags </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_generate_generic_binary</span><span class="s4">(</span>
                <span class="s1">binary</span><span class="s4">, </span><span class="s2">&quot; %s &quot; </span><span class="s4">% </span><span class="s1">base_op</span><span class="s4">, **</span><span class="s1">kw</span>
            <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">flags </span><span class="s4">== </span><span class="s2">&quot;i&quot;</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_generate_generic_binary</span><span class="s4">(</span>
                <span class="s1">binary</span><span class="s4">, </span><span class="s2">&quot; %s* &quot; </span><span class="s4">% </span><span class="s1">base_op</span><span class="s4">, **</span><span class="s1">kw</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s2">&quot;%s %s CONCAT('(?', %s, ')', %s)&quot; </span><span class="s4">% (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">binary</span><span class="s4">.</span><span class="s1">left</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),</span>
            <span class="s1">base_op</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">render_literal_value</span><span class="s4">(</span><span class="s1">flags</span><span class="s4">, </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">STRINGTYPE</span><span class="s4">),</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">binary</span><span class="s4">.</span><span class="s1">right</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_regexp_match_op_binary</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">binary</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_regexp_match</span><span class="s4">(</span><span class="s2">&quot;~&quot;</span><span class="s4">, </span><span class="s1">binary</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">, </span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_not_regexp_match_op_binary</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">binary</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_regexp_match</span><span class="s4">(</span><span class="s2">&quot;!~&quot;</span><span class="s4">, </span><span class="s1">binary</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">, </span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_regexp_replace_op_binary</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">binary</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">string </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">binary</span><span class="s4">.</span><span class="s1">left</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s1">pattern_replace </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">binary</span><span class="s4">.</span><span class="s1">right</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s1">flags </span><span class="s4">= </span><span class="s1">binary</span><span class="s4">.</span><span class="s1">modifiers</span><span class="s4">[</span><span class="s2">&quot;flags&quot;</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">flags </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s2">&quot;REGEXP_REPLACE(%s, %s)&quot; </span><span class="s4">% (</span>
                <span class="s1">string</span><span class="s4">,</span>
                <span class="s1">pattern_replace</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s2">&quot;REGEXP_REPLACE(%s, %s, %s)&quot; </span><span class="s4">% (</span>
                <span class="s1">string</span><span class="s4">,</span>
                <span class="s1">pattern_replace</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">render_literal_value</span><span class="s4">(</span><span class="s1">flags</span><span class="s4">, </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">STRINGTYPE</span><span class="s4">),</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_empty_set_expr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element_types</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s0"># cast the empty set to the type we are comparing against.  if</span>
        <span class="s0"># we are comparing against the null type, pick an arbitrary</span>
        <span class="s0"># datatype for the empty set</span>
        <span class="s3">return </span><span class="s2">&quot;SELECT %s WHERE 1!=1&quot; </span><span class="s4">% (</span>
            <span class="s2">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
                <span class="s2">&quot;CAST(NULL AS %s)&quot;</span>
                <span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">type_compiler_instance</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span>
                    <span class="s1">INTEGER</span><span class="s4">() </span><span class="s3">if </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">_isnull </span><span class="s3">else </span><span class="s1">type_</span>
                <span class="s4">)</span>
                <span class="s3">for </span><span class="s1">type_ </span><span class="s3">in </span><span class="s1">element_types </span><span class="s3">or </span><span class="s4">[</span><span class="s1">INTEGER</span><span class="s4">()]</span>
            <span class="s4">),</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">render_literal_value</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">):</span>
        <span class="s1">value </span><span class="s4">= </span><span class="s1">super</span><span class="s4">().</span><span class="s1">render_literal_value</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">_backslash_escapes</span><span class="s4">:</span>
            <span class="s1">value </span><span class="s4">= </span><span class="s1">value</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s2">&quot;</span><span class="s3">\\</span><span class="s2">&quot;</span><span class="s4">, </span><span class="s2">&quot;</span><span class="s3">\\\\</span><span class="s2">&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">visit_aggregate_strings_func</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;string_agg%s&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">function_argspec</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_sequence</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">seq</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;nextval('%s')&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">format_sequence</span><span class="s4">(</span><span class="s1">seq</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">limit_clause</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">select</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">text </span><span class="s4">= </span><span class="s2">&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_limit_clause </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot; </span><span class="s3">\n </span><span class="s2">LIMIT &quot; </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">select</span><span class="s4">.</span><span class="s1">_limit_clause</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_offset_clause </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_limit_clause </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot;</span><span class="s3">\n </span><span class="s2">LIMIT ALL&quot;</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot; OFFSET &quot; </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">select</span><span class="s4">.</span><span class="s1">_offset_clause</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">format_from_hint_text</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">sqltext</span><span class="s4">, </span><span class="s1">table</span><span class="s4">, </span><span class="s1">hint</span><span class="s4">, </span><span class="s1">iscrud</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">hint</span><span class="s4">.</span><span class="s1">upper</span><span class="s4">() != </span><span class="s2">&quot;ONLY&quot;</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">CompileError</span><span class="s4">(</span><span class="s2">&quot;Unrecognized hint: %r&quot; </span><span class="s4">% </span><span class="s1">hint</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s2">&quot;ONLY &quot; </span><span class="s4">+ </span><span class="s1">sqltext</span>

    <span class="s3">def </span><span class="s1">get_select_precolumns</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">select</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s0"># Do not call super().get_select_precolumns because</span>
        <span class="s0"># it will warn/raise when distinct on is present</span>
        <span class="s3">if </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_distinct </span><span class="s3">or </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_distinct_on</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_distinct_on</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s4">(</span>
                    <span class="s2">&quot;DISTINCT ON (&quot;</span>
                    <span class="s4">+ </span><span class="s2">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
                        <span class="s4">[</span>
                            <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">col</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
                            <span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_distinct_on</span>
                        <span class="s4">]</span>
                    <span class="s4">)</span>
                    <span class="s4">+ </span><span class="s2">&quot;) &quot;</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s2">&quot;DISTINCT &quot;</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s2">&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">for_update_clause</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">select</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_for_update_arg</span><span class="s4">.</span><span class="s1">read</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_for_update_arg</span><span class="s4">.</span><span class="s1">key_share</span><span class="s4">:</span>
                <span class="s1">tmp </span><span class="s4">= </span><span class="s2">&quot; FOR KEY SHARE&quot;</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">tmp </span><span class="s4">= </span><span class="s2">&quot; FOR SHARE&quot;</span>
        <span class="s3">elif </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_for_update_arg</span><span class="s4">.</span><span class="s1">key_share</span><span class="s4">:</span>
            <span class="s1">tmp </span><span class="s4">= </span><span class="s2">&quot; FOR NO KEY UPDATE&quot;</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">tmp </span><span class="s4">= </span><span class="s2">&quot; FOR UPDATE&quot;</span>

        <span class="s3">if </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_for_update_arg</span><span class="s4">.</span><span class="s1">of</span><span class="s4">:</span>
            <span class="s1">tables </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">OrderedSet</span><span class="s4">()</span>
            <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_for_update_arg</span><span class="s4">.</span><span class="s1">of</span><span class="s4">:</span>
                <span class="s1">tables</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">sql_util</span><span class="s4">.</span><span class="s1">surface_selectables_only</span><span class="s4">(</span><span class="s1">c</span><span class="s4">))</span>

            <span class="s1">tmp </span><span class="s4">+= </span><span class="s2">&quot; OF &quot; </span><span class="s4">+ </span><span class="s2">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">table</span><span class="s4">, </span><span class="s1">ashint</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">use_schema</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">table </span><span class="s3">in </span><span class="s1">tables</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_for_update_arg</span><span class="s4">.</span><span class="s1">nowait</span><span class="s4">:</span>
            <span class="s1">tmp </span><span class="s4">+= </span><span class="s2">&quot; NOWAIT&quot;</span>
        <span class="s3">if </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_for_update_arg</span><span class="s4">.</span><span class="s1">skip_locked</span><span class="s4">:</span>
            <span class="s1">tmp </span><span class="s4">+= </span><span class="s2">&quot; SKIP LOCKED&quot;</span>

        <span class="s3">return </span><span class="s1">tmp</span>

    <span class="s3">def </span><span class="s1">visit_substring_func</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">func</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">s </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">func</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">[</span><span class="s5">0</span><span class="s4">], **</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s1">start </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">func</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">[</span><span class="s5">1</span><span class="s4">], **</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">func</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">) &gt; </span><span class="s5">2</span><span class="s4">:</span>
            <span class="s1">length </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">func</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">[</span><span class="s5">2</span><span class="s4">], **</span><span class="s1">kw</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s2">&quot;SUBSTRING(%s FROM %s FOR %s)&quot; </span><span class="s4">% (</span><span class="s1">s</span><span class="s4">, </span><span class="s1">start</span><span class="s4">, </span><span class="s1">length</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s2">&quot;SUBSTRING(%s FROM %s)&quot; </span><span class="s4">% (</span><span class="s1">s</span><span class="s4">, </span><span class="s1">start</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_on_conflict_target</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">clause</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">clause</span><span class="s4">.</span><span class="s1">constraint_target </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s0"># target may be a name of an Index, UniqueConstraint or</span>
            <span class="s0"># ExcludeConstraint.  While there is a separate</span>
            <span class="s0"># &quot;max_identifier_length&quot; for indexes, PostgreSQL uses the same</span>
            <span class="s0"># length for all objects so we can use</span>
            <span class="s0"># truncate_and_render_constraint_name</span>
            <span class="s1">target_text </span><span class="s4">= (</span>
                <span class="s2">&quot;ON CONSTRAINT %s&quot;</span>
                <span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">truncate_and_render_constraint_name</span><span class="s4">(</span>
                    <span class="s1">clause</span><span class="s4">.</span><span class="s1">constraint_target</span>
                <span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">clause</span><span class="s4">.</span><span class="s1">inferred_target_elements </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">target_text </span><span class="s4">= </span><span class="s2">&quot;(%s)&quot; </span><span class="s4">% </span><span class="s2">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
                <span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">c</span><span class="s4">, </span><span class="s1">str</span><span class="s4">)</span>
                    <span class="s3">else </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">c</span><span class="s4">, </span><span class="s1">include_table</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">use_schema</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
                <span class="s4">)</span>
                <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">clause</span><span class="s4">.</span><span class="s1">inferred_target_elements</span>
            <span class="s4">)</span>
            <span class="s3">if </span><span class="s1">clause</span><span class="s4">.</span><span class="s1">inferred_target_whereclause </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">target_text </span><span class="s4">+= </span><span class="s2">&quot; WHERE %s&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span>
                    <span class="s1">clause</span><span class="s4">.</span><span class="s1">inferred_target_whereclause</span><span class="s4">,</span>
                    <span class="s1">include_table</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                    <span class="s1">use_schema</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">target_text </span><span class="s4">= </span><span class="s2">&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">target_text</span>

    <span class="s3">def </span><span class="s1">visit_on_conflict_do_nothing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">on_conflict</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">target_text </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_on_conflict_target</span><span class="s4">(</span><span class="s1">on_conflict</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">target_text</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s2">&quot;ON CONFLICT %s DO NOTHING&quot; </span><span class="s4">% </span><span class="s1">target_text</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s2">&quot;ON CONFLICT DO NOTHING&quot;</span>

    <span class="s3">def </span><span class="s1">visit_on_conflict_do_update</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">on_conflict</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">clause </span><span class="s4">= </span><span class="s1">on_conflict</span>

        <span class="s1">target_text </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_on_conflict_target</span><span class="s4">(</span><span class="s1">on_conflict</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

        <span class="s1">action_set_ops </span><span class="s4">= []</span>

        <span class="s1">set_parameters </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">clause</span><span class="s4">.</span><span class="s1">update_values_to_set</span><span class="s4">)</span>
        <span class="s0"># create a list of column assignment clauses as tuples</span>

        <span class="s1">insert_statement </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stack</span><span class="s4">[-</span><span class="s5">1</span><span class="s4">][</span><span class="s2">&quot;selectable&quot;</span><span class="s4">]</span>
        <span class="s1">cols </span><span class="s4">= </span><span class="s1">insert_statement</span><span class="s4">.</span><span class="s1">table</span><span class="s4">.</span><span class="s1">c</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">cols</span><span class="s4">:</span>
            <span class="s1">col_key </span><span class="s4">= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">key</span>

            <span class="s3">if </span><span class="s1">col_key </span><span class="s3">in </span><span class="s1">set_parameters</span><span class="s4">:</span>
                <span class="s1">value </span><span class="s4">= </span><span class="s1">set_parameters</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">col_key</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">c </span><span class="s3">in </span><span class="s1">set_parameters</span><span class="s4">:</span>
                <span class="s1">value </span><span class="s4">= </span><span class="s1">set_parameters</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">continue</span>

            <span class="s3">if </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">_is_literal</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                <span class="s1">value </span><span class="s4">= </span><span class="s1">elements</span><span class="s4">.</span><span class="s1">BindParameter</span><span class="s4">(</span><span class="s3">None</span><span class="s4">, </span><span class="s1">value</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">=</span><span class="s1">c</span><span class="s4">.</span><span class="s1">type</span><span class="s4">)</span>

            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s4">(</span>
                    <span class="s1">isinstance</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">elements</span><span class="s4">.</span><span class="s1">BindParameter</span><span class="s4">)</span>
                    <span class="s3">and </span><span class="s1">value</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">_isnull</span>
                <span class="s4">):</span>
                    <span class="s1">value </span><span class="s4">= </span><span class="s1">value</span><span class="s4">.</span><span class="s1">_clone</span><span class="s4">()</span>
                    <span class="s1">value</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">type</span>
            <span class="s1">value_text </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">(), </span><span class="s1">use_schema</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

            <span class="s1">key_text </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">(</span><span class="s1">c</span><span class="s4">.</span><span class="s1">name</span><span class="s4">)</span>
            <span class="s1">action_set_ops</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s2">&quot;%s = %s&quot; </span><span class="s4">% (</span><span class="s1">key_text</span><span class="s4">, </span><span class="s1">value_text</span><span class="s4">))</span>

        <span class="s0"># check for names that don't match columns</span>
        <span class="s3">if </span><span class="s1">set_parameters</span><span class="s4">:</span>
            <span class="s1">util</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                <span class="s2">&quot;Additional column names not matching &quot;</span>
                <span class="s2">&quot;any column keys in table '%s': %s&quot;</span>
                <span class="s4">% (</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">current_executable</span><span class="s4">.</span><span class="s1">table</span><span class="s4">.</span><span class="s1">name</span><span class="s4">,</span>
                    <span class="s4">(</span><span class="s2">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s2">&quot;'%s'&quot; </span><span class="s4">% </span><span class="s1">c </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">set_parameters</span><span class="s4">)),</span>
                <span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">set_parameters</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
                <span class="s1">key_text </span><span class="s4">= (</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">(</span><span class="s1">k</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">k</span><span class="s4">, </span><span class="s1">str</span><span class="s4">)</span>
                    <span class="s3">else </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">k</span><span class="s4">, </span><span class="s1">use_schema</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
                <span class="s4">)</span>
                <span class="s1">value_text </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span>
                    <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">, </span><span class="s1">v</span><span class="s4">),</span>
                    <span class="s1">use_schema</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                <span class="s4">)</span>
                <span class="s1">action_set_ops</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s2">&quot;%s = %s&quot; </span><span class="s4">% (</span><span class="s1">key_text</span><span class="s4">, </span><span class="s1">value_text</span><span class="s4">))</span>

        <span class="s1">action_text </span><span class="s4">= </span><span class="s2">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">action_set_ops</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">clause</span><span class="s4">.</span><span class="s1">update_whereclause </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">action_text </span><span class="s4">+= </span><span class="s2">&quot; WHERE %s&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span>
                <span class="s1">clause</span><span class="s4">.</span><span class="s1">update_whereclause</span><span class="s4">, </span><span class="s1">include_table</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">use_schema</span><span class="s4">=</span><span class="s3">False</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s2">&quot;ON CONFLICT %s DO UPDATE SET %s&quot; </span><span class="s4">% (</span><span class="s1">target_text</span><span class="s4">, </span><span class="s1">action_text</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">update_from_clause</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">update_stmt</span><span class="s4">, </span><span class="s1">from_table</span><span class="s4">, </span><span class="s1">extra_froms</span><span class="s4">, </span><span class="s1">from_hints</span><span class="s4">, **</span><span class="s1">kw</span>
    <span class="s4">):</span>
        <span class="s1">kw</span><span class="s4">[</span><span class="s2">&quot;asfrom&quot;</span><span class="s4">] = </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s2">&quot;FROM &quot; </span><span class="s4">+ </span><span class="s2">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
            <span class="s1">t</span><span class="s4">.</span><span class="s1">_compiler_dispatch</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fromhints</span><span class="s4">=</span><span class="s1">from_hints</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
            <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">extra_froms</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">delete_extra_from_clause</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">delete_stmt</span><span class="s4">, </span><span class="s1">from_table</span><span class="s4">, </span><span class="s1">extra_froms</span><span class="s4">, </span><span class="s1">from_hints</span><span class="s4">, **</span><span class="s1">kw</span>
    <span class="s4">):</span>
        <span class="s6">&quot;&quot;&quot;Render the DELETE .. USING clause specific to PostgreSQL.&quot;&quot;&quot;</span>
        <span class="s1">kw</span><span class="s4">[</span><span class="s2">&quot;asfrom&quot;</span><span class="s4">] = </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s2">&quot;USING &quot; </span><span class="s4">+ </span><span class="s2">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
            <span class="s1">t</span><span class="s4">.</span><span class="s1">_compiler_dispatch</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fromhints</span><span class="s4">=</span><span class="s1">from_hints</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
            <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">extra_froms</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">fetch_clause</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">select</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s0"># pg requires parens for non literal clauses. It's also required for</span>
        <span class="s0"># bind parameters if a ::type casts is used by the driver (asyncpg),</span>
        <span class="s0"># so it's easiest to just always add it</span>
        <span class="s1">text </span><span class="s4">= </span><span class="s2">&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_offset_clause </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot;</span><span class="s3">\n </span><span class="s2">OFFSET (%s) ROWS&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span>
                <span class="s1">select</span><span class="s4">.</span><span class="s1">_offset_clause</span><span class="s4">, **</span><span class="s1">kw</span>
            <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_fetch_clause </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot;</span><span class="s3">\n </span><span class="s2">FETCH FIRST (%s)%s ROWS %s&quot; </span><span class="s4">% (</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">select</span><span class="s4">.</span><span class="s1">_fetch_clause</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),</span>
                <span class="s2">&quot; PERCENT&quot; </span><span class="s3">if </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_fetch_clause_options</span><span class="s4">[</span><span class="s2">&quot;percent&quot;</span><span class="s4">] </span><span class="s3">else </span><span class="s2">&quot;&quot;</span><span class="s4">,</span>
                <span class="s4">(</span>
                    <span class="s2">&quot;WITH TIES&quot;</span>
                    <span class="s3">if </span><span class="s1">select</span><span class="s4">.</span><span class="s1">_fetch_clause_options</span><span class="s4">[</span><span class="s2">&quot;with_ties&quot;</span><span class="s4">]</span>
                    <span class="s3">else </span><span class="s2">&quot;ONLY&quot;</span>
                <span class="s4">),</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">text</span>


<span class="s3">class </span><span class="s1">PGDDLCompiler</span><span class="s4">(</span><span class="s1">compiler</span><span class="s4">.</span><span class="s1">DDLCompiler</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">get_column_specification</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s1">colspec </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">format_column</span><span class="s4">(</span><span class="s1">column</span><span class="s4">)</span>
        <span class="s1">impl_type </span><span class="s4">= </span><span class="s1">column</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">dialect_impl</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">impl_type</span><span class="s4">, </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">TypeDecorator</span><span class="s4">):</span>
            <span class="s1">impl_type </span><span class="s4">= </span><span class="s1">impl_type</span><span class="s4">.</span><span class="s1">impl</span>

        <span class="s1">has_identity </span><span class="s4">= (</span>
            <span class="s1">column</span><span class="s4">.</span><span class="s1">identity </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">supports_identity_columns</span>
        <span class="s4">)</span>

        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">column</span><span class="s4">.</span><span class="s1">primary_key</span>
            <span class="s3">and </span><span class="s1">column </span><span class="s3">is </span><span class="s1">column</span><span class="s4">.</span><span class="s1">table</span><span class="s4">.</span><span class="s1">_autoincrement_column</span>
            <span class="s3">and </span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">supports_smallserial</span>
                <span class="s3">or not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">impl_type</span><span class="s4">, </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">SmallInteger</span><span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s3">and not </span><span class="s1">has_identity</span>
            <span class="s3">and </span><span class="s4">(</span>
                <span class="s1">column</span><span class="s4">.</span><span class="s1">default </span><span class="s3">is None</span>
                <span class="s3">or </span><span class="s4">(</span>
                    <span class="s1">isinstance</span><span class="s4">(</span><span class="s1">column</span><span class="s4">.</span><span class="s1">default</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">.</span><span class="s1">Sequence</span><span class="s4">)</span>
                    <span class="s3">and </span><span class="s1">column</span><span class="s4">.</span><span class="s1">default</span><span class="s4">.</span><span class="s1">optional</span>
                <span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s4">):</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">impl_type</span><span class="s4">, </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">BigInteger</span><span class="s4">):</span>
                <span class="s1">colspec </span><span class="s4">+= </span><span class="s2">&quot; BIGSERIAL&quot;</span>
            <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">impl_type</span><span class="s4">, </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">SmallInteger</span><span class="s4">):</span>
                <span class="s1">colspec </span><span class="s4">+= </span><span class="s2">&quot; SMALLSERIAL&quot;</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">colspec </span><span class="s4">+= </span><span class="s2">&quot; SERIAL&quot;</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">colspec </span><span class="s4">+= </span><span class="s2">&quot; &quot; </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">type_compiler_instance</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span>
                <span class="s1">column</span><span class="s4">.</span><span class="s1">type</span><span class="s4">,</span>
                <span class="s1">type_expression</span><span class="s4">=</span><span class="s1">column</span><span class="s4">,</span>
                <span class="s1">identifier_preparer</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s1">default </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_column_default_string</span><span class="s4">(</span><span class="s1">column</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">default </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">colspec </span><span class="s4">+= </span><span class="s2">&quot; DEFAULT &quot; </span><span class="s4">+ </span><span class="s1">default</span>

        <span class="s3">if </span><span class="s1">column</span><span class="s4">.</span><span class="s1">computed </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">colspec </span><span class="s4">+= </span><span class="s2">&quot; &quot; </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">column</span><span class="s4">.</span><span class="s1">computed</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">has_identity</span><span class="s4">:</span>
            <span class="s1">colspec </span><span class="s4">+= </span><span class="s2">&quot; &quot; </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">column</span><span class="s4">.</span><span class="s1">identity</span><span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">column</span><span class="s4">.</span><span class="s1">nullable </span><span class="s3">and not </span><span class="s1">has_identity</span><span class="s4">:</span>
            <span class="s1">colspec </span><span class="s4">+= </span><span class="s2">&quot; NOT NULL&quot;</span>
        <span class="s3">elif </span><span class="s1">column</span><span class="s4">.</span><span class="s1">nullable </span><span class="s3">and </span><span class="s1">has_identity</span><span class="s4">:</span>
            <span class="s1">colspec </span><span class="s4">+= </span><span class="s2">&quot; NULL&quot;</span>
        <span class="s3">return </span><span class="s1">colspec</span>

    <span class="s3">def </span><span class="s1">_define_constraint_validity</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">constraint</span><span class="s4">):</span>
        <span class="s1">not_valid </span><span class="s4">= </span><span class="s1">constraint</span><span class="s4">.</span><span class="s1">dialect_options</span><span class="s4">[</span><span class="s2">&quot;postgresql&quot;</span><span class="s4">][</span><span class="s2">&quot;not_valid&quot;</span><span class="s4">]</span>
        <span class="s3">return </span><span class="s2">&quot; NOT VALID&quot; </span><span class="s3">if </span><span class="s1">not_valid </span><span class="s3">else </span><span class="s2">&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">visit_check_constraint</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">constraint</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">constraint</span><span class="s4">.</span><span class="s1">_type_bound</span><span class="s4">:</span>
            <span class="s1">typ </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">constraint</span><span class="s4">.</span><span class="s1">columns</span><span class="s4">)[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">type</span>
            <span class="s3">if </span><span class="s4">(</span>
                <span class="s1">isinstance</span><span class="s4">(</span><span class="s1">typ</span><span class="s4">, </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">ARRAY</span><span class="s4">)</span>
                <span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">typ</span><span class="s4">.</span><span class="s1">item_type</span><span class="s4">, </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">Enum</span><span class="s4">)</span>
                <span class="s3">and not </span><span class="s1">typ</span><span class="s4">.</span><span class="s1">item_type</span><span class="s4">.</span><span class="s1">native_enum</span>
            <span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">CompileError</span><span class="s4">(</span>
                    <span class="s2">&quot;PostgreSQL dialect cannot produce the CHECK constraint &quot;</span>
                    <span class="s2">&quot;for ARRAY of non-native ENUM; please specify &quot;</span>
                    <span class="s2">&quot;create_constraint=False on this Enum datatype.&quot;</span>
                <span class="s4">)</span>

        <span class="s1">text </span><span class="s4">= </span><span class="s1">super</span><span class="s4">().</span><span class="s1">visit_check_constraint</span><span class="s4">(</span><span class="s1">constraint</span><span class="s4">)</span>
        <span class="s1">text </span><span class="s4">+= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_define_constraint_validity</span><span class="s4">(</span><span class="s1">constraint</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_foreign_key_constraint</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">constraint</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">text </span><span class="s4">= </span><span class="s1">super</span><span class="s4">().</span><span class="s1">visit_foreign_key_constraint</span><span class="s4">(</span><span class="s1">constraint</span><span class="s4">)</span>
        <span class="s1">text </span><span class="s4">+= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_define_constraint_validity</span><span class="s4">(</span><span class="s1">constraint</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_create_enum_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">create</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">type_ </span><span class="s4">= </span><span class="s1">create</span><span class="s4">.</span><span class="s1">element</span>

        <span class="s3">return </span><span class="s2">&quot;CREATE TYPE %s AS ENUM (%s)&quot; </span><span class="s4">% (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">format_type</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">),</span>
            <span class="s2">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">sql_compiler</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">literal</span><span class="s4">(</span><span class="s1">e</span><span class="s4">), </span><span class="s1">literal_binds</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">enums</span>
            <span class="s4">),</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_drop_enum_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">drop</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">type_ </span><span class="s4">= </span><span class="s1">drop</span><span class="s4">.</span><span class="s1">element</span>

        <span class="s3">return </span><span class="s2">&quot;DROP TYPE %s&quot; </span><span class="s4">% (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">format_type</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">visit_create_domain_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">create</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">domain</span><span class="s4">: </span><span class="s1">DOMAIN </span><span class="s4">= </span><span class="s1">create</span><span class="s4">.</span><span class="s1">element</span>

        <span class="s1">options </span><span class="s4">= []</span>
        <span class="s3">if </span><span class="s1">domain</span><span class="s4">.</span><span class="s1">collation </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">options</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s2">f&quot;COLLATE </span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">(</span><span class="s1">domain</span><span class="s4">.</span><span class="s1">collation</span><span class="s4">)</span><span class="s3">}</span><span class="s2">&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">domain</span><span class="s4">.</span><span class="s1">default </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">default </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">render_default_string</span><span class="s4">(</span><span class="s1">domain</span><span class="s4">.</span><span class="s1">default</span><span class="s4">)</span>
            <span class="s1">options</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s2">f&quot;DEFAULT </span><span class="s3">{</span><span class="s1">default</span><span class="s3">}</span><span class="s2">&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">domain</span><span class="s4">.</span><span class="s1">constraint_name </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">truncate_and_render_constraint_name</span><span class="s4">(</span>
                <span class="s1">domain</span><span class="s4">.</span><span class="s1">constraint_name</span>
            <span class="s4">)</span>
            <span class="s1">options</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s2">f&quot;CONSTRAINT </span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">domain</span><span class="s4">.</span><span class="s1">not_null</span><span class="s4">:</span>
            <span class="s1">options</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s2">&quot;NOT NULL&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">domain</span><span class="s4">.</span><span class="s1">check </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">check </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">sql_compiler</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span>
                <span class="s1">domain</span><span class="s4">.</span><span class="s1">check</span><span class="s4">, </span><span class="s1">include_table</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">literal_binds</span><span class="s4">=</span><span class="s3">True</span>
            <span class="s4">)</span>
            <span class="s1">options</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s2">f&quot;CHECK (</span><span class="s3">{</span><span class="s1">check</span><span class="s3">}</span><span class="s2">)&quot;</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s4">(</span>
            <span class="s2">f&quot;CREATE DOMAIN </span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">format_type</span><span class="s4">(</span><span class="s1">domain</span><span class="s4">)</span><span class="s3">} </span><span class="s2">AS &quot;</span>
            <span class="s2">f&quot;</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">type_compiler</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">domain</span><span class="s4">.</span><span class="s1">data_type</span><span class="s4">)</span><span class="s3">} </span><span class="s2">&quot;</span>
            <span class="s2">f&quot;</span><span class="s3">{</span><span class="s2">' '</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">options</span><span class="s4">)</span><span class="s3">}</span><span class="s2">&quot;</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_drop_domain_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">drop</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">domain </span><span class="s4">= </span><span class="s1">drop</span><span class="s4">.</span><span class="s1">element</span>
        <span class="s3">return </span><span class="s2">f&quot;DROP DOMAIN </span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">format_type</span><span class="s4">(</span><span class="s1">domain</span><span class="s4">)</span><span class="s3">}</span><span class="s2">&quot;</span>

    <span class="s3">def </span><span class="s1">visit_create_index</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">create</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">preparer </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span>
        <span class="s1">index </span><span class="s4">= </span><span class="s1">create</span><span class="s4">.</span><span class="s1">element</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_verify_index_table</span><span class="s4">(</span><span class="s1">index</span><span class="s4">)</span>
        <span class="s1">text </span><span class="s4">= </span><span class="s2">&quot;CREATE &quot;</span>
        <span class="s3">if </span><span class="s1">index</span><span class="s4">.</span><span class="s1">unique</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot;UNIQUE &quot;</span>

        <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot;INDEX &quot;</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">_supports_create_index_concurrently</span><span class="s4">:</span>
            <span class="s1">concurrently </span><span class="s4">= </span><span class="s1">index</span><span class="s4">.</span><span class="s1">dialect_options</span><span class="s4">[</span><span class="s2">&quot;postgresql&quot;</span><span class="s4">][</span><span class="s2">&quot;concurrently&quot;</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">concurrently</span><span class="s4">:</span>
                <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot;CONCURRENTLY &quot;</span>

        <span class="s3">if </span><span class="s1">create</span><span class="s4">.</span><span class="s1">if_not_exists</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot;IF NOT EXISTS &quot;</span>

        <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot;%s ON %s &quot; </span><span class="s4">% (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_prepared_index_name</span><span class="s4">(</span><span class="s1">index</span><span class="s4">, </span><span class="s1">include_schema</span><span class="s4">=</span><span class="s3">False</span><span class="s4">),</span>
            <span class="s1">preparer</span><span class="s4">.</span><span class="s1">format_table</span><span class="s4">(</span><span class="s1">index</span><span class="s4">.</span><span class="s1">table</span><span class="s4">),</span>
        <span class="s4">)</span>

        <span class="s1">using </span><span class="s4">= </span><span class="s1">index</span><span class="s4">.</span><span class="s1">dialect_options</span><span class="s4">[</span><span class="s2">&quot;postgresql&quot;</span><span class="s4">][</span><span class="s2">&quot;using&quot;</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">using</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= (</span>
                <span class="s2">&quot;USING %s &quot;</span>
                <span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">validate_sql_phrase</span><span class="s4">(</span><span class="s1">using</span><span class="s4">, </span><span class="s1">IDX_USING</span><span class="s4">).</span><span class="s1">lower</span><span class="s4">()</span>
            <span class="s4">)</span>

        <span class="s1">ops </span><span class="s4">= </span><span class="s1">index</span><span class="s4">.</span><span class="s1">dialect_options</span><span class="s4">[</span><span class="s2">&quot;postgresql&quot;</span><span class="s4">][</span><span class="s2">&quot;ops&quot;</span><span class="s4">]</span>
        <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot;(%s)&quot; </span><span class="s4">% (</span>
            <span class="s2">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
                <span class="s4">[</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">sql_compiler</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span>
                        <span class="s4">(</span>
                            <span class="s1">expr</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">()</span>
                            <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">, </span><span class="s1">expression</span><span class="s4">.</span><span class="s1">ColumnClause</span><span class="s4">)</span>
                            <span class="s3">else </span><span class="s1">expr</span>
                        <span class="s4">),</span>
                        <span class="s1">include_table</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                        <span class="s1">literal_binds</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                    <span class="s4">)</span>
                    <span class="s4">+ (</span>
                        <span class="s4">(</span><span class="s2">&quot; &quot; </span><span class="s4">+ </span><span class="s1">ops</span><span class="s4">[</span><span class="s1">expr</span><span class="s4">.</span><span class="s1">key</span><span class="s4">])</span>
                        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">, </span><span class="s2">&quot;key&quot;</span><span class="s4">) </span><span class="s3">and </span><span class="s1">expr</span><span class="s4">.</span><span class="s1">key </span><span class="s3">in </span><span class="s1">ops</span>
                        <span class="s3">else </span><span class="s2">&quot;&quot;</span>
                    <span class="s4">)</span>
                    <span class="s3">for </span><span class="s1">expr </span><span class="s3">in </span><span class="s1">index</span><span class="s4">.</span><span class="s1">expressions</span>
                <span class="s4">]</span>
            <span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s1">includeclause </span><span class="s4">= </span><span class="s1">index</span><span class="s4">.</span><span class="s1">dialect_options</span><span class="s4">[</span><span class="s2">&quot;postgresql&quot;</span><span class="s4">][</span><span class="s2">&quot;include&quot;</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">includeclause</span><span class="s4">:</span>
            <span class="s1">inclusions </span><span class="s4">= [</span>
                <span class="s1">index</span><span class="s4">.</span><span class="s1">table</span><span class="s4">.</span><span class="s1">c</span><span class="s4">[</span><span class="s1">col</span><span class="s4">] </span><span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">col</span><span class="s4">, </span><span class="s1">str</span><span class="s4">) </span><span class="s3">else </span><span class="s1">col</span>
                <span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">includeclause</span>
            <span class="s4">]</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot; INCLUDE (%s)&quot; </span><span class="s4">% </span><span class="s2">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
                <span class="s4">[</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">(</span><span class="s1">c</span><span class="s4">.</span><span class="s1">name</span><span class="s4">) </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">inclusions</span><span class="s4">]</span>
            <span class="s4">)</span>

        <span class="s1">nulls_not_distinct </span><span class="s4">= </span><span class="s1">index</span><span class="s4">.</span><span class="s1">dialect_options</span><span class="s4">[</span><span class="s2">&quot;postgresql&quot;</span><span class="s4">][</span>
            <span class="s2">&quot;nulls_not_distinct&quot;</span>
        <span class="s4">]</span>
        <span class="s3">if </span><span class="s1">nulls_not_distinct </span><span class="s3">is True</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot; NULLS NOT DISTINCT&quot;</span>
        <span class="s3">elif </span><span class="s1">nulls_not_distinct </span><span class="s3">is False</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot; NULLS DISTINCT&quot;</span>

        <span class="s1">withclause </span><span class="s4">= </span><span class="s1">index</span><span class="s4">.</span><span class="s1">dialect_options</span><span class="s4">[</span><span class="s2">&quot;postgresql&quot;</span><span class="s4">][</span><span class="s2">&quot;with&quot;</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">withclause</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot; WITH (%s)&quot; </span><span class="s4">% (</span>
                <span class="s2">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
                    <span class="s4">[</span>
                        <span class="s2">&quot;%s = %s&quot; </span><span class="s4">% </span><span class="s1">storage_parameter</span>
                        <span class="s3">for </span><span class="s1">storage_parameter </span><span class="s3">in </span><span class="s1">withclause</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()</span>
                    <span class="s4">]</span>
                <span class="s4">)</span>
            <span class="s4">)</span>

        <span class="s1">tablespace_name </span><span class="s4">= </span><span class="s1">index</span><span class="s4">.</span><span class="s1">dialect_options</span><span class="s4">[</span><span class="s2">&quot;postgresql&quot;</span><span class="s4">][</span><span class="s2">&quot;tablespace&quot;</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">tablespace_name</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot; TABLESPACE %s&quot; </span><span class="s4">% </span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">(</span><span class="s1">tablespace_name</span><span class="s4">)</span>

        <span class="s1">whereclause </span><span class="s4">= </span><span class="s1">index</span><span class="s4">.</span><span class="s1">dialect_options</span><span class="s4">[</span><span class="s2">&quot;postgresql&quot;</span><span class="s4">][</span><span class="s2">&quot;where&quot;</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">whereclause </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">whereclause </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                <span class="s1">roles</span><span class="s4">.</span><span class="s1">DDLExpressionRole</span><span class="s4">, </span><span class="s1">whereclause</span>
            <span class="s4">)</span>

            <span class="s1">where_compiled </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">sql_compiler</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span>
                <span class="s1">whereclause</span><span class="s4">, </span><span class="s1">include_table</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">literal_binds</span><span class="s4">=</span><span class="s3">True</span>
            <span class="s4">)</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot; WHERE &quot; </span><span class="s4">+ </span><span class="s1">where_compiled</span>

        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">define_unique_constraint_distinct</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">constraint</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">nulls_not_distinct </span><span class="s4">= </span><span class="s1">constraint</span><span class="s4">.</span><span class="s1">dialect_options</span><span class="s4">[</span><span class="s2">&quot;postgresql&quot;</span><span class="s4">][</span>
            <span class="s2">&quot;nulls_not_distinct&quot;</span>
        <span class="s4">]</span>
        <span class="s3">if </span><span class="s1">nulls_not_distinct </span><span class="s3">is True</span><span class="s4">:</span>
            <span class="s1">nulls_not_distinct_param </span><span class="s4">= </span><span class="s2">&quot;NULLS NOT DISTINCT &quot;</span>
        <span class="s3">elif </span><span class="s1">nulls_not_distinct </span><span class="s3">is False</span><span class="s4">:</span>
            <span class="s1">nulls_not_distinct_param </span><span class="s4">= </span><span class="s2">&quot;NULLS DISTINCT &quot;</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">nulls_not_distinct_param </span><span class="s4">= </span><span class="s2">&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">nulls_not_distinct_param</span>

    <span class="s3">def </span><span class="s1">visit_drop_index</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">drop</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">index </span><span class="s4">= </span><span class="s1">drop</span><span class="s4">.</span><span class="s1">element</span>

        <span class="s1">text </span><span class="s4">= </span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">DROP INDEX &quot;</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">_supports_drop_index_concurrently</span><span class="s4">:</span>
            <span class="s1">concurrently </span><span class="s4">= </span><span class="s1">index</span><span class="s4">.</span><span class="s1">dialect_options</span><span class="s4">[</span><span class="s2">&quot;postgresql&quot;</span><span class="s4">][</span><span class="s2">&quot;concurrently&quot;</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">concurrently</span><span class="s4">:</span>
                <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot;CONCURRENTLY &quot;</span>

        <span class="s3">if </span><span class="s1">drop</span><span class="s4">.</span><span class="s1">if_exists</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot;IF EXISTS &quot;</span>

        <span class="s1">text </span><span class="s4">+= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prepared_index_name</span><span class="s4">(</span><span class="s1">index</span><span class="s4">, </span><span class="s1">include_schema</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_exclude_constraint</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">constraint</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">text </span><span class="s4">= </span><span class="s2">&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">constraint</span><span class="s4">.</span><span class="s1">name </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot;CONSTRAINT %s &quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">format_constraint</span><span class="s4">(</span>
                <span class="s1">constraint</span>
            <span class="s4">)</span>
        <span class="s1">elements </span><span class="s4">= []</span>
        <span class="s1">kw</span><span class="s4">[</span><span class="s2">&quot;include_table&quot;</span><span class="s4">] = </span><span class="s3">False</span>
        <span class="s1">kw</span><span class="s4">[</span><span class="s2">&quot;literal_binds&quot;</span><span class="s4">] = </span><span class="s3">True</span>
        <span class="s3">for </span><span class="s1">expr</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">op </span><span class="s3">in </span><span class="s1">constraint</span><span class="s4">.</span><span class="s1">_render_exprs</span><span class="s4">:</span>
            <span class="s1">exclude_element </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">sql_compiler</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">) + (</span>
                <span class="s4">(</span><span class="s2">&quot; &quot; </span><span class="s4">+ </span><span class="s1">constraint</span><span class="s4">.</span><span class="s1">ops</span><span class="s4">[</span><span class="s1">expr</span><span class="s4">.</span><span class="s1">key</span><span class="s4">])</span>
                <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">, </span><span class="s2">&quot;key&quot;</span><span class="s4">) </span><span class="s3">and </span><span class="s1">expr</span><span class="s4">.</span><span class="s1">key </span><span class="s3">in </span><span class="s1">constraint</span><span class="s4">.</span><span class="s1">ops</span>
                <span class="s3">else </span><span class="s2">&quot;&quot;</span>
            <span class="s4">)</span>

            <span class="s1">elements</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s2">&quot;%s WITH %s&quot; </span><span class="s4">% (</span><span class="s1">exclude_element</span><span class="s4">, </span><span class="s1">op</span><span class="s4">))</span>
        <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot;EXCLUDE USING %s (%s)&quot; </span><span class="s4">% (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">validate_sql_phrase</span><span class="s4">(</span>
                <span class="s1">constraint</span><span class="s4">.</span><span class="s1">using</span><span class="s4">, </span><span class="s1">IDX_USING</span>
            <span class="s4">).</span><span class="s1">lower</span><span class="s4">(),</span>
            <span class="s2">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">elements</span><span class="s4">),</span>
        <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">constraint</span><span class="s4">.</span><span class="s1">where </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot; WHERE (%s)&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">sql_compiler</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span>
                <span class="s1">constraint</span><span class="s4">.</span><span class="s1">where</span><span class="s4">, </span><span class="s1">literal_binds</span><span class="s4">=</span><span class="s3">True</span>
            <span class="s4">)</span>
        <span class="s1">text </span><span class="s4">+= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">define_constraint_deferrability</span><span class="s4">(</span><span class="s1">constraint</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">post_create_table</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">table</span><span class="s4">):</span>
        <span class="s1">table_opts </span><span class="s4">= []</span>
        <span class="s1">pg_opts </span><span class="s4">= </span><span class="s1">table</span><span class="s4">.</span><span class="s1">dialect_options</span><span class="s4">[</span><span class="s2">&quot;postgresql&quot;</span><span class="s4">]</span>

        <span class="s1">inherits </span><span class="s4">= </span><span class="s1">pg_opts</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s2">&quot;inherits&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">inherits </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">inherits</span><span class="s4">, (</span><span class="s1">list</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">)):</span>
                <span class="s1">inherits </span><span class="s4">= (</span><span class="s1">inherits</span><span class="s4">,)</span>
            <span class="s1">table_opts</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span>
                <span class="s2">&quot;</span><span class="s3">\n </span><span class="s2">INHERITS ( &quot;</span>
                <span class="s4">+ </span><span class="s2">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">(</span><span class="s1">name</span><span class="s4">) </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">inherits</span><span class="s4">)</span>
                <span class="s4">+ </span><span class="s2">&quot; )&quot;</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">pg_opts</span><span class="s4">[</span><span class="s2">&quot;partition_by&quot;</span><span class="s4">]:</span>
            <span class="s1">table_opts</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s2">&quot;</span><span class="s3">\n </span><span class="s2">PARTITION BY %s&quot; </span><span class="s4">% </span><span class="s1">pg_opts</span><span class="s4">[</span><span class="s2">&quot;partition_by&quot;</span><span class="s4">])</span>

        <span class="s3">if </span><span class="s1">pg_opts</span><span class="s4">[</span><span class="s2">&quot;using&quot;</span><span class="s4">]:</span>
            <span class="s1">table_opts</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s2">&quot;</span><span class="s3">\n </span><span class="s2">USING %s&quot; </span><span class="s4">% </span><span class="s1">pg_opts</span><span class="s4">[</span><span class="s2">&quot;using&quot;</span><span class="s4">])</span>

        <span class="s3">if </span><span class="s1">pg_opts</span><span class="s4">[</span><span class="s2">&quot;with_oids&quot;</span><span class="s4">] </span><span class="s3">is True</span><span class="s4">:</span>
            <span class="s1">table_opts</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s2">&quot;</span><span class="s3">\n </span><span class="s2">WITH OIDS&quot;</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">pg_opts</span><span class="s4">[</span><span class="s2">&quot;with_oids&quot;</span><span class="s4">] </span><span class="s3">is False</span><span class="s4">:</span>
            <span class="s1">table_opts</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s2">&quot;</span><span class="s3">\n </span><span class="s2">WITHOUT OIDS&quot;</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">pg_opts</span><span class="s4">[</span><span class="s2">&quot;on_commit&quot;</span><span class="s4">]:</span>
            <span class="s1">on_commit_options </span><span class="s4">= </span><span class="s1">pg_opts</span><span class="s4">[</span><span class="s2">&quot;on_commit&quot;</span><span class="s4">].</span><span class="s1">replace</span><span class="s4">(</span><span class="s2">&quot;_&quot;</span><span class="s4">, </span><span class="s2">&quot; &quot;</span><span class="s4">).</span><span class="s1">upper</span><span class="s4">()</span>
            <span class="s1">table_opts</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s2">&quot;</span><span class="s3">\n </span><span class="s2">ON COMMIT %s&quot; </span><span class="s4">% </span><span class="s1">on_commit_options</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">pg_opts</span><span class="s4">[</span><span class="s2">&quot;tablespace&quot;</span><span class="s4">]:</span>
            <span class="s1">tablespace_name </span><span class="s4">= </span><span class="s1">pg_opts</span><span class="s4">[</span><span class="s2">&quot;tablespace&quot;</span><span class="s4">]</span>
            <span class="s1">table_opts</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span>
                <span class="s2">&quot;</span><span class="s3">\n </span><span class="s2">TABLESPACE %s&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">(</span><span class="s1">tablespace_name</span><span class="s4">)</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s2">&quot;&quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">table_opts</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_computed_column</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">generated</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">generated</span><span class="s4">.</span><span class="s1">persisted </span><span class="s3">is False</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">CompileError</span><span class="s4">(</span>
                <span class="s2">&quot;PostrgreSQL computed columns do not support 'virtual' &quot;</span>
                <span class="s2">&quot;persistence; set the 'persisted' flag to None or True for &quot;</span>
                <span class="s2">&quot;PostgreSQL support.&quot;</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s2">&quot;GENERATED ALWAYS AS (%s) STORED&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">sql_compiler</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span>
            <span class="s1">generated</span><span class="s4">.</span><span class="s1">sqltext</span><span class="s4">, </span><span class="s1">include_table</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">literal_binds</span><span class="s4">=</span><span class="s3">True</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_create_sequence</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">create</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">prefix </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">create</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">data_type </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">prefix </span><span class="s4">= </span><span class="s2">&quot; AS %s&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type_compiler</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span>
                <span class="s1">create</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">data_type</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">visit_create_sequence</span><span class="s4">(</span><span class="s1">create</span><span class="s4">, </span><span class="s1">prefix</span><span class="s4">=</span><span class="s1">prefix</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_can_comment_on_constraint</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">ddl_instance</span><span class="s4">):</span>
        <span class="s1">constraint </span><span class="s4">= </span><span class="s1">ddl_instance</span><span class="s4">.</span><span class="s1">element</span>
        <span class="s3">if </span><span class="s1">constraint</span><span class="s4">.</span><span class="s1">name </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">CompileError</span><span class="s4">(</span>
                <span class="s2">f&quot;Can't emit COMMENT ON for constraint </span><span class="s3">{</span><span class="s1">constraint</span><span class="s3">!r}</span><span class="s2">: &quot;</span>
                <span class="s2">&quot;it has no name&quot;</span>
            <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">constraint</span><span class="s4">.</span><span class="s1">table </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">CompileError</span><span class="s4">(</span>
                <span class="s2">f&quot;Can't emit COMMENT ON for constraint </span><span class="s3">{</span><span class="s1">constraint</span><span class="s3">!r}</span><span class="s2">: &quot;</span>
                <span class="s2">&quot;it has no associated table&quot;</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_set_constraint_comment</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">create</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_can_comment_on_constraint</span><span class="s4">(</span><span class="s1">create</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s2">&quot;COMMENT ON CONSTRAINT %s ON %s IS %s&quot; </span><span class="s4">% (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">format_constraint</span><span class="s4">(</span><span class="s1">create</span><span class="s4">.</span><span class="s1">element</span><span class="s4">),</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">format_table</span><span class="s4">(</span><span class="s1">create</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">table</span><span class="s4">),</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">sql_compiler</span><span class="s4">.</span><span class="s1">render_literal_value</span><span class="s4">(</span>
                <span class="s1">create</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">comment</span><span class="s4">, </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">String</span><span class="s4">()</span>
            <span class="s4">),</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_drop_constraint_comment</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">drop</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_can_comment_on_constraint</span><span class="s4">(</span><span class="s1">drop</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s2">&quot;COMMENT ON CONSTRAINT %s ON %s IS NULL&quot; </span><span class="s4">% (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">format_constraint</span><span class="s4">(</span><span class="s1">drop</span><span class="s4">.</span><span class="s1">element</span><span class="s4">),</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">format_table</span><span class="s4">(</span><span class="s1">drop</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">table</span><span class="s4">),</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">PGTypeCompiler</span><span class="s4">(</span><span class="s1">compiler</span><span class="s4">.</span><span class="s1">GenericTypeCompiler</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">visit_TSVECTOR</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;TSVECTOR&quot;</span>

    <span class="s3">def </span><span class="s1">visit_TSQUERY</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;TSQUERY&quot;</span>

    <span class="s3">def </span><span class="s1">visit_INET</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;INET&quot;</span>

    <span class="s3">def </span><span class="s1">visit_CIDR</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;CIDR&quot;</span>

    <span class="s3">def </span><span class="s1">visit_CITEXT</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;CITEXT&quot;</span>

    <span class="s3">def </span><span class="s1">visit_MACADDR</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;MACADDR&quot;</span>

    <span class="s3">def </span><span class="s1">visit_MACADDR8</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;MACADDR8&quot;</span>

    <span class="s3">def </span><span class="s1">visit_MONEY</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;MONEY&quot;</span>

    <span class="s3">def </span><span class="s1">visit_OID</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;OID&quot;</span>

    <span class="s3">def </span><span class="s1">visit_REGCONFIG</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;REGCONFIG&quot;</span>

    <span class="s3">def </span><span class="s1">visit_REGCLASS</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;REGCLASS&quot;</span>

    <span class="s3">def </span><span class="s1">visit_FLOAT</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">precision</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s2">&quot;FLOAT&quot;</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s2">&quot;FLOAT(%(precision)s)&quot; </span><span class="s4">% {</span><span class="s2">&quot;precision&quot;</span><span class="s4">: </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">precision</span><span class="s4">}</span>

    <span class="s3">def </span><span class="s1">visit_double</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">visit_DOUBLE_PRECISION</span><span class="s4">(</span><span class="s1">type</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_BIGINT</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;BIGINT&quot;</span>

    <span class="s3">def </span><span class="s1">visit_HSTORE</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;HSTORE&quot;</span>

    <span class="s3">def </span><span class="s1">visit_JSON</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;JSON&quot;</span>

    <span class="s3">def </span><span class="s1">visit_JSONB</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;JSONB&quot;</span>

    <span class="s3">def </span><span class="s1">visit_INT4MULTIRANGE</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;INT4MULTIRANGE&quot;</span>

    <span class="s3">def </span><span class="s1">visit_INT8MULTIRANGE</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;INT8MULTIRANGE&quot;</span>

    <span class="s3">def </span><span class="s1">visit_NUMMULTIRANGE</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;NUMMULTIRANGE&quot;</span>

    <span class="s3">def </span><span class="s1">visit_DATEMULTIRANGE</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;DATEMULTIRANGE&quot;</span>

    <span class="s3">def </span><span class="s1">visit_TSMULTIRANGE</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;TSMULTIRANGE&quot;</span>

    <span class="s3">def </span><span class="s1">visit_TSTZMULTIRANGE</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;TSTZMULTIRANGE&quot;</span>

    <span class="s3">def </span><span class="s1">visit_INT4RANGE</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;INT4RANGE&quot;</span>

    <span class="s3">def </span><span class="s1">visit_INT8RANGE</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;INT8RANGE&quot;</span>

    <span class="s3">def </span><span class="s1">visit_NUMRANGE</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;NUMRANGE&quot;</span>

    <span class="s3">def </span><span class="s1">visit_DATERANGE</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;DATERANGE&quot;</span>

    <span class="s3">def </span><span class="s1">visit_TSRANGE</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;TSRANGE&quot;</span>

    <span class="s3">def </span><span class="s1">visit_TSTZRANGE</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;TSTZRANGE&quot;</span>

    <span class="s3">def </span><span class="s1">visit_json_int_index</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;INT&quot;</span>

    <span class="s3">def </span><span class="s1">visit_json_str_index</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;TEXT&quot;</span>

    <span class="s3">def </span><span class="s1">visit_datetime</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">visit_TIMESTAMP</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_enum</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">native_enum </span><span class="s3">or not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">supports_native_enum</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">visit_enum</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">visit_ENUM</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_ENUM</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, </span><span class="s1">identifier_preparer</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">identifier_preparer </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">identifier_preparer </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">identifier_preparer</span>
        <span class="s3">return </span><span class="s1">identifier_preparer</span><span class="s4">.</span><span class="s1">format_type</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_DOMAIN</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, </span><span class="s1">identifier_preparer</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">identifier_preparer </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">identifier_preparer </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">identifier_preparer</span>
        <span class="s3">return </span><span class="s1">identifier_preparer</span><span class="s4">.</span><span class="s1">format_type</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_TIMESTAMP</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;TIMESTAMP%s %s&quot; </span><span class="s4">% (</span>
            <span class="s4">(</span>
                <span class="s2">&quot;(%d)&quot; </span><span class="s4">% </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">precision</span>
                <span class="s3">if </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">, </span><span class="s2">&quot;precision&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">is not None</span>
                <span class="s3">else </span><span class="s2">&quot;&quot;</span>
            <span class="s4">),</span>
            <span class="s4">(</span><span class="s1">type_</span><span class="s4">.</span><span class="s1">timezone </span><span class="s3">and </span><span class="s2">&quot;WITH&quot; </span><span class="s3">or </span><span class="s2">&quot;WITHOUT&quot;</span><span class="s4">) + </span><span class="s2">&quot; TIME ZONE&quot;</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_TIME</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;TIME%s %s&quot; </span><span class="s4">% (</span>
            <span class="s4">(</span>
                <span class="s2">&quot;(%d)&quot; </span><span class="s4">% </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">precision</span>
                <span class="s3">if </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">, </span><span class="s2">&quot;precision&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">is not None</span>
                <span class="s3">else </span><span class="s2">&quot;&quot;</span>
            <span class="s4">),</span>
            <span class="s4">(</span><span class="s1">type_</span><span class="s4">.</span><span class="s1">timezone </span><span class="s3">and </span><span class="s2">&quot;WITH&quot; </span><span class="s3">or </span><span class="s2">&quot;WITHOUT&quot;</span><span class="s4">) + </span><span class="s2">&quot; TIME ZONE&quot;</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_INTERVAL</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">text </span><span class="s4">= </span><span class="s2">&quot;INTERVAL&quot;</span>
        <span class="s3">if </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">fields </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot; &quot; </span><span class="s4">+ </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">fields</span>
        <span class="s3">if </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">precision </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">text </span><span class="s4">+= </span><span class="s2">&quot; (%d)&quot; </span><span class="s4">% </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">precision</span>
        <span class="s3">return </span><span class="s1">text</span>

    <span class="s3">def </span><span class="s1">visit_BIT</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">varying</span><span class="s4">:</span>
            <span class="s1">compiled </span><span class="s4">= </span><span class="s2">&quot;BIT VARYING&quot;</span>
            <span class="s3">if </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">length </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">compiled </span><span class="s4">+= </span><span class="s2">&quot;(%d)&quot; </span><span class="s4">% </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">length</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">compiled </span><span class="s4">= </span><span class="s2">&quot;BIT(%d)&quot; </span><span class="s4">% </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">length</span>
        <span class="s3">return </span><span class="s1">compiled</span>

    <span class="s3">def </span><span class="s1">visit_uuid</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">native_uuid</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">visit_UUID</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">visit_uuid</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_UUID</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;UUID&quot;</span>

    <span class="s3">def </span><span class="s1">visit_large_binary</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">visit_BYTEA</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_BYTEA</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;BYTEA&quot;</span>

    <span class="s3">def </span><span class="s1">visit_ARRAY</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">inner </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">process</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">.</span><span class="s1">item_type</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">re</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">(</span>
            <span class="s2">r&quot;((?: COLLATE.*)?)$&quot;</span><span class="s4">,</span>
            <span class="s4">(</span>
                <span class="s2">r&quot;%s\1&quot;</span>
                <span class="s4">% (</span>
                    <span class="s2">&quot;[]&quot;</span>
                    <span class="s4">* (</span><span class="s1">type_</span><span class="s4">.</span><span class="s1">dimensions </span><span class="s3">if </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">dimensions </span><span class="s3">is not None else </span><span class="s5">1</span><span class="s4">)</span>
                <span class="s4">)</span>
            <span class="s4">),</span>
            <span class="s1">inner</span><span class="s4">,</span>
            <span class="s1">count</span><span class="s4">=</span><span class="s5">1</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_json_path</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">visit_JSONPATH</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">visit_JSONPATH</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s2">&quot;JSONPATH&quot;</span>


<span class="s3">class </span><span class="s1">PGIdentifierPreparer</span><span class="s4">(</span><span class="s1">compiler</span><span class="s4">.</span><span class="s1">IdentifierPreparer</span><span class="s4">):</span>
    <span class="s1">reserved_words </span><span class="s4">= </span><span class="s1">RESERVED_WORDS</span>

    <span class="s3">def </span><span class="s1">_unquote_identifier</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">value</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] == </span><span class="s1">self</span><span class="s4">.</span><span class="s1">initial_quote</span><span class="s4">:</span>
            <span class="s1">value </span><span class="s4">= </span><span class="s1">value</span><span class="s4">[</span><span class="s5">1</span><span class="s4">:-</span><span class="s5">1</span><span class="s4">].</span><span class="s1">replace</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">escape_to_quote</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">escape_quote</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">format_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">, </span><span class="s1">use_schema</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">name</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">CompileError</span><span class="s4">(</span>
                <span class="s2">f&quot;PostgreSQL </span><span class="s3">{</span><span class="s1">type_</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s3">} </span><span class="s2">type requires a name.&quot;</span>
            <span class="s4">)</span>

        <span class="s1">name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">.</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s1">effective_schema </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">schema_for_object</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s4">(</span>
            <span class="s3">not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">omit_schema</span>
            <span class="s3">and </span><span class="s1">use_schema</span>
            <span class="s3">and </span><span class="s1">effective_schema </span><span class="s3">is not None</span>
        <span class="s4">):</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s2">f&quot;</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">quote_schema</span><span class="s4">(</span><span class="s1">effective_schema</span><span class="s4">)</span><span class="s3">}</span><span class="s2">.</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">&quot;</span>
        <span class="s3">return </span><span class="s1">name</span>


<span class="s3">class </span><span class="s1">ReflectedNamedType</span><span class="s4">(</span><span class="s1">TypedDict</span><span class="s4">):</span>
    <span class="s6">&quot;&quot;&quot;Represents a reflected named type.&quot;&quot;&quot;</span>

    <span class="s1">name</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s2">&quot;&quot;&quot;Name of the type.&quot;&quot;&quot;</span>
    <span class="s1">schema</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s2">&quot;&quot;&quot;The schema of the type.&quot;&quot;&quot;</span>
    <span class="s1">visible</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s2">&quot;&quot;&quot;Indicates if this type is in the current search path.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">ReflectedDomainConstraint</span><span class="s4">(</span><span class="s1">TypedDict</span><span class="s4">):</span>
    <span class="s6">&quot;&quot;&quot;Represents a reflect check constraint of a domain.&quot;&quot;&quot;</span>

    <span class="s1">name</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s2">&quot;&quot;&quot;Name of the constraint.&quot;&quot;&quot;</span>
    <span class="s1">check</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s2">&quot;&quot;&quot;The check constraint text.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">ReflectedDomain</span><span class="s4">(</span><span class="s1">ReflectedNamedType</span><span class="s4">):</span>
    <span class="s6">&quot;&quot;&quot;Represents a reflected enum.&quot;&quot;&quot;</span>

    <span class="s1">type</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s2">&quot;&quot;&quot;The string name of the underlying data type of the domain.&quot;&quot;&quot;</span>
    <span class="s1">nullable</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s2">&quot;&quot;&quot;Indicates if the domain allows null or not.&quot;&quot;&quot;</span>
    <span class="s1">default</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s2">&quot;&quot;&quot;The string representation of the default value of this domain 
    or ``None`` if none present. 
    &quot;&quot;&quot;</span>
    <span class="s1">constraints</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">ReflectedDomainConstraint</span><span class="s4">]</span>
    <span class="s2">&quot;&quot;&quot;The constraints defined in the domain, if any. 
    The constraint are in order of evaluation by postgresql. 
    &quot;&quot;&quot;</span>
    <span class="s1">collation</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s2">&quot;&quot;&quot;The collation for the domain.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">ReflectedEnum</span><span class="s4">(</span><span class="s1">ReflectedNamedType</span><span class="s4">):</span>
    <span class="s6">&quot;&quot;&quot;Represents a reflected enum.&quot;&quot;&quot;</span>

    <span class="s1">labels</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>
    <span class="s2">&quot;&quot;&quot;The labels that compose the enum.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">PGInspector</span><span class="s4">(</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">Inspector</span><span class="s4">):</span>
    <span class="s1">dialect</span><span class="s4">: </span><span class="s1">PGDialect</span>

    <span class="s3">def </span><span class="s1">get_table_oid</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s6">&quot;&quot;&quot;Return the OID for the given table name. 
 
        :param table_name: string name of the table.  For special quoting, 
         use :class:`.quoted_name`. 
 
        :param schema: string schema name; if omitted, uses the default schema 
         of the database connection.  For special quoting, 
         use :class:`.quoted_name`. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">with </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_operation_context</span><span class="s4">() </span><span class="s3">as </span><span class="s1">conn</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">get_table_oid</span><span class="s4">(</span>
                <span class="s1">conn</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">info_cache</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">info_cache</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_domains</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">ReflectedDomain</span><span class="s4">]:</span>
        <span class="s6">&quot;&quot;&quot;Return a list of DOMAIN objects. 
 
        Each member is a dictionary containing these fields: 
 
            * name - name of the domain 
            * schema - the schema name for the domain. 
            * visible - boolean, whether or not this domain is visible 
              in the default search path. 
            * type - the type defined by this domain. 
            * nullable - Indicates if this domain can be ``NULL``. 
            * default - The default value of the domain or ``None`` if the 
              domain has no default. 
            * constraints - A list of dict wit the constraint defined by this 
              domain. Each element constaints two keys: ``name`` of the 
              constraint and ``check`` with the constraint text. 
 
        :param schema: schema name.  If None, the default schema 
         (typically 'public') is used.  May also be set to ``'*'`` to 
         indicate load domains for all schemas. 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>
        <span class="s3">with </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_operation_context</span><span class="s4">() </span><span class="s3">as </span><span class="s1">conn</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">_load_domains</span><span class="s4">(</span>
                <span class="s1">conn</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">info_cache</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">info_cache</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_enums</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">ReflectedEnum</span><span class="s4">]:</span>
        <span class="s6">&quot;&quot;&quot;Return a list of ENUM objects. 
 
        Each member is a dictionary containing these fields: 
 
            * name - name of the enum 
            * schema - the schema name for the enum. 
            * visible - boolean, whether or not this enum is visible 
              in the default search path. 
            * labels - a list of string labels that apply to the enum. 
 
        :param schema: schema name.  If None, the default schema 
         (typically 'public') is used.  May also be set to ``'*'`` to 
         indicate load enums for all schemas. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">with </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_operation_context</span><span class="s4">() </span><span class="s3">as </span><span class="s1">conn</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">_load_enums</span><span class="s4">(</span>
                <span class="s1">conn</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">info_cache</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">info_cache</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_foreign_table_names</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s6">&quot;&quot;&quot;Return a list of FOREIGN TABLE names. 
 
        Behavior is similar to that of 
        :meth:`_reflection.Inspector.get_table_names`, 
        except that the list is limited to those tables that report a 
        ``relkind`` value of ``f``. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">with </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_operation_context</span><span class="s4">() </span><span class="s3">as </span><span class="s1">conn</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">_get_foreign_table_names</span><span class="s4">(</span>
                <span class="s1">conn</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">info_cache</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">info_cache</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">has_type</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">type_name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s6">&quot;&quot;&quot;Return if the database has the specified type in the provided 
        schema. 
 
        :param type_name: the type to check. 
        :param schema: schema name.  If None, the default schema 
         (typically 'public') is used.  May also be set to ``'*'`` to 
         check in all schemas. 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>
        <span class="s3">with </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_operation_context</span><span class="s4">() </span><span class="s3">as </span><span class="s1">conn</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">has_type</span><span class="s4">(</span>
                <span class="s1">conn</span><span class="s4">, </span><span class="s1">type_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">info_cache</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">info_cache</span>
            <span class="s4">)</span>


<span class="s3">class </span><span class="s1">PGExecutionContext</span><span class="s4">(</span><span class="s1">default</span><span class="s4">.</span><span class="s1">DefaultExecutionContext</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">fire_sequence</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">seq</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_execute_scalar</span><span class="s4">(</span>
            <span class="s4">(</span>
                <span class="s2">&quot;select nextval('%s')&quot;</span>
                <span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identifier_preparer</span><span class="s4">.</span><span class="s1">format_sequence</span><span class="s4">(</span><span class="s1">seq</span><span class="s4">)</span>
            <span class="s4">),</span>
            <span class="s1">type_</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_insert_default</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">column</span><span class="s4">.</span><span class="s1">primary_key </span><span class="s3">and </span><span class="s1">column </span><span class="s3">is </span><span class="s1">column</span><span class="s4">.</span><span class="s1">table</span><span class="s4">.</span><span class="s1">_autoincrement_column</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">column</span><span class="s4">.</span><span class="s1">server_default </span><span class="s3">and </span><span class="s1">column</span><span class="s4">.</span><span class="s1">server_default</span><span class="s4">.</span><span class="s1">has_argument</span><span class="s4">:</span>
                <span class="s0"># pre-execute passive defaults on primary key columns</span>
                <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_execute_scalar</span><span class="s4">(</span>
                    <span class="s2">&quot;select %s&quot; </span><span class="s4">% </span><span class="s1">column</span><span class="s4">.</span><span class="s1">server_default</span><span class="s4">.</span><span class="s1">arg</span><span class="s4">, </span><span class="s1">column</span><span class="s4">.</span><span class="s1">type</span>
                <span class="s4">)</span>

            <span class="s3">elif </span><span class="s1">column</span><span class="s4">.</span><span class="s1">default </span><span class="s3">is None or </span><span class="s4">(</span>
                <span class="s1">column</span><span class="s4">.</span><span class="s1">default</span><span class="s4">.</span><span class="s1">is_sequence </span><span class="s3">and </span><span class="s1">column</span><span class="s4">.</span><span class="s1">default</span><span class="s4">.</span><span class="s1">optional</span>
            <span class="s4">):</span>
                <span class="s0"># execute the sequence associated with a SERIAL primary</span>
                <span class="s0"># key column. for non-primary-key SERIAL, the ID just</span>
                <span class="s0"># generates server side.</span>

                <span class="s3">try</span><span class="s4">:</span>
                    <span class="s1">seq_name </span><span class="s4">= </span><span class="s1">column</span><span class="s4">.</span><span class="s1">_postgresql_seq_name</span>
                <span class="s3">except </span><span class="s1">AttributeError</span><span class="s4">:</span>
                    <span class="s1">tab </span><span class="s4">= </span><span class="s1">column</span><span class="s4">.</span><span class="s1">table</span><span class="s4">.</span><span class="s1">name</span>
                    <span class="s1">col </span><span class="s4">= </span><span class="s1">column</span><span class="s4">.</span><span class="s1">name</span>
                    <span class="s1">tab </span><span class="s4">= </span><span class="s1">tab</span><span class="s4">[</span><span class="s5">0 </span><span class="s4">: </span><span class="s5">29 </span><span class="s4">+ </span><span class="s1">max</span><span class="s4">(</span><span class="s5">0</span><span class="s4">, (</span><span class="s5">29 </span><span class="s4">- </span><span class="s1">len</span><span class="s4">(</span><span class="s1">col</span><span class="s4">)))]</span>
                    <span class="s1">col </span><span class="s4">= </span><span class="s1">col</span><span class="s4">[</span><span class="s5">0 </span><span class="s4">: </span><span class="s5">29 </span><span class="s4">+ </span><span class="s1">max</span><span class="s4">(</span><span class="s5">0</span><span class="s4">, (</span><span class="s5">29 </span><span class="s4">- </span><span class="s1">len</span><span class="s4">(</span><span class="s1">tab</span><span class="s4">)))]</span>
                    <span class="s1">name </span><span class="s4">= </span><span class="s2">&quot;%s_%s_seq&quot; </span><span class="s4">% (</span><span class="s1">tab</span><span class="s4">, </span><span class="s1">col</span><span class="s4">)</span>
                    <span class="s1">column</span><span class="s4">.</span><span class="s1">_postgresql_seq_name </span><span class="s4">= </span><span class="s1">seq_name </span><span class="s4">= </span><span class="s1">name</span>

                <span class="s3">if </span><span class="s1">column</span><span class="s4">.</span><span class="s1">table </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s1">effective_schema </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">schema_for_object</span><span class="s4">(</span>
                        <span class="s1">column</span><span class="s4">.</span><span class="s1">table</span>
                    <span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">effective_schema </span><span class="s4">= </span><span class="s3">None</span>

                <span class="s3">if </span><span class="s1">effective_schema </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s1">exc </span><span class="s4">= </span><span class="s2">'select nextval(</span><span class="s3">\'</span><span class="s2">&quot;%s&quot;.&quot;%s&quot;</span><span class="s3">\'</span><span class="s2">)' </span><span class="s4">% (</span>
                        <span class="s1">effective_schema</span><span class="s4">,</span>
                        <span class="s1">seq_name</span><span class="s4">,</span>
                    <span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">exc </span><span class="s4">= </span><span class="s2">&quot;select nextval('</span><span class="s3">\&quot;</span><span class="s2">%s</span><span class="s3">\&quot;</span><span class="s2">')&quot; </span><span class="s4">% (</span><span class="s1">seq_name</span><span class="s4">,)</span>

                <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_execute_scalar</span><span class="s4">(</span><span class="s1">exc</span><span class="s4">, </span><span class="s1">column</span><span class="s4">.</span><span class="s1">type</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">get_insert_default</span><span class="s4">(</span><span class="s1">column</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">PGReadOnlyConnectionCharacteristic</span><span class="s4">(</span>
    <span class="s1">characteristics</span><span class="s4">.</span><span class="s1">ConnectionCharacteristic</span>
<span class="s4">):</span>
    <span class="s1">transactional </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">reset_characteristic</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">dbapi_conn</span><span class="s4">):</span>
        <span class="s1">dialect</span><span class="s4">.</span><span class="s1">set_readonly</span><span class="s4">(</span><span class="s1">dbapi_conn</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">set_characteristic</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">dbapi_conn</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s1">dialect</span><span class="s4">.</span><span class="s1">set_readonly</span><span class="s4">(</span><span class="s1">dbapi_conn</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_characteristic</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">dbapi_conn</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">get_readonly</span><span class="s4">(</span><span class="s1">dbapi_conn</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">PGDeferrableConnectionCharacteristic</span><span class="s4">(</span>
    <span class="s1">characteristics</span><span class="s4">.</span><span class="s1">ConnectionCharacteristic</span>
<span class="s4">):</span>
    <span class="s1">transactional </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">reset_characteristic</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">dbapi_conn</span><span class="s4">):</span>
        <span class="s1">dialect</span><span class="s4">.</span><span class="s1">set_deferrable</span><span class="s4">(</span><span class="s1">dbapi_conn</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">set_characteristic</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">dbapi_conn</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s1">dialect</span><span class="s4">.</span><span class="s1">set_deferrable</span><span class="s4">(</span><span class="s1">dbapi_conn</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_characteristic</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">dbapi_conn</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">get_deferrable</span><span class="s4">(</span><span class="s1">dbapi_conn</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">PGDialect</span><span class="s4">(</span><span class="s1">default</span><span class="s4">.</span><span class="s1">DefaultDialect</span><span class="s4">):</span>
    <span class="s1">name </span><span class="s4">= </span><span class="s2">&quot;postgresql&quot;</span>
    <span class="s1">supports_statement_cache </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">supports_alter </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">max_identifier_length </span><span class="s4">= </span><span class="s5">63</span>
    <span class="s1">supports_sane_rowcount </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">bind_typing </span><span class="s4">= </span><span class="s1">interfaces</span><span class="s4">.</span><span class="s1">BindTyping</span><span class="s4">.</span><span class="s1">RENDER_CASTS</span>

    <span class="s1">supports_native_enum </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">supports_native_boolean </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">supports_native_uuid </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">supports_smallserial </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">supports_sequences </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">sequences_optional </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">preexecute_autoincrement_sequences </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">postfetch_lastrowid </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">use_insertmanyvalues </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">returns_native_bytes </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">insertmanyvalues_implicit_sentinel </span><span class="s4">= (</span>
        <span class="s1">InsertmanyvaluesSentinelOpts</span><span class="s4">.</span><span class="s1">ANY_AUTOINCREMENT</span>
        <span class="s4">| </span><span class="s1">InsertmanyvaluesSentinelOpts</span><span class="s4">.</span><span class="s1">USE_INSERT_FROM_SELECT</span>
        <span class="s4">| </span><span class="s1">InsertmanyvaluesSentinelOpts</span><span class="s4">.</span><span class="s1">RENDER_SELECT_COL_CASTS</span>
    <span class="s4">)</span>

    <span class="s1">supports_comments </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">supports_constraint_comments </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">supports_default_values </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">supports_default_metavalue </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">supports_empty_insert </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">supports_multivalues_insert </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">supports_identity_columns </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">default_paramstyle </span><span class="s4">= </span><span class="s2">&quot;pyformat&quot;</span>
    <span class="s1">ischema_names </span><span class="s4">= </span><span class="s1">ischema_names</span>
    <span class="s1">colspecs </span><span class="s4">= </span><span class="s1">colspecs</span>

    <span class="s1">statement_compiler </span><span class="s4">= </span><span class="s1">PGCompiler</span>
    <span class="s1">ddl_compiler </span><span class="s4">= </span><span class="s1">PGDDLCompiler</span>
    <span class="s1">type_compiler_cls </span><span class="s4">= </span><span class="s1">PGTypeCompiler</span>
    <span class="s1">preparer </span><span class="s4">= </span><span class="s1">PGIdentifierPreparer</span>
    <span class="s1">execution_ctx_cls </span><span class="s4">= </span><span class="s1">PGExecutionContext</span>
    <span class="s1">inspector </span><span class="s4">= </span><span class="s1">PGInspector</span>

    <span class="s1">update_returning </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">delete_returning </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">insert_returning </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">update_returning_multifrom </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">delete_returning_multifrom </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">connection_characteristics </span><span class="s4">= (</span>
        <span class="s1">default</span><span class="s4">.</span><span class="s1">DefaultDialect</span><span class="s4">.</span><span class="s1">connection_characteristics</span>
    <span class="s4">)</span>
    <span class="s1">connection_characteristics </span><span class="s4">= </span><span class="s1">connection_characteristics</span><span class="s4">.</span><span class="s1">union</span><span class="s4">(</span>
        <span class="s4">{</span>
            <span class="s2">&quot;postgresql_readonly&quot;</span><span class="s4">: </span><span class="s1">PGReadOnlyConnectionCharacteristic</span><span class="s4">(),</span>
            <span class="s2">&quot;postgresql_deferrable&quot;</span><span class="s4">: </span><span class="s1">PGDeferrableConnectionCharacteristic</span><span class="s4">(),</span>
        <span class="s4">}</span>
    <span class="s4">)</span>

    <span class="s1">construct_arguments </span><span class="s4">= [</span>
        <span class="s4">(</span>
            <span class="s1">schema</span><span class="s4">.</span><span class="s1">Index</span><span class="s4">,</span>
            <span class="s4">{</span>
                <span class="s2">&quot;using&quot;</span><span class="s4">: </span><span class="s3">False</span><span class="s4">,</span>
                <span class="s2">&quot;include&quot;</span><span class="s4">: </span><span class="s3">None</span><span class="s4">,</span>
                <span class="s2">&quot;where&quot;</span><span class="s4">: </span><span class="s3">None</span><span class="s4">,</span>
                <span class="s2">&quot;ops&quot;</span><span class="s4">: {},</span>
                <span class="s2">&quot;concurrently&quot;</span><span class="s4">: </span><span class="s3">False</span><span class="s4">,</span>
                <span class="s2">&quot;with&quot;</span><span class="s4">: {},</span>
                <span class="s2">&quot;tablespace&quot;</span><span class="s4">: </span><span class="s3">None</span><span class="s4">,</span>
                <span class="s2">&quot;nulls_not_distinct&quot;</span><span class="s4">: </span><span class="s3">None</span><span class="s4">,</span>
            <span class="s4">},</span>
        <span class="s4">),</span>
        <span class="s4">(</span>
            <span class="s1">schema</span><span class="s4">.</span><span class="s1">Table</span><span class="s4">,</span>
            <span class="s4">{</span>
                <span class="s2">&quot;ignore_search_path&quot;</span><span class="s4">: </span><span class="s3">False</span><span class="s4">,</span>
                <span class="s2">&quot;tablespace&quot;</span><span class="s4">: </span><span class="s3">None</span><span class="s4">,</span>
                <span class="s2">&quot;partition_by&quot;</span><span class="s4">: </span><span class="s3">None</span><span class="s4">,</span>
                <span class="s2">&quot;with_oids&quot;</span><span class="s4">: </span><span class="s3">None</span><span class="s4">,</span>
                <span class="s2">&quot;on_commit&quot;</span><span class="s4">: </span><span class="s3">None</span><span class="s4">,</span>
                <span class="s2">&quot;inherits&quot;</span><span class="s4">: </span><span class="s3">None</span><span class="s4">,</span>
                <span class="s2">&quot;using&quot;</span><span class="s4">: </span><span class="s3">None</span><span class="s4">,</span>
            <span class="s4">},</span>
        <span class="s4">),</span>
        <span class="s4">(</span>
            <span class="s1">schema</span><span class="s4">.</span><span class="s1">CheckConstraint</span><span class="s4">,</span>
            <span class="s4">{</span>
                <span class="s2">&quot;not_valid&quot;</span><span class="s4">: </span><span class="s3">False</span><span class="s4">,</span>
            <span class="s4">},</span>
        <span class="s4">),</span>
        <span class="s4">(</span>
            <span class="s1">schema</span><span class="s4">.</span><span class="s1">ForeignKeyConstraint</span><span class="s4">,</span>
            <span class="s4">{</span>
                <span class="s2">&quot;not_valid&quot;</span><span class="s4">: </span><span class="s3">False</span><span class="s4">,</span>
            <span class="s4">},</span>
        <span class="s4">),</span>
        <span class="s4">(</span>
            <span class="s1">schema</span><span class="s4">.</span><span class="s1">UniqueConstraint</span><span class="s4">,</span>
            <span class="s4">{</span><span class="s2">&quot;nulls_not_distinct&quot;</span><span class="s4">: </span><span class="s3">None</span><span class="s4">},</span>
        <span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">reflection_options </span><span class="s4">= (</span><span class="s2">&quot;postgresql_ignore_search_path&quot;</span><span class="s4">,)</span>

    <span class="s1">_backslash_escapes </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">_supports_create_index_concurrently </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">_supports_drop_index_concurrently </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">native_inet_types</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">json_serializer</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">json_deserializer</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kwargs</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">default</span><span class="s4">.</span><span class="s1">DefaultDialect</span><span class="s4">.</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_native_inet_types </span><span class="s4">= </span><span class="s1">native_inet_types</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_json_deserializer </span><span class="s4">= </span><span class="s1">json_deserializer</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_json_serializer </span><span class="s4">= </span><span class="s1">json_serializer</span>

    <span class="s3">def </span><span class="s1">initialize</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">initialize</span><span class="s4">(</span><span class="s1">connection</span><span class="s4">)</span>

        <span class="s0"># https://www.postgresql.org/docs/9.3/static/release-9-2.html#AEN116689</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">supports_smallserial </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">server_version_info </span><span class="s4">&gt;= (</span><span class="s5">9</span><span class="s4">, </span><span class="s5">2</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_set_backslash_escapes</span><span class="s4">(</span><span class="s1">connection</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_supports_drop_index_concurrently </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">server_version_info </span><span class="s4">&gt;= (</span>
            <span class="s5">9</span><span class="s4">,</span>
            <span class="s5">2</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">supports_identity_columns </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">server_version_info </span><span class="s4">&gt;= (</span><span class="s5">10</span><span class="s4">,)</span>

    <span class="s3">def </span><span class="s1">get_isolation_level_values</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_conn</span><span class="s4">):</span>
        <span class="s0"># note the generic dialect doesn't have AUTOCOMMIT, however</span>
        <span class="s0"># all postgresql dialects should include AUTOCOMMIT.</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s2">&quot;SERIALIZABLE&quot;</span><span class="s4">,</span>
            <span class="s2">&quot;READ UNCOMMITTED&quot;</span><span class="s4">,</span>
            <span class="s2">&quot;READ COMMITTED&quot;</span><span class="s4">,</span>
            <span class="s2">&quot;REPEATABLE READ&quot;</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">set_isolation_level</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_connection</span><span class="s4">, </span><span class="s1">level</span><span class="s4">):</span>
        <span class="s1">cursor </span><span class="s4">= </span><span class="s1">dbapi_connection</span><span class="s4">.</span><span class="s1">cursor</span><span class="s4">()</span>
        <span class="s1">cursor</span><span class="s4">.</span><span class="s1">execute</span><span class="s4">(</span>
            <span class="s2">&quot;SET SESSION CHARACTERISTICS AS TRANSACTION &quot;</span>
            <span class="s2">f&quot;ISOLATION LEVEL </span><span class="s3">{</span><span class="s1">level</span><span class="s3">}</span><span class="s2">&quot;</span>
        <span class="s4">)</span>
        <span class="s1">cursor</span><span class="s4">.</span><span class="s1">execute</span><span class="s4">(</span><span class="s2">&quot;COMMIT&quot;</span><span class="s4">)</span>
        <span class="s1">cursor</span><span class="s4">.</span><span class="s1">close</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_isolation_level</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi_connection</span><span class="s4">):</span>
        <span class="s1">cursor </span><span class="s4">= </span><span class="s1">dbapi_connection</span><span class="s4">.</span><span class="s1">cursor</span><span class="s4">()</span>
        <span class="s1">cursor</span><span class="s4">.</span><span class="s1">execute</span><span class="s4">(</span><span class="s2">&quot;show transaction isolation level&quot;</span><span class="s4">)</span>
        <span class="s1">val </span><span class="s4">= </span><span class="s1">cursor</span><span class="s4">.</span><span class="s1">fetchone</span><span class="s4">()[</span><span class="s5">0</span><span class="s4">]</span>
        <span class="s1">cursor</span><span class="s4">.</span><span class="s1">close</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">val</span><span class="s4">.</span><span class="s1">upper</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">set_readonly</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_readonly</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">set_deferrable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">get_deferrable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_split_multihost_from_url</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">url</span><span class="s4">: </span><span class="s1">URL</span><span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span>
        <span class="s1">Tuple</span><span class="s4">[</span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], ...], </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">], ...]],</span>
    <span class="s4">]:</span>
        <span class="s1">hosts</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], ...]] = </span><span class="s3">None</span>
        <span class="s1">ports_str</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], ...], </span><span class="s3">None</span><span class="s4">] = </span><span class="s3">None</span>

        <span class="s1">integrated_multihost </span><span class="s4">= </span><span class="s3">False</span>

        <span class="s3">if </span><span class="s2">&quot;host&quot; </span><span class="s3">in </span><span class="s1">url</span><span class="s4">.</span><span class="s1">query</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">url</span><span class="s4">.</span><span class="s1">query</span><span class="s4">[</span><span class="s2">&quot;host&quot;</span><span class="s4">], (</span><span class="s1">list</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">)):</span>
                <span class="s1">integrated_multihost </span><span class="s4">= </span><span class="s3">True</span>
                <span class="s1">hosts</span><span class="s4">, </span><span class="s1">ports_str </span><span class="s4">= </span><span class="s1">zip</span><span class="s4">(</span>
                    <span class="s4">*[</span>
                        <span class="s1">token</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s2">&quot;:&quot;</span><span class="s4">) </span><span class="s3">if </span><span class="s2">&quot;:&quot; </span><span class="s3">in </span><span class="s1">token </span><span class="s3">else </span><span class="s4">(</span><span class="s1">token</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
                        <span class="s3">for </span><span class="s1">token </span><span class="s3">in </span><span class="s1">url</span><span class="s4">.</span><span class="s1">query</span><span class="s4">[</span><span class="s2">&quot;host&quot;</span><span class="s4">]</span>
                    <span class="s4">]</span>
                <span class="s4">)</span>

            <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">url</span><span class="s4">.</span><span class="s1">query</span><span class="s4">[</span><span class="s2">&quot;host&quot;</span><span class="s4">], </span><span class="s1">str</span><span class="s4">):</span>
                <span class="s1">hosts </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">url</span><span class="s4">.</span><span class="s1">query</span><span class="s4">[</span><span class="s2">&quot;host&quot;</span><span class="s4">].</span><span class="s1">split</span><span class="s4">(</span><span class="s2">&quot;,&quot;</span><span class="s4">))</span>

                <span class="s3">if </span><span class="s4">(</span>
                    <span class="s2">&quot;port&quot; </span><span class="s3">not in </span><span class="s1">url</span><span class="s4">.</span><span class="s1">query</span>
                    <span class="s3">and </span><span class="s1">len</span><span class="s4">(</span><span class="s1">hosts</span><span class="s4">) == </span><span class="s5">1</span>
                    <span class="s3">and </span><span class="s2">&quot;:&quot; </span><span class="s3">in </span><span class="s1">hosts</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
                <span class="s4">):</span>
                    <span class="s0"># internet host is alphanumeric plus dots or hyphens.</span>
                    <span class="s0"># this is essentially rfc1123, which refers to rfc952.</span>
                    <span class="s0"># https://stackoverflow.com/questions/3523028/</span>
                    <span class="s0"># valid-characters-of-a-hostname</span>
                    <span class="s1">host_port_match </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span>
                        <span class="s2">r&quot;^([a-zA-Z0-9\-\.]*)(?:\:(\d*))?$&quot;</span><span class="s4">, </span><span class="s1">hosts</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
                    <span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">host_port_match</span><span class="s4">:</span>
                        <span class="s1">integrated_multihost </span><span class="s4">= </span><span class="s3">True</span>
                        <span class="s1">h</span><span class="s4">, </span><span class="s1">p </span><span class="s4">= </span><span class="s1">host_port_match</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">)</span>
                        <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
                            <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">h</span><span class="s4">, </span><span class="s1">str</span><span class="s4">)</span>
                            <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">p</span><span class="s4">, </span><span class="s1">str</span><span class="s4">)</span>
                        <span class="s1">hosts </span><span class="s4">= (</span><span class="s1">h</span><span class="s4">,)</span>
                        <span class="s1">ports_str </span><span class="s4">= </span><span class="s1">cast</span><span class="s4">(</span>
                            <span class="s2">&quot;Tuple[Optional[str], ...]&quot;</span><span class="s4">, (</span><span class="s1">p</span><span class="s4">,) </span><span class="s3">if </span><span class="s1">p </span><span class="s3">else </span><span class="s4">(</span><span class="s3">None</span><span class="s4">,)</span>
                        <span class="s4">)</span>

        <span class="s3">if </span><span class="s2">&quot;port&quot; </span><span class="s3">in </span><span class="s1">url</span><span class="s4">.</span><span class="s1">query</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">integrated_multihost</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                    <span class="s2">&quot;Can't mix 'multihost' formats together; use &quot;</span>
                    <span class="s2">'&quot;host=h1,h2,h3&amp;port=p1,p2,p3&quot; or '</span>
                    <span class="s2">'&quot;host=h1:p1&amp;host=h2:p2&amp;host=h3:p3&quot; separately'</span>
                <span class="s4">)</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">url</span><span class="s4">.</span><span class="s1">query</span><span class="s4">[</span><span class="s2">&quot;port&quot;</span><span class="s4">], (</span><span class="s1">list</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">)):</span>
                <span class="s1">ports_str </span><span class="s4">= </span><span class="s1">url</span><span class="s4">.</span><span class="s1">query</span><span class="s4">[</span><span class="s2">&quot;port&quot;</span><span class="s4">]</span>
            <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">url</span><span class="s4">.</span><span class="s1">query</span><span class="s4">[</span><span class="s2">&quot;port&quot;</span><span class="s4">], </span><span class="s1">str</span><span class="s4">):</span>
                <span class="s1">ports_str </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">url</span><span class="s4">.</span><span class="s1">query</span><span class="s4">[</span><span class="s2">&quot;port&quot;</span><span class="s4">].</span><span class="s1">split</span><span class="s4">(</span><span class="s2">&quot;,&quot;</span><span class="s4">))</span>

        <span class="s1">ports</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">], ...]] = </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">ports_str</span><span class="s4">:</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">ports </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">int</span><span class="s4">(</span><span class="s1">x</span><span class="s4">) </span><span class="s3">if </span><span class="s1">x </span><span class="s3">else None for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">ports_str</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s1">ValueError</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                    <span class="s2">f&quot;Received non-integer port arguments: </span><span class="s3">{</span><span class="s1">ports_str</span><span class="s3">}</span><span class="s2">&quot;</span>
                <span class="s4">) </span><span class="s3">from None</span>

        <span class="s3">if </span><span class="s1">ports </span><span class="s3">and </span><span class="s4">(</span>
            <span class="s4">(</span><span class="s3">not </span><span class="s1">hosts </span><span class="s3">and </span><span class="s1">len</span><span class="s4">(</span><span class="s1">ports</span><span class="s4">) &gt; </span><span class="s5">1</span><span class="s4">)</span>
            <span class="s3">or </span><span class="s4">(</span>
                <span class="s1">hosts</span>
                <span class="s3">and </span><span class="s1">ports</span>
                <span class="s3">and </span><span class="s1">len</span><span class="s4">(</span><span class="s1">hosts</span><span class="s4">) != </span><span class="s1">len</span><span class="s4">(</span><span class="s1">ports</span><span class="s4">)</span>
                <span class="s3">and </span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">hosts</span><span class="s4">) &gt; </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">len</span><span class="s4">(</span><span class="s1">ports</span><span class="s4">) &gt; </span><span class="s5">1</span><span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span><span class="s2">&quot;number of hosts and ports don't match&quot;</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">hosts </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">ports </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">ports </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span><span class="s3">None for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">hosts</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">hosts</span><span class="s4">, </span><span class="s1">ports  </span><span class="s0"># type: ignore</span>

    <span class="s3">def </span><span class="s1">do_begin_twophase</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">xid</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">do_begin</span><span class="s4">(</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">connection</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">do_prepare_twophase</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">xid</span><span class="s4">):</span>
        <span class="s1">connection</span><span class="s4">.</span><span class="s1">exec_driver_sql</span><span class="s4">(</span><span class="s2">&quot;PREPARE TRANSACTION '%s'&quot; </span><span class="s4">% </span><span class="s1">xid</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">do_rollback_twophase</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">xid</span><span class="s4">, </span><span class="s1">is_prepared</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">recover</span><span class="s4">=</span><span class="s3">False</span>
    <span class="s4">):</span>
        <span class="s3">if </span><span class="s1">is_prepared</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">recover</span><span class="s4">:</span>
                <span class="s0"># FIXME: ugly hack to get out of transaction</span>
                <span class="s0"># context when committing recoverable transactions</span>
                <span class="s0"># Must find out a way how to make the dbapi not</span>
                <span class="s0"># open a transaction.</span>
                <span class="s1">connection</span><span class="s4">.</span><span class="s1">exec_driver_sql</span><span class="s4">(</span><span class="s2">&quot;ROLLBACK&quot;</span><span class="s4">)</span>
            <span class="s1">connection</span><span class="s4">.</span><span class="s1">exec_driver_sql</span><span class="s4">(</span><span class="s2">&quot;ROLLBACK PREPARED '%s'&quot; </span><span class="s4">% </span><span class="s1">xid</span><span class="s4">)</span>
            <span class="s1">connection</span><span class="s4">.</span><span class="s1">exec_driver_sql</span><span class="s4">(</span><span class="s2">&quot;BEGIN&quot;</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">do_rollback</span><span class="s4">(</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">connection</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">do_rollback</span><span class="s4">(</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">connection</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">do_commit_twophase</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">xid</span><span class="s4">, </span><span class="s1">is_prepared</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">recover</span><span class="s4">=</span><span class="s3">False</span>
    <span class="s4">):</span>
        <span class="s3">if </span><span class="s1">is_prepared</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">recover</span><span class="s4">:</span>
                <span class="s1">connection</span><span class="s4">.</span><span class="s1">exec_driver_sql</span><span class="s4">(</span><span class="s2">&quot;ROLLBACK&quot;</span><span class="s4">)</span>
            <span class="s1">connection</span><span class="s4">.</span><span class="s1">exec_driver_sql</span><span class="s4">(</span><span class="s2">&quot;COMMIT PREPARED '%s'&quot; </span><span class="s4">% </span><span class="s1">xid</span><span class="s4">)</span>
            <span class="s1">connection</span><span class="s4">.</span><span class="s1">exec_driver_sql</span><span class="s4">(</span><span class="s2">&quot;BEGIN&quot;</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">do_rollback</span><span class="s4">(</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">connection</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">do_commit</span><span class="s4">(</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">connection</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">do_recover_twophase</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">scalars</span><span class="s4">(</span>
            <span class="s1">sql</span><span class="s4">.</span><span class="s1">text</span><span class="s4">(</span><span class="s2">&quot;SELECT gid FROM pg_prepared_xacts&quot;</span><span class="s4">)</span>
        <span class="s4">).</span><span class="s1">all</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_get_default_schema_name</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">exec_driver_sql</span><span class="s4">(</span><span class="s2">&quot;select current_schema()&quot;</span><span class="s4">).</span><span class="s1">scalar</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">has_schema</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">select</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">nspname</span><span class="s4">).</span><span class="s1">where</span><span class="s4">(</span>
            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">nspname </span><span class="s4">== </span><span class="s1">schema</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">bool</span><span class="s4">(</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">scalar</span><span class="s4">(</span><span class="s1">query</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">_pg_class_filter_scope_schema</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">query</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">pg_class_table</span><span class="s4">=</span><span class="s3">None</span>
    <span class="s4">):</span>
        <span class="s3">if </span><span class="s1">pg_class_table </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">pg_class_table </span><span class="s4">= </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">query</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">,</span>
            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid </span><span class="s4">== </span><span class="s1">pg_class_table</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relnamespace</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">scope </span><span class="s3">is </span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">DEFAULT</span><span class="s4">:</span>
            <span class="s1">query </span><span class="s4">= </span><span class="s1">query</span><span class="s4">.</span><span class="s1">where</span><span class="s4">(</span><span class="s1">pg_class_table</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relpersistence </span><span class="s4">!= </span><span class="s2">&quot;t&quot;</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">scope </span><span class="s3">is </span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">TEMPORARY</span><span class="s4">:</span>
            <span class="s1">query </span><span class="s4">= </span><span class="s1">query</span><span class="s4">.</span><span class="s1">where</span><span class="s4">(</span><span class="s1">pg_class_table</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relpersistence </span><span class="s4">== </span><span class="s2">&quot;t&quot;</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">schema </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">query </span><span class="s4">= </span><span class="s1">query</span><span class="s4">.</span><span class="s1">where</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_table_is_visible</span><span class="s4">(</span><span class="s1">pg_class_table</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">),</span>
                <span class="s0"># ignore pg_catalog schema</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">nspname </span><span class="s4">!= </span><span class="s2">&quot;pg_catalog&quot;</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">query </span><span class="s4">= </span><span class="s1">query</span><span class="s4">.</span><span class="s1">where</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">nspname </span><span class="s4">== </span><span class="s1">schema</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">query</span>

    <span class="s3">def </span><span class="s1">_pg_class_relkind_condition</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">relkinds</span><span class="s4">, </span><span class="s1">pg_class_table</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">pg_class_table </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">pg_class_table </span><span class="s4">= </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span>
        <span class="s0"># uses the any form instead of in otherwise postgresql complaings</span>
        <span class="s0"># that 'IN could not convert type character to &quot;char&quot;'</span>
        <span class="s3">return </span><span class="s1">pg_class_table</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relkind </span><span class="s4">== </span><span class="s1">sql</span><span class="s4">.</span><span class="s1">any_</span><span class="s4">(</span><span class="s1">_array</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span><span class="s1">relkinds</span><span class="s4">))</span>

    <span class="s4">@</span><span class="s1">lru_cache</span><span class="s4">()</span>
    <span class="s3">def </span><span class="s1">_has_table_query</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">):</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">select</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span><span class="s4">).</span><span class="s1">where</span><span class="s4">(</span>
            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname </span><span class="s4">== </span><span class="s1">bindparam</span><span class="s4">(</span><span class="s2">&quot;table_name&quot;</span><span class="s4">),</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_relkind_condition</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">RELKINDS_ALL_TABLE_LIKE</span>
            <span class="s4">),</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_filter_scope_schema</span><span class="s4">(</span>
            <span class="s1">query</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">ANY</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">has_table</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_ensure_has_table_connection</span><span class="s4">(</span><span class="s1">connection</span><span class="s4">)</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_has_table_query</span><span class="s4">(</span><span class="s1">schema</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">bool</span><span class="s4">(</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">scalar</span><span class="s4">(</span><span class="s1">query</span><span class="s4">, {</span><span class="s2">&quot;table_name&quot;</span><span class="s4">: </span><span class="s1">table_name</span><span class="s4">}))</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">has_sequence</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">sequence_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">select</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span><span class="s4">).</span><span class="s1">where</span><span class="s4">(</span>
            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relkind </span><span class="s4">== </span><span class="s2">&quot;S&quot;</span><span class="s4">,</span>
            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname </span><span class="s4">== </span><span class="s1">sequence_name</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_filter_scope_schema</span><span class="s4">(</span>
            <span class="s1">query</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">ANY</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">bool</span><span class="s4">(</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">scalar</span><span class="s4">(</span><span class="s1">query</span><span class="s4">))</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">has_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">type_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">query </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">typname</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span>
                <span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">typnamespace</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">where</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">typname </span><span class="s4">== </span><span class="s1">type_name</span><span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">schema </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">query </span><span class="s4">= </span><span class="s1">query</span><span class="s4">.</span><span class="s1">where</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type_is_visible</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">),</span>
                <span class="s0"># ignore pg_catalog schema</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">nspname </span><span class="s4">!= </span><span class="s2">&quot;pg_catalog&quot;</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">schema </span><span class="s4">!= </span><span class="s2">&quot;*&quot;</span><span class="s4">:</span>
            <span class="s1">query </span><span class="s4">= </span><span class="s1">query</span><span class="s4">.</span><span class="s1">where</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">nspname </span><span class="s4">== </span><span class="s1">schema</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">bool</span><span class="s4">(</span><span class="s1">connection</span><span class="s4">.</span><span class="s1">scalar</span><span class="s4">(</span><span class="s1">query</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">_get_server_version_info</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">):</span>
        <span class="s1">v </span><span class="s4">= </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">exec_driver_sql</span><span class="s4">(</span><span class="s2">&quot;select pg_catalog.version()&quot;</span><span class="s4">).</span><span class="s1">scalar</span><span class="s4">()</span>
        <span class="s1">m </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span>
            <span class="s2">r&quot;.*(?:PostgreSQL|EnterpriseDB) &quot;</span>
            <span class="s2">r&quot;(\d+)\.?(\d+)?(?:\.(\d+))?(?:\.\d+)?(?:devel|beta)?&quot;</span><span class="s4">,</span>
            <span class="s1">v</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">m</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">AssertionError</span><span class="s4">(</span>
                <span class="s2">&quot;Could not determine version from string '%s'&quot; </span><span class="s4">% </span><span class="s1">v</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">tuple</span><span class="s4">([</span><span class="s1">int</span><span class="s4">(</span><span class="s1">x</span><span class="s4">) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">3</span><span class="s4">) </span><span class="s3">if </span><span class="s1">x </span><span class="s3">is not None</span><span class="s4">])</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">get_table_oid</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s6">&quot;&quot;&quot;Fetch the oid for schema.table_name.&quot;&quot;&quot;</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">select</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">).</span><span class="s1">where</span><span class="s4">(</span>
            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname </span><span class="s4">== </span><span class="s1">table_name</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_relkind_condition</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">RELKINDS_ALL_TABLE_LIKE</span>
            <span class="s4">),</span>
        <span class="s4">)</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_filter_scope_schema</span><span class="s4">(</span>
            <span class="s1">query</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">ANY</span>
        <span class="s4">)</span>
        <span class="s1">table_oid </span><span class="s4">= </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">scalar</span><span class="s4">(</span><span class="s1">query</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">table_oid </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">NoSuchTableError</span><span class="s4">(</span>
                <span class="s2">f&quot;</span><span class="s3">{</span><span class="s1">schema</span><span class="s3">}</span><span class="s2">.</span><span class="s3">{</span><span class="s1">table_name</span><span class="s3">}</span><span class="s2">&quot; </span><span class="s3">if </span><span class="s1">schema </span><span class="s3">else </span><span class="s1">table_name</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">table_oid</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">get_schema_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">query </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">nspname</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">where</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">nspname</span><span class="s4">.</span><span class="s1">not_like</span><span class="s4">(</span><span class="s2">&quot;pg_%&quot;</span><span class="s4">))</span>
            <span class="s4">.</span><span class="s1">order_by</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">nspname</span><span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">scalars</span><span class="s4">(</span><span class="s1">query</span><span class="s4">).</span><span class="s1">all</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_get_relnames_for_relkinds</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">relkinds</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">):</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">select</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span><span class="s4">).</span><span class="s1">where</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_relkind_condition</span><span class="s4">(</span><span class="s1">relkinds</span><span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_filter_scope_schema</span><span class="s4">(</span><span class="s1">query</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">=</span><span class="s1">scope</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">scalars</span><span class="s4">(</span><span class="s1">query</span><span class="s4">).</span><span class="s1">all</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">get_table_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_relnames_for_relkinds</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">,</span>
            <span class="s1">schema</span><span class="s4">,</span>
            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">RELKINDS_TABLE_NO_FOREIGN</span><span class="s4">,</span>
            <span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">DEFAULT</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">get_temp_table_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_relnames_for_relkinds</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">,</span>
            <span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
            <span class="s1">relkinds</span><span class="s4">=</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">RELKINDS_TABLE_NO_FOREIGN</span><span class="s4">,</span>
            <span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">TEMPORARY</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">_get_foreign_table_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_relnames_for_relkinds</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">relkinds</span><span class="s4">=(</span><span class="s2">&quot;f&quot;</span><span class="s4">,), </span><span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">ANY</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">get_view_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_relnames_for_relkinds</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">,</span>
            <span class="s1">schema</span><span class="s4">,</span>
            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">RELKINDS_VIEW</span><span class="s4">,</span>
            <span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">DEFAULT</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">get_materialized_view_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_relnames_for_relkinds</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">,</span>
            <span class="s1">schema</span><span class="s4">,</span>
            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">RELKINDS_MAT_VIEW</span><span class="s4">,</span>
            <span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">DEFAULT</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">get_temp_view_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_relnames_for_relkinds</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">,</span>
            <span class="s1">schema</span><span class="s4">,</span>
            <span class="s0"># NOTE: do not include temp materialzied views (that do not</span>
            <span class="s0"># seem to be a thing at least up to version 14)</span>
            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">RELKINDS_VIEW</span><span class="s4">,</span>
            <span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">TEMPORARY</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">get_sequence_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_relnames_for_relkinds</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">relkinds</span><span class="s4">=(</span><span class="s2">&quot;S&quot;</span><span class="s4">,), </span><span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">ANY</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">get_view_definition</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">view_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">query </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_get_viewdef</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">))</span>
            <span class="s4">.</span><span class="s1">select_from</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">where</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname </span><span class="s4">== </span><span class="s1">view_name</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_relkind_condition</span><span class="s4">(</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">RELKINDS_VIEW </span><span class="s4">+ </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">RELKINDS_MAT_VIEW</span>
                <span class="s4">),</span>
            <span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_filter_scope_schema</span><span class="s4">(</span>
            <span class="s1">query</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">ANY</span>
        <span class="s4">)</span>
        <span class="s1">res </span><span class="s4">= </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">scalar</span><span class="s4">(</span><span class="s1">query</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">res </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">NoSuchTableError</span><span class="s4">(</span>
                <span class="s2">f&quot;</span><span class="s3">{</span><span class="s1">schema</span><span class="s3">}</span><span class="s2">.</span><span class="s3">{</span><span class="s1">view_name</span><span class="s3">}</span><span class="s2">&quot; </span><span class="s3">if </span><span class="s1">schema </span><span class="s3">else </span><span class="s1">view_name</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">res</span>

    <span class="s3">def </span><span class="s1">_value_or_raise</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">table</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">):</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">data</span><span class="s4">)[(</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">table</span><span class="s4">)]</span>
        <span class="s3">except </span><span class="s1">KeyError</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">NoSuchTableError</span><span class="s4">(</span>
                <span class="s2">f&quot;</span><span class="s3">{</span><span class="s1">schema</span><span class="s3">}</span><span class="s2">.</span><span class="s3">{</span><span class="s1">table</span><span class="s3">}</span><span class="s2">&quot; </span><span class="s3">if </span><span class="s1">schema </span><span class="s3">else </span><span class="s1">table</span>
            <span class="s4">) </span><span class="s3">from None</span>

    <span class="s3">def </span><span class="s1">_prepare_filter_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">filter_names</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">filter_names</span><span class="s4">:</span>
            <span class="s3">return True</span><span class="s4">, {</span><span class="s2">&quot;filter_names&quot;</span><span class="s4">: </span><span class="s1">filter_names</span><span class="s4">}</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return False</span><span class="s4">, {}</span>

    <span class="s3">def </span><span class="s1">_kind_to_relkinds</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">: </span><span class="s1">ObjectKind</span><span class="s4">) </span><span class="s1">-&gt; Tuple</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, ...]:</span>
        <span class="s3">if </span><span class="s1">kind </span><span class="s3">is </span><span class="s1">ObjectKind</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">RELKINDS_ALL_TABLE_LIKE</span>
        <span class="s1">relkinds </span><span class="s4">= ()</span>
        <span class="s3">if </span><span class="s1">ObjectKind</span><span class="s4">.</span><span class="s1">TABLE </span><span class="s3">in </span><span class="s1">kind</span><span class="s4">:</span>
            <span class="s1">relkinds </span><span class="s4">+= </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">RELKINDS_TABLE</span>
        <span class="s3">if </span><span class="s1">ObjectKind</span><span class="s4">.</span><span class="s1">VIEW </span><span class="s3">in </span><span class="s1">kind</span><span class="s4">:</span>
            <span class="s1">relkinds </span><span class="s4">+= </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">RELKINDS_VIEW</span>
        <span class="s3">if </span><span class="s1">ObjectKind</span><span class="s4">.</span><span class="s1">MATERIALIZED_VIEW </span><span class="s3">in </span><span class="s1">kind</span><span class="s4">:</span>
            <span class="s1">relkinds </span><span class="s4">+= </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">RELKINDS_MAT_VIEW</span>
        <span class="s3">return </span><span class="s1">relkinds</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">get_columns</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">data </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_multi_columns</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">,</span>
            <span class="s1">schema</span><span class="s4">=</span><span class="s1">schema</span><span class="s4">,</span>
            <span class="s1">filter_names</span><span class="s4">=[</span><span class="s1">table_name</span><span class="s4">],</span>
            <span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">,</span>
            <span class="s1">kind</span><span class="s4">=</span><span class="s1">ObjectKind</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">,</span>
            <span class="s4">**</span><span class="s1">kw</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_value_or_raise</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">lru_cache</span><span class="s4">()</span>
    <span class="s3">def </span><span class="s1">_columns_query</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">has_filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">):</span>
        <span class="s0"># NOTE: the query with the default and identity options scalar</span>
        <span class="s0"># subquery is faster than trying to use outer joins for them</span>
        <span class="s1">generated </span><span class="s4">= (</span>
            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attgenerated</span><span class="s4">.</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;generated&quot;</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">server_version_info </span><span class="s4">&gt;= (</span><span class="s5">12</span><span class="s4">,)</span>
            <span class="s3">else </span><span class="s1">sql</span><span class="s4">.</span><span class="s1">null</span><span class="s4">().</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;generated&quot;</span><span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">server_version_info </span><span class="s4">&gt;= (</span><span class="s5">10</span><span class="s4">,):</span>
            <span class="s0"># join lateral performs worse (~2x slower) than a scalar_subquery</span>
            <span class="s1">identity </span><span class="s4">= (</span>
                <span class="s1">select</span><span class="s4">(</span>
                    <span class="s1">sql</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">json_build_object</span><span class="s4">(</span>
                        <span class="s2">&quot;always&quot;</span><span class="s4">,</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attidentity </span><span class="s4">== </span><span class="s2">&quot;a&quot;</span><span class="s4">,</span>
                        <span class="s2">&quot;start&quot;</span><span class="s4">,</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_sequence</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">seqstart</span><span class="s4">,</span>
                        <span class="s2">&quot;increment&quot;</span><span class="s4">,</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_sequence</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">seqincrement</span><span class="s4">,</span>
                        <span class="s2">&quot;minvalue&quot;</span><span class="s4">,</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_sequence</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">seqmin</span><span class="s4">,</span>
                        <span class="s2">&quot;maxvalue&quot;</span><span class="s4">,</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_sequence</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">seqmax</span><span class="s4">,</span>
                        <span class="s2">&quot;cache&quot;</span><span class="s4">,</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_sequence</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">seqcache</span><span class="s4">,</span>
                        <span class="s2">&quot;cycle&quot;</span><span class="s4">,</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_sequence</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">seqcycle</span><span class="s4">,</span>
                    <span class="s4">)</span>
                <span class="s4">)</span>
                <span class="s4">.</span><span class="s1">select_from</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_sequence</span><span class="s4">)</span>
                <span class="s4">.</span><span class="s1">where</span><span class="s4">(</span>
                    <span class="s0"># attidentity != '' is required or it will reflect also</span>
                    <span class="s0"># serial columns as identity.</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attidentity </span><span class="s4">!= </span><span class="s2">&quot;&quot;</span><span class="s4">,</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_sequence</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">seqrelid</span>
                    <span class="s4">== </span><span class="s1">sql</span><span class="s4">.</span><span class="s1">cast</span><span class="s4">(</span>
                        <span class="s1">sql</span><span class="s4">.</span><span class="s1">cast</span><span class="s4">(</span>
                            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_get_serial_sequence</span><span class="s4">(</span>
                                <span class="s1">sql</span><span class="s4">.</span><span class="s1">cast</span><span class="s4">(</span>
                                    <span class="s1">sql</span><span class="s4">.</span><span class="s1">cast</span><span class="s4">(</span>
                                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attrelid</span><span class="s4">,</span>
                                        <span class="s1">REGCLASS</span><span class="s4">,</span>
                                    <span class="s4">),</span>
                                    <span class="s1">TEXT</span><span class="s4">,</span>
                                <span class="s4">),</span>
                                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attname</span><span class="s4">,</span>
                            <span class="s4">),</span>
                            <span class="s1">REGCLASS</span><span class="s4">,</span>
                        <span class="s4">),</span>
                        <span class="s1">OID</span><span class="s4">,</span>
                    <span class="s4">),</span>
                <span class="s4">)</span>
                <span class="s4">.</span><span class="s1">correlate</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">)</span>
                <span class="s4">.</span><span class="s1">scalar_subquery</span><span class="s4">()</span>
                <span class="s4">.</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;identity_options&quot;</span><span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">identity </span><span class="s4">= </span><span class="s1">sql</span><span class="s4">.</span><span class="s1">null</span><span class="s4">().</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;identity_options&quot;</span><span class="s4">)</span>

        <span class="s0"># join lateral performs the same as scalar_subquery here</span>
        <span class="s1">default </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_get_expr</span><span class="s4">(</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attrdef</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">adbin</span><span class="s4">,</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attrdef</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">adrelid</span><span class="s4">,</span>
                <span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">select_from</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attrdef</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">where</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attrdef</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">adrelid</span>
                <span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attrelid</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attrdef</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">adnum</span>
                <span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attnum</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">atthasdef</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">correlate</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">scalar_subquery</span><span class="s4">()</span>
            <span class="s4">.</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;default&quot;</span><span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s1">relkinds </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_kind_to_relkinds</span><span class="s4">(</span><span class="s1">kind</span><span class="s4">)</span>
        <span class="s1">query </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attname</span><span class="s4">.</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;name&quot;</span><span class="s4">),</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">format_type</span><span class="s4">(</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">atttypid</span><span class="s4">,</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">atttypmod</span><span class="s4">,</span>
                <span class="s4">).</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;format_type&quot;</span><span class="s4">),</span>
                <span class="s1">default</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attnotnull</span><span class="s4">.</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;not_null&quot;</span><span class="s4">),</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span><span class="s4">.</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;table_name&quot;</span><span class="s4">),</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_description</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">description</span><span class="s4">.</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;comment&quot;</span><span class="s4">),</span>
                <span class="s1">generated</span><span class="s4">,</span>
                <span class="s1">identity</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">select_from</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">)</span>
            <span class="s0"># NOTE: postgresql support table with no user column, meaning</span>
            <span class="s0"># there is no row with pg_attribute.attnum &gt; 0. use a left outer</span>
            <span class="s0"># join to avoid filtering these tables.</span>
            <span class="s4">.</span><span class="s1">outerjoin</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">,</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">and_</span><span class="s4">(</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span>
                    <span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attrelid</span><span class="s4">,</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attnum </span><span class="s4">&gt; </span><span class="s5">0</span><span class="s4">,</span>
                    <span class="s4">~</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attisdropped</span><span class="s4">,</span>
                <span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">outerjoin</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_description</span><span class="s4">,</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">and_</span><span class="s4">(</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_description</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">objoid</span>
                    <span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attrelid</span><span class="s4">,</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_description</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">objsubid</span>
                    <span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attnum</span><span class="s4">,</span>
                <span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">where</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_relkind_condition</span><span class="s4">(</span><span class="s1">relkinds</span><span class="s4">))</span>
            <span class="s4">.</span><span class="s1">order_by</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span><span class="s4">, </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attnum</span>
            <span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_filter_scope_schema</span><span class="s4">(</span><span class="s1">query</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">=</span><span class="s1">scope</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">has_filter_names</span><span class="s4">:</span>
            <span class="s1">query </span><span class="s4">= </span><span class="s1">query</span><span class="s4">.</span><span class="s1">where</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span><span class="s4">.</span><span class="s1">in_</span><span class="s4">(</span><span class="s1">bindparam</span><span class="s4">(</span><span class="s2">&quot;filter_names&quot;</span><span class="s4">))</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">query</span>

    <span class="s3">def </span><span class="s1">get_multi_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">, **</span><span class="s1">kw</span>
    <span class="s4">):</span>
        <span class="s1">has_filter_names</span><span class="s4">, </span><span class="s1">params </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prepare_filter_names</span><span class="s4">(</span><span class="s1">filter_names</span><span class="s4">)</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_columns_query</span><span class="s4">(</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">has_filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">)</span>
        <span class="s1">rows </span><span class="s4">= </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">execute</span><span class="s4">(</span><span class="s1">query</span><span class="s4">, </span><span class="s1">params</span><span class="s4">).</span><span class="s1">mappings</span><span class="s4">()</span>

        <span class="s0"># dictionary with (name, ) if default search path or (schema, name)</span>
        <span class="s0"># as keys</span>
        <span class="s1">domains </span><span class="s4">= {</span>
            <span class="s4">((</span><span class="s1">d</span><span class="s4">[</span><span class="s2">&quot;schema&quot;</span><span class="s4">], </span><span class="s1">d</span><span class="s4">[</span><span class="s2">&quot;name&quot;</span><span class="s4">]) </span><span class="s3">if not </span><span class="s1">d</span><span class="s4">[</span><span class="s2">&quot;visible&quot;</span><span class="s4">] </span><span class="s3">else </span><span class="s4">(</span><span class="s1">d</span><span class="s4">[</span><span class="s2">&quot;name&quot;</span><span class="s4">],)): </span><span class="s1">d</span>
            <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_load_domains</span><span class="s4">(</span>
                <span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s2">&quot;*&quot;</span><span class="s4">, </span><span class="s1">info_cache</span><span class="s4">=</span><span class="s1">kw</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s2">&quot;info_cache&quot;</span><span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s4">}</span>

        <span class="s0"># dictionary with (name, ) if default search path or (schema, name)</span>
        <span class="s0"># as keys</span>
        <span class="s1">enums </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span>
            <span class="s4">(</span>
                <span class="s4">((</span><span class="s1">rec</span><span class="s4">[</span><span class="s2">&quot;name&quot;</span><span class="s4">],), </span><span class="s1">rec</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">rec</span><span class="s4">[</span><span class="s2">&quot;visible&quot;</span><span class="s4">]</span>
                <span class="s3">else </span><span class="s4">((</span><span class="s1">rec</span><span class="s4">[</span><span class="s2">&quot;schema&quot;</span><span class="s4">], </span><span class="s1">rec</span><span class="s4">[</span><span class="s2">&quot;name&quot;</span><span class="s4">]), </span><span class="s1">rec</span><span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">rec </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_load_enums</span><span class="s4">(</span>
                <span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s2">&quot;*&quot;</span><span class="s4">, </span><span class="s1">info_cache</span><span class="s4">=</span><span class="s1">kw</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s2">&quot;info_cache&quot;</span><span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s1">columns </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_columns_info</span><span class="s4">(</span><span class="s1">rows</span><span class="s4">, </span><span class="s1">domains</span><span class="s4">, </span><span class="s1">enums</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">columns</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()</span>

    <span class="s1">_format_type_args_pattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s2">r&quot;\((.*)\)&quot;</span><span class="s4">)</span>
    <span class="s1">_format_type_args_delim </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s2">r&quot;\s*,\s*&quot;</span><span class="s4">)</span>
    <span class="s1">_format_array_spec_pattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s2">r&quot;((?:\[\])*)$&quot;</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_reflect_type</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">format_type</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">],</span>
        <span class="s1">domains</span><span class="s4">: </span><span class="s1">dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ReflectedDomain</span><span class="s4">],</span>
        <span class="s1">enums</span><span class="s4">: </span><span class="s1">dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ReflectedEnum</span><span class="s4">],</span>
        <span class="s1">type_description</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; sqltypes</span><span class="s4">.</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s6">&quot;&quot;&quot; 
        Attempts to reconstruct a column type defined in ischema_names based 
        on the information available in the format_type. 
 
        If the `format_type` cannot be associated with a known `ischema_names`, 
        it is treated as a reference to a known PostgreSQL named `ENUM` or 
        `DOMAIN` type. 
        &quot;&quot;&quot;</span>
        <span class="s1">type_description </span><span class="s4">= </span><span class="s1">type_description </span><span class="s3">or </span><span class="s2">&quot;unknown type&quot;</span>
        <span class="s3">if </span><span class="s1">format_type </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">util</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                <span class="s2">&quot;PostgreSQL format_type() returned NULL for %s&quot;</span>
                <span class="s4">% </span><span class="s1">type_description</span>
            <span class="s4">)</span>
            <span class="s3">return </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">NULLTYPE</span>

        <span class="s1">attype_args_match </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_format_type_args_pattern</span><span class="s4">.</span><span class="s1">search</span><span class="s4">(</span><span class="s1">format_type</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">attype_args_match </span><span class="s3">and </span><span class="s1">attype_args_match</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">1</span><span class="s4">):</span>
            <span class="s1">attype_args </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_format_type_args_delim</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span>
                <span class="s1">attype_args_match</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">attype_args </span><span class="s4">= ()</span>

        <span class="s1">match_array_dim </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_format_array_spec_pattern</span><span class="s4">.</span><span class="s1">search</span><span class="s4">(</span><span class="s1">format_type</span><span class="s4">)</span>
        <span class="s0"># Each &quot;[]&quot; in array specs corresponds to an array dimension</span>
        <span class="s1">array_dim </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">match_array_dim</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">1</span><span class="s4">) </span><span class="s3">or </span><span class="s2">&quot;&quot;</span><span class="s4">) // </span><span class="s5">2</span>

        <span class="s0"># Remove all parameters and array specs from format_type to obtain an</span>
        <span class="s0"># ischema_name candidate</span>
        <span class="s1">attype </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_format_type_args_pattern</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">(</span><span class="s2">&quot;&quot;</span><span class="s4">, </span><span class="s1">format_type</span><span class="s4">)</span>
        <span class="s1">attype </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_format_array_spec_pattern</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">(</span><span class="s2">&quot;&quot;</span><span class="s4">, </span><span class="s1">attype</span><span class="s4">)</span>

        <span class="s1">schema_type </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">ischema_names</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">attype</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">(), </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s1">args</span><span class="s4">, </span><span class="s1">kwargs </span><span class="s4">= (), {}</span>

        <span class="s3">if </span><span class="s1">attype </span><span class="s4">== </span><span class="s2">&quot;numeric&quot;</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">attype_args</span><span class="s4">) == </span><span class="s5">2</span><span class="s4">:</span>
                <span class="s1">precision</span><span class="s4">, </span><span class="s1">scale </span><span class="s4">= </span><span class="s1">map</span><span class="s4">(</span><span class="s1">int</span><span class="s4">, </span><span class="s1">attype_args</span><span class="s4">)</span>
                <span class="s1">args </span><span class="s4">= (</span><span class="s1">precision</span><span class="s4">, </span><span class="s1">scale</span><span class="s4">)</span>

        <span class="s3">elif </span><span class="s1">attype </span><span class="s4">== </span><span class="s2">&quot;double precision&quot;</span><span class="s4">:</span>
            <span class="s1">args </span><span class="s4">= (</span><span class="s5">53</span><span class="s4">,)</span>

        <span class="s3">elif </span><span class="s1">attype </span><span class="s4">== </span><span class="s2">&quot;integer&quot;</span><span class="s4">:</span>
            <span class="s1">args </span><span class="s4">= ()</span>

        <span class="s3">elif </span><span class="s1">attype </span><span class="s3">in </span><span class="s4">(</span><span class="s2">&quot;timestamp with time zone&quot;</span><span class="s4">, </span><span class="s2">&quot;time with time zone&quot;</span><span class="s4">):</span>
            <span class="s1">kwargs</span><span class="s4">[</span><span class="s2">&quot;timezone&quot;</span><span class="s4">] = </span><span class="s3">True</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">attype_args</span><span class="s4">) == </span><span class="s5">1</span><span class="s4">:</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s2">&quot;precision&quot;</span><span class="s4">] = </span><span class="s1">int</span><span class="s4">(</span><span class="s1">attype_args</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>

        <span class="s3">elif </span><span class="s1">attype </span><span class="s3">in </span><span class="s4">(</span>
            <span class="s2">&quot;timestamp without time zone&quot;</span><span class="s4">,</span>
            <span class="s2">&quot;time without time zone&quot;</span><span class="s4">,</span>
            <span class="s2">&quot;time&quot;</span><span class="s4">,</span>
        <span class="s4">):</span>
            <span class="s1">kwargs</span><span class="s4">[</span><span class="s2">&quot;timezone&quot;</span><span class="s4">] = </span><span class="s3">False</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">attype_args</span><span class="s4">) == </span><span class="s5">1</span><span class="s4">:</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s2">&quot;precision&quot;</span><span class="s4">] = </span><span class="s1">int</span><span class="s4">(</span><span class="s1">attype_args</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>

        <span class="s3">elif </span><span class="s1">attype </span><span class="s4">== </span><span class="s2">&quot;bit varying&quot;</span><span class="s4">:</span>
            <span class="s1">kwargs</span><span class="s4">[</span><span class="s2">&quot;varying&quot;</span><span class="s4">] = </span><span class="s3">True</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">attype_args</span><span class="s4">) == </span><span class="s5">1</span><span class="s4">:</span>
                <span class="s1">charlen </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">attype_args</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>
                <span class="s1">args </span><span class="s4">= (</span><span class="s1">charlen</span><span class="s4">,)</span>

        <span class="s3">elif </span><span class="s1">attype</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s2">&quot;interval&quot;</span><span class="s4">):</span>
            <span class="s1">schema_type </span><span class="s4">= </span><span class="s1">INTERVAL</span>

            <span class="s1">field_match </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s2">r&quot;interval (.+)&quot;</span><span class="s4">, </span><span class="s1">attype</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">field_match</span><span class="s4">:</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s2">&quot;fields&quot;</span><span class="s4">] = </span><span class="s1">field_match</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">attype_args</span><span class="s4">) == </span><span class="s5">1</span><span class="s4">:</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s2">&quot;precision&quot;</span><span class="s4">] = </span><span class="s1">int</span><span class="s4">(</span><span class="s1">attype_args</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>

        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">enum_or_domain_key </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">util</span><span class="s4">.</span><span class="s1">quoted_token_parser</span><span class="s4">(</span><span class="s1">attype</span><span class="s4">))</span>

            <span class="s3">if </span><span class="s1">enum_or_domain_key </span><span class="s3">in </span><span class="s1">enums</span><span class="s4">:</span>
                <span class="s1">schema_type </span><span class="s4">= </span><span class="s1">ENUM</span>
                <span class="s1">enum </span><span class="s4">= </span><span class="s1">enums</span><span class="s4">[</span><span class="s1">enum_or_domain_key</span><span class="s4">]</span>

                <span class="s1">args </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">enum</span><span class="s4">[</span><span class="s2">&quot;labels&quot;</span><span class="s4">])</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s2">&quot;name&quot;</span><span class="s4">] = </span><span class="s1">enum</span><span class="s4">[</span><span class="s2">&quot;name&quot;</span><span class="s4">]</span>

                <span class="s3">if not </span><span class="s1">enum</span><span class="s4">[</span><span class="s2">&quot;visible&quot;</span><span class="s4">]:</span>
                    <span class="s1">kwargs</span><span class="s4">[</span><span class="s2">&quot;schema&quot;</span><span class="s4">] = </span><span class="s1">enum</span><span class="s4">[</span><span class="s2">&quot;schema&quot;</span><span class="s4">]</span>
                <span class="s1">args </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">enum</span><span class="s4">[</span><span class="s2">&quot;labels&quot;</span><span class="s4">])</span>
            <span class="s3">elif </span><span class="s1">enum_or_domain_key </span><span class="s3">in </span><span class="s1">domains</span><span class="s4">:</span>
                <span class="s1">schema_type </span><span class="s4">= </span><span class="s1">DOMAIN</span>
                <span class="s1">domain </span><span class="s4">= </span><span class="s1">domains</span><span class="s4">[</span><span class="s1">enum_or_domain_key</span><span class="s4">]</span>

                <span class="s1">data_type </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_reflect_type</span><span class="s4">(</span>
                    <span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;type&quot;</span><span class="s4">],</span>
                    <span class="s1">domains</span><span class="s4">,</span>
                    <span class="s1">enums</span><span class="s4">,</span>
                    <span class="s1">type_description</span><span class="s4">=</span><span class="s2">&quot;DOMAIN '%s'&quot; </span><span class="s4">% </span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;name&quot;</span><span class="s4">],</span>
                <span class="s4">)</span>
                <span class="s1">args </span><span class="s4">= (</span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;name&quot;</span><span class="s4">], </span><span class="s1">data_type</span><span class="s4">)</span>

                <span class="s1">kwargs</span><span class="s4">[</span><span class="s2">&quot;collation&quot;</span><span class="s4">] = </span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;collation&quot;</span><span class="s4">]</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s2">&quot;default&quot;</span><span class="s4">] = </span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;default&quot;</span><span class="s4">]</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s2">&quot;not_null&quot;</span><span class="s4">] = </span><span class="s3">not </span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;nullable&quot;</span><span class="s4">]</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s2">&quot;create_type&quot;</span><span class="s4">] = </span><span class="s3">False</span>

                <span class="s3">if </span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;constraints&quot;</span><span class="s4">]:</span>
                    <span class="s0"># We only support a single constraint</span>
                    <span class="s1">check_constraint </span><span class="s4">= </span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;constraints&quot;</span><span class="s4">][</span><span class="s5">0</span><span class="s4">]</span>

                    <span class="s1">kwargs</span><span class="s4">[</span><span class="s2">&quot;constraint_name&quot;</span><span class="s4">] = </span><span class="s1">check_constraint</span><span class="s4">[</span><span class="s2">&quot;name&quot;</span><span class="s4">]</span>
                    <span class="s1">kwargs</span><span class="s4">[</span><span class="s2">&quot;check&quot;</span><span class="s4">] = </span><span class="s1">check_constraint</span><span class="s4">[</span><span class="s2">&quot;check&quot;</span><span class="s4">]</span>

                <span class="s3">if not </span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;visible&quot;</span><span class="s4">]:</span>
                    <span class="s1">kwargs</span><span class="s4">[</span><span class="s2">&quot;schema&quot;</span><span class="s4">] = </span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;schema&quot;</span><span class="s4">]</span>

            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">try</span><span class="s4">:</span>
                    <span class="s1">charlen </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">attype_args</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>
                    <span class="s1">args </span><span class="s4">= (</span><span class="s1">charlen</span><span class="s4">, *</span><span class="s1">attype_args</span><span class="s4">[</span><span class="s5">1</span><span class="s4">:])</span>
                <span class="s3">except </span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">, </span><span class="s1">IndexError</span><span class="s4">):</span>
                    <span class="s1">args </span><span class="s4">= </span><span class="s1">attype_args</span>

        <span class="s3">if not </span><span class="s1">schema_type</span><span class="s4">:</span>
            <span class="s1">util</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                <span class="s2">&quot;Did not recognize type '%s' of %s&quot;</span>
                <span class="s4">% (</span><span class="s1">attype</span><span class="s4">, </span><span class="s1">type_description</span><span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s3">return </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">NULLTYPE</span>

        <span class="s1">data_type </span><span class="s4">= </span><span class="s1">schema_type</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">array_dim </span><span class="s4">&gt;= </span><span class="s5">1</span><span class="s4">:</span>
            <span class="s0"># postgres does not preserve dimensionality or size of array types.</span>
            <span class="s1">data_type </span><span class="s4">= </span><span class="s1">_array</span><span class="s4">.</span><span class="s1">ARRAY</span><span class="s4">(</span><span class="s1">data_type</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">data_type</span>

    <span class="s3">def </span><span class="s1">_get_columns_info</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">rows</span><span class="s4">, </span><span class="s1">domains</span><span class="s4">, </span><span class="s1">enums</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">):</span>
        <span class="s1">columns </span><span class="s4">= </span><span class="s1">defaultdict</span><span class="s4">(</span><span class="s1">list</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">row_dict </span><span class="s3">in </span><span class="s1">rows</span><span class="s4">:</span>
            <span class="s0"># ensure that each table has an entry, even if it has no columns</span>
            <span class="s3">if </span><span class="s1">row_dict</span><span class="s4">[</span><span class="s2">&quot;name&quot;</span><span class="s4">] </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">columns</span><span class="s4">[(</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">row_dict</span><span class="s4">[</span><span class="s2">&quot;table_name&quot;</span><span class="s4">])] = (</span>
                    <span class="s1">ReflectionDefaults</span><span class="s4">.</span><span class="s1">columns</span><span class="s4">()</span>
                <span class="s4">)</span>
                <span class="s3">continue</span>
            <span class="s1">table_cols </span><span class="s4">= </span><span class="s1">columns</span><span class="s4">[(</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">row_dict</span><span class="s4">[</span><span class="s2">&quot;table_name&quot;</span><span class="s4">])]</span>

            <span class="s1">coltype </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_reflect_type</span><span class="s4">(</span>
                <span class="s1">row_dict</span><span class="s4">[</span><span class="s2">&quot;format_type&quot;</span><span class="s4">],</span>
                <span class="s1">domains</span><span class="s4">,</span>
                <span class="s1">enums</span><span class="s4">,</span>
                <span class="s1">type_description</span><span class="s4">=</span><span class="s2">&quot;column '%s'&quot; </span><span class="s4">% </span><span class="s1">row_dict</span><span class="s4">[</span><span class="s2">&quot;name&quot;</span><span class="s4">],</span>
            <span class="s4">)</span>

            <span class="s1">default </span><span class="s4">= </span><span class="s1">row_dict</span><span class="s4">[</span><span class="s2">&quot;default&quot;</span><span class="s4">]</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s1">row_dict</span><span class="s4">[</span><span class="s2">&quot;name&quot;</span><span class="s4">]</span>
            <span class="s1">generated </span><span class="s4">= </span><span class="s1">row_dict</span><span class="s4">[</span><span class="s2">&quot;generated&quot;</span><span class="s4">]</span>
            <span class="s1">nullable </span><span class="s4">= </span><span class="s3">not </span><span class="s1">row_dict</span><span class="s4">[</span><span class="s2">&quot;not_null&quot;</span><span class="s4">]</span>

            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">coltype</span><span class="s4">, </span><span class="s1">DOMAIN</span><span class="s4">):</span>
                <span class="s3">if not </span><span class="s1">default</span><span class="s4">:</span>
                    <span class="s0"># domain can override the default value but</span>
                    <span class="s0"># cant set it to None</span>
                    <span class="s3">if </span><span class="s1">coltype</span><span class="s4">.</span><span class="s1">default </span><span class="s3">is not None</span><span class="s4">:</span>
                        <span class="s1">default </span><span class="s4">= </span><span class="s1">coltype</span><span class="s4">.</span><span class="s1">default</span>

                <span class="s1">nullable </span><span class="s4">= </span><span class="s1">nullable </span><span class="s3">and not </span><span class="s1">coltype</span><span class="s4">.</span><span class="s1">not_null</span>

            <span class="s1">identity </span><span class="s4">= </span><span class="s1">row_dict</span><span class="s4">[</span><span class="s2">&quot;identity_options&quot;</span><span class="s4">]</span>

            <span class="s0"># If a zero byte or blank string depending on driver (is also</span>
            <span class="s0"># absent for older PG versions), then not a generated column.</span>
            <span class="s0"># Otherwise, s = stored. (Other values might be added in the</span>
            <span class="s0"># future.)</span>
            <span class="s3">if </span><span class="s1">generated </span><span class="s3">not in </span><span class="s4">(</span><span class="s3">None</span><span class="s4">, </span><span class="s2">&quot;&quot;</span><span class="s4">, </span><span class="s7">b&quot;</span><span class="s3">\x00</span><span class="s7">&quot;</span><span class="s4">):</span>
                <span class="s1">computed </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span>
                    <span class="s1">sqltext</span><span class="s4">=</span><span class="s1">default</span><span class="s4">, </span><span class="s1">persisted</span><span class="s4">=</span><span class="s1">generated </span><span class="s3">in </span><span class="s4">(</span><span class="s2">&quot;s&quot;</span><span class="s4">, </span><span class="s7">b&quot;s&quot;</span><span class="s4">)</span>
                <span class="s4">)</span>
                <span class="s1">default </span><span class="s4">= </span><span class="s3">None</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">computed </span><span class="s4">= </span><span class="s3">None</span>

            <span class="s0"># adjust the default value</span>
            <span class="s1">autoincrement </span><span class="s4">= </span><span class="s3">False</span>
            <span class="s3">if </span><span class="s1">default </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">match </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">search</span><span class="s4">(</span><span class="s2">r&quot;&quot;&quot;(nextval\(')([^']+)('.*$)&quot;&quot;&quot;</span><span class="s4">, </span><span class="s1">default</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">match </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">issubclass</span><span class="s4">(</span><span class="s1">coltype</span><span class="s4">.</span><span class="s1">_type_affinity</span><span class="s4">, </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">Integer</span><span class="s4">):</span>
                        <span class="s1">autoincrement </span><span class="s4">= </span><span class="s3">True</span>
                    <span class="s0"># the default is related to a Sequence</span>
                    <span class="s3">if </span><span class="s2">&quot;.&quot; </span><span class="s3">not in </span><span class="s1">match</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">2</span><span class="s4">) </span><span class="s3">and </span><span class="s1">schema </span><span class="s3">is not None</span><span class="s4">:</span>
                        <span class="s0"># unconditionally quote the schema name.  this could</span>
                        <span class="s0"># later be enhanced to obey quoting rules /</span>
                        <span class="s0"># &quot;quote schema&quot;</span>
                        <span class="s1">default </span><span class="s4">= (</span>
                            <span class="s1">match</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
                            <span class="s4">+ (</span><span class="s2">'&quot;%s&quot;' </span><span class="s4">% </span><span class="s1">schema</span><span class="s4">)</span>
                            <span class="s4">+ </span><span class="s2">&quot;.&quot;</span>
                            <span class="s4">+ </span><span class="s1">match</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">2</span><span class="s4">)</span>
                            <span class="s4">+ </span><span class="s1">match</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">3</span><span class="s4">)</span>
                        <span class="s4">)</span>

            <span class="s1">column_info </span><span class="s4">= {</span>
                <span class="s2">&quot;name&quot;</span><span class="s4">: </span><span class="s1">name</span><span class="s4">,</span>
                <span class="s2">&quot;type&quot;</span><span class="s4">: </span><span class="s1">coltype</span><span class="s4">,</span>
                <span class="s2">&quot;nullable&quot;</span><span class="s4">: </span><span class="s1">nullable</span><span class="s4">,</span>
                <span class="s2">&quot;default&quot;</span><span class="s4">: </span><span class="s1">default</span><span class="s4">,</span>
                <span class="s2">&quot;autoincrement&quot;</span><span class="s4">: </span><span class="s1">autoincrement </span><span class="s3">or </span><span class="s1">identity </span><span class="s3">is not None</span><span class="s4">,</span>
                <span class="s2">&quot;comment&quot;</span><span class="s4">: </span><span class="s1">row_dict</span><span class="s4">[</span><span class="s2">&quot;comment&quot;</span><span class="s4">],</span>
            <span class="s4">}</span>
            <span class="s3">if </span><span class="s1">computed </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">column_info</span><span class="s4">[</span><span class="s2">&quot;computed&quot;</span><span class="s4">] = </span><span class="s1">computed</span>
            <span class="s3">if </span><span class="s1">identity </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">column_info</span><span class="s4">[</span><span class="s2">&quot;identity&quot;</span><span class="s4">] = </span><span class="s1">identity</span>

            <span class="s1">table_cols</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">column_info</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">columns</span>

    <span class="s4">@</span><span class="s1">lru_cache</span><span class="s4">()</span>
    <span class="s3">def </span><span class="s1">_table_oids_query</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">has_filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">):</span>
        <span class="s1">relkinds </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_kind_to_relkinds</span><span class="s4">(</span><span class="s1">kind</span><span class="s4">)</span>
        <span class="s1">oid_q </span><span class="s4">= </span><span class="s1">select</span><span class="s4">(</span>
            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">, </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span>
        <span class="s4">).</span><span class="s1">where</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_relkind_condition</span><span class="s4">(</span><span class="s1">relkinds</span><span class="s4">))</span>
        <span class="s1">oid_q </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_filter_scope_schema</span><span class="s4">(</span><span class="s1">oid_q</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">=</span><span class="s1">scope</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">has_filter_names</span><span class="s4">:</span>
            <span class="s1">oid_q </span><span class="s4">= </span><span class="s1">oid_q</span><span class="s4">.</span><span class="s1">where</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span><span class="s4">.</span><span class="s1">in_</span><span class="s4">(</span><span class="s1">bindparam</span><span class="s4">(</span><span class="s2">&quot;filter_names&quot;</span><span class="s4">))</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">oid_q</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">flexi_cache</span><span class="s4">(</span>
        <span class="s4">(</span><span class="s2">&quot;schema&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_string</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s2">&quot;filter_names&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_string_list</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s2">&quot;kind&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_plain_obj</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s2">&quot;scope&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_plain_obj</span><span class="s4">),</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">_get_table_oids</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">, **</span><span class="s1">kw</span>
    <span class="s4">):</span>
        <span class="s1">has_filter_names</span><span class="s4">, </span><span class="s1">params </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prepare_filter_names</span><span class="s4">(</span><span class="s1">filter_names</span><span class="s4">)</span>
        <span class="s1">oid_q </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_table_oids_query</span><span class="s4">(</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">has_filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">)</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">execute</span><span class="s4">(</span><span class="s1">oid_q</span><span class="s4">, </span><span class="s1">params</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">result</span><span class="s4">.</span><span class="s1">all</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">lru_cache</span><span class="s4">()</span>
    <span class="s3">def </span><span class="s1">_constraint_query</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">is_unique</span><span class="s4">):</span>
        <span class="s1">con_sq </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conrelid</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conname</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conindid</span><span class="s4">,</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">unnest</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conkey</span><span class="s4">).</span><span class="s1">label</span><span class="s4">(</span>
                    <span class="s2">&quot;attnum&quot;</span>
                <span class="s4">),</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">generate_subscripts</span><span class="s4">(</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conkey</span><span class="s4">, </span><span class="s5">1</span>
                <span class="s4">).</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;ord&quot;</span><span class="s4">),</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_description</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">description</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">outerjoin</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_description</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_description</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">objoid</span>
                <span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">where</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">contype </span><span class="s4">== </span><span class="s1">bindparam</span><span class="s4">(</span><span class="s2">&quot;contype&quot;</span><span class="s4">),</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conrelid</span><span class="s4">.</span><span class="s1">in_</span><span class="s4">(</span><span class="s1">bindparam</span><span class="s4">(</span><span class="s2">&quot;oids&quot;</span><span class="s4">)),</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">subquery</span><span class="s4">(</span><span class="s2">&quot;con&quot;</span><span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s1">attr_sq </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span>
                <span class="s1">con_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conrelid</span><span class="s4">,</span>
                <span class="s1">con_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conname</span><span class="s4">,</span>
                <span class="s1">con_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conindid</span><span class="s4">,</span>
                <span class="s1">con_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">description</span><span class="s4">,</span>
                <span class="s1">con_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">ord</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attname</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">select_from</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
                <span class="s1">con_sq</span><span class="s4">,</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">and_</span><span class="s4">(</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attnum </span><span class="s4">== </span><span class="s1">con_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attnum</span><span class="s4">,</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attrelid </span><span class="s4">== </span><span class="s1">con_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conrelid</span><span class="s4">,</span>
                <span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">where</span><span class="s4">(</span>
                <span class="s0"># NOTE: restate the condition here, since pg15 otherwise</span>
                <span class="s0"># seems to get confused on pscopg2 sometimes, doing</span>
                <span class="s0"># a sequential scan of pg_attribute.</span>
                <span class="s0"># The condition in the con_sq subquery is not actually needed</span>
                <span class="s0"># in pg15, but it may be needed in older versions. Keeping it</span>
                <span class="s0"># does not seems to have any inpact in any case.</span>
                <span class="s1">con_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conrelid</span><span class="s4">.</span><span class="s1">in_</span><span class="s4">(</span><span class="s1">bindparam</span><span class="s4">(</span><span class="s2">&quot;oids&quot;</span><span class="s4">))</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">subquery</span><span class="s4">(</span><span class="s2">&quot;attr&quot;</span><span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s1">constraint_query </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span>
                <span class="s1">attr_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conrelid</span><span class="s4">,</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">array_agg</span><span class="s4">(</span>
                    <span class="s0"># NOTE: cast since some postgresql derivatives may</span>
                    <span class="s0"># not support array_agg on the name type</span>
                    <span class="s1">aggregate_order_by</span><span class="s4">(</span>
                        <span class="s1">attr_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attname</span><span class="s4">.</span><span class="s1">cast</span><span class="s4">(</span><span class="s1">TEXT</span><span class="s4">), </span><span class="s1">attr_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">ord</span>
                    <span class="s4">)</span>
                <span class="s4">).</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;cols&quot;</span><span class="s4">),</span>
                <span class="s1">attr_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conname</span><span class="s4">,</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">min</span><span class="s4">(</span><span class="s1">attr_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">description</span><span class="s4">).</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;description&quot;</span><span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">group_by</span><span class="s4">(</span><span class="s1">attr_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conrelid</span><span class="s4">, </span><span class="s1">attr_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conname</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">order_by</span><span class="s4">(</span><span class="s1">attr_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conrelid</span><span class="s4">, </span><span class="s1">attr_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conname</span><span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">is_unique</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">server_version_info </span><span class="s4">&gt;= (</span><span class="s5">15</span><span class="s4">,):</span>
                <span class="s1">constraint_query </span><span class="s4">= </span><span class="s1">constraint_query</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">,</span>
                    <span class="s1">attr_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conindid </span><span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indexrelid</span><span class="s4">,</span>
                <span class="s4">).</span><span class="s1">add_columns</span><span class="s4">(</span>
                    <span class="s1">sql</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">bool_and</span><span class="s4">(</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indnullsnotdistinct</span>
                    <span class="s4">).</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;indnullsnotdistinct&quot;</span><span class="s4">)</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">constraint_query </span><span class="s4">= </span><span class="s1">constraint_query</span><span class="s4">.</span><span class="s1">add_columns</span><span class="s4">(</span>
                    <span class="s1">sql</span><span class="s4">.</span><span class="s1">false</span><span class="s4">().</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;indnullsnotdistinct&quot;</span><span class="s4">)</span>
                <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">constraint_query </span><span class="s4">= </span><span class="s1">constraint_query</span><span class="s4">.</span><span class="s1">add_columns</span><span class="s4">(</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">null</span><span class="s4">().</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;extra&quot;</span><span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">constraint_query</span>

    <span class="s3">def </span><span class="s1">_reflect_constraint</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">contype</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">, **</span><span class="s1">kw</span>
    <span class="s4">):</span>
        <span class="s0"># used to reflect primary and unique constraint</span>
        <span class="s1">table_oids </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_table_oids</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">, **</span><span class="s1">kw</span>
        <span class="s4">)</span>
        <span class="s1">batches </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">table_oids</span><span class="s4">)</span>
        <span class="s1">is_unique </span><span class="s4">= </span><span class="s1">contype </span><span class="s4">== </span><span class="s2">&quot;u&quot;</span>

        <span class="s3">while </span><span class="s1">batches</span><span class="s4">:</span>
            <span class="s1">batch </span><span class="s4">= </span><span class="s1">batches</span><span class="s4">[</span><span class="s5">0</span><span class="s4">:</span><span class="s5">3000</span><span class="s4">]</span>
            <span class="s1">batches</span><span class="s4">[</span><span class="s5">0</span><span class="s4">:</span><span class="s5">3000</span><span class="s4">] = []</span>

            <span class="s1">result </span><span class="s4">= </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">execute</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_constraint_query</span><span class="s4">(</span><span class="s1">is_unique</span><span class="s4">),</span>
                <span class="s4">{</span><span class="s2">&quot;oids&quot;</span><span class="s4">: [</span><span class="s1">r</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] </span><span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">batch</span><span class="s4">], </span><span class="s2">&quot;contype&quot;</span><span class="s4">: </span><span class="s1">contype</span><span class="s4">},</span>
            <span class="s4">)</span>

            <span class="s1">result_by_oid </span><span class="s4">= </span><span class="s1">defaultdict</span><span class="s4">(</span><span class="s1">list</span><span class="s4">)</span>
            <span class="s3">for </span><span class="s1">oid</span><span class="s4">, </span><span class="s1">cols</span><span class="s4">, </span><span class="s1">constraint_name</span><span class="s4">, </span><span class="s1">comment</span><span class="s4">, </span><span class="s1">extra </span><span class="s3">in </span><span class="s1">result</span><span class="s4">:</span>
                <span class="s1">result_by_oid</span><span class="s4">[</span><span class="s1">oid</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span>
                    <span class="s4">(</span><span class="s1">cols</span><span class="s4">, </span><span class="s1">constraint_name</span><span class="s4">, </span><span class="s1">comment</span><span class="s4">, </span><span class="s1">extra</span><span class="s4">)</span>
                <span class="s4">)</span>

            <span class="s3">for </span><span class="s1">oid</span><span class="s4">, </span><span class="s1">tablename </span><span class="s3">in </span><span class="s1">batch</span><span class="s4">:</span>
                <span class="s1">for_oid </span><span class="s4">= </span><span class="s1">result_by_oid</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">oid</span><span class="s4">, ())</span>
                <span class="s3">if </span><span class="s1">for_oid</span><span class="s4">:</span>
                    <span class="s3">for </span><span class="s1">cols</span><span class="s4">, </span><span class="s1">constraint</span><span class="s4">, </span><span class="s1">comment</span><span class="s4">, </span><span class="s1">extra </span><span class="s3">in </span><span class="s1">for_oid</span><span class="s4">:</span>
                        <span class="s3">if </span><span class="s1">is_unique</span><span class="s4">:</span>
                            <span class="s3">yield </span><span class="s1">tablename</span><span class="s4">, </span><span class="s1">cols</span><span class="s4">, </span><span class="s1">constraint</span><span class="s4">, </span><span class="s1">comment</span><span class="s4">, {</span>
                                <span class="s2">&quot;nullsnotdistinct&quot;</span><span class="s4">: </span><span class="s1">extra</span>
                            <span class="s4">}</span>
                        <span class="s3">else</span><span class="s4">:</span>
                            <span class="s3">yield </span><span class="s1">tablename</span><span class="s4">, </span><span class="s1">cols</span><span class="s4">, </span><span class="s1">constraint</span><span class="s4">, </span><span class="s1">comment</span><span class="s4">, </span><span class="s3">None</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s3">yield </span><span class="s1">tablename</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">get_pk_constraint</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">data </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_multi_pk_constraint</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">,</span>
            <span class="s1">schema</span><span class="s4">=</span><span class="s1">schema</span><span class="s4">,</span>
            <span class="s1">filter_names</span><span class="s4">=[</span><span class="s1">table_name</span><span class="s4">],</span>
            <span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">,</span>
            <span class="s1">kind</span><span class="s4">=</span><span class="s1">ObjectKind</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">,</span>
            <span class="s4">**</span><span class="s1">kw</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_value_or_raise</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_multi_pk_constraint</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">, **</span><span class="s1">kw</span>
    <span class="s4">):</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_reflect_constraint</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">, </span><span class="s2">&quot;p&quot;</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">, **</span><span class="s1">kw</span>
        <span class="s4">)</span>

        <span class="s0"># only a single pk can be present for each table. Return an entry</span>
        <span class="s0"># even if a table has no primary key</span>
        <span class="s1">default </span><span class="s4">= </span><span class="s1">ReflectionDefaults</span><span class="s4">.</span><span class="s1">pk_constraint</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s4">(</span>
                <span class="s4">(</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">),</span>
                <span class="s4">(</span>
                    <span class="s4">{</span>
                        <span class="s2">&quot;constrained_columns&quot;</span><span class="s4">: [] </span><span class="s3">if </span><span class="s1">cols </span><span class="s3">is None else </span><span class="s1">cols</span><span class="s4">,</span>
                        <span class="s2">&quot;name&quot;</span><span class="s4">: </span><span class="s1">pk_name</span><span class="s4">,</span>
                        <span class="s2">&quot;comment&quot;</span><span class="s4">: </span><span class="s1">comment</span><span class="s4">,</span>
                    <span class="s4">}</span>
                    <span class="s3">if </span><span class="s1">pk_name </span><span class="s3">is not None</span>
                    <span class="s3">else </span><span class="s1">default</span><span class="s4">()</span>
                <span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">cols</span><span class="s4">, </span><span class="s1">pk_name</span><span class="s4">, </span><span class="s1">comment</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">result</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">get_foreign_keys</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">,</span>
        <span class="s1">table_name</span><span class="s4">,</span>
        <span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">postgresql_ignore_search_path</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">data </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_multi_foreign_keys</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">,</span>
            <span class="s1">schema</span><span class="s4">=</span><span class="s1">schema</span><span class="s4">,</span>
            <span class="s1">filter_names</span><span class="s4">=[</span><span class="s1">table_name</span><span class="s4">],</span>
            <span class="s1">postgresql_ignore_search_path</span><span class="s4">=</span><span class="s1">postgresql_ignore_search_path</span><span class="s4">,</span>
            <span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">,</span>
            <span class="s1">kind</span><span class="s4">=</span><span class="s1">ObjectKind</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">,</span>
            <span class="s4">**</span><span class="s1">kw</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_value_or_raise</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">lru_cache</span><span class="s4">()</span>
    <span class="s3">def </span><span class="s1">_foreing_key_query</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">has_filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">):</span>
        <span class="s1">pg_class_ref </span><span class="s4">= </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">alias</span><span class="s4">(</span><span class="s2">&quot;cls_ref&quot;</span><span class="s4">)</span>
        <span class="s1">pg_namespace_ref </span><span class="s4">= </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">alias</span><span class="s4">(</span><span class="s2">&quot;nsp_ref&quot;</span><span class="s4">)</span>
        <span class="s1">relkinds </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_kind_to_relkinds</span><span class="s4">(</span><span class="s1">kind</span><span class="s4">)</span>
        <span class="s1">query </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conname</span><span class="s4">,</span>
                <span class="s0"># NOTE: avoid calling pg_get_constraintdef when not needed</span>
                <span class="s0"># to speed up the query</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">case</span><span class="s4">(</span>
                    <span class="s4">(</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">.</span><span class="s1">is_not</span><span class="s4">(</span><span class="s3">None</span><span class="s4">),</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_get_constraintdef</span><span class="s4">(</span>
                            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">, </span><span class="s3">True</span>
                        <span class="s4">),</span>
                    <span class="s4">),</span>
                    <span class="s1">else_</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
                <span class="s4">),</span>
                <span class="s1">pg_namespace_ref</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">nspname</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_description</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">description</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">select_from</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">outerjoin</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">,</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">and_</span><span class="s4">(</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span>
                    <span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conrelid</span><span class="s4">,</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">contype </span><span class="s4">== </span><span class="s2">&quot;f&quot;</span><span class="s4">,</span>
                <span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">outerjoin</span><span class="s4">(</span>
                <span class="s1">pg_class_ref</span><span class="s4">,</span>
                <span class="s1">pg_class_ref</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid </span><span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">confrelid</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">outerjoin</span><span class="s4">(</span>
                <span class="s1">pg_namespace_ref</span><span class="s4">,</span>
                <span class="s1">pg_class_ref</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relnamespace </span><span class="s4">== </span><span class="s1">pg_namespace_ref</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">outerjoin</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_description</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_description</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">objoid</span>
                <span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">order_by</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conname</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">where</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_relkind_condition</span><span class="s4">(</span><span class="s1">relkinds</span><span class="s4">))</span>
        <span class="s4">)</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_filter_scope_schema</span><span class="s4">(</span><span class="s1">query</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">has_filter_names</span><span class="s4">:</span>
            <span class="s1">query </span><span class="s4">= </span><span class="s1">query</span><span class="s4">.</span><span class="s1">where</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span><span class="s4">.</span><span class="s1">in_</span><span class="s4">(</span><span class="s1">bindparam</span><span class="s4">(</span><span class="s2">&quot;filter_names&quot;</span><span class="s4">))</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">query</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_fk_regex_pattern</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0"># optionally quoted token</span>
        <span class="s1">qtoken </span><span class="s4">= </span><span class="s2">'(?:&quot;[^&quot;]+&quot;|[A-Za-z0-9_]+?)'</span>

        <span class="s0"># https://www.postgresql.org/docs/current/static/sql-createtable.html</span>
        <span class="s3">return </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
            <span class="s2">r&quot;FOREIGN KEY \((.*?)\) &quot;</span>
            <span class="s2">rf&quot;REFERENCES (?:(</span><span class="s3">{</span><span class="s1">qtoken</span><span class="s3">}</span><span class="s2">)\.)?(</span><span class="s3">{</span><span class="s1">qtoken</span><span class="s3">}</span><span class="s2">)\(((?:</span><span class="s3">{</span><span class="s1">qtoken</span><span class="s3">}</span><span class="s2">(?: *, *)?)+)\)&quot;  </span><span class="s0"># noqa: E501</span>
            <span class="s2">r&quot;[\s]?(MATCH (FULL|PARTIAL|SIMPLE)+)?&quot;</span>
            <span class="s2">r&quot;[\s]?(ON UPDATE &quot;</span>
            <span class="s2">r&quot;(CASCADE|RESTRICT|NO ACTION|SET NULL|SET DEFAULT)+)?&quot;</span>
            <span class="s2">r&quot;[\s]?(ON DELETE &quot;</span>
            <span class="s2">r&quot;(CASCADE|RESTRICT|NO ACTION|SET NULL|SET DEFAULT)+)?&quot;</span>
            <span class="s2">r&quot;[\s]?(DEFERRABLE|NOT DEFERRABLE)?&quot;</span>
            <span class="s2">r&quot;[\s]?(INITIALLY (DEFERRED|IMMEDIATE)+)?&quot;</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_multi_foreign_keys</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">,</span>
        <span class="s1">schema</span><span class="s4">,</span>
        <span class="s1">filter_names</span><span class="s4">,</span>
        <span class="s1">scope</span><span class="s4">,</span>
        <span class="s1">kind</span><span class="s4">,</span>
        <span class="s1">postgresql_ignore_search_path</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">preparer </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">identifier_preparer</span>

        <span class="s1">has_filter_names</span><span class="s4">, </span><span class="s1">params </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prepare_filter_names</span><span class="s4">(</span><span class="s1">filter_names</span><span class="s4">)</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_foreing_key_query</span><span class="s4">(</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">has_filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">)</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">execute</span><span class="s4">(</span><span class="s1">query</span><span class="s4">, </span><span class="s1">params</span><span class="s4">)</span>

        <span class="s1">FK_REGEX </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fk_regex_pattern</span>

        <span class="s1">fkeys </span><span class="s4">= </span><span class="s1">defaultdict</span><span class="s4">(</span><span class="s1">list</span><span class="s4">)</span>
        <span class="s1">default </span><span class="s4">= </span><span class="s1">ReflectionDefaults</span><span class="s4">.</span><span class="s1">foreign_keys</span>
        <span class="s3">for </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">conname</span><span class="s4">, </span><span class="s1">condef</span><span class="s4">, </span><span class="s1">conschema</span><span class="s4">, </span><span class="s1">comment </span><span class="s3">in </span><span class="s1">result</span><span class="s4">:</span>
            <span class="s0"># ensure that each table has an entry, even if it has</span>
            <span class="s0"># no foreign keys</span>
            <span class="s3">if </span><span class="s1">conname </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">fkeys</span><span class="s4">[(</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">)] = </span><span class="s1">default</span><span class="s4">()</span>
                <span class="s3">continue</span>
            <span class="s1">table_fks </span><span class="s4">= </span><span class="s1">fkeys</span><span class="s4">[(</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">)]</span>
            <span class="s1">m </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">search</span><span class="s4">(</span><span class="s1">FK_REGEX</span><span class="s4">, </span><span class="s1">condef</span><span class="s4">).</span><span class="s1">groups</span><span class="s4">()</span>

            <span class="s4">(</span>
                <span class="s1">constrained_columns</span><span class="s4">,</span>
                <span class="s1">referred_schema</span><span class="s4">,</span>
                <span class="s1">referred_table</span><span class="s4">,</span>
                <span class="s1">referred_columns</span><span class="s4">,</span>
                <span class="s1">_</span><span class="s4">,</span>
                <span class="s1">match</span><span class="s4">,</span>
                <span class="s1">_</span><span class="s4">,</span>
                <span class="s1">onupdate</span><span class="s4">,</span>
                <span class="s1">_</span><span class="s4">,</span>
                <span class="s1">ondelete</span><span class="s4">,</span>
                <span class="s1">deferrable</span><span class="s4">,</span>
                <span class="s1">_</span><span class="s4">,</span>
                <span class="s1">initially</span><span class="s4">,</span>
            <span class="s4">) = </span><span class="s1">m</span>

            <span class="s3">if </span><span class="s1">deferrable </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">deferrable </span><span class="s4">= </span><span class="s3">True if </span><span class="s1">deferrable </span><span class="s4">== </span><span class="s2">&quot;DEFERRABLE&quot; </span><span class="s3">else False</span>
            <span class="s1">constrained_columns </span><span class="s4">= [</span>
                <span class="s1">preparer</span><span class="s4">.</span><span class="s1">_unquote_identifier</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">re</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s2">r&quot;\s*,\s*&quot;</span><span class="s4">, </span><span class="s1">constrained_columns</span><span class="s4">)</span>
            <span class="s4">]</span>

            <span class="s3">if </span><span class="s1">postgresql_ignore_search_path</span><span class="s4">:</span>
                <span class="s0"># when ignoring search path, we use the actual schema</span>
                <span class="s0"># provided it isn't the &quot;default&quot; schema</span>
                <span class="s3">if </span><span class="s1">conschema </span><span class="s4">!= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">default_schema_name</span><span class="s4">:</span>
                    <span class="s1">referred_schema </span><span class="s4">= </span><span class="s1">conschema</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">referred_schema </span><span class="s4">= </span><span class="s1">schema</span>
            <span class="s3">elif </span><span class="s1">referred_schema</span><span class="s4">:</span>
                <span class="s0"># referred_schema is the schema that we regexp'ed from</span>
                <span class="s0"># pg_get_constraintdef().  If the schema is in the search</span>
                <span class="s0"># path, pg_get_constraintdef() will give us None.</span>
                <span class="s1">referred_schema </span><span class="s4">= </span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">_unquote_identifier</span><span class="s4">(</span><span class="s1">referred_schema</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">schema </span><span class="s3">is not None and </span><span class="s1">schema </span><span class="s4">== </span><span class="s1">conschema</span><span class="s4">:</span>
                <span class="s0"># If the actual schema matches the schema of the table</span>
                <span class="s0"># we're reflecting, then we will use that.</span>
                <span class="s1">referred_schema </span><span class="s4">= </span><span class="s1">schema</span>

            <span class="s1">referred_table </span><span class="s4">= </span><span class="s1">preparer</span><span class="s4">.</span><span class="s1">_unquote_identifier</span><span class="s4">(</span><span class="s1">referred_table</span><span class="s4">)</span>
            <span class="s1">referred_columns </span><span class="s4">= [</span>
                <span class="s1">preparer</span><span class="s4">.</span><span class="s1">_unquote_identifier</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">re</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s2">r&quot;\s*,\s&quot;</span><span class="s4">, </span><span class="s1">referred_columns</span><span class="s4">)</span>
            <span class="s4">]</span>
            <span class="s1">options </span><span class="s4">= {</span>
                <span class="s1">k</span><span class="s4">: </span><span class="s1">v</span>
                <span class="s3">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s3">in </span><span class="s4">[</span>
                    <span class="s4">(</span><span class="s2">&quot;onupdate&quot;</span><span class="s4">, </span><span class="s1">onupdate</span><span class="s4">),</span>
                    <span class="s4">(</span><span class="s2">&quot;ondelete&quot;</span><span class="s4">, </span><span class="s1">ondelete</span><span class="s4">),</span>
                    <span class="s4">(</span><span class="s2">&quot;initially&quot;</span><span class="s4">, </span><span class="s1">initially</span><span class="s4">),</span>
                    <span class="s4">(</span><span class="s2">&quot;deferrable&quot;</span><span class="s4">, </span><span class="s1">deferrable</span><span class="s4">),</span>
                    <span class="s4">(</span><span class="s2">&quot;match&quot;</span><span class="s4">, </span><span class="s1">match</span><span class="s4">),</span>
                <span class="s4">]</span>
                <span class="s3">if </span><span class="s1">v </span><span class="s3">is not None and </span><span class="s1">v </span><span class="s4">!= </span><span class="s2">&quot;NO ACTION&quot;</span>
            <span class="s4">}</span>
            <span class="s1">fkey_d </span><span class="s4">= {</span>
                <span class="s2">&quot;name&quot;</span><span class="s4">: </span><span class="s1">conname</span><span class="s4">,</span>
                <span class="s2">&quot;constrained_columns&quot;</span><span class="s4">: </span><span class="s1">constrained_columns</span><span class="s4">,</span>
                <span class="s2">&quot;referred_schema&quot;</span><span class="s4">: </span><span class="s1">referred_schema</span><span class="s4">,</span>
                <span class="s2">&quot;referred_table&quot;</span><span class="s4">: </span><span class="s1">referred_table</span><span class="s4">,</span>
                <span class="s2">&quot;referred_columns&quot;</span><span class="s4">: </span><span class="s1">referred_columns</span><span class="s4">,</span>
                <span class="s2">&quot;options&quot;</span><span class="s4">: </span><span class="s1">options</span><span class="s4">,</span>
                <span class="s2">&quot;comment&quot;</span><span class="s4">: </span><span class="s1">comment</span><span class="s4">,</span>
            <span class="s4">}</span>
            <span class="s1">table_fks</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">fkey_d</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">fkeys</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">get_indexes</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">data </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_multi_indexes</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">,</span>
            <span class="s1">schema</span><span class="s4">=</span><span class="s1">schema</span><span class="s4">,</span>
            <span class="s1">filter_names</span><span class="s4">=[</span><span class="s1">table_name</span><span class="s4">],</span>
            <span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">,</span>
            <span class="s1">kind</span><span class="s4">=</span><span class="s1">ObjectKind</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">,</span>
            <span class="s4">**</span><span class="s1">kw</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_value_or_raise</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_index_query</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">pg_class_index </span><span class="s4">= </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">alias</span><span class="s4">(</span><span class="s2">&quot;cls_idx&quot;</span><span class="s4">)</span>
        <span class="s0"># NOTE: repeating oids clause improve query performance</span>

        <span class="s0"># subquery to get the columns</span>
        <span class="s1">idx_sq </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indexrelid</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indrelid</span><span class="s4">,</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">unnest</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indkey</span><span class="s4">).</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;attnum&quot;</span><span class="s4">),</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">generate_subscripts</span><span class="s4">(</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indkey</span><span class="s4">, </span><span class="s5">1</span>
                <span class="s4">).</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;ord&quot;</span><span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">where</span><span class="s4">(</span>
                <span class="s4">~</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indisprimary</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indrelid</span><span class="s4">.</span><span class="s1">in_</span><span class="s4">(</span><span class="s1">bindparam</span><span class="s4">(</span><span class="s2">&quot;oids&quot;</span><span class="s4">)),</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">subquery</span><span class="s4">(</span><span class="s2">&quot;idx&quot;</span><span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s1">attr_sq </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span>
                <span class="s1">idx_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indexrelid</span><span class="s4">,</span>
                <span class="s1">idx_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indrelid</span><span class="s4">,</span>
                <span class="s1">idx_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">ord</span><span class="s4">,</span>
                <span class="s0"># NOTE: always using pg_get_indexdef is too slow so just</span>
                <span class="s0"># invoke when the element is an expression</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">case</span><span class="s4">(</span>
                    <span class="s4">(</span>
                        <span class="s1">idx_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attnum </span><span class="s4">== </span><span class="s5">0</span><span class="s4">,</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_get_indexdef</span><span class="s4">(</span>
                            <span class="s1">idx_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indexrelid</span><span class="s4">, </span><span class="s1">idx_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">ord </span><span class="s4">+ </span><span class="s5">1</span><span class="s4">, </span><span class="s3">True</span>
                        <span class="s4">),</span>
                    <span class="s4">),</span>
                    <span class="s0"># NOTE: need to cast this since attname is of type &quot;name&quot;</span>
                    <span class="s0"># that's limited to 63 bytes, while pg_get_indexdef</span>
                    <span class="s0"># returns &quot;text&quot; so its output may get cut</span>
                    <span class="s1">else_</span><span class="s4">=</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attname</span><span class="s4">.</span><span class="s1">cast</span><span class="s4">(</span><span class="s1">TEXT</span><span class="s4">),</span>
                <span class="s4">).</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;element&quot;</span><span class="s4">),</span>
                <span class="s4">(</span><span class="s1">idx_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attnum </span><span class="s4">== </span><span class="s5">0</span><span class="s4">).</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;is_expr&quot;</span><span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">select_from</span><span class="s4">(</span><span class="s1">idx_sq</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">outerjoin</span><span class="s4">(</span>
                <span class="s0"># do not remove rows where idx_sq.c.attnum is 0</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">,</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">and_</span><span class="s4">(</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attnum </span><span class="s4">== </span><span class="s1">idx_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attnum</span><span class="s4">,</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_attribute</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">attrelid </span><span class="s4">== </span><span class="s1">idx_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indrelid</span><span class="s4">,</span>
                <span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">where</span><span class="s4">(</span><span class="s1">idx_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indrelid</span><span class="s4">.</span><span class="s1">in_</span><span class="s4">(</span><span class="s1">bindparam</span><span class="s4">(</span><span class="s2">&quot;oids&quot;</span><span class="s4">)))</span>
            <span class="s4">.</span><span class="s1">subquery</span><span class="s4">(</span><span class="s2">&quot;idx_attr&quot;</span><span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s1">cols_sq </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span>
                <span class="s1">attr_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indexrelid</span><span class="s4">,</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">min</span><span class="s4">(</span><span class="s1">attr_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indrelid</span><span class="s4">),</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">array_agg</span><span class="s4">(</span>
                    <span class="s1">aggregate_order_by</span><span class="s4">(</span><span class="s1">attr_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">element</span><span class="s4">, </span><span class="s1">attr_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">ord</span><span class="s4">)</span>
                <span class="s4">).</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;elements&quot;</span><span class="s4">),</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">array_agg</span><span class="s4">(</span>
                    <span class="s1">aggregate_order_by</span><span class="s4">(</span><span class="s1">attr_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">is_expr</span><span class="s4">, </span><span class="s1">attr_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">ord</span><span class="s4">)</span>
                <span class="s4">).</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;elements_is_expr&quot;</span><span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">group_by</span><span class="s4">(</span><span class="s1">attr_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indexrelid</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">subquery</span><span class="s4">(</span><span class="s2">&quot;idx_cols&quot;</span><span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">server_version_info </span><span class="s4">&gt;= (</span><span class="s5">11</span><span class="s4">, </span><span class="s5">0</span><span class="s4">):</span>
            <span class="s1">indnkeyatts </span><span class="s4">= </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indnkeyatts</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">indnkeyatts </span><span class="s4">= </span><span class="s1">sql</span><span class="s4">.</span><span class="s1">null</span><span class="s4">().</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;indnkeyatts&quot;</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">server_version_info </span><span class="s4">&gt;= (</span><span class="s5">15</span><span class="s4">,):</span>
            <span class="s1">nulls_not_distinct </span><span class="s4">= </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indnullsnotdistinct</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">nulls_not_distinct </span><span class="s4">= </span><span class="s1">sql</span><span class="s4">.</span><span class="s1">false</span><span class="s4">().</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;indnullsnotdistinct&quot;</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">select</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indrelid</span><span class="s4">,</span>
                <span class="s1">pg_class_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span><span class="s4">.</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;relname_index&quot;</span><span class="s4">),</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indisunique</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conrelid</span><span class="s4">.</span><span class="s1">is_not</span><span class="s4">(</span><span class="s3">None</span><span class="s4">).</span><span class="s1">label</span><span class="s4">(</span>
                    <span class="s2">&quot;has_constraint&quot;</span>
                <span class="s4">),</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indoption</span><span class="s4">,</span>
                <span class="s1">pg_class_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">reloptions</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_am</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">amname</span><span class="s4">,</span>
                <span class="s0"># NOTE: pg_get_expr is very fast so this case has almost no</span>
                <span class="s0"># performance impact</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">case</span><span class="s4">(</span>
                    <span class="s4">(</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indpred</span><span class="s4">.</span><span class="s1">is_not</span><span class="s4">(</span><span class="s3">None</span><span class="s4">),</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_get_expr</span><span class="s4">(</span>
                            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indpred</span><span class="s4">,</span>
                            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indrelid</span><span class="s4">,</span>
                        <span class="s4">),</span>
                    <span class="s4">),</span>
                    <span class="s1">else_</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
                <span class="s4">).</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;filter_definition&quot;</span><span class="s4">),</span>
                <span class="s1">indnkeyatts</span><span class="s4">,</span>
                <span class="s1">nulls_not_distinct</span><span class="s4">,</span>
                <span class="s1">cols_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">elements</span><span class="s4">,</span>
                <span class="s1">cols_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">elements_is_expr</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">select_from</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">where</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indrelid</span><span class="s4">.</span><span class="s1">in_</span><span class="s4">(</span><span class="s1">bindparam</span><span class="s4">(</span><span class="s2">&quot;oids&quot;</span><span class="s4">)),</span>
                <span class="s4">~</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indisprimary</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
                <span class="s1">pg_class_index</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indexrelid </span><span class="s4">== </span><span class="s1">pg_class_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_am</span><span class="s4">,</span>
                <span class="s1">pg_class_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relam </span><span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_am</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">outerjoin</span><span class="s4">(</span>
                <span class="s1">cols_sq</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indexrelid </span><span class="s4">== </span><span class="s1">cols_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indexrelid</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">outerjoin</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">,</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">and_</span><span class="s4">(</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indrelid</span>
                    <span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conrelid</span><span class="s4">,</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indexrelid</span>
                    <span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conindid</span><span class="s4">,</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">contype</span>
                    <span class="s4">== </span><span class="s1">sql</span><span class="s4">.</span><span class="s1">any_</span><span class="s4">(</span><span class="s1">_array</span><span class="s4">.</span><span class="s1">array</span><span class="s4">((</span><span class="s2">&quot;p&quot;</span><span class="s4">, </span><span class="s2">&quot;u&quot;</span><span class="s4">, </span><span class="s2">&quot;x&quot;</span><span class="s4">))),</span>
                <span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">order_by</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">indrelid</span><span class="s4">, </span><span class="s1">pg_class_index</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span><span class="s4">)</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_multi_indexes</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">, **</span><span class="s1">kw</span>
    <span class="s4">):</span>
        <span class="s1">table_oids </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_table_oids</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">, **</span><span class="s1">kw</span>
        <span class="s4">)</span>

        <span class="s1">indexes </span><span class="s4">= </span><span class="s1">defaultdict</span><span class="s4">(</span><span class="s1">list</span><span class="s4">)</span>
        <span class="s1">default </span><span class="s4">= </span><span class="s1">ReflectionDefaults</span><span class="s4">.</span><span class="s1">indexes</span>

        <span class="s1">batches </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">table_oids</span><span class="s4">)</span>

        <span class="s3">while </span><span class="s1">batches</span><span class="s4">:</span>
            <span class="s1">batch </span><span class="s4">= </span><span class="s1">batches</span><span class="s4">[</span><span class="s5">0</span><span class="s4">:</span><span class="s5">3000</span><span class="s4">]</span>
            <span class="s1">batches</span><span class="s4">[</span><span class="s5">0</span><span class="s4">:</span><span class="s5">3000</span><span class="s4">] = []</span>

            <span class="s1">result </span><span class="s4">= </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">execute</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_index_query</span><span class="s4">, {</span><span class="s2">&quot;oids&quot;</span><span class="s4">: [</span><span class="s1">r</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] </span><span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">batch</span><span class="s4">]}</span>
            <span class="s4">).</span><span class="s1">mappings</span><span class="s4">()</span>

            <span class="s1">result_by_oid </span><span class="s4">= </span><span class="s1">defaultdict</span><span class="s4">(</span><span class="s1">list</span><span class="s4">)</span>
            <span class="s3">for </span><span class="s1">row_dict </span><span class="s3">in </span><span class="s1">result</span><span class="s4">:</span>
                <span class="s1">result_by_oid</span><span class="s4">[</span><span class="s1">row_dict</span><span class="s4">[</span><span class="s2">&quot;indrelid&quot;</span><span class="s4">]].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">row_dict</span><span class="s4">)</span>

            <span class="s3">for </span><span class="s1">oid</span><span class="s4">, </span><span class="s1">table_name </span><span class="s3">in </span><span class="s1">batch</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">oid </span><span class="s3">not in </span><span class="s1">result_by_oid</span><span class="s4">:</span>
                    <span class="s0"># ensure that each table has an entry, even if reflection</span>
                    <span class="s0"># is skipped because not supported</span>
                    <span class="s1">indexes</span><span class="s4">[(</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">)] = </span><span class="s1">default</span><span class="s4">()</span>
                    <span class="s3">continue</span>

                <span class="s3">for </span><span class="s1">row </span><span class="s3">in </span><span class="s1">result_by_oid</span><span class="s4">[</span><span class="s1">oid</span><span class="s4">]:</span>
                    <span class="s1">index_name </span><span class="s4">= </span><span class="s1">row</span><span class="s4">[</span><span class="s2">&quot;relname_index&quot;</span><span class="s4">]</span>

                    <span class="s1">table_indexes </span><span class="s4">= </span><span class="s1">indexes</span><span class="s4">[(</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">)]</span>

                    <span class="s1">all_elements </span><span class="s4">= </span><span class="s1">row</span><span class="s4">[</span><span class="s2">&quot;elements&quot;</span><span class="s4">]</span>
                    <span class="s1">all_elements_is_expr </span><span class="s4">= </span><span class="s1">row</span><span class="s4">[</span><span class="s2">&quot;elements_is_expr&quot;</span><span class="s4">]</span>
                    <span class="s1">indnkeyatts </span><span class="s4">= </span><span class="s1">row</span><span class="s4">[</span><span class="s2">&quot;indnkeyatts&quot;</span><span class="s4">]</span>
                    <span class="s0"># &quot;The number of key columns in the index, not counting any</span>
                    <span class="s0"># included columns, which are merely stored and do not</span>
                    <span class="s0"># participate in the index semantics&quot;</span>
                    <span class="s3">if </span><span class="s1">indnkeyatts </span><span class="s3">and </span><span class="s1">len</span><span class="s4">(</span><span class="s1">all_elements</span><span class="s4">) &gt; </span><span class="s1">indnkeyatts</span><span class="s4">:</span>
                        <span class="s0"># this is a &quot;covering index&quot; which has INCLUDE columns</span>
                        <span class="s0"># as well as regular index columns</span>
                        <span class="s1">inc_cols </span><span class="s4">= </span><span class="s1">all_elements</span><span class="s4">[</span><span class="s1">indnkeyatts</span><span class="s4">:]</span>
                        <span class="s1">idx_elements </span><span class="s4">= </span><span class="s1">all_elements</span><span class="s4">[:</span><span class="s1">indnkeyatts</span><span class="s4">]</span>
                        <span class="s1">idx_elements_is_expr </span><span class="s4">= </span><span class="s1">all_elements_is_expr</span><span class="s4">[</span>
                            <span class="s4">:</span><span class="s1">indnkeyatts</span>
                        <span class="s4">]</span>
                        <span class="s0"># postgresql does not support expression on included</span>
                        <span class="s0"># columns as of v14: &quot;ERROR: expressions are not</span>
                        <span class="s0"># supported in included columns&quot;.</span>
                        <span class="s3">assert </span><span class="s1">all</span><span class="s4">(</span>
                            <span class="s3">not </span><span class="s1">is_expr</span>
                            <span class="s3">for </span><span class="s1">is_expr </span><span class="s3">in </span><span class="s1">all_elements_is_expr</span><span class="s4">[</span><span class="s1">indnkeyatts</span><span class="s4">:]</span>
                        <span class="s4">)</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">idx_elements </span><span class="s4">= </span><span class="s1">all_elements</span>
                        <span class="s1">idx_elements_is_expr </span><span class="s4">= </span><span class="s1">all_elements_is_expr</span>
                        <span class="s1">inc_cols </span><span class="s4">= []</span>

                    <span class="s1">index </span><span class="s4">= {</span><span class="s2">&quot;name&quot;</span><span class="s4">: </span><span class="s1">index_name</span><span class="s4">, </span><span class="s2">&quot;unique&quot;</span><span class="s4">: </span><span class="s1">row</span><span class="s4">[</span><span class="s2">&quot;indisunique&quot;</span><span class="s4">]}</span>
                    <span class="s3">if </span><span class="s1">any</span><span class="s4">(</span><span class="s1">idx_elements_is_expr</span><span class="s4">):</span>
                        <span class="s1">index</span><span class="s4">[</span><span class="s2">&quot;column_names&quot;</span><span class="s4">] = [</span>
                            <span class="s3">None if </span><span class="s1">is_expr </span><span class="s3">else </span><span class="s1">expr</span>
                            <span class="s3">for </span><span class="s1">expr</span><span class="s4">, </span><span class="s1">is_expr </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span>
                                <span class="s1">idx_elements</span><span class="s4">, </span><span class="s1">idx_elements_is_expr</span>
                            <span class="s4">)</span>
                        <span class="s4">]</span>
                        <span class="s1">index</span><span class="s4">[</span><span class="s2">&quot;expressions&quot;</span><span class="s4">] = </span><span class="s1">idx_elements</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">index</span><span class="s4">[</span><span class="s2">&quot;column_names&quot;</span><span class="s4">] = </span><span class="s1">idx_elements</span>

                    <span class="s1">sorting </span><span class="s4">= {}</span>
                    <span class="s3">for </span><span class="s1">col_index</span><span class="s4">, </span><span class="s1">col_flags </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">row</span><span class="s4">[</span><span class="s2">&quot;indoption&quot;</span><span class="s4">]):</span>
                        <span class="s1">col_sorting </span><span class="s4">= ()</span>
                        <span class="s0"># try to set flags only if they differ from PG</span>
                        <span class="s0"># defaults...</span>
                        <span class="s3">if </span><span class="s1">col_flags </span><span class="s4">&amp; </span><span class="s5">0x01</span><span class="s4">:</span>
                            <span class="s1">col_sorting </span><span class="s4">+= (</span><span class="s2">&quot;desc&quot;</span><span class="s4">,)</span>
                            <span class="s3">if not </span><span class="s4">(</span><span class="s1">col_flags </span><span class="s4">&amp; </span><span class="s5">0x02</span><span class="s4">):</span>
                                <span class="s1">col_sorting </span><span class="s4">+= (</span><span class="s2">&quot;nulls_last&quot;</span><span class="s4">,)</span>
                        <span class="s3">else</span><span class="s4">:</span>
                            <span class="s3">if </span><span class="s1">col_flags </span><span class="s4">&amp; </span><span class="s5">0x02</span><span class="s4">:</span>
                                <span class="s1">col_sorting </span><span class="s4">+= (</span><span class="s2">&quot;nulls_first&quot;</span><span class="s4">,)</span>
                        <span class="s3">if </span><span class="s1">col_sorting</span><span class="s4">:</span>
                            <span class="s1">sorting</span><span class="s4">[</span><span class="s1">idx_elements</span><span class="s4">[</span><span class="s1">col_index</span><span class="s4">]] = </span><span class="s1">col_sorting</span>
                    <span class="s3">if </span><span class="s1">sorting</span><span class="s4">:</span>
                        <span class="s1">index</span><span class="s4">[</span><span class="s2">&quot;column_sorting&quot;</span><span class="s4">] = </span><span class="s1">sorting</span>
                    <span class="s3">if </span><span class="s1">row</span><span class="s4">[</span><span class="s2">&quot;has_constraint&quot;</span><span class="s4">]:</span>
                        <span class="s1">index</span><span class="s4">[</span><span class="s2">&quot;duplicates_constraint&quot;</span><span class="s4">] = </span><span class="s1">index_name</span>

                    <span class="s1">dialect_options </span><span class="s4">= {}</span>
                    <span class="s3">if </span><span class="s1">row</span><span class="s4">[</span><span class="s2">&quot;reloptions&quot;</span><span class="s4">]:</span>
                        <span class="s1">dialect_options</span><span class="s4">[</span><span class="s2">&quot;postgresql_with&quot;</span><span class="s4">] = </span><span class="s1">dict</span><span class="s4">(</span>
                            <span class="s4">[</span><span class="s1">option</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s2">&quot;=&quot;</span><span class="s4">) </span><span class="s3">for </span><span class="s1">option </span><span class="s3">in </span><span class="s1">row</span><span class="s4">[</span><span class="s2">&quot;reloptions&quot;</span><span class="s4">]]</span>
                        <span class="s4">)</span>
                    <span class="s0"># it *might* be nice to include that this is 'btree' in the</span>
                    <span class="s0"># reflection info.  But we don't want an Index object</span>
                    <span class="s0"># to have a ``postgresql_using`` in it that is just the</span>
                    <span class="s0"># default, so for the moment leaving this out.</span>
                    <span class="s1">amname </span><span class="s4">= </span><span class="s1">row</span><span class="s4">[</span><span class="s2">&quot;amname&quot;</span><span class="s4">]</span>
                    <span class="s3">if </span><span class="s1">amname </span><span class="s4">!= </span><span class="s2">&quot;btree&quot;</span><span class="s4">:</span>
                        <span class="s1">dialect_options</span><span class="s4">[</span><span class="s2">&quot;postgresql_using&quot;</span><span class="s4">] = </span><span class="s1">row</span><span class="s4">[</span><span class="s2">&quot;amname&quot;</span><span class="s4">]</span>
                    <span class="s3">if </span><span class="s1">row</span><span class="s4">[</span><span class="s2">&quot;filter_definition&quot;</span><span class="s4">]:</span>
                        <span class="s1">dialect_options</span><span class="s4">[</span><span class="s2">&quot;postgresql_where&quot;</span><span class="s4">] = </span><span class="s1">row</span><span class="s4">[</span>
                            <span class="s2">&quot;filter_definition&quot;</span>
                        <span class="s4">]</span>
                    <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">server_version_info </span><span class="s4">&gt;= (</span><span class="s5">11</span><span class="s4">,):</span>
                        <span class="s0"># NOTE: this is legacy, this is part of</span>
                        <span class="s0"># dialect_options now as of #7382</span>
                        <span class="s1">index</span><span class="s4">[</span><span class="s2">&quot;include_columns&quot;</span><span class="s4">] = </span><span class="s1">inc_cols</span>
                        <span class="s1">dialect_options</span><span class="s4">[</span><span class="s2">&quot;postgresql_include&quot;</span><span class="s4">] = </span><span class="s1">inc_cols</span>
                    <span class="s3">if </span><span class="s1">row</span><span class="s4">[</span><span class="s2">&quot;indnullsnotdistinct&quot;</span><span class="s4">]:</span>
                        <span class="s0"># the default is False, so ignore it.</span>
                        <span class="s1">dialect_options</span><span class="s4">[</span><span class="s2">&quot;postgresql_nulls_not_distinct&quot;</span><span class="s4">] = </span><span class="s1">row</span><span class="s4">[</span>
                            <span class="s2">&quot;indnullsnotdistinct&quot;</span>
                        <span class="s4">]</span>

                    <span class="s3">if </span><span class="s1">dialect_options</span><span class="s4">:</span>
                        <span class="s1">index</span><span class="s4">[</span><span class="s2">&quot;dialect_options&quot;</span><span class="s4">] = </span><span class="s1">dialect_options</span>

                    <span class="s1">table_indexes</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">index</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">indexes</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">get_unique_constraints</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span>
    <span class="s4">):</span>
        <span class="s1">data </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_multi_unique_constraints</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">,</span>
            <span class="s1">schema</span><span class="s4">=</span><span class="s1">schema</span><span class="s4">,</span>
            <span class="s1">filter_names</span><span class="s4">=[</span><span class="s1">table_name</span><span class="s4">],</span>
            <span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">,</span>
            <span class="s1">kind</span><span class="s4">=</span><span class="s1">ObjectKind</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">,</span>
            <span class="s4">**</span><span class="s1">kw</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_value_or_raise</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_multi_unique_constraints</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">,</span>
        <span class="s1">schema</span><span class="s4">,</span>
        <span class="s1">filter_names</span><span class="s4">,</span>
        <span class="s1">scope</span><span class="s4">,</span>
        <span class="s1">kind</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_reflect_constraint</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">, </span><span class="s2">&quot;u&quot;</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">, **</span><span class="s1">kw</span>
        <span class="s4">)</span>

        <span class="s0"># each table can have multiple unique constraints</span>
        <span class="s1">uniques </span><span class="s4">= </span><span class="s1">defaultdict</span><span class="s4">(</span><span class="s1">list</span><span class="s4">)</span>
        <span class="s1">default </span><span class="s4">= </span><span class="s1">ReflectionDefaults</span><span class="s4">.</span><span class="s1">unique_constraints</span>
        <span class="s3">for </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">cols</span><span class="s4">, </span><span class="s1">con_name</span><span class="s4">, </span><span class="s1">comment</span><span class="s4">, </span><span class="s1">options </span><span class="s3">in </span><span class="s1">result</span><span class="s4">:</span>
            <span class="s0"># ensure a list is created for each table. leave it empty if</span>
            <span class="s0"># the table has no unique cosntraint</span>
            <span class="s3">if </span><span class="s1">con_name </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">uniques</span><span class="s4">[(</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">)] = </span><span class="s1">default</span><span class="s4">()</span>
                <span class="s3">continue</span>

            <span class="s1">uc_dict </span><span class="s4">= {</span>
                <span class="s2">&quot;column_names&quot;</span><span class="s4">: </span><span class="s1">cols</span><span class="s4">,</span>
                <span class="s2">&quot;name&quot;</span><span class="s4">: </span><span class="s1">con_name</span><span class="s4">,</span>
                <span class="s2">&quot;comment&quot;</span><span class="s4">: </span><span class="s1">comment</span><span class="s4">,</span>
            <span class="s4">}</span>
            <span class="s3">if </span><span class="s1">options</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">options</span><span class="s4">[</span><span class="s2">&quot;nullsnotdistinct&quot;</span><span class="s4">]:</span>
                    <span class="s1">uc_dict</span><span class="s4">[</span><span class="s2">&quot;dialect_options&quot;</span><span class="s4">] = {</span>
                        <span class="s2">&quot;postgresql_nulls_not_distinct&quot;</span><span class="s4">: </span><span class="s1">options</span><span class="s4">[</span>
                            <span class="s2">&quot;nullsnotdistinct&quot;</span>
                        <span class="s4">]</span>
                    <span class="s4">}</span>

            <span class="s1">uniques</span><span class="s4">[(</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">)].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">uc_dict</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">uniques</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">get_table_comment</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">data </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_multi_table_comment</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">,</span>
            <span class="s1">schema</span><span class="s4">,</span>
            <span class="s4">[</span><span class="s1">table_name</span><span class="s4">],</span>
            <span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">,</span>
            <span class="s1">kind</span><span class="s4">=</span><span class="s1">ObjectKind</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">,</span>
            <span class="s4">**</span><span class="s1">kw</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_value_or_raise</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">lru_cache</span><span class="s4">()</span>
    <span class="s3">def </span><span class="s1">_comment_query</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">has_filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">):</span>
        <span class="s1">relkinds </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_kind_to_relkinds</span><span class="s4">(</span><span class="s1">kind</span><span class="s4">)</span>
        <span class="s1">query </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_description</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">description</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">select_from</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">outerjoin</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_description</span><span class="s4">,</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">and_</span><span class="s4">(</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span>
                    <span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_description</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">objoid</span><span class="s4">,</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_description</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">objsubid </span><span class="s4">== </span><span class="s5">0</span><span class="s4">,</span>
                <span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">where</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_relkind_condition</span><span class="s4">(</span><span class="s1">relkinds</span><span class="s4">))</span>
        <span class="s4">)</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_filter_scope_schema</span><span class="s4">(</span><span class="s1">query</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">has_filter_names</span><span class="s4">:</span>
            <span class="s1">query </span><span class="s4">= </span><span class="s1">query</span><span class="s4">.</span><span class="s1">where</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span><span class="s4">.</span><span class="s1">in_</span><span class="s4">(</span><span class="s1">bindparam</span><span class="s4">(</span><span class="s2">&quot;filter_names&quot;</span><span class="s4">))</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">query</span>

    <span class="s3">def </span><span class="s1">get_multi_table_comment</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">, **</span><span class="s1">kw</span>
    <span class="s4">):</span>
        <span class="s1">has_filter_names</span><span class="s4">, </span><span class="s1">params </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prepare_filter_names</span><span class="s4">(</span><span class="s1">filter_names</span><span class="s4">)</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_comment_query</span><span class="s4">(</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">has_filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">)</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">execute</span><span class="s4">(</span><span class="s1">query</span><span class="s4">, </span><span class="s1">params</span><span class="s4">)</span>

        <span class="s1">default </span><span class="s4">= </span><span class="s1">ReflectionDefaults</span><span class="s4">.</span><span class="s1">table_comment</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s4">(</span>
                <span class="s4">(</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">table</span><span class="s4">),</span>
                <span class="s4">{</span><span class="s2">&quot;text&quot;</span><span class="s4">: </span><span class="s1">comment</span><span class="s4">} </span><span class="s3">if </span><span class="s1">comment </span><span class="s3">is not None else </span><span class="s1">default</span><span class="s4">(),</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">table</span><span class="s4">, </span><span class="s1">comment </span><span class="s3">in </span><span class="s1">result</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">get_check_constraints</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">data </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_multi_check_constraints</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">,</span>
            <span class="s1">schema</span><span class="s4">,</span>
            <span class="s4">[</span><span class="s1">table_name</span><span class="s4">],</span>
            <span class="s1">scope</span><span class="s4">=</span><span class="s1">ObjectScope</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">,</span>
            <span class="s1">kind</span><span class="s4">=</span><span class="s1">ObjectKind</span><span class="s4">.</span><span class="s1">ANY</span><span class="s4">,</span>
            <span class="s4">**</span><span class="s1">kw</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_value_or_raise</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">lru_cache</span><span class="s4">()</span>
    <span class="s3">def </span><span class="s1">_check_constraint_query</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">has_filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">):</span>
        <span class="s1">relkinds </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_kind_to_relkinds</span><span class="s4">(</span><span class="s1">kind</span><span class="s4">)</span>
        <span class="s1">query </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conname</span><span class="s4">,</span>
                <span class="s0"># NOTE: avoid calling pg_get_constraintdef when not needed</span>
                <span class="s0"># to speed up the query</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">case</span><span class="s4">(</span>
                    <span class="s4">(</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">.</span><span class="s1">is_not</span><span class="s4">(</span><span class="s3">None</span><span class="s4">),</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_get_constraintdef</span><span class="s4">(</span>
                            <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">, </span><span class="s3">True</span>
                        <span class="s4">),</span>
                    <span class="s4">),</span>
                    <span class="s1">else_</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
                <span class="s4">),</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_description</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">description</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">select_from</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">outerjoin</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">,</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">and_</span><span class="s4">(</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span>
                    <span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conrelid</span><span class="s4">,</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">contype </span><span class="s4">== </span><span class="s2">&quot;c&quot;</span><span class="s4">,</span>
                <span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">outerjoin</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_description</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_description</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">objoid</span>
                <span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">order_by</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conname</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">where</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_relkind_condition</span><span class="s4">(</span><span class="s1">relkinds</span><span class="s4">))</span>
        <span class="s4">)</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_class_filter_scope_schema</span><span class="s4">(</span><span class="s1">query</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">has_filter_names</span><span class="s4">:</span>
            <span class="s1">query </span><span class="s4">= </span><span class="s1">query</span><span class="s4">.</span><span class="s1">where</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_class</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">relname</span><span class="s4">.</span><span class="s1">in_</span><span class="s4">(</span><span class="s1">bindparam</span><span class="s4">(</span><span class="s2">&quot;filter_names&quot;</span><span class="s4">))</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">query</span>

    <span class="s3">def </span><span class="s1">get_multi_check_constraints</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span><span class="s4">, **</span><span class="s1">kw</span>
    <span class="s4">):</span>
        <span class="s1">has_filter_names</span><span class="s4">, </span><span class="s1">params </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prepare_filter_names</span><span class="s4">(</span><span class="s1">filter_names</span><span class="s4">)</span>
        <span class="s1">query </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_check_constraint_query</span><span class="s4">(</span>
            <span class="s1">schema</span><span class="s4">, </span><span class="s1">has_filter_names</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">kind</span>
        <span class="s4">)</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">execute</span><span class="s4">(</span><span class="s1">query</span><span class="s4">, </span><span class="s1">params</span><span class="s4">)</span>

        <span class="s1">check_constraints </span><span class="s4">= </span><span class="s1">defaultdict</span><span class="s4">(</span><span class="s1">list</span><span class="s4">)</span>
        <span class="s1">default </span><span class="s4">= </span><span class="s1">ReflectionDefaults</span><span class="s4">.</span><span class="s1">check_constraints</span>
        <span class="s3">for </span><span class="s1">table_name</span><span class="s4">, </span><span class="s1">check_name</span><span class="s4">, </span><span class="s1">src</span><span class="s4">, </span><span class="s1">comment </span><span class="s3">in </span><span class="s1">result</span><span class="s4">:</span>
            <span class="s0"># only two cases for check_name and src: both null or both defined</span>
            <span class="s3">if </span><span class="s1">check_name </span><span class="s3">is None and </span><span class="s1">src </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">check_constraints</span><span class="s4">[(</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">)] = </span><span class="s1">default</span><span class="s4">()</span>
                <span class="s3">continue</span>
            <span class="s0"># samples:</span>
            <span class="s0"># &quot;CHECK (((a &gt; 1) AND (a &lt; 5)))&quot;</span>
            <span class="s0"># &quot;CHECK (((a = 1) OR ((a &gt; 2) AND (a &lt; 5))))&quot;</span>
            <span class="s0"># &quot;CHECK (((a &gt; 1) AND (a &lt; 5))) NOT VALID&quot;</span>
            <span class="s0"># &quot;CHECK (some_boolean_function(a))&quot;</span>
            <span class="s0"># &quot;CHECK (((a\n &lt; 1)\n OR\n (a\n &gt;= 5))\n)&quot;</span>
            <span class="s0"># &quot;CHECK (a NOT NULL) NO INHERIT&quot;</span>
            <span class="s0"># &quot;CHECK (a NOT NULL) NO INHERIT NOT VALID&quot;</span>

            <span class="s1">m </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span>
                <span class="s2">r&quot;^CHECK *\((.+)\)( NO INHERIT)?( NOT VALID)?$&quot;</span><span class="s4">,</span>
                <span class="s1">src</span><span class="s4">,</span>
                <span class="s1">flags</span><span class="s4">=</span><span class="s1">re</span><span class="s4">.</span><span class="s1">DOTALL</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s3">if not </span><span class="s1">m</span><span class="s4">:</span>
                <span class="s1">util</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span><span class="s2">&quot;Could not parse CHECK constraint text: %r&quot; </span><span class="s4">% </span><span class="s1">src</span><span class="s4">)</span>
                <span class="s1">sqltext </span><span class="s4">= </span><span class="s2">&quot;&quot;</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">sqltext </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
                    <span class="s2">r&quot;^[\s\n]*\((.+)\)[\s\n]*$&quot;</span><span class="s4">, </span><span class="s1">flags</span><span class="s4">=</span><span class="s1">re</span><span class="s4">.</span><span class="s1">DOTALL</span>
                <span class="s4">).</span><span class="s1">sub</span><span class="s4">(</span><span class="s2">r&quot;\1&quot;</span><span class="s4">, </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">1</span><span class="s4">))</span>
            <span class="s1">entry </span><span class="s4">= {</span>
                <span class="s2">&quot;name&quot;</span><span class="s4">: </span><span class="s1">check_name</span><span class="s4">,</span>
                <span class="s2">&quot;sqltext&quot;</span><span class="s4">: </span><span class="s1">sqltext</span><span class="s4">,</span>
                <span class="s2">&quot;comment&quot;</span><span class="s4">: </span><span class="s1">comment</span><span class="s4">,</span>
            <span class="s4">}</span>
            <span class="s3">if </span><span class="s1">m</span><span class="s4">:</span>
                <span class="s1">do </span><span class="s4">= {}</span>
                <span class="s3">if </span><span class="s2">&quot; NOT VALID&quot; </span><span class="s3">in </span><span class="s1">m</span><span class="s4">.</span><span class="s1">groups</span><span class="s4">():</span>
                    <span class="s1">do</span><span class="s4">[</span><span class="s2">&quot;not_valid&quot;</span><span class="s4">] = </span><span class="s3">True</span>
                <span class="s3">if </span><span class="s2">&quot; NO INHERIT&quot; </span><span class="s3">in </span><span class="s1">m</span><span class="s4">.</span><span class="s1">groups</span><span class="s4">():</span>
                    <span class="s1">do</span><span class="s4">[</span><span class="s2">&quot;no_inherit&quot;</span><span class="s4">] = </span><span class="s3">True</span>
                <span class="s3">if </span><span class="s1">do</span><span class="s4">:</span>
                    <span class="s1">entry</span><span class="s4">[</span><span class="s2">&quot;dialect_options&quot;</span><span class="s4">] = </span><span class="s1">do</span>

            <span class="s1">check_constraints</span><span class="s4">[(</span><span class="s1">schema</span><span class="s4">, </span><span class="s1">table_name</span><span class="s4">)].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">entry</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">check_constraints</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_pg_type_filter_schema</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">query</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">schema </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">query </span><span class="s4">= </span><span class="s1">query</span><span class="s4">.</span><span class="s1">where</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type_is_visible</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">),</span>
                <span class="s0"># ignore pg_catalog schema</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">nspname </span><span class="s4">!= </span><span class="s2">&quot;pg_catalog&quot;</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">schema </span><span class="s4">!= </span><span class="s2">&quot;*&quot;</span><span class="s4">:</span>
            <span class="s1">query </span><span class="s4">= </span><span class="s1">query</span><span class="s4">.</span><span class="s1">where</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">nspname </span><span class="s4">== </span><span class="s1">schema</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">query</span>

    <span class="s4">@</span><span class="s1">lru_cache</span><span class="s4">()</span>
    <span class="s3">def </span><span class="s1">_enum_query</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">):</span>
        <span class="s1">lbl_agg_sq </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_enum</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">enumtypid</span><span class="s4">,</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">array_agg</span><span class="s4">(</span>
                    <span class="s1">aggregate_order_by</span><span class="s4">(</span>
                        <span class="s0"># NOTE: cast since some postgresql derivatives may</span>
                        <span class="s0"># not support array_agg on the name type</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_enum</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">enumlabel</span><span class="s4">.</span><span class="s1">cast</span><span class="s4">(</span><span class="s1">TEXT</span><span class="s4">),</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_enum</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">enumsortorder</span><span class="s4">,</span>
                    <span class="s4">)</span>
                <span class="s4">).</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;labels&quot;</span><span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">group_by</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_enum</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">enumtypid</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">subquery</span><span class="s4">(</span><span class="s2">&quot;lbl_agg&quot;</span><span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s1">query </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">typname</span><span class="s4">.</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;name&quot;</span><span class="s4">),</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type_is_visible</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">).</span><span class="s1">label</span><span class="s4">(</span>
                    <span class="s2">&quot;visible&quot;</span>
                <span class="s4">),</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">nspname</span><span class="s4">.</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;schema&quot;</span><span class="s4">),</span>
                <span class="s1">lbl_agg_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">labels</span><span class="s4">.</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;labels&quot;</span><span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span>
                <span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">typnamespace</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">outerjoin</span><span class="s4">(</span>
                <span class="s1">lbl_agg_sq</span><span class="s4">, </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid </span><span class="s4">== </span><span class="s1">lbl_agg_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">enumtypid</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">where</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">typtype </span><span class="s4">== </span><span class="s2">&quot;e&quot;</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">order_by</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">nspname</span><span class="s4">, </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">typname</span>
            <span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_type_filter_schema</span><span class="s4">(</span><span class="s1">query</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">_load_enums</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">supports_native_enum</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">[]</span>

        <span class="s1">result </span><span class="s4">= </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">execute</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_enum_query</span><span class="s4">(</span><span class="s1">schema</span><span class="s4">))</span>

        <span class="s1">enums </span><span class="s4">= []</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">visible</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">, </span><span class="s1">labels </span><span class="s3">in </span><span class="s1">result</span><span class="s4">:</span>
            <span class="s1">enums</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span>
                <span class="s4">{</span>
                    <span class="s2">&quot;name&quot;</span><span class="s4">: </span><span class="s1">name</span><span class="s4">,</span>
                    <span class="s2">&quot;schema&quot;</span><span class="s4">: </span><span class="s1">schema</span><span class="s4">,</span>
                    <span class="s2">&quot;visible&quot;</span><span class="s4">: </span><span class="s1">visible</span><span class="s4">,</span>
                    <span class="s2">&quot;labels&quot;</span><span class="s4">: [] </span><span class="s3">if </span><span class="s1">labels </span><span class="s3">is None else </span><span class="s1">labels</span><span class="s4">,</span>
                <span class="s4">}</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">enums</span>

    <span class="s4">@</span><span class="s1">lru_cache</span><span class="s4">()</span>
    <span class="s3">def </span><span class="s1">_domain_query</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">):</span>
        <span class="s1">con_sq </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">contypid</span><span class="s4">,</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">array_agg</span><span class="s4">(</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_get_constraintdef</span><span class="s4">(</span>
                        <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">, </span><span class="s3">True</span>
                    <span class="s4">)</span>
                <span class="s4">).</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;condefs&quot;</span><span class="s4">),</span>
                <span class="s1">sql</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">array_agg</span><span class="s4">(</span>
                    <span class="s0"># NOTE: cast since some postgresql derivatives may</span>
                    <span class="s0"># not support array_agg on the name type</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">conname</span><span class="s4">.</span><span class="s1">cast</span><span class="s4">(</span><span class="s1">TEXT</span><span class="s4">)</span>
                <span class="s4">).</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;connames&quot;</span><span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s0"># The domain this constraint is on; zero if not a domain constraint</span>
            <span class="s4">.</span><span class="s1">where</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">contypid </span><span class="s4">!= </span><span class="s5">0</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">group_by</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_constraint</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">contypid</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">subquery</span><span class="s4">(</span><span class="s2">&quot;domain_constraints&quot;</span><span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s1">query </span><span class="s4">= (</span>
            <span class="s1">select</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">typname</span><span class="s4">.</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;name&quot;</span><span class="s4">),</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">format_type</span><span class="s4">(</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">typbasetype</span><span class="s4">,</span>
                    <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">typtypmod</span><span class="s4">,</span>
                <span class="s4">).</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;attype&quot;</span><span class="s4">),</span>
                <span class="s4">(~</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">typnotnull</span><span class="s4">).</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;nullable&quot;</span><span class="s4">),</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">typdefault</span><span class="s4">.</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;default&quot;</span><span class="s4">),</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type_is_visible</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">).</span><span class="s1">label</span><span class="s4">(</span>
                    <span class="s2">&quot;visible&quot;</span>
                <span class="s4">),</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">nspname</span><span class="s4">.</span><span class="s1">label</span><span class="s4">(</span><span class="s2">&quot;schema&quot;</span><span class="s4">),</span>
                <span class="s1">con_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">condefs</span><span class="s4">,</span>
                <span class="s1">con_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">connames</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_collation</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">collname</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">join</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span>
                <span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">typnamespace</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">outerjoin</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_collation</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">typcollation</span>
                <span class="s4">== </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_collation</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">outerjoin</span><span class="s4">(</span>
                <span class="s1">con_sq</span><span class="s4">,</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">oid </span><span class="s4">== </span><span class="s1">con_sq</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">contypid</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">where</span><span class="s4">(</span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">typtype </span><span class="s4">== </span><span class="s2">&quot;d&quot;</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">order_by</span><span class="s4">(</span>
                <span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_namespace</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">nspname</span><span class="s4">, </span><span class="s1">pg_catalog</span><span class="s4">.</span><span class="s1">pg_type</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">typname</span>
            <span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pg_type_filter_schema</span><span class="s4">(</span><span class="s1">query</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">reflection</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">_load_domains</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">execute</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_domain_query</span><span class="s4">(</span><span class="s1">schema</span><span class="s4">))</span>

        <span class="s1">domains</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">ReflectedDomain</span><span class="s4">] = []</span>
        <span class="s3">for </span><span class="s1">domain </span><span class="s3">in </span><span class="s1">result</span><span class="s4">.</span><span class="s1">mappings</span><span class="s4">():</span>
            <span class="s0"># strip (30) from character varying(30)</span>
            <span class="s1">attype </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">search</span><span class="s4">(</span><span class="s2">r&quot;([^\(]+)&quot;</span><span class="s4">, </span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;attype&quot;</span><span class="s4">]).</span><span class="s1">group</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
            <span class="s1">constraints</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">ReflectedDomainConstraint</span><span class="s4">] = []</span>
            <span class="s3">if </span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;connames&quot;</span><span class="s4">]:</span>
                <span class="s0"># When a domain has multiple CHECK constraints, they will</span>
                <span class="s0"># be tested in alphabetical order by name.</span>
                <span class="s1">sorted_constraints </span><span class="s4">= </span><span class="s1">sorted</span><span class="s4">(</span>
                    <span class="s1">zip</span><span class="s4">(</span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;connames&quot;</span><span class="s4">], </span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;condefs&quot;</span><span class="s4">]),</span>
                    <span class="s1">key</span><span class="s4">=</span><span class="s3">lambda </span><span class="s1">t</span><span class="s4">: </span><span class="s1">t</span><span class="s4">[</span><span class="s5">0</span><span class="s4">],</span>
                <span class="s4">)</span>
                <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">def_ </span><span class="s3">in </span><span class="s1">sorted_constraints</span><span class="s4">:</span>
                    <span class="s0"># constraint is in the form &quot;CHECK (expression)&quot;.</span>
                    <span class="s0"># remove &quot;CHECK (&quot; and the tailing &quot;)&quot;.</span>
                    <span class="s1">check </span><span class="s4">= </span><span class="s1">def_</span><span class="s4">[</span><span class="s5">7</span><span class="s4">:-</span><span class="s5">1</span><span class="s4">]</span>
                    <span class="s1">constraints</span><span class="s4">.</span><span class="s1">append</span><span class="s4">({</span><span class="s2">&quot;name&quot;</span><span class="s4">: </span><span class="s1">name</span><span class="s4">, </span><span class="s2">&quot;check&quot;</span><span class="s4">: </span><span class="s1">check</span><span class="s4">})</span>

            <span class="s1">domain_rec</span><span class="s4">: </span><span class="s1">ReflectedDomain </span><span class="s4">= {</span>
                <span class="s2">&quot;name&quot;</span><span class="s4">: </span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;name&quot;</span><span class="s4">],</span>
                <span class="s2">&quot;schema&quot;</span><span class="s4">: </span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;schema&quot;</span><span class="s4">],</span>
                <span class="s2">&quot;visible&quot;</span><span class="s4">: </span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;visible&quot;</span><span class="s4">],</span>
                <span class="s2">&quot;type&quot;</span><span class="s4">: </span><span class="s1">attype</span><span class="s4">,</span>
                <span class="s2">&quot;nullable&quot;</span><span class="s4">: </span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;nullable&quot;</span><span class="s4">],</span>
                <span class="s2">&quot;default&quot;</span><span class="s4">: </span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;default&quot;</span><span class="s4">],</span>
                <span class="s2">&quot;constraints&quot;</span><span class="s4">: </span><span class="s1">constraints</span><span class="s4">,</span>
                <span class="s2">&quot;collation&quot;</span><span class="s4">: </span><span class="s1">domain</span><span class="s4">[</span><span class="s2">&quot;collname&quot;</span><span class="s4">],</span>
            <span class="s4">}</span>
            <span class="s1">domains</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">domain_rec</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">domains</span>

    <span class="s3">def </span><span class="s1">_set_backslash_escapes</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">connection</span><span class="s4">):</span>
        <span class="s0"># this method is provided as an override hook for descendant</span>
        <span class="s0"># dialects (e.g. Redshift), so removing it may break them</span>
        <span class="s1">std_string </span><span class="s4">= </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">exec_driver_sql</span><span class="s4">(</span>
            <span class="s2">&quot;show standard_conforming_strings&quot;</span>
        <span class="s4">).</span><span class="s1">scalar</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_backslash_escapes </span><span class="s4">= </span><span class="s1">std_string </span><span class="s4">== </span><span class="s2">&quot;off&quot;</span>
</pre>
</body>
</html>