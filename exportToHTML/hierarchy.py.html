<html>
<head>
<title>hierarchy.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
hierarchy.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Hierarchical clustering (:mod:`scipy.cluster.hierarchy`) 
======================================================== 
 
.. currentmodule:: scipy.cluster.hierarchy 
 
These functions cut hierarchical clusterings into flat clusterings 
or find the roots of the forest formed by a cut by providing the flat 
cluster ids of each observation. 
 
.. autosummary:: 
   :toctree: generated/ 
 
   fcluster 
   fclusterdata 
   leaders 
 
These are routines for agglomerative clustering. 
 
.. autosummary:: 
   :toctree: generated/ 
 
   linkage 
   single 
   complete 
   average 
   weighted 
   centroid 
   median 
   ward 
 
These routines compute statistics on hierarchies. 
 
.. autosummary:: 
   :toctree: generated/ 
 
   cophenet 
   from_mlab_linkage 
   inconsistent 
   maxinconsts 
   maxdists 
   maxRstat 
   to_mlab_linkage 
 
Routines for visualizing flat clusters. 
 
.. autosummary:: 
   :toctree: generated/ 
 
   dendrogram 
 
These are data structures and routines for representing hierarchies as 
tree objects. 
 
.. autosummary:: 
   :toctree: generated/ 
 
   ClusterNode 
   leaves_list 
   to_tree 
   cut_tree 
   optimal_leaf_ordering 
 
These are predicates for checking the validity of linkage and 
inconsistency matrices as well as for checking isomorphism of two 
flat cluster assignments. 
 
.. autosummary:: 
   :toctree: generated/ 
 
   is_valid_im 
   is_valid_linkage 
   is_isomorphic 
   is_monotonic 
   correspond 
   num_obs_linkage 
 
Utility routines for plotting: 
 
.. autosummary:: 
   :toctree: generated/ 
 
   set_link_color_palette 
 
Utility classes: 
 
.. autosummary:: 
   :toctree: generated/ 
 
   DisjointSet -- data structure for incremental connectivity queries 
 
&quot;&quot;&quot;</span>
<span class="s2"># Copyright (C) Damian Eads, 2007-2008. New BSD License.</span>

<span class="s2"># hierarchy.py (derived from cluster.py, http://scipy-cluster.googlecode.com)</span>
<span class="s2">#</span>
<span class="s2"># Author: Damian Eads</span>
<span class="s2"># Date:   September 22, 2007</span>
<span class="s2">#</span>
<span class="s2"># Copyright (c) 2007, 2008, Damian Eads</span>
<span class="s2">#</span>
<span class="s2"># All rights reserved.</span>
<span class="s2">#</span>
<span class="s2"># Redistribution and use in source and binary forms, with or without</span>
<span class="s2"># modification, are permitted provided that the following conditions</span>
<span class="s2"># are met:</span>
<span class="s2">#   - Redistributions of source code must retain the above</span>
<span class="s2">#     copyright notice, this list of conditions and the</span>
<span class="s2">#     following disclaimer.</span>
<span class="s2">#   - Redistributions in binary form must reproduce the above copyright</span>
<span class="s2">#     notice, this list of conditions and the following disclaimer</span>
<span class="s2">#     in the documentation and/or other materials provided with the</span>
<span class="s2">#     distribution.</span>
<span class="s2">#   - Neither the name of the author nor the names of its</span>
<span class="s2">#     contributors may be used to endorse or promote products derived</span>
<span class="s2">#     from this software without specific prior written permission.</span>
<span class="s2">#</span>
<span class="s2"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="s2"># &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="s2"># LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="s2"># A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="s2"># OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="s2"># SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="s2"># LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="s2"># DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="s2"># THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="s2"># (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="s2"># OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">import </span><span class="s1">bisect</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">deque</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">_hierarchy</span><span class="s4">, </span><span class="s1">_optimal_leaf_ordering</span>
<span class="s3">import </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">spatial</span><span class="s4">.</span><span class="s1">distance </span><span class="s3">as </span><span class="s1">distance</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">_lib</span><span class="s4">.</span><span class="s1">_array_api </span><span class="s3">import </span><span class="s1">array_namespace</span><span class="s4">, </span><span class="s1">_asarray</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">, </span><span class="s1">is_jax</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">_lib</span><span class="s4">.</span><span class="s1">_disjoint_set </span><span class="s3">import </span><span class="s1">DisjointSet</span>


<span class="s1">_LINKAGE_METHODS </span><span class="s4">= {</span><span class="s5">'single'</span><span class="s4">: </span><span class="s6">0</span><span class="s4">, </span><span class="s5">'complete'</span><span class="s4">: </span><span class="s6">1</span><span class="s4">, </span><span class="s5">'average'</span><span class="s4">: </span><span class="s6">2</span><span class="s4">, </span><span class="s5">'centroid'</span><span class="s4">: </span><span class="s6">3</span><span class="s4">,</span>
                    <span class="s5">'median'</span><span class="s4">: </span><span class="s6">4</span><span class="s4">, </span><span class="s5">'ward'</span><span class="s4">: </span><span class="s6">5</span><span class="s4">, </span><span class="s5">'weighted'</span><span class="s4">: </span><span class="s6">6</span><span class="s4">}</span>
<span class="s1">_EUCLIDEAN_METHODS </span><span class="s4">= (</span><span class="s5">'centroid'</span><span class="s4">, </span><span class="s5">'median'</span><span class="s4">, </span><span class="s5">'ward'</span><span class="s4">)</span>

<span class="s1">__all__ </span><span class="s4">= [</span><span class="s5">'ClusterNode'</span><span class="s4">, </span><span class="s5">'DisjointSet'</span><span class="s4">, </span><span class="s5">'average'</span><span class="s4">, </span><span class="s5">'centroid'</span><span class="s4">, </span><span class="s5">'complete'</span><span class="s4">,</span>
           <span class="s5">'cophenet'</span><span class="s4">, </span><span class="s5">'correspond'</span><span class="s4">, </span><span class="s5">'cut_tree'</span><span class="s4">, </span><span class="s5">'dendrogram'</span><span class="s4">, </span><span class="s5">'fcluster'</span><span class="s4">,</span>
           <span class="s5">'fclusterdata'</span><span class="s4">, </span><span class="s5">'from_mlab_linkage'</span><span class="s4">, </span><span class="s5">'inconsistent'</span><span class="s4">,</span>
           <span class="s5">'is_isomorphic'</span><span class="s4">, </span><span class="s5">'is_monotonic'</span><span class="s4">, </span><span class="s5">'is_valid_im'</span><span class="s4">, </span><span class="s5">'is_valid_linkage'</span><span class="s4">,</span>
           <span class="s5">'leaders'</span><span class="s4">, </span><span class="s5">'leaves_list'</span><span class="s4">, </span><span class="s5">'linkage'</span><span class="s4">, </span><span class="s5">'maxRstat'</span><span class="s4">, </span><span class="s5">'maxdists'</span><span class="s4">,</span>
           <span class="s5">'maxinconsts'</span><span class="s4">, </span><span class="s5">'median'</span><span class="s4">, </span><span class="s5">'num_obs_linkage'</span><span class="s4">, </span><span class="s5">'optimal_leaf_ordering'</span><span class="s4">,</span>
           <span class="s5">'set_link_color_palette'</span><span class="s4">, </span><span class="s5">'single'</span><span class="s4">, </span><span class="s5">'to_mlab_linkage'</span><span class="s4">, </span><span class="s5">'to_tree'</span><span class="s4">,</span>
           <span class="s5">'ward'</span><span class="s4">, </span><span class="s5">'weighted'</span><span class="s4">]</span>


<span class="s3">class </span><span class="s1">ClusterWarning</span><span class="s4">(</span><span class="s1">UserWarning</span><span class="s4">):</span>
    <span class="s3">pass</span>


<span class="s3">def </span><span class="s1">_warning</span><span class="s4">(</span><span class="s1">s</span><span class="s4">):</span>
    <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span><span class="s5">'scipy.cluster: %s' </span><span class="s4">% </span><span class="s1">s</span><span class="s4">, </span><span class="s1">ClusterWarning</span><span class="s4">, </span><span class="s1">stacklevel</span><span class="s4">=</span><span class="s6">3</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">int_floor</span><span class="s4">(</span><span class="s1">arr</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">):</span>
    <span class="s2"># array_api_strict is strict about not allowing `int()` on a float array.</span>
    <span class="s2"># That's typically not needed, here it is - so explicitly convert</span>
    <span class="s3">return </span><span class="s1">int</span><span class="s4">(</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">arr</span><span class="s4">), </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">int64</span><span class="s4">))</span>


<span class="s3">def </span><span class="s1">single</span><span class="s4">(</span><span class="s1">y</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Perform single/min/nearest linkage on the condensed distance matrix ``y``. 
 
    Parameters 
    ---------- 
    y : ndarray 
        The upper triangular of the distance matrix. The result of 
        ``pdist`` is returned in this form. 
 
    Returns 
    ------- 
    Z : ndarray 
        The linkage matrix. 
 
    See Also 
    -------- 
    linkage : for advanced creation of hierarchical clusterings. 
    scipy.spatial.distance.pdist : pairwise distance metrics 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import single, fcluster 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    First, we need a toy dataset to play with:: 
 
        x x    x x 
        x        x 
 
        x        x 
        x x    x x 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    Then, we get a condensed distance matrix from this dataset: 
 
    &gt;&gt;&gt; y = pdist(X) 
 
    Finally, we can perform the clustering: 
 
    &gt;&gt;&gt; Z = single(y) 
    &gt;&gt;&gt; Z 
    array([[ 0.,  1.,  1.,  2.], 
           [ 2., 12.,  1.,  3.], 
           [ 3.,  4.,  1.,  2.], 
           [ 5., 14.,  1.,  3.], 
           [ 6.,  7.,  1.,  2.], 
           [ 8., 16.,  1.,  3.], 
           [ 9., 10.,  1.,  2.], 
           [11., 18.,  1.,  3.], 
           [13., 15.,  2.,  6.], 
           [17., 20.,  2.,  9.], 
           [19., 21.,  2., 12.]]) 
 
    The linkage matrix ``Z`` represents a dendrogram - see 
    `scipy.cluster.hierarchy.linkage` for a detailed explanation of its 
    contents. 
 
    We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster 
    each initial point would belong given a distance threshold: 
 
    &gt;&gt;&gt; fcluster(Z, 0.9, criterion='distance') 
    array([ 7,  8,  9, 10, 11, 12,  4,  5,  6,  1,  2,  3], dtype=int32) 
    &gt;&gt;&gt; fcluster(Z, 1, criterion='distance') 
    array([3, 3, 3, 4, 4, 4, 2, 2, 2, 1, 1, 1], dtype=int32) 
    &gt;&gt;&gt; fcluster(Z, 2, criterion='distance') 
    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32) 
 
    Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a 
    plot of the dendrogram. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">linkage</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s5">'single'</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s5">'euclidean'</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">complete</span><span class="s4">(</span><span class="s1">y</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Perform complete/max/farthest point linkage on a condensed distance matrix. 
 
    Parameters 
    ---------- 
    y : ndarray 
        The upper triangular of the distance matrix. The result of 
        ``pdist`` is returned in this form. 
 
    Returns 
    ------- 
    Z : ndarray 
        A linkage matrix containing the hierarchical clustering. See 
        the `linkage` function documentation for more information 
        on its structure. 
 
    See Also 
    -------- 
    linkage : for advanced creation of hierarchical clusterings. 
    scipy.spatial.distance.pdist : pairwise distance metrics 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import complete, fcluster 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    First, we need a toy dataset to play with:: 
 
        x x    x x 
        x        x 
 
        x        x 
        x x    x x 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    Then, we get a condensed distance matrix from this dataset: 
 
    &gt;&gt;&gt; y = pdist(X) 
 
    Finally, we can perform the clustering: 
 
    &gt;&gt;&gt; Z = complete(y) 
    &gt;&gt;&gt; Z 
    array([[ 0.        ,  1.        ,  1.        ,  2.        ], 
           [ 3.        ,  4.        ,  1.        ,  2.        ], 
           [ 6.        ,  7.        ,  1.        ,  2.        ], 
           [ 9.        , 10.        ,  1.        ,  2.        ], 
           [ 2.        , 12.        ,  1.41421356,  3.        ], 
           [ 5.        , 13.        ,  1.41421356,  3.        ], 
           [ 8.        , 14.        ,  1.41421356,  3.        ], 
           [11.        , 15.        ,  1.41421356,  3.        ], 
           [16.        , 17.        ,  4.12310563,  6.        ], 
           [18.        , 19.        ,  4.12310563,  6.        ], 
           [20.        , 21.        ,  5.65685425, 12.        ]]) 
 
    The linkage matrix ``Z`` represents a dendrogram - see 
    `scipy.cluster.hierarchy.linkage` for a detailed explanation of its 
    contents. 
 
    We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster 
    each initial point would belong given a distance threshold: 
 
    &gt;&gt;&gt; fcluster(Z, 0.9, criterion='distance') 
    array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12], dtype=int32) 
    &gt;&gt;&gt; fcluster(Z, 1.5, criterion='distance') 
    array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32) 
    &gt;&gt;&gt; fcluster(Z, 4.5, criterion='distance') 
    array([1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2], dtype=int32) 
    &gt;&gt;&gt; fcluster(Z, 6, criterion='distance') 
    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32) 
 
    Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a 
    plot of the dendrogram. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">linkage</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s5">'complete'</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s5">'euclidean'</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">average</span><span class="s4">(</span><span class="s1">y</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Perform average/UPGMA linkage on a condensed distance matrix. 
 
    Parameters 
    ---------- 
    y : ndarray 
        The upper triangular of the distance matrix. The result of 
        ``pdist`` is returned in this form. 
 
    Returns 
    ------- 
    Z : ndarray 
        A linkage matrix containing the hierarchical clustering. See 
        `linkage` for more information on its structure. 
 
    See Also 
    -------- 
    linkage : for advanced creation of hierarchical clusterings. 
    scipy.spatial.distance.pdist : pairwise distance metrics 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import average, fcluster 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    First, we need a toy dataset to play with:: 
 
        x x    x x 
        x        x 
 
        x        x 
        x x    x x 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    Then, we get a condensed distance matrix from this dataset: 
 
    &gt;&gt;&gt; y = pdist(X) 
 
    Finally, we can perform the clustering: 
 
    &gt;&gt;&gt; Z = average(y) 
    &gt;&gt;&gt; Z 
    array([[ 0.        ,  1.        ,  1.        ,  2.        ], 
           [ 3.        ,  4.        ,  1.        ,  2.        ], 
           [ 6.        ,  7.        ,  1.        ,  2.        ], 
           [ 9.        , 10.        ,  1.        ,  2.        ], 
           [ 2.        , 12.        ,  1.20710678,  3.        ], 
           [ 5.        , 13.        ,  1.20710678,  3.        ], 
           [ 8.        , 14.        ,  1.20710678,  3.        ], 
           [11.        , 15.        ,  1.20710678,  3.        ], 
           [16.        , 17.        ,  3.39675184,  6.        ], 
           [18.        , 19.        ,  3.39675184,  6.        ], 
           [20.        , 21.        ,  4.09206523, 12.        ]]) 
 
    The linkage matrix ``Z`` represents a dendrogram - see 
    `scipy.cluster.hierarchy.linkage` for a detailed explanation of its 
    contents. 
 
    We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster 
    each initial point would belong given a distance threshold: 
 
    &gt;&gt;&gt; fcluster(Z, 0.9, criterion='distance') 
    array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12], dtype=int32) 
    &gt;&gt;&gt; fcluster(Z, 1.5, criterion='distance') 
    array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32) 
    &gt;&gt;&gt; fcluster(Z, 4, criterion='distance') 
    array([1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2], dtype=int32) 
    &gt;&gt;&gt; fcluster(Z, 6, criterion='distance') 
    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32) 
 
    Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a 
    plot of the dendrogram. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">linkage</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s5">'average'</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s5">'euclidean'</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">weighted</span><span class="s4">(</span><span class="s1">y</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Perform weighted/WPGMA linkage on the condensed distance matrix. 
 
    See `linkage` for more information on the return 
    structure and algorithm. 
 
    Parameters 
    ---------- 
    y : ndarray 
        The upper triangular of the distance matrix. The result of 
        ``pdist`` is returned in this form. 
 
    Returns 
    ------- 
    Z : ndarray 
        A linkage matrix containing the hierarchical clustering. See 
        `linkage` for more information on its structure. 
 
    See Also 
    -------- 
    linkage : for advanced creation of hierarchical clusterings. 
    scipy.spatial.distance.pdist : pairwise distance metrics 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import weighted, fcluster 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    First, we need a toy dataset to play with:: 
 
        x x    x x 
        x        x 
 
        x        x 
        x x    x x 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    Then, we get a condensed distance matrix from this dataset: 
 
    &gt;&gt;&gt; y = pdist(X) 
 
    Finally, we can perform the clustering: 
 
    &gt;&gt;&gt; Z = weighted(y) 
    &gt;&gt;&gt; Z 
    array([[ 0.        ,  1.        ,  1.        ,  2.        ], 
           [ 6.        ,  7.        ,  1.        ,  2.        ], 
           [ 3.        ,  4.        ,  1.        ,  2.        ], 
           [ 9.        , 11.        ,  1.        ,  2.        ], 
           [ 2.        , 12.        ,  1.20710678,  3.        ], 
           [ 8.        , 13.        ,  1.20710678,  3.        ], 
           [ 5.        , 14.        ,  1.20710678,  3.        ], 
           [10.        , 15.        ,  1.20710678,  3.        ], 
           [18.        , 19.        ,  3.05595762,  6.        ], 
           [16.        , 17.        ,  3.32379407,  6.        ], 
           [20.        , 21.        ,  4.06357713, 12.        ]]) 
 
    The linkage matrix ``Z`` represents a dendrogram - see 
    `scipy.cluster.hierarchy.linkage` for a detailed explanation of its 
    contents. 
 
    We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster 
    each initial point would belong given a distance threshold: 
 
    &gt;&gt;&gt; fcluster(Z, 0.9, criterion='distance') 
    array([ 7,  8,  9,  1,  2,  3, 10, 11, 12,  4,  6,  5], dtype=int32) 
    &gt;&gt;&gt; fcluster(Z, 1.5, criterion='distance') 
    array([3, 3, 3, 1, 1, 1, 4, 4, 4, 2, 2, 2], dtype=int32) 
    &gt;&gt;&gt; fcluster(Z, 4, criterion='distance') 
    array([2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1, 1], dtype=int32) 
    &gt;&gt;&gt; fcluster(Z, 6, criterion='distance') 
    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32) 
 
    Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a 
    plot of the dendrogram. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">linkage</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s5">'weighted'</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s5">'euclidean'</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">centroid</span><span class="s4">(</span><span class="s1">y</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Perform centroid/UPGMC linkage. 
 
    See `linkage` for more information on the input matrix, 
    return structure, and algorithm. 
 
    The following are common calling conventions: 
 
    1. ``Z = centroid(y)`` 
 
       Performs centroid/UPGMC linkage on the condensed distance 
       matrix ``y``. 
 
    2. ``Z = centroid(X)`` 
 
       Performs centroid/UPGMC linkage on the observation matrix ``X`` 
       using Euclidean distance as the distance metric. 
 
    Parameters 
    ---------- 
    y : ndarray 
        A condensed distance matrix. A condensed 
        distance matrix is a flat array containing the upper 
        triangular of the distance matrix. This is the form that 
        ``pdist`` returns. Alternatively, a collection of 
        m observation vectors in n dimensions may be passed as 
        an m by n array. 
 
    Returns 
    ------- 
    Z : ndarray 
        A linkage matrix containing the hierarchical clustering. See 
        the `linkage` function documentation for more information 
        on its structure. 
 
    See Also 
    -------- 
    linkage : for advanced creation of hierarchical clusterings. 
    scipy.spatial.distance.pdist : pairwise distance metrics 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import centroid, fcluster 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    First, we need a toy dataset to play with:: 
 
        x x    x x 
        x        x 
 
        x        x 
        x x    x x 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    Then, we get a condensed distance matrix from this dataset: 
 
    &gt;&gt;&gt; y = pdist(X) 
 
    Finally, we can perform the clustering: 
 
    &gt;&gt;&gt; Z = centroid(y) 
    &gt;&gt;&gt; Z 
    array([[ 0.        ,  1.        ,  1.        ,  2.        ], 
           [ 3.        ,  4.        ,  1.        ,  2.        ], 
           [ 9.        , 10.        ,  1.        ,  2.        ], 
           [ 6.        ,  7.        ,  1.        ,  2.        ], 
           [ 2.        , 12.        ,  1.11803399,  3.        ], 
           [ 5.        , 13.        ,  1.11803399,  3.        ], 
           [ 8.        , 15.        ,  1.11803399,  3.        ], 
           [11.        , 14.        ,  1.11803399,  3.        ], 
           [18.        , 19.        ,  3.33333333,  6.        ], 
           [16.        , 17.        ,  3.33333333,  6.        ], 
           [20.        , 21.        ,  3.33333333, 12.        ]]) # may vary 
 
    The linkage matrix ``Z`` represents a dendrogram - see 
    `scipy.cluster.hierarchy.linkage` for a detailed explanation of its 
    contents. 
 
    We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster 
    each initial point would belong given a distance threshold: 
 
    &gt;&gt;&gt; fcluster(Z, 0.9, criterion='distance') 
    array([ 7,  8,  9, 10, 11, 12,  1,  2,  3,  4,  5,  6], dtype=int32) # may vary 
    &gt;&gt;&gt; fcluster(Z, 1.1, criterion='distance') 
    array([5, 5, 6, 7, 7, 8, 1, 1, 2, 3, 3, 4], dtype=int32) # may vary 
    &gt;&gt;&gt; fcluster(Z, 2, criterion='distance') 
    array([3, 3, 3, 4, 4, 4, 1, 1, 1, 2, 2, 2], dtype=int32) # may vary 
    &gt;&gt;&gt; fcluster(Z, 4, criterion='distance') 
    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32) 
 
    Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a 
    plot of the dendrogram. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">linkage</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s5">'centroid'</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s5">'euclidean'</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">median</span><span class="s4">(</span><span class="s1">y</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Perform median/WPGMC linkage. 
 
    See `linkage` for more information on the return structure 
    and algorithm. 
 
     The following are common calling conventions: 
 
     1. ``Z = median(y)`` 
 
        Performs median/WPGMC linkage on the condensed distance matrix 
        ``y``.  See ``linkage`` for more information on the return 
        structure and algorithm. 
 
     2. ``Z = median(X)`` 
 
        Performs median/WPGMC linkage on the observation matrix ``X`` 
        using Euclidean distance as the distance metric. See `linkage` 
        for more information on the return structure and algorithm. 
 
    Parameters 
    ---------- 
    y : ndarray 
        A condensed distance matrix. A condensed 
        distance matrix is a flat array containing the upper 
        triangular of the distance matrix. This is the form that 
        ``pdist`` returns.  Alternatively, a collection of 
        m observation vectors in n dimensions may be passed as 
        an m by n array. 
 
    Returns 
    ------- 
    Z : ndarray 
        The hierarchical clustering encoded as a linkage matrix. 
 
    See Also 
    -------- 
    linkage : for advanced creation of hierarchical clusterings. 
    scipy.spatial.distance.pdist : pairwise distance metrics 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import median, fcluster 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    First, we need a toy dataset to play with:: 
 
        x x    x x 
        x        x 
 
        x        x 
        x x    x x 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    Then, we get a condensed distance matrix from this dataset: 
 
    &gt;&gt;&gt; y = pdist(X) 
 
    Finally, we can perform the clustering: 
 
    &gt;&gt;&gt; Z = median(y) 
    &gt;&gt;&gt; Z 
    array([[ 0.        ,  1.        ,  1.        ,  2.        ], 
           [ 3.        ,  4.        ,  1.        ,  2.        ], 
           [ 9.        , 10.        ,  1.        ,  2.        ], 
           [ 6.        ,  7.        ,  1.        ,  2.        ], 
           [ 2.        , 12.        ,  1.11803399,  3.        ], 
           [ 5.        , 13.        ,  1.11803399,  3.        ], 
           [ 8.        , 15.        ,  1.11803399,  3.        ], 
           [11.        , 14.        ,  1.11803399,  3.        ], 
           [18.        , 19.        ,  3.        ,  6.        ], 
           [16.        , 17.        ,  3.5       ,  6.        ], 
           [20.        , 21.        ,  3.25      , 12.        ]]) 
 
    The linkage matrix ``Z`` represents a dendrogram - see 
    `scipy.cluster.hierarchy.linkage` for a detailed explanation of its 
    contents. 
 
    We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster 
    each initial point would belong given a distance threshold: 
 
    &gt;&gt;&gt; fcluster(Z, 0.9, criterion='distance') 
    array([ 7,  8,  9, 10, 11, 12,  1,  2,  3,  4,  5,  6], dtype=int32) 
    &gt;&gt;&gt; fcluster(Z, 1.1, criterion='distance') 
    array([5, 5, 6, 7, 7, 8, 1, 1, 2, 3, 3, 4], dtype=int32) 
    &gt;&gt;&gt; fcluster(Z, 2, criterion='distance') 
    array([3, 3, 3, 4, 4, 4, 1, 1, 1, 2, 2, 2], dtype=int32) 
    &gt;&gt;&gt; fcluster(Z, 4, criterion='distance') 
    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32) 
 
    Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a 
    plot of the dendrogram. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">linkage</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s5">'median'</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s5">'euclidean'</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">ward</span><span class="s4">(</span><span class="s1">y</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Perform Ward's linkage on a condensed distance matrix. 
 
    See `linkage` for more information on the return structure 
    and algorithm. 
 
    The following are common calling conventions: 
 
    1. ``Z = ward(y)`` 
       Performs Ward's linkage on the condensed distance matrix ``y``. 
 
    2. ``Z = ward(X)`` 
       Performs Ward's linkage on the observation matrix ``X`` using 
       Euclidean distance as the distance metric. 
 
    Parameters 
    ---------- 
    y : ndarray 
        A condensed distance matrix. A condensed 
        distance matrix is a flat array containing the upper 
        triangular of the distance matrix. This is the form that 
        ``pdist`` returns.  Alternatively, a collection of 
        m observation vectors in n dimensions may be passed as 
        an m by n array. 
 
    Returns 
    ------- 
    Z : ndarray 
        The hierarchical clustering encoded as a linkage matrix. See 
        `linkage` for more information on the return structure and 
        algorithm. 
 
    See Also 
    -------- 
    linkage : for advanced creation of hierarchical clusterings. 
    scipy.spatial.distance.pdist : pairwise distance metrics 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, fcluster 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    First, we need a toy dataset to play with:: 
 
        x x    x x 
        x        x 
 
        x        x 
        x x    x x 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    Then, we get a condensed distance matrix from this dataset: 
 
    &gt;&gt;&gt; y = pdist(X) 
 
    Finally, we can perform the clustering: 
 
    &gt;&gt;&gt; Z = ward(y) 
    &gt;&gt;&gt; Z 
    array([[ 0.        ,  1.        ,  1.        ,  2.        ], 
           [ 3.        ,  4.        ,  1.        ,  2.        ], 
           [ 6.        ,  7.        ,  1.        ,  2.        ], 
           [ 9.        , 10.        ,  1.        ,  2.        ], 
           [ 2.        , 12.        ,  1.29099445,  3.        ], 
           [ 5.        , 13.        ,  1.29099445,  3.        ], 
           [ 8.        , 14.        ,  1.29099445,  3.        ], 
           [11.        , 15.        ,  1.29099445,  3.        ], 
           [16.        , 17.        ,  5.77350269,  6.        ], 
           [18.        , 19.        ,  5.77350269,  6.        ], 
           [20.        , 21.        ,  8.16496581, 12.        ]]) 
 
    The linkage matrix ``Z`` represents a dendrogram - see 
    `scipy.cluster.hierarchy.linkage` for a detailed explanation of its 
    contents. 
 
    We can use `scipy.cluster.hierarchy.fcluster` to see to which cluster 
    each initial point would belong given a distance threshold: 
 
    &gt;&gt;&gt; fcluster(Z, 0.9, criterion='distance') 
    array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12], dtype=int32) 
    &gt;&gt;&gt; fcluster(Z, 1.1, criterion='distance') 
    array([1, 1, 2, 3, 3, 4, 5, 5, 6, 7, 7, 8], dtype=int32) 
    &gt;&gt;&gt; fcluster(Z, 3, criterion='distance') 
    array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32) 
    &gt;&gt;&gt; fcluster(Z, 9, criterion='distance') 
    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32) 
 
    Also, `scipy.cluster.hierarchy.dendrogram` can be used to generate a 
    plot of the dendrogram. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">linkage</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s5">'ward'</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s5">'euclidean'</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">linkage</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s5">'single'</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s5">'euclidean'</span><span class="s4">, </span><span class="s1">optimal_ordering</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Perform hierarchical/agglomerative clustering. 
 
    The input y may be either a 1-D condensed distance matrix 
    or a 2-D array of observation vectors. 
 
    If y is a 1-D condensed distance matrix, 
    then y must be a :math:`\\binom{n}{2}` sized 
    vector, where n is the number of original observations paired 
    in the distance matrix. The behavior of this function is very 
    similar to the MATLAB linkage function. 
 
    A :math:`(n-1)` by 4 matrix ``Z`` is returned. At the 
    :math:`i`-th iteration, clusters with indices ``Z[i, 0]`` and 
    ``Z[i, 1]`` are combined to form cluster :math:`n + i`. A 
    cluster with an index less than :math:`n` corresponds to one of 
    the :math:`n` original observations. The distance between 
    clusters ``Z[i, 0]`` and ``Z[i, 1]`` is given by ``Z[i, 2]``. The 
    fourth value ``Z[i, 3]`` represents the number of original 
    observations in the newly formed cluster. 
 
    The following linkage methods are used to compute the distance 
    :math:`d(s, t)` between two clusters :math:`s` and 
    :math:`t`. The algorithm begins with a forest of clusters that 
    have yet to be used in the hierarchy being formed. When two 
    clusters :math:`s` and :math:`t` from this forest are combined 
    into a single cluster :math:`u`, :math:`s` and :math:`t` are 
    removed from the forest, and :math:`u` is added to the 
    forest. When only one cluster remains in the forest, the algorithm 
    stops, and this cluster becomes the root. 
 
    A distance matrix is maintained at each iteration. The ``d[i,j]`` 
    entry corresponds to the distance between cluster :math:`i` and 
    :math:`j` in the original forest. 
 
    At each iteration, the algorithm must update the distance matrix 
    to reflect the distance of the newly formed cluster u with the 
    remaining clusters in the forest. 
 
    Suppose there are :math:`|u|` original observations 
    :math:`u[0], \\ldots, u[|u|-1]` in cluster :math:`u` and 
    :math:`|v|` original objects :math:`v[0], \\ldots, v[|v|-1]` in 
    cluster :math:`v`. Recall, :math:`s` and :math:`t` are 
    combined to form cluster :math:`u`. Let :math:`v` be any 
    remaining cluster in the forest that is not :math:`u`. 
 
    The following are methods for calculating the distance between the 
    newly formed cluster :math:`u` and each :math:`v`. 
 
      * method='single' assigns 
 
        .. math:: 
           d(u,v) = \\min(dist(u[i],v[j])) 
 
        for all points :math:`i` in cluster :math:`u` and 
        :math:`j` in cluster :math:`v`. This is also known as the 
        Nearest Point Algorithm. 
 
      * method='complete' assigns 
 
        .. math:: 
           d(u, v) = \\max(dist(u[i],v[j])) 
 
        for all points :math:`i` in cluster u and :math:`j` in 
        cluster :math:`v`. This is also known by the Farthest Point 
        Algorithm or Voor Hees Algorithm. 
 
      * method='average' assigns 
 
        .. math:: 
           d(u,v) = \\sum_{ij} \\frac{d(u[i], v[j])} 
                                   {(|u|*|v|)} 
 
        for all points :math:`i` and :math:`j` where :math:`|u|` 
        and :math:`|v|` are the cardinalities of clusters :math:`u` 
        and :math:`v`, respectively. This is also called the UPGMA 
        algorithm. 
 
      * method='weighted' assigns 
 
        .. math:: 
           d(u,v) = (dist(s,v) + dist(t,v))/2 
 
        where cluster u was formed with cluster s and t and v 
        is a remaining cluster in the forest (also called WPGMA). 
 
      * method='centroid' assigns 
 
        .. math:: 
           dist(s,t) = ||c_s-c_t||_2 
 
        where :math:`c_s` and :math:`c_t` are the centroids of 
        clusters :math:`s` and :math:`t`, respectively. When two 
        clusters :math:`s` and :math:`t` are combined into a new 
        cluster :math:`u`, the new centroid is computed over all the 
        original objects in clusters :math:`s` and :math:`t`. The 
        distance then becomes the Euclidean distance between the 
        centroid of :math:`u` and the centroid of a remaining cluster 
        :math:`v` in the forest. This is also known as the UPGMC 
        algorithm. 
 
      * method='median' assigns :math:`d(s,t)` like the ``centroid`` 
        method. When two clusters :math:`s` and :math:`t` are combined 
        into a new cluster :math:`u`, the average of centroids s and t 
        give the new centroid :math:`u`. This is also known as the 
        WPGMC algorithm. 
 
      * method='ward' uses the Ward variance minimization algorithm. 
        The new entry :math:`d(u,v)` is computed as follows, 
 
        .. math:: 
 
           d(u,v) = \\sqrt{\\frac{|v|+|s|} 
                               {T}d(v,s)^2 
                        + \\frac{|v|+|t|} 
                               {T}d(v,t)^2 
                        - \\frac{|v|} 
                               {T}d(s,t)^2} 
 
        where :math:`u` is the newly joined cluster consisting of 
        clusters :math:`s` and :math:`t`, :math:`v` is an unused 
        cluster in the forest, :math:`T=|v|+|s|+|t|`, and 
        :math:`|*|` is the cardinality of its argument. This is also 
        known as the incremental algorithm. 
 
    Warning: When the minimum distance pair in the forest is chosen, there 
    may be two or more pairs with the same minimum distance. This 
    implementation may choose a different minimum than the MATLAB 
    version. 
 
    Parameters 
    ---------- 
    y : ndarray 
        A condensed distance matrix. A condensed distance matrix 
        is a flat array containing the upper triangular of the distance matrix. 
        This is the form that ``pdist`` returns. Alternatively, a collection of 
        :math:`m` observation vectors in :math:`n` dimensions may be passed as 
        an :math:`m` by :math:`n` array. All elements of the condensed distance 
        matrix must be finite, i.e., no NaNs or infs. 
    method : str, optional 
        The linkage algorithm to use. See the ``Linkage Methods`` section below 
        for full descriptions. 
    metric : str or function, optional 
        The distance metric to use in the case that y is a collection of 
        observation vectors; ignored otherwise. See the ``pdist`` 
        function for a list of valid distance metrics. A custom distance 
        function can also be used. 
    optimal_ordering : bool, optional 
        If True, the linkage matrix will be reordered so that the distance 
        between successive leaves is minimal. This results in a more intuitive 
        tree structure when the data are visualized. defaults to False, because 
        this algorithm can be slow, particularly on large datasets [2]_. See 
        also the `optimal_leaf_ordering` function. 
 
        .. versionadded:: 1.0.0 
 
    Returns 
    ------- 
    Z : ndarray 
        The hierarchical clustering encoded as a linkage matrix. 
 
    Notes 
    ----- 
    1. For method 'single', an optimized algorithm based on minimum spanning 
       tree is implemented. It has time complexity :math:`O(n^2)`. 
       For methods 'complete', 'average', 'weighted' and 'ward', an algorithm 
       called nearest-neighbors chain is implemented. It also has time 
       complexity :math:`O(n^2)`. 
       For other methods, a naive algorithm is implemented with :math:`O(n^3)` 
       time complexity. 
       All algorithms use :math:`O(n^2)` memory. 
       Refer to [1]_ for details about the algorithms. 
    2. Methods 'centroid', 'median', and 'ward' are correctly defined only if 
       Euclidean pairwise metric is used. If `y` is passed as precomputed 
       pairwise distances, then it is the user's responsibility to assure that 
       these distances are in fact Euclidean, otherwise the produced result 
       will be incorrect. 
 
    See Also 
    -------- 
    scipy.spatial.distance.pdist : pairwise distance metrics 
 
    References 
    ---------- 
    .. [1] Daniel Mullner, &quot;Modern hierarchical, agglomerative clustering 
           algorithms&quot;, :arXiv:`1109.2378v1`. 
    .. [2] Ziv Bar-Joseph, David K. Gifford, Tommi S. Jaakkola, &quot;Fast optimal 
           leaf ordering for hierarchical clustering&quot;, 2001. Bioinformatics 
           :doi:`10.1093/bioinformatics/17.suppl_1.S22` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import dendrogram, linkage 
    &gt;&gt;&gt; from matplotlib import pyplot as plt 
    &gt;&gt;&gt; X = [[i] for i in [2, 8, 0, 4, 1, 9, 9, 0]] 
 
    &gt;&gt;&gt; Z = linkage(X, 'ward') 
    &gt;&gt;&gt; fig = plt.figure(figsize=(25, 10)) 
    &gt;&gt;&gt; dn = dendrogram(Z) 
 
    &gt;&gt;&gt; Z = linkage(X, 'single') 
    &gt;&gt;&gt; fig = plt.figure(figsize=(25, 10)) 
    &gt;&gt;&gt; dn = dendrogram(Z) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
    <span class="s1">y </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">method </span><span class="s3">not in </span><span class="s1">_LINKAGE_METHODS</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;Invalid method: </span><span class="s3">{</span><span class="s1">method</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">method </span><span class="s3">in </span><span class="s1">_EUCLIDEAN_METHODS </span><span class="s3">and </span><span class="s1">metric </span><span class="s4">!= </span><span class="s5">'euclidean' </span><span class="s3">and </span><span class="s1">y</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">== </span><span class="s6">2</span><span class="s4">:</span>
        <span class="s1">msg </span><span class="s4">= </span><span class="s5">f&quot;`method=</span><span class="s3">{</span><span class="s1">method</span><span class="s3">}</span><span class="s5">` requires the distance metric to be Euclidean&quot;</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s1">msg</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">y</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">== </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s1">distance</span><span class="s4">.</span><span class="s1">is_valid_y</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'y'</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">y</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">== </span><span class="s6">2</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s1">y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s1">y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] </span><span class="s3">and </span><span class="s1">np</span><span class="s4">.</span><span class="s1">allclose</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">diag</span><span class="s4">(</span><span class="s1">y</span><span class="s4">), </span><span class="s6">0</span><span class="s4">) </span><span class="s3">and</span>
                <span class="s1">xp</span><span class="s4">.</span><span class="s1">all</span><span class="s4">(</span><span class="s1">y </span><span class="s4">&gt;= </span><span class="s6">0</span><span class="s4">) </span><span class="s3">and </span><span class="s1">np</span><span class="s4">.</span><span class="s1">allclose</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">y</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)):</span>
            <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span><span class="s5">'The symmetric non-negative hollow observation '</span>
                          <span class="s5">'matrix looks suspiciously like an uncondensed '</span>
                          <span class="s5">'distance matrix'</span><span class="s4">,</span>
                          <span class="s1">ClusterWarning</span><span class="s4">, </span><span class="s1">stacklevel</span><span class="s4">=</span><span class="s6">2</span><span class="s4">)</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">distance</span><span class="s4">.</span><span class="s1">pdist</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">)</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;`y` must be 1 or 2 dimensional.&quot;</span><span class="s4">)</span>

    <span class="s3">if not </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">all</span><span class="s4">(</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">isfinite</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;The condensed distance matrix must contain only &quot;</span>
                         <span class="s5">&quot;finite values.&quot;</span><span class="s4">)</span>

    <span class="s1">n </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">distance</span><span class="s4">.</span><span class="s1">num_obs_y</span><span class="s4">(</span><span class="s1">y</span><span class="s4">))</span>
    <span class="s1">method_code </span><span class="s4">= </span><span class="s1">_LINKAGE_METHODS</span><span class="s4">[</span><span class="s1">method</span><span class="s4">]</span>

    <span class="s1">y </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">method </span><span class="s4">== </span><span class="s5">'single'</span><span class="s4">:</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">_hierarchy</span><span class="s4">.</span><span class="s1">mst_single_linkage</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">n</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">method </span><span class="s3">in </span><span class="s4">[</span><span class="s5">'complete'</span><span class="s4">, </span><span class="s5">'average'</span><span class="s4">, </span><span class="s5">'weighted'</span><span class="s4">, </span><span class="s5">'ward'</span><span class="s4">]:</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">_hierarchy</span><span class="s4">.</span><span class="s1">nn_chain</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">method_code</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">_hierarchy</span><span class="s4">.</span><span class="s1">fast_linkage</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">method_code</span><span class="s4">)</span>
    <span class="s1">result </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">result</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">optimal_ordering</span><span class="s4">:</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">optimal_leaf_ordering</span><span class="s4">(</span><span class="s1">result</span><span class="s4">, </span><span class="s1">y</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">result</span>


<span class="s3">class </span><span class="s1">ClusterNode</span><span class="s4">:</span>
    <span class="s0">&quot;&quot;&quot; 
    A tree node class for representing a cluster. 
 
    Leaf nodes correspond to original observations, while non-leaf nodes 
    correspond to non-singleton clusters. 
 
    The `to_tree` function converts a matrix returned by the linkage 
    function into an easy-to-use tree representation. 
 
    All parameter names are also attributes. 
 
    Parameters 
    ---------- 
    id : int 
        The node id. 
    left : ClusterNode instance, optional 
        The left child tree node. 
    right : ClusterNode instance, optional 
        The right child tree node. 
    dist : float, optional 
        Distance for this cluster in the linkage matrix. 
    count : int, optional 
        The number of samples in this cluster. 
 
    See Also 
    -------- 
    to_tree : for converting a linkage matrix ``Z`` into a tree object. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">id</span><span class="s4">, </span><span class="s1">left</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">right</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">dist</span><span class="s4">=</span><span class="s6">0</span><span class="s4">, </span><span class="s1">count</span><span class="s4">=</span><span class="s6">1</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">id </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'The id must be non-negative.'</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">dist </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'The distance must be non-negative.'</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s1">left </span><span class="s3">is None and </span><span class="s1">right </span><span class="s3">is not None</span><span class="s4">) </span><span class="s3">or </span><span class="s1">\</span>
           <span class="s4">(</span><span class="s1">left </span><span class="s3">is not None and </span><span class="s1">right </span><span class="s3">is None</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Only full or proper binary trees are permitted.'</span>
                             <span class="s5">'  This node has one child.'</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">count </span><span class="s4">&lt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'A cluster must contain at least one original '</span>
                             <span class="s5">'observation.'</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">id </span><span class="s4">= </span><span class="s1">id</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">left </span><span class="s4">= </span><span class="s1">left</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">right </span><span class="s4">= </span><span class="s1">right</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">dist </span><span class="s4">= </span><span class="s1">dist</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">left </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">count </span><span class="s4">= </span><span class="s1">count</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">count </span><span class="s4">= </span><span class="s1">left</span><span class="s4">.</span><span class="s1">count </span><span class="s4">+ </span><span class="s1">right</span><span class="s4">.</span><span class="s1">count</span>

    <span class="s3">def </span><span class="s1">__lt__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">node</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">ClusterNode</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Can't compare ClusterNode &quot;</span>
                             <span class="s5">f&quot;to type </span><span class="s3">{</span><span class="s1">type</span><span class="s4">(</span><span class="s1">node</span><span class="s4">)</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dist </span><span class="s4">&lt; </span><span class="s1">node</span><span class="s4">.</span><span class="s1">dist</span>

    <span class="s3">def </span><span class="s1">__gt__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">node</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">ClusterNode</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Can't compare ClusterNode &quot;</span>
                             <span class="s5">f&quot;to type </span><span class="s3">{</span><span class="s1">type</span><span class="s4">(</span><span class="s1">node</span><span class="s4">)</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dist </span><span class="s4">&gt; </span><span class="s1">node</span><span class="s4">.</span><span class="s1">dist</span>

    <span class="s3">def </span><span class="s1">__eq__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">node</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">node</span><span class="s4">, </span><span class="s1">ClusterNode</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Can't compare ClusterNode &quot;</span>
                             <span class="s5">f&quot;to type </span><span class="s3">{</span><span class="s1">type</span><span class="s4">(</span><span class="s1">node</span><span class="s4">)</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dist </span><span class="s4">== </span><span class="s1">node</span><span class="s4">.</span><span class="s1">dist</span>

    <span class="s3">def </span><span class="s1">get_id</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        The identifier of the target node. 
 
        For ``0 &lt;= i &lt; n``, `i` corresponds to original observation i. 
        For ``n &lt;= i &lt; 2n-1``, `i` corresponds to non-singleton cluster formed 
        at iteration ``i-n``. 
 
        Returns 
        ------- 
        id : int 
            The identifier of the target node. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">id</span>

    <span class="s3">def </span><span class="s1">get_count</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        The number of leaf nodes (original observations) belonging to 
        the cluster node nd. If the target node is a leaf, 1 is 
        returned. 
 
        Returns 
        ------- 
        get_count : int 
            The number of leaf nodes below the target node. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">count</span>

    <span class="s3">def </span><span class="s1">get_left</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a reference to the left child tree object. 
 
        Returns 
        ------- 
        left : ClusterNode 
            The left child of the target node. If the node is a leaf, 
            None is returned. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">left</span>

    <span class="s3">def </span><span class="s1">get_right</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a reference to the right child tree object. 
 
        Returns 
        ------- 
        right : ClusterNode 
            The left child of the target node. If the node is a leaf, 
            None is returned. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">right</span>

    <span class="s3">def </span><span class="s1">is_leaf</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return True if the target node is a leaf. 
 
        Returns 
        ------- 
        leafness : bool 
            True if the target node is a leaf node. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">left </span><span class="s3">is None</span>

    <span class="s3">def </span><span class="s1">pre_order</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">func</span><span class="s4">=(</span><span class="s3">lambda </span><span class="s1">x</span><span class="s4">: </span><span class="s1">x</span><span class="s4">.</span><span class="s1">id</span><span class="s4">)):</span>
        <span class="s0">&quot;&quot;&quot; 
        Perform pre-order traversal without recursive function calls. 
 
        When a leaf node is first encountered, ``func`` is called with 
        the leaf node as its argument, and its result is appended to 
        the list. 
 
        For example, the statement:: 
 
           ids = root.pre_order(lambda x: x.id) 
 
        returns a list of the node ids corresponding to the leaf nodes 
        of the tree as they appear from left to right. 
 
        Parameters 
        ---------- 
        func : function 
            Applied to each leaf ClusterNode object in the pre-order traversal. 
            Given the ``i``-th leaf node in the pre-order traversal ``n[i]``, 
            the result of ``func(n[i])`` is stored in ``L[i]``. If not 
            provided, the index of the original observation to which the node 
            corresponds is used. 
 
        Returns 
        ------- 
        L : list 
            The pre-order traversal. 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># Do a preorder traversal, caching the result. To avoid having to do</span>
        <span class="s2"># recursion, we'll store the previous index we've visited in a vector.</span>
        <span class="s1">n </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">count</span>

        <span class="s1">curNode </span><span class="s4">= [</span><span class="s3">None</span><span class="s4">] * (</span><span class="s6">2 </span><span class="s4">* </span><span class="s1">n</span><span class="s4">)</span>
        <span class="s1">lvisited </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()</span>
        <span class="s1">rvisited </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()</span>
        <span class="s1">curNode</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] = </span><span class="s1">self</span>
        <span class="s1">k </span><span class="s4">= </span><span class="s6">0</span>
        <span class="s1">preorder </span><span class="s4">= []</span>
        <span class="s3">while </span><span class="s1">k </span><span class="s4">&gt;= </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">nd </span><span class="s4">= </span><span class="s1">curNode</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>
            <span class="s1">ndid </span><span class="s4">= </span><span class="s1">nd</span><span class="s4">.</span><span class="s1">id</span>
            <span class="s3">if </span><span class="s1">nd</span><span class="s4">.</span><span class="s1">is_leaf</span><span class="s4">():</span>
                <span class="s1">preorder</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">func</span><span class="s4">(</span><span class="s1">nd</span><span class="s4">))</span>
                <span class="s1">k </span><span class="s4">= </span><span class="s1">k </span><span class="s4">- </span><span class="s6">1</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">ndid </span><span class="s3">not in </span><span class="s1">lvisited</span><span class="s4">:</span>
                    <span class="s1">curNode</span><span class="s4">[</span><span class="s1">k </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">] = </span><span class="s1">nd</span><span class="s4">.</span><span class="s1">left</span>
                    <span class="s1">lvisited</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">ndid</span><span class="s4">)</span>
                    <span class="s1">k </span><span class="s4">= </span><span class="s1">k </span><span class="s4">+ </span><span class="s6">1</span>
                <span class="s3">elif </span><span class="s1">ndid </span><span class="s3">not in </span><span class="s1">rvisited</span><span class="s4">:</span>
                    <span class="s1">curNode</span><span class="s4">[</span><span class="s1">k </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">] = </span><span class="s1">nd</span><span class="s4">.</span><span class="s1">right</span>
                    <span class="s1">rvisited</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">ndid</span><span class="s4">)</span>
                    <span class="s1">k </span><span class="s4">= </span><span class="s1">k </span><span class="s4">+ </span><span class="s6">1</span>
                <span class="s2"># If we've visited the left and right of this non-leaf</span>
                <span class="s2"># node already, go up in the tree.</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">k </span><span class="s4">= </span><span class="s1">k </span><span class="s4">- </span><span class="s6">1</span>

        <span class="s3">return </span><span class="s1">preorder</span>


<span class="s1">_cnode_bare </span><span class="s4">= </span><span class="s1">ClusterNode</span><span class="s4">(</span><span class="s6">0</span><span class="s4">)</span>
<span class="s1">_cnode_type </span><span class="s4">= </span><span class="s1">type</span><span class="s4">(</span><span class="s1">ClusterNode</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_order_cluster_tree</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return clustering nodes in bottom-up order by distance. 
 
    Parameters 
    ---------- 
    Z : scipy.cluster.linkage array 
        The linkage matrix. 
 
    Returns 
    ------- 
    nodes : list 
        A list of ClusterNode objects. 
    &quot;&quot;&quot;</span>
    <span class="s1">q </span><span class="s4">= </span><span class="s1">deque</span><span class="s4">()</span>
    <span class="s1">tree </span><span class="s4">= </span><span class="s1">to_tree</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">q</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">tree</span><span class="s4">)</span>
    <span class="s1">nodes </span><span class="s4">= []</span>

    <span class="s3">while </span><span class="s1">q</span><span class="s4">:</span>
        <span class="s1">node </span><span class="s4">= </span><span class="s1">q</span><span class="s4">.</span><span class="s1">popleft</span><span class="s4">()</span>
        <span class="s3">if not </span><span class="s1">node</span><span class="s4">.</span><span class="s1">is_leaf</span><span class="s4">():</span>
            <span class="s1">bisect</span><span class="s4">.</span><span class="s1">insort_left</span><span class="s4">(</span><span class="s1">nodes</span><span class="s4">, </span><span class="s1">node</span><span class="s4">)</span>
            <span class="s1">q</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">node</span><span class="s4">.</span><span class="s1">get_right</span><span class="s4">())</span>
            <span class="s1">q</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">node</span><span class="s4">.</span><span class="s1">get_left</span><span class="s4">())</span>
    <span class="s3">return </span><span class="s1">nodes</span>


<span class="s3">def </span><span class="s1">cut_tree</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">n_clusters</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">height</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Given a linkage matrix Z, return the cut tree. 
 
    Parameters 
    ---------- 
    Z : scipy.cluster.linkage array 
        The linkage matrix. 
    n_clusters : array_like, optional 
        Number of clusters in the tree at the cut point. 
    height : array_like, optional 
        The height at which to cut the tree. Only possible for ultrametric 
        trees. 
 
    Returns 
    ------- 
    cutree : array 
        An array indicating group membership at each agglomeration step. I.e., 
        for a full cut tree, in the first column each data point is in its own 
        cluster. At the next step, two nodes are merged. Finally, all 
        singleton and non-singleton clusters are in one group. If `n_clusters` 
        or `height` are given, the columns correspond to the columns of 
        `n_clusters` or `height`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import cluster 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from numpy.random import default_rng 
    &gt;&gt;&gt; rng = default_rng() 
    &gt;&gt;&gt; X = rng.random((50, 4)) 
    &gt;&gt;&gt; Z = cluster.hierarchy.ward(X) 
    &gt;&gt;&gt; cutree = cluster.hierarchy.cut_tree(Z, n_clusters=[5, 10]) 
    &gt;&gt;&gt; cutree[:10] 
    array([[0, 0], 
           [1, 1], 
           [2, 2], 
           [3, 3], 
           [3, 4], 
           [2, 2], 
           [0, 0], 
           [1, 5], 
           [3, 6], 
           [4, 7]])  # random 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">nobs </span><span class="s4">= </span><span class="s1">num_obs_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">nodes </span><span class="s4">= </span><span class="s1">_order_cluster_tree</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">height </span><span class="s3">is not None and </span><span class="s1">n_clusters </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;At least one of either height or n_clusters &quot;</span>
                         <span class="s5">&quot;must be None&quot;</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">height </span><span class="s3">is None and </span><span class="s1">n_clusters </span><span class="s3">is None</span><span class="s4">:  </span><span class="s2"># return the full cut tree</span>
        <span class="s1">cols_idx </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s1">nobs</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">height </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">height </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">height</span><span class="s4">)</span>
        <span class="s1">heights </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">([</span><span class="s1">x</span><span class="s4">.</span><span class="s1">dist </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">nodes</span><span class="s4">])</span>
        <span class="s1">cols_idx </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">searchsorted</span><span class="s4">(</span><span class="s1">heights</span><span class="s4">, </span><span class="s1">height</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">n_clusters </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">n_clusters</span><span class="s4">)</span>
        <span class="s1">cols_idx </span><span class="s4">= </span><span class="s1">nobs </span><span class="s4">- </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">searchsorted</span><span class="s4">(</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s1">nobs</span><span class="s4">), </span><span class="s1">n_clusters</span><span class="s4">)</span>

    <span class="s3">try</span><span class="s4">:</span>
        <span class="s1">n_cols </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">cols_idx</span><span class="s4">)</span>
    <span class="s3">except </span><span class="s1">TypeError</span><span class="s4">:  </span><span class="s2"># scalar</span>
        <span class="s1">n_cols </span><span class="s4">= </span><span class="s6">1</span>
        <span class="s1">cols_idx </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">([</span><span class="s1">cols_idx</span><span class="s4">])</span>

    <span class="s1">groups </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n_cols</span><span class="s4">, </span><span class="s1">nobs</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">int64</span><span class="s4">)</span>
    <span class="s1">last_group </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s1">nobs</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s6">0 </span><span class="s3">in </span><span class="s1">cols_idx</span><span class="s4">:</span>
        <span class="s1">groups</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] = </span><span class="s1">last_group</span>

    <span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">node </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">nodes</span><span class="s4">):</span>
        <span class="s1">idx </span><span class="s4">= </span><span class="s1">node</span><span class="s4">.</span><span class="s1">pre_order</span><span class="s4">()</span>
        <span class="s1">this_group </span><span class="s4">= </span><span class="s1">copy</span><span class="s4">(</span><span class="s1">last_group</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
        <span class="s2"># TODO ARRAY_API complex indexing not supported</span>
        <span class="s1">this_group</span><span class="s4">[</span><span class="s1">idx</span><span class="s4">] = </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">min</span><span class="s4">(</span><span class="s1">last_group</span><span class="s4">[</span><span class="s1">idx</span><span class="s4">])</span>
        <span class="s1">this_group</span><span class="s4">[</span><span class="s1">this_group </span><span class="s4">&gt; </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">max</span><span class="s4">(</span><span class="s1">last_group</span><span class="s4">[</span><span class="s1">idx</span><span class="s4">])] -= </span><span class="s6">1</span>
        <span class="s3">if </span><span class="s1">i </span><span class="s4">+ </span><span class="s6">1 </span><span class="s3">in </span><span class="s1">cols_idx</span><span class="s4">:</span>
            <span class="s1">groups</span><span class="s4">[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">nonzero</span><span class="s4">(</span><span class="s1">i </span><span class="s4">+ </span><span class="s6">1 </span><span class="s4">== </span><span class="s1">cols_idx</span><span class="s4">)[</span><span class="s6">0</span><span class="s4">]] = </span><span class="s1">this_group</span>
        <span class="s1">last_group </span><span class="s4">= </span><span class="s1">this_group</span>

    <span class="s3">return </span><span class="s1">groups</span><span class="s4">.</span><span class="s1">T</span>


<span class="s3">def </span><span class="s1">to_tree</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">rd</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a linkage matrix into an easy-to-use tree object. 
 
    The reference to the root `ClusterNode` object is returned (by default). 
 
    Each `ClusterNode` object has a ``left``, ``right``, ``dist``, ``id``, 
    and ``count`` attribute. The left and right attributes point to 
    ClusterNode objects that were combined to generate the cluster. 
    If both are None then the `ClusterNode` object is a leaf node, its count 
    must be 1, and its distance is meaningless but set to 0. 
 
    *Note: This function is provided for the convenience of the library 
    user. ClusterNodes are not used as input to any of the functions in this 
    library.* 
 
    Parameters 
    ---------- 
    Z : ndarray 
        The linkage matrix in proper form (see the `linkage` 
        function documentation). 
    rd : bool, optional 
        When False (default), a reference to the root `ClusterNode` object is 
        returned.  Otherwise, a tuple ``(r, d)`` is returned. ``r`` is a 
        reference to the root node while ``d`` is a list of `ClusterNode` 
        objects - one per original entry in the linkage matrix plus entries 
        for all clustering steps. If a cluster id is 
        less than the number of samples ``n`` in the data that the linkage 
        matrix describes, then it corresponds to a singleton cluster (leaf 
        node). 
        See `linkage` for more information on the assignment of cluster ids 
        to clusters. 
 
    Returns 
    ------- 
    tree : ClusterNode or tuple (ClusterNode, list of ClusterNode) 
        If ``rd`` is False, a `ClusterNode`. 
        If ``rd`` is True, a list of length ``2*n - 1``, with ``n`` the number 
        of samples.  See the description of `rd` above for more details. 
 
    See Also 
    -------- 
    linkage, is_valid_linkage, ClusterNode 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.cluster import hierarchy 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; x = rng.random((5, 2)) 
    &gt;&gt;&gt; Z = hierarchy.linkage(x) 
    &gt;&gt;&gt; hierarchy.to_tree(Z) 
    &lt;scipy.cluster.hierarchy.ClusterNode object at ... 
    &gt;&gt;&gt; rootnode, nodelist = hierarchy.to_tree(Z, rd=True) 
    &gt;&gt;&gt; rootnode 
    &lt;scipy.cluster.hierarchy.ClusterNode object at ... 
    &gt;&gt;&gt; len(nodelist) 
    9 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'c'</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">is_valid_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'Z'</span><span class="s4">)</span>

    <span class="s2"># Number of original objects is equal to the number of rows plus 1.</span>
    <span class="s1">n </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1</span>

    <span class="s2"># Create a list full of None's to store the node objects</span>
    <span class="s1">d </span><span class="s4">= [</span><span class="s3">None</span><span class="s4">] * (</span><span class="s1">n </span><span class="s4">* </span><span class="s6">2 </span><span class="s4">- </span><span class="s6">1</span><span class="s4">)</span>

    <span class="s2"># Create the nodes corresponding to the n original objects.</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">n</span><span class="s4">):</span>
        <span class="s1">d</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s1">ClusterNode</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)</span>

    <span class="s1">nd </span><span class="s4">= </span><span class="s3">None</span>

    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]):</span>
        <span class="s1">row </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, :]</span>

        <span class="s1">fi </span><span class="s4">= </span><span class="s1">int_floor</span><span class="s4">(</span><span class="s1">row</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">xp</span><span class="s4">)</span>
        <span class="s1">fj </span><span class="s4">= </span><span class="s1">int_floor</span><span class="s4">(</span><span class="s1">row</span><span class="s4">[</span><span class="s6">1</span><span class="s4">], </span><span class="s1">xp</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">fi </span><span class="s4">&gt; </span><span class="s1">i </span><span class="s4">+ </span><span class="s1">n</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">((</span><span class="s5">'Corrupt matrix Z. Index to derivative cluster '</span>
                              <span class="s5">'is used before it is formed. See row %d, '</span>
                              <span class="s5">'column 0'</span><span class="s4">) % </span><span class="s1">fi</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">fj </span><span class="s4">&gt; </span><span class="s1">i </span><span class="s4">+ </span><span class="s1">n</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">((</span><span class="s5">'Corrupt matrix Z. Index to derivative cluster '</span>
                              <span class="s5">'is used before it is formed. See row %d, '</span>
                              <span class="s5">'column 1'</span><span class="s4">) % </span><span class="s1">fj</span><span class="s4">)</span>

        <span class="s1">nd </span><span class="s4">= </span><span class="s1">ClusterNode</span><span class="s4">(</span><span class="s1">i </span><span class="s4">+ </span><span class="s1">n</span><span class="s4">, </span><span class="s1">d</span><span class="s4">[</span><span class="s1">fi</span><span class="s4">], </span><span class="s1">d</span><span class="s4">[</span><span class="s1">fj</span><span class="s4">], </span><span class="s1">row</span><span class="s4">[</span><span class="s6">2</span><span class="s4">])</span>
        <span class="s2">#                ^ id   ^ left ^ right ^ dist</span>
        <span class="s3">if </span><span class="s1">row</span><span class="s4">[</span><span class="s6">3</span><span class="s4">] != </span><span class="s1">nd</span><span class="s4">.</span><span class="s1">count</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">((</span><span class="s5">'Corrupt matrix Z. The count Z[%d,3] is '</span>
                              <span class="s5">'incorrect.'</span><span class="s4">) % </span><span class="s1">i</span><span class="s4">)</span>
        <span class="s1">d</span><span class="s4">[</span><span class="s1">n </span><span class="s4">+ </span><span class="s1">i</span><span class="s4">] = </span><span class="s1">nd</span>

    <span class="s3">if </span><span class="s1">rd</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">nd</span><span class="s4">, </span><span class="s1">d</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">nd</span>


<span class="s3">def </span><span class="s1">optimal_leaf_ordering</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s5">'euclidean'</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Given a linkage matrix Z and distance, reorder the cut tree. 
 
    Parameters 
    ---------- 
    Z : ndarray 
        The hierarchical clustering encoded as a linkage matrix. See 
        `linkage` for more information on the return structure and 
        algorithm. 
    y : ndarray 
        The condensed distance matrix from which Z was generated. 
        Alternatively, a collection of m observation vectors in n 
        dimensions may be passed as an m by n array. 
    metric : str or function, optional 
        The distance metric to use in the case that y is a collection of 
        observation vectors; ignored otherwise. See the ``pdist`` 
        function for a list of valid distance metrics. A custom distance 
        function can also be used. 
 
    Returns 
    ------- 
    Z_ordered : ndarray 
        A copy of the linkage matrix Z, reordered to minimize the distance 
        between adjacent leaves. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.cluster import hierarchy 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; X = rng.standard_normal((10, 10)) 
    &gt;&gt;&gt; Z = hierarchy.ward(X) 
    &gt;&gt;&gt; hierarchy.leaves_list(Z) 
    array([0, 3, 1, 9, 2, 5, 7, 4, 6, 8], dtype=int32) 
    &gt;&gt;&gt; hierarchy.leaves_list(hierarchy.optimal_leaf_ordering(Z, X)) 
    array([3, 0, 2, 5, 7, 4, 8, 6, 9, 1], dtype=int32) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">y</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">is_valid_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'Z'</span><span class="s4">)</span>

    <span class="s1">y </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">y</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">== </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s1">distance</span><span class="s4">.</span><span class="s1">is_valid_y</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'y'</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">y</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">== </span><span class="s6">2</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s1">y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s1">y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] </span><span class="s3">and </span><span class="s1">np</span><span class="s4">.</span><span class="s1">allclose</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">diag</span><span class="s4">(</span><span class="s1">y</span><span class="s4">), </span><span class="s6">0</span><span class="s4">) </span><span class="s3">and</span>
                <span class="s1">np</span><span class="s4">.</span><span class="s1">all</span><span class="s4">(</span><span class="s1">y </span><span class="s4">&gt;= </span><span class="s6">0</span><span class="s4">) </span><span class="s3">and </span><span class="s1">np</span><span class="s4">.</span><span class="s1">allclose</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">y</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)):</span>
            <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span><span class="s5">'The symmetric non-negative hollow observation '</span>
                          <span class="s5">'matrix looks suspiciously like an uncondensed '</span>
                          <span class="s5">'distance matrix'</span><span class="s4">,</span>
                          <span class="s1">ClusterWarning</span><span class="s4">, </span><span class="s1">stacklevel</span><span class="s4">=</span><span class="s6">2</span><span class="s4">)</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">distance</span><span class="s4">.</span><span class="s1">pdist</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">)</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;`y` must be 1 or 2 dimensional.&quot;</span><span class="s4">)</span>

    <span class="s3">if not </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">all</span><span class="s4">(</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">isfinite</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;The condensed distance matrix must contain only &quot;</span>
                         <span class="s5">&quot;finite values.&quot;</span><span class="s4">)</span>

    <span class="s1">Z </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">y </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">_optimal_leaf_ordering</span><span class="s4">.</span><span class="s1">optimal_leaf_ordering</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">y</span><span class="s4">))</span>


<span class="s3">def </span><span class="s1">cophenet</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate the cophenetic distances between each observation in 
    the hierarchical clustering defined by the linkage ``Z``. 
 
    Suppose ``p`` and ``q`` are original observations in 
    disjoint clusters ``s`` and ``t``, respectively and 
    ``s`` and ``t`` are joined by a direct parent cluster 
    ``u``. The cophenetic distance between observations 
    ``i`` and ``j`` is simply the distance between 
    clusters ``s`` and ``t``. 
 
    Parameters 
    ---------- 
    Z : ndarray 
        The hierarchical clustering encoded as an array 
        (see `linkage` function). 
    Y : ndarray (optional) 
        Calculates the cophenetic correlation coefficient ``c`` of a 
        hierarchical clustering defined by the linkage matrix `Z` 
        of a set of :math:`n` observations in :math:`m` 
        dimensions. `Y` is the condensed distance matrix from which 
        `Z` was generated. 
 
    Returns 
    ------- 
    c : ndarray 
        The cophentic correlation distance (if ``Y`` is passed). 
    d : ndarray 
        The cophenetic distance matrix in condensed form. The 
        :math:`ij` th entry is the cophenetic distance between 
        original observations :math:`i` and :math:`j`. 
 
    See Also 
    -------- 
    linkage : 
        for a description of what a linkage matrix is. 
    scipy.spatial.distance.squareform : 
        transforming condensed matrices into square ones. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import single, cophenet 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist, squareform 
 
    Given a dataset ``X`` and a linkage matrix ``Z``, the cophenetic distance 
    between two points of ``X`` is the distance between the largest two 
    distinct clusters that each of the points: 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    ``X`` corresponds to this dataset :: 
 
        x x    x x 
        x        x 
 
        x        x 
        x x    x x 
 
    &gt;&gt;&gt; Z = single(pdist(X)) 
    &gt;&gt;&gt; Z 
    array([[ 0.,  1.,  1.,  2.], 
           [ 2., 12.,  1.,  3.], 
           [ 3.,  4.,  1.,  2.], 
           [ 5., 14.,  1.,  3.], 
           [ 6.,  7.,  1.,  2.], 
           [ 8., 16.,  1.,  3.], 
           [ 9., 10.,  1.,  2.], 
           [11., 18.,  1.,  3.], 
           [13., 15.,  2.,  6.], 
           [17., 20.,  2.,  9.], 
           [19., 21.,  2., 12.]]) 
    &gt;&gt;&gt; cophenet(Z) 
    array([1., 1., 2., 2., 2., 2., 2., 2., 2., 2., 2., 1., 2., 2., 2., 2., 2., 
           2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 1., 1., 2., 2., 
           2., 2., 2., 2., 1., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., 
           1., 1., 2., 2., 2., 1., 2., 2., 2., 2., 2., 2., 1., 1., 1.]) 
 
    The output of the `scipy.cluster.hierarchy.cophenet` method is 
    represented in condensed form. We can use 
    `scipy.spatial.distance.squareform` to see the output as a 
    regular matrix (where each element ``ij`` denotes the cophenetic distance 
    between each ``i``, ``j`` pair of points in ``X``): 
 
    &gt;&gt;&gt; squareform(cophenet(Z)) 
    array([[0., 1., 1., 2., 2., 2., 2., 2., 2., 2., 2., 2.], 
           [1., 0., 1., 2., 2., 2., 2., 2., 2., 2., 2., 2.], 
           [1., 1., 0., 2., 2., 2., 2., 2., 2., 2., 2., 2.], 
           [2., 2., 2., 0., 1., 1., 2., 2., 2., 2., 2., 2.], 
           [2., 2., 2., 1., 0., 1., 2., 2., 2., 2., 2., 2.], 
           [2., 2., 2., 1., 1., 0., 2., 2., 2., 2., 2., 2.], 
           [2., 2., 2., 2., 2., 2., 0., 1., 1., 2., 2., 2.], 
           [2., 2., 2., 2., 2., 2., 1., 0., 1., 2., 2., 2.], 
           [2., 2., 2., 2., 2., 2., 1., 1., 0., 2., 2., 2.], 
           [2., 2., 2., 2., 2., 2., 2., 2., 2., 0., 1., 1.], 
           [2., 2., 2., 2., 2., 2., 2., 2., 2., 1., 0., 1.], 
           [2., 2., 2., 2., 2., 2., 2., 2., 2., 1., 1., 0.]]) 
 
    In this example, the cophenetic distance between points on ``X`` that are 
    very close (i.e., in the same corner) is 1. For other pairs of points is 2, 
    because the points will be located in clusters at different 
    corners - thus, the distance between these clusters will be larger. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s2"># Ensure float64 C-contiguous array. Cython code doesn't deal with striding.</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">is_valid_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'Z'</span><span class="s4">)</span>
    <span class="s1">n </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1</span>
    <span class="s1">zz </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n </span><span class="s4">* (</span><span class="s1">n</span><span class="s4">-</span><span class="s6">1</span><span class="s4">)) // </span><span class="s6">2</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>

    <span class="s1">Z </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">_hierarchy</span><span class="s4">.</span><span class="s1">cophenetic_distances</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">zz</span><span class="s4">, </span><span class="s1">int</span><span class="s4">(</span><span class="s1">n</span><span class="s4">))</span>
    <span class="s1">zz </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">zz</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">Y </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">zz</span>

    <span class="s1">Y </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">distance</span><span class="s4">.</span><span class="s1">is_valid_y</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'Y'</span><span class="s4">)</span>

    <span class="s1">z </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">mean</span><span class="s4">(</span><span class="s1">zz</span><span class="s4">)</span>
    <span class="s1">y </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">mean</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s1">Yy </span><span class="s4">= </span><span class="s1">Y </span><span class="s4">- </span><span class="s1">y</span>
    <span class="s1">Zz </span><span class="s4">= </span><span class="s1">zz </span><span class="s4">- </span><span class="s1">z</span>
    <span class="s1">numerator </span><span class="s4">= (</span><span class="s1">Yy </span><span class="s4">* </span><span class="s1">Zz</span><span class="s4">)</span>
    <span class="s1">denomA </span><span class="s4">= </span><span class="s1">Yy</span><span class="s4">**</span><span class="s6">2</span>
    <span class="s1">denomB </span><span class="s4">= </span><span class="s1">Zz</span><span class="s4">**</span><span class="s6">2</span>
    <span class="s1">c </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">numerator</span><span class="s4">) / </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">denomA</span><span class="s4">) * </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">denomB</span><span class="s4">))</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">c</span><span class="s4">, </span><span class="s1">zz</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">inconsistent</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">d</span><span class="s4">=</span><span class="s6">2</span><span class="s4">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Calculate inconsistency statistics on a linkage matrix. 
 
    Parameters 
    ---------- 
    Z : ndarray 
        The :math:`(n-1)` by 4 matrix encoding the linkage (hierarchical 
        clustering).  See `linkage` documentation for more information on its 
        form. 
    d : int, optional 
        The number of links up to `d` levels below each non-singleton cluster. 
 
    Returns 
    ------- 
    R : ndarray 
        A :math:`(n-1)` by 4 matrix where the ``i``'th row contains the link 
        statistics for the non-singleton cluster ``i``. The link statistics are 
        computed over the link heights for links :math:`d` levels below the 
        cluster ``i``. ``R[i,0]`` and ``R[i,1]`` are the mean and standard 
        deviation of the link heights, respectively; ``R[i,2]`` is the number 
        of links included in the calculation; and ``R[i,3]`` is the 
        inconsistency coefficient, 
 
        .. math:: \frac{\mathtt{Z[i,2]} - \mathtt{R[i,0]}} {R[i,1]} 
 
    Notes 
    ----- 
    This function behaves similarly to the MATLAB(TM) ``inconsistent`` 
    function. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import inconsistent, linkage 
    &gt;&gt;&gt; from matplotlib import pyplot as plt 
    &gt;&gt;&gt; X = [[i] for i in [2, 8, 0, 4, 1, 9, 9, 0]] 
    &gt;&gt;&gt; Z = linkage(X, 'ward') 
    &gt;&gt;&gt; print(Z) 
    [[ 5.          6.          0.          2.        ] 
     [ 2.          7.          0.          2.        ] 
     [ 0.          4.          1.          2.        ] 
     [ 1.          8.          1.15470054  3.        ] 
     [ 9.         10.          2.12132034  4.        ] 
     [ 3.         12.          4.11096096  5.        ] 
     [11.         13.         14.07183949  8.        ]] 
    &gt;&gt;&gt; inconsistent(Z) 
    array([[ 0.        ,  0.        ,  1.        ,  0.        ], 
           [ 0.        ,  0.        ,  1.        ,  0.        ], 
           [ 1.        ,  0.        ,  1.        ,  0.        ], 
           [ 0.57735027,  0.81649658,  2.        ,  0.70710678], 
           [ 1.04044011,  1.06123822,  3.        ,  1.01850858], 
           [ 3.11614065,  1.40688837,  2.        ,  0.70710678], 
           [ 6.44583366,  6.76770586,  3.        ,  1.12682288]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">is_valid_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'Z'</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s4">(</span><span class="s3">not </span><span class="s1">d </span><span class="s4">== </span><span class="s1">np</span><span class="s4">.</span><span class="s1">floor</span><span class="s4">(</span><span class="s1">d</span><span class="s4">)) </span><span class="s3">or </span><span class="s1">d </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'The second argument d must be a nonnegative '</span>
                         <span class="s5">'integer value.'</span><span class="s4">)</span>

    <span class="s1">n </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1</span>
    <span class="s1">R </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n </span><span class="s4">- </span><span class="s6">1</span><span class="s4">, </span><span class="s6">4</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>

    <span class="s1">Z </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">_hierarchy</span><span class="s4">.</span><span class="s1">inconsistent</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">R</span><span class="s4">, </span><span class="s1">int</span><span class="s4">(</span><span class="s1">n</span><span class="s4">), </span><span class="s1">int</span><span class="s4">(</span><span class="s1">d</span><span class="s4">))</span>
    <span class="s1">R </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">R</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">R</span>


<span class="s3">def </span><span class="s1">from_mlab_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a linkage matrix generated by MATLAB(TM) to a new 
    linkage matrix compatible with this module. 
 
    The conversion does two things: 
 
     * the indices are converted from ``1..N`` to ``0..(N-1)`` form, 
       and 
 
     * a fourth column ``Z[:,3]`` is added where ``Z[i,3]`` represents the 
       number of original observations (leaves) in the non-singleton 
       cluster ``i``. 
 
    This function is useful when loading in linkages from legacy data 
    files generated by MATLAB. 
 
    Parameters 
    ---------- 
    Z : ndarray 
        A linkage matrix generated by MATLAB(TM). 
 
    Returns 
    ------- 
    ZS : ndarray 
        A linkage matrix compatible with ``scipy.cluster.hierarchy``. 
 
    See Also 
    -------- 
    linkage : for a description of what a linkage matrix is. 
    to_mlab_linkage : transform from SciPy to MATLAB format. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, from_mlab_linkage 
 
    Given a linkage matrix in MATLAB format ``mZ``, we can use 
    `scipy.cluster.hierarchy.from_mlab_linkage` to import 
    it into SciPy format: 
 
    &gt;&gt;&gt; mZ = np.array([[1, 2, 1], [4, 5, 1], [7, 8, 1], 
    ...                [10, 11, 1], [3, 13, 1.29099445], 
    ...                [6, 14, 1.29099445], 
    ...                [9, 15, 1.29099445], 
    ...                [12, 16, 1.29099445], 
    ...                [17, 18, 5.77350269], 
    ...                [19, 20, 5.77350269], 
    ...                [21, 22,  8.16496581]]) 
 
    &gt;&gt;&gt; Z = from_mlab_linkage(mZ) 
    &gt;&gt;&gt; Z 
    array([[  0.        ,   1.        ,   1.        ,   2.        ], 
           [  3.        ,   4.        ,   1.        ,   2.        ], 
           [  6.        ,   7.        ,   1.        ,   2.        ], 
           [  9.        ,  10.        ,   1.        ,   2.        ], 
           [  2.        ,  12.        ,   1.29099445,   3.        ], 
           [  5.        ,  13.        ,   1.29099445,   3.        ], 
           [  8.        ,  14.        ,   1.29099445,   3.        ], 
           [ 11.        ,  15.        ,   1.29099445,   3.        ], 
           [ 16.        ,  17.        ,   5.77350269,   6.        ], 
           [ 18.        ,  19.        ,   5.77350269,   6.        ], 
           [ 20.        ,  21.        ,   8.16496581,  12.        ]]) 
 
    As expected, the linkage matrix ``Z`` returned includes an 
    additional column counting the number of original samples in 
    each cluster. Also, all cluster indices are reduced by 1 
    (MATLAB format uses 1-indexing, whereas SciPy uses 0-indexing). 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">Zs </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span>

    <span class="s2"># If it's empty, return it.</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">Zs</span><span class="s4">) == </span><span class="s6">0 </span><span class="s3">or </span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">Zs</span><span class="s4">) == </span><span class="s6">1 </span><span class="s3">and </span><span class="s1">Zs</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s6">0</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">copy</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">Zs</span><span class="s4">) != </span><span class="s6">2</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;The linkage array must be rectangular.&quot;</span><span class="s4">)</span>

    <span class="s2"># If it contains no rows, return it.</span>
    <span class="s3">if </span><span class="s1">Zs</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">copy</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">min</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[:, </span><span class="s6">0</span><span class="s4">:</span><span class="s6">2</span><span class="s4">]) != </span><span class="s6">1.0 </span><span class="s3">and </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">max</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[:, </span><span class="s6">0</span><span class="s4">:</span><span class="s6">2</span><span class="s4">]) != </span><span class="s6">2 </span><span class="s4">* </span><span class="s1">Zs</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'The format of the indices is not 1..N'</span><span class="s4">)</span>

    <span class="s1">Zpart </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">concat</span><span class="s4">((</span><span class="s1">Z</span><span class="s4">[:, </span><span class="s6">0</span><span class="s4">:</span><span class="s6">2</span><span class="s4">] - </span><span class="s6">1.0</span><span class="s4">, </span><span class="s1">Z</span><span class="s4">[:, </span><span class="s6">2</span><span class="s4">:]), </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s1">CS </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">Zs</span><span class="s4">[</span><span class="s6">0</span><span class="s4">],), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">is_jax</span><span class="s4">(</span><span class="s1">xp</span><span class="s4">):</span>
        <span class="s2"># calculate_cluster_sizes doesn't accept read-only arrays</span>
        <span class="s1">Zpart </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span><span class="s1">Zpart</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">Zpart </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">Zpart</span><span class="s4">)</span>
    <span class="s1">_hierarchy</span><span class="s4">.</span><span class="s1">calculate_cluster_sizes</span><span class="s4">(</span><span class="s1">Zpart</span><span class="s4">, </span><span class="s1">CS</span><span class="s4">, </span><span class="s1">int</span><span class="s4">(</span><span class="s1">Zs</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]) + </span><span class="s6">1</span><span class="s4">)</span>
    <span class="s1">res </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">([</span><span class="s1">Zpart</span><span class="s4">, </span><span class="s1">CS</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">(</span><span class="s1">Zs</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s6">1</span><span class="s4">)])</span>
    <span class="s3">return </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">res</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">to_mlab_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a linkage matrix to a MATLAB(TM) compatible one. 
 
    Converts a linkage matrix ``Z`` generated by the linkage function 
    of this module to a MATLAB(TM) compatible one. The return linkage 
    matrix has the last column removed and the cluster indices are 
    converted to ``1..N`` indexing. 
 
    Parameters 
    ---------- 
    Z : ndarray 
        A linkage matrix generated by ``scipy.cluster.hierarchy``. 
 
    Returns 
    ------- 
    to_mlab_linkage : ndarray 
        A linkage matrix compatible with MATLAB(TM)'s hierarchical 
        clustering functions. 
 
        The return linkage matrix has the last column removed 
        and the cluster indices are converted to ``1..N`` indexing. 
 
    See Also 
    -------- 
    linkage : for a description of what a linkage matrix is. 
    from_mlab_linkage : transform from Matlab to SciPy format. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, to_mlab_linkage 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    &gt;&gt;&gt; Z = ward(pdist(X)) 
    &gt;&gt;&gt; Z 
    array([[ 0.        ,  1.        ,  1.        ,  2.        ], 
           [ 3.        ,  4.        ,  1.        ,  2.        ], 
           [ 6.        ,  7.        ,  1.        ,  2.        ], 
           [ 9.        , 10.        ,  1.        ,  2.        ], 
           [ 2.        , 12.        ,  1.29099445,  3.        ], 
           [ 5.        , 13.        ,  1.29099445,  3.        ], 
           [ 8.        , 14.        ,  1.29099445,  3.        ], 
           [11.        , 15.        ,  1.29099445,  3.        ], 
           [16.        , 17.        ,  5.77350269,  6.        ], 
           [18.        , 19.        ,  5.77350269,  6.        ], 
           [20.        , 21.        ,  8.16496581, 12.        ]]) 
 
    After a linkage matrix ``Z`` has been created, we can use 
    `scipy.cluster.hierarchy.to_mlab_linkage` to convert it 
    into MATLAB format: 
 
    &gt;&gt;&gt; mZ = to_mlab_linkage(Z) 
    &gt;&gt;&gt; mZ 
    array([[  1.        ,   2.        ,   1.        ], 
           [  4.        ,   5.        ,   1.        ], 
           [  7.        ,   8.        ,   1.        ], 
           [ 10.        ,  11.        ,   1.        ], 
           [  3.        ,  13.        ,   1.29099445], 
           [  6.        ,  14.        ,   1.29099445], 
           [  9.        ,  15.        ,   1.29099445], 
           [ 12.        ,  16.        ,   1.29099445], 
           [ 17.        ,  18.        ,   5.77350269], 
           [ 19.        ,  20.        ,   5.77350269], 
           [ 21.        ,  22.        ,   8.16496581]]) 
 
    The new linkage matrix ``mZ`` uses 1-indexing for all the 
    clusters (instead of 0-indexing). Also, the last column of 
    the original linkage matrix has been dropped. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">Zs </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">Zs</span><span class="s4">) == </span><span class="s6">0 </span><span class="s3">or </span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">Zs</span><span class="s4">) == </span><span class="s6">1 </span><span class="s3">and </span><span class="s1">Zs</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s6">0</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">copy</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">is_valid_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'Z'</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">concat</span><span class="s4">((</span><span class="s1">Z</span><span class="s4">[:, :</span><span class="s6">2</span><span class="s4">] + </span><span class="s6">1.0</span><span class="s4">, </span><span class="s1">Z</span><span class="s4">[:, </span><span class="s6">2</span><span class="s4">:</span><span class="s6">3</span><span class="s4">]), </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">is_monotonic</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return True if the linkage passed is monotonic. 
 
    The linkage is monotonic if for every cluster :math:`s` and :math:`t` 
    joined, the distance between them is no less than the distance 
    between any previously joined clusters. 
 
    Parameters 
    ---------- 
    Z : ndarray 
        The linkage matrix to check for monotonicity. 
 
    Returns 
    ------- 
    b : bool 
        A boolean indicating whether the linkage is monotonic. 
 
    See Also 
    -------- 
    linkage : for a description of what a linkage matrix is. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import median, ward, is_monotonic 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    By definition, some hierarchical clustering algorithms - such as 
    `scipy.cluster.hierarchy.ward` - produce monotonic assignments of 
    samples to clusters; however, this is not always true for other 
    hierarchical methods - e.g. `scipy.cluster.hierarchy.median`. 
 
    Given a linkage matrix ``Z`` (as the result of a hierarchical clustering 
    method) we can test programmatically whether it has the monotonicity 
    property or not, using `scipy.cluster.hierarchy.is_monotonic`: 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    &gt;&gt;&gt; Z = ward(pdist(X)) 
    &gt;&gt;&gt; Z 
    array([[ 0.        ,  1.        ,  1.        ,  2.        ], 
           [ 3.        ,  4.        ,  1.        ,  2.        ], 
           [ 6.        ,  7.        ,  1.        ,  2.        ], 
           [ 9.        , 10.        ,  1.        ,  2.        ], 
           [ 2.        , 12.        ,  1.29099445,  3.        ], 
           [ 5.        , 13.        ,  1.29099445,  3.        ], 
           [ 8.        , 14.        ,  1.29099445,  3.        ], 
           [11.        , 15.        ,  1.29099445,  3.        ], 
           [16.        , 17.        ,  5.77350269,  6.        ], 
           [18.        , 19.        ,  5.77350269,  6.        ], 
           [20.        , 21.        ,  8.16496581, 12.        ]]) 
    &gt;&gt;&gt; is_monotonic(Z) 
    True 
 
    &gt;&gt;&gt; Z = median(pdist(X)) 
    &gt;&gt;&gt; Z 
    array([[ 0.        ,  1.        ,  1.        ,  2.        ], 
           [ 3.        ,  4.        ,  1.        ,  2.        ], 
           [ 9.        , 10.        ,  1.        ,  2.        ], 
           [ 6.        ,  7.        ,  1.        ,  2.        ], 
           [ 2.        , 12.        ,  1.11803399,  3.        ], 
           [ 5.        , 13.        ,  1.11803399,  3.        ], 
           [ 8.        , 15.        ,  1.11803399,  3.        ], 
           [11.        , 14.        ,  1.11803399,  3.        ], 
           [18.        , 19.        ,  3.        ,  6.        ], 
           [16.        , 17.        ,  3.5       ,  6.        ], 
           [20.        , 21.        ,  3.25      , 12.        ]]) 
    &gt;&gt;&gt; is_monotonic(Z) 
    False 
 
    Note that this method is equivalent to just verifying that the distances 
    in the third column of the linkage matrix appear in a monotonically 
    increasing order. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'c'</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">is_valid_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'Z'</span><span class="s4">)</span>

    <span class="s2"># We expect the i'th value to be greater than its successor.</span>
    <span class="s3">return </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">all</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:, </span><span class="s6">2</span><span class="s4">] &gt;= </span><span class="s1">Z</span><span class="s4">[:-</span><span class="s6">1</span><span class="s4">, </span><span class="s6">2</span><span class="s4">])</span>


<span class="s3">def </span><span class="s1">is_valid_im</span><span class="s4">(</span><span class="s1">R</span><span class="s4">, </span><span class="s1">warning</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Return True if the inconsistency matrix passed is valid. 
 
    It must be a :math:`n` by 4 array of doubles. The standard 
    deviations ``R[:,1]`` must be nonnegative. The link counts 
    ``R[:,2]`` must be positive and no greater than :math:`n-1`. 
 
    Parameters 
    ---------- 
    R : ndarray 
        The inconsistency matrix to check for validity. 
    warning : bool, optional 
        When True, issues a Python warning if the linkage 
        matrix passed is invalid. 
    throw : bool, optional 
        When True, throws a Python exception if the linkage 
        matrix passed is invalid. 
    name : str, optional 
        This string refers to the variable name of the invalid 
        linkage matrix. 
 
    Returns 
    ------- 
    b : bool 
        True if the inconsistency matrix is valid. 
 
    See Also 
    -------- 
    linkage : for a description of what a linkage matrix is. 
    inconsistent : for the creation of a inconsistency matrix. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, inconsistent, is_valid_im 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    Given a data set ``X``, we can apply a clustering method to obtain a 
    linkage matrix ``Z``. `scipy.cluster.hierarchy.inconsistent` can 
    be also used to obtain the inconsistency matrix ``R`` associated to 
    this clustering process: 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    &gt;&gt;&gt; Z = ward(pdist(X)) 
    &gt;&gt;&gt; R = inconsistent(Z) 
    &gt;&gt;&gt; Z 
    array([[ 0.        ,  1.        ,  1.        ,  2.        ], 
           [ 3.        ,  4.        ,  1.        ,  2.        ], 
           [ 6.        ,  7.        ,  1.        ,  2.        ], 
           [ 9.        , 10.        ,  1.        ,  2.        ], 
           [ 2.        , 12.        ,  1.29099445,  3.        ], 
           [ 5.        , 13.        ,  1.29099445,  3.        ], 
           [ 8.        , 14.        ,  1.29099445,  3.        ], 
           [11.        , 15.        ,  1.29099445,  3.        ], 
           [16.        , 17.        ,  5.77350269,  6.        ], 
           [18.        , 19.        ,  5.77350269,  6.        ], 
           [20.        , 21.        ,  8.16496581, 12.        ]]) 
    &gt;&gt;&gt; R 
    array([[1.        , 0.        , 1.        , 0.        ], 
           [1.        , 0.        , 1.        , 0.        ], 
           [1.        , 0.        , 1.        , 0.        ], 
           [1.        , 0.        , 1.        , 0.        ], 
           [1.14549722, 0.20576415, 2.        , 0.70710678], 
           [1.14549722, 0.20576415, 2.        , 0.70710678], 
           [1.14549722, 0.20576415, 2.        , 0.70710678], 
           [1.14549722, 0.20576415, 2.        , 0.70710678], 
           [2.78516386, 2.58797734, 3.        , 1.15470054], 
           [2.78516386, 2.58797734, 3.        , 1.15470054], 
           [6.57065706, 1.38071187, 3.        , 1.15470054]]) 
 
    Now we can use `scipy.cluster.hierarchy.is_valid_im` to verify that 
    ``R`` is correct: 
 
    &gt;&gt;&gt; is_valid_im(R) 
    True 
 
    However, if ``R`` is wrongly constructed (e.g., one of the standard 
    deviations is set to a negative value), then the check will fail: 
 
    &gt;&gt;&gt; R[-1,1] = R[-1,1] * -1 
    &gt;&gt;&gt; is_valid_im(R) 
    False 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">R</span><span class="s4">)</span>
    <span class="s1">R </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">R</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'c'</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">valid </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">name_str </span><span class="s4">= </span><span class="s5">&quot;%r &quot; </span><span class="s4">% </span><span class="s1">name </span><span class="s3">if </span><span class="s1">name </span><span class="s3">else </span><span class="s5">''</span>
    <span class="s3">try</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">R</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">!= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">'Inconsistency matrix %smust contain doubles '</span>
                            <span class="s5">'(double).' </span><span class="s4">% </span><span class="s1">name_str</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">R</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">) != </span><span class="s6">2</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Inconsistency matrix %smust have shape=2 (i.e. '</span>
                             <span class="s5">'be two-dimensional).' </span><span class="s4">% </span><span class="s1">name_str</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">R</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] != </span><span class="s6">4</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Inconsistency matrix %smust have 4 columns.' </span><span class="s4">%</span>
                             <span class="s1">name_str</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">R</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] &lt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Inconsistency matrix %smust have at least one '</span>
                             <span class="s5">'row.' </span><span class="s4">% </span><span class="s1">name_str</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">any</span><span class="s4">(</span><span class="s1">R</span><span class="s4">[:, </span><span class="s6">0</span><span class="s4">] &lt; </span><span class="s6">0</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Inconsistency matrix %scontains negative link '</span>
                             <span class="s5">'height means.' </span><span class="s4">% </span><span class="s1">name_str</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">any</span><span class="s4">(</span><span class="s1">R</span><span class="s4">[:, </span><span class="s6">1</span><span class="s4">] &lt; </span><span class="s6">0</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Inconsistency matrix %scontains negative link '</span>
                             <span class="s5">'height standard deviations.' </span><span class="s4">% </span><span class="s1">name_str</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">any</span><span class="s4">(</span><span class="s1">R</span><span class="s4">[:, </span><span class="s6">2</span><span class="s4">] &lt; </span><span class="s6">0</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Inconsistency matrix %scontains negative link '</span>
                             <span class="s5">'counts.' </span><span class="s4">% </span><span class="s1">name_str</span><span class="s4">)</span>
    <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">throw</span><span class="s4">:</span>
            <span class="s3">raise</span>
        <span class="s3">if </span><span class="s1">warning</span><span class="s4">:</span>
            <span class="s1">_warning</span><span class="s4">(</span><span class="s1">str</span><span class="s4">(</span><span class="s1">e</span><span class="s4">))</span>
        <span class="s1">valid </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s3">return </span><span class="s1">valid</span>


<span class="s3">def </span><span class="s1">is_valid_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">warning</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check the validity of a linkage matrix. 
 
    A linkage matrix is valid if it is a 2-D array (type double) 
    with :math:`n` rows and 4 columns. The first two columns must contain 
    indices between 0 and :math:`2n-1`. For a given row ``i``, the following 
    two expressions have to hold: 
 
    .. math:: 
 
        0 \\leq \\mathtt{Z[i,0]} \\leq i+n-1 
        0 \\leq Z[i,1] \\leq i+n-1 
 
    I.e., a cluster cannot join another cluster unless the cluster being joined 
    has been generated. 
 
    Parameters 
    ---------- 
    Z : array_like 
        Linkage matrix. 
    warning : bool, optional 
        When True, issues a Python warning if the linkage 
        matrix passed is invalid. 
    throw : bool, optional 
        When True, throws a Python exception if the linkage 
        matrix passed is invalid. 
    name : str, optional 
        This string refers to the variable name of the invalid 
        linkage matrix. 
 
    Returns 
    ------- 
    b : bool 
        True if the inconsistency matrix is valid. 
 
    See Also 
    -------- 
    linkage: for a description of what a linkage matrix is. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, is_valid_linkage 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    All linkage matrices generated by the clustering methods in this module 
    will be valid (i.e., they will have the appropriate dimensions and the two 
    required expressions will hold for all the rows). 
 
    We can check this using `scipy.cluster.hierarchy.is_valid_linkage`: 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    &gt;&gt;&gt; Z = ward(pdist(X)) 
    &gt;&gt;&gt; Z 
    array([[ 0.        ,  1.        ,  1.        ,  2.        ], 
           [ 3.        ,  4.        ,  1.        ,  2.        ], 
           [ 6.        ,  7.        ,  1.        ,  2.        ], 
           [ 9.        , 10.        ,  1.        ,  2.        ], 
           [ 2.        , 12.        ,  1.29099445,  3.        ], 
           [ 5.        , 13.        ,  1.29099445,  3.        ], 
           [ 8.        , 14.        ,  1.29099445,  3.        ], 
           [11.        , 15.        ,  1.29099445,  3.        ], 
           [16.        , 17.        ,  5.77350269,  6.        ], 
           [18.        , 19.        ,  5.77350269,  6.        ], 
           [20.        , 21.        ,  8.16496581, 12.        ]]) 
    &gt;&gt;&gt; is_valid_linkage(Z) 
    True 
 
    However, if we create a linkage matrix in a wrong way - or if we modify 
    a valid one in a way that any of the required expressions don't hold 
    anymore, then the check will fail: 
 
    &gt;&gt;&gt; Z[3][1] = 20    # the cluster number 20 is not defined at this point 
    &gt;&gt;&gt; is_valid_linkage(Z) 
    False 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'c'</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">valid </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">name_str </span><span class="s4">= </span><span class="s5">&quot;%r &quot; </span><span class="s4">% </span><span class="s1">name </span><span class="s3">if </span><span class="s1">name </span><span class="s3">else </span><span class="s5">''</span>
    <span class="s3">try</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">!= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">'Linkage matrix %smust contain doubles.' </span><span class="s4">% </span><span class="s1">name_str</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">) != </span><span class="s6">2</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Linkage matrix %smust have shape=2 (i.e. be '</span>
                             <span class="s5">'two-dimensional).' </span><span class="s4">% </span><span class="s1">name_str</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] != </span><span class="s6">4</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Linkage matrix %smust have 4 columns.' </span><span class="s4">% </span><span class="s1">name_str</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Linkage must be computed on at least two '</span>
                             <span class="s5">'observations.'</span><span class="s4">)</span>
        <span class="s1">n </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">n </span><span class="s4">&gt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">any</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[:, </span><span class="s6">0</span><span class="s4">] &lt; </span><span class="s6">0</span><span class="s4">) </span><span class="s3">or </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">any</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[:, </span><span class="s6">1</span><span class="s4">] &lt; </span><span class="s6">0</span><span class="s4">)):</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Linkage %scontains negative indices.' </span><span class="s4">%</span>
                                 <span class="s1">name_str</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">any</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[:, </span><span class="s6">2</span><span class="s4">] &lt; </span><span class="s6">0</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Linkage %scontains negative distances.' </span><span class="s4">%</span>
                                 <span class="s1">name_str</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">any</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[:, </span><span class="s6">3</span><span class="s4">] &lt; </span><span class="s6">0</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Linkage %scontains negative counts.' </span><span class="s4">%</span>
                                 <span class="s1">name_str</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">_check_hierarchy_uses_cluster_before_formed</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Linkage %suses non-singleton cluster before '</span>
                             <span class="s5">'it is formed.' </span><span class="s4">% </span><span class="s1">name_str</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">_check_hierarchy_uses_cluster_more_than_once</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Linkage %suses the same cluster more than once.'</span>
                             <span class="s4">% </span><span class="s1">name_str</span><span class="s4">)</span>
    <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">throw</span><span class="s4">:</span>
            <span class="s3">raise</span>
        <span class="s3">if </span><span class="s1">warning</span><span class="s4">:</span>
            <span class="s1">_warning</span><span class="s4">(</span><span class="s1">str</span><span class="s4">(</span><span class="s1">e</span><span class="s4">))</span>
        <span class="s1">valid </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s3">return </span><span class="s1">valid</span>


<span class="s3">def </span><span class="s1">_check_hierarchy_uses_cluster_before_formed</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">):</span>
    <span class="s1">n </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">n </span><span class="s4">- </span><span class="s6">1</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, </span><span class="s6">0</span><span class="s4">] &gt;= </span><span class="s1">n </span><span class="s4">+ </span><span class="s1">i </span><span class="s3">or </span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, </span><span class="s6">1</span><span class="s4">] &gt;= </span><span class="s1">n </span><span class="s4">+ </span><span class="s1">i</span><span class="s4">:</span>
            <span class="s3">return True</span>
    <span class="s3">return False</span>


<span class="s3">def </span><span class="s1">_check_hierarchy_uses_cluster_more_than_once</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">):</span>
    <span class="s1">n </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1</span>
    <span class="s1">chosen </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">n </span><span class="s4">- </span><span class="s6">1</span><span class="s4">):</span>
        <span class="s1">used_more_than_once </span><span class="s4">= (</span>
            <span class="s4">(</span><span class="s1">float</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, </span><span class="s6">0</span><span class="s4">]) </span><span class="s3">in </span><span class="s1">chosen</span><span class="s4">)</span>
            <span class="s3">or </span><span class="s4">(</span><span class="s1">float</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, </span><span class="s6">1</span><span class="s4">]) </span><span class="s3">in </span><span class="s1">chosen</span><span class="s4">)</span>
            <span class="s3">or </span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, </span><span class="s6">0</span><span class="s4">] == </span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, </span><span class="s6">1</span><span class="s4">]</span>
        <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">used_more_than_once</span><span class="s4">:</span>
            <span class="s3">return True</span>
        <span class="s1">chosen</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">float</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, </span><span class="s6">0</span><span class="s4">]))</span>
        <span class="s1">chosen</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">float</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, </span><span class="s6">1</span><span class="s4">]))</span>
    <span class="s3">return False</span>


<span class="s3">def </span><span class="s1">_check_hierarchy_not_all_clusters_used</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">):</span>
    <span class="s1">n </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1</span>
    <span class="s1">chosen </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">n </span><span class="s4">- </span><span class="s6">1</span><span class="s4">):</span>
        <span class="s1">chosen</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">int</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, </span><span class="s6">0</span><span class="s4">]))</span>
        <span class="s1">chosen</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">int</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, </span><span class="s6">1</span><span class="s4">]))</span>
    <span class="s1">must_chosen </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">range</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s6">2 </span><span class="s4">* </span><span class="s1">n </span><span class="s4">- </span><span class="s6">2</span><span class="s4">))</span>
    <span class="s3">return </span><span class="s1">len</span><span class="s4">(</span><span class="s1">must_chosen</span><span class="s4">.</span><span class="s1">difference</span><span class="s4">(</span><span class="s1">chosen</span><span class="s4">)) &gt; </span><span class="s6">0</span>


<span class="s3">def </span><span class="s1">num_obs_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the number of original observations of the linkage matrix passed. 
 
    Parameters 
    ---------- 
    Z : ndarray 
        The linkage matrix on which to perform the operation. 
 
    Returns 
    ------- 
    n : int 
        The number of original observations in the linkage. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, num_obs_linkage 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    &gt;&gt;&gt; Z = ward(pdist(X)) 
 
    ``Z`` is a linkage matrix obtained after using the Ward clustering method 
    with ``X``, a dataset with 12 data points. 
 
    &gt;&gt;&gt; num_obs_linkage(Z) 
    12 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'c'</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">is_valid_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'Z'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">correspond</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check for correspondence between linkage and condensed distance matrices. 
 
    They must have the same number of original observations for 
    the check to succeed. 
 
    This function is useful as a sanity check in algorithms that make 
    extensive use of linkage and distance matrices that must 
    correspond to the same set of original observations. 
 
    Parameters 
    ---------- 
    Z : array_like 
        The linkage matrix to check for correspondence. 
    Y : array_like 
        The condensed distance matrix to check for correspondence. 
 
    Returns 
    ------- 
    b : bool 
        A boolean indicating whether the linkage matrix and distance 
        matrix could possibly correspond to one another. 
 
    See Also 
    -------- 
    linkage : for a description of what a linkage matrix is. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, correspond 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    This method can be used to check if a given linkage matrix ``Z`` has been 
    obtained from the application of a cluster method over a dataset ``X``: 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
    &gt;&gt;&gt; X_condensed = pdist(X) 
    &gt;&gt;&gt; Z = ward(X_condensed) 
 
    Here, we can compare ``Z`` and ``X`` (in condensed form): 
 
    &gt;&gt;&gt; correspond(Z, X_condensed) 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s1">is_valid_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s1">distance</span><span class="s4">.</span><span class="s1">is_valid_y</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'c'</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">Y </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'c'</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">distance</span><span class="s4">.</span><span class="s1">num_obs_y</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">) == </span><span class="s1">num_obs_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">fcluster</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">t</span><span class="s4">, </span><span class="s1">criterion</span><span class="s4">=</span><span class="s5">'inconsistent'</span><span class="s4">, </span><span class="s1">depth</span><span class="s4">=</span><span class="s6">2</span><span class="s4">, </span><span class="s1">R</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">monocrit</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Form flat clusters from the hierarchical clustering defined by 
    the given linkage matrix. 
 
    Parameters 
    ---------- 
    Z : ndarray 
        The hierarchical clustering encoded with the matrix returned 
        by the `linkage` function. 
    t : scalar 
        For criteria 'inconsistent', 'distance' or 'monocrit', 
         this is the threshold to apply when forming flat clusters. 
        For 'maxclust' or 'maxclust_monocrit' criteria, 
         this would be max number of clusters requested. 
    criterion : str, optional 
        The criterion to use in forming flat clusters. This can 
        be any of the following values: 
 
          ``inconsistent`` : 
              If a cluster node and all its 
              descendants have an inconsistent value less than or equal 
              to `t`, then all its leaf descendants belong to the 
              same flat cluster. When no non-singleton cluster meets 
              this criterion, every node is assigned to its own 
              cluster. (Default) 
 
          ``distance`` : 
              Forms flat clusters so that the original 
              observations in each flat cluster have no greater a 
              cophenetic distance than `t`. 
 
          ``maxclust`` : 
              Finds a minimum threshold ``r`` so that 
              the cophenetic distance between any two original 
              observations in the same flat cluster is no more than 
              ``r`` and no more than `t` flat clusters are formed. 
 
          ``monocrit`` : 
              Forms a flat cluster from a cluster node c 
              with index i when ``monocrit[j] &lt;= t``. 
 
              For example, to threshold on the maximum mean distance 
              as computed in the inconsistency matrix R with a 
              threshold of 0.8 do:: 
 
                  MR = maxRstat(Z, R, 3) 
                  fcluster(Z, t=0.8, criterion='monocrit', monocrit=MR) 
 
          ``maxclust_monocrit`` : 
              Forms a flat cluster from a 
              non-singleton cluster node ``c`` when ``monocrit[i] &lt;= 
              r`` for all cluster indices ``i`` below and including 
              ``c``. ``r`` is minimized such that no more than ``t`` 
              flat clusters are formed. monocrit must be 
              monotonic. For example, to minimize the threshold t on 
              maximum inconsistency values so that no more than 3 flat 
              clusters are formed, do:: 
 
                  MI = maxinconsts(Z, R) 
                  fcluster(Z, t=3, criterion='maxclust_monocrit', monocrit=MI) 
    depth : int, optional 
        The maximum depth to perform the inconsistency calculation. 
        It has no meaning for the other criteria. Default is 2. 
    R : ndarray, optional 
        The inconsistency matrix to use for the ``'inconsistent'`` 
        criterion. This matrix is computed if not provided. 
    monocrit : ndarray, optional 
        An array of length n-1. `monocrit[i]` is the 
        statistics upon which non-singleton i is thresholded. The 
        monocrit vector must be monotonic, i.e., given a node c with 
        index i, for all node indices j corresponding to nodes 
        below c, ``monocrit[i] &gt;= monocrit[j]``. 
 
    Returns 
    ------- 
    fcluster : ndarray 
        An array of length ``n``. ``T[i]`` is the flat cluster number to 
        which original observation ``i`` belongs. 
 
    See Also 
    -------- 
    linkage : for information about hierarchical clustering methods work. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, fcluster 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    All cluster linkage methods - e.g., `scipy.cluster.hierarchy.ward` 
    generate a linkage matrix ``Z`` as their output: 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    &gt;&gt;&gt; Z = ward(pdist(X)) 
 
    &gt;&gt;&gt; Z 
    array([[ 0.        ,  1.        ,  1.        ,  2.        ], 
           [ 3.        ,  4.        ,  1.        ,  2.        ], 
           [ 6.        ,  7.        ,  1.        ,  2.        ], 
           [ 9.        , 10.        ,  1.        ,  2.        ], 
           [ 2.        , 12.        ,  1.29099445,  3.        ], 
           [ 5.        , 13.        ,  1.29099445,  3.        ], 
           [ 8.        , 14.        ,  1.29099445,  3.        ], 
           [11.        , 15.        ,  1.29099445,  3.        ], 
           [16.        , 17.        ,  5.77350269,  6.        ], 
           [18.        , 19.        ,  5.77350269,  6.        ], 
           [20.        , 21.        ,  8.16496581, 12.        ]]) 
 
    This matrix represents a dendrogram, where the first and second elements 
    are the two clusters merged at each step, the third element is the 
    distance between these clusters, and the fourth element is the size of 
    the new cluster - the number of original data points included. 
 
    `scipy.cluster.hierarchy.fcluster` can be used to flatten the 
    dendrogram, obtaining as a result an assignation of the original data 
    points to single clusters. 
 
    This assignation mostly depends on a distance threshold ``t`` - the maximum 
    inter-cluster distance allowed: 
 
    &gt;&gt;&gt; fcluster(Z, t=0.9, criterion='distance') 
    array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12], dtype=int32) 
 
    &gt;&gt;&gt; fcluster(Z, t=1.1, criterion='distance') 
    array([1, 1, 2, 3, 3, 4, 5, 5, 6, 7, 7, 8], dtype=int32) 
 
    &gt;&gt;&gt; fcluster(Z, t=3, criterion='distance') 
    array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32) 
 
    &gt;&gt;&gt; fcluster(Z, t=9, criterion='distance') 
    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], dtype=int32) 
 
    In the first case, the threshold ``t`` is too small to allow any two 
    samples in the data to form a cluster, so 12 different clusters are 
    returned. 
 
    In the second case, the threshold is large enough to allow the first 
    4 points to be merged with their nearest neighbors. So, here, only 8 
    clusters are returned. 
 
    The third case, with a much higher threshold, allows for up to 8 data 
    points to be connected - so 4 clusters are returned here. 
 
    Lastly, the threshold of the fourth case is large enough to allow for 
    all data points to be merged together - so a single cluster is returned. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">is_valid_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'Z'</span><span class="s4">)</span>

    <span class="s1">n </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1</span>
    <span class="s1">T </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n</span><span class="s4">,), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s5">'i'</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">monocrit </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">monocrit </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">monocrit</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>

    <span class="s1">Z </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">monocrit </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">monocrit</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">criterion </span><span class="s4">== </span><span class="s5">'inconsistent'</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">R </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">R </span><span class="s4">= </span><span class="s1">inconsistent</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">depth</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">R </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">R</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
            <span class="s1">is_valid_im</span><span class="s4">(</span><span class="s1">R</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'R'</span><span class="s4">)</span>
            <span class="s2"># Since the C code does not support striding using strides.</span>
            <span class="s2"># The dimensions are used instead.</span>
            <span class="s1">R </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">R</span><span class="s4">)</span>
        <span class="s1">_hierarchy</span><span class="s4">.</span><span class="s1">cluster_in</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">R</span><span class="s4">, </span><span class="s1">T</span><span class="s4">, </span><span class="s1">float</span><span class="s4">(</span><span class="s1">t</span><span class="s4">), </span><span class="s1">int</span><span class="s4">(</span><span class="s1">n</span><span class="s4">))</span>
    <span class="s3">elif </span><span class="s1">criterion </span><span class="s4">== </span><span class="s5">'distance'</span><span class="s4">:</span>
        <span class="s1">_hierarchy</span><span class="s4">.</span><span class="s1">cluster_dist</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">T</span><span class="s4">, </span><span class="s1">float</span><span class="s4">(</span><span class="s1">t</span><span class="s4">), </span><span class="s1">int</span><span class="s4">(</span><span class="s1">n</span><span class="s4">))</span>
    <span class="s3">elif </span><span class="s1">criterion </span><span class="s4">== </span><span class="s5">'maxclust'</span><span class="s4">:</span>
        <span class="s1">_hierarchy</span><span class="s4">.</span><span class="s1">cluster_maxclust_dist</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">T</span><span class="s4">, </span><span class="s1">int</span><span class="s4">(</span><span class="s1">n</span><span class="s4">), </span><span class="s1">t</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">criterion </span><span class="s4">== </span><span class="s5">'monocrit'</span><span class="s4">:</span>
        <span class="s1">_hierarchy</span><span class="s4">.</span><span class="s1">cluster_monocrit</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">monocrit</span><span class="s4">, </span><span class="s1">T</span><span class="s4">, </span><span class="s1">float</span><span class="s4">(</span><span class="s1">t</span><span class="s4">), </span><span class="s1">int</span><span class="s4">(</span><span class="s1">n</span><span class="s4">))</span>
    <span class="s3">elif </span><span class="s1">criterion </span><span class="s4">== </span><span class="s5">'maxclust_monocrit'</span><span class="s4">:</span>
        <span class="s1">_hierarchy</span><span class="s4">.</span><span class="s1">cluster_maxclust_monocrit</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">monocrit</span><span class="s4">, </span><span class="s1">T</span><span class="s4">, </span><span class="s1">int</span><span class="s4">(</span><span class="s1">n</span><span class="s4">), </span><span class="s1">int</span><span class="s4">(</span><span class="s1">t</span><span class="s4">))</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Invalid cluster formation criterion: %s'</span>
                         <span class="s4">% </span><span class="s1">str</span><span class="s4">(</span><span class="s1">criterion</span><span class="s4">))</span>
    <span class="s3">return </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">T</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">fclusterdata</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">t</span><span class="s4">, </span><span class="s1">criterion</span><span class="s4">=</span><span class="s5">'inconsistent'</span><span class="s4">,</span>
                 <span class="s1">metric</span><span class="s4">=</span><span class="s5">'euclidean'</span><span class="s4">, </span><span class="s1">depth</span><span class="s4">=</span><span class="s6">2</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s5">'single'</span><span class="s4">, </span><span class="s1">R</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Cluster observation data using a given metric. 
 
    Clusters the original observations in the n-by-m data 
    matrix X (n observations in m dimensions), using the euclidean 
    distance metric to calculate distances between original observations, 
    performs hierarchical clustering using the single linkage algorithm, 
    and forms flat clusters using the inconsistency method with `t` as the 
    cut-off threshold. 
 
    A 1-D array ``T`` of length ``n`` is returned. ``T[i]`` is 
    the index of the flat cluster to which the original observation ``i`` 
    belongs. 
 
    Parameters 
    ---------- 
    X : (N, M) ndarray 
        N by M data matrix with N observations in M dimensions. 
    t : scalar 
        For criteria 'inconsistent', 'distance' or 'monocrit', 
         this is the threshold to apply when forming flat clusters. 
        For 'maxclust' or 'maxclust_monocrit' criteria, 
         this would be max number of clusters requested. 
    criterion : str, optional 
        Specifies the criterion for forming flat clusters. Valid 
        values are 'inconsistent' (default), 'distance', or 'maxclust' 
        cluster formation algorithms. See `fcluster` for descriptions. 
    metric : str or function, optional 
        The distance metric for calculating pairwise distances. See 
        ``distance.pdist`` for descriptions and linkage to verify 
        compatibility with the linkage method. 
    depth : int, optional 
        The maximum depth for the inconsistency calculation. See 
        `inconsistent` for more information. 
    method : str, optional 
        The linkage method to use (single, complete, average, 
        weighted, median centroid, ward). See `linkage` for more 
        information. Default is &quot;single&quot;. 
    R : ndarray, optional 
        The inconsistency matrix. It will be computed if necessary 
        if it is not passed. 
 
    Returns 
    ------- 
    fclusterdata : ndarray 
        A vector of length n. T[i] is the flat cluster number to 
        which original observation i belongs. 
 
    See Also 
    -------- 
    scipy.spatial.distance.pdist : pairwise distance metrics 
 
    Notes 
    ----- 
    This function is similar to the MATLAB function ``clusterdata``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import fclusterdata 
 
    This is a convenience method that abstracts all the steps to perform in a 
    typical SciPy's hierarchical clustering workflow. 
 
    * Transform the input data into a condensed matrix with 
      `scipy.spatial.distance.pdist`. 
 
    * Apply a clustering method. 
 
    * Obtain flat clusters at a user defined distance threshold ``t`` using 
      `scipy.cluster.hierarchy.fcluster`. 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    &gt;&gt;&gt; fclusterdata(X, t=1) 
    array([3, 3, 3, 4, 4, 4, 2, 2, 2, 1, 1, 1], dtype=int32) 
 
    The output here (for the dataset ``X``, distance threshold ``t``, and the 
    default settings) is four clusters with three data points each. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">X</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">!= </span><span class="s6">2</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">'The observation matrix X must be an n by m '</span>
                        <span class="s5">'array.'</span><span class="s4">)</span>

    <span class="s1">Y </span><span class="s4">= </span><span class="s1">distance</span><span class="s4">.</span><span class="s1">pdist</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s1">metric</span><span class="s4">)</span>
    <span class="s1">Y </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">linkage</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s1">method</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">R </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">R </span><span class="s4">= </span><span class="s1">inconsistent</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">d</span><span class="s4">=</span><span class="s1">depth</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">R </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">R</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'c'</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">T </span><span class="s4">= </span><span class="s1">fcluster</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">criterion</span><span class="s4">=</span><span class="s1">criterion</span><span class="s4">, </span><span class="s1">depth</span><span class="s4">=</span><span class="s1">depth</span><span class="s4">, </span><span class="s1">R</span><span class="s4">=</span><span class="s1">R</span><span class="s4">, </span><span class="s1">t</span><span class="s4">=</span><span class="s1">t</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">T</span>


<span class="s3">def </span><span class="s1">leaves_list</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a list of leaf node ids. 
 
    The return corresponds to the observation vector index as it appears 
    in the tree from left to right. Z is a linkage matrix. 
 
    Parameters 
    ---------- 
    Z : ndarray 
        The hierarchical clustering encoded as a matrix.  `Z` is 
        a linkage matrix.  See `linkage` for more information. 
 
    Returns 
    ------- 
    leaves_list : ndarray 
        The list of leaf node ids. 
 
    See Also 
    -------- 
    dendrogram : for information about dendrogram structure. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, dendrogram, leaves_list 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
    &gt;&gt;&gt; from matplotlib import pyplot as plt 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    &gt;&gt;&gt; Z = ward(pdist(X)) 
 
    The linkage matrix ``Z`` represents a dendrogram, that is, a tree that 
    encodes the structure of the clustering performed. 
    `scipy.cluster.hierarchy.leaves_list` shows the mapping between 
    indices in the ``X`` dataset and leaves in the dendrogram: 
 
    &gt;&gt;&gt; leaves_list(Z) 
    array([ 2,  0,  1,  5,  3,  4,  8,  6,  7, 11,  9, 10], dtype=int32) 
 
    &gt;&gt;&gt; fig = plt.figure(figsize=(25, 10)) 
    &gt;&gt;&gt; dn = dendrogram(Z) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">is_valid_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'Z'</span><span class="s4">)</span>
    <span class="s1">n </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1</span>
    <span class="s1">ML </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n</span><span class="s4">,), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s5">'i'</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">_hierarchy</span><span class="s4">.</span><span class="s1">prelist</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">ML</span><span class="s4">, </span><span class="s1">n</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">ML</span><span class="s4">)</span>


<span class="s2"># Maps number of leaves to text size.</span>
<span class="s2">#</span>
<span class="s2"># p &lt;= 20, size=&quot;12&quot;</span>
<span class="s2"># 20 &lt; p &lt;= 30, size=&quot;10&quot;</span>
<span class="s2"># 30 &lt; p &lt;= 50, size=&quot;8&quot;</span>
<span class="s2"># 50 &lt; p &lt;= np.inf, size=&quot;6&quot;</span>

<span class="s1">_dtextsizes </span><span class="s4">= {</span><span class="s6">20</span><span class="s4">: </span><span class="s6">12</span><span class="s4">, </span><span class="s6">30</span><span class="s4">: </span><span class="s6">10</span><span class="s4">, </span><span class="s6">50</span><span class="s4">: </span><span class="s6">8</span><span class="s4">, </span><span class="s6">85</span><span class="s4">: </span><span class="s6">6</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span><span class="s4">: </span><span class="s6">5</span><span class="s4">}</span>
<span class="s1">_drotation </span><span class="s4">= {</span><span class="s6">20</span><span class="s4">: </span><span class="s6">0</span><span class="s4">, </span><span class="s6">40</span><span class="s4">: </span><span class="s6">45</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span><span class="s4">: </span><span class="s6">90</span><span class="s4">}</span>
<span class="s1">_dtextsortedkeys </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">_dtextsizes</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">())</span>
<span class="s1">_dtextsortedkeys</span><span class="s4">.</span><span class="s1">sort</span><span class="s4">()</span>
<span class="s1">_drotationsortedkeys </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">_drotation</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">())</span>
<span class="s1">_drotationsortedkeys</span><span class="s4">.</span><span class="s1">sort</span><span class="s4">()</span>


<span class="s3">def </span><span class="s1">_remove_dups</span><span class="s4">(</span><span class="s1">L</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Remove duplicates AND preserve the original order of the elements. 
 
    The set class is not guaranteed to do this. 
    &quot;&quot;&quot;</span>
    <span class="s1">seen_before </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()</span>
    <span class="s1">L2 </span><span class="s4">= []</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">L</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">i </span><span class="s3">not in </span><span class="s1">seen_before</span><span class="s4">:</span>
            <span class="s1">seen_before</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)</span>
            <span class="s1">L2</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">L2</span>


<span class="s3">def </span><span class="s1">_get_tick_text_size</span><span class="s4">(</span><span class="s1">p</span><span class="s4">):</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">_dtextsortedkeys</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">p </span><span class="s4">&lt;= </span><span class="s1">k</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_dtextsizes</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">_get_tick_rotation</span><span class="s4">(</span><span class="s1">p</span><span class="s4">):</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">_drotationsortedkeys</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">p </span><span class="s4">&lt;= </span><span class="s1">k</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_drotation</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">_plot_dendrogram</span><span class="s4">(</span><span class="s1">icoords</span><span class="s4">, </span><span class="s1">dcoords</span><span class="s4">, </span><span class="s1">ivl</span><span class="s4">, </span><span class="s1">p</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">mh</span><span class="s4">, </span><span class="s1">orientation</span><span class="s4">,</span>
                     <span class="s1">no_labels</span><span class="s4">, </span><span class="s1">color_list</span><span class="s4">, </span><span class="s1">leaf_font_size</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
                     <span class="s1">leaf_rotation</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">contraction_marks</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
                     <span class="s1">ax</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">above_threshold_color</span><span class="s4">=</span><span class="s5">'C0'</span><span class="s4">):</span>
    <span class="s2"># Import matplotlib here so that it's not imported unless dendrograms</span>
    <span class="s2"># are plotted. Raise an informative error if importing fails.</span>
    <span class="s3">try</span><span class="s4">:</span>
        <span class="s2"># if an axis is provided, don't use pylab at all</span>
        <span class="s3">if </span><span class="s1">ax </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">import </span><span class="s1">matplotlib</span><span class="s4">.</span><span class="s1">pylab</span>
        <span class="s3">import </span><span class="s1">matplotlib</span><span class="s4">.</span><span class="s1">patches</span>
        <span class="s3">import </span><span class="s1">matplotlib</span><span class="s4">.</span><span class="s1">collections</span>
    <span class="s3">except </span><span class="s1">ImportError </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ImportError</span><span class="s4">(</span><span class="s5">&quot;You must install the matplotlib library to plot &quot;</span>
                          <span class="s5">&quot;the dendrogram. Use no_plot=True to calculate the &quot;</span>
                          <span class="s5">&quot;dendrogram without plotting.&quot;</span><span class="s4">) </span><span class="s3">from </span><span class="s1">e</span>

    <span class="s3">if </span><span class="s1">ax </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">ax </span><span class="s4">= </span><span class="s1">matplotlib</span><span class="s4">.</span><span class="s1">pylab</span><span class="s4">.</span><span class="s1">gca</span><span class="s4">()</span>
        <span class="s2"># if we're using pylab, we want to trigger a draw at the end</span>
        <span class="s1">trigger_redraw </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">trigger_redraw </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s2"># Independent variable plot width</span>
    <span class="s1">ivw </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">ivl</span><span class="s4">) * </span><span class="s6">10</span>
    <span class="s2"># Dependent variable plot height</span>
    <span class="s1">dvw </span><span class="s4">= </span><span class="s1">mh </span><span class="s4">+ </span><span class="s1">mh </span><span class="s4">* </span><span class="s6">0.05</span>

    <span class="s1">iv_ticks </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s6">5</span><span class="s4">, </span><span class="s1">len</span><span class="s4">(</span><span class="s1">ivl</span><span class="s4">) * </span><span class="s6">10 </span><span class="s4">+ </span><span class="s6">5</span><span class="s4">, </span><span class="s6">10</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">orientation </span><span class="s3">in </span><span class="s4">(</span><span class="s5">'top'</span><span class="s4">, </span><span class="s5">'bottom'</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">orientation </span><span class="s4">== </span><span class="s5">'top'</span><span class="s4">:</span>
            <span class="s1">ax</span><span class="s4">.</span><span class="s1">set_ylim</span><span class="s4">([</span><span class="s6">0</span><span class="s4">, </span><span class="s1">dvw</span><span class="s4">])</span>
            <span class="s1">ax</span><span class="s4">.</span><span class="s1">set_xlim</span><span class="s4">([</span><span class="s6">0</span><span class="s4">, </span><span class="s1">ivw</span><span class="s4">])</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">ax</span><span class="s4">.</span><span class="s1">set_ylim</span><span class="s4">([</span><span class="s1">dvw</span><span class="s4">, </span><span class="s6">0</span><span class="s4">])</span>
            <span class="s1">ax</span><span class="s4">.</span><span class="s1">set_xlim</span><span class="s4">([</span><span class="s6">0</span><span class="s4">, </span><span class="s1">ivw</span><span class="s4">])</span>

        <span class="s1">xlines </span><span class="s4">= </span><span class="s1">icoords</span>
        <span class="s1">ylines </span><span class="s4">= </span><span class="s1">dcoords</span>
        <span class="s3">if </span><span class="s1">no_labels</span><span class="s4">:</span>
            <span class="s1">ax</span><span class="s4">.</span><span class="s1">set_xticks</span><span class="s4">([])</span>
            <span class="s1">ax</span><span class="s4">.</span><span class="s1">set_xticklabels</span><span class="s4">([])</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">ax</span><span class="s4">.</span><span class="s1">set_xticks</span><span class="s4">(</span><span class="s1">iv_ticks</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">orientation </span><span class="s4">== </span><span class="s5">'top'</span><span class="s4">:</span>
                <span class="s1">ax</span><span class="s4">.</span><span class="s1">xaxis</span><span class="s4">.</span><span class="s1">set_ticks_position</span><span class="s4">(</span><span class="s5">'bottom'</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">ax</span><span class="s4">.</span><span class="s1">xaxis</span><span class="s4">.</span><span class="s1">set_ticks_position</span><span class="s4">(</span><span class="s5">'top'</span><span class="s4">)</span>

            <span class="s2"># Make the tick marks invisible because they cover up the links</span>
            <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">ax</span><span class="s4">.</span><span class="s1">get_xticklines</span><span class="s4">():</span>
                <span class="s1">line</span><span class="s4">.</span><span class="s1">set_visible</span><span class="s4">(</span><span class="s3">False</span><span class="s4">)</span>

            <span class="s1">leaf_rot </span><span class="s4">= (</span><span class="s1">float</span><span class="s4">(</span><span class="s1">_get_tick_rotation</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">ivl</span><span class="s4">)))</span>
                        <span class="s3">if </span><span class="s4">(</span><span class="s1">leaf_rotation </span><span class="s3">is None</span><span class="s4">) </span><span class="s3">else </span><span class="s1">leaf_rotation</span><span class="s4">)</span>
            <span class="s1">leaf_font </span><span class="s4">= (</span><span class="s1">float</span><span class="s4">(</span><span class="s1">_get_tick_text_size</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">ivl</span><span class="s4">)))</span>
                         <span class="s3">if </span><span class="s4">(</span><span class="s1">leaf_font_size </span><span class="s3">is None</span><span class="s4">) </span><span class="s3">else </span><span class="s1">leaf_font_size</span><span class="s4">)</span>
            <span class="s1">ax</span><span class="s4">.</span><span class="s1">set_xticklabels</span><span class="s4">(</span><span class="s1">ivl</span><span class="s4">, </span><span class="s1">rotation</span><span class="s4">=</span><span class="s1">leaf_rot</span><span class="s4">, </span><span class="s1">size</span><span class="s4">=</span><span class="s1">leaf_font</span><span class="s4">)</span>

    <span class="s3">elif </span><span class="s1">orientation </span><span class="s3">in </span><span class="s4">(</span><span class="s5">'left'</span><span class="s4">, </span><span class="s5">'right'</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">orientation </span><span class="s4">== </span><span class="s5">'left'</span><span class="s4">:</span>
            <span class="s1">ax</span><span class="s4">.</span><span class="s1">set_xlim</span><span class="s4">([</span><span class="s1">dvw</span><span class="s4">, </span><span class="s6">0</span><span class="s4">])</span>
            <span class="s1">ax</span><span class="s4">.</span><span class="s1">set_ylim</span><span class="s4">([</span><span class="s6">0</span><span class="s4">, </span><span class="s1">ivw</span><span class="s4">])</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">ax</span><span class="s4">.</span><span class="s1">set_xlim</span><span class="s4">([</span><span class="s6">0</span><span class="s4">, </span><span class="s1">dvw</span><span class="s4">])</span>
            <span class="s1">ax</span><span class="s4">.</span><span class="s1">set_ylim</span><span class="s4">([</span><span class="s6">0</span><span class="s4">, </span><span class="s1">ivw</span><span class="s4">])</span>

        <span class="s1">xlines </span><span class="s4">= </span><span class="s1">dcoords</span>
        <span class="s1">ylines </span><span class="s4">= </span><span class="s1">icoords</span>
        <span class="s3">if </span><span class="s1">no_labels</span><span class="s4">:</span>
            <span class="s1">ax</span><span class="s4">.</span><span class="s1">set_yticks</span><span class="s4">([])</span>
            <span class="s1">ax</span><span class="s4">.</span><span class="s1">set_yticklabels</span><span class="s4">([])</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">ax</span><span class="s4">.</span><span class="s1">set_yticks</span><span class="s4">(</span><span class="s1">iv_ticks</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">orientation </span><span class="s4">== </span><span class="s5">'left'</span><span class="s4">:</span>
                <span class="s1">ax</span><span class="s4">.</span><span class="s1">yaxis</span><span class="s4">.</span><span class="s1">set_ticks_position</span><span class="s4">(</span><span class="s5">'right'</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">ax</span><span class="s4">.</span><span class="s1">yaxis</span><span class="s4">.</span><span class="s1">set_ticks_position</span><span class="s4">(</span><span class="s5">'left'</span><span class="s4">)</span>

            <span class="s2"># Make the tick marks invisible because they cover up the links</span>
            <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">ax</span><span class="s4">.</span><span class="s1">get_yticklines</span><span class="s4">():</span>
                <span class="s1">line</span><span class="s4">.</span><span class="s1">set_visible</span><span class="s4">(</span><span class="s3">False</span><span class="s4">)</span>

            <span class="s1">leaf_font </span><span class="s4">= (</span><span class="s1">float</span><span class="s4">(</span><span class="s1">_get_tick_text_size</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">ivl</span><span class="s4">)))</span>
                         <span class="s3">if </span><span class="s4">(</span><span class="s1">leaf_font_size </span><span class="s3">is None</span><span class="s4">) </span><span class="s3">else </span><span class="s1">leaf_font_size</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">leaf_rotation </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">ax</span><span class="s4">.</span><span class="s1">set_yticklabels</span><span class="s4">(</span><span class="s1">ivl</span><span class="s4">, </span><span class="s1">rotation</span><span class="s4">=</span><span class="s1">leaf_rotation</span><span class="s4">, </span><span class="s1">size</span><span class="s4">=</span><span class="s1">leaf_font</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">ax</span><span class="s4">.</span><span class="s1">set_yticklabels</span><span class="s4">(</span><span class="s1">ivl</span><span class="s4">, </span><span class="s1">size</span><span class="s4">=</span><span class="s1">leaf_font</span><span class="s4">)</span>

    <span class="s2"># Let's use collections instead. This way there is a separate legend item</span>
    <span class="s2"># for each tree grouping, rather than stupidly one for each line segment.</span>
    <span class="s1">colors_used </span><span class="s4">= </span><span class="s1">_remove_dups</span><span class="s4">(</span><span class="s1">color_list</span><span class="s4">)</span>
    <span class="s1">color_to_lines </span><span class="s4">= {}</span>
    <span class="s3">for </span><span class="s1">color </span><span class="s3">in </span><span class="s1">colors_used</span><span class="s4">:</span>
        <span class="s1">color_to_lines</span><span class="s4">[</span><span class="s1">color</span><span class="s4">] = []</span>
    <span class="s3">for </span><span class="s4">(</span><span class="s1">xline</span><span class="s4">, </span><span class="s1">yline</span><span class="s4">, </span><span class="s1">color</span><span class="s4">) </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">xlines</span><span class="s4">, </span><span class="s1">ylines</span><span class="s4">, </span><span class="s1">color_list</span><span class="s4">):</span>
        <span class="s1">color_to_lines</span><span class="s4">[</span><span class="s1">color</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">list</span><span class="s4">(</span><span class="s1">zip</span><span class="s4">(</span><span class="s1">xline</span><span class="s4">, </span><span class="s1">yline</span><span class="s4">)))</span>

    <span class="s1">colors_to_collections </span><span class="s4">= {}</span>
    <span class="s2"># Construct the collections.</span>
    <span class="s3">for </span><span class="s1">color </span><span class="s3">in </span><span class="s1">colors_used</span><span class="s4">:</span>
        <span class="s1">coll </span><span class="s4">= </span><span class="s1">matplotlib</span><span class="s4">.</span><span class="s1">collections</span><span class="s4">.</span><span class="s1">LineCollection</span><span class="s4">(</span><span class="s1">color_to_lines</span><span class="s4">[</span><span class="s1">color</span><span class="s4">],</span>
                                                     <span class="s1">colors</span><span class="s4">=(</span><span class="s1">color</span><span class="s4">,))</span>
        <span class="s1">colors_to_collections</span><span class="s4">[</span><span class="s1">color</span><span class="s4">] = </span><span class="s1">coll</span>

    <span class="s2"># Add all the groupings below the color threshold.</span>
    <span class="s3">for </span><span class="s1">color </span><span class="s3">in </span><span class="s1">colors_used</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">color </span><span class="s4">!= </span><span class="s1">above_threshold_color</span><span class="s4">:</span>
            <span class="s1">ax</span><span class="s4">.</span><span class="s1">add_collection</span><span class="s4">(</span><span class="s1">colors_to_collections</span><span class="s4">[</span><span class="s1">color</span><span class="s4">])</span>
    <span class="s2"># If there's a grouping of links above the color threshold, it goes last.</span>
    <span class="s3">if </span><span class="s1">above_threshold_color </span><span class="s3">in </span><span class="s1">colors_to_collections</span><span class="s4">:</span>
        <span class="s1">ax</span><span class="s4">.</span><span class="s1">add_collection</span><span class="s4">(</span><span class="s1">colors_to_collections</span><span class="s4">[</span><span class="s1">above_threshold_color</span><span class="s4">])</span>

    <span class="s3">if </span><span class="s1">contraction_marks </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">Ellipse </span><span class="s4">= </span><span class="s1">matplotlib</span><span class="s4">.</span><span class="s1">patches</span><span class="s4">.</span><span class="s1">Ellipse</span>
        <span class="s3">for </span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">) </span><span class="s3">in </span><span class="s1">contraction_marks</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">orientation </span><span class="s3">in </span><span class="s4">(</span><span class="s5">'left'</span><span class="s4">, </span><span class="s5">'right'</span><span class="s4">):</span>
                <span class="s1">e </span><span class="s4">= </span><span class="s1">Ellipse</span><span class="s4">((</span><span class="s1">y</span><span class="s4">, </span><span class="s1">x</span><span class="s4">), </span><span class="s1">width</span><span class="s4">=</span><span class="s1">dvw </span><span class="s4">/ </span><span class="s6">100</span><span class="s4">, </span><span class="s1">height</span><span class="s4">=</span><span class="s6">1.0</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">e </span><span class="s4">= </span><span class="s1">Ellipse</span><span class="s4">((</span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">), </span><span class="s1">width</span><span class="s4">=</span><span class="s6">1.0</span><span class="s4">, </span><span class="s1">height</span><span class="s4">=</span><span class="s1">dvw </span><span class="s4">/ </span><span class="s6">100</span><span class="s4">)</span>
            <span class="s1">ax</span><span class="s4">.</span><span class="s1">add_artist</span><span class="s4">(</span><span class="s1">e</span><span class="s4">)</span>
            <span class="s1">e</span><span class="s4">.</span><span class="s1">set_clip_box</span><span class="s4">(</span><span class="s1">ax</span><span class="s4">.</span><span class="s1">bbox</span><span class="s4">)</span>
            <span class="s1">e</span><span class="s4">.</span><span class="s1">set_alpha</span><span class="s4">(</span><span class="s6">0.5</span><span class="s4">)</span>
            <span class="s1">e</span><span class="s4">.</span><span class="s1">set_facecolor</span><span class="s4">(</span><span class="s5">'k'</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">trigger_redraw</span><span class="s4">:</span>
        <span class="s1">matplotlib</span><span class="s4">.</span><span class="s1">pylab</span><span class="s4">.</span><span class="s1">draw_if_interactive</span><span class="s4">()</span>


<span class="s2"># C0  is used for above threshold color</span>
<span class="s1">_link_line_colors_default </span><span class="s4">= (</span><span class="s5">'C1'</span><span class="s4">, </span><span class="s5">'C2'</span><span class="s4">, </span><span class="s5">'C3'</span><span class="s4">, </span><span class="s5">'C4'</span><span class="s4">, </span><span class="s5">'C5'</span><span class="s4">, </span><span class="s5">'C6'</span><span class="s4">, </span><span class="s5">'C7'</span><span class="s4">, </span><span class="s5">'C8'</span><span class="s4">, </span><span class="s5">'C9'</span><span class="s4">)</span>
<span class="s1">_link_line_colors </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">_link_line_colors_default</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">set_link_color_palette</span><span class="s4">(</span><span class="s1">palette</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Set list of matplotlib color codes for use by dendrogram. 
 
    Note that this palette is global (i.e., setting it once changes the colors 
    for all subsequent calls to `dendrogram`) and that it affects only the 
    the colors below ``color_threshold``. 
 
    Note that `dendrogram` also accepts a custom coloring function through its 
    ``link_color_func`` keyword, which is more flexible and non-global. 
 
    Parameters 
    ---------- 
    palette : list of str or None 
        A list of matplotlib color codes.  The order of the color codes is the 
        order in which the colors are cycled through when color thresholding in 
        the dendrogram. 
 
        If ``None``, resets the palette to its default (which are matplotlib 
        default colors C1 to C9). 
 
    Returns 
    ------- 
    None 
 
    See Also 
    -------- 
    dendrogram 
 
    Notes 
    ----- 
    Ability to reset the palette with ``None`` added in SciPy 0.17.0. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.cluster import hierarchy 
    &gt;&gt;&gt; ytdist = np.array([662., 877., 255., 412., 996., 295., 468., 268., 
    ...                    400., 754., 564., 138., 219., 869., 669.]) 
    &gt;&gt;&gt; Z = hierarchy.linkage(ytdist, 'single') 
    &gt;&gt;&gt; dn = hierarchy.dendrogram(Z, no_plot=True) 
    &gt;&gt;&gt; dn['color_list'] 
    ['C1', 'C0', 'C0', 'C0', 'C0'] 
    &gt;&gt;&gt; hierarchy.set_link_color_palette(['c', 'm', 'y', 'k']) 
    &gt;&gt;&gt; dn = hierarchy.dendrogram(Z, no_plot=True, above_threshold_color='b') 
    &gt;&gt;&gt; dn['color_list'] 
    ['c', 'b', 'b', 'b', 'b'] 
    &gt;&gt;&gt; dn = hierarchy.dendrogram(Z, no_plot=True, color_threshold=267, 
    ...                           above_threshold_color='k') 
    &gt;&gt;&gt; dn['color_list'] 
    ['c', 'm', 'm', 'k', 'k'] 
 
    Now, reset the color palette to its default: 
 
    &gt;&gt;&gt; hierarchy.set_link_color_palette(None) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">palette </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s2"># reset to its default</span>
        <span class="s1">palette </span><span class="s4">= </span><span class="s1">_link_line_colors_default</span>
    <span class="s3">elif not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">palette</span><span class="s4">, (</span><span class="s1">list</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">)):</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;palette must be a list or tuple&quot;</span><span class="s4">)</span>
    <span class="s1">_ptypes </span><span class="s4">= [</span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">p</span><span class="s4">, </span><span class="s1">str</span><span class="s4">) </span><span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">palette</span><span class="s4">]</span>

    <span class="s3">if False in </span><span class="s1">_ptypes</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;all palette list elements must be color strings&quot;</span><span class="s4">)</span>

    <span class="s3">global </span><span class="s1">_link_line_colors</span>
    <span class="s1">_link_line_colors </span><span class="s4">= </span><span class="s1">palette</span>


<span class="s3">def </span><span class="s1">dendrogram</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">p</span><span class="s4">=</span><span class="s6">30</span><span class="s4">, </span><span class="s1">truncate_mode</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">color_threshold</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
               <span class="s1">get_leaves</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">orientation</span><span class="s4">=</span><span class="s5">'top'</span><span class="s4">, </span><span class="s1">labels</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
               <span class="s1">count_sort</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">distance_sort</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">show_leaf_counts</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
               <span class="s1">no_plot</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">no_labels</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">leaf_font_size</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
               <span class="s1">leaf_rotation</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">leaf_label_func</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
               <span class="s1">show_contracted</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">link_color_func</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">ax</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
               <span class="s1">above_threshold_color</span><span class="s4">=</span><span class="s5">'C0'</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Plot the hierarchical clustering as a dendrogram. 
 
    The dendrogram illustrates how each cluster is 
    composed by drawing a U-shaped link between a non-singleton 
    cluster and its children. The top of the U-link indicates a 
    cluster merge. The two legs of the U-link indicate which clusters 
    were merged. The length of the two legs of the U-link represents 
    the distance between the child clusters. It is also the 
    cophenetic distance between original observations in the two 
    children clusters. 
 
    Parameters 
    ---------- 
    Z : ndarray 
        The linkage matrix encoding the hierarchical clustering to 
        render as a dendrogram. See the ``linkage`` function for more 
        information on the format of ``Z``. 
    p : int, optional 
        The ``p`` parameter for ``truncate_mode``. 
    truncate_mode : str, optional 
        The dendrogram can be hard to read when the original 
        observation matrix from which the linkage is derived is 
        large. Truncation is used to condense the dendrogram. There 
        are several modes: 
 
        ``None`` 
          No truncation is performed (default). 
          Note: ``'none'`` is an alias for ``None`` that's kept for 
          backward compatibility. 
 
        ``'lastp'`` 
          The last ``p`` non-singleton clusters formed in the linkage are the 
          only non-leaf nodes in the linkage; they correspond to rows 
          ``Z[n-p-2:end]`` in ``Z``. All other non-singleton clusters are 
          contracted into leaf nodes. 
 
        ``'level'`` 
          No more than ``p`` levels of the dendrogram tree are displayed. 
          A &quot;level&quot; includes all nodes with ``p`` merges from the final merge. 
 
          Note: ``'mtica'`` is an alias for ``'level'`` that's kept for 
          backward compatibility. 
 
    color_threshold : double, optional 
        For brevity, let :math:`t` be the ``color_threshold``. 
        Colors all the descendent links below a cluster node 
        :math:`k` the same color if :math:`k` is the first node below 
        the cut threshold :math:`t`. All links connecting nodes with 
        distances greater than or equal to the threshold are colored 
        with de default matplotlib color ``'C0'``. If :math:`t` is less 
        than or equal to zero, all nodes are colored ``'C0'``. 
        If ``color_threshold`` is None or 'default', 
        corresponding with MATLAB(TM) behavior, the threshold is set to 
        ``0.7*max(Z[:,2])``. 
 
    get_leaves : bool, optional 
        Includes a list ``R['leaves']=H`` in the result 
        dictionary. For each :math:`i`, ``H[i] == j``, cluster node 
        ``j`` appears in position ``i`` in the left-to-right traversal 
        of the leaves, where :math:`j &lt; 2n-1` and :math:`i &lt; n`. 
    orientation : str, optional 
        The direction to plot the dendrogram, which can be any 
        of the following strings: 
 
        ``'top'`` 
          Plots the root at the top, and plot descendent links going downwards. 
          (default). 
 
        ``'bottom'`` 
          Plots the root at the bottom, and plot descendent links going 
          upwards. 
 
        ``'left'`` 
          Plots the root at the left, and plot descendent links going right. 
 
        ``'right'`` 
          Plots the root at the right, and plot descendent links going left. 
 
    labels : ndarray, optional 
        By default, ``labels`` is None so the index of the original observation 
        is used to label the leaf nodes.  Otherwise, this is an :math:`n`-sized 
        sequence, with ``n == Z.shape[0] + 1``. The ``labels[i]`` value is the 
        text to put under the :math:`i` th leaf node only if it corresponds to 
        an original observation and not a non-singleton cluster. 
    count_sort : str or bool, optional 
        For each node n, the order (visually, from left-to-right) n's 
        two descendent links are plotted is determined by this 
        parameter, which can be any of the following values: 
 
        ``False`` 
          Nothing is done. 
 
        ``'ascending'`` or ``True`` 
          The child with the minimum number of original objects in its cluster 
          is plotted first. 
 
        ``'descending'`` 
          The child with the maximum number of original objects in its cluster 
          is plotted first. 
 
        Note, ``distance_sort`` and ``count_sort`` cannot both be True. 
    distance_sort : str or bool, optional 
        For each node n, the order (visually, from left-to-right) n's 
        two descendent links are plotted is determined by this 
        parameter, which can be any of the following values: 
 
        ``False`` 
          Nothing is done. 
 
        ``'ascending'`` or ``True`` 
          The child with the minimum distance between its direct descendents is 
          plotted first. 
 
        ``'descending'`` 
          The child with the maximum distance between its direct descendents is 
          plotted first. 
 
        Note ``distance_sort`` and ``count_sort`` cannot both be True. 
    show_leaf_counts : bool, optional 
         When True, leaf nodes representing :math:`k&gt;1` original 
         observation are labeled with the number of observations they 
         contain in parentheses. 
    no_plot : bool, optional 
        When True, the final rendering is not performed. This is 
        useful if only the data structures computed for the rendering 
        are needed or if matplotlib is not available. 
    no_labels : bool, optional 
        When True, no labels appear next to the leaf nodes in the 
        rendering of the dendrogram. 
    leaf_rotation : double, optional 
        Specifies the angle (in degrees) to rotate the leaf 
        labels. When unspecified, the rotation is based on the number of 
        nodes in the dendrogram (default is 0). 
    leaf_font_size : int, optional 
        Specifies the font size (in points) of the leaf labels. When 
        unspecified, the size based on the number of nodes in the 
        dendrogram. 
    leaf_label_func : lambda or function, optional 
        When ``leaf_label_func`` is a callable function, for each 
        leaf with cluster index :math:`k &lt; 2n-1`. The function 
        is expected to return a string with the label for the 
        leaf. 
 
        Indices :math:`k &lt; n` correspond to original observations 
        while indices :math:`k \\geq n` correspond to non-singleton 
        clusters. 
 
        For example, to label singletons with their node id and 
        non-singletons with their id, count, and inconsistency 
        coefficient, simply do:: 
 
            # First define the leaf label function. 
            def llf(id): 
                if id &lt; n: 
                    return str(id) 
                else: 
                    return '[%d %d %1.2f]' % (id, count, R[n-id,3]) 
 
            # The text for the leaf nodes is going to be big so force 
            # a rotation of 90 degrees. 
            dendrogram(Z, leaf_label_func=llf, leaf_rotation=90) 
 
            # leaf_label_func can also be used together with ``truncate_mode``, 
            # in which case you will get your leaves labeled after truncation: 
            dendrogram(Z, leaf_label_func=llf, leaf_rotation=90, 
                       truncate_mode='level', p=2) 
 
    show_contracted : bool, optional 
        When True the heights of non-singleton nodes contracted 
        into a leaf node are plotted as crosses along the link 
        connecting that leaf node.  This really is only useful when 
        truncation is used (see ``truncate_mode`` parameter). 
    link_color_func : callable, optional 
        If given, `link_color_function` is called with each non-singleton id 
        corresponding to each U-shaped link it will paint. The function is 
        expected to return the color to paint the link, encoded as a matplotlib 
        color string code. For example:: 
 
            dendrogram(Z, link_color_func=lambda k: colors[k]) 
 
        colors the direct links below each untruncated non-singleton node 
        ``k`` using ``colors[k]``. 
    ax : matplotlib Axes instance, optional 
        If None and `no_plot` is not True, the dendrogram will be plotted 
        on the current axes.  Otherwise if `no_plot` is not True the 
        dendrogram will be plotted on the given ``Axes`` instance. This can be 
        useful if the dendrogram is part of a more complex figure. 
    above_threshold_color : str, optional 
        This matplotlib color string sets the color of the links above the 
        color_threshold. The default is ``'C0'``. 
 
    Returns 
    ------- 
    R : dict 
        A dictionary of data structures computed to render the 
        dendrogram. Its has the following keys: 
 
        ``'color_list'`` 
          A list of color names. The k'th element represents the color of the 
          k'th link. 
 
        ``'icoord'`` and ``'dcoord'`` 
          Each of them is a list of lists. Let ``icoord = [I1, I2, ..., Ip]`` 
          where ``Ik = [xk1, xk2, xk3, xk4]`` and ``dcoord = [D1, D2, ..., Dp]`` 
          where ``Dk = [yk1, yk2, yk3, yk4]``, then the k'th link painted is 
          ``(xk1, yk1)`` - ``(xk2, yk2)`` - ``(xk3, yk3)`` - ``(xk4, yk4)``. 
 
        ``'ivl'`` 
          A list of labels corresponding to the leaf nodes. 
 
        ``'leaves'`` 
          For each i, ``H[i] == j``, cluster node ``j`` appears in position 
          ``i`` in the left-to-right traversal of the leaves, where 
          :math:`j &lt; 2n-1` and :math:`i &lt; n`. If ``j`` is less than ``n``, the 
          ``i``-th leaf node corresponds to an original observation. 
          Otherwise, it corresponds to a non-singleton cluster. 
 
        ``'leaves_color_list'`` 
          A list of color names. The k'th element represents the color of the 
          k'th leaf. 
 
    See Also 
    -------- 
    linkage, set_link_color_palette 
 
    Notes 
    ----- 
    It is expected that the distances in ``Z[:,2]`` be monotonic, otherwise 
    crossings appear in the dendrogram. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.cluster import hierarchy 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    A very basic example: 
 
    &gt;&gt;&gt; ytdist = np.array([662., 877., 255., 412., 996., 295., 468., 268., 
    ...                    400., 754., 564., 138., 219., 869., 669.]) 
    &gt;&gt;&gt; Z = hierarchy.linkage(ytdist, 'single') 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; dn = hierarchy.dendrogram(Z) 
 
    Now, plot in given axes, improve the color scheme and use both vertical and 
    horizontal orientations: 
 
    &gt;&gt;&gt; hierarchy.set_link_color_palette(['m', 'c', 'y', 'k']) 
    &gt;&gt;&gt; fig, axes = plt.subplots(1, 2, figsize=(8, 3)) 
    &gt;&gt;&gt; dn1 = hierarchy.dendrogram(Z, ax=axes[0], above_threshold_color='y', 
    ...                            orientation='top') 
    &gt;&gt;&gt; dn2 = hierarchy.dendrogram(Z, ax=axes[1], 
    ...                            above_threshold_color='#bcbddc', 
    ...                            orientation='right') 
    &gt;&gt;&gt; hierarchy.set_link_color_palette(None)  # reset to default after use 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># This feature was thought about but never implemented (still useful?):</span>
    <span class="s2">#</span>
    <span class="s2">#         ... = dendrogram(..., leaves_order=None)</span>
    <span class="s2">#</span>
    <span class="s2">#         Plots the leaves in the order specified by a vector of</span>
    <span class="s2">#         original observation indices. If the vector contains duplicates</span>
    <span class="s2">#         or results in a crossing, an exception will be thrown. Passing</span>
    <span class="s2">#         None orders leaf nodes based on the order they appear in the</span>
    <span class="s2">#         pre-order traversal.</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'c'</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">orientation </span><span class="s3">not in </span><span class="s4">[</span><span class="s5">&quot;top&quot;</span><span class="s4">, </span><span class="s5">&quot;left&quot;</span><span class="s4">, </span><span class="s5">&quot;bottom&quot;</span><span class="s4">, </span><span class="s5">&quot;right&quot;</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;orientation must be one of 'top', 'left', &quot;</span>
                         <span class="s5">&quot;'bottom', or 'right'&quot;</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">labels </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">len_labels </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s4">(</span><span class="s1">TypeError</span><span class="s4">, </span><span class="s1">AttributeError</span><span class="s4">):</span>
            <span class="s1">len_labels </span><span class="s4">= </span><span class="s1">labels</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1 </span><span class="s4">!= </span><span class="s1">len_labels</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Dimensions of Z and labels must be consistent.&quot;</span><span class="s4">)</span>

    <span class="s1">is_valid_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'Z'</span><span class="s4">)</span>
    <span class="s1">Zs </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s1">n </span><span class="s4">= </span><span class="s1">Zs</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">p</span><span class="s4">, (</span><span class="s1">int</span><span class="s4">, </span><span class="s1">float</span><span class="s4">)):</span>
        <span class="s1">p </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">p</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">'The second argument must be a number'</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">truncate_mode </span><span class="s3">not in </span><span class="s4">(</span><span class="s5">'lastp'</span><span class="s4">, </span><span class="s5">'mtica'</span><span class="s4">, </span><span class="s5">'level'</span><span class="s4">, </span><span class="s5">'none'</span><span class="s4">, </span><span class="s3">None</span><span class="s4">):</span>
        <span class="s2"># 'mtica' is kept working for backwards compat.</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Invalid truncation mode.'</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">truncate_mode </span><span class="s4">== </span><span class="s5">'lastp'</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">p </span><span class="s4">&gt; </span><span class="s1">n </span><span class="s3">or </span><span class="s1">p </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">p </span><span class="s4">= </span><span class="s1">n</span>

    <span class="s3">if </span><span class="s1">truncate_mode </span><span class="s4">== </span><span class="s5">'mtica'</span><span class="s4">:</span>
        <span class="s2"># 'mtica' is an alias</span>
        <span class="s1">truncate_mode </span><span class="s4">= </span><span class="s5">'level'</span>

    <span class="s3">if </span><span class="s1">truncate_mode </span><span class="s4">== </span><span class="s5">'level'</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">p </span><span class="s4">&lt;= </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">p </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span>

    <span class="s3">if </span><span class="s1">get_leaves</span><span class="s4">:</span>
        <span class="s1">lvs </span><span class="s4">= []</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">lvs </span><span class="s4">= </span><span class="s3">None</span>

    <span class="s1">icoord_list </span><span class="s4">= []</span>
    <span class="s1">dcoord_list </span><span class="s4">= []</span>
    <span class="s1">color_list </span><span class="s4">= []</span>
    <span class="s1">current_color </span><span class="s4">= [</span><span class="s6">0</span><span class="s4">]</span>
    <span class="s1">currently_below_threshold </span><span class="s4">= [</span><span class="s3">False</span><span class="s4">]</span>
    <span class="s1">ivl </span><span class="s4">= []  </span><span class="s2"># list of leaves</span>

    <span class="s3">if </span><span class="s1">color_threshold </span><span class="s3">is None or </span><span class="s4">(</span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">color_threshold</span><span class="s4">, </span><span class="s1">str</span><span class="s4">) </span><span class="s3">and</span>
                                   <span class="s1">color_threshold </span><span class="s4">== </span><span class="s5">'default'</span><span class="s4">):</span>
        <span class="s1">color_threshold </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">max</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[:, </span><span class="s6">2</span><span class="s4">]) * </span><span class="s6">0.7</span>

    <span class="s1">R </span><span class="s4">= {</span><span class="s5">'icoord'</span><span class="s4">: </span><span class="s1">icoord_list</span><span class="s4">, </span><span class="s5">'dcoord'</span><span class="s4">: </span><span class="s1">dcoord_list</span><span class="s4">, </span><span class="s5">'ivl'</span><span class="s4">: </span><span class="s1">ivl</span><span class="s4">,</span>
         <span class="s5">'leaves'</span><span class="s4">: </span><span class="s1">lvs</span><span class="s4">, </span><span class="s5">'color_list'</span><span class="s4">: </span><span class="s1">color_list</span><span class="s4">}</span>

    <span class="s2"># Empty list will be filled in _dendrogram_calculate_info</span>
    <span class="s1">contraction_marks </span><span class="s4">= [] </span><span class="s3">if </span><span class="s1">show_contracted </span><span class="s3">else None</span>

    <span class="s1">_dendrogram_calculate_info</span><span class="s4">(</span>
        <span class="s1">Z</span><span class="s4">=</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">p</span><span class="s4">=</span><span class="s1">p</span><span class="s4">,</span>
        <span class="s1">truncate_mode</span><span class="s4">=</span><span class="s1">truncate_mode</span><span class="s4">,</span>
        <span class="s1">color_threshold</span><span class="s4">=</span><span class="s1">color_threshold</span><span class="s4">,</span>
        <span class="s1">get_leaves</span><span class="s4">=</span><span class="s1">get_leaves</span><span class="s4">,</span>
        <span class="s1">orientation</span><span class="s4">=</span><span class="s1">orientation</span><span class="s4">,</span>
        <span class="s1">labels</span><span class="s4">=</span><span class="s1">labels</span><span class="s4">,</span>
        <span class="s1">count_sort</span><span class="s4">=</span><span class="s1">count_sort</span><span class="s4">,</span>
        <span class="s1">distance_sort</span><span class="s4">=</span><span class="s1">distance_sort</span><span class="s4">,</span>
        <span class="s1">show_leaf_counts</span><span class="s4">=</span><span class="s1">show_leaf_counts</span><span class="s4">,</span>
        <span class="s1">i</span><span class="s4">=</span><span class="s6">2</span><span class="s4">*</span><span class="s1">n </span><span class="s4">- </span><span class="s6">2</span><span class="s4">,</span>
        <span class="s1">iv</span><span class="s4">=</span><span class="s6">0.0</span><span class="s4">,</span>
        <span class="s1">ivl</span><span class="s4">=</span><span class="s1">ivl</span><span class="s4">,</span>
        <span class="s1">n</span><span class="s4">=</span><span class="s1">n</span><span class="s4">,</span>
        <span class="s1">icoord_list</span><span class="s4">=</span><span class="s1">icoord_list</span><span class="s4">,</span>
        <span class="s1">dcoord_list</span><span class="s4">=</span><span class="s1">dcoord_list</span><span class="s4">,</span>
        <span class="s1">lvs</span><span class="s4">=</span><span class="s1">lvs</span><span class="s4">,</span>
        <span class="s1">current_color</span><span class="s4">=</span><span class="s1">current_color</span><span class="s4">,</span>
        <span class="s1">color_list</span><span class="s4">=</span><span class="s1">color_list</span><span class="s4">,</span>
        <span class="s1">currently_below_threshold</span><span class="s4">=</span><span class="s1">currently_below_threshold</span><span class="s4">,</span>
        <span class="s1">leaf_label_func</span><span class="s4">=</span><span class="s1">leaf_label_func</span><span class="s4">,</span>
        <span class="s1">contraction_marks</span><span class="s4">=</span><span class="s1">contraction_marks</span><span class="s4">,</span>
        <span class="s1">link_color_func</span><span class="s4">=</span><span class="s1">link_color_func</span><span class="s4">,</span>
        <span class="s1">above_threshold_color</span><span class="s4">=</span><span class="s1">above_threshold_color</span><span class="s4">)</span>

    <span class="s3">if not </span><span class="s1">no_plot</span><span class="s4">:</span>
        <span class="s1">mh </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">max</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[:, </span><span class="s6">2</span><span class="s4">])</span>
        <span class="s1">_plot_dendrogram</span><span class="s4">(</span><span class="s1">icoord_list</span><span class="s4">, </span><span class="s1">dcoord_list</span><span class="s4">, </span><span class="s1">ivl</span><span class="s4">, </span><span class="s1">p</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">mh</span><span class="s4">, </span><span class="s1">orientation</span><span class="s4">,</span>
                         <span class="s1">no_labels</span><span class="s4">, </span><span class="s1">color_list</span><span class="s4">,</span>
                         <span class="s1">leaf_font_size</span><span class="s4">=</span><span class="s1">leaf_font_size</span><span class="s4">,</span>
                         <span class="s1">leaf_rotation</span><span class="s4">=</span><span class="s1">leaf_rotation</span><span class="s4">,</span>
                         <span class="s1">contraction_marks</span><span class="s4">=</span><span class="s1">contraction_marks</span><span class="s4">,</span>
                         <span class="s1">ax</span><span class="s4">=</span><span class="s1">ax</span><span class="s4">,</span>
                         <span class="s1">above_threshold_color</span><span class="s4">=</span><span class="s1">above_threshold_color</span><span class="s4">)</span>

    <span class="s1">R</span><span class="s4">[</span><span class="s5">&quot;leaves_color_list&quot;</span><span class="s4">] = </span><span class="s1">_get_leaves_color_list</span><span class="s4">(</span><span class="s1">R</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">R</span>


<span class="s3">def </span><span class="s1">_get_leaves_color_list</span><span class="s4">(</span><span class="s1">R</span><span class="s4">):</span>
    <span class="s1">leaves_color_list </span><span class="s4">= [</span><span class="s3">None</span><span class="s4">] * </span><span class="s1">len</span><span class="s4">(</span><span class="s1">R</span><span class="s4">[</span><span class="s5">'leaves'</span><span class="s4">])</span>
    <span class="s3">for </span><span class="s1">link_x</span><span class="s4">, </span><span class="s1">link_y</span><span class="s4">, </span><span class="s1">link_color </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">R</span><span class="s4">[</span><span class="s5">'icoord'</span><span class="s4">],</span>
                                          <span class="s1">R</span><span class="s4">[</span><span class="s5">'dcoord'</span><span class="s4">],</span>
                                          <span class="s1">R</span><span class="s4">[</span><span class="s5">'color_list'</span><span class="s4">]):</span>
        <span class="s3">for </span><span class="s4">(</span><span class="s1">xi</span><span class="s4">, </span><span class="s1">yi</span><span class="s4">) </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">link_x</span><span class="s4">, </span><span class="s1">link_y</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">yi </span><span class="s4">== </span><span class="s6">0.0 </span><span class="s3">and </span><span class="s4">(</span><span class="s1">xi </span><span class="s4">% </span><span class="s6">5 </span><span class="s4">== </span><span class="s6">0 </span><span class="s3">and </span><span class="s1">xi </span><span class="s4">% </span><span class="s6">2 </span><span class="s4">== </span><span class="s6">1</span><span class="s4">):</span>
                <span class="s2"># if yi is 0.0 and xi is divisible by 5 and odd,</span>
                <span class="s2"># the point is a leaf</span>
                <span class="s2"># xi of leaves are      5, 15, 25, 35, ... (see `iv_ticks`)</span>
                <span class="s2"># index of leaves are   0,  1,  2,  3, ... as below</span>
                <span class="s1">leaf_index </span><span class="s4">= (</span><span class="s1">int</span><span class="s4">(</span><span class="s1">xi</span><span class="s4">) - </span><span class="s6">5</span><span class="s4">) // </span><span class="s6">10</span>
                <span class="s2"># each leaf has a same color of its link.</span>
                <span class="s1">leaves_color_list</span><span class="s4">[</span><span class="s1">leaf_index</span><span class="s4">] = </span><span class="s1">link_color</span>
    <span class="s3">return </span><span class="s1">leaves_color_list</span>


<span class="s3">def </span><span class="s1">_append_singleton_leaf_node</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">p</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">level</span><span class="s4">, </span><span class="s1">lvs</span><span class="s4">, </span><span class="s1">ivl</span><span class="s4">, </span><span class="s1">leaf_label_func</span><span class="s4">,</span>
                                <span class="s1">i</span><span class="s4">, </span><span class="s1">labels</span><span class="s4">):</span>
    <span class="s2"># If the leaf id structure is not None and is a list then the caller</span>
    <span class="s2"># to dendrogram has indicated that cluster id's corresponding to the</span>
    <span class="s2"># leaf nodes should be recorded.</span>

    <span class="s3">if </span><span class="s1">lvs </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">lvs</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">int</span><span class="s4">(</span><span class="s1">i</span><span class="s4">))</span>

    <span class="s2"># If leaf node labels are to be displayed...</span>
    <span class="s3">if </span><span class="s1">ivl </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s2"># If a leaf_label_func has been provided, the label comes from the</span>
        <span class="s2"># string returned from the leaf_label_func, which is a function</span>
        <span class="s2"># passed to dendrogram.</span>
        <span class="s3">if </span><span class="s1">leaf_label_func</span><span class="s4">:</span>
            <span class="s1">ivl</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">leaf_label_func</span><span class="s4">(</span><span class="s1">int</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)))</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># Otherwise, if the dendrogram caller has passed a labels list</span>
            <span class="s2"># for the leaf nodes, use it.</span>
            <span class="s3">if </span><span class="s1">labels </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">ivl</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">[</span><span class="s1">int</span><span class="s4">(</span><span class="s1">i </span><span class="s4">- </span><span class="s1">n</span><span class="s4">)])</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s2"># Otherwise, use the id as the label for the leaf.x</span>
                <span class="s1">ivl</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">str</span><span class="s4">(</span><span class="s1">int</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)))</span>


<span class="s3">def </span><span class="s1">_append_nonsingleton_leaf_node</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">p</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">level</span><span class="s4">, </span><span class="s1">lvs</span><span class="s4">, </span><span class="s1">ivl</span><span class="s4">, </span><span class="s1">leaf_label_func</span><span class="s4">,</span>
                                   <span class="s1">i</span><span class="s4">, </span><span class="s1">labels</span><span class="s4">, </span><span class="s1">show_leaf_counts</span><span class="s4">):</span>
    <span class="s2"># If the leaf id structure is not None and is a list then the caller</span>
    <span class="s2"># to dendrogram has indicated that cluster id's corresponding to the</span>
    <span class="s2"># leaf nodes should be recorded.</span>

    <span class="s3">if </span><span class="s1">lvs </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">lvs</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">int</span><span class="s4">(</span><span class="s1">i</span><span class="s4">))</span>
    <span class="s3">if </span><span class="s1">ivl </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">leaf_label_func</span><span class="s4">:</span>
            <span class="s1">ivl</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">leaf_label_func</span><span class="s4">(</span><span class="s1">int</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)))</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">show_leaf_counts</span><span class="s4">:</span>
                <span class="s1">ivl</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">&quot;(&quot; </span><span class="s4">+ </span><span class="s1">str</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i </span><span class="s4">- </span><span class="s1">n</span><span class="s4">, </span><span class="s6">3</span><span class="s4">], </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">int64</span><span class="s4">)) + </span><span class="s5">&quot;)&quot;</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">ivl</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">&quot;&quot;</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_append_contraction_marks</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">iv</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">contraction_marks</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">):</span>
    <span class="s1">_append_contraction_marks_sub</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">iv</span><span class="s4">, </span><span class="s1">int_floor</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i </span><span class="s4">- </span><span class="s1">n</span><span class="s4">, </span><span class="s6">0</span><span class="s4">], </span><span class="s1">xp</span><span class="s4">),</span>
                                  <span class="s1">n</span><span class="s4">, </span><span class="s1">contraction_marks</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">_append_contraction_marks_sub</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">iv</span><span class="s4">, </span><span class="s1">int_floor</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i </span><span class="s4">- </span><span class="s1">n</span><span class="s4">, </span><span class="s6">1</span><span class="s4">], </span><span class="s1">xp</span><span class="s4">),</span>
                                  <span class="s1">n</span><span class="s4">, </span><span class="s1">contraction_marks</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_append_contraction_marks_sub</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">iv</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">contraction_marks</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">i </span><span class="s4">&gt;= </span><span class="s1">n</span><span class="s4">:</span>
        <span class="s1">contraction_marks</span><span class="s4">.</span><span class="s1">append</span><span class="s4">((</span><span class="s1">iv</span><span class="s4">, </span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i </span><span class="s4">- </span><span class="s1">n</span><span class="s4">, </span><span class="s6">2</span><span class="s4">]))</span>
        <span class="s1">_append_contraction_marks_sub</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">iv</span><span class="s4">, </span><span class="s1">int_floor</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i </span><span class="s4">- </span><span class="s1">n</span><span class="s4">, </span><span class="s6">0</span><span class="s4">], </span><span class="s1">xp</span><span class="s4">),</span>
                                      <span class="s1">n</span><span class="s4">, </span><span class="s1">contraction_marks</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">)</span>
        <span class="s1">_append_contraction_marks_sub</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">iv</span><span class="s4">, </span><span class="s1">int_floor</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i </span><span class="s4">- </span><span class="s1">n</span><span class="s4">, </span><span class="s6">1</span><span class="s4">], </span><span class="s1">xp</span><span class="s4">),</span>
                                      <span class="s1">n</span><span class="s4">, </span><span class="s1">contraction_marks</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_dendrogram_calculate_info</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">p</span><span class="s4">, </span><span class="s1">truncate_mode</span><span class="s4">,</span>
                               <span class="s1">color_threshold</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span><span class="s4">, </span><span class="s1">get_leaves</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                               <span class="s1">orientation</span><span class="s4">=</span><span class="s5">'top'</span><span class="s4">, </span><span class="s1">labels</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
                               <span class="s1">count_sort</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">distance_sort</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                               <span class="s1">show_leaf_counts</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">i</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">, </span><span class="s1">iv</span><span class="s4">=</span><span class="s6">0.0</span><span class="s4">,</span>
                               <span class="s1">ivl</span><span class="s4">=[], </span><span class="s1">n</span><span class="s4">=</span><span class="s6">0</span><span class="s4">, </span><span class="s1">icoord_list</span><span class="s4">=[], </span><span class="s1">dcoord_list</span><span class="s4">=[],</span>
                               <span class="s1">lvs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">mhr</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                               <span class="s1">current_color</span><span class="s4">=[], </span><span class="s1">color_list</span><span class="s4">=[],</span>
                               <span class="s1">currently_below_threshold</span><span class="s4">=[],</span>
                               <span class="s1">leaf_label_func</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">level</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
                               <span class="s1">contraction_marks</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
                               <span class="s1">link_color_func</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
                               <span class="s1">above_threshold_color</span><span class="s4">=</span><span class="s5">'C0'</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate the endpoints of the links as well as the labels for the 
    the dendrogram rooted at the node with index i. iv is the independent 
    variable value to plot the left-most leaf node below the root node i 
    (if orientation='top', this would be the left-most x value where the 
    plotting of this root node i and its descendents should begin). 
 
    ivl is a list to store the labels of the leaf nodes. The leaf_label_func 
    is called whenever ivl != None, labels == None, and 
    leaf_label_func != None. When ivl != None and labels != None, the 
    labels list is used only for labeling the leaf nodes. When 
    ivl == None, no labels are generated for leaf nodes. 
 
    When get_leaves==True, a list of leaves is built as they are visited 
    in the dendrogram. 
 
    Returns a tuple with l being the independent variable coordinate that 
    corresponds to the midpoint of cluster to the left of cluster i if 
    i is non-singleton, otherwise the independent coordinate of the leaf 
    node if i is a leaf node. 
 
    Returns 
    ------- 
    A tuple (left, w, h, md), where: 
        * left is the independent variable coordinate of the center of the 
          the U of the subtree 
 
        * w is the amount of space used for the subtree (in independent 
          variable units) 
 
        * h is the height of the subtree in dependent variable units 
 
        * md is the ``max(Z[*,2]``) for all nodes ``*`` below and including 
          the target node. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">n </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Invalid singleton cluster count n.&quot;</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">i </span><span class="s4">== -</span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Invalid root cluster index i.&quot;</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">truncate_mode </span><span class="s4">== </span><span class="s5">'lastp'</span><span class="s4">:</span>
        <span class="s2"># If the node is a leaf node but corresponds to a non-singleton</span>
        <span class="s2"># cluster, its label is either the empty string or the number of</span>
        <span class="s2"># original observations belonging to cluster i.</span>
        <span class="s3">if </span><span class="s6">2</span><span class="s4">*</span><span class="s1">n </span><span class="s4">- </span><span class="s1">p </span><span class="s4">&gt; </span><span class="s1">i </span><span class="s4">&gt;= </span><span class="s1">n</span><span class="s4">:</span>
            <span class="s1">d </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i </span><span class="s4">- </span><span class="s1">n</span><span class="s4">, </span><span class="s6">2</span><span class="s4">]</span>
            <span class="s1">_append_nonsingleton_leaf_node</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">p</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">level</span><span class="s4">, </span><span class="s1">lvs</span><span class="s4">, </span><span class="s1">ivl</span><span class="s4">,</span>
                                           <span class="s1">leaf_label_func</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">labels</span><span class="s4">,</span>
                                           <span class="s1">show_leaf_counts</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">contraction_marks </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">_append_contraction_marks</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">iv </span><span class="s4">+ </span><span class="s6">5.0</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">contraction_marks</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s4">(</span><span class="s1">iv </span><span class="s4">+ </span><span class="s6">5.0</span><span class="s4">, </span><span class="s6">10.0</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">, </span><span class="s1">d</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">i </span><span class="s4">&lt; </span><span class="s1">n</span><span class="s4">:</span>
            <span class="s1">_append_singleton_leaf_node</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">p</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">level</span><span class="s4">, </span><span class="s1">lvs</span><span class="s4">, </span><span class="s1">ivl</span><span class="s4">,</span>
                                        <span class="s1">leaf_label_func</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">labels</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s4">(</span><span class="s1">iv </span><span class="s4">+ </span><span class="s6">5.0</span><span class="s4">, </span><span class="s6">10.0</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">truncate_mode </span><span class="s4">== </span><span class="s5">'level'</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">i </span><span class="s4">&gt; </span><span class="s1">n </span><span class="s3">and </span><span class="s1">level </span><span class="s4">&gt; </span><span class="s1">p</span><span class="s4">:</span>
            <span class="s1">d </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i </span><span class="s4">- </span><span class="s1">n</span><span class="s4">, </span><span class="s6">2</span><span class="s4">]</span>
            <span class="s1">_append_nonsingleton_leaf_node</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">p</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">level</span><span class="s4">, </span><span class="s1">lvs</span><span class="s4">, </span><span class="s1">ivl</span><span class="s4">,</span>
                                           <span class="s1">leaf_label_func</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">labels</span><span class="s4">,</span>
                                           <span class="s1">show_leaf_counts</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">contraction_marks </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">_append_contraction_marks</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">iv </span><span class="s4">+ </span><span class="s6">5.0</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">contraction_marks</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s4">(</span><span class="s1">iv </span><span class="s4">+ </span><span class="s6">5.0</span><span class="s4">, </span><span class="s6">10.0</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">, </span><span class="s1">d</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">i </span><span class="s4">&lt; </span><span class="s1">n</span><span class="s4">:</span>
            <span class="s1">_append_singleton_leaf_node</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">p</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">level</span><span class="s4">, </span><span class="s1">lvs</span><span class="s4">, </span><span class="s1">ivl</span><span class="s4">,</span>
                                        <span class="s1">leaf_label_func</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">labels</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s4">(</span><span class="s1">iv </span><span class="s4">+ </span><span class="s6">5.0</span><span class="s4">, </span><span class="s6">10.0</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">)</span>

    <span class="s2"># Otherwise, only truncate if we have a leaf node.</span>
    <span class="s2">#</span>
    <span class="s2"># Only place leaves if they correspond to original observations.</span>
    <span class="s3">if </span><span class="s1">i </span><span class="s4">&lt; </span><span class="s1">n</span><span class="s4">:</span>
        <span class="s1">_append_singleton_leaf_node</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">p</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">level</span><span class="s4">, </span><span class="s1">lvs</span><span class="s4">, </span><span class="s1">ivl</span><span class="s4">,</span>
                                    <span class="s1">leaf_label_func</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">labels</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">iv </span><span class="s4">+ </span><span class="s6">5.0</span><span class="s4">, </span><span class="s6">10.0</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">)</span>

    <span class="s2"># !!! Otherwise, we don't have a leaf node, so work on plotting a</span>
    <span class="s2"># non-leaf node.</span>
    <span class="s2"># Actual indices of a and b</span>
    <span class="s1">aa </span><span class="s4">= </span><span class="s1">int_floor</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i </span><span class="s4">- </span><span class="s1">n</span><span class="s4">, </span><span class="s6">0</span><span class="s4">], </span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">ab </span><span class="s4">= </span><span class="s1">int_floor</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i </span><span class="s4">- </span><span class="s1">n</span><span class="s4">, </span><span class="s6">1</span><span class="s4">], </span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">aa </span><span class="s4">&gt;= </span><span class="s1">n</span><span class="s4">:</span>
        <span class="s2"># The number of singletons below cluster a</span>
        <span class="s1">na </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">[</span><span class="s1">aa </span><span class="s4">- </span><span class="s1">n</span><span class="s4">, </span><span class="s6">3</span><span class="s4">]</span>
        <span class="s2"># The distance between a's two direct children.</span>
        <span class="s1">da </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">[</span><span class="s1">aa </span><span class="s4">- </span><span class="s1">n</span><span class="s4">, </span><span class="s6">2</span><span class="s4">]</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">na </span><span class="s4">= </span><span class="s6">1</span>
        <span class="s1">da </span><span class="s4">= </span><span class="s6">0.0</span>
    <span class="s3">if </span><span class="s1">ab </span><span class="s4">&gt;= </span><span class="s1">n</span><span class="s4">:</span>
        <span class="s1">nb </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">[</span><span class="s1">ab </span><span class="s4">- </span><span class="s1">n</span><span class="s4">, </span><span class="s6">3</span><span class="s4">]</span>
        <span class="s1">db </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">[</span><span class="s1">ab </span><span class="s4">- </span><span class="s1">n</span><span class="s4">, </span><span class="s6">2</span><span class="s4">]</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">nb </span><span class="s4">= </span><span class="s6">1</span>
        <span class="s1">db </span><span class="s4">= </span><span class="s6">0.0</span>

    <span class="s3">if </span><span class="s1">count_sort </span><span class="s4">== </span><span class="s5">'ascending' </span><span class="s3">or </span><span class="s1">count_sort </span><span class="s3">is True</span><span class="s4">:</span>
        <span class="s2"># If a has a count greater than b, it and its descendents should</span>
        <span class="s2"># be drawn to the right. Otherwise, to the left.</span>
        <span class="s3">if </span><span class="s1">na </span><span class="s4">&gt; </span><span class="s1">nb</span><span class="s4">:</span>
            <span class="s2"># The cluster index to draw to the left (ua) will be ab</span>
            <span class="s2"># and the one to draw to the right (ub) will be aa</span>
            <span class="s1">ua </span><span class="s4">= </span><span class="s1">ab</span>
            <span class="s1">ub </span><span class="s4">= </span><span class="s1">aa</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">ua </span><span class="s4">= </span><span class="s1">aa</span>
            <span class="s1">ub </span><span class="s4">= </span><span class="s1">ab</span>
    <span class="s3">elif </span><span class="s1">count_sort </span><span class="s4">== </span><span class="s5">'descending'</span><span class="s4">:</span>
        <span class="s2"># If a has a count less than or equal to b, it and its</span>
        <span class="s2"># descendents should be drawn to the left. Otherwise, to</span>
        <span class="s2"># the right.</span>
        <span class="s3">if </span><span class="s1">na </span><span class="s4">&gt; </span><span class="s1">nb</span><span class="s4">:</span>
            <span class="s1">ua </span><span class="s4">= </span><span class="s1">aa</span>
            <span class="s1">ub </span><span class="s4">= </span><span class="s1">ab</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">ua </span><span class="s4">= </span><span class="s1">ab</span>
            <span class="s1">ub </span><span class="s4">= </span><span class="s1">aa</span>
    <span class="s3">elif </span><span class="s1">distance_sort </span><span class="s4">== </span><span class="s5">'ascending' </span><span class="s3">or </span><span class="s1">distance_sort </span><span class="s3">is True</span><span class="s4">:</span>
        <span class="s2"># If a has a distance greater than b, it and its descendents should</span>
        <span class="s2"># be drawn to the right. Otherwise, to the left.</span>
        <span class="s3">if </span><span class="s1">da </span><span class="s4">&gt; </span><span class="s1">db</span><span class="s4">:</span>
            <span class="s1">ua </span><span class="s4">= </span><span class="s1">ab</span>
            <span class="s1">ub </span><span class="s4">= </span><span class="s1">aa</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">ua </span><span class="s4">= </span><span class="s1">aa</span>
            <span class="s1">ub </span><span class="s4">= </span><span class="s1">ab</span>
    <span class="s3">elif </span><span class="s1">distance_sort </span><span class="s4">== </span><span class="s5">'descending'</span><span class="s4">:</span>
        <span class="s2"># If a has a distance less than or equal to b, it and its</span>
        <span class="s2"># descendents should be drawn to the left. Otherwise, to</span>
        <span class="s2"># the right.</span>
        <span class="s3">if </span><span class="s1">da </span><span class="s4">&gt; </span><span class="s1">db</span><span class="s4">:</span>
            <span class="s1">ua </span><span class="s4">= </span><span class="s1">aa</span>
            <span class="s1">ub </span><span class="s4">= </span><span class="s1">ab</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">ua </span><span class="s4">= </span><span class="s1">ab</span>
            <span class="s1">ub </span><span class="s4">= </span><span class="s1">aa</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">ua </span><span class="s4">= </span><span class="s1">aa</span>
        <span class="s1">ub </span><span class="s4">= </span><span class="s1">ab</span>

    <span class="s2"># Updated iv variable and the amount of space used.</span>
    <span class="s4">(</span><span class="s1">uiva</span><span class="s4">, </span><span class="s1">uwa</span><span class="s4">, </span><span class="s1">uah</span><span class="s4">, </span><span class="s1">uamd</span><span class="s4">) = </span><span class="s1">\</span>
        <span class="s1">_dendrogram_calculate_info</span><span class="s4">(</span>
            <span class="s1">Z</span><span class="s4">=</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">p</span><span class="s4">=</span><span class="s1">p</span><span class="s4">,</span>
            <span class="s1">truncate_mode</span><span class="s4">=</span><span class="s1">truncate_mode</span><span class="s4">,</span>
            <span class="s1">color_threshold</span><span class="s4">=</span><span class="s1">color_threshold</span><span class="s4">,</span>
            <span class="s1">get_leaves</span><span class="s4">=</span><span class="s1">get_leaves</span><span class="s4">,</span>
            <span class="s1">orientation</span><span class="s4">=</span><span class="s1">orientation</span><span class="s4">,</span>
            <span class="s1">labels</span><span class="s4">=</span><span class="s1">labels</span><span class="s4">,</span>
            <span class="s1">count_sort</span><span class="s4">=</span><span class="s1">count_sort</span><span class="s4">,</span>
            <span class="s1">distance_sort</span><span class="s4">=</span><span class="s1">distance_sort</span><span class="s4">,</span>
            <span class="s1">show_leaf_counts</span><span class="s4">=</span><span class="s1">show_leaf_counts</span><span class="s4">,</span>
            <span class="s1">i</span><span class="s4">=</span><span class="s1">ua</span><span class="s4">, </span><span class="s1">iv</span><span class="s4">=</span><span class="s1">iv</span><span class="s4">, </span><span class="s1">ivl</span><span class="s4">=</span><span class="s1">ivl</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s1">n</span><span class="s4">,</span>
            <span class="s1">icoord_list</span><span class="s4">=</span><span class="s1">icoord_list</span><span class="s4">,</span>
            <span class="s1">dcoord_list</span><span class="s4">=</span><span class="s1">dcoord_list</span><span class="s4">, </span><span class="s1">lvs</span><span class="s4">=</span><span class="s1">lvs</span><span class="s4">,</span>
            <span class="s1">current_color</span><span class="s4">=</span><span class="s1">current_color</span><span class="s4">,</span>
            <span class="s1">color_list</span><span class="s4">=</span><span class="s1">color_list</span><span class="s4">,</span>
            <span class="s1">currently_below_threshold</span><span class="s4">=</span><span class="s1">currently_below_threshold</span><span class="s4">,</span>
            <span class="s1">leaf_label_func</span><span class="s4">=</span><span class="s1">leaf_label_func</span><span class="s4">,</span>
            <span class="s1">level</span><span class="s4">=</span><span class="s1">level </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">, </span><span class="s1">contraction_marks</span><span class="s4">=</span><span class="s1">contraction_marks</span><span class="s4">,</span>
            <span class="s1">link_color_func</span><span class="s4">=</span><span class="s1">link_color_func</span><span class="s4">,</span>
            <span class="s1">above_threshold_color</span><span class="s4">=</span><span class="s1">above_threshold_color</span><span class="s4">)</span>

    <span class="s1">h </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">[</span><span class="s1">i </span><span class="s4">- </span><span class="s1">n</span><span class="s4">, </span><span class="s6">2</span><span class="s4">]</span>
    <span class="s3">if </span><span class="s1">h </span><span class="s4">&gt;= </span><span class="s1">color_threshold </span><span class="s3">or </span><span class="s1">color_threshold </span><span class="s4">&lt;= </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s1">c </span><span class="s4">= </span><span class="s1">above_threshold_color</span>

        <span class="s3">if </span><span class="s1">currently_below_threshold</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
            <span class="s1">current_color</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] = (</span><span class="s1">current_color</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1</span><span class="s4">) % </span><span class="s1">len</span><span class="s4">(</span><span class="s1">_link_line_colors</span><span class="s4">)</span>
        <span class="s1">currently_below_threshold</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] = </span><span class="s3">False</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">currently_below_threshold</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] = </span><span class="s3">True</span>
        <span class="s1">c </span><span class="s4">= </span><span class="s1">_link_line_colors</span><span class="s4">[</span><span class="s1">current_color</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]]</span>

    <span class="s4">(</span><span class="s1">uivb</span><span class="s4">, </span><span class="s1">uwb</span><span class="s4">, </span><span class="s1">ubh</span><span class="s4">, </span><span class="s1">ubmd</span><span class="s4">) = </span><span class="s1">\</span>
        <span class="s1">_dendrogram_calculate_info</span><span class="s4">(</span>
            <span class="s1">Z</span><span class="s4">=</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">p</span><span class="s4">=</span><span class="s1">p</span><span class="s4">,</span>
            <span class="s1">truncate_mode</span><span class="s4">=</span><span class="s1">truncate_mode</span><span class="s4">,</span>
            <span class="s1">color_threshold</span><span class="s4">=</span><span class="s1">color_threshold</span><span class="s4">,</span>
            <span class="s1">get_leaves</span><span class="s4">=</span><span class="s1">get_leaves</span><span class="s4">,</span>
            <span class="s1">orientation</span><span class="s4">=</span><span class="s1">orientation</span><span class="s4">,</span>
            <span class="s1">labels</span><span class="s4">=</span><span class="s1">labels</span><span class="s4">,</span>
            <span class="s1">count_sort</span><span class="s4">=</span><span class="s1">count_sort</span><span class="s4">,</span>
            <span class="s1">distance_sort</span><span class="s4">=</span><span class="s1">distance_sort</span><span class="s4">,</span>
            <span class="s1">show_leaf_counts</span><span class="s4">=</span><span class="s1">show_leaf_counts</span><span class="s4">,</span>
            <span class="s1">i</span><span class="s4">=</span><span class="s1">ub</span><span class="s4">, </span><span class="s1">iv</span><span class="s4">=</span><span class="s1">iv </span><span class="s4">+ </span><span class="s1">uwa</span><span class="s4">, </span><span class="s1">ivl</span><span class="s4">=</span><span class="s1">ivl</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s1">n</span><span class="s4">,</span>
            <span class="s1">icoord_list</span><span class="s4">=</span><span class="s1">icoord_list</span><span class="s4">,</span>
            <span class="s1">dcoord_list</span><span class="s4">=</span><span class="s1">dcoord_list</span><span class="s4">, </span><span class="s1">lvs</span><span class="s4">=</span><span class="s1">lvs</span><span class="s4">,</span>
            <span class="s1">current_color</span><span class="s4">=</span><span class="s1">current_color</span><span class="s4">,</span>
            <span class="s1">color_list</span><span class="s4">=</span><span class="s1">color_list</span><span class="s4">,</span>
            <span class="s1">currently_below_threshold</span><span class="s4">=</span><span class="s1">currently_below_threshold</span><span class="s4">,</span>
            <span class="s1">leaf_label_func</span><span class="s4">=</span><span class="s1">leaf_label_func</span><span class="s4">,</span>
            <span class="s1">level</span><span class="s4">=</span><span class="s1">level </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">, </span><span class="s1">contraction_marks</span><span class="s4">=</span><span class="s1">contraction_marks</span><span class="s4">,</span>
            <span class="s1">link_color_func</span><span class="s4">=</span><span class="s1">link_color_func</span><span class="s4">,</span>
            <span class="s1">above_threshold_color</span><span class="s4">=</span><span class="s1">above_threshold_color</span><span class="s4">)</span>

    <span class="s1">max_dist </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s1">uamd</span><span class="s4">, </span><span class="s1">ubmd</span><span class="s4">, </span><span class="s1">h</span><span class="s4">)</span>

    <span class="s1">icoord_list</span><span class="s4">.</span><span class="s1">append</span><span class="s4">([</span><span class="s1">uiva</span><span class="s4">, </span><span class="s1">uiva</span><span class="s4">, </span><span class="s1">uivb</span><span class="s4">, </span><span class="s1">uivb</span><span class="s4">])</span>
    <span class="s1">dcoord_list</span><span class="s4">.</span><span class="s1">append</span><span class="s4">([</span><span class="s1">uah</span><span class="s4">, </span><span class="s1">h</span><span class="s4">, </span><span class="s1">h</span><span class="s4">, </span><span class="s1">ubh</span><span class="s4">])</span>
    <span class="s3">if </span><span class="s1">link_color_func </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">v </span><span class="s4">= </span><span class="s1">link_color_func</span><span class="s4">(</span><span class="s1">int</span><span class="s4">(</span><span class="s1">i</span><span class="s4">))</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">v</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;link_color_func must return a matplotlib &quot;</span>
                            <span class="s5">&quot;color string!&quot;</span><span class="s4">)</span>
        <span class="s1">color_list</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">v</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">color_list</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s4">(((</span><span class="s1">uiva </span><span class="s4">+ </span><span class="s1">uivb</span><span class="s4">) / </span><span class="s6">2</span><span class="s4">), </span><span class="s1">uwa </span><span class="s4">+ </span><span class="s1">uwb</span><span class="s4">, </span><span class="s1">h</span><span class="s4">, </span><span class="s1">max_dist</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">is_isomorphic</span><span class="s4">(</span><span class="s1">T1</span><span class="s4">, </span><span class="s1">T2</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Determine if two different cluster assignments are equivalent. 
 
    Parameters 
    ---------- 
    T1 : array_like 
        An assignment of singleton cluster ids to flat cluster ids. 
    T2 : array_like 
        An assignment of singleton cluster ids to flat cluster ids. 
 
    Returns 
    ------- 
    b : bool 
        Whether the flat cluster assignments `T1` and `T2` are 
        equivalent. 
 
    See Also 
    -------- 
    linkage : for a description of what a linkage matrix is. 
    fcluster : for the creation of flat cluster assignments. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import fcluster, is_isomorphic 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import single, complete 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    Two flat cluster assignments can be isomorphic if they represent the same 
    cluster assignment, with different labels. 
 
    For example, we can use the `scipy.cluster.hierarchy.single`: method 
    and flatten the output to four clusters: 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    &gt;&gt;&gt; Z = single(pdist(X)) 
    &gt;&gt;&gt; T = fcluster(Z, 1, criterion='distance') 
    &gt;&gt;&gt; T 
    array([3, 3, 3, 4, 4, 4, 2, 2, 2, 1, 1, 1], dtype=int32) 
 
    We can then do the same using the 
    `scipy.cluster.hierarchy.complete`: method: 
 
    &gt;&gt;&gt; Z = complete(pdist(X)) 
    &gt;&gt;&gt; T_ = fcluster(Z, 1.5, criterion='distance') 
    &gt;&gt;&gt; T_ 
    array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32) 
 
    As we can see, in both cases we obtain four clusters and all the data 
    points are distributed in the same way - the only thing that changes 
    are the flat cluster labels (3 =&gt; 1, 4 =&gt;2, 2 =&gt;3 and 4 =&gt;1), so both 
    cluster assignments are isomorphic: 
 
    &gt;&gt;&gt; is_isomorphic(T, T_) 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s1">T1 </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">T1</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'c'</span><span class="s4">)</span>
    <span class="s1">T2 </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">T2</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'c'</span><span class="s4">)</span>

    <span class="s1">T1S </span><span class="s4">= </span><span class="s1">T1</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s1">T2S </span><span class="s4">= </span><span class="s1">T2</span><span class="s4">.</span><span class="s1">shape</span>

    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">T1S</span><span class="s4">) != </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'T1 must be one-dimensional.'</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">T2S</span><span class="s4">) != </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'T2 must be one-dimensional.'</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">T1S</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] != </span><span class="s1">T2S</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'T1 and T2 must have the same number of elements.'</span><span class="s4">)</span>
    <span class="s1">n </span><span class="s4">= </span><span class="s1">T1S</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
    <span class="s1">d1 </span><span class="s4">= {}</span>
    <span class="s1">d2 </span><span class="s4">= {}</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">n</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">T1</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] </span><span class="s3">in </span><span class="s1">d1</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">T2</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] </span><span class="s3">not in </span><span class="s1">d2</span><span class="s4">:</span>
                <span class="s3">return False</span>
            <span class="s3">if </span><span class="s1">d1</span><span class="s4">[</span><span class="s1">T1</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]] != </span><span class="s1">T2</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] </span><span class="s3">or </span><span class="s1">d2</span><span class="s4">[</span><span class="s1">T2</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]] != </span><span class="s1">T1</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]:</span>
                <span class="s3">return False</span>
        <span class="s3">elif </span><span class="s1">T2</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] </span><span class="s3">in </span><span class="s1">d2</span><span class="s4">:</span>
            <span class="s3">return False</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">d1</span><span class="s4">[</span><span class="s1">T1</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]] = </span><span class="s1">T2</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
            <span class="s1">d2</span><span class="s4">[</span><span class="s1">T2</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]] = </span><span class="s1">T1</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
    <span class="s3">return True</span>


<span class="s3">def </span><span class="s1">maxdists</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the maximum distance between any non-singleton cluster. 
 
    Parameters 
    ---------- 
    Z : ndarray 
        The hierarchical clustering encoded as a matrix. See 
        ``linkage`` for more information. 
 
    Returns 
    ------- 
    maxdists : ndarray 
        A ``(n-1)`` sized numpy array of doubles; ``MD[i]`` represents 
        the maximum distance between any cluster (including 
        singletons) below and including the node with index i. More 
        specifically, ``MD[i] = Z[Q(i)-n, 2].max()`` where ``Q(i)`` is the 
        set of all node indices below and including node i. 
 
    See Also 
    -------- 
    linkage : for a description of what a linkage matrix is. 
    is_monotonic : for testing for monotonicity of a linkage matrix. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import median, maxdists 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    Given a linkage matrix ``Z``, `scipy.cluster.hierarchy.maxdists` 
    computes for each new cluster generated (i.e., for each row of the linkage 
    matrix) what is the maximum distance between any two child clusters. 
 
    Due to the nature of hierarchical clustering, in many cases this is going 
    to be just the distance between the two child clusters that were merged 
    to form the current one - that is, Z[:,2]. 
 
    However, for non-monotonic cluster assignments such as 
    `scipy.cluster.hierarchy.median` clustering this is not always the 
    case: There may be cluster formations were the distance between the two 
    clusters merged is smaller than the distance between their children. 
 
    We can see this in an example: 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    &gt;&gt;&gt; Z = median(pdist(X)) 
    &gt;&gt;&gt; Z 
    array([[ 0.        ,  1.        ,  1.        ,  2.        ], 
           [ 3.        ,  4.        ,  1.        ,  2.        ], 
           [ 9.        , 10.        ,  1.        ,  2.        ], 
           [ 6.        ,  7.        ,  1.        ,  2.        ], 
           [ 2.        , 12.        ,  1.11803399,  3.        ], 
           [ 5.        , 13.        ,  1.11803399,  3.        ], 
           [ 8.        , 15.        ,  1.11803399,  3.        ], 
           [11.        , 14.        ,  1.11803399,  3.        ], 
           [18.        , 19.        ,  3.        ,  6.        ], 
           [16.        , 17.        ,  3.5       ,  6.        ], 
           [20.        , 21.        ,  3.25      , 12.        ]]) 
    &gt;&gt;&gt; maxdists(Z) 
    array([1.        , 1.        , 1.        , 1.        , 1.11803399, 
           1.11803399, 1.11803399, 1.11803399, 3.        , 3.5       , 
           3.5       ]) 
 
    Note that while the distance between the two clusters merged when creating the 
    last cluster is 3.25, there are two children (clusters 16 and 17) whose distance 
    is larger (3.5). Thus, `scipy.cluster.hierarchy.maxdists` returns 3.5 in 
    this case. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">is_valid_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'Z'</span><span class="s4">)</span>

    <span class="s1">n </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1</span>
    <span class="s1">MD </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n </span><span class="s4">- </span><span class="s6">1</span><span class="s4">,))</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">_hierarchy</span><span class="s4">.</span><span class="s1">get_max_dist_for_each_cluster</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">MD</span><span class="s4">, </span><span class="s1">int</span><span class="s4">(</span><span class="s1">n</span><span class="s4">))</span>
    <span class="s1">MD </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">MD</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">MD</span>


<span class="s3">def </span><span class="s1">maxinconsts</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">R</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the maximum inconsistency coefficient for each 
    non-singleton cluster and its children. 
 
    Parameters 
    ---------- 
    Z : ndarray 
        The hierarchical clustering encoded as a matrix. See 
        `linkage` for more information. 
    R : ndarray 
        The inconsistency matrix. 
 
    Returns 
    ------- 
    MI : ndarray 
        A monotonic ``(n-1)``-sized numpy array of doubles. 
 
    See Also 
    -------- 
    linkage : for a description of what a linkage matrix is. 
    inconsistent : for the creation of a inconsistency matrix. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import median, inconsistent, maxinconsts 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    Given a data set ``X``, we can apply a clustering method to obtain a 
    linkage matrix ``Z``. `scipy.cluster.hierarchy.inconsistent` can 
    be also used to obtain the inconsistency matrix ``R`` associated to 
    this clustering process: 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    &gt;&gt;&gt; Z = median(pdist(X)) 
    &gt;&gt;&gt; R = inconsistent(Z) 
    &gt;&gt;&gt; Z 
    array([[ 0.        ,  1.        ,  1.        ,  2.        ], 
           [ 3.        ,  4.        ,  1.        ,  2.        ], 
           [ 9.        , 10.        ,  1.        ,  2.        ], 
           [ 6.        ,  7.        ,  1.        ,  2.        ], 
           [ 2.        , 12.        ,  1.11803399,  3.        ], 
           [ 5.        , 13.        ,  1.11803399,  3.        ], 
           [ 8.        , 15.        ,  1.11803399,  3.        ], 
           [11.        , 14.        ,  1.11803399,  3.        ], 
           [18.        , 19.        ,  3.        ,  6.        ], 
           [16.        , 17.        ,  3.5       ,  6.        ], 
           [20.        , 21.        ,  3.25      , 12.        ]]) 
    &gt;&gt;&gt; R 
    array([[1.        , 0.        , 1.        , 0.        ], 
           [1.        , 0.        , 1.        , 0.        ], 
           [1.        , 0.        , 1.        , 0.        ], 
           [1.        , 0.        , 1.        , 0.        ], 
           [1.05901699, 0.08346263, 2.        , 0.70710678], 
           [1.05901699, 0.08346263, 2.        , 0.70710678], 
           [1.05901699, 0.08346263, 2.        , 0.70710678], 
           [1.05901699, 0.08346263, 2.        , 0.70710678], 
           [1.74535599, 1.08655358, 3.        , 1.15470054], 
           [1.91202266, 1.37522872, 3.        , 1.15470054], 
           [3.25      , 0.25      , 3.        , 0.        ]]) 
 
    Here, `scipy.cluster.hierarchy.maxinconsts` can be used to compute 
    the maximum value of the inconsistency statistic (the last column of 
    ``R``) for each non-singleton cluster and its children: 
 
    &gt;&gt;&gt; maxinconsts(Z, R) 
    array([0.        , 0.        , 0.        , 0.        , 0.70710678, 
           0.70710678, 0.70710678, 0.70710678, 1.15470054, 1.15470054, 
           1.15470054]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">R</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">R </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">R</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">is_valid_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'Z'</span><span class="s4">)</span>
    <span class="s1">is_valid_im</span><span class="s4">(</span><span class="s1">R</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'R'</span><span class="s4">)</span>

    <span class="s1">n </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1</span>
    <span class="s3">if </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] != </span><span class="s1">R</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;The inconsistency matrix and linkage matrix each &quot;</span>
                         <span class="s5">&quot;have a different number of rows.&quot;</span><span class="s4">)</span>
    <span class="s1">MI </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n </span><span class="s4">- </span><span class="s6">1</span><span class="s4">,))</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">R </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">R</span><span class="s4">)</span>
    <span class="s1">_hierarchy</span><span class="s4">.</span><span class="s1">get_max_Rfield_for_each_cluster</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">R</span><span class="s4">, </span><span class="s1">MI</span><span class="s4">, </span><span class="s1">int</span><span class="s4">(</span><span class="s1">n</span><span class="s4">), </span><span class="s6">3</span><span class="s4">)</span>
    <span class="s1">MI </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">MI</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">MI</span>


<span class="s3">def </span><span class="s1">maxRstat</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">R</span><span class="s4">, </span><span class="s1">i</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the maximum statistic for each non-singleton cluster and its 
    children. 
 
    Parameters 
    ---------- 
    Z : array_like 
        The hierarchical clustering encoded as a matrix. See `linkage` for more 
        information. 
    R : array_like 
        The inconsistency matrix. 
    i : int 
        The column of `R` to use as the statistic. 
 
    Returns 
    ------- 
    MR : ndarray 
        Calculates the maximum statistic for the i'th column of the 
        inconsistency matrix `R` for each non-singleton cluster 
        node. ``MR[j]`` is the maximum over ``R[Q(j)-n, i]``, where 
        ``Q(j)`` the set of all node ids corresponding to nodes below 
        and including ``j``. 
 
    See Also 
    -------- 
    linkage : for a description of what a linkage matrix is. 
    inconsistent : for the creation of a inconsistency matrix. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import median, inconsistent, maxRstat 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    Given a data set ``X``, we can apply a clustering method to obtain a 
    linkage matrix ``Z``. `scipy.cluster.hierarchy.inconsistent` can 
    be also used to obtain the inconsistency matrix ``R`` associated to 
    this clustering process: 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    &gt;&gt;&gt; Z = median(pdist(X)) 
    &gt;&gt;&gt; R = inconsistent(Z) 
    &gt;&gt;&gt; R 
    array([[1.        , 0.        , 1.        , 0.        ], 
           [1.        , 0.        , 1.        , 0.        ], 
           [1.        , 0.        , 1.        , 0.        ], 
           [1.        , 0.        , 1.        , 0.        ], 
           [1.05901699, 0.08346263, 2.        , 0.70710678], 
           [1.05901699, 0.08346263, 2.        , 0.70710678], 
           [1.05901699, 0.08346263, 2.        , 0.70710678], 
           [1.05901699, 0.08346263, 2.        , 0.70710678], 
           [1.74535599, 1.08655358, 3.        , 1.15470054], 
           [1.91202266, 1.37522872, 3.        , 1.15470054], 
           [3.25      , 0.25      , 3.        , 0.        ]]) 
 
    `scipy.cluster.hierarchy.maxRstat` can be used to compute 
    the maximum value of each column of ``R``, for each non-singleton 
    cluster and its children: 
 
    &gt;&gt;&gt; maxRstat(Z, R, 0) 
    array([1.        , 1.        , 1.        , 1.        , 1.05901699, 
           1.05901699, 1.05901699, 1.05901699, 1.74535599, 1.91202266, 
           3.25      ]) 
    &gt;&gt;&gt; maxRstat(Z, R, 1) 
    array([0.        , 0.        , 0.        , 0.        , 0.08346263, 
           0.08346263, 0.08346263, 0.08346263, 1.08655358, 1.37522872, 
           1.37522872]) 
    &gt;&gt;&gt; maxRstat(Z, R, 3) 
    array([0.        , 0.        , 0.        , 0.        , 0.70710678, 
           0.70710678, 0.70710678, 0.70710678, 1.15470054, 1.15470054, 
           1.15470054]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">R</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">R </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">R</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">is_valid_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'Z'</span><span class="s4">)</span>
    <span class="s1">is_valid_im</span><span class="s4">(</span><span class="s1">R</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'R'</span><span class="s4">)</span>

    <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">i</span><span class="s4">, </span><span class="s1">int</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">'The third argument must be an integer.'</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">i </span><span class="s4">&lt; </span><span class="s6">0 </span><span class="s3">or </span><span class="s1">i </span><span class="s4">&gt; </span><span class="s6">3</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'i must be an integer between 0 and 3 inclusive.'</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] != </span><span class="s1">R</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;The inconsistency matrix and linkage matrix each &quot;</span>
                         <span class="s5">&quot;have a different number of rows.&quot;</span><span class="s4">)</span>

    <span class="s1">n </span><span class="s4">= </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1</span>
    <span class="s1">MR </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n </span><span class="s4">- </span><span class="s6">1</span><span class="s4">,))</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">R </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">R</span><span class="s4">)</span>
    <span class="s1">_hierarchy</span><span class="s4">.</span><span class="s1">get_max_Rfield_for_each_cluster</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">R</span><span class="s4">, </span><span class="s1">MR</span><span class="s4">, </span><span class="s1">int</span><span class="s4">(</span><span class="s1">n</span><span class="s4">), </span><span class="s1">i</span><span class="s4">)</span>
    <span class="s1">MR </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">MR</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">MR</span>


<span class="s3">def </span><span class="s1">leaders</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">T</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the root nodes in a hierarchical clustering. 
 
    Returns the root nodes in a hierarchical clustering corresponding 
    to a cut defined by a flat cluster assignment vector ``T``. See 
    the ``fcluster`` function for more information on the format of ``T``. 
 
    For each flat cluster :math:`j` of the :math:`k` flat clusters 
    represented in the n-sized flat cluster assignment vector ``T``, 
    this function finds the lowest cluster node :math:`i` in the linkage 
    tree Z, such that: 
 
      * leaf descendants belong only to flat cluster j 
        (i.e., ``T[p]==j`` for all :math:`p` in :math:`S(i)`, where 
        :math:`S(i)` is the set of leaf ids of descendant leaf nodes 
        with cluster node :math:`i`) 
 
      * there does not exist a leaf that is not a descendant with 
        :math:`i` that also belongs to cluster :math:`j` 
        (i.e., ``T[q]!=j`` for all :math:`q` not in :math:`S(i)`). If 
        this condition is violated, ``T`` is not a valid cluster 
        assignment vector, and an exception will be thrown. 
 
    Parameters 
    ---------- 
    Z : ndarray 
        The hierarchical clustering encoded as a matrix. See 
        `linkage` for more information. 
    T : ndarray 
        The flat cluster assignment vector. 
 
    Returns 
    ------- 
    L : ndarray 
        The leader linkage node id's stored as a k-element 1-D array, 
        where ``k`` is the number of flat clusters found in ``T``. 
 
        ``L[j]=i`` is the linkage cluster node id that is the 
        leader of flat cluster with id M[j]. If ``i &lt; n``, ``i`` 
        corresponds to an original observation, otherwise it 
        corresponds to a non-singleton cluster. 
    M : ndarray 
        The leader linkage node id's stored as a k-element 1-D array, where 
        ``k`` is the number of flat clusters found in ``T``. This allows the 
        set of flat cluster ids to be any arbitrary set of ``k`` integers. 
 
        For example: if ``L[3]=2`` and ``M[3]=8``, the flat cluster with 
        id 8's leader is linkage node 2. 
 
    See Also 
    -------- 
    fcluster : for the creation of flat cluster assignments. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.cluster.hierarchy import ward, fcluster, leaders 
    &gt;&gt;&gt; from scipy.spatial.distance import pdist 
 
    Given a linkage matrix ``Z`` - obtained after apply a clustering method 
    to a dataset ``X`` - and a flat cluster assignment array ``T``: 
 
    &gt;&gt;&gt; X = [[0, 0], [0, 1], [1, 0], 
    ...      [0, 4], [0, 3], [1, 4], 
    ...      [4, 0], [3, 0], [4, 1], 
    ...      [4, 4], [3, 4], [4, 3]] 
 
    &gt;&gt;&gt; Z = ward(pdist(X)) 
    &gt;&gt;&gt; Z 
    array([[ 0.        ,  1.        ,  1.        ,  2.        ], 
           [ 3.        ,  4.        ,  1.        ,  2.        ], 
           [ 6.        ,  7.        ,  1.        ,  2.        ], 
           [ 9.        , 10.        ,  1.        ,  2.        ], 
           [ 2.        , 12.        ,  1.29099445,  3.        ], 
           [ 5.        , 13.        ,  1.29099445,  3.        ], 
           [ 8.        , 14.        ,  1.29099445,  3.        ], 
           [11.        , 15.        ,  1.29099445,  3.        ], 
           [16.        , 17.        ,  5.77350269,  6.        ], 
           [18.        , 19.        ,  5.77350269,  6.        ], 
           [20.        , 21.        ,  8.16496581, 12.        ]]) 
 
    &gt;&gt;&gt; T = fcluster(Z, 3, criterion='distance') 
    &gt;&gt;&gt; T 
    array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4], dtype=int32) 
 
    `scipy.cluster.hierarchy.leaders` returns the indices of the nodes 
    in the dendrogram that are the leaders of each flat cluster: 
 
    &gt;&gt;&gt; L, M = leaders(Z, T) 
    &gt;&gt;&gt; L 
    array([16, 17, 18, 19], dtype=int32) 
 
    (remember that indices 0-11 point to the 12 data points in ``X``, 
    whereas indices 12-22 point to the 11 rows of ``Z``) 
 
    `scipy.cluster.hierarchy.leaders` also returns the indices of 
    the flat clusters in ``T``: 
 
    &gt;&gt;&gt; M 
    array([1, 2, 3, 4], dtype=int32) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">T</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">T </span><span class="s4">= </span><span class="s1">_asarray</span><span class="s4">(</span><span class="s1">T</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">is_valid_linkage</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">throw</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">name</span><span class="s4">=</span><span class="s5">'Z'</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">T</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">!= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">int32</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">'T must be a 1-D array of dtype int32.'</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">T</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] != </span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Mismatch: len(T)!=Z.shape[0] + 1.'</span><span class="s4">)</span>

    <span class="s1">n_clusters </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">unique_values</span><span class="s4">(</span><span class="s1">T</span><span class="s4">).</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])</span>
    <span class="s1">n_obs </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] + </span><span class="s6">1</span><span class="s4">)</span>
    <span class="s1">L </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_clusters</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">int32</span><span class="s4">)</span>
    <span class="s1">M </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_clusters</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">int32</span><span class="s4">)</span>
    <span class="s1">Z </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">)</span>
    <span class="s1">T </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">T</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">int32</span><span class="s4">)</span>
    <span class="s1">s </span><span class="s4">= </span><span class="s1">_hierarchy</span><span class="s4">.</span><span class="s1">leaders</span><span class="s4">(</span><span class="s1">Z</span><span class="s4">, </span><span class="s1">T</span><span class="s4">, </span><span class="s1">L</span><span class="s4">, </span><span class="s1">M</span><span class="s4">, </span><span class="s1">n_clusters</span><span class="s4">, </span><span class="s1">n_obs</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">s </span><span class="s4">&gt;= </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">((</span><span class="s5">'T is not a valid assignment vector. Error found '</span>
                          <span class="s5">'when examining linkage node %d (&lt; 2n-1).'</span><span class="s4">) % </span><span class="s1">s</span><span class="s4">)</span>
    <span class="s1">L</span><span class="s4">, </span><span class="s1">M </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">L</span><span class="s4">), </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">M</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">L</span><span class="s4">, </span><span class="s1">M</span><span class="s4">)</span>
</pre>
</body>
</html>