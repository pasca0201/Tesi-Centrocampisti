<html>
<head>
<title>iterative.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #2aacb8;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
iterative.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">_interface </span><span class="s0">import </span><span class="s1">LinearOperator</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">utils </span><span class="s0">import </span><span class="s1">make_system</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">linalg </span><span class="s0">import </span><span class="s1">get_lapack_funcs</span>

<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">'bicg'</span><span class="s2">, </span><span class="s3">'bicgstab'</span><span class="s2">, </span><span class="s3">'cg'</span><span class="s2">, </span><span class="s3">'cgs'</span><span class="s2">, </span><span class="s3">'gmres'</span><span class="s2">, </span><span class="s3">'qmr'</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">_get_atol_rtol</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">b_norm</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s4">1e-5</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    A helper function to handle tolerance normalization 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">atol </span><span class="s2">== </span><span class="s3">'legacy' </span><span class="s0">or </span><span class="s1">atol </span><span class="s0">is None or </span><span class="s1">atol </span><span class="s2">&lt; </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= (</span><span class="s3">f&quot;'scipy.sparse.linalg.</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s3">' called with invalid `atol`=</span><span class="s0">{</span><span class="s1">atol</span><span class="s0">}</span><span class="s3">; &quot;</span>
               <span class="s3">&quot;if set, `atol` must be a real, non-negative number.&quot;</span><span class="s2">)</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

    <span class="s1">atol </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">float</span><span class="s2">(</span><span class="s1">atol</span><span class="s2">), </span><span class="s1">float</span><span class="s2">(</span><span class="s1">rtol</span><span class="s2">) * </span><span class="s1">float</span><span class="s2">(</span><span class="s1">b_norm</span><span class="s2">))</span>

    <span class="s0">return </span><span class="s1">atol</span><span class="s2">, </span><span class="s1">rtol</span>


<span class="s0">def </span><span class="s1">bicg</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">M</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Use BIConjugate Gradient iteration to solve ``Ax = b``. 
 
    Parameters 
    ---------- 
    A : {sparse matrix, ndarray, LinearOperator} 
        The real or complex N-by-N matrix of the linear system. 
        Alternatively, ``A`` can be a linear operator which can 
        produce ``Ax`` and ``A^T x`` using, e.g., 
        ``scipy.sparse.linalg.LinearOperator``. 
    b : ndarray 
        Right hand side of the linear system. Has shape (N,) or (N,1). 
    x0 : ndarray 
        Starting guess for the solution. 
    rtol, atol : float, optional 
        Parameters for the convergence test. For convergence, 
        ``norm(b - A @ x) &lt;= max(rtol*norm(b), atol)`` should be satisfied. 
        The default is ``atol=0.`` and ``rtol=1e-5``. 
    maxiter : integer 
        Maximum number of iterations.  Iteration will stop after maxiter 
        steps even if the specified tolerance has not been achieved. 
    M : {sparse matrix, ndarray, LinearOperator} 
        Preconditioner for A.  The preconditioner should approximate the 
        inverse of A.  Effective preconditioning dramatically improves the 
        rate of convergence, which implies that fewer iterations are needed 
        to reach a given error tolerance. 
    callback : function 
        User-supplied function to call after each iteration.  It is called 
        as callback(xk), where xk is the current solution vector. 
 
    Returns 
    ------- 
    x : ndarray 
        The converged solution. 
    info : integer 
        Provides convergence information: 
            0  : successful exit 
            &gt;0 : convergence to tolerance not achieved, number of iterations 
            &lt;0 : parameter breakdown 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import csc_matrix 
    &gt;&gt;&gt; from scipy.sparse.linalg import bicg 
    &gt;&gt;&gt; A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1.]]) 
    &gt;&gt;&gt; b = np.array([2., 4., -1.]) 
    &gt;&gt;&gt; x, exitCode = bicg(A, b, atol=1e-5) 
    &gt;&gt;&gt; print(exitCode)  # 0 indicates successful convergence 
    0 
    &gt;&gt;&gt; np.allclose(A.dot(x), b) 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s1">A</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">postprocess </span><span class="s2">= </span><span class="s1">make_system</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
    <span class="s1">bnrm2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>

    <span class="s1">atol</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_get_atol_rtol</span><span class="s2">(</span><span class="s3">'bicg'</span><span class="s2">, </span><span class="s1">bnrm2</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">bnrm2 </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">b</span><span class="s2">), </span><span class="s4">0</span>

    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>
    <span class="s1">dotprod </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">vdot </span><span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">else </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span>

    <span class="s0">if </span><span class="s1">maxiter </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">n</span><span class="s2">*</span><span class="s4">10</span>

    <span class="s1">matvec</span><span class="s2">, </span><span class="s1">rmatvec </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">matvec</span><span class="s2">, </span><span class="s1">A</span><span class="s2">.</span><span class="s1">rmatvec</span>
    <span class="s1">psolve</span><span class="s2">, </span><span class="s1">rpsolve </span><span class="s2">= </span><span class="s1">M</span><span class="s2">.</span><span class="s1">matvec</span><span class="s2">, </span><span class="s1">M</span><span class="s2">.</span><span class="s1">rmatvec</span>

    <span class="s1">rhotol </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">).</span><span class="s1">eps</span><span class="s2">**</span><span class="s4">2</span>

    <span class="s6"># Dummy values to initialize vars, silence linter warnings</span>
    <span class="s1">rho_prev</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">ptilde </span><span class="s2">= </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span>

    <span class="s1">r </span><span class="s2">= </span><span class="s1">b </span><span class="s2">- </span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">any</span><span class="s2">() </span><span class="s0">else </span><span class="s1">b</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
    <span class="s1">rtilde </span><span class="s2">= </span><span class="s1">r</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

    <span class="s0">for </span><span class="s1">iteration </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">r</span><span class="s2">) &lt; </span><span class="s1">atol</span><span class="s2">:  </span><span class="s6"># Are we done?</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s4">0</span>

        <span class="s1">z </span><span class="s2">= </span><span class="s1">psolve</span><span class="s2">(</span><span class="s1">r</span><span class="s2">)</span>
        <span class="s1">ztilde </span><span class="s2">= </span><span class="s1">rpsolve</span><span class="s2">(</span><span class="s1">rtilde</span><span class="s2">)</span>
        <span class="s6"># order matters in this dot product</span>
        <span class="s1">rho_cur </span><span class="s2">= </span><span class="s1">dotprod</span><span class="s2">(</span><span class="s1">rtilde</span><span class="s2">, </span><span class="s1">z</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">rho_cur</span><span class="s2">) &lt; </span><span class="s1">rhotol</span><span class="s2">:  </span><span class="s6"># Breakdown case</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">, -</span><span class="s4">10</span>

        <span class="s0">if </span><span class="s1">iteration </span><span class="s2">&gt; </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s1">beta </span><span class="s2">= </span><span class="s1">rho_cur </span><span class="s2">/ </span><span class="s1">rho_prev</span>
            <span class="s1">p </span><span class="s2">*= </span><span class="s1">beta</span>
            <span class="s1">p </span><span class="s2">+= </span><span class="s1">z</span>
            <span class="s1">ptilde </span><span class="s2">*= </span><span class="s1">beta</span><span class="s2">.</span><span class="s1">conj</span><span class="s2">()</span>
            <span class="s1">ptilde </span><span class="s2">+= </span><span class="s1">ztilde</span>
        <span class="s0">else</span><span class="s2">:  </span><span class="s6"># First spin</span>
            <span class="s1">p </span><span class="s2">= </span><span class="s1">z</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s1">ptilde </span><span class="s2">= </span><span class="s1">ztilde</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

        <span class="s1">q </span><span class="s2">= </span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>
        <span class="s1">qtilde </span><span class="s2">= </span><span class="s1">rmatvec</span><span class="s2">(</span><span class="s1">ptilde</span><span class="s2">)</span>
        <span class="s1">rv </span><span class="s2">= </span><span class="s1">dotprod</span><span class="s2">(</span><span class="s1">ptilde</span><span class="s2">, </span><span class="s1">q</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">rv </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), -</span><span class="s4">11</span>

        <span class="s1">alpha </span><span class="s2">= </span><span class="s1">rho_cur </span><span class="s2">/ </span><span class="s1">rv</span>
        <span class="s1">x </span><span class="s2">+= </span><span class="s1">alpha</span><span class="s2">*</span><span class="s1">p</span>
        <span class="s1">r </span><span class="s2">-= </span><span class="s1">alpha</span><span class="s2">*</span><span class="s1">q</span>
        <span class="s1">rtilde </span><span class="s2">-= </span><span class="s1">alpha</span><span class="s2">.</span><span class="s1">conj</span><span class="s2">()*</span><span class="s1">qtilde</span>
        <span class="s1">rho_prev </span><span class="s2">= </span><span class="s1">rho_cur</span>

        <span class="s0">if </span><span class="s1">callback</span><span class="s2">:</span>
            <span class="s1">callback</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s0">else</span><span class="s2">:  </span><span class="s6"># for loop exhausted</span>
        <span class="s6"># Return incomplete progress</span>
        <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s1">maxiter</span>


<span class="s0">def </span><span class="s1">bicgstab</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">M</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
             <span class="s1">callback</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Use BIConjugate Gradient STABilized iteration to solve ``Ax = b``. 
 
    Parameters 
    ---------- 
    A : {sparse matrix, ndarray, LinearOperator} 
        The real or complex N-by-N matrix of the linear system. 
        Alternatively, ``A`` can be a linear operator which can 
        produce ``Ax`` and ``A^T x`` using, e.g., 
        ``scipy.sparse.linalg.LinearOperator``. 
    b : ndarray 
        Right hand side of the linear system. Has shape (N,) or (N,1). 
    x0 : ndarray 
        Starting guess for the solution. 
    rtol, atol : float, optional 
        Parameters for the convergence test. For convergence, 
        ``norm(b - A @ x) &lt;= max(rtol*norm(b), atol)`` should be satisfied. 
        The default is ``atol=0.`` and ``rtol=1e-5``. 
    maxiter : integer 
        Maximum number of iterations.  Iteration will stop after maxiter 
        steps even if the specified tolerance has not been achieved. 
    M : {sparse matrix, ndarray, LinearOperator} 
        Preconditioner for A.  The preconditioner should approximate the 
        inverse of A.  Effective preconditioning dramatically improves the 
        rate of convergence, which implies that fewer iterations are needed 
        to reach a given error tolerance. 
    callback : function 
        User-supplied function to call after each iteration.  It is called 
        as callback(xk), where xk is the current solution vector. 
 
    Returns 
    ------- 
    x : ndarray 
        The converged solution. 
    info : integer 
        Provides convergence information: 
            0  : successful exit 
            &gt;0 : convergence to tolerance not achieved, number of iterations 
            &lt;0 : parameter breakdown 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import csc_matrix 
    &gt;&gt;&gt; from scipy.sparse.linalg import bicgstab 
    &gt;&gt;&gt; R = np.array([[4, 2, 0, 1], 
    ...               [3, 0, 0, 2], 
    ...               [0, 1, 1, 1], 
    ...               [0, 2, 1, 0]]) 
    &gt;&gt;&gt; A = csc_matrix(R) 
    &gt;&gt;&gt; b = np.array([-1, -0.5, -1, 2]) 
    &gt;&gt;&gt; x, exit_code = bicgstab(A, b, atol=1e-5) 
    &gt;&gt;&gt; print(exit_code)  # 0 indicates successful convergence 
    0 
    &gt;&gt;&gt; np.allclose(A.dot(x), b) 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s1">A</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">postprocess </span><span class="s2">= </span><span class="s1">make_system</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
    <span class="s1">bnrm2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>

    <span class="s1">atol</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_get_atol_rtol</span><span class="s2">(</span><span class="s3">'bicgstab'</span><span class="s2">, </span><span class="s1">bnrm2</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">bnrm2 </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">b</span><span class="s2">), </span><span class="s4">0</span>

    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>

    <span class="s1">dotprod </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">vdot </span><span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">else </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span>

    <span class="s0">if </span><span class="s1">maxiter </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">n</span><span class="s2">*</span><span class="s4">10</span>

    <span class="s1">matvec </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">matvec</span>
    <span class="s1">psolve </span><span class="s2">= </span><span class="s1">M</span><span class="s2">.</span><span class="s1">matvec</span>

    <span class="s6"># These values make no sense but coming from original Fortran code</span>
    <span class="s6"># sqrt might have been meant instead.</span>
    <span class="s1">rhotol </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">).</span><span class="s1">eps</span><span class="s2">**</span><span class="s4">2</span>
    <span class="s1">omegatol </span><span class="s2">= </span><span class="s1">rhotol</span>

    <span class="s6"># Dummy values to initialize vars, silence linter warnings</span>
    <span class="s1">rho_prev</span><span class="s2">, </span><span class="s1">omega</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">v </span><span class="s2">= </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span>

    <span class="s1">r </span><span class="s2">= </span><span class="s1">b </span><span class="s2">- </span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">any</span><span class="s2">() </span><span class="s0">else </span><span class="s1">b</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
    <span class="s1">rtilde </span><span class="s2">= </span><span class="s1">r</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

    <span class="s0">for </span><span class="s1">iteration </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">r</span><span class="s2">) &lt; </span><span class="s1">atol</span><span class="s2">:  </span><span class="s6"># Are we done?</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s4">0</span>

        <span class="s1">rho </span><span class="s2">= </span><span class="s1">dotprod</span><span class="s2">(</span><span class="s1">rtilde</span><span class="s2">, </span><span class="s1">r</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">rho</span><span class="s2">) &lt; </span><span class="s1">rhotol</span><span class="s2">:  </span><span class="s6"># rho breakdown</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), -</span><span class="s4">10</span>

        <span class="s0">if </span><span class="s1">iteration </span><span class="s2">&gt; </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">omega</span><span class="s2">) &lt; </span><span class="s1">omegatol</span><span class="s2">:  </span><span class="s6"># omega breakdown</span>
                <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), -</span><span class="s4">11</span>

            <span class="s1">beta </span><span class="s2">= (</span><span class="s1">rho </span><span class="s2">/ </span><span class="s1">rho_prev</span><span class="s2">) * (</span><span class="s1">alpha </span><span class="s2">/ </span><span class="s1">omega</span><span class="s2">)</span>
            <span class="s1">p </span><span class="s2">-= </span><span class="s1">omega</span><span class="s2">*</span><span class="s1">v</span>
            <span class="s1">p </span><span class="s2">*= </span><span class="s1">beta</span>
            <span class="s1">p </span><span class="s2">+= </span><span class="s1">r</span>
        <span class="s0">else</span><span class="s2">:  </span><span class="s6"># First spin</span>
            <span class="s1">s </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">r</span><span class="s2">)</span>
            <span class="s1">p </span><span class="s2">= </span><span class="s1">r</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

        <span class="s1">phat </span><span class="s2">= </span><span class="s1">psolve</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>
        <span class="s1">v </span><span class="s2">= </span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">phat</span><span class="s2">)</span>
        <span class="s1">rv </span><span class="s2">= </span><span class="s1">dotprod</span><span class="s2">(</span><span class="s1">rtilde</span><span class="s2">, </span><span class="s1">v</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">rv </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), -</span><span class="s4">11</span>
        <span class="s1">alpha </span><span class="s2">= </span><span class="s1">rho </span><span class="s2">/ </span><span class="s1">rv</span>
        <span class="s1">r </span><span class="s2">-= </span><span class="s1">alpha</span><span class="s2">*</span><span class="s1">v</span>
        <span class="s1">s</span><span class="s2">[:] = </span><span class="s1">r</span><span class="s2">[:]</span>

        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">s</span><span class="s2">) &lt; </span><span class="s1">atol</span><span class="s2">:</span>
            <span class="s1">x </span><span class="s2">+= </span><span class="s1">alpha</span><span class="s2">*</span><span class="s1">phat</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s4">0</span>

        <span class="s1">shat </span><span class="s2">= </span><span class="s1">psolve</span><span class="s2">(</span><span class="s1">s</span><span class="s2">)</span>
        <span class="s1">t </span><span class="s2">= </span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">shat</span><span class="s2">)</span>
        <span class="s1">omega </span><span class="s2">= </span><span class="s1">dotprod</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">s</span><span class="s2">) / </span><span class="s1">dotprod</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">t</span><span class="s2">)</span>
        <span class="s1">x </span><span class="s2">+= </span><span class="s1">alpha</span><span class="s2">*</span><span class="s1">phat</span>
        <span class="s1">x </span><span class="s2">+= </span><span class="s1">omega</span><span class="s2">*</span><span class="s1">shat</span>
        <span class="s1">r </span><span class="s2">-= </span><span class="s1">omega</span><span class="s2">*</span><span class="s1">t</span>
        <span class="s1">rho_prev </span><span class="s2">= </span><span class="s1">rho</span>

        <span class="s0">if </span><span class="s1">callback</span><span class="s2">:</span>
            <span class="s1">callback</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s0">else</span><span class="s2">:  </span><span class="s6"># for loop exhausted</span>
        <span class="s6"># Return incomplete progress</span>
        <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s1">maxiter</span>


<span class="s0">def </span><span class="s1">cg</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">M</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Use Conjugate Gradient iteration to solve ``Ax = b``. 
 
    Parameters 
    ---------- 
    A : {sparse matrix, ndarray, LinearOperator} 
        The real or complex N-by-N matrix of the linear system. 
        ``A`` must represent a hermitian, positive definite matrix. 
        Alternatively, ``A`` can be a linear operator which can 
        produce ``Ax`` using, e.g., 
        ``scipy.sparse.linalg.LinearOperator``. 
    b : ndarray 
        Right hand side of the linear system. Has shape (N,) or (N,1). 
    x0 : ndarray 
        Starting guess for the solution. 
    rtol, atol : float, optional 
        Parameters for the convergence test. For convergence, 
        ``norm(b - A @ x) &lt;= max(rtol*norm(b), atol)`` should be satisfied. 
        The default is ``atol=0.`` and ``rtol=1e-5``. 
    maxiter : integer 
        Maximum number of iterations.  Iteration will stop after maxiter 
        steps even if the specified tolerance has not been achieved. 
    M : {sparse matrix, ndarray, LinearOperator} 
        Preconditioner for A.  The preconditioner should approximate the 
        inverse of A.  Effective preconditioning dramatically improves the 
        rate of convergence, which implies that fewer iterations are needed 
        to reach a given error tolerance. 
    callback : function 
        User-supplied function to call after each iteration.  It is called 
        as callback(xk), where xk is the current solution vector. 
 
    Returns 
    ------- 
    x : ndarray 
        The converged solution. 
    info : integer 
        Provides convergence information: 
            0  : successful exit 
            &gt;0 : convergence to tolerance not achieved, number of iterations 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import csc_matrix 
    &gt;&gt;&gt; from scipy.sparse.linalg import cg 
    &gt;&gt;&gt; P = np.array([[4, 0, 1, 0], 
    ...               [0, 5, 0, 0], 
    ...               [1, 0, 3, 2], 
    ...               [0, 0, 2, 4]]) 
    &gt;&gt;&gt; A = csc_matrix(P) 
    &gt;&gt;&gt; b = np.array([-1, -0.5, -1, 2]) 
    &gt;&gt;&gt; x, exit_code = cg(A, b, atol=1e-5) 
    &gt;&gt;&gt; print(exit_code)    # 0 indicates successful convergence 
    0 
    &gt;&gt;&gt; np.allclose(A.dot(x), b) 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s1">A</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">postprocess </span><span class="s2">= </span><span class="s1">make_system</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
    <span class="s1">bnrm2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>

    <span class="s1">atol</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_get_atol_rtol</span><span class="s2">(</span><span class="s3">'cg'</span><span class="s2">, </span><span class="s1">bnrm2</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">bnrm2 </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">b</span><span class="s2">), </span><span class="s4">0</span>

    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">maxiter </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">n</span><span class="s2">*</span><span class="s4">10</span>

    <span class="s1">dotprod </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">vdot </span><span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">else </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span>

    <span class="s1">matvec </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">matvec</span>
    <span class="s1">psolve </span><span class="s2">= </span><span class="s1">M</span><span class="s2">.</span><span class="s1">matvec</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">b </span><span class="s2">- </span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">any</span><span class="s2">() </span><span class="s0">else </span><span class="s1">b</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

    <span class="s6"># Dummy value to initialize var, silences warnings</span>
    <span class="s1">rho_prev</span><span class="s2">, </span><span class="s1">p </span><span class="s2">= </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span>

    <span class="s0">for </span><span class="s1">iteration </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">r</span><span class="s2">) &lt; </span><span class="s1">atol</span><span class="s2">:  </span><span class="s6"># Are we done?</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s4">0</span>

        <span class="s1">z </span><span class="s2">= </span><span class="s1">psolve</span><span class="s2">(</span><span class="s1">r</span><span class="s2">)</span>
        <span class="s1">rho_cur </span><span class="s2">= </span><span class="s1">dotprod</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s1">z</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">iteration </span><span class="s2">&gt; </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s1">beta </span><span class="s2">= </span><span class="s1">rho_cur </span><span class="s2">/ </span><span class="s1">rho_prev</span>
            <span class="s1">p </span><span class="s2">*= </span><span class="s1">beta</span>
            <span class="s1">p </span><span class="s2">+= </span><span class="s1">z</span>
        <span class="s0">else</span><span class="s2">:  </span><span class="s6"># First spin</span>
            <span class="s1">p </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">r</span><span class="s2">)</span>
            <span class="s1">p</span><span class="s2">[:] = </span><span class="s1">z</span><span class="s2">[:]</span>

        <span class="s1">q </span><span class="s2">= </span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>
        <span class="s1">alpha </span><span class="s2">= </span><span class="s1">rho_cur </span><span class="s2">/ </span><span class="s1">dotprod</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">)</span>
        <span class="s1">x </span><span class="s2">+= </span><span class="s1">alpha</span><span class="s2">*</span><span class="s1">p</span>
        <span class="s1">r </span><span class="s2">-= </span><span class="s1">alpha</span><span class="s2">*</span><span class="s1">q</span>
        <span class="s1">rho_prev </span><span class="s2">= </span><span class="s1">rho_cur</span>

        <span class="s0">if </span><span class="s1">callback</span><span class="s2">:</span>
            <span class="s1">callback</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s0">else</span><span class="s2">:  </span><span class="s6"># for loop exhausted</span>
        <span class="s6"># Return incomplete progress</span>
        <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s1">maxiter</span>


<span class="s0">def </span><span class="s1">cgs</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">M</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Use Conjugate Gradient Squared iteration to solve ``Ax = b``. 
 
    Parameters 
    ---------- 
    A : {sparse matrix, ndarray, LinearOperator} 
        The real-valued N-by-N matrix of the linear system. 
        Alternatively, ``A`` can be a linear operator which can 
        produce ``Ax`` using, e.g., 
        ``scipy.sparse.linalg.LinearOperator``. 
    b : ndarray 
        Right hand side of the linear system. Has shape (N,) or (N,1). 
    x0 : ndarray 
        Starting guess for the solution. 
    rtol, atol : float, optional 
        Parameters for the convergence test. For convergence, 
        ``norm(b - A @ x) &lt;= max(rtol*norm(b), atol)`` should be satisfied. 
        The default is ``atol=0.`` and ``rtol=1e-5``. 
    maxiter : integer 
        Maximum number of iterations.  Iteration will stop after maxiter 
        steps even if the specified tolerance has not been achieved. 
    M : {sparse matrix, ndarray, LinearOperator} 
        Preconditioner for A.  The preconditioner should approximate the 
        inverse of A.  Effective preconditioning dramatically improves the 
        rate of convergence, which implies that fewer iterations are needed 
        to reach a given error tolerance. 
    callback : function 
        User-supplied function to call after each iteration.  It is called 
        as callback(xk), where xk is the current solution vector. 
 
    Returns 
    ------- 
    x : ndarray 
        The converged solution. 
    info : integer 
        Provides convergence information: 
            0  : successful exit 
            &gt;0 : convergence to tolerance not achieved, number of iterations 
            &lt;0 : parameter breakdown 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import csc_matrix 
    &gt;&gt;&gt; from scipy.sparse.linalg import cgs 
    &gt;&gt;&gt; R = np.array([[4, 2, 0, 1], 
    ...               [3, 0, 0, 2], 
    ...               [0, 1, 1, 1], 
    ...               [0, 2, 1, 0]]) 
    &gt;&gt;&gt; A = csc_matrix(R) 
    &gt;&gt;&gt; b = np.array([-1, -0.5, -1, 2]) 
    &gt;&gt;&gt; x, exit_code = cgs(A, b) 
    &gt;&gt;&gt; print(exit_code)  # 0 indicates successful convergence 
    0 
    &gt;&gt;&gt; np.allclose(A.dot(x), b) 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s1">A</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">postprocess </span><span class="s2">= </span><span class="s1">make_system</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
    <span class="s1">bnrm2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>

    <span class="s1">atol</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_get_atol_rtol</span><span class="s2">(</span><span class="s3">'cgs'</span><span class="s2">, </span><span class="s1">bnrm2</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">bnrm2 </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">b</span><span class="s2">), </span><span class="s4">0</span>

    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>

    <span class="s1">dotprod </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">vdot </span><span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">else </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span>

    <span class="s0">if </span><span class="s1">maxiter </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">n</span><span class="s2">*</span><span class="s4">10</span>

    <span class="s1">matvec </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">matvec</span>
    <span class="s1">psolve </span><span class="s2">= </span><span class="s1">M</span><span class="s2">.</span><span class="s1">matvec</span>

    <span class="s1">rhotol </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">).</span><span class="s1">eps</span><span class="s2">**</span><span class="s4">2</span>

    <span class="s1">r </span><span class="s2">= </span><span class="s1">b </span><span class="s2">- </span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">any</span><span class="s2">() </span><span class="s0">else </span><span class="s1">b</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

    <span class="s1">rtilde </span><span class="s2">= </span><span class="s1">r</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
    <span class="s1">bnorm </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">bnorm </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s1">bnorm </span><span class="s2">= </span><span class="s4">1</span>

    <span class="s6"># Dummy values to initialize vars, silence linter warnings</span>
    <span class="s1">rho_prev</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">q </span><span class="s2">= </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span>

    <span class="s0">for </span><span class="s1">iteration </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">):</span>
        <span class="s1">rnorm </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">r</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">rnorm </span><span class="s2">&lt; </span><span class="s1">atol</span><span class="s2">:  </span><span class="s6"># Are we done?</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s4">0</span>

        <span class="s1">rho_cur </span><span class="s2">= </span><span class="s1">dotprod</span><span class="s2">(</span><span class="s1">rtilde</span><span class="s2">, </span><span class="s1">r</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">rho_cur</span><span class="s2">) &lt; </span><span class="s1">rhotol</span><span class="s2">:  </span><span class="s6"># Breakdown case</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">, -</span><span class="s4">10</span>

        <span class="s0">if </span><span class="s1">iteration </span><span class="s2">&gt; </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s1">beta </span><span class="s2">= </span><span class="s1">rho_cur </span><span class="s2">/ </span><span class="s1">rho_prev</span>

            <span class="s6"># u = r + beta * q</span>
            <span class="s6"># p = u + beta * (q + beta * p);</span>
            <span class="s1">u</span><span class="s2">[:] = </span><span class="s1">r</span><span class="s2">[:]</span>
            <span class="s1">u </span><span class="s2">+= </span><span class="s1">beta</span><span class="s2">*</span><span class="s1">q</span>

            <span class="s1">p </span><span class="s2">*= </span><span class="s1">beta</span>
            <span class="s1">p </span><span class="s2">+= </span><span class="s1">q</span>
            <span class="s1">p </span><span class="s2">*= </span><span class="s1">beta</span>
            <span class="s1">p </span><span class="s2">+= </span><span class="s1">u</span>

        <span class="s0">else</span><span class="s2">:  </span><span class="s6"># First spin</span>
            <span class="s1">p </span><span class="s2">= </span><span class="s1">r</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s1">u </span><span class="s2">= </span><span class="s1">r</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s1">q </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">r</span><span class="s2">)</span>

        <span class="s1">phat </span><span class="s2">= </span><span class="s1">psolve</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>
        <span class="s1">vhat </span><span class="s2">= </span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">phat</span><span class="s2">)</span>
        <span class="s1">rv </span><span class="s2">= </span><span class="s1">dotprod</span><span class="s2">(</span><span class="s1">rtilde</span><span class="s2">, </span><span class="s1">vhat</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">rv </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:  </span><span class="s6"># Dot product breakdown</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), -</span><span class="s4">11</span>

        <span class="s1">alpha </span><span class="s2">= </span><span class="s1">rho_cur </span><span class="s2">/ </span><span class="s1">rv</span>
        <span class="s1">q</span><span class="s2">[:] = </span><span class="s1">u</span><span class="s2">[:]</span>
        <span class="s1">q </span><span class="s2">-= </span><span class="s1">alpha</span><span class="s2">*</span><span class="s1">vhat</span>
        <span class="s1">uhat </span><span class="s2">= </span><span class="s1">psolve</span><span class="s2">(</span><span class="s1">u </span><span class="s2">+ </span><span class="s1">q</span><span class="s2">)</span>
        <span class="s1">x </span><span class="s2">+= </span><span class="s1">alpha</span><span class="s2">*</span><span class="s1">uhat</span>

        <span class="s6"># Due to numerical error build-up the actual residual is computed</span>
        <span class="s6"># instead of the following two lines that were in the original</span>
        <span class="s6"># FORTRAN templates, still using a single matvec.</span>

        <span class="s6"># qhat = matvec(uhat)</span>
        <span class="s6"># r -= alpha*qhat</span>
        <span class="s1">r </span><span class="s2">= </span><span class="s1">b </span><span class="s2">- </span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

        <span class="s1">rho_prev </span><span class="s2">= </span><span class="s1">rho_cur</span>

        <span class="s0">if </span><span class="s1">callback</span><span class="s2">:</span>
            <span class="s1">callback</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s0">else</span><span class="s2">:  </span><span class="s6"># for loop exhausted</span>
        <span class="s6"># Return incomplete progress</span>
        <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s1">maxiter</span>


<span class="s0">def </span><span class="s1">gmres</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">restart</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">M</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
          <span class="s1">callback</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">callback_type</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Use Generalized Minimal RESidual iteration to solve ``Ax = b``. 
 
    Parameters 
    ---------- 
    A : {sparse matrix, ndarray, LinearOperator} 
        The real or complex N-by-N matrix of the linear system. 
        Alternatively, ``A`` can be a linear operator which can 
        produce ``Ax`` using, e.g., 
        ``scipy.sparse.linalg.LinearOperator``. 
    b : ndarray 
        Right hand side of the linear system. Has shape (N,) or (N,1). 
    x0 : ndarray 
        Starting guess for the solution (a vector of zeros by default). 
    atol, rtol : float 
        Parameters for the convergence test. For convergence, 
        ``norm(b - A @ x) &lt;= max(rtol*norm(b), atol)`` should be satisfied. 
        The default is ``atol=0.`` and ``rtol=1e-5``. 
    restart : int, optional 
        Number of iterations between restarts. Larger values increase 
        iteration cost, but may be necessary for convergence. 
        If omitted, ``min(20, n)`` is used. 
    maxiter : int, optional 
        Maximum number of iterations (restart cycles).  Iteration will stop 
        after maxiter steps even if the specified tolerance has not been 
        achieved. See `callback_type`. 
    M : {sparse matrix, ndarray, LinearOperator} 
        Inverse of the preconditioner of A.  M should approximate the 
        inverse of A and be easy to solve for (see Notes).  Effective 
        preconditioning dramatically improves the rate of convergence, 
        which implies that fewer iterations are needed to reach a given 
        error tolerance.  By default, no preconditioner is used. 
        In this implementation, left preconditioning is used, 
        and the preconditioned residual is minimized. However, the final 
        convergence is tested with respect to the ``b - A @ x`` residual. 
    callback : function 
        User-supplied function to call after each iteration.  It is called 
        as `callback(args)`, where `args` are selected by `callback_type`. 
    callback_type : {'x', 'pr_norm', 'legacy'}, optional 
        Callback function argument requested: 
          - ``x``: current iterate (ndarray), called on every restart 
          - ``pr_norm``: relative (preconditioned) residual norm (float), 
            called on every inner iteration 
          - ``legacy`` (default): same as ``pr_norm``, but also changes the 
            meaning of `maxiter` to count inner iterations instead of restart 
            cycles. 
 
        This keyword has no effect if `callback` is not set. 
 
    Returns 
    ------- 
    x : ndarray 
        The converged solution. 
    info : int 
        Provides convergence information: 
            0  : successful exit 
            &gt;0 : convergence to tolerance not achieved, number of iterations 
 
    See Also 
    -------- 
    LinearOperator 
 
    Notes 
    ----- 
    A preconditioner, P, is chosen such that P is close to A but easy to solve 
    for. The preconditioner parameter required by this routine is 
    ``M = P^-1``. The inverse should preferably not be calculated 
    explicitly.  Rather, use the following template to produce M:: 
 
      # Construct a linear operator that computes P^-1 @ x. 
      import scipy.sparse.linalg as spla 
      M_x = lambda x: spla.spsolve(P, x) 
      M = spla.LinearOperator((n, n), M_x) 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import csc_matrix 
    &gt;&gt;&gt; from scipy.sparse.linalg import gmres 
    &gt;&gt;&gt; A = csc_matrix([[3, 2, 0], [1, -1, 0], [0, 5, 1]], dtype=float) 
    &gt;&gt;&gt; b = np.array([2, 4, -1], dtype=float) 
    &gt;&gt;&gt; x, exitCode = gmres(A, b, atol=1e-5) 
    &gt;&gt;&gt; print(exitCode)            # 0 indicates successful convergence 
    0 
    &gt;&gt;&gt; np.allclose(A.dot(x), b) 
    True 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">callback </span><span class="s0">is not None and </span><span class="s1">callback_type </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s6"># Warn about 'callback_type' semantic changes.</span>
        <span class="s6"># Probably should be removed only in far future, Scipy 2.0 or so.</span>
        <span class="s1">msg </span><span class="s2">= (</span><span class="s3">&quot;scipy.sparse.linalg.gmres called without specifying &quot;</span>
               <span class="s3">&quot;`callback_type`. The default value will be changed in&quot;</span>
               <span class="s3">&quot; a future release. For compatibility, specify a value &quot;</span>
               <span class="s3">&quot;for `callback_type` explicitly, e.g., &quot;</span>
               <span class="s3">&quot;``gmres(..., callback_type='pr_norm')``, or to retain the &quot;</span>
               <span class="s3">&quot;old behavior ``gmres(..., callback_type='legacy')``&quot;</span>
               <span class="s2">)</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">category</span><span class="s2">=</span><span class="s1">DeprecationWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s4">3</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">callback_type </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">callback_type </span><span class="s2">= </span><span class="s3">'legacy'</span>

    <span class="s0">if </span><span class="s1">callback_type </span><span class="s0">not in </span><span class="s2">(</span><span class="s3">'x'</span><span class="s2">, </span><span class="s3">'pr_norm'</span><span class="s2">, </span><span class="s3">'legacy'</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f&quot;Unknown callback_type: </span><span class="s0">{</span><span class="s1">callback_type</span><span class="s0">!r}</span><span class="s3">&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">callback </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">callback_type </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s1">A</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">postprocess </span><span class="s2">= </span><span class="s1">make_system</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
    <span class="s1">matvec </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">matvec</span>
    <span class="s1">psolve </span><span class="s2">= </span><span class="s1">M</span><span class="s2">.</span><span class="s1">matvec</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>
    <span class="s1">bnrm2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>

    <span class="s1">atol</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_get_atol_rtol</span><span class="s2">(</span><span class="s3">'gmres'</span><span class="s2">, </span><span class="s1">bnrm2</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">bnrm2 </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">b</span><span class="s2">), </span><span class="s4">0</span>

    <span class="s1">eps </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">).</span><span class="s1">eps</span>

    <span class="s1">dotprod </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">vdot </span><span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">else </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span>

    <span class="s0">if </span><span class="s1">maxiter </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">n</span><span class="s2">*</span><span class="s4">10</span>

    <span class="s0">if </span><span class="s1">restart </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">restart </span><span class="s2">= </span><span class="s4">20</span>
    <span class="s1">restart </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">restart</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>

    <span class="s1">Mb_nrm2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">psolve</span><span class="s2">(</span><span class="s1">b</span><span class="s2">))</span>

    <span class="s6"># ====================================================</span>
    <span class="s6"># =========== Tolerance control from gh-8400 =========</span>
    <span class="s6"># ====================================================</span>
    <span class="s6"># Tolerance passed to GMRESREVCOM applies to the inner</span>
    <span class="s6"># iteration and deals with the left-preconditioned</span>
    <span class="s6"># residual.</span>
    <span class="s1">ptol_max_factor </span><span class="s2">= </span><span class="s4">1.</span>
    <span class="s1">ptol </span><span class="s2">= </span><span class="s1">Mb_nrm2 </span><span class="s2">* </span><span class="s1">min</span><span class="s2">(</span><span class="s1">ptol_max_factor</span><span class="s2">, </span><span class="s1">atol </span><span class="s2">/ </span><span class="s1">bnrm2</span><span class="s2">)</span>
    <span class="s1">presid </span><span class="s2">= </span><span class="s4">0.</span>
    <span class="s6"># ====================================================</span>
    <span class="s1">lartg </span><span class="s2">= </span><span class="s1">get_lapack_funcs</span><span class="s2">(</span><span class="s3">'lartg'</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s6"># allocate internal variables</span>
    <span class="s1">v </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">([</span><span class="s1">restart</span><span class="s2">+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">h </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">([</span><span class="s1">restart</span><span class="s2">, </span><span class="s1">restart</span><span class="s2">+</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">givens </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">([</span><span class="s1">restart</span><span class="s2">, </span><span class="s4">2</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s6"># legacy iteration count</span>
    <span class="s1">inner_iter </span><span class="s2">= </span><span class="s4">0</span>

    <span class="s0">for </span><span class="s1">iteration </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">iteration </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s1">r </span><span class="s2">= </span><span class="s1">b </span><span class="s2">- </span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">any</span><span class="s2">() </span><span class="s0">else </span><span class="s1">b</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">r</span><span class="s2">) &lt; </span><span class="s1">atol</span><span class="s2">:  </span><span class="s6"># Are we done?</span>
                <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s4">0</span>

        <span class="s1">v</span><span class="s2">[</span><span class="s4">0</span><span class="s2">, :] = </span><span class="s1">psolve</span><span class="s2">(</span><span class="s1">r</span><span class="s2">)</span>
        <span class="s1">tmp </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">v</span><span class="s2">[</span><span class="s4">0</span><span class="s2">, :])</span>
        <span class="s1">v</span><span class="s2">[</span><span class="s4">0</span><span class="s2">, :] *= (</span><span class="s4">1 </span><span class="s2">/ </span><span class="s1">tmp</span><span class="s2">)</span>
        <span class="s6"># RHS of the Hessenberg problem</span>
        <span class="s1">S </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">restart</span><span class="s2">+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">S</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] = </span><span class="s1">tmp</span>

        <span class="s1">breakdown </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">restart</span><span class="s2">):</span>
            <span class="s1">av </span><span class="s2">= </span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">v</span><span class="s2">[</span><span class="s1">col</span><span class="s2">, :])</span>
            <span class="s1">w </span><span class="s2">= </span><span class="s1">psolve</span><span class="s2">(</span><span class="s1">av</span><span class="s2">)</span>

            <span class="s6"># Modified Gram-Schmidt</span>
            <span class="s1">h0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">w</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">col</span><span class="s2">+</span><span class="s4">1</span><span class="s2">):</span>
                <span class="s1">tmp </span><span class="s2">= </span><span class="s1">dotprod</span><span class="s2">(</span><span class="s1">v</span><span class="s2">[</span><span class="s1">k</span><span class="s2">, :], </span><span class="s1">w</span><span class="s2">)</span>
                <span class="s1">h</span><span class="s2">[</span><span class="s1">col</span><span class="s2">, </span><span class="s1">k</span><span class="s2">] = </span><span class="s1">tmp</span>
                <span class="s1">w </span><span class="s2">-= </span><span class="s1">tmp</span><span class="s2">*</span><span class="s1">v</span><span class="s2">[</span><span class="s1">k</span><span class="s2">, :]</span>

            <span class="s1">h1 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">w</span><span class="s2">)</span>
            <span class="s1">h</span><span class="s2">[</span><span class="s1">col</span><span class="s2">, </span><span class="s1">col </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">] = </span><span class="s1">h1</span>
            <span class="s1">v</span><span class="s2">[</span><span class="s1">col </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">, :] = </span><span class="s1">w</span><span class="s2">[:]</span>

            <span class="s6"># Exact solution indicator</span>
            <span class="s0">if </span><span class="s1">h1 </span><span class="s2">&lt;= </span><span class="s1">eps</span><span class="s2">*</span><span class="s1">h0</span><span class="s2">:</span>
                <span class="s1">h</span><span class="s2">[</span><span class="s1">col</span><span class="s2">, </span><span class="s1">col </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">] = </span><span class="s4">0</span>
                <span class="s1">breakdown </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">v</span><span class="s2">[</span><span class="s1">col </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">, :] *= (</span><span class="s4">1 </span><span class="s2">/ </span><span class="s1">h1</span><span class="s2">)</span>

            <span class="s6"># apply past Givens rotations to current h column</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">col</span><span class="s2">):</span>
                <span class="s1">c</span><span class="s2">, </span><span class="s1">s </span><span class="s2">= </span><span class="s1">givens</span><span class="s2">[</span><span class="s1">k</span><span class="s2">, </span><span class="s4">0</span><span class="s2">], </span><span class="s1">givens</span><span class="s2">[</span><span class="s1">k</span><span class="s2">, </span><span class="s4">1</span><span class="s2">]</span>
                <span class="s1">n0</span><span class="s2">, </span><span class="s1">n1 </span><span class="s2">= </span><span class="s1">h</span><span class="s2">[</span><span class="s1">col</span><span class="s2">, [</span><span class="s1">k</span><span class="s2">, </span><span class="s1">k</span><span class="s2">+</span><span class="s4">1</span><span class="s2">]]</span>
                <span class="s1">h</span><span class="s2">[</span><span class="s1">col</span><span class="s2">, [</span><span class="s1">k</span><span class="s2">, </span><span class="s1">k </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">]] = [</span><span class="s1">c</span><span class="s2">*</span><span class="s1">n0 </span><span class="s2">+ </span><span class="s1">s</span><span class="s2">*</span><span class="s1">n1</span><span class="s2">, -</span><span class="s1">s</span><span class="s2">.</span><span class="s1">conj</span><span class="s2">()*</span><span class="s1">n0 </span><span class="s2">+ </span><span class="s1">c</span><span class="s2">*</span><span class="s1">n1</span><span class="s2">]</span>

            <span class="s6"># get and apply current rotation to h and S</span>
            <span class="s1">c</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">mag </span><span class="s2">= </span><span class="s1">lartg</span><span class="s2">(</span><span class="s1">h</span><span class="s2">[</span><span class="s1">col</span><span class="s2">, </span><span class="s1">col</span><span class="s2">], </span><span class="s1">h</span><span class="s2">[</span><span class="s1">col</span><span class="s2">, </span><span class="s1">col</span><span class="s2">+</span><span class="s4">1</span><span class="s2">])</span>
            <span class="s1">givens</span><span class="s2">[</span><span class="s1">col</span><span class="s2">, :] = [</span><span class="s1">c</span><span class="s2">, </span><span class="s1">s</span><span class="s2">]</span>
            <span class="s1">h</span><span class="s2">[</span><span class="s1">col</span><span class="s2">, [</span><span class="s1">col</span><span class="s2">, </span><span class="s1">col</span><span class="s2">+</span><span class="s4">1</span><span class="s2">]] = </span><span class="s1">mag</span><span class="s2">, </span><span class="s4">0</span>

            <span class="s6"># S[col+1] component is always 0</span>
            <span class="s1">tmp </span><span class="s2">= -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">conjugate</span><span class="s2">(</span><span class="s1">s</span><span class="s2">)*</span><span class="s1">S</span><span class="s2">[</span><span class="s1">col</span><span class="s2">]</span>
            <span class="s1">S</span><span class="s2">[[</span><span class="s1">col</span><span class="s2">, </span><span class="s1">col </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">]] = [</span><span class="s1">c</span><span class="s2">*</span><span class="s1">S</span><span class="s2">[</span><span class="s1">col</span><span class="s2">], </span><span class="s1">tmp</span><span class="s2">]</span>
            <span class="s1">presid </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">tmp</span><span class="s2">)</span>
            <span class="s1">inner_iter </span><span class="s2">+= </span><span class="s4">1</span>

            <span class="s0">if </span><span class="s1">callback_type </span><span class="s0">in </span><span class="s2">(</span><span class="s3">'legacy'</span><span class="s2">, </span><span class="s3">'pr_norm'</span><span class="s2">):</span>
                <span class="s1">callback</span><span class="s2">(</span><span class="s1">presid </span><span class="s2">/ </span><span class="s1">bnrm2</span><span class="s2">)</span>
            <span class="s6"># Legacy behavior</span>
            <span class="s0">if </span><span class="s1">callback_type </span><span class="s2">== </span><span class="s3">'legacy' </span><span class="s0">and </span><span class="s1">inner_iter </span><span class="s2">== </span><span class="s1">maxiter</span><span class="s2">:</span>
                <span class="s0">break</span>
            <span class="s0">if </span><span class="s1">presid </span><span class="s2">&lt;= </span><span class="s1">ptol </span><span class="s0">or </span><span class="s1">breakdown</span><span class="s2">:</span>
                <span class="s0">break</span>

        <span class="s6"># Solve h(col, col) upper triangular system and allow pseudo-solve</span>
        <span class="s6"># singular cases as in (but without the f2py copies):</span>
        <span class="s6"># y = trsv(h[:col+1, :col+1].T, S[:col+1])</span>

        <span class="s0">if </span><span class="s1">h</span><span class="s2">[</span><span class="s1">col</span><span class="s2">, </span><span class="s1">col</span><span class="s2">] == </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s1">S</span><span class="s2">[</span><span class="s1">col</span><span class="s2">] = </span><span class="s4">0</span>

        <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">([</span><span class="s1">col</span><span class="s2">+</span><span class="s4">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">y</span><span class="s2">[:] = </span><span class="s1">S</span><span class="s2">[:</span><span class="s1">col</span><span class="s2">+</span><span class="s4">1</span><span class="s2">]</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">col</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">y</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] != </span><span class="s4">0</span><span class="s2">:</span>
                <span class="s1">y</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] /= </span><span class="s1">h</span><span class="s2">[</span><span class="s1">k</span><span class="s2">, </span><span class="s1">k</span><span class="s2">]</span>
                <span class="s1">tmp </span><span class="s2">= </span><span class="s1">y</span><span class="s2">[</span><span class="s1">k</span><span class="s2">]</span>
                <span class="s1">y</span><span class="s2">[:</span><span class="s1">k</span><span class="s2">] -= </span><span class="s1">tmp</span><span class="s2">*</span><span class="s1">h</span><span class="s2">[</span><span class="s1">k</span><span class="s2">, :</span><span class="s1">k</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">y</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] != </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s1">y</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] /= </span><span class="s1">h</span><span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">]</span>

        <span class="s1">x </span><span class="s2">+= </span><span class="s1">y </span><span class="s2">@ </span><span class="s1">v</span><span class="s2">[:</span><span class="s1">col</span><span class="s2">+</span><span class="s4">1</span><span class="s2">, :]</span>

        <span class="s1">r </span><span class="s2">= </span><span class="s1">b </span><span class="s2">- </span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s1">rnorm </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">r</span><span class="s2">)</span>

        <span class="s6"># Legacy exit</span>
        <span class="s0">if </span><span class="s1">callback_type </span><span class="s2">== </span><span class="s3">'legacy' </span><span class="s0">and </span><span class="s1">inner_iter </span><span class="s2">== </span><span class="s1">maxiter</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s4">0 </span><span class="s0">if </span><span class="s1">rnorm </span><span class="s2">&lt;= </span><span class="s1">atol </span><span class="s0">else </span><span class="s1">maxiter</span>

        <span class="s0">if </span><span class="s1">callback_type </span><span class="s2">== </span><span class="s3">'x'</span><span class="s2">:</span>
            <span class="s1">callback</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">rnorm </span><span class="s2">&lt;= </span><span class="s1">atol</span><span class="s2">:</span>
            <span class="s0">break</span>
        <span class="s0">elif </span><span class="s1">breakdown</span><span class="s2">:</span>
            <span class="s6"># Reached breakdown (= exact solution), but the external</span>
            <span class="s6"># tolerance check failed. Bail out with failure.</span>
            <span class="s0">break</span>
        <span class="s0">elif </span><span class="s1">presid </span><span class="s2">&lt;= </span><span class="s1">ptol</span><span class="s2">:</span>
            <span class="s6"># Inner loop passed but outer didn't</span>
            <span class="s1">ptol_max_factor </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">eps</span><span class="s2">, </span><span class="s4">0.25 </span><span class="s2">* </span><span class="s1">ptol_max_factor</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">ptol_max_factor </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.5 </span><span class="s2">* </span><span class="s1">ptol_max_factor</span><span class="s2">)</span>

        <span class="s1">ptol </span><span class="s2">= </span><span class="s1">presid </span><span class="s2">* </span><span class="s1">min</span><span class="s2">(</span><span class="s1">ptol_max_factor</span><span class="s2">, </span><span class="s1">atol </span><span class="s2">/ </span><span class="s1">rnorm</span><span class="s2">)</span>

    <span class="s1">info </span><span class="s2">= </span><span class="s4">0 </span><span class="s0">if </span><span class="s2">(</span><span class="s1">rnorm </span><span class="s2">&lt;= </span><span class="s1">atol</span><span class="s2">) </span><span class="s0">else </span><span class="s1">maxiter</span>
    <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s1">info</span>


<span class="s0">def </span><span class="s1">qmr</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">M1</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">M2</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">callback</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Use Quasi-Minimal Residual iteration to solve ``Ax = b``. 
 
    Parameters 
    ---------- 
    A : {sparse matrix, ndarray, LinearOperator} 
        The real-valued N-by-N matrix of the linear system. 
        Alternatively, ``A`` can be a linear operator which can 
        produce ``Ax`` and ``A^T x`` using, e.g., 
        ``scipy.sparse.linalg.LinearOperator``. 
    b : ndarray 
        Right hand side of the linear system. Has shape (N,) or (N,1). 
    x0 : ndarray 
        Starting guess for the solution. 
    atol, rtol : float, optional 
        Parameters for the convergence test. For convergence, 
        ``norm(b - A @ x) &lt;= max(rtol*norm(b), atol)`` should be satisfied. 
        The default is ``atol=0.`` and ``rtol=1e-5``. 
    maxiter : integer 
        Maximum number of iterations.  Iteration will stop after maxiter 
        steps even if the specified tolerance has not been achieved. 
    M1 : {sparse matrix, ndarray, LinearOperator} 
        Left preconditioner for A. 
    M2 : {sparse matrix, ndarray, LinearOperator} 
        Right preconditioner for A. Used together with the left 
        preconditioner M1.  The matrix M1@A@M2 should have better 
        conditioned than A alone. 
    callback : function 
        User-supplied function to call after each iteration.  It is called 
        as callback(xk), where xk is the current solution vector. 
 
    Returns 
    ------- 
    x : ndarray 
        The converged solution. 
    info : integer 
        Provides convergence information: 
            0  : successful exit 
            &gt;0 : convergence to tolerance not achieved, number of iterations 
            &lt;0 : parameter breakdown 
 
    See Also 
    -------- 
    LinearOperator 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import csc_matrix 
    &gt;&gt;&gt; from scipy.sparse.linalg import qmr 
    &gt;&gt;&gt; A = csc_matrix([[3., 2., 0.], [1., -1., 0.], [0., 5., 1.]]) 
    &gt;&gt;&gt; b = np.array([2., 4., -1.]) 
    &gt;&gt;&gt; x, exitCode = qmr(A, b, atol=1e-5) 
    &gt;&gt;&gt; print(exitCode)            # 0 indicates successful convergence 
    0 
    &gt;&gt;&gt; np.allclose(A.dot(x), b) 
    True 
    &quot;&quot;&quot;</span>
    <span class="s1">A_ </span><span class="s2">= </span><span class="s1">A</span>
    <span class="s1">A</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">postprocess </span><span class="s2">= </span><span class="s1">make_system</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
    <span class="s1">bnrm2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>

    <span class="s1">atol</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_get_atol_rtol</span><span class="s2">(</span><span class="s3">'qmr'</span><span class="s2">, </span><span class="s1">bnrm2</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">bnrm2 </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">b</span><span class="s2">), </span><span class="s4">0</span>

    <span class="s0">if </span><span class="s1">M1 </span><span class="s0">is None and </span><span class="s1">M2 </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">A_</span><span class="s2">, </span><span class="s3">'psolve'</span><span class="s2">):</span>
            <span class="s0">def </span><span class="s1">left_psolve</span><span class="s2">(</span><span class="s1">b</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">A_</span><span class="s2">.</span><span class="s1">psolve</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s3">'left'</span><span class="s2">)</span>

            <span class="s0">def </span><span class="s1">right_psolve</span><span class="s2">(</span><span class="s1">b</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">A_</span><span class="s2">.</span><span class="s1">psolve</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s3">'right'</span><span class="s2">)</span>

            <span class="s0">def </span><span class="s1">left_rpsolve</span><span class="s2">(</span><span class="s1">b</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">A_</span><span class="s2">.</span><span class="s1">rpsolve</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s3">'left'</span><span class="s2">)</span>

            <span class="s0">def </span><span class="s1">right_rpsolve</span><span class="s2">(</span><span class="s1">b</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">A_</span><span class="s2">.</span><span class="s1">rpsolve</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s3">'right'</span><span class="s2">)</span>
            <span class="s1">M1 </span><span class="s2">= </span><span class="s1">LinearOperator</span><span class="s2">(</span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">,</span>
                                <span class="s1">matvec</span><span class="s2">=</span><span class="s1">left_psolve</span><span class="s2">,</span>
                                <span class="s1">rmatvec</span><span class="s2">=</span><span class="s1">left_rpsolve</span><span class="s2">)</span>
            <span class="s1">M2 </span><span class="s2">= </span><span class="s1">LinearOperator</span><span class="s2">(</span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">,</span>
                                <span class="s1">matvec</span><span class="s2">=</span><span class="s1">right_psolve</span><span class="s2">,</span>
                                <span class="s1">rmatvec</span><span class="s2">=</span><span class="s1">right_rpsolve</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">def </span><span class="s1">id</span><span class="s2">(</span><span class="s1">b</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">b</span>
            <span class="s1">M1 </span><span class="s2">= </span><span class="s1">LinearOperator</span><span class="s2">(</span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">matvec</span><span class="s2">=</span><span class="s1">id</span><span class="s2">, </span><span class="s1">rmatvec</span><span class="s2">=</span><span class="s1">id</span><span class="s2">)</span>
            <span class="s1">M2 </span><span class="s2">= </span><span class="s1">LinearOperator</span><span class="s2">(</span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">matvec</span><span class="s2">=</span><span class="s1">id</span><span class="s2">, </span><span class="s1">rmatvec</span><span class="s2">=</span><span class="s1">id</span><span class="s2">)</span>

    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">maxiter </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">n</span><span class="s2">*</span><span class="s4">10</span>

    <span class="s1">dotprod </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">vdot </span><span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">else </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span>

    <span class="s1">rhotol </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">).</span><span class="s1">eps</span>
    <span class="s1">betatol </span><span class="s2">= </span><span class="s1">rhotol</span>
    <span class="s1">gammatol </span><span class="s2">= </span><span class="s1">rhotol</span>
    <span class="s1">deltatol </span><span class="s2">= </span><span class="s1">rhotol</span>
    <span class="s1">epsilontol </span><span class="s2">= </span><span class="s1">rhotol</span>
    <span class="s1">xitol </span><span class="s2">= </span><span class="s1">rhotol</span>

    <span class="s1">r </span><span class="s2">= </span><span class="s1">b </span><span class="s2">- </span><span class="s1">A</span><span class="s2">.</span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">any</span><span class="s2">() </span><span class="s0">else </span><span class="s1">b</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

    <span class="s1">vtilde </span><span class="s2">= </span><span class="s1">r</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">M1</span><span class="s2">.</span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">vtilde</span><span class="s2">)</span>
    <span class="s1">rho </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
    <span class="s1">wtilde </span><span class="s2">= </span><span class="s1">r</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
    <span class="s1">z </span><span class="s2">= </span><span class="s1">M2</span><span class="s2">.</span><span class="s1">rmatvec</span><span class="s2">(</span><span class="s1">wtilde</span><span class="s2">)</span>
    <span class="s1">xi </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">z</span><span class="s2">)</span>
    <span class="s1">gamma</span><span class="s2">, </span><span class="s1">eta</span><span class="s2">, </span><span class="s1">theta </span><span class="s2">= </span><span class="s4">1</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span>
    <span class="s1">v </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">vtilde</span><span class="s2">)</span>
    <span class="s1">w </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">wtilde</span><span class="s2">)</span>

    <span class="s6"># Dummy values to initialize vars, silence linter warnings</span>
    <span class="s1">epsilon</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">s </span><span class="s2">= </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span>

    <span class="s0">for </span><span class="s1">iteration </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">r</span><span class="s2">) &lt; </span><span class="s1">atol</span><span class="s2">:  </span><span class="s6"># Are we done?</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s4">0</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">rho</span><span class="s2">) &lt; </span><span class="s1">rhotol</span><span class="s2">:  </span><span class="s6"># rho breakdown</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), -</span><span class="s4">10</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">xi</span><span class="s2">) &lt; </span><span class="s1">xitol</span><span class="s2">:  </span><span class="s6"># xi breakdown</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), -</span><span class="s4">15</span>

        <span class="s1">v</span><span class="s2">[:] = </span><span class="s1">vtilde</span><span class="s2">[:]</span>
        <span class="s1">v </span><span class="s2">*= (</span><span class="s4">1 </span><span class="s2">/ </span><span class="s1">rho</span><span class="s2">)</span>
        <span class="s1">y </span><span class="s2">*= (</span><span class="s4">1 </span><span class="s2">/ </span><span class="s1">rho</span><span class="s2">)</span>
        <span class="s1">w</span><span class="s2">[:] = </span><span class="s1">wtilde</span><span class="s2">[:]</span>
        <span class="s1">w </span><span class="s2">*= (</span><span class="s4">1 </span><span class="s2">/ </span><span class="s1">xi</span><span class="s2">)</span>
        <span class="s1">z </span><span class="s2">*= (</span><span class="s4">1 </span><span class="s2">/ </span><span class="s1">xi</span><span class="s2">)</span>
        <span class="s1">delta </span><span class="s2">= </span><span class="s1">dotprod</span><span class="s2">(</span><span class="s1">z</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">delta</span><span class="s2">) &lt; </span><span class="s1">deltatol</span><span class="s2">:  </span><span class="s6"># delta breakdown</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), -</span><span class="s4">13</span>

        <span class="s1">ytilde </span><span class="s2">= </span><span class="s1">M2</span><span class="s2">.</span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
        <span class="s1">ztilde </span><span class="s2">= </span><span class="s1">M1</span><span class="s2">.</span><span class="s1">rmatvec</span><span class="s2">(</span><span class="s1">z</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">iteration </span><span class="s2">&gt; </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s1">ytilde </span><span class="s2">-= (</span><span class="s1">xi </span><span class="s2">* </span><span class="s1">delta </span><span class="s2">/ </span><span class="s1">epsilon</span><span class="s2">) * </span><span class="s1">p</span>
            <span class="s1">p</span><span class="s2">[:] = </span><span class="s1">ytilde</span><span class="s2">[:]</span>
            <span class="s1">ztilde </span><span class="s2">-= (</span><span class="s1">rho </span><span class="s2">* (</span><span class="s1">delta </span><span class="s2">/ </span><span class="s1">epsilon</span><span class="s2">).</span><span class="s1">conj</span><span class="s2">()) * </span><span class="s1">q</span>
            <span class="s1">q</span><span class="s2">[:] = </span><span class="s1">ztilde</span><span class="s2">[:]</span>
        <span class="s0">else</span><span class="s2">:  </span><span class="s6"># First spin</span>
            <span class="s1">p </span><span class="s2">= </span><span class="s1">ytilde</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s1">q </span><span class="s2">= </span><span class="s1">ztilde</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

        <span class="s1">ptilde </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>
        <span class="s1">epsilon </span><span class="s2">= </span><span class="s1">dotprod</span><span class="s2">(</span><span class="s1">q</span><span class="s2">, </span><span class="s1">ptilde</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">epsilon</span><span class="s2">) &lt; </span><span class="s1">epsilontol</span><span class="s2">:  </span><span class="s6"># epsilon breakdown</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), -</span><span class="s4">14</span>

        <span class="s1">beta </span><span class="s2">= </span><span class="s1">epsilon </span><span class="s2">/ </span><span class="s1">delta</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">beta</span><span class="s2">) &lt; </span><span class="s1">betatol</span><span class="s2">:  </span><span class="s6"># beta breakdown</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), -</span><span class="s4">11</span>

        <span class="s1">vtilde</span><span class="s2">[:] = </span><span class="s1">ptilde</span><span class="s2">[:]</span>
        <span class="s1">vtilde </span><span class="s2">-= </span><span class="s1">beta</span><span class="s2">*</span><span class="s1">v</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">M1</span><span class="s2">.</span><span class="s1">matvec</span><span class="s2">(</span><span class="s1">vtilde</span><span class="s2">)</span>

        <span class="s1">rho_prev </span><span class="s2">= </span><span class="s1">rho</span>
        <span class="s1">rho </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
        <span class="s1">wtilde</span><span class="s2">[:] = </span><span class="s1">w</span><span class="s2">[:]</span>
        <span class="s1">wtilde </span><span class="s2">*= - </span><span class="s1">beta</span><span class="s2">.</span><span class="s1">conj</span><span class="s2">()</span>
        <span class="s1">wtilde </span><span class="s2">+= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">rmatvec</span><span class="s2">(</span><span class="s1">q</span><span class="s2">)</span>
        <span class="s1">z </span><span class="s2">= </span><span class="s1">M2</span><span class="s2">.</span><span class="s1">rmatvec</span><span class="s2">(</span><span class="s1">wtilde</span><span class="s2">)</span>
        <span class="s1">xi </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">z</span><span class="s2">)</span>
        <span class="s1">gamma_prev </span><span class="s2">= </span><span class="s1">gamma</span>
        <span class="s1">theta_prev </span><span class="s2">= </span><span class="s1">theta</span>
        <span class="s1">theta </span><span class="s2">= </span><span class="s1">rho </span><span class="s2">/ (</span><span class="s1">gamma_prev </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">beta</span><span class="s2">))</span>
        <span class="s1">gamma </span><span class="s2">= </span><span class="s4">1 </span><span class="s2">/ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s4">1 </span><span class="s2">+ </span><span class="s1">theta</span><span class="s2">**</span><span class="s4">2</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">gamma</span><span class="s2">) &lt; </span><span class="s1">gammatol</span><span class="s2">:  </span><span class="s6"># gamma breakdown</span>
            <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), -</span><span class="s4">12</span>

        <span class="s1">eta </span><span class="s2">*= -(</span><span class="s1">rho_prev </span><span class="s2">/ </span><span class="s1">beta</span><span class="s2">) * (</span><span class="s1">gamma </span><span class="s2">/ </span><span class="s1">gamma_prev</span><span class="s2">)**</span><span class="s4">2</span>

        <span class="s0">if </span><span class="s1">iteration </span><span class="s2">&gt; </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s1">d </span><span class="s2">*= (</span><span class="s1">theta_prev </span><span class="s2">* </span><span class="s1">gamma</span><span class="s2">) ** </span><span class="s4">2</span>
            <span class="s1">d </span><span class="s2">+= </span><span class="s1">eta</span><span class="s2">*</span><span class="s1">p</span>
            <span class="s1">s </span><span class="s2">*= (</span><span class="s1">theta_prev </span><span class="s2">* </span><span class="s1">gamma</span><span class="s2">) ** </span><span class="s4">2</span>
            <span class="s1">s </span><span class="s2">+= </span><span class="s1">eta</span><span class="s2">*</span><span class="s1">ptilde</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">d </span><span class="s2">= </span><span class="s1">p</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s1">d </span><span class="s2">*= </span><span class="s1">eta</span>
            <span class="s1">s </span><span class="s2">= </span><span class="s1">ptilde</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s1">s </span><span class="s2">*= </span><span class="s1">eta</span>

        <span class="s1">x </span><span class="s2">+= </span><span class="s1">d</span>
        <span class="s1">r </span><span class="s2">-= </span><span class="s1">s</span>

        <span class="s0">if </span><span class="s1">callback</span><span class="s2">:</span>
            <span class="s1">callback</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s0">else</span><span class="s2">:  </span><span class="s6"># for loop exhausted</span>
        <span class="s6"># Return incomplete progress</span>
        <span class="s0">return </span><span class="s1">postprocess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s1">maxiter</span>
</pre>
</body>
</html>