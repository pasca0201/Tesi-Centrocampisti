<html>
<head>
<title>_testutils.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #7a7e85;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_testutils.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">_lib </span><span class="s0">import </span><span class="s1">_pep440</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">testing </span><span class="s0">import </span><span class="s1">assert_</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">special </span><span class="s0">as </span><span class="s1">sc</span>

<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">'with_special_errors'</span><span class="s2">, </span><span class="s3">'assert_func_equal'</span><span class="s2">, </span><span class="s3">'FuncData'</span><span class="s2">]</span>


<span class="s4">#------------------------------------------------------------------------------</span>
<span class="s4"># Check if a module is present to be used in tests</span>
<span class="s4">#------------------------------------------------------------------------------</span>

<span class="s0">class </span><span class="s1">MissingModule</span><span class="s2">:</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">name </span><span class="s2">= </span><span class="s1">name</span>


<span class="s0">def </span><span class="s1">check_version</span><span class="s2">(</span><span class="s1">module</span><span class="s2">, </span><span class="s1">min_ver</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">module</span><span class="s2">) == </span><span class="s1">MissingModule</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">skip</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">module</span><span class="s2">.</span><span class="s1">name</span><span class="s0">} </span><span class="s3">is not installed&quot;</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">skipif</span><span class="s2">(</span>
        <span class="s1">_pep440</span><span class="s2">.</span><span class="s1">parse</span><span class="s2">(</span><span class="s1">module</span><span class="s2">.</span><span class="s1">__version__</span><span class="s2">) &lt; </span><span class="s1">_pep440</span><span class="s2">.</span><span class="s1">Version</span><span class="s2">(</span><span class="s1">min_ver</span><span class="s2">),</span>
        <span class="s1">reason</span><span class="s2">=</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">module</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">} </span><span class="s3">version &gt;= </span><span class="s0">{</span><span class="s1">min_ver</span><span class="s0">} </span><span class="s3">required&quot;</span>
    <span class="s2">)</span>


<span class="s4">#------------------------------------------------------------------------------</span>
<span class="s4"># Enable convergence and loss of precision warnings -- turn off one by one</span>
<span class="s4">#------------------------------------------------------------------------------</span>

<span class="s0">def </span><span class="s1">with_special_errors</span><span class="s2">(</span><span class="s1">func</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Enable special function errors (such as underflow, overflow, 
    loss of precision, etc.) 
    &quot;&quot;&quot;</span>
    <span class="s2">@</span><span class="s1">functools</span><span class="s2">.</span><span class="s1">wraps</span><span class="s2">(</span><span class="s1">func</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">wrapper</span><span class="s2">(*</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">sc</span><span class="s2">.</span><span class="s1">errstate</span><span class="s2">(</span><span class="s1">all</span><span class="s2">=</span><span class="s3">'raise'</span><span class="s2">):</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">res</span>
    <span class="s0">return </span><span class="s1">wrapper</span>


<span class="s4">#------------------------------------------------------------------------------</span>
<span class="s4"># Comparing function values at many data points at once, with helpful</span>
<span class="s4"># error reports</span>
<span class="s4">#------------------------------------------------------------------------------</span>

<span class="s0">def </span><span class="s1">assert_func_equal</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">results</span><span class="s2">, </span><span class="s1">points</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                      <span class="s1">param_filter</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">knownfailure</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                      <span class="s1">vectorized</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">nan_ok</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
                      <span class="s1">ignore_inf_sign</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">distinguish_nan_and_inf</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">points</span><span class="s2">, </span><span class="s3">'next'</span><span class="s2">):</span>
        <span class="s4"># it's a generator</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

    <span class="s1">points </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">points</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">points</span><span class="s2">[:,</span><span class="s0">None</span><span class="s2">]</span>
    <span class="s1">nparams </span><span class="s2">= </span><span class="s1">points</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]</span>

    <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">results</span><span class="s2">, </span><span class="s3">'__name__'</span><span class="s2">):</span>
        <span class="s4"># function</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">points</span>
        <span class="s1">result_columns </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">result_func </span><span class="s2">= </span><span class="s1">results</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s4"># dataset</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">c_</span><span class="s2">[</span><span class="s1">points</span><span class="s2">, </span><span class="s1">results</span><span class="s2">]</span>
        <span class="s1">result_columns </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">nparams</span><span class="s2">, </span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]))</span>
        <span class="s1">result_func </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s1">fdata </span><span class="s2">= </span><span class="s1">FuncData</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">nparams</span><span class="s2">)),</span>
                     <span class="s1">result_columns</span><span class="s2">=</span><span class="s1">result_columns</span><span class="s2">, </span><span class="s1">result_func</span><span class="s2">=</span><span class="s1">result_func</span><span class="s2">,</span>
                     <span class="s1">rtol</span><span class="s2">=</span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">atol</span><span class="s2">, </span><span class="s1">param_filter</span><span class="s2">=</span><span class="s1">param_filter</span><span class="s2">,</span>
                     <span class="s1">knownfailure</span><span class="s2">=</span><span class="s1">knownfailure</span><span class="s2">, </span><span class="s1">nan_ok</span><span class="s2">=</span><span class="s1">nan_ok</span><span class="s2">, </span><span class="s1">vectorized</span><span class="s2">=</span><span class="s1">vectorized</span><span class="s2">,</span>
                     <span class="s1">ignore_inf_sign</span><span class="s2">=</span><span class="s1">ignore_inf_sign</span><span class="s2">,</span>
                     <span class="s1">distinguish_nan_and_inf</span><span class="s2">=</span><span class="s1">distinguish_nan_and_inf</span><span class="s2">)</span>
    <span class="s1">fdata</span><span class="s2">.</span><span class="s1">check</span><span class="s2">()</span>


<span class="s0">class </span><span class="s1">FuncData</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Data set for checking a special function. 
 
    Parameters 
    ---------- 
    func : function 
        Function to test 
    data : numpy array 
        columnar data to use for testing 
    param_columns : int or tuple of ints 
        Columns indices in which the parameters to `func` lie. 
        Can be imaginary integers to indicate that the parameter 
        should be cast to complex. 
    result_columns : int or tuple of ints, optional 
        Column indices for expected results from `func`. 
    result_func : callable, optional 
        Function to call to obtain results. 
    rtol : float, optional 
        Required relative tolerance. Default is 5*eps. 
    atol : float, optional 
        Required absolute tolerance. Default is 5*tiny. 
    param_filter : function, or tuple of functions/Nones, optional 
        Filter functions to exclude some parameter ranges. 
        If omitted, no filtering is done. 
    knownfailure : str, optional 
        Known failure error message to raise when the test is run. 
        If omitted, no exception is raised. 
    nan_ok : bool, optional 
        If nan is always an accepted result. 
    vectorized : bool, optional 
        Whether all functions passed in are vectorized. 
    ignore_inf_sign : bool, optional 
        Whether to ignore signs of infinities. 
        (Doesn't matter for complex-valued functions.) 
    distinguish_nan_and_inf : bool, optional 
        If True, treat numbers which contain nans or infs as 
        equal. Sets ignore_inf_sign to be True. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">param_columns</span><span class="s2">, </span><span class="s1">result_columns</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                 <span class="s1">result_func</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">param_filter</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                 <span class="s1">knownfailure</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">dataname</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">nan_ok</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">vectorized</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                 <span class="s1">ignore_inf_sign</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">distinguish_nan_and_inf</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">func </span><span class="s2">= </span><span class="s1">func</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">data</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">dataname </span><span class="s2">= </span><span class="s1">dataname</span>
        <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">param_columns</span><span class="s2">, </span><span class="s3">'__len__'</span><span class="s2">):</span>
            <span class="s1">param_columns </span><span class="s2">= (</span><span class="s1">param_columns</span><span class="s2">,)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">param_columns </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">param_columns</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">result_columns </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">result_columns</span><span class="s2">, </span><span class="s3">'__len__'</span><span class="s2">):</span>
                <span class="s1">result_columns </span><span class="s2">= (</span><span class="s1">result_columns</span><span class="s2">,)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">result_columns </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">result_columns</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">result_func </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">message </span><span class="s2">= </span><span class="s3">&quot;Only result_func or result_columns should be provided&quot;</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">result_func </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">result_columns </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Either result_func or result_columns should be provided&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">result_func </span><span class="s2">= </span><span class="s1">result_func</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">rtol </span><span class="s2">= </span><span class="s1">rtol</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">atol </span><span class="s2">= </span><span class="s1">atol</span>
        <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">param_filter</span><span class="s2">, </span><span class="s3">'__len__'</span><span class="s2">):</span>
            <span class="s1">param_filter </span><span class="s2">= (</span><span class="s1">param_filter</span><span class="s2">,)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">param_filter </span><span class="s2">= </span><span class="s1">param_filter</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">knownfailure </span><span class="s2">= </span><span class="s1">knownfailure</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">nan_ok </span><span class="s2">= </span><span class="s1">nan_ok</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">vectorized </span><span class="s2">= </span><span class="s1">vectorized</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ignore_inf_sign </span><span class="s2">= </span><span class="s1">ignore_inf_sign</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">distinguish_nan_and_inf </span><span class="s2">= </span><span class="s1">distinguish_nan_and_inf</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">distinguish_nan_and_inf</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">ignore_inf_sign </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">get_tolerances</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inexact</span><span class="s2">):</span>
            <span class="s1">dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">float</span><span class="s2">)</span>
        <span class="s1">info </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">rtol</span><span class="s2">, </span><span class="s1">atol </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">atol</span>
        <span class="s0">if </span><span class="s1">rtol </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">rtol </span><span class="s2">= </span><span class="s6">5</span><span class="s2">*</span><span class="s1">info</span><span class="s2">.</span><span class="s1">eps</span>
        <span class="s0">if </span><span class="s1">atol </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">atol </span><span class="s2">= </span><span class="s6">5</span><span class="s2">*</span><span class="s1">info</span><span class="s2">.</span><span class="s1">tiny</span>
        <span class="s0">return </span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">atol</span>

    <span class="s0">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">dtypes</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Check the special function against the data.&quot;&quot;&quot;</span>
        <span class="s1">__tracebackhide__ </span><span class="s2">= </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">methodcaller</span><span class="s2">(</span>
            <span class="s3">'errisinstance'</span><span class="s2">, </span><span class="s1">AssertionError</span>
        <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">knownfailure</span><span class="s2">:</span>
            <span class="s1">pytest</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">knownfailure</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">data </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>

        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">dtype </span><span class="s2">= </span><span class="s1">data</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">data</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s1">rtol</span><span class="s2">, </span><span class="s1">atol </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_tolerances</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s4"># Apply given filter functions</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">param_filter</span><span class="s2">:</span>
            <span class="s1">param_mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">((</span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">],), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">filter </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">param_columns</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">param_filter</span><span class="s2">):</span>
                <span class="s0">if </span><span class="s1">filter</span><span class="s2">:</span>
                    <span class="s1">param_mask </span><span class="s2">&amp;= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">filter</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[:,</span><span class="s1">j</span><span class="s2">]))</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">data</span><span class="s2">[</span><span class="s1">param_mask</span><span class="s2">]</span>

        <span class="s4"># Pick parameters from the correct columns</span>
        <span class="s1">params </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">param_columns</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">j</span><span class="s2">):</span>
                <span class="s1">j </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">j</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">)</span>
                <span class="s1">params</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[:,</span><span class="s1">j</span><span class="s2">].</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">complex</span><span class="s2">))</span>
            <span class="s0">elif </span><span class="s1">dtypes </span><span class="s0">and </span><span class="s1">idx </span><span class="s2">&lt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">dtypes</span><span class="s2">):</span>
                <span class="s1">params</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[:, </span><span class="s1">j</span><span class="s2">].</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtypes</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">]))</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">params</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[:,</span><span class="s1">j</span><span class="s2">])</span>

        <span class="s4"># Helper for evaluating results</span>
        <span class="s0">def </span><span class="s1">eval_func_at_params</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">skip_mask</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">vectorized</span><span class="s2">:</span>
                <span class="s1">got </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*</span><span class="s1">params</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">got </span><span class="s2">= []</span>
                <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">params</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])):</span>
                    <span class="s0">if </span><span class="s1">skip_mask </span><span class="s0">is not None and </span><span class="s1">skip_mask</span><span class="s2">[</span><span class="s1">j</span><span class="s2">]:</span>
                        <span class="s1">got</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">)</span>
                        <span class="s0">continue</span>
                    <span class="s1">got</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">func</span><span class="s2">(*</span><span class="s1">tuple</span><span class="s2">([</span><span class="s1">params</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s1">j</span><span class="s2">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">params</span><span class="s2">))])))</span>
                <span class="s1">got </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">got</span><span class="s2">)</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s1">got </span><span class="s2">= (</span><span class="s1">got</span><span class="s2">,)</span>
            <span class="s0">return </span><span class="s1">got</span>

        <span class="s4"># Evaluate function to be tested</span>
        <span class="s1">got </span><span class="s2">= </span><span class="s1">eval_func_at_params</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">)</span>

        <span class="s4"># Grab the correct results</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">result_columns </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s4"># Correct results passed in with the data</span>
            <span class="s1">wanted </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">([</span><span class="s1">data</span><span class="s2">[:,</span><span class="s1">icol</span><span class="s2">] </span><span class="s0">for </span><span class="s1">icol </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">result_columns</span><span class="s2">])</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s4"># Function producing correct results passed in</span>
            <span class="s1">skip_mask </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nan_ok </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">got</span><span class="s2">) == </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s4"># Don't spend time evaluating what doesn't need to be evaluated</span>
                <span class="s1">skip_mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">got</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>
            <span class="s1">wanted </span><span class="s2">= </span><span class="s1">eval_func_at_params</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">result_func</span><span class="s2">, </span><span class="s1">skip_mask</span><span class="s2">=</span><span class="s1">skip_mask</span><span class="s2">)</span>

        <span class="s4"># Check the validity of each output returned</span>
        <span class="s1">assert_</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">got</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">wanted</span><span class="s2">))</span>

        <span class="s0">for </span><span class="s1">output_num</span><span class="s2">, (</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">got</span><span class="s2">, </span><span class="s1">wanted</span><span class="s2">)):</span>
            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">complexfloating</span><span class="s2">) </span><span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ignore_inf_sign</span><span class="s2">:</span>
                <span class="s1">pinf_x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
                <span class="s1">pinf_y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
                <span class="s1">minf_x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
                <span class="s1">minf_y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">pinf_x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isposinf</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
                <span class="s1">pinf_y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isposinf</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
                <span class="s1">minf_x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isneginf</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
                <span class="s1">minf_y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isneginf</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
            <span class="s1">nan_x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
            <span class="s1">nan_y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>

            <span class="s0">with </span><span class="s1">np</span><span class="s2">.</span><span class="s1">errstate</span><span class="s2">(</span><span class="s1">all</span><span class="s2">=</span><span class="s3">'ignore'</span><span class="s2">):</span>
                <span class="s1">abs_y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">absolute</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
                <span class="s1">abs_y</span><span class="s2">[~</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">abs_y</span><span class="s2">)] = </span><span class="s6">0</span>
                <span class="s1">diff </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">absolute</span><span class="s2">(</span><span class="s1">x </span><span class="s2">- </span><span class="s1">y</span><span class="s2">)</span>
                <span class="s1">diff</span><span class="s2">[~</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">diff</span><span class="s2">)] = </span><span class="s6">0</span>

                <span class="s1">rdiff </span><span class="s2">= </span><span class="s1">diff </span><span class="s2">/ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">absolute</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
                <span class="s1">rdiff</span><span class="s2">[~</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">rdiff</span><span class="s2">)] = </span><span class="s6">0</span>

            <span class="s1">tol_mask </span><span class="s2">= (</span><span class="s1">diff </span><span class="s2">&lt;= </span><span class="s1">atol </span><span class="s2">+ </span><span class="s1">rtol</span><span class="s2">*</span><span class="s1">abs_y</span><span class="s2">)</span>
            <span class="s1">pinf_mask </span><span class="s2">= (</span><span class="s1">pinf_x </span><span class="s2">== </span><span class="s1">pinf_y</span><span class="s2">)</span>
            <span class="s1">minf_mask </span><span class="s2">= (</span><span class="s1">minf_x </span><span class="s2">== </span><span class="s1">minf_y</span><span class="s2">)</span>

            <span class="s1">nan_mask </span><span class="s2">= (</span><span class="s1">nan_x </span><span class="s2">== </span><span class="s1">nan_y</span><span class="s2">)</span>

            <span class="s1">bad_j </span><span class="s2">= ~(</span><span class="s1">tol_mask </span><span class="s2">&amp; </span><span class="s1">pinf_mask </span><span class="s2">&amp; </span><span class="s1">minf_mask </span><span class="s2">&amp; </span><span class="s1">nan_mask</span><span class="s2">)</span>

            <span class="s1">point_count </span><span class="s2">= </span><span class="s1">bad_j</span><span class="s2">.</span><span class="s1">size</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nan_ok</span><span class="s2">:</span>
                <span class="s1">bad_j </span><span class="s2">&amp;= ~</span><span class="s1">nan_x</span>
                <span class="s1">bad_j </span><span class="s2">&amp;= ~</span><span class="s1">nan_y</span>
                <span class="s1">point_count </span><span class="s2">-= (</span><span class="s1">nan_x </span><span class="s2">| </span><span class="s1">nan_y</span><span class="s2">).</span><span class="s1">sum</span><span class="s2">()</span>

            <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">distinguish_nan_and_inf </span><span class="s0">and not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nan_ok</span><span class="s2">:</span>
                <span class="s4"># If nan's are okay we've already covered all these cases</span>
                <span class="s1">inf_x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
                <span class="s1">inf_y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
                <span class="s1">both_nonfinite </span><span class="s2">= (</span><span class="s1">inf_x </span><span class="s2">&amp; </span><span class="s1">nan_y</span><span class="s2">) | (</span><span class="s1">nan_x </span><span class="s2">&amp; </span><span class="s1">inf_y</span><span class="s2">)</span>
                <span class="s1">bad_j </span><span class="s2">&amp;= ~</span><span class="s1">both_nonfinite</span>
                <span class="s1">point_count </span><span class="s2">-= </span><span class="s1">both_nonfinite</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">()</span>

            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">bad_j</span><span class="s2">):</span>
                <span class="s4"># Some bad results: inform what, where, and how bad</span>
                <span class="s1">msg </span><span class="s2">= [</span><span class="s3">&quot;&quot;</span><span class="s2">]</span>
                <span class="s1">msg</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">&quot;Max |adiff|: %g&quot; </span><span class="s2">% </span><span class="s1">diff</span><span class="s2">[</span><span class="s1">bad_j</span><span class="s2">].</span><span class="s1">max</span><span class="s2">())</span>
                <span class="s1">msg</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">&quot;Max |rdiff|: %g&quot; </span><span class="s2">% </span><span class="s1">rdiff</span><span class="s2">[</span><span class="s1">bad_j</span><span class="s2">].</span><span class="s1">max</span><span class="s2">())</span>
                <span class="s1">msg</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">&quot;Bad results (%d out of %d) for the following points &quot;</span>
                           <span class="s3">&quot;(in output %d):&quot;</span>
                           <span class="s2">% (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">bad_j</span><span class="s2">), </span><span class="s1">point_count</span><span class="s2">, </span><span class="s1">output_num</span><span class="s2">,))</span>
                <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">(</span><span class="s1">bad_j</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">]:</span>
                    <span class="s1">j </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">j</span><span class="s2">)</span>
                    <span class="s0">def </span><span class="s1">fmt</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
                        <span class="s0">return </span><span class="s3">'%30s' </span><span class="s2">% </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array2string</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[</span><span class="s1">j</span><span class="s2">], </span><span class="s1">precision</span><span class="s2">=</span><span class="s6">18</span><span class="s2">)</span>
                    <span class="s1">a </span><span class="s2">= </span><span class="s3">&quot;  &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">params</span><span class="s2">))</span>
                    <span class="s1">b </span><span class="s2">= </span><span class="s3">&quot;  &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">got</span><span class="s2">))</span>
                    <span class="s1">c </span><span class="s2">= </span><span class="s3">&quot;  &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">wanted</span><span class="s2">))</span>
                    <span class="s1">d </span><span class="s2">= </span><span class="s1">fmt</span><span class="s2">(</span><span class="s1">rdiff</span><span class="s2">)</span>
                    <span class="s1">msg</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">a</span><span class="s0">} </span><span class="s3">=&gt; </span><span class="s0">{</span><span class="s1">b</span><span class="s0">} </span><span class="s3">!= </span><span class="s0">{</span><span class="s1">c</span><span class="s0">}  </span><span class="s3">(rdiff </span><span class="s0">{</span><span class="s1">d</span><span class="s0">}</span><span class="s3">)&quot;</span><span class="s2">)</span>
                <span class="s1">assert_</span><span class="s2">(</span><span class="s0">False</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;Pretty-printing, esp. for Nose output&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">param_columns</span><span class="s2">))):</span>
            <span class="s1">is_complex </span><span class="s2">= </span><span class="s3">&quot; (complex)&quot;</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">is_complex </span><span class="s2">= </span><span class="s3">&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dataname</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s3">&quot;&lt;Data for {}{}: {}&gt;&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, </span><span class="s1">is_complex</span><span class="s2">,</span>
                                            <span class="s1">os</span><span class="s2">.</span><span class="s1">path</span><span class="s2">.</span><span class="s1">basename</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dataname</span><span class="s2">))</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s3">f&quot;&lt;Data for </span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">}{</span><span class="s1">is_complex</span><span class="s0">}</span><span class="s3">&gt;&quot;</span>
</pre>
</body>
</html>