<html>
<head>
<title>_filter_design.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_filter_design.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Filter design.&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s3">(</span><span class="s1">atleast_1d</span><span class="s3">, </span><span class="s1">poly</span><span class="s3">, </span><span class="s1">polyval</span><span class="s3">, </span><span class="s1">roots</span><span class="s3">, </span><span class="s1">real</span><span class="s3">, </span><span class="s1">asarray</span><span class="s3">,</span>
                   <span class="s1">resize</span><span class="s3">, </span><span class="s1">pi</span><span class="s3">, </span><span class="s1">absolute</span><span class="s3">, </span><span class="s1">sqrt</span><span class="s3">, </span><span class="s1">tan</span><span class="s3">, </span><span class="s1">log10</span><span class="s3">,</span>
                   <span class="s1">arcsinh</span><span class="s3">, </span><span class="s1">sin</span><span class="s3">, </span><span class="s1">exp</span><span class="s3">, </span><span class="s1">cosh</span><span class="s3">, </span><span class="s1">arccosh</span><span class="s3">, </span><span class="s1">ceil</span><span class="s3">, </span><span class="s1">conjugate</span><span class="s3">,</span>
                   <span class="s1">zeros</span><span class="s3">, </span><span class="s1">sinh</span><span class="s3">, </span><span class="s1">append</span><span class="s3">, </span><span class="s1">concatenate</span><span class="s3">, </span><span class="s1">prod</span><span class="s3">, </span><span class="s1">ones</span><span class="s3">, </span><span class="s1">full</span><span class="s3">, </span><span class="s1">array</span><span class="s3">,</span>
                   <span class="s1">mintypecode</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">polynomial</span><span class="s3">.</span><span class="s1">polynomial </span><span class="s2">import </span><span class="s1">polyval </span><span class="s2">as </span><span class="s1">npp_polyval</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">polynomial</span><span class="s3">.</span><span class="s1">polynomial </span><span class="s2">import </span><span class="s1">polyvalfromroots</span>

<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">special</span><span class="s3">, </span><span class="s1">optimize</span><span class="s3">, </span><span class="s1">fft </span><span class="s2">as </span><span class="s1">sp_fft</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special </span><span class="s2">import </span><span class="s1">comb</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">_lib</span><span class="s3">.</span><span class="s1">_util </span><span class="s2">import </span><span class="s1">float_factorial</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">signal</span><span class="s3">.</span><span class="s1">_arraytools </span><span class="s2">import </span><span class="s1">_validate_fs</span>


<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">'findfreqs'</span><span class="s3">, </span><span class="s4">'freqs'</span><span class="s3">, </span><span class="s4">'freqz'</span><span class="s3">, </span><span class="s4">'tf2zpk'</span><span class="s3">, </span><span class="s4">'zpk2tf'</span><span class="s3">, </span><span class="s4">'normalize'</span><span class="s3">,</span>
           <span class="s4">'lp2lp'</span><span class="s3">, </span><span class="s4">'lp2hp'</span><span class="s3">, </span><span class="s4">'lp2bp'</span><span class="s3">, </span><span class="s4">'lp2bs'</span><span class="s3">, </span><span class="s4">'bilinear'</span><span class="s3">, </span><span class="s4">'iirdesign'</span><span class="s3">,</span>
           <span class="s4">'iirfilter'</span><span class="s3">, </span><span class="s4">'butter'</span><span class="s3">, </span><span class="s4">'cheby1'</span><span class="s3">, </span><span class="s4">'cheby2'</span><span class="s3">, </span><span class="s4">'ellip'</span><span class="s3">, </span><span class="s4">'bessel'</span><span class="s3">,</span>
           <span class="s4">'band_stop_obj'</span><span class="s3">, </span><span class="s4">'buttord'</span><span class="s3">, </span><span class="s4">'cheb1ord'</span><span class="s3">, </span><span class="s4">'cheb2ord'</span><span class="s3">, </span><span class="s4">'ellipord'</span><span class="s3">,</span>
           <span class="s4">'buttap'</span><span class="s3">, </span><span class="s4">'cheb1ap'</span><span class="s3">, </span><span class="s4">'cheb2ap'</span><span class="s3">, </span><span class="s4">'ellipap'</span><span class="s3">, </span><span class="s4">'besselap'</span><span class="s3">,</span>
           <span class="s4">'BadCoefficients'</span><span class="s3">, </span><span class="s4">'freqs_zpk'</span><span class="s3">, </span><span class="s4">'freqz_zpk'</span><span class="s3">,</span>
           <span class="s4">'tf2sos'</span><span class="s3">, </span><span class="s4">'sos2tf'</span><span class="s3">, </span><span class="s4">'zpk2sos'</span><span class="s3">, </span><span class="s4">'sos2zpk'</span><span class="s3">, </span><span class="s4">'group_delay'</span><span class="s3">,</span>
           <span class="s4">'sosfreqz'</span><span class="s3">, </span><span class="s4">'iirnotch'</span><span class="s3">, </span><span class="s4">'iirpeak'</span><span class="s3">, </span><span class="s4">'bilinear_zpk'</span><span class="s3">,</span>
           <span class="s4">'lp2lp_zpk'</span><span class="s3">, </span><span class="s4">'lp2hp_zpk'</span><span class="s3">, </span><span class="s4">'lp2bp_zpk'</span><span class="s3">, </span><span class="s4">'lp2bs_zpk'</span><span class="s3">,</span>
           <span class="s4">'gammatone'</span><span class="s3">, </span><span class="s4">'iircomb'</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">BadCoefficients</span><span class="s3">(</span><span class="s1">UserWarning</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Warning about badly conditioned filter coefficients&quot;&quot;&quot;</span>
    <span class="s2">pass</span>


<span class="s1">abs </span><span class="s3">= </span><span class="s1">absolute</span>


<span class="s2">def </span><span class="s1">_is_int_type</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check if input is of a scalar integer type (so ``5`` and ``array(5)`` will 
    pass, while ``5.0`` and ``array([5])`` will fail. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) != </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s6"># Older versions of NumPy did not raise for np.array([1]).__index__()</span>
        <span class="s6"># This is safe to remove when support for those versions is dropped</span>
        <span class="s2">return False</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">operator</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">TypeError</span><span class="s3">:</span>
        <span class="s2">return False</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">findfreqs</span><span class="s3">(</span><span class="s1">num</span><span class="s3">, </span><span class="s1">den</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">=</span><span class="s4">'ba'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find array of frequencies for computing the response of an analog filter. 
 
    Parameters 
    ---------- 
    num, den : array_like, 1-D 
        The polynomial coefficients of the numerator and denominator of the 
        transfer function of the filter or LTI system, where the coefficients 
        are ordered from highest to lowest degree. Or, the roots  of the 
        transfer function numerator and denominator (i.e., zeroes and poles). 
    N : int 
        The length of the array to be computed. 
    kind : str {'ba', 'zp'}, optional 
        Specifies whether the numerator and denominator are specified by their 
        polynomial coefficients ('ba'), or their roots ('zp'). 
 
    Returns 
    ------- 
    w : (N,) ndarray 
        A 1-D array of frequencies, logarithmically spaced. 
 
    Examples 
    -------- 
    Find a set of nine frequencies that span the &quot;interesting part&quot; of the 
    frequency response for the filter with the transfer function 
 
        H(s) = s / (s^2 + 8s + 25) 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; signal.findfreqs([1, 0], [1, 8, 25], N=9) 
    array([  1.00000000e-02,   3.16227766e-02,   1.00000000e-01, 
             3.16227766e-01,   1.00000000e+00,   3.16227766e+00, 
             1.00000000e+01,   3.16227766e+01,   1.00000000e+02]) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'ba'</span><span class="s3">:</span>
        <span class="s1">ep </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">roots</span><span class="s3">(</span><span class="s1">den</span><span class="s3">)) + </span><span class="s5">0j</span>
        <span class="s1">tz </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">roots</span><span class="s3">(</span><span class="s1">num</span><span class="s3">)) + </span><span class="s5">0j</span>
    <span class="s2">elif </span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'zp'</span><span class="s3">:</span>
        <span class="s1">ep </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">den</span><span class="s3">) + </span><span class="s5">0j</span>
        <span class="s1">tz </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">num</span><span class="s3">) + </span><span class="s5">0j</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;input must be one of {'ba', 'zp'}&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">ep</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">ep </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(-</span><span class="s5">1000</span><span class="s3">) + </span><span class="s5">0j</span>

    <span class="s1">ez </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">r_</span><span class="s3">[</span><span class="s1">ep</span><span class="s3">[</span><span class="s1">ep</span><span class="s3">.</span><span class="s1">imag </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">], </span><span class="s1">tz</span><span class="s3">[(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">tz</span><span class="s3">) &lt; </span><span class="s5">1e5</span><span class="s3">) &amp; (</span><span class="s1">tz</span><span class="s3">.</span><span class="s1">imag </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">)]]</span>

    <span class="s1">integ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">ez</span><span class="s3">) &lt; </span><span class="s5">1e-10</span>
    <span class="s1">hfreq </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">log10</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s5">3 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">ez</span><span class="s3">.</span><span class="s1">real </span><span class="s3">+ </span><span class="s1">integ</span><span class="s3">) +</span>
                                     <span class="s5">1.5 </span><span class="s3">* </span><span class="s1">ez</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">)) + </span><span class="s5">0.5</span><span class="s3">)</span>
    <span class="s1">lfreq </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">round</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">log10</span><span class="s3">(</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">((</span><span class="s1">ez </span><span class="s3">+ </span><span class="s1">integ</span><span class="s3">).</span><span class="s1">real</span><span class="s3">) +</span>
                                           <span class="s5">2 </span><span class="s3">* </span><span class="s1">ez</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">)) - </span><span class="s5">0.5</span><span class="s3">)</span>

    <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">logspace</span><span class="s3">(</span><span class="s1">lfreq</span><span class="s3">, </span><span class="s1">hfreq</span><span class="s3">, </span><span class="s1">N</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">w</span>


<span class="s2">def </span><span class="s1">freqs</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">worN</span><span class="s3">=</span><span class="s5">200</span><span class="s3">, </span><span class="s1">plot</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute frequency response of analog filter. 
 
    Given the M-order numerator `b` and N-order denominator `a` of an analog 
    filter, compute its frequency response:: 
 
             b[0]*(jw)**M + b[1]*(jw)**(M-1) + ... + b[M] 
     H(w) = ---------------------------------------------- 
             a[0]*(jw)**N + a[1]*(jw)**(N-1) + ... + a[N] 
 
    Parameters 
    ---------- 
    b : array_like 
        Numerator of a linear filter. 
    a : array_like 
        Denominator of a linear filter. 
    worN : {None, int, array_like}, optional 
        If None, then compute at 200 frequencies around the interesting parts 
        of the response curve (determined by pole-zero locations). If a single 
        integer, then compute at that many frequencies. Otherwise, compute the 
        response at the angular frequencies (e.g., rad/s) given in `worN`. 
    plot : callable, optional 
        A callable that takes two arguments. If given, the return parameters 
        `w` and `h` are passed to plot. Useful for plotting the frequency 
        response inside `freqs`. 
 
    Returns 
    ------- 
    w : ndarray 
        The angular frequencies at which `h` was computed. 
    h : ndarray 
        The frequency response. 
 
    See Also 
    -------- 
    freqz : Compute the frequency response of a digital filter. 
 
    Notes 
    ----- 
    Using Matplotlib's &quot;plot&quot; function as the callable for `plot` produces 
    unexpected results, this plots the real part of the complex transfer 
    function, not the magnitude. Try ``lambda w, h: plot(w, abs(h))``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.signal import freqs, iirfilter 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; b, a = iirfilter(4, [1, 10], 1, 60, analog=True, ftype='cheby1') 
 
    &gt;&gt;&gt; w, h = freqs(b, a, worN=np.logspace(-1, 2, 1000)) 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h))) 
    &gt;&gt;&gt; plt.xlabel('Frequency') 
    &gt;&gt;&gt; plt.ylabel('Amplitude response [dB]') 
    &gt;&gt;&gt; plt.grid(True) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">worN </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s6"># For backwards compatibility</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">findfreqs</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s5">200</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">_is_int_type</span><span class="s3">(</span><span class="s1">worN</span><span class="s3">):</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">findfreqs</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">worN</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">worN</span><span class="s3">)</span>

    <span class="s1">s </span><span class="s3">= </span><span class="s5">1j </span><span class="s3">* </span><span class="s1">w</span>
    <span class="s1">h </span><span class="s3">= </span><span class="s1">polyval</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">s</span><span class="s3">) / </span><span class="s1">polyval</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">s</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">plot </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">plot</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">h</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h</span>


<span class="s2">def </span><span class="s1">freqs_zpk</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">worN</span><span class="s3">=</span><span class="s5">200</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute frequency response of analog filter. 
 
    Given the zeros `z`, poles `p`, and gain `k` of a filter, compute its 
    frequency response:: 
 
                (jw-z[0]) * (jw-z[1]) * ... * (jw-z[-1]) 
     H(w) = k * ---------------------------------------- 
                (jw-p[0]) * (jw-p[1]) * ... * (jw-p[-1]) 
 
    Parameters 
    ---------- 
    z : array_like 
        Zeroes of a linear filter 
    p : array_like 
        Poles of a linear filter 
    k : scalar 
        Gain of a linear filter 
    worN : {None, int, array_like}, optional 
        If None, then compute at 200 frequencies around the interesting parts 
        of the response curve (determined by pole-zero locations). If a single 
        integer, then compute at that many frequencies. Otherwise, compute the 
        response at the angular frequencies (e.g., rad/s) given in `worN`. 
 
    Returns 
    ------- 
    w : ndarray 
        The angular frequencies at which `h` was computed. 
    h : ndarray 
        The frequency response. 
 
    See Also 
    -------- 
    freqs : Compute the frequency response of an analog filter in TF form 
    freqz : Compute the frequency response of a digital filter in TF form 
    freqz_zpk : Compute the frequency response of a digital filter in ZPK form 
 
    Notes 
    ----- 
    .. versionadded:: 0.19.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal import freqs_zpk, iirfilter 
 
    &gt;&gt;&gt; z, p, k = iirfilter(4, [1, 10], 1, 60, analog=True, ftype='cheby1', 
    ...                     output='zpk') 
 
    &gt;&gt;&gt; w, h = freqs_zpk(z, p, k, worN=np.logspace(-1, 2, 1000)) 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h))) 
    &gt;&gt;&gt; plt.xlabel('Frequency') 
    &gt;&gt;&gt; plt.ylabel('Amplitude response [dB]') 
    &gt;&gt;&gt; plt.grid(True) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">k</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'k must be a single scalar gain'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">worN </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s6"># For backwards compatibility</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">findfreqs</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s5">200</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">=</span><span class="s4">'zp'</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">_is_int_type</span><span class="s3">(</span><span class="s1">worN</span><span class="s3">):</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">findfreqs</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">worN</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">=</span><span class="s4">'zp'</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">worN</span>

    <span class="s1">w </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">w</span><span class="s3">)</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s5">1j </span><span class="s3">* </span><span class="s1">w</span>
    <span class="s1">num </span><span class="s3">= </span><span class="s1">polyvalfromroots</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">z</span><span class="s3">)</span>
    <span class="s1">den </span><span class="s3">= </span><span class="s1">polyvalfromroots</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>
    <span class="s1">h </span><span class="s3">= </span><span class="s1">k </span><span class="s3">* </span><span class="s1">num</span><span class="s3">/</span><span class="s1">den</span>
    <span class="s2">return </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h</span>


<span class="s2">def </span><span class="s1">freqz</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">worN</span><span class="s3">=</span><span class="s5">512</span><span class="s3">, </span><span class="s1">whole</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">plot</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">2</span><span class="s3">*</span><span class="s1">pi</span><span class="s3">,</span>
          <span class="s1">include_nyquist</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the frequency response of a digital filter. 
 
    Given the M-order numerator `b` and N-order denominator `a` of a digital 
    filter, compute its frequency response:: 
 
                 jw                 -jw              -jwM 
        jw    B(e  )    b[0] + b[1]e    + ... + b[M]e 
     H(e  ) = ------ = ----------------------------------- 
                 jw                 -jw              -jwN 
              A(e  )    a[0] + a[1]e    + ... + a[N]e 
 
    Parameters 
    ---------- 
    b : array_like 
        Numerator of a linear filter. If `b` has dimension greater than 1, 
        it is assumed that the coefficients are stored in the first dimension, 
        and ``b.shape[1:]``, ``a.shape[1:]``, and the shape of the frequencies 
        array must be compatible for broadcasting. 
    a : array_like 
        Denominator of a linear filter. If `b` has dimension greater than 1, 
        it is assumed that the coefficients are stored in the first dimension, 
        and ``b.shape[1:]``, ``a.shape[1:]``, and the shape of the frequencies 
        array must be compatible for broadcasting. 
    worN : {None, int, array_like}, optional 
        If a single integer, then compute at that many frequencies (default is 
        N=512). This is a convenient alternative to:: 
 
            np.linspace(0, fs if whole else fs/2, N, endpoint=include_nyquist) 
 
        Using a number that is fast for FFT computations can result in 
        faster computations (see Notes). 
 
        If an array_like, compute the response at the frequencies given. 
        These are in the same units as `fs`. 
    whole : bool, optional 
        Normally, frequencies are computed from 0 to the Nyquist frequency, 
        fs/2 (upper-half of unit-circle). If `whole` is True, compute 
        frequencies from 0 to fs. Ignored if worN is array_like. 
    plot : callable 
        A callable that takes two arguments. If given, the return parameters 
        `w` and `h` are passed to plot. Useful for plotting the frequency 
        response inside `freqz`. 
    fs : float, optional 
        The sampling frequency of the digital system. Defaults to 2*pi 
        radians/sample (so w is from 0 to pi). 
 
        .. versionadded:: 1.2.0 
    include_nyquist : bool, optional 
        If `whole` is False and `worN` is an integer, setting `include_nyquist` 
        to True will include the last frequency (Nyquist frequency) and is 
        otherwise ignored. 
 
        .. versionadded:: 1.5.0 
 
    Returns 
    ------- 
    w : ndarray 
        The frequencies at which `h` was computed, in the same units as `fs`. 
        By default, `w` is normalized to the range [0, pi) (radians/sample). 
    h : ndarray 
        The frequency response, as complex numbers. 
 
    See Also 
    -------- 
    freqz_zpk 
    sosfreqz 
 
    Notes 
    ----- 
    Using Matplotlib's :func:`matplotlib.pyplot.plot` function as the callable 
    for `plot` produces unexpected results, as this plots the real part of the 
    complex transfer function, not the magnitude. 
    Try ``lambda w, h: plot(w, np.abs(h))``. 
 
    A direct computation via (R)FFT is used to compute the frequency response 
    when the following conditions are met: 
 
    1. An integer value is given for `worN`. 
    2. `worN` is fast to compute via FFT (i.e., 
       `next_fast_len(worN) &lt;scipy.fft.next_fast_len&gt;` equals `worN`). 
    3. The denominator coefficients are a single value (``a.shape[0] == 1``). 
    4. `worN` is at least as long as the numerator coefficients 
       (``worN &gt;= b.shape[0]``). 
    5. If ``b.ndim &gt; 1``, then ``b.shape[-1] == 1``. 
 
    For long FIR filters, the FFT approach can have lower error and be much 
    faster than the equivalent direct polynomial calculation. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; b = signal.firwin(80, 0.5, window=('kaiser', 8)) 
    &gt;&gt;&gt; w, h = signal.freqz(b) 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax1 = plt.subplots() 
    &gt;&gt;&gt; ax1.set_title('Digital filter frequency response') 
 
    &gt;&gt;&gt; ax1.plot(w, 20 * np.log10(abs(h)), 'b') 
    &gt;&gt;&gt; ax1.set_ylabel('Amplitude [dB]', color='b') 
    &gt;&gt;&gt; ax1.set_xlabel('Frequency [rad/sample]') 
 
    &gt;&gt;&gt; ax2 = ax1.twinx() 
    &gt;&gt;&gt; angles = np.unwrap(np.angle(h)) 
    &gt;&gt;&gt; ax2.plot(w, angles, 'g') 
    &gt;&gt;&gt; ax2.set_ylabel('Angle (radians)', color='g') 
    &gt;&gt;&gt; ax2.grid(True) 
    &gt;&gt;&gt; ax2.axis('tight') 
    &gt;&gt;&gt; plt.show() 
 
    Broadcasting Examples 
 
    Suppose we have two FIR filters whose coefficients are stored in the 
    rows of an array with shape (2, 25). For this demonstration, we'll 
    use random data: 
 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; b = rng.random((2, 25)) 
 
    To compute the frequency response for these two filters with one call 
    to `freqz`, we must pass in ``b.T``, because `freqz` expects the first 
    axis to hold the coefficients. We must then extend the shape with a 
    trivial dimension of length 1 to allow broadcasting with the array 
    of frequencies.  That is, we pass in ``b.T[..., np.newaxis]``, which has 
    shape (25, 2, 1): 
 
    &gt;&gt;&gt; w, h = signal.freqz(b.T[..., np.newaxis], worN=1024) 
    &gt;&gt;&gt; w.shape 
    (1024,) 
    &gt;&gt;&gt; h.shape 
    (2, 1024) 
 
    Now, suppose we have two transfer functions, with the same numerator 
    coefficients ``b = [0.5, 0.5]``. The coefficients for the two denominators 
    are stored in the first dimension of the 2-D array  `a`:: 
 
        a = [   1      1  ] 
            [ -0.25, -0.5 ] 
 
    &gt;&gt;&gt; b = np.array([0.5, 0.5]) 
    &gt;&gt;&gt; a = np.array([[1, 1], [-0.25, -0.5]]) 
 
    Only `a` is more than 1-D. To make it compatible for 
    broadcasting with the frequencies, we extend it with a trivial dimension 
    in the call to `freqz`: 
 
    &gt;&gt;&gt; w, h = signal.freqz(b, a[..., np.newaxis], worN=1024) 
    &gt;&gt;&gt; w.shape 
    (1024,) 
    &gt;&gt;&gt; h.shape 
    (2, 1024) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">b </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">worN </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s6"># For backwards compatibility</span>
        <span class="s1">worN </span><span class="s3">= </span><span class="s5">512</span>

    <span class="s1">h </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">if </span><span class="s1">_is_int_type</span><span class="s3">(</span><span class="s1">worN</span><span class="s3">):</span>
        <span class="s1">N </span><span class="s3">= </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">worN</span><span class="s3">)</span>
        <span class="s2">del </span><span class="s1">worN</span>
        <span class="s2">if </span><span class="s1">N </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f'worN must be nonnegative, got </span><span class="s2">{</span><span class="s1">N</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
        <span class="s1">lastpoint </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">pi </span><span class="s2">if </span><span class="s1">whole </span><span class="s2">else </span><span class="s1">pi</span>
        <span class="s6"># if include_nyquist is true and whole is false, w should</span>
        <span class="s6"># include end point</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">lastpoint</span><span class="s3">, </span><span class="s1">N</span><span class="s3">,</span>
                        <span class="s1">endpoint</span><span class="s3">=</span><span class="s1">include_nyquist </span><span class="s2">and not </span><span class="s1">whole</span><span class="s3">)</span>
        <span class="s1">n_fft </span><span class="s3">= </span><span class="s1">N </span><span class="s2">if </span><span class="s1">whole </span><span class="s2">else </span><span class="s5">2 </span><span class="s3">* (</span><span class="s1">N </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) </span><span class="s2">if </span><span class="s1">include_nyquist </span><span class="s2">else </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">N</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">1 </span><span class="s2">and </span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1 </span><span class="s2">or </span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] == </span><span class="s5">1</span><span class="s3">))</span>
                <span class="s2">and </span><span class="s1">n_fft </span><span class="s3">&gt;= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
                <span class="s2">and </span><span class="s1">n_fft </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">):  </span><span class="s6"># TODO: review threshold acc. to benchmark?</span>
            <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isrealobj</span><span class="s3">(</span><span class="s1">b</span><span class="s3">) </span><span class="s2">and </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isrealobj</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
                <span class="s1">fft_func </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">rfft</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">fft_func </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">fft</span>
            <span class="s1">h </span><span class="s3">= </span><span class="s1">fft_func</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s1">n_fft</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)[:</span><span class="s1">N</span><span class="s3">]</span>
            <span class="s1">h </span><span class="s3">/= </span><span class="s1">a</span>
            <span class="s2">if </span><span class="s1">fft_func </span><span class="s2">is </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">rfft </span><span class="s2">and </span><span class="s1">whole</span><span class="s3">:</span>
                <span class="s6"># exclude DC and maybe Nyquist (no need to use axis_reverse</span>
                <span class="s6"># here because we can build reversal with the truncation)</span>
                <span class="s1">stop </span><span class="s3">= -</span><span class="s5">1 </span><span class="s2">if </span><span class="s1">n_fft </span><span class="s3">% </span><span class="s5">2 </span><span class="s3">== </span><span class="s5">1 </span><span class="s2">else </span><span class="s3">-</span><span class="s5">2</span>
                <span class="s1">h_flip </span><span class="s3">= </span><span class="s1">slice</span><span class="s3">(</span><span class="s1">stop</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)</span>
                <span class="s1">h </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">h</span><span class="s3">, </span><span class="s1">h</span><span class="s3">[</span><span class="s1">h_flip</span><span class="s3">].</span><span class="s1">conj</span><span class="s3">()))</span>
            <span class="s2">if </span><span class="s1">b</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s6"># Last axis of h has length 1, so drop it.</span>
                <span class="s1">h </span><span class="s3">= </span><span class="s1">h</span><span class="s3">[..., </span><span class="s5">0</span><span class="s3">]</span>
                <span class="s6"># Move the first axis of h to the end.</span>
                <span class="s1">h </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">h</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">worN</span><span class="s3">)</span>
        <span class="s2">del </span><span class="s1">worN</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s5">2</span><span class="s3">*</span><span class="s1">pi</span><span class="s3">*</span><span class="s1">w</span><span class="s3">/</span><span class="s1">fs</span>

    <span class="s2">if </span><span class="s1">h </span><span class="s2">is None</span><span class="s3">:  </span><span class="s6"># still need to compute using freqs w</span>
        <span class="s1">zm1 </span><span class="s3">= </span><span class="s1">exp</span><span class="s3">(-</span><span class="s5">1j </span><span class="s3">* </span><span class="s1">w</span><span class="s3">)</span>
        <span class="s1">h </span><span class="s3">= (</span><span class="s1">npp_polyval</span><span class="s3">(</span><span class="s1">zm1</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">tensor</span><span class="s3">=</span><span class="s2">False</span><span class="s3">) /</span>
             <span class="s1">npp_polyval</span><span class="s3">(</span><span class="s1">zm1</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">tensor</span><span class="s3">=</span><span class="s2">False</span><span class="s3">))</span>

    <span class="s1">w </span><span class="s3">= </span><span class="s1">w</span><span class="s3">*(</span><span class="s1">fs</span><span class="s3">/(</span><span class="s5">2</span><span class="s3">*</span><span class="s1">pi</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s1">plot </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">plot</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">h</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h</span>


<span class="s2">def </span><span class="s1">freqz_zpk</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">worN</span><span class="s3">=</span><span class="s5">512</span><span class="s3">, </span><span class="s1">whole</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">2</span><span class="s3">*</span><span class="s1">pi</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Compute the frequency response of a digital filter in ZPK form. 
 
    Given the Zeros, Poles and Gain of a digital filter, compute its frequency 
    response: 
 
    :math:`H(z)=k \prod_i (z - Z[i]) / \prod_j (z - P[j])` 
 
    where :math:`k` is the `gain`, :math:`Z` are the `zeros` and :math:`P` are 
    the `poles`. 
 
    Parameters 
    ---------- 
    z : array_like 
        Zeroes of a linear filter 
    p : array_like 
        Poles of a linear filter 
    k : scalar 
        Gain of a linear filter 
    worN : {None, int, array_like}, optional 
        If a single integer, then compute at that many frequencies (default is 
        N=512). 
 
        If an array_like, compute the response at the frequencies given. 
        These are in the same units as `fs`. 
    whole : bool, optional 
        Normally, frequencies are computed from 0 to the Nyquist frequency, 
        fs/2 (upper-half of unit-circle). If `whole` is True, compute 
        frequencies from 0 to fs. Ignored if w is array_like. 
    fs : float, optional 
        The sampling frequency of the digital system. Defaults to 2*pi 
        radians/sample (so w is from 0 to pi). 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    w : ndarray 
        The frequencies at which `h` was computed, in the same units as `fs`. 
        By default, `w` is normalized to the range [0, pi) (radians/sample). 
    h : ndarray 
        The frequency response, as complex numbers. 
 
    See Also 
    -------- 
    freqs : Compute the frequency response of an analog filter in TF form 
    freqs_zpk : Compute the frequency response of an analog filter in ZPK form 
    freqz : Compute the frequency response of a digital filter in TF form 
 
    Notes 
    ----- 
    .. versionadded:: 0.19.0 
 
    Examples 
    -------- 
    Design a 4th-order digital Butterworth filter with cut-off of 100 Hz in a 
    system with sample rate of 1000 Hz, and plot the frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; z, p, k = signal.butter(4, 100, output='zpk', fs=1000) 
    &gt;&gt;&gt; w, h = signal.freqz_zpk(z, p, k, fs=1000) 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; ax1 = fig.add_subplot(1, 1, 1) 
    &gt;&gt;&gt; ax1.set_title('Digital filter frequency response') 
 
    &gt;&gt;&gt; ax1.plot(w, 20 * np.log10(abs(h)), 'b') 
    &gt;&gt;&gt; ax1.set_ylabel('Amplitude [dB]', color='b') 
    &gt;&gt;&gt; ax1.set_xlabel('Frequency [Hz]') 
    &gt;&gt;&gt; ax1.grid(True) 
 
    &gt;&gt;&gt; ax2 = ax1.twinx() 
    &gt;&gt;&gt; angles = np.unwrap(np.angle(h)) 
    &gt;&gt;&gt; ax2.plot(w, angles, 'g') 
    &gt;&gt;&gt; ax2.set_ylabel('Angle [radians]', color='g') 
 
    &gt;&gt;&gt; plt.axis('tight') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">z</span><span class="s3">, </span><span class="s1">p </span><span class="s3">= </span><span class="s1">map</span><span class="s3">(</span><span class="s1">atleast_1d</span><span class="s3">, (</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">))</span>

    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">whole</span><span class="s3">:</span>
        <span class="s1">lastpoint </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">pi</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">lastpoint </span><span class="s3">= </span><span class="s1">pi</span>

    <span class="s2">if </span><span class="s1">worN </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s6"># For backwards compatibility</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">lastpoint</span><span class="s3">, </span><span class="s5">512</span><span class="s3">, </span><span class="s1">endpoint</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">_is_int_type</span><span class="s3">(</span><span class="s1">worN</span><span class="s3">):</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">lastpoint</span><span class="s3">, </span><span class="s1">worN</span><span class="s3">, </span><span class="s1">endpoint</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">worN</span><span class="s3">)</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s5">2</span><span class="s3">*</span><span class="s1">pi</span><span class="s3">*</span><span class="s1">w</span><span class="s3">/</span><span class="s1">fs</span>

    <span class="s1">zm1 </span><span class="s3">= </span><span class="s1">exp</span><span class="s3">(</span><span class="s5">1j </span><span class="s3">* </span><span class="s1">w</span><span class="s3">)</span>
    <span class="s1">h </span><span class="s3">= </span><span class="s1">k </span><span class="s3">* </span><span class="s1">polyvalfromroots</span><span class="s3">(</span><span class="s1">zm1</span><span class="s3">, </span><span class="s1">z</span><span class="s3">) / </span><span class="s1">polyvalfromroots</span><span class="s3">(</span><span class="s1">zm1</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s1">w </span><span class="s3">= </span><span class="s1">w</span><span class="s3">*(</span><span class="s1">fs</span><span class="s3">/(</span><span class="s5">2</span><span class="s3">*</span><span class="s1">pi</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h</span>


<span class="s2">def </span><span class="s1">group_delay</span><span class="s3">(</span><span class="s1">system</span><span class="s3">, </span><span class="s1">w</span><span class="s3">=</span><span class="s5">512</span><span class="s3">, </span><span class="s1">whole</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">2</span><span class="s3">*</span><span class="s1">pi</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot;Compute the group delay of a digital filter. 
 
    The group delay measures by how many samples amplitude envelopes of 
    various spectral components of a signal are delayed by a filter. 
    It is formally defined as the derivative of continuous (unwrapped) phase:: 
 
               d        jw 
     D(w) = - -- arg H(e) 
              dw 
 
    Parameters 
    ---------- 
    system : tuple of array_like (b, a) 
        Numerator and denominator coefficients of a filter transfer function. 
    w : {None, int, array_like}, optional 
        If a single integer, then compute at that many frequencies (default is 
        N=512). 
 
        If an array_like, compute the delay at the frequencies given. These 
        are in the same units as `fs`. 
    whole : bool, optional 
        Normally, frequencies are computed from 0 to the Nyquist frequency, 
        fs/2 (upper-half of unit-circle). If `whole` is True, compute 
        frequencies from 0 to fs. Ignored if w is array_like. 
    fs : float, optional 
        The sampling frequency of the digital system. Defaults to 2*pi 
        radians/sample (so w is from 0 to pi). 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    w : ndarray 
        The frequencies at which group delay was computed, in the same units 
        as `fs`.  By default, `w` is normalized to the range [0, pi) 
        (radians/sample). 
    gd : ndarray 
        The group delay. 
 
    See Also 
    -------- 
    freqz : Frequency response of a digital filter 
 
    Notes 
    ----- 
    The similar function in MATLAB is called `grpdelay`. 
 
    If the transfer function :math:`H(z)` has zeros or poles on the unit 
    circle, the group delay at corresponding frequencies is undefined. 
    When such a case arises the warning is raised and the group delay 
    is set to 0 at those frequencies. 
 
    For the details of numerical computation of the group delay refer to [1]_ or [2]_. 
 
    .. versionadded:: 0.16.0 
 
    References 
    ---------- 
    .. [1] Richard G. Lyons, &quot;Understanding Digital Signal Processing, 
           3rd edition&quot;, p. 830. 
    .. [2] Julius O. Smith III, &quot;Numerical Computation of Group Delay&quot;, 
           in &quot;Introduction to Digital Filters with Audio Applications&quot;, 
           online book, 2007, 
           https://ccrma.stanford.edu/~jos/fp/Numerical_Computation_Group_Delay.html 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; b, a = signal.iirdesign(0.1, 0.3, 5, 50, ftype='cheby1') 
    &gt;&gt;&gt; w, gd = signal.group_delay((b, a)) 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.title('Digital filter group delay') 
    &gt;&gt;&gt; plt.plot(w, gd) 
    &gt;&gt;&gt; plt.ylabel('Group delay [samples]') 
    &gt;&gt;&gt; plt.xlabel('Frequency [rad/sample]') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">w </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s6"># For backwards compatibility</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s5">512</span>

    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">_is_int_type</span><span class="s3">(</span><span class="s1">w</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">whole</span><span class="s3">:</span>
            <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">pi</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">endpoint</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">pi</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">endpoint</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">w</span><span class="s3">)</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s5">2</span><span class="s3">*</span><span class="s1">pi</span><span class="s3">*</span><span class="s1">w</span><span class="s3">/</span><span class="s1">fs</span>

    <span class="s1">b</span><span class="s3">, </span><span class="s1">a </span><span class="s3">= </span><span class="s1">map</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">, </span><span class="s1">system</span><span class="s3">)</span>
    <span class="s1">c </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">convolve</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">conjugate</span><span class="s3">(</span><span class="s1">a</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]))</span>
    <span class="s1">cr </span><span class="s3">= </span><span class="s1">c </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">c</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(-</span><span class="s5">1j </span><span class="s3">* </span><span class="s1">w</span><span class="s3">)</span>
    <span class="s1">num </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">polyval</span><span class="s3">(</span><span class="s1">cr</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">z</span><span class="s3">)</span>
    <span class="s1">den </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">polyval</span><span class="s3">(</span><span class="s1">c</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">z</span><span class="s3">)</span>
    <span class="s1">gd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">real</span><span class="s3">(</span><span class="s1">num </span><span class="s3">/ </span><span class="s1">den</span><span class="s3">) - </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">+ </span><span class="s5">1</span>
    <span class="s1">singular </span><span class="s3">= ~</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">gd</span><span class="s3">)</span>
    <span class="s1">near_singular </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">absolute</span><span class="s3">(</span><span class="s1">den</span><span class="s3">) &lt; </span><span class="s5">10 </span><span class="s3">* </span><span class="s1">EPSILON</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">singular</span><span class="s3">):</span>
        <span class="s1">gd</span><span class="s3">[</span><span class="s1">singular</span><span class="s3">] = </span><span class="s5">0</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">&quot;The group delay is singular at frequencies [{}], setting to 0&quot;</span><span class="s3">.</span>
            <span class="s1">format</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">ws</span><span class="s2">:</span><span class="s4">.3f</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">ws </span><span class="s2">in </span><span class="s1">w</span><span class="s3">[</span><span class="s1">singular</span><span class="s3">])),</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span>
        <span class="s3">)</span>

    <span class="s2">elif </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">near_singular</span><span class="s3">):</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
            <span class="s4">&quot;The filter's denominator is extremely small at frequencies [{}], </span><span class="s2">\ 
            </span><span class="s4">around which a singularity may be present&quot;</span><span class="s3">.</span>
            <span class="s1">format</span><span class="s3">(</span><span class="s4">&quot;, &quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">ws</span><span class="s2">:</span><span class="s4">.3f</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">ws </span><span class="s2">in </span><span class="s1">w</span><span class="s3">[</span><span class="s1">near_singular</span><span class="s3">])),</span>
            <span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span>
        <span class="s3">)</span>

    <span class="s1">w </span><span class="s3">= </span><span class="s1">w</span><span class="s3">*(</span><span class="s1">fs</span><span class="s3">/(</span><span class="s5">2</span><span class="s3">*</span><span class="s1">pi</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">w</span><span class="s3">, </span><span class="s1">gd</span>


<span class="s2">def </span><span class="s1">_validate_sos</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Helper to validate a SOS input&quot;&quot;&quot;</span>
    <span class="s1">sos </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_2d</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">sos</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'sos array must be 2D'</span><span class="s3">)</span>
    <span class="s1">n_sections</span><span class="s3">, </span><span class="s1">m </span><span class="s3">= </span><span class="s1">sos</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s2">if </span><span class="s1">m </span><span class="s3">!= </span><span class="s5">6</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'sos array must be shape (n_sections, 6)'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">sos</span><span class="s3">[:, </span><span class="s5">3</span><span class="s3">] == </span><span class="s5">1</span><span class="s3">).</span><span class="s1">all</span><span class="s3">():</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'sos[:, 3] should be all ones'</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">sos</span><span class="s3">, </span><span class="s1">n_sections</span>


<span class="s2">def </span><span class="s1">sosfreqz</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">, </span><span class="s1">worN</span><span class="s3">=</span><span class="s5">512</span><span class="s3">, </span><span class="s1">whole</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">2</span><span class="s3">*</span><span class="s1">pi</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Compute the frequency response of a digital filter in SOS format. 
 
    Given `sos`, an array with shape (n, 6) of second order sections of 
    a digital filter, compute the frequency response of the system function:: 
 
               B0(z)   B1(z)         B{n-1}(z) 
        H(z) = ----- * ----- * ... * --------- 
               A0(z)   A1(z)         A{n-1}(z) 
 
    for z = exp(omega*1j), where B{k}(z) and A{k}(z) are numerator and 
    denominator of the transfer function of the k-th second order section. 
 
    Parameters 
    ---------- 
    sos : array_like 
        Array of second-order filter coefficients, must have shape 
        ``(n_sections, 6)``. Each row corresponds to a second-order 
        section, with the first three columns providing the numerator 
        coefficients and the last three providing the denominator 
        coefficients. 
    worN : {None, int, array_like}, optional 
        If a single integer, then compute at that many frequencies (default is 
        N=512).  Using a number that is fast for FFT computations can result 
        in faster computations (see Notes of `freqz`). 
 
        If an array_like, compute the response at the frequencies given (must 
        be 1-D). These are in the same units as `fs`. 
    whole : bool, optional 
        Normally, frequencies are computed from 0 to the Nyquist frequency, 
        fs/2 (upper-half of unit-circle). If `whole` is True, compute 
        frequencies from 0 to fs. 
    fs : float, optional 
        The sampling frequency of the digital system. Defaults to 2*pi 
        radians/sample (so w is from 0 to pi). 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    w : ndarray 
        The frequencies at which `h` was computed, in the same units as `fs`. 
        By default, `w` is normalized to the range [0, pi) (radians/sample). 
    h : ndarray 
        The frequency response, as complex numbers. 
 
    See Also 
    -------- 
    freqz, sosfilt 
 
    Notes 
    ----- 
    .. versionadded:: 0.19.0 
 
    Examples 
    -------- 
    Design a 15th-order bandpass filter in SOS format. 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; sos = signal.ellip(15, 0.5, 60, (0.2, 0.4), btype='bandpass', 
    ...                    output='sos') 
 
    Compute the frequency response at 1500 points from DC to Nyquist. 
 
    &gt;&gt;&gt; w, h = signal.sosfreqz(sos, worN=1500) 
 
    Plot the response. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.subplot(2, 1, 1) 
    &gt;&gt;&gt; db = 20*np.log10(np.maximum(np.abs(h), 1e-5)) 
    &gt;&gt;&gt; plt.plot(w/np.pi, db) 
    &gt;&gt;&gt; plt.ylim(-75, 5) 
    &gt;&gt;&gt; plt.grid(True) 
    &gt;&gt;&gt; plt.yticks([0, -20, -40, -60]) 
    &gt;&gt;&gt; plt.ylabel('Gain [dB]') 
    &gt;&gt;&gt; plt.title('Frequency Response') 
    &gt;&gt;&gt; plt.subplot(2, 1, 2) 
    &gt;&gt;&gt; plt.plot(w/np.pi, np.angle(h)) 
    &gt;&gt;&gt; plt.grid(True) 
    &gt;&gt;&gt; plt.yticks([-np.pi, -0.5*np.pi, 0, 0.5*np.pi, np.pi], 
    ...            [r'$-\pi$', r'$-\pi/2$', '0', r'$\pi/2$', r'$\pi$']) 
    &gt;&gt;&gt; plt.ylabel('Phase [rad]') 
    &gt;&gt;&gt; plt.xlabel('Normalized frequency (1.0 = Nyquist)') 
    &gt;&gt;&gt; plt.show() 
 
    If the same filter is implemented as a single transfer function, 
    numerical error corrupts the frequency response: 
 
    &gt;&gt;&gt; b, a = signal.ellip(15, 0.5, 60, (0.2, 0.4), btype='bandpass', 
    ...                    output='ba') 
    &gt;&gt;&gt; w, h = signal.freqz(b, a, worN=1500) 
    &gt;&gt;&gt; plt.subplot(2, 1, 1) 
    &gt;&gt;&gt; db = 20*np.log10(np.maximum(np.abs(h), 1e-5)) 
    &gt;&gt;&gt; plt.plot(w/np.pi, db) 
    &gt;&gt;&gt; plt.ylim(-75, 5) 
    &gt;&gt;&gt; plt.grid(True) 
    &gt;&gt;&gt; plt.yticks([0, -20, -40, -60]) 
    &gt;&gt;&gt; plt.ylabel('Gain [dB]') 
    &gt;&gt;&gt; plt.title('Frequency Response') 
    &gt;&gt;&gt; plt.subplot(2, 1, 2) 
    &gt;&gt;&gt; plt.plot(w/np.pi, np.angle(h)) 
    &gt;&gt;&gt; plt.grid(True) 
    &gt;&gt;&gt; plt.yticks([-np.pi, -0.5*np.pi, 0, 0.5*np.pi, np.pi], 
    ...            [r'$-\pi$', r'$-\pi/2$', '0', r'$\pi/2$', r'$\pi$']) 
    &gt;&gt;&gt; plt.ylabel('Phase [rad]') 
    &gt;&gt;&gt; plt.xlabel('Normalized frequency (1.0 = Nyquist)') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s1">sos</span><span class="s3">, </span><span class="s1">n_sections </span><span class="s3">= </span><span class="s1">_validate_sos</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">n_sections </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Cannot compute frequencies with no sections'</span><span class="s3">)</span>
    <span class="s1">h </span><span class="s3">= </span><span class="s5">1.</span>
    <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">sos</span><span class="s3">:</span>
        <span class="s1">w</span><span class="s3">, </span><span class="s1">rowh </span><span class="s3">= </span><span class="s1">freqz</span><span class="s3">(</span><span class="s1">row</span><span class="s3">[:</span><span class="s5">3</span><span class="s3">], </span><span class="s1">row</span><span class="s3">[</span><span class="s5">3</span><span class="s3">:], </span><span class="s1">worN</span><span class="s3">=</span><span class="s1">worN</span><span class="s3">, </span><span class="s1">whole</span><span class="s3">=</span><span class="s1">whole</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s1">fs</span><span class="s3">)</span>
        <span class="s1">h </span><span class="s3">*= </span><span class="s1">rowh</span>
    <span class="s2">return </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h</span>


<span class="s2">def </span><span class="s1">_cplxreal</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Split into complex and real parts, combining conjugate pairs. 
 
    The 1-D input vector `z` is split up into its complex (`zc`) and real (`zr`) 
    elements. Every complex element must be part of a complex-conjugate pair, 
    which are combined into a single number (with positive imaginary part) in 
    the output. Two complex numbers are considered a conjugate pair if their 
    real and imaginary parts differ in magnitude by less than ``tol * abs(z)``. 
 
    Parameters 
    ---------- 
    z : array_like 
        Vector of complex numbers to be sorted and split 
    tol : float, optional 
        Relative tolerance for testing realness and conjugate equality. 
        Default is ``100 * spacing(1)`` of `z`'s data type (i.e., 2e-14 for 
        float64) 
 
    Returns 
    ------- 
    zc : ndarray 
        Complex elements of `z`, with each pair represented by a single value 
        having positive imaginary part, sorted first by real part, and then 
        by magnitude of imaginary part. The pairs are averaged when combined 
        to reduce error. 
    zr : ndarray 
        Real elements of `z` (those having imaginary part less than 
        `tol` times their magnitude), sorted by value. 
 
    Raises 
    ------ 
    ValueError 
        If there are any complex numbers in `z` for which a conjugate 
        cannot be found. 
 
    See Also 
    -------- 
    _cplxpair 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.signal._filter_design import _cplxreal 
    &gt;&gt;&gt; a = [4, 3, 1, 2-2j, 2+2j, 2-1j, 2+1j, 2-1j, 2+1j, 1+1j, 1-1j] 
    &gt;&gt;&gt; zc, zr = _cplxreal(a) 
    &gt;&gt;&gt; print(zc) 
    [ 1.+1.j  2.+1.j  2.+1.j  2.+2.j] 
    &gt;&gt;&gt; print(zr) 
    [ 1.  3.  4.] 
    &quot;&quot;&quot;</span>

    <span class="s1">z </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">z</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">z</span><span class="s3">, </span><span class="s1">z</span>
    <span class="s2">elif </span><span class="s1">z</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'_cplxreal only accepts 1-D input'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">tol </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s6"># Get tolerance from dtype of input</span>
        <span class="s1">tol </span><span class="s3">= </span><span class="s5">100 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">((</span><span class="s5">1.0 </span><span class="s3">* </span><span class="s1">z</span><span class="s3">).</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">eps</span>

    <span class="s6"># Sort by real part, magnitude of imaginary part (speed up further sorting)</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">z</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">lexsort</span><span class="s3">((</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">z</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">), </span><span class="s1">z</span><span class="s3">.</span><span class="s1">real</span><span class="s3">))]</span>

    <span class="s6"># Split reals from conjugate pairs</span>
    <span class="s1">real_indices </span><span class="s3">= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">z</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">) &lt;= </span><span class="s1">tol </span><span class="s3">* </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s1">zr </span><span class="s3">= </span><span class="s1">z</span><span class="s3">[</span><span class="s1">real_indices</span><span class="s3">].</span><span class="s1">real</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">zr</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">z</span><span class="s3">):</span>
        <span class="s6"># Input is entirely real</span>
        <span class="s2">return </span><span class="s1">array</span><span class="s3">([]), </span><span class="s1">zr</span>

    <span class="s6"># Split positive and negative halves of conjugates</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">z</span><span class="s3">[~</span><span class="s1">real_indices</span><span class="s3">]</span>
    <span class="s1">zp </span><span class="s3">= </span><span class="s1">z</span><span class="s3">[</span><span class="s1">z</span><span class="s3">.</span><span class="s1">imag </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">zn </span><span class="s3">= </span><span class="s1">z</span><span class="s3">[</span><span class="s1">z</span><span class="s3">.</span><span class="s1">imag </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">]</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">zp</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">zn</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Array contains complex value with no matching '</span>
                         <span class="s4">'conjugate.'</span><span class="s3">)</span>

    <span class="s6"># Find runs of (approximately) the same real part</span>
    <span class="s1">same_real </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">zp</span><span class="s3">.</span><span class="s1">real</span><span class="s3">) &lt;= </span><span class="s1">tol </span><span class="s3">* </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">zp</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">])</span>
    <span class="s1">diffs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">concatenate</span><span class="s3">(([</span><span class="s5">0</span><span class="s3">], </span><span class="s1">same_real</span><span class="s3">, [</span><span class="s5">0</span><span class="s3">])))</span>
    <span class="s1">run_starts </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">(</span><span class="s1">diffs </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">run_stops </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">(</span><span class="s1">diffs </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s6"># Sort each run by their imaginary parts</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">run_starts</span><span class="s3">)):</span>
        <span class="s1">start </span><span class="s3">= </span><span class="s1">run_starts</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s1">stop </span><span class="s3">= </span><span class="s1">run_stops</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + </span><span class="s5">1</span>
        <span class="s2">for </span><span class="s1">chunk </span><span class="s2">in </span><span class="s3">(</span><span class="s1">zp</span><span class="s3">[</span><span class="s1">start</span><span class="s3">:</span><span class="s1">stop</span><span class="s3">], </span><span class="s1">zn</span><span class="s3">[</span><span class="s1">start</span><span class="s3">:</span><span class="s1">stop</span><span class="s3">]):</span>
            <span class="s1">chunk</span><span class="s3">[...] = </span><span class="s1">chunk</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">lexsort</span><span class="s3">([</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">chunk</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">)])]</span>

    <span class="s6"># Check that negatives match positives</span>
    <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">zp </span><span class="s3">- </span><span class="s1">zn</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">()) &gt; </span><span class="s1">tol </span><span class="s3">* </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">zn</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Array contains complex value with no matching '</span>
                         <span class="s4">'conjugate.'</span><span class="s3">)</span>

    <span class="s6"># Average out numerical inaccuracy in real vs imag parts of pairs</span>
    <span class="s1">zc </span><span class="s3">= (</span><span class="s1">zp </span><span class="s3">+ </span><span class="s1">zn</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">()) / </span><span class="s5">2</span>

    <span class="s2">return </span><span class="s1">zc</span><span class="s3">, </span><span class="s1">zr</span>


<span class="s2">def </span><span class="s1">_cplxpair</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Sort into pairs of complex conjugates. 
 
    Complex conjugates in `z` are sorted by increasing real part. In each 
    pair, the number with negative imaginary part appears first. 
 
    If pairs have identical real parts, they are sorted by increasing 
    imaginary magnitude. 
 
    Two complex numbers are considered a conjugate pair if their real and 
    imaginary parts differ in magnitude by less than ``tol * abs(z)``.  The 
    pairs are forced to be exact complex conjugates by averaging the positive 
    and negative values. 
 
    Purely real numbers are also sorted, but placed after the complex 
    conjugate pairs. A number is considered real if its imaginary part is 
    smaller than `tol` times the magnitude of the number. 
 
    Parameters 
    ---------- 
    z : array_like 
        1-D input array to be sorted. 
    tol : float, optional 
        Relative tolerance for testing realness and conjugate equality. 
        Default is ``100 * spacing(1)`` of `z`'s data type (i.e., 2e-14 for 
        float64) 
 
    Returns 
    ------- 
    y : ndarray 
        Complex conjugate pairs followed by real numbers. 
 
    Raises 
    ------ 
    ValueError 
        If there are any complex numbers in `z` for which a conjugate 
        cannot be found. 
 
    See Also 
    -------- 
    _cplxreal 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.signal._filter_design import _cplxpair 
    &gt;&gt;&gt; a = [4, 3, 1, 2-2j, 2+2j, 2-1j, 2+1j, 2-1j, 2+1j, 1+1j, 1-1j] 
    &gt;&gt;&gt; z = _cplxpair(a) 
    &gt;&gt;&gt; print(z) 
    [ 1.-1.j  1.+1.j  2.-1.j  2.+1.j  2.-1.j  2.+1.j  2.-2.j  2.+2.j  1.+0.j 
      3.+0.j  4.+0.j] 
    &quot;&quot;&quot;</span>

    <span class="s1">z </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">z</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isrealobj</span><span class="s3">(</span><span class="s1">z</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">z</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'z must be 1-D'</span><span class="s3">)</span>

    <span class="s1">zc</span><span class="s3">, </span><span class="s1">zr </span><span class="s3">= </span><span class="s1">_cplxreal</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">)</span>

    <span class="s6"># Interleave complex values and their conjugates, with negative imaginary</span>
    <span class="s6"># parts first in each pair</span>
    <span class="s1">zc </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dstack</span><span class="s3">((</span><span class="s1">zc</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">(), </span><span class="s1">zc</span><span class="s3">)).</span><span class="s1">flatten</span><span class="s3">()</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">zc</span><span class="s3">, </span><span class="s1">zr</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">z</span>


<span class="s2">def </span><span class="s1">tf2zpk</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot;Return zero, pole, gain (z, p, k) representation from a numerator, 
    denominator representation of a linear filter. 
 
    Parameters 
    ---------- 
    b : array_like 
        Numerator polynomial coefficients. 
    a : array_like 
        Denominator polynomial coefficients. 
 
    Returns 
    ------- 
    z : ndarray 
        Zeros of the transfer function. 
    p : ndarray 
        Poles of the transfer function. 
    k : float 
        System gain. 
 
    Notes 
    ----- 
    If some values of `b` are too close to 0, they are removed. In that case, 
    a BadCoefficients warning is emitted. 
 
    The `b` and `a` arrays are interpreted as coefficients for positive, 
    descending powers of the transfer function variable. So the inputs 
    :math:`b = [b_0, b_1, ..., b_M]` and :math:`a =[a_0, a_1, ..., a_N]` 
    can represent an analog filter of the form: 
 
    .. math:: 
 
        H(s) = \frac 
        {b_0 s^M + b_1 s^{(M-1)} + \cdots + b_M} 
        {a_0 s^N + a_1 s^{(N-1)} + \cdots + a_N} 
 
    or a discrete-time filter of the form: 
 
    .. math:: 
 
        H(z) = \frac 
        {b_0 z^M + b_1 z^{(M-1)} + \cdots + b_M} 
        {a_0 z^N + a_1 z^{(N-1)} + \cdots + a_N} 
 
    This &quot;positive powers&quot; form is found more commonly in controls 
    engineering. If `M` and `N` are equal (which is true for all filters 
    generated by the bilinear transform), then this happens to be equivalent 
    to the &quot;negative powers&quot; discrete-time form preferred in DSP: 
 
    .. math:: 
 
        H(z) = \frac 
        {b_0 + b_1 z^{-1} + \cdots + b_M z^{-M}} 
        {a_0 + a_1 z^{-1} + \cdots + a_N z^{-N}} 
 
    Although this is true for common filters, remember that this is not true 
    in the general case. If `M` and `N` are not equal, the discrete-time 
    transfer function coefficients must first be converted to the &quot;positive 
    powers&quot; form before finding the poles and zeros. 
 
    Examples 
    -------- 
    Find the zeroes, poles and gain of  
    a filter with the transfer function 
 
    .. math:: 
     
        H(s) = \frac{3s^2}{s^2 + 5s + 13} 
         
    &gt;&gt;&gt; from scipy.signal import tf2zpk 
    &gt;&gt;&gt; tf2zpk([3, 0, 0], [1, 5, 13]) 
    (   array([ 0.               ,  0.              ]),  
        array([ -2.5+2.59807621j ,  -2.5-2.59807621j]),  
        3.0) 
    &quot;&quot;&quot;</span>
    <span class="s1">b</span><span class="s3">, </span><span class="s1">a </span><span class="s3">= </span><span class="s1">normalize</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">b </span><span class="s3">= (</span><span class="s1">b </span><span class="s3">+ </span><span class="s5">0.0</span><span class="s3">) / </span><span class="s1">a</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">a </span><span class="s3">= (</span><span class="s1">a </span><span class="s3">+ </span><span class="s5">0.0</span><span class="s3">) / </span><span class="s1">a</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">b</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">b </span><span class="s3">/= </span><span class="s1">b</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">roots</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">roots</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span>


<span class="s2">def </span><span class="s1">zpk2tf</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Return polynomial transfer function representation from zeros and poles 
 
    Parameters 
    ---------- 
    z : array_like 
        Zeros of the transfer function. 
    p : array_like 
        Poles of the transfer function. 
    k : float 
        System gain. 
 
    Returns 
    ------- 
    b : ndarray 
        Numerator polynomial coefficients. 
    a : ndarray 
        Denominator polynomial coefficients. 
 
    Examples 
    -------- 
    Find the polynomial representation of a transfer function H(s) 
    using its 'zpk' (Zero-Pole-Gain) representation. 
     
    .. math:: 
             
        H(z) = 5 \frac 
        { (s - 2)(s - 6) } 
        { (s - 1)(s - 8) } 
 
    &gt;&gt;&gt; from scipy.signal import zpk2tf 
    &gt;&gt;&gt; z   = [2,   6] 
    &gt;&gt;&gt; p   = [1,   8] 
    &gt;&gt;&gt; k   = 5 
    &gt;&gt;&gt; zpk2tf(z, p, k) 
    (   array([  5., -40.,  60.]), array([ 1., -9.,  8.])) 
    &quot;&quot;&quot;</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">z</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">) &gt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">temp </span><span class="s3">= </span><span class="s1">poly</span><span class="s3">(</span><span class="s1">z</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">z</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">z</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] + </span><span class="s5">1</span><span class="s3">), </span><span class="s1">temp</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">k</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">k </span><span class="s3">= [</span><span class="s1">k</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]] * </span><span class="s1">z</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">z</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]):</span>
            <span class="s1">b</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">k</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] * </span><span class="s1">poly</span><span class="s3">(</span><span class="s1">z</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">k </span><span class="s3">* </span><span class="s1">poly</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">poly</span><span class="s3">(</span><span class="s1">p</span><span class="s3">))</span>

    <span class="s6"># Use real output if possible. Copied from np.poly, since</span>
    <span class="s6"># we can't depend on a specific version of numpy.</span>
    <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">):</span>
        <span class="s6"># if complex roots are all complex conjugates, the roots are real.</span>
        <span class="s1">roots </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">complex</span><span class="s3">)</span>
        <span class="s1">pos_roots </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">compress</span><span class="s3">(</span><span class="s1">roots</span><span class="s3">.</span><span class="s1">imag </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">, </span><span class="s1">roots</span><span class="s3">)</span>
        <span class="s1">neg_roots </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">conjugate</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">compress</span><span class="s3">(</span><span class="s1">roots</span><span class="s3">.</span><span class="s1">imag </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">, </span><span class="s1">roots</span><span class="s3">))</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">pos_roots</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">neg_roots</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort_complex</span><span class="s3">(</span><span class="s1">neg_roots</span><span class="s3">) == </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort_complex</span><span class="s3">(</span><span class="s1">pos_roots</span><span class="s3">)):</span>
                <span class="s1">b </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">real</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

    <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">):</span>
        <span class="s6"># if complex roots are all complex conjugates, the roots are real.</span>
        <span class="s1">roots </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">complex</span><span class="s3">)</span>
        <span class="s1">pos_roots </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">compress</span><span class="s3">(</span><span class="s1">roots</span><span class="s3">.</span><span class="s1">imag </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">, </span><span class="s1">roots</span><span class="s3">)</span>
        <span class="s1">neg_roots </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">conjugate</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">compress</span><span class="s3">(</span><span class="s1">roots</span><span class="s3">.</span><span class="s1">imag </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">, </span><span class="s1">roots</span><span class="s3">))</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">pos_roots</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">neg_roots</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort_complex</span><span class="s3">(</span><span class="s1">neg_roots</span><span class="s3">) == </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort_complex</span><span class="s3">(</span><span class="s1">pos_roots</span><span class="s3">)):</span>
                <span class="s1">a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">real</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

    <span class="s2">return </span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span>


<span class="s2">def </span><span class="s1">tf2sos</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">pairing</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, *, </span><span class="s1">analog</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Return second-order sections from transfer function representation 
 
    Parameters 
    ---------- 
    b : array_like 
        Numerator polynomial coefficients. 
    a : array_like 
        Denominator polynomial coefficients. 
    pairing : {None, 'nearest', 'keep_odd', 'minimal'}, optional 
        The method to use to combine pairs of poles and zeros into sections. 
        See `zpk2sos` for information and restrictions on `pairing` and 
        `analog` arguments. 
    analog : bool, optional 
        If True, system is analog, otherwise discrete. 
 
        .. versionadded:: 1.8.0 
 
    Returns 
    ------- 
    sos : ndarray 
        Array of second-order filter coefficients, with shape 
        ``(n_sections, 6)``. See `sosfilt` for the SOS filter format 
        specification. 
 
    See Also 
    -------- 
    zpk2sos, sosfilt 
 
    Notes 
    ----- 
    It is generally discouraged to convert from TF to SOS format, since doing 
    so usually will not improve numerical precision errors. Instead, consider 
    designing filters in ZPK format and converting directly to SOS. TF is 
    converted to SOS by first converting to ZPK format, then converting 
    ZPK to SOS. 
 
    .. versionadded:: 0.16.0 
 
    Examples 
    -------- 
    Find the 'sos' (second-order sections) of the transfer function H(s) 
    using its polynomial representation. 
     
    .. math:: 
     
        H(s) = \frac{s^2 - 3.5s - 2}{s^4 + 3s^3 - 15s^2 - 19s + 30} 
         
    &gt;&gt;&gt; from scipy.signal import tf2sos 
    &gt;&gt;&gt; tf2sos([1, -3.5, -2], [1, 3, -15, -19, 30], analog=True) 
    array([[  0. ,   0. ,   1. ,   1. ,   2. , -15. ], 
           [  1. ,  -3.5,  -2. ,   1. ,   1. ,  -2. ]]) 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">zpk2sos</span><span class="s3">(*</span><span class="s1">tf2zpk</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">), </span><span class="s1">pairing</span><span class="s3">=</span><span class="s1">pairing</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s1">analog</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">sos2tf</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Return a single transfer function from a series of second-order sections 
 
    Parameters 
    ---------- 
    sos : array_like 
        Array of second-order filter coefficients, must have shape 
        ``(n_sections, 6)``. See `sosfilt` for the SOS filter format 
        specification. 
 
    Returns 
    ------- 
    b : ndarray 
        Numerator polynomial coefficients. 
    a : ndarray 
        Denominator polynomial coefficients. 
 
    Notes 
    ----- 
    .. versionadded:: 0.16.0 
 
    Examples 
    -------- 
    Find the polynomial representation of an elliptic filter  
    using its 'sos' (second-order sections) format. 
    
    &gt;&gt;&gt; from scipy.signal import sos2tf 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; sos = signal.ellip(1, 0.001, 50, 0.1, output='sos') 
    &gt;&gt;&gt; sos2tf(sos) 
    (   array([0.91256522, 0.91256522, 0.        ]), 
        array([1.        , 0.82513043, 0.        ])) 
    &quot;&quot;&quot;</span>
    <span class="s1">sos </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">)</span>
    <span class="s1">result_type </span><span class="s3">= </span><span class="s1">sos</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s2">if </span><span class="s1">result_type</span><span class="s3">.</span><span class="s1">kind </span><span class="s2">in </span><span class="s4">'bui'</span><span class="s3">:</span>
        <span class="s1">result_type </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span>

    <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">1</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">result_type</span><span class="s3">)</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">1</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">result_type</span><span class="s3">)</span>
    <span class="s1">n_sections </span><span class="s3">= </span><span class="s1">sos</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">for </span><span class="s1">section </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_sections</span><span class="s3">):</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">polymul</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">sos</span><span class="s3">[</span><span class="s1">section</span><span class="s3">, :</span><span class="s5">3</span><span class="s3">])</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">polymul</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">sos</span><span class="s3">[</span><span class="s1">section</span><span class="s3">, </span><span class="s5">3</span><span class="s3">:])</span>
    <span class="s2">return </span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span>


<span class="s2">def </span><span class="s1">sos2zpk</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return zeros, poles, and gain of a series of second-order sections 
 
    Parameters 
    ---------- 
    sos : array_like 
        Array of second-order filter coefficients, must have shape 
        ``(n_sections, 6)``. See `sosfilt` for the SOS filter format 
        specification. 
 
    Returns 
    ------- 
    z : ndarray 
        Zeros of the transfer function. 
    p : ndarray 
        Poles of the transfer function. 
    k : float 
        System gain. 
 
    Notes 
    ----- 
    The number of zeros and poles returned will be ``n_sections * 2`` 
    even if some of these are (effectively) zero. 
 
    .. versionadded:: 0.16.0 
    &quot;&quot;&quot;</span>
    <span class="s1">sos </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">)</span>
    <span class="s1">n_sections </span><span class="s3">= </span><span class="s1">sos</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_sections</span><span class="s3">*</span><span class="s5">2</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complex128</span><span class="s3">)</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_sections</span><span class="s3">*</span><span class="s5">2</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complex128</span><span class="s3">)</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s5">1.</span>
    <span class="s2">for </span><span class="s1">section </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_sections</span><span class="s3">):</span>
        <span class="s1">zpk </span><span class="s3">= </span><span class="s1">tf2zpk</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">[</span><span class="s1">section</span><span class="s3">, :</span><span class="s5">3</span><span class="s3">], </span><span class="s1">sos</span><span class="s3">[</span><span class="s1">section</span><span class="s3">, </span><span class="s5">3</span><span class="s3">:])</span>
        <span class="s1">z</span><span class="s3">[</span><span class="s5">2</span><span class="s3">*</span><span class="s1">section</span><span class="s3">:</span><span class="s5">2</span><span class="s3">*</span><span class="s1">section</span><span class="s3">+</span><span class="s1">len</span><span class="s3">(</span><span class="s1">zpk</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])] = </span><span class="s1">zpk</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s5">2</span><span class="s3">*</span><span class="s1">section</span><span class="s3">:</span><span class="s5">2</span><span class="s3">*</span><span class="s1">section</span><span class="s3">+</span><span class="s1">len</span><span class="s3">(</span><span class="s1">zpk</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])] = </span><span class="s1">zpk</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s1">k </span><span class="s3">*= </span><span class="s1">zpk</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span>


<span class="s2">def </span><span class="s1">_nearest_real_complex_idx</span><span class="s3">(</span><span class="s1">fro</span><span class="s3">, </span><span class="s1">to</span><span class="s3">, </span><span class="s1">which</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Get the next closest real or complex element based on distance&quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">which </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'real'</span><span class="s3">, </span><span class="s4">'complex'</span><span class="s3">, </span><span class="s4">'any'</span><span class="s3">)</span>
    <span class="s1">order </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">fro </span><span class="s3">- </span><span class="s1">to</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">which </span><span class="s3">== </span><span class="s4">'any'</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">order</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isreal</span><span class="s3">(</span><span class="s1">fro</span><span class="s3">[</span><span class="s1">order</span><span class="s3">])</span>
        <span class="s2">if </span><span class="s1">which </span><span class="s3">== </span><span class="s4">'complex'</span><span class="s3">:</span>
            <span class="s1">mask </span><span class="s3">= ~</span><span class="s1">mask</span>
        <span class="s2">return </span><span class="s1">order</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">][</span><span class="s5">0</span><span class="s3">]]</span>


<span class="s2">def </span><span class="s1">_single_zpksos</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Create one second-order section from up to two zeros and poles&quot;&quot;&quot;</span>
    <span class="s1">sos </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s5">6</span><span class="s3">)</span>
    <span class="s1">b</span><span class="s3">, </span><span class="s1">a </span><span class="s3">= </span><span class="s1">zpk2tf</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>
    <span class="s1">sos</span><span class="s3">[</span><span class="s5">3</span><span class="s3">-</span><span class="s1">len</span><span class="s3">(</span><span class="s1">b</span><span class="s3">):</span><span class="s5">3</span><span class="s3">] = </span><span class="s1">b</span>
    <span class="s1">sos</span><span class="s3">[</span><span class="s5">6</span><span class="s3">-</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span><span class="s5">6</span><span class="s3">] = </span><span class="s1">a</span>
    <span class="s2">return </span><span class="s1">sos</span>


<span class="s2">def </span><span class="s1">zpk2sos</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">pairing</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, *, </span><span class="s1">analog</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return second-order sections from zeros, poles, and gain of a system 
 
    Parameters 
    ---------- 
    z : array_like 
        Zeros of the transfer function. 
    p : array_like 
        Poles of the transfer function. 
    k : float 
        System gain. 
    pairing : {None, 'nearest', 'keep_odd', 'minimal'}, optional 
        The method to use to combine pairs of poles and zeros into sections. 
        If analog is False and pairing is None, pairing is set to 'nearest'; 
        if analog is True, pairing must be 'minimal', and is set to that if 
        it is None. 
    analog : bool, optional 
        If True, system is analog, otherwise discrete. 
 
        .. versionadded:: 1.8.0 
 
    Returns 
    ------- 
    sos : ndarray 
        Array of second-order filter coefficients, with shape 
        ``(n_sections, 6)``. See `sosfilt` for the SOS filter format 
        specification. 
 
    See Also 
    -------- 
    sosfilt 
 
    Notes 
    ----- 
    The algorithm used to convert ZPK to SOS format is designed to 
    minimize errors due to numerical precision issues. The pairing 
    algorithm attempts to minimize the peak gain of each biquadratic 
    section. This is done by pairing poles with the nearest zeros, starting 
    with the poles closest to the unit circle for discrete-time systems, and 
    poles closest to the imaginary axis for continuous-time systems. 
 
    ``pairing='minimal'`` outputs may not be suitable for `sosfilt`, 
    and ``analog=True`` outputs will never be suitable for `sosfilt`. 
 
    *Algorithms* 
 
    The steps in the ``pairing='nearest'``, ``pairing='keep_odd'``, 
    and ``pairing='minimal'`` algorithms are mostly shared. The 
    ``'nearest'`` algorithm attempts to minimize the peak gain, while 
    ``'keep_odd'`` minimizes peak gain under the constraint that 
    odd-order systems should retain one section as first order. 
    ``'minimal'`` is similar to ``'keep_odd'``, but no additional 
    poles or zeros are introduced 
 
    The algorithm steps are as follows: 
 
    As a pre-processing step for ``pairing='nearest'``, 
    ``pairing='keep_odd'``, add poles or zeros to the origin as 
    necessary to obtain the same number of poles and zeros for 
    pairing.  If ``pairing == 'nearest'`` and there are an odd number 
    of poles, add an additional pole and a zero at the origin. 
 
    The following steps are then iterated over until no more poles or 
    zeros remain: 
 
    1. Take the (next remaining) pole (complex or real) closest to the 
       unit circle (or imaginary axis, for ``analog=True``) to 
       begin a new filter section. 
 
    2. If the pole is real and there are no other remaining real poles [#]_, 
       add the closest real zero to the section and leave it as a first 
       order section. Note that after this step we are guaranteed to be 
       left with an even number of real poles, complex poles, real zeros, 
       and complex zeros for subsequent pairing iterations. 
 
    3. Else: 
 
        1. If the pole is complex and the zero is the only remaining real 
           zero*, then pair the pole with the *next* closest zero 
           (guaranteed to be complex). This is necessary to ensure that 
           there will be a real zero remaining to eventually create a 
           first-order section (thus keeping the odd order). 
 
        2. Else pair the pole with the closest remaining zero (complex or 
           real). 
 
        3. Proceed to complete the second-order section by adding another 
           pole and zero to the current pole and zero in the section: 
 
            1. If the current pole and zero are both complex, add their 
               conjugates. 
 
            2. Else if the pole is complex and the zero is real, add the 
               conjugate pole and the next closest real zero. 
 
            3. Else if the pole is real and the zero is complex, add the 
               conjugate zero and the real pole closest to those zeros. 
 
            4. Else (we must have a real pole and real zero) add the next 
               real pole closest to the unit circle, and then add the real 
               zero closest to that pole. 
 
    .. [#] This conditional can only be met for specific odd-order inputs 
           with the ``pairing = 'keep_odd'`` or ``'minimal'`` methods. 
 
    .. versionadded:: 0.16.0 
 
    Examples 
    -------- 
 
    Design a 6th order low-pass elliptic digital filter for a system with a 
    sampling rate of 8000 Hz that has a pass-band corner frequency of 
    1000 Hz. The ripple in the pass-band should not exceed 0.087 dB, and 
    the attenuation in the stop-band should be at least 90 dB. 
 
    In the following call to `ellip`, we could use ``output='sos'``, 
    but for this example, we'll use ``output='zpk'``, and then convert 
    to SOS format with `zpk2sos`: 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; z, p, k = signal.ellip(6, 0.087, 90, 1000/(0.5*8000), output='zpk') 
 
    Now convert to SOS format. 
 
    &gt;&gt;&gt; sos = signal.zpk2sos(z, p, k) 
 
    The coefficients of the numerators of the sections: 
 
    &gt;&gt;&gt; sos[:, :3] 
    array([[0.0014152 , 0.00248677, 0.0014152 ], 
           [1.        , 0.72976874, 1.        ], 
           [1.        , 0.17607852, 1.        ]]) 
 
    The symmetry in the coefficients occurs because all the zeros are on the 
    unit circle. 
 
    The coefficients of the denominators of the sections: 
 
    &gt;&gt;&gt; sos[:, 3:] 
    array([[ 1.        , -1.32544025,  0.46989976], 
           [ 1.        , -1.26118294,  0.62625924], 
           [ 1.        , -1.2570723 ,  0.8619958 ]]) 
 
    The next example shows the effect of the `pairing` option.  We have a 
    system with three poles and three zeros, so the SOS array will have 
    shape (2, 6). The means there is, in effect, an extra pole and an extra 
    zero at the origin in the SOS representation. 
 
    &gt;&gt;&gt; z1 = np.array([-1, -0.5-0.5j, -0.5+0.5j]) 
    &gt;&gt;&gt; p1 = np.array([0.75, 0.8+0.1j, 0.8-0.1j]) 
 
    With ``pairing='nearest'`` (the default), we obtain 
 
    &gt;&gt;&gt; signal.zpk2sos(z1, p1, 1) 
    array([[ 1.  ,  1.  ,  0.5 ,  1.  , -0.75,  0.  ], 
           [ 1.  ,  1.  ,  0.  ,  1.  , -1.6 ,  0.65]]) 
 
    The first section has the zeros {-0.5-0.05j, -0.5+0.5j} and the poles 
    {0, 0.75}, and the second section has the zeros {-1, 0} and poles 
    {0.8+0.1j, 0.8-0.1j}. Note that the extra pole and zero at the origin 
    have been assigned to different sections. 
 
    With ``pairing='keep_odd'``, we obtain: 
 
    &gt;&gt;&gt; signal.zpk2sos(z1, p1, 1, pairing='keep_odd') 
    array([[ 1.  ,  1.  ,  0.  ,  1.  , -0.75,  0.  ], 
           [ 1.  ,  1.  ,  0.5 ,  1.  , -1.6 ,  0.65]]) 
 
    The extra pole and zero at the origin are in the same section. 
    The first section is, in effect, a first-order section. 
 
    With ``pairing='minimal'``, the first-order section doesn't have 
    the extra pole and zero at the origin: 
 
    &gt;&gt;&gt; signal.zpk2sos(z1, p1, 1, pairing='minimal') 
    array([[ 0.  ,  1.  ,  1.  ,  0.  ,  1.  , -0.75], 
           [ 1.  ,  1.  ,  0.5 ,  1.  , -1.6 ,  0.65]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s6"># TODO in the near future:</span>
    <span class="s6"># 1. Add SOS capability to `filtfilt`, `freqz`, etc. somehow (#3259).</span>
    <span class="s6"># 2. Make `decimate` use `sosfilt` instead of `lfilter`.</span>
    <span class="s6"># 3. Make sosfilt automatically simplify sections to first order</span>
    <span class="s6">#    when possible. Note this might make `sosfiltfilt` a bit harder (ICs).</span>
    <span class="s6"># 4. Further optimizations of the section ordering / pole-zero pairing.</span>
    <span class="s6"># See the wiki for other potential issues.</span>

    <span class="s2">if </span><span class="s1">pairing </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">pairing </span><span class="s3">= </span><span class="s4">'minimal' </span><span class="s2">if </span><span class="s1">analog </span><span class="s2">else </span><span class="s4">'nearest'</span>

    <span class="s1">valid_pairings </span><span class="s3">= [</span><span class="s4">'nearest'</span><span class="s3">, </span><span class="s4">'keep_odd'</span><span class="s3">, </span><span class="s4">'minimal'</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">pairing </span><span class="s2">not in </span><span class="s1">valid_pairings</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f'pairing must be one of </span><span class="s2">{</span><span class="s1">valid_pairings</span><span class="s2">}</span><span class="s4">, not </span><span class="s2">{</span><span class="s1">pairing</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">analog </span><span class="s2">and </span><span class="s1">pairing </span><span class="s3">!= </span><span class="s4">'minimal'</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'for analog zpk2sos conversion, '</span>
                         <span class="s4">'pairing must be &quot;minimal&quot;'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">z</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s1">analog</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s1">k</span><span class="s3">, </span><span class="s5">0.</span><span class="s3">, </span><span class="s5">0.</span><span class="s3">, </span><span class="s5">1.</span><span class="s3">, </span><span class="s5">0.</span><span class="s3">, </span><span class="s5">0.</span><span class="s3">]])</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s5">0.</span><span class="s3">, </span><span class="s5">0.</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s5">0.</span><span class="s3">, </span><span class="s5">0.</span><span class="s3">, </span><span class="s5">1.</span><span class="s3">]])</span>

    <span class="s2">if </span><span class="s1">pairing </span><span class="s3">!= </span><span class="s4">'minimal'</span><span class="s3">:</span>
        <span class="s6"># ensure we have the same number of poles and zeros, and make copies</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">p</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">max</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">z</span><span class="s3">) - </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">), </span><span class="s5">0</span><span class="s3">))))</span>
        <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">z</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">max</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) - </span><span class="s1">len</span><span class="s3">(</span><span class="s1">z</span><span class="s3">), </span><span class="s5">0</span><span class="s3">))))</span>
        <span class="s1">n_sections </span><span class="s3">= (</span><span class="s1">max</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">), </span><span class="s1">len</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)) + </span><span class="s5">1</span><span class="s3">) // </span><span class="s5">2</span>

        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) % </span><span class="s5">2 </span><span class="s3">== </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">pairing </span><span class="s3">== </span><span class="s4">'nearest'</span><span class="s3">:</span>
            <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">p</span><span class="s3">, [</span><span class="s5">0.</span><span class="s3">]))</span>
            <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">z</span><span class="s3">, [</span><span class="s5">0.</span><span class="s3">]))</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) &lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">z</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'for analog zpk2sos conversion, '</span>
                             <span class="s4">'must have len(p)&gt;=len(z)'</span><span class="s3">)</span>

        <span class="s1">n_sections </span><span class="s3">= (</span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) + </span><span class="s5">1</span><span class="s3">) // </span><span class="s5">2</span>

    <span class="s6"># Ensure we have complex conjugate pairs</span>
    <span class="s6"># (note that _cplxreal only gives us one element of each complex pair):</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">(</span><span class="s1">_cplxreal</span><span class="s3">(</span><span class="s1">z</span><span class="s3">))</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">(</span><span class="s1">_cplxreal</span><span class="s3">(</span><span class="s1">p</span><span class="s3">))</span>
    <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isreal</span><span class="s3">(</span><span class="s1">k</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'k must be real'</span><span class="s3">)</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">k</span><span class="s3">.</span><span class="s1">real</span>

    <span class="s2">if not </span><span class="s1">analog</span><span class="s3">:</span>
        <span class="s6"># digital: &quot;worst&quot; is the closest to the unit circle</span>
        <span class="s2">def </span><span class="s1">idx_worst</span><span class="s3">(</span><span class="s1">p</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># analog: &quot;worst&quot; is the closest to the imaginary axis</span>
        <span class="s2">def </span><span class="s1">idx_worst</span><span class="s3">(</span><span class="s1">p</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">real</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)))</span>

    <span class="s1">sos </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">n_sections</span><span class="s3">, </span><span class="s5">6</span><span class="s3">))</span>

    <span class="s6"># Construct the system, reversing order so the &quot;worst&quot; are last</span>
    <span class="s2">for </span><span class="s1">si </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_sections</span><span class="s3">-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">):</span>
        <span class="s6"># Select the next &quot;worst&quot; pole</span>
        <span class="s1">p1_idx </span><span class="s3">= </span><span class="s1">idx_worst</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
        <span class="s1">p1 </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s1">p1_idx</span><span class="s3">]</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">p1_idx</span><span class="s3">)</span>

        <span class="s6"># Pair that pole with a zero</span>

        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isreal</span><span class="s3">(</span><span class="s1">p1</span><span class="s3">) </span><span class="s2">and </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isreal</span><span class="s3">(</span><span class="s1">p</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">() == </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s6"># Special case (1): last remaining real pole</span>
            <span class="s2">if </span><span class="s1">pairing </span><span class="s3">!= </span><span class="s4">'minimal'</span><span class="s3">:</span>
                <span class="s1">z1_idx </span><span class="s3">= </span><span class="s1">_nearest_real_complex_idx</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p1</span><span class="s3">, </span><span class="s4">'real'</span><span class="s3">)</span>
                <span class="s1">z1 </span><span class="s3">= </span><span class="s1">z</span><span class="s3">[</span><span class="s1">z1_idx</span><span class="s3">]</span>
                <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">z1_idx</span><span class="s3">)</span>
                <span class="s1">sos</span><span class="s3">[</span><span class="s1">si</span><span class="s3">] = </span><span class="s1">_single_zpksos</span><span class="s3">([</span><span class="s1">z1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">], [</span><span class="s1">p1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">], </span><span class="s5">1</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">z</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s1">z1_idx </span><span class="s3">= </span><span class="s1">_nearest_real_complex_idx</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p1</span><span class="s3">, </span><span class="s4">'real'</span><span class="s3">)</span>
                <span class="s1">z1 </span><span class="s3">= </span><span class="s1">z</span><span class="s3">[</span><span class="s1">z1_idx</span><span class="s3">]</span>
                <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">z1_idx</span><span class="s3">)</span>
                <span class="s1">sos</span><span class="s3">[</span><span class="s1">si</span><span class="s3">] = </span><span class="s1">_single_zpksos</span><span class="s3">([</span><span class="s1">z1</span><span class="s3">], [</span><span class="s1">p1</span><span class="s3">], </span><span class="s5">1</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">sos</span><span class="s3">[</span><span class="s1">si</span><span class="s3">] = </span><span class="s1">_single_zpksos</span><span class="s3">([], [</span><span class="s1">p1</span><span class="s3">], </span><span class="s5">1</span><span class="s3">)</span>

        <span class="s2">elif </span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) + </span><span class="s5">1 </span><span class="s3">== </span><span class="s1">len</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
              <span class="s2">and not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isreal</span><span class="s3">(</span><span class="s1">p1</span><span class="s3">)</span>
              <span class="s2">and </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isreal</span><span class="s3">(</span><span class="s1">p</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">() == </span><span class="s5">1</span>
              <span class="s2">and </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isreal</span><span class="s3">(</span><span class="s1">z</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">() == </span><span class="s5">1</span><span class="s3">):</span>

            <span class="s6"># Special case (2): there's one real pole and one real zero</span>
            <span class="s6"># left, and an equal number of poles and zeros to pair up.</span>
            <span class="s6"># We *must* pair with a complex zero</span>

            <span class="s1">z1_idx </span><span class="s3">= </span><span class="s1">_nearest_real_complex_idx</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p1</span><span class="s3">, </span><span class="s4">'complex'</span><span class="s3">)</span>
            <span class="s1">z1 </span><span class="s3">= </span><span class="s1">z</span><span class="s3">[</span><span class="s1">z1_idx</span><span class="s3">]</span>
            <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">z1_idx</span><span class="s3">)</span>
            <span class="s1">sos</span><span class="s3">[</span><span class="s1">si</span><span class="s3">] = </span><span class="s1">_single_zpksos</span><span class="s3">([</span><span class="s1">z1</span><span class="s3">, </span><span class="s1">z1</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">()], [</span><span class="s1">p1</span><span class="s3">, </span><span class="s1">p1</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">()], </span><span class="s5">1</span><span class="s3">)</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isreal</span><span class="s3">(</span><span class="s1">p1</span><span class="s3">):</span>
                <span class="s1">prealidx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">flatnonzero</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isreal</span><span class="s3">(</span><span class="s1">p</span><span class="s3">))</span>
                <span class="s1">p2_idx </span><span class="s3">= </span><span class="s1">prealidx</span><span class="s3">[</span><span class="s1">idx_worst</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s1">prealidx</span><span class="s3">])]</span>
                <span class="s1">p2 </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s1">p2_idx</span><span class="s3">]</span>
                <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">p2_idx</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">p2 </span><span class="s3">= </span><span class="s1">p1</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">()</span>

            <span class="s6"># find closest zero</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">z</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">:</span>
                <span class="s1">z1_idx </span><span class="s3">= </span><span class="s1">_nearest_real_complex_idx</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p1</span><span class="s3">, </span><span class="s4">'any'</span><span class="s3">)</span>
                <span class="s1">z1 </span><span class="s3">= </span><span class="s1">z</span><span class="s3">[</span><span class="s1">z1_idx</span><span class="s3">]</span>
                <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">z1_idx</span><span class="s3">)</span>

                <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isreal</span><span class="s3">(</span><span class="s1">z1</span><span class="s3">):</span>
                    <span class="s1">sos</span><span class="s3">[</span><span class="s1">si</span><span class="s3">] = </span><span class="s1">_single_zpksos</span><span class="s3">([</span><span class="s1">z1</span><span class="s3">, </span><span class="s1">z1</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">()], [</span><span class="s1">p1</span><span class="s3">, </span><span class="s1">p2</span><span class="s3">], </span><span class="s5">1</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">z</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">:</span>
                        <span class="s1">z2_idx </span><span class="s3">= </span><span class="s1">_nearest_real_complex_idx</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p1</span><span class="s3">, </span><span class="s4">'real'</span><span class="s3">)</span>
                        <span class="s1">z2 </span><span class="s3">= </span><span class="s1">z</span><span class="s3">[</span><span class="s1">z2_idx</span><span class="s3">]</span>
                        <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isreal</span><span class="s3">(</span><span class="s1">z2</span><span class="s3">)</span>
                        <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">z2_idx</span><span class="s3">)</span>
                        <span class="s1">sos</span><span class="s3">[</span><span class="s1">si</span><span class="s3">] = </span><span class="s1">_single_zpksos</span><span class="s3">([</span><span class="s1">z1</span><span class="s3">, </span><span class="s1">z2</span><span class="s3">], [</span><span class="s1">p1</span><span class="s3">, </span><span class="s1">p2</span><span class="s3">], </span><span class="s5">1</span><span class="s3">)</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">sos</span><span class="s3">[</span><span class="s1">si</span><span class="s3">] = </span><span class="s1">_single_zpksos</span><span class="s3">([</span><span class="s1">z1</span><span class="s3">], [</span><span class="s1">p1</span><span class="s3">, </span><span class="s1">p2</span><span class="s3">], </span><span class="s5">1</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s6"># no more zeros</span>
                <span class="s1">sos</span><span class="s3">[</span><span class="s1">si</span><span class="s3">] = </span><span class="s1">_single_zpksos</span><span class="s3">([], [</span><span class="s1">p1</span><span class="s3">, </span><span class="s1">p2</span><span class="s3">], </span><span class="s5">1</span><span class="s3">)</span>

    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">z</span><span class="s3">) == </span><span class="s5">0  </span><span class="s6"># we've consumed all poles and zeros</span>
    <span class="s2">del </span><span class="s1">p</span><span class="s3">, </span><span class="s1">z</span>

    <span class="s6"># put gain in first sos</span>
    <span class="s1">sos</span><span class="s3">[</span><span class="s5">0</span><span class="s3">][:</span><span class="s5">3</span><span class="s3">] *= </span><span class="s1">k</span>
    <span class="s2">return </span><span class="s1">sos</span>


<span class="s2">def </span><span class="s1">_align_nums</span><span class="s3">(</span><span class="s1">nums</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Aligns the shapes of multiple numerators. 
 
    Given an array of numerator coefficient arrays [[a_1, a_2,..., 
    a_n],..., [b_1, b_2,..., b_m]], this function pads shorter numerator 
    arrays with zero's so that all numerators have the same length. Such 
    alignment is necessary for functions like 'tf2ss', which needs the 
    alignment when dealing with SIMO transfer functions. 
 
    Parameters 
    ---------- 
    nums: array_like 
        Numerator or list of numerators. Not necessarily with same length. 
 
    Returns 
    ------- 
    nums: array 
        The numerator. If `nums` input was a list of numerators then a 2-D 
        array with padded zeros for shorter numerators is returned. Otherwise 
        returns ``np.asarray(nums)``. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s6"># The statement can throw a ValueError if one</span>
        <span class="s6"># of the numerators is a single digit and another</span>
        <span class="s6"># is array-like e.g. if nums = [5, [1, 2, 3]]</span>
        <span class="s1">nums </span><span class="s3">= </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">nums</span><span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">nums</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">number</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;dtype of numerator is non-numeric&quot;</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">nums</span>

    <span class="s2">except </span><span class="s1">ValueError</span><span class="s3">:</span>
        <span class="s1">nums </span><span class="s3">= [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">num</span><span class="s3">) </span><span class="s2">for </span><span class="s1">num </span><span class="s2">in </span><span class="s1">nums</span><span class="s3">]</span>
        <span class="s1">max_width </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">num</span><span class="s3">.</span><span class="s1">size </span><span class="s2">for </span><span class="s1">num </span><span class="s2">in </span><span class="s1">nums</span><span class="s3">)</span>

        <span class="s6"># pre-allocate</span>
        <span class="s1">aligned_nums </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">len</span><span class="s3">(</span><span class="s1">nums</span><span class="s3">), </span><span class="s1">max_width</span><span class="s3">))</span>

        <span class="s6"># Create numerators with padded zeros</span>
        <span class="s2">for </span><span class="s1">index</span><span class="s3">, </span><span class="s1">num </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">nums</span><span class="s3">):</span>
            <span class="s1">aligned_nums</span><span class="s3">[</span><span class="s1">index</span><span class="s3">, -</span><span class="s1">num</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:] = </span><span class="s1">num</span>

        <span class="s2">return </span><span class="s1">aligned_nums</span>


<span class="s2">def </span><span class="s1">normalize</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Normalize numerator/denominator of a continuous-time transfer function. 
 
    If values of `b` are too close to 0, they are removed. In that case, a 
    BadCoefficients warning is emitted. 
 
    Parameters 
    ---------- 
    b: array_like 
        Numerator of the transfer function. Can be a 2-D array to normalize 
        multiple transfer functions. 
    a: array_like 
        Denominator of the transfer function. At most 1-D. 
 
    Returns 
    ------- 
    num: array 
        The numerator of the normalized transfer function. At least a 1-D 
        array. A 2-D array if the input `num` is a 2-D array. 
    den: 1-D array 
        The denominator of the normalized transfer function. 
 
    Notes 
    ----- 
    Coefficients for both the numerator and denominator should be specified in 
    descending exponent order (e.g., ``s^2 + 3s + 5`` would be represented as 
    ``[1, 3, 5]``). 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.signal import normalize 
 
    Normalize the coefficients of the transfer function 
    ``(3*s^2 - 2*s + 5) / (2*s^2 + 3*s + 1)``: 
 
    &gt;&gt;&gt; b = [3, -2, 5] 
    &gt;&gt;&gt; a = [2, 3, 1] 
    &gt;&gt;&gt; normalize(b, a) 
    (array([ 1.5, -1. ,  2.5]), array([1. , 1.5, 0.5])) 
 
    A warning is generated if, for example, the first coefficient of 
    `b` is 0.  In the following example, the result is as expected: 
 
    &gt;&gt;&gt; import warnings 
    &gt;&gt;&gt; with warnings.catch_warnings(record=True) as w: 
    ...     num, den = normalize([0, 3, 6], [2, -5, 4]) 
 
    &gt;&gt;&gt; num 
    array([1.5, 3. ]) 
    &gt;&gt;&gt; den 
    array([ 1. , -2.5,  2. ]) 
 
    &gt;&gt;&gt; print(w[0].message) 
    Badly conditioned filter coefficients (numerator): the results may be meaningless 
 
    &quot;&quot;&quot;</span>
    <span class="s1">num</span><span class="s3">, </span><span class="s1">den </span><span class="s3">= </span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span>

    <span class="s1">den </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">den</span><span class="s3">)</span>
    <span class="s1">num </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_2d</span><span class="s3">(</span><span class="s1">_align_nums</span><span class="s3">(</span><span class="s1">num</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s1">den</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Denominator polynomial must be rank-1 array.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">num</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Numerator polynomial must be rank-1 or&quot;</span>
                         <span class="s4">&quot; rank-2 array.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">den </span><span class="s3">== </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Denominator must have at least on nonzero element.&quot;</span><span class="s3">)</span>

    <span class="s6"># Trim leading zeros in denominator, leave at least one.</span>
    <span class="s1">den </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">trim_zeros</span><span class="s3">(</span><span class="s1">den</span><span class="s3">, </span><span class="s4">'f'</span><span class="s3">)</span>

    <span class="s6"># Normalize transfer function</span>
    <span class="s1">num</span><span class="s3">, </span><span class="s1">den </span><span class="s3">= </span><span class="s1">num </span><span class="s3">/ </span><span class="s1">den</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">den </span><span class="s3">/ </span><span class="s1">den</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s6"># Count numerator columns that are all zero</span>
    <span class="s1">leading_zeros </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">num</span><span class="s3">.</span><span class="s1">T</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">allclose</span><span class="s3">(</span><span class="s1">col</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s5">1e-14</span><span class="s3">):</span>
            <span class="s1">leading_zeros </span><span class="s3">+= </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">break</span>

    <span class="s6"># Trim leading zeros of numerator</span>
    <span class="s2">if </span><span class="s1">leading_zeros </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">&quot;Badly conditioned filter coefficients (numerator): the &quot;</span>
                      <span class="s4">&quot;results may be meaningless&quot;</span><span class="s3">,</span>
                      <span class="s1">BadCoefficients</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
        <span class="s6"># Make sure at least one column remains</span>
        <span class="s2">if </span><span class="s1">leading_zeros </span><span class="s3">== </span><span class="s1">num</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]:</span>
            <span class="s1">leading_zeros </span><span class="s3">-= </span><span class="s5">1</span>
        <span class="s1">num </span><span class="s3">= </span><span class="s1">num</span><span class="s3">[:, </span><span class="s1">leading_zeros</span><span class="s3">:]</span>

    <span class="s6"># Squeeze first dimension if singular</span>
    <span class="s2">if </span><span class="s1">num</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">num </span><span class="s3">= </span><span class="s1">num</span><span class="s3">[</span><span class="s5">0</span><span class="s3">, :]</span>

    <span class="s2">return </span><span class="s1">num</span><span class="s3">, </span><span class="s1">den</span>


<span class="s2">def </span><span class="s1">lp2lp</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">wo</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Transform a lowpass filter prototype to a different frequency. 
 
    Return an analog low-pass filter with cutoff frequency `wo` 
    from an analog low-pass filter prototype with unity cutoff frequency, in 
    transfer function ('ba') representation. 
 
    Parameters 
    ---------- 
    b : array_like 
        Numerator polynomial coefficients. 
    a : array_like 
        Denominator polynomial coefficients. 
    wo : float 
        Desired cutoff, as angular frequency (e.g. rad/s). 
        Defaults to no change. 
 
    Returns 
    ------- 
    b : array_like 
        Numerator polynomial coefficients of the transformed low-pass filter. 
    a : array_like 
        Denominator polynomial coefficients of the transformed low-pass filter. 
 
    See Also 
    -------- 
    lp2hp, lp2bp, lp2bs, bilinear 
    lp2lp_zpk 
 
    Notes 
    ----- 
    This is derived from the s-plane substitution 
 
    .. math:: s \rightarrow \frac{s}{\omega_0} 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; lp = signal.lti([1.0], [1.0, 1.0]) 
    &gt;&gt;&gt; lp2 = signal.lti(*signal.lp2lp(lp.num, lp.den, 2)) 
    &gt;&gt;&gt; w, mag_lp, p_lp = lp.bode() 
    &gt;&gt;&gt; w, mag_lp2, p_lp2 = lp2.bode(w) 
 
    &gt;&gt;&gt; plt.plot(w, mag_lp, label='Lowpass') 
    &gt;&gt;&gt; plt.plot(w, mag_lp2, label='Transformed Lowpass') 
    &gt;&gt;&gt; plt.semilogx() 
    &gt;&gt;&gt; plt.grid(True) 
    &gt;&gt;&gt; plt.xlabel('Frequency [rad/s]') 
    &gt;&gt;&gt; plt.ylabel('Magnitude [dB]') 
    &gt;&gt;&gt; plt.legend() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s3">= </span><span class="s1">map</span><span class="s3">(</span><span class="s1">atleast_1d</span><span class="s3">, (</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">))</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">wo </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">wo</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">TypeError</span><span class="s3">:</span>
        <span class="s1">wo </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">wo</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
    <span class="s1">M </span><span class="s3">= </span><span class="s1">max</span><span class="s3">((</span><span class="s1">d</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>
    <span class="s1">pwo </span><span class="s3">= </span><span class="s1">pow</span><span class="s3">(</span><span class="s1">wo</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">M </span><span class="s3">- </span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">))</span>
    <span class="s1">start1 </span><span class="s3">= </span><span class="s1">max</span><span class="s3">((</span><span class="s1">n </span><span class="s3">- </span><span class="s1">d</span><span class="s3">, </span><span class="s5">0</span><span class="s3">))</span>
    <span class="s1">start2 </span><span class="s3">= </span><span class="s1">max</span><span class="s3">((</span><span class="s1">d </span><span class="s3">- </span><span class="s1">n</span><span class="s3">, </span><span class="s5">0</span><span class="s3">))</span>
    <span class="s1">b </span><span class="s3">= </span><span class="s1">b </span><span class="s3">* </span><span class="s1">pwo</span><span class="s3">[</span><span class="s1">start1</span><span class="s3">] / </span><span class="s1">pwo</span><span class="s3">[</span><span class="s1">start2</span><span class="s3">:]</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">a </span><span class="s3">* </span><span class="s1">pwo</span><span class="s3">[</span><span class="s1">start1</span><span class="s3">] / </span><span class="s1">pwo</span><span class="s3">[</span><span class="s1">start1</span><span class="s3">:]</span>
    <span class="s2">return </span><span class="s1">normalize</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">lp2hp</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">wo</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Transform a lowpass filter prototype to a highpass filter. 
 
    Return an analog high-pass filter with cutoff frequency `wo` 
    from an analog low-pass filter prototype with unity cutoff frequency, in 
    transfer function ('ba') representation. 
 
    Parameters 
    ---------- 
    b : array_like 
        Numerator polynomial coefficients. 
    a : array_like 
        Denominator polynomial coefficients. 
    wo : float 
        Desired cutoff, as angular frequency (e.g., rad/s). 
        Defaults to no change. 
 
    Returns 
    ------- 
    b : array_like 
        Numerator polynomial coefficients of the transformed high-pass filter. 
    a : array_like 
        Denominator polynomial coefficients of the transformed high-pass filter. 
 
    See Also 
    -------- 
    lp2lp, lp2bp, lp2bs, bilinear 
    lp2hp_zpk 
 
    Notes 
    ----- 
    This is derived from the s-plane substitution 
 
    .. math:: s \rightarrow \frac{\omega_0}{s} 
 
    This maintains symmetry of the lowpass and highpass responses on a 
    logarithmic scale. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; lp = signal.lti([1.0], [1.0, 1.0]) 
    &gt;&gt;&gt; hp = signal.lti(*signal.lp2hp(lp.num, lp.den)) 
    &gt;&gt;&gt; w, mag_lp, p_lp = lp.bode() 
    &gt;&gt;&gt; w, mag_hp, p_hp = hp.bode(w) 
 
    &gt;&gt;&gt; plt.plot(w, mag_lp, label='Lowpass') 
    &gt;&gt;&gt; plt.plot(w, mag_hp, label='Highpass') 
    &gt;&gt;&gt; plt.semilogx() 
    &gt;&gt;&gt; plt.grid(True) 
    &gt;&gt;&gt; plt.xlabel('Frequency [rad/s]') 
    &gt;&gt;&gt; plt.ylabel('Magnitude [dB]') 
    &gt;&gt;&gt; plt.legend() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s3">= </span><span class="s1">map</span><span class="s3">(</span><span class="s1">atleast_1d</span><span class="s3">, (</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">))</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">wo </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">wo</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">TypeError</span><span class="s3">:</span>
        <span class="s1">wo </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">wo</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">wo </span><span class="s3">!= </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">pwo </span><span class="s3">= </span><span class="s1">pow</span><span class="s3">(</span><span class="s1">wo</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">max</span><span class="s3">((</span><span class="s1">d</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">pwo </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">max</span><span class="s3">((</span><span class="s1">d</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)), </span><span class="s1">b</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">d </span><span class="s3">&gt;= </span><span class="s1">n</span><span class="s3">:</span>
        <span class="s1">outa </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">pwo</span>
        <span class="s1">outb </span><span class="s3">= </span><span class="s1">resize</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, (</span><span class="s1">d</span><span class="s3">,))</span>
        <span class="s1">outb</span><span class="s3">[</span><span class="s1">n</span><span class="s3">:] = </span><span class="s5">0.0</span>
        <span class="s1">outb</span><span class="s3">[:</span><span class="s1">n</span><span class="s3">] = </span><span class="s1">b</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">pwo</span><span class="s3">[:</span><span class="s1">n</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">outb </span><span class="s3">= </span><span class="s1">b</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">pwo</span>
        <span class="s1">outa </span><span class="s3">= </span><span class="s1">resize</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, (</span><span class="s1">n</span><span class="s3">,))</span>
        <span class="s1">outa</span><span class="s3">[</span><span class="s1">d</span><span class="s3">:] = </span><span class="s5">0.0</span>
        <span class="s1">outa</span><span class="s3">[:</span><span class="s1">d</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">pwo</span><span class="s3">[:</span><span class="s1">d</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">normalize</span><span class="s3">(</span><span class="s1">outb</span><span class="s3">, </span><span class="s1">outa</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">lp2bp</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">wo</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">bw</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Transform a lowpass filter prototype to a bandpass filter. 
 
    Return an analog band-pass filter with center frequency `wo` and 
    bandwidth `bw` from an analog low-pass filter prototype with unity 
    cutoff frequency, in transfer function ('ba') representation. 
 
    Parameters 
    ---------- 
    b : array_like 
        Numerator polynomial coefficients. 
    a : array_like 
        Denominator polynomial coefficients. 
    wo : float 
        Desired passband center, as angular frequency (e.g., rad/s). 
        Defaults to no change. 
    bw : float 
        Desired passband width, as angular frequency (e.g., rad/s). 
        Defaults to 1. 
 
    Returns 
    ------- 
    b : array_like 
        Numerator polynomial coefficients of the transformed band-pass filter. 
    a : array_like 
        Denominator polynomial coefficients of the transformed band-pass filter. 
 
    See Also 
    -------- 
    lp2lp, lp2hp, lp2bs, bilinear 
    lp2bp_zpk 
 
    Notes 
    ----- 
    This is derived from the s-plane substitution 
 
    .. math:: s \rightarrow \frac{s^2 + {\omega_0}^2}{s \cdot \mathrm{BW}} 
 
    This is the &quot;wideband&quot; transformation, producing a passband with 
    geometric (log frequency) symmetry about `wo`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; lp = signal.lti([1.0], [1.0, 1.0]) 
    &gt;&gt;&gt; bp = signal.lti(*signal.lp2bp(lp.num, lp.den)) 
    &gt;&gt;&gt; w, mag_lp, p_lp = lp.bode() 
    &gt;&gt;&gt; w, mag_bp, p_bp = bp.bode(w) 
 
    &gt;&gt;&gt; plt.plot(w, mag_lp, label='Lowpass') 
    &gt;&gt;&gt; plt.plot(w, mag_bp, label='Bandpass') 
    &gt;&gt;&gt; plt.semilogx() 
    &gt;&gt;&gt; plt.grid(True) 
    &gt;&gt;&gt; plt.xlabel('Frequency [rad/s]') 
    &gt;&gt;&gt; plt.ylabel('Magnitude [dB]') 
    &gt;&gt;&gt; plt.legend() 
    &quot;&quot;&quot;</span>

    <span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s3">= </span><span class="s1">map</span><span class="s3">(</span><span class="s1">atleast_1d</span><span class="s3">, (</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">))</span>
    <span class="s1">D </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) - </span><span class="s5">1</span>
    <span class="s1">N </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">b</span><span class="s3">) - </span><span class="s5">1</span>
    <span class="s1">artype </span><span class="s3">= </span><span class="s1">mintypecode</span><span class="s3">((</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">))</span>
    <span class="s1">ma </span><span class="s3">= </span><span class="s1">max</span><span class="s3">([</span><span class="s1">N</span><span class="s3">, </span><span class="s1">D</span><span class="s3">])</span>
    <span class="s1">Np </span><span class="s3">= </span><span class="s1">N </span><span class="s3">+ </span><span class="s1">ma</span>
    <span class="s1">Dp </span><span class="s3">= </span><span class="s1">D </span><span class="s3">+ </span><span class="s1">ma</span>
    <span class="s1">bprime </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">Np </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">artype</span><span class="s3">)</span>
    <span class="s1">aprime </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">Dp </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">artype</span><span class="s3">)</span>
    <span class="s1">wosq </span><span class="s3">= </span><span class="s1">wo </span><span class="s3">* </span><span class="s1">wo</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">Np </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s5">0.0</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">N </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">ma </span><span class="s3">- </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">k </span><span class="s3">== </span><span class="s1">j</span><span class="s3">:</span>
                    <span class="s1">val </span><span class="s3">+= </span><span class="s1">comb</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">) * </span><span class="s1">b</span><span class="s3">[</span><span class="s1">N </span><span class="s3">- </span><span class="s1">i</span><span class="s3">] * (</span><span class="s1">wosq</span><span class="s3">) ** (</span><span class="s1">i </span><span class="s3">- </span><span class="s1">k</span><span class="s3">) / </span><span class="s1">bw </span><span class="s3">** </span><span class="s1">i</span>
        <span class="s1">bprime</span><span class="s3">[</span><span class="s1">Np </span><span class="s3">- </span><span class="s1">j</span><span class="s3">] = </span><span class="s1">val</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">Dp </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s5">0.0</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">D </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">ma </span><span class="s3">- </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">k </span><span class="s3">== </span><span class="s1">j</span><span class="s3">:</span>
                    <span class="s1">val </span><span class="s3">+= </span><span class="s1">comb</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">) * </span><span class="s1">a</span><span class="s3">[</span><span class="s1">D </span><span class="s3">- </span><span class="s1">i</span><span class="s3">] * (</span><span class="s1">wosq</span><span class="s3">) ** (</span><span class="s1">i </span><span class="s3">- </span><span class="s1">k</span><span class="s3">) / </span><span class="s1">bw </span><span class="s3">** </span><span class="s1">i</span>
        <span class="s1">aprime</span><span class="s3">[</span><span class="s1">Dp </span><span class="s3">- </span><span class="s1">j</span><span class="s3">] = </span><span class="s1">val</span>

    <span class="s2">return </span><span class="s1">normalize</span><span class="s3">(</span><span class="s1">bprime</span><span class="s3">, </span><span class="s1">aprime</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">lp2bs</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">wo</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">bw</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Transform a lowpass filter prototype to a bandstop filter. 
 
    Return an analog band-stop filter with center frequency `wo` and 
    bandwidth `bw` from an analog low-pass filter prototype with unity 
    cutoff frequency, in transfer function ('ba') representation. 
 
    Parameters 
    ---------- 
    b : array_like 
        Numerator polynomial coefficients. 
    a : array_like 
        Denominator polynomial coefficients. 
    wo : float 
        Desired stopband center, as angular frequency (e.g., rad/s). 
        Defaults to no change. 
    bw : float 
        Desired stopband width, as angular frequency (e.g., rad/s). 
        Defaults to 1. 
 
    Returns 
    ------- 
    b : array_like 
        Numerator polynomial coefficients of the transformed band-stop filter. 
    a : array_like 
        Denominator polynomial coefficients of the transformed band-stop filter. 
 
    See Also 
    -------- 
    lp2lp, lp2hp, lp2bp, bilinear 
    lp2bs_zpk 
 
    Notes 
    ----- 
    This is derived from the s-plane substitution 
 
    .. math:: s \rightarrow \frac{s \cdot \mathrm{BW}}{s^2 + {\omega_0}^2} 
 
    This is the &quot;wideband&quot; transformation, producing a stopband with 
    geometric (log frequency) symmetry about `wo`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; lp = signal.lti([1.0], [1.0, 1.5]) 
    &gt;&gt;&gt; bs = signal.lti(*signal.lp2bs(lp.num, lp.den)) 
    &gt;&gt;&gt; w, mag_lp, p_lp = lp.bode() 
    &gt;&gt;&gt; w, mag_bs, p_bs = bs.bode(w) 
    &gt;&gt;&gt; plt.plot(w, mag_lp, label='Lowpass') 
    &gt;&gt;&gt; plt.plot(w, mag_bs, label='Bandstop') 
    &gt;&gt;&gt; plt.semilogx() 
    &gt;&gt;&gt; plt.grid(True) 
    &gt;&gt;&gt; plt.xlabel('Frequency [rad/s]') 
    &gt;&gt;&gt; plt.ylabel('Magnitude [dB]') 
    &gt;&gt;&gt; plt.legend() 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s3">= </span><span class="s1">map</span><span class="s3">(</span><span class="s1">atleast_1d</span><span class="s3">, (</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">))</span>
    <span class="s1">D </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) - </span><span class="s5">1</span>
    <span class="s1">N </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">b</span><span class="s3">) - </span><span class="s5">1</span>
    <span class="s1">artype </span><span class="s3">= </span><span class="s1">mintypecode</span><span class="s3">((</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">))</span>
    <span class="s1">M </span><span class="s3">= </span><span class="s1">max</span><span class="s3">([</span><span class="s1">N</span><span class="s3">, </span><span class="s1">D</span><span class="s3">])</span>
    <span class="s1">Np </span><span class="s3">= </span><span class="s1">M </span><span class="s3">+ </span><span class="s1">M</span>
    <span class="s1">Dp </span><span class="s3">= </span><span class="s1">M </span><span class="s3">+ </span><span class="s1">M</span>
    <span class="s1">bprime </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">Np </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">artype</span><span class="s3">)</span>
    <span class="s1">aprime </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">Dp </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">artype</span><span class="s3">)</span>
    <span class="s1">wosq </span><span class="s3">= </span><span class="s1">wo </span><span class="s3">* </span><span class="s1">wo</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">Np </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s5">0.0</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">N </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">M </span><span class="s3">- </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">k </span><span class="s3">== </span><span class="s1">j</span><span class="s3">:</span>
                    <span class="s1">val </span><span class="s3">+= (</span><span class="s1">comb</span><span class="s3">(</span><span class="s1">M </span><span class="s3">- </span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">) * </span><span class="s1">b</span><span class="s3">[</span><span class="s1">N </span><span class="s3">- </span><span class="s1">i</span><span class="s3">] *</span>
                            <span class="s3">(</span><span class="s1">wosq</span><span class="s3">) ** (</span><span class="s1">M </span><span class="s3">- </span><span class="s1">i </span><span class="s3">- </span><span class="s1">k</span><span class="s3">) * </span><span class="s1">bw </span><span class="s3">** </span><span class="s1">i</span><span class="s3">)</span>
        <span class="s1">bprime</span><span class="s3">[</span><span class="s1">Np </span><span class="s3">- </span><span class="s1">j</span><span class="s3">] = </span><span class="s1">val</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">Dp </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s5">0.0</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">D </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">M </span><span class="s3">- </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">k </span><span class="s3">== </span><span class="s1">j</span><span class="s3">:</span>
                    <span class="s1">val </span><span class="s3">+= (</span><span class="s1">comb</span><span class="s3">(</span><span class="s1">M </span><span class="s3">- </span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">) * </span><span class="s1">a</span><span class="s3">[</span><span class="s1">D </span><span class="s3">- </span><span class="s1">i</span><span class="s3">] *</span>
                            <span class="s3">(</span><span class="s1">wosq</span><span class="s3">) ** (</span><span class="s1">M </span><span class="s3">- </span><span class="s1">i </span><span class="s3">- </span><span class="s1">k</span><span class="s3">) * </span><span class="s1">bw </span><span class="s3">** </span><span class="s1">i</span><span class="s3">)</span>
        <span class="s1">aprime</span><span class="s3">[</span><span class="s1">Dp </span><span class="s3">- </span><span class="s1">j</span><span class="s3">] = </span><span class="s1">val</span>

    <span class="s2">return </span><span class="s1">normalize</span><span class="s3">(</span><span class="s1">bprime</span><span class="s3">, </span><span class="s1">aprime</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">bilinear</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Return a digital IIR filter from an analog one using a bilinear transform. 
 
    Transform a set of poles and zeros from the analog s-plane to the digital 
    z-plane using Tustin's method, which substitutes ``2*fs*(z-1) / (z+1)`` for 
    ``s``, maintaining the shape of the frequency response. 
 
    Parameters 
    ---------- 
    b : array_like 
        Numerator of the analog filter transfer function. 
    a : array_like 
        Denominator of the analog filter transfer function. 
    fs : float 
        Sample rate, as ordinary frequency (e.g., hertz). No prewarping is 
        done in this function. 
 
    Returns 
    ------- 
    b : ndarray 
        Numerator of the transformed digital filter transfer function. 
    a : ndarray 
        Denominator of the transformed digital filter transfer function. 
 
    See Also 
    -------- 
    lp2lp, lp2hp, lp2bp, lp2bs 
    bilinear_zpk 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; fs = 100 
    &gt;&gt;&gt; bf = 2 * np.pi * np.array([7, 13]) 
    &gt;&gt;&gt; filts = signal.lti(*signal.butter(4, bf, btype='bandpass', 
    ...                                   analog=True)) 
    &gt;&gt;&gt; filtz = signal.lti(*signal.bilinear(filts.num, filts.den, fs)) 
    &gt;&gt;&gt; wz, hz = signal.freqz(filtz.num, filtz.den) 
    &gt;&gt;&gt; ws, hs = signal.freqs(filts.num, filts.den, worN=fs*wz) 
 
    &gt;&gt;&gt; plt.semilogx(wz*fs/(2*np.pi), 20*np.log10(np.abs(hz).clip(1e-15)), 
    ...              label=r'$|H_z(e^{j \omega})|$') 
    &gt;&gt;&gt; plt.semilogx(wz*fs/(2*np.pi), 20*np.log10(np.abs(hs).clip(1e-15)), 
    ...              label=r'$|H(j \omega)|$') 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.xlabel('Frequency [Hz]') 
    &gt;&gt;&gt; plt.ylabel('Magnitude [dB]') 
    &gt;&gt;&gt; plt.grid(True) 
    &quot;&quot;&quot;</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s3">= </span><span class="s1">map</span><span class="s3">(</span><span class="s1">atleast_1d</span><span class="s3">, (</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">))</span>
    <span class="s1">D </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) - </span><span class="s5">1</span>
    <span class="s1">N </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">b</span><span class="s3">) - </span><span class="s5">1</span>
    <span class="s1">artype </span><span class="s3">= </span><span class="s1">float</span>
    <span class="s1">M </span><span class="s3">= </span><span class="s1">max</span><span class="s3">([</span><span class="s1">N</span><span class="s3">, </span><span class="s1">D</span><span class="s3">])</span>
    <span class="s1">Np </span><span class="s3">= </span><span class="s1">M</span>
    <span class="s1">Dp </span><span class="s3">= </span><span class="s1">M</span>
    <span class="s1">bprime </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">Np </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">artype</span><span class="s3">)</span>
    <span class="s1">aprime </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">Dp </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">artype</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">Np </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s5">0.0</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">N </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">M </span><span class="s3">- </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">k </span><span class="s3">+ </span><span class="s1">l </span><span class="s3">== </span><span class="s1">j</span><span class="s3">:</span>
                        <span class="s1">val </span><span class="s3">+= (</span><span class="s1">comb</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">) * </span><span class="s1">comb</span><span class="s3">(</span><span class="s1">M </span><span class="s3">- </span><span class="s1">i</span><span class="s3">, </span><span class="s1">l</span><span class="s3">) * </span><span class="s1">b</span><span class="s3">[</span><span class="s1">N </span><span class="s3">- </span><span class="s1">i</span><span class="s3">] *</span>
                                <span class="s1">pow</span><span class="s3">(</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">i</span><span class="s3">) * (-</span><span class="s5">1</span><span class="s3">) ** </span><span class="s1">k</span><span class="s3">)</span>
        <span class="s1">bprime</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">real</span><span class="s3">(</span><span class="s1">val</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">Dp </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s5">0.0</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">D </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
                <span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">M </span><span class="s3">- </span><span class="s1">i </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">k </span><span class="s3">+ </span><span class="s1">l </span><span class="s3">== </span><span class="s1">j</span><span class="s3">:</span>
                        <span class="s1">val </span><span class="s3">+= (</span><span class="s1">comb</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">) * </span><span class="s1">comb</span><span class="s3">(</span><span class="s1">M </span><span class="s3">- </span><span class="s1">i</span><span class="s3">, </span><span class="s1">l</span><span class="s3">) * </span><span class="s1">a</span><span class="s3">[</span><span class="s1">D </span><span class="s3">- </span><span class="s1">i</span><span class="s3">] *</span>
                                <span class="s1">pow</span><span class="s3">(</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">i</span><span class="s3">) * (-</span><span class="s5">1</span><span class="s3">) ** </span><span class="s1">k</span><span class="s3">)</span>
        <span class="s1">aprime</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">real</span><span class="s3">(</span><span class="s1">val</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">normalize</span><span class="s3">(</span><span class="s1">bprime</span><span class="s3">, </span><span class="s1">aprime</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_validate_gpass_gstop</span><span class="s3">(</span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">):</span>

    <span class="s2">if </span><span class="s1">gpass </span><span class="s3">&lt;= </span><span class="s5">0.0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;gpass should be larger than 0.0&quot;</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">gstop </span><span class="s3">&lt;= </span><span class="s5">0.0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;gstop should be larger than 0.0&quot;</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">gpass </span><span class="s3">&gt; </span><span class="s1">gstop</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;gpass should be smaller than gstop&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">iirdesign</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">ftype</span><span class="s3">=</span><span class="s4">'ellip'</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s4">'ba'</span><span class="s3">,</span>
              <span class="s1">fs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Complete IIR digital and analog filter design. 
 
    Given passband and stopband frequencies and gains, construct an analog or 
    digital IIR filter of minimum order for a given basic type. Return the 
    output in numerator, denominator ('ba'), pole-zero ('zpk') or second order 
    sections ('sos') form. 
 
    Parameters 
    ---------- 
    wp, ws : float or array like, shape (2,) 
        Passband and stopband edge frequencies. Possible values are scalars 
        (for lowpass and highpass filters) or ranges (for bandpass and bandstop 
        filters). 
        For digital filters, these are in the same units as `fs`. By default, 
        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1, 
        where 1 is the Nyquist frequency. For example: 
 
            - Lowpass:   wp = 0.2,          ws = 0.3 
            - Highpass:  wp = 0.3,          ws = 0.2 
            - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6] 
            - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5] 
 
        For analog filters, `wp` and `ws` are angular frequencies (e.g., rad/s). 
        Note, that for bandpass and bandstop filters passband must lie strictly 
        inside stopband or vice versa. 
    gpass : float 
        The maximum loss in the passband (dB). 
    gstop : float 
        The minimum attenuation in the stopband (dB). 
    analog : bool, optional 
        When True, return an analog filter, otherwise a digital filter is 
        returned. 
    ftype : str, optional 
        The type of IIR filter to design: 
 
            - Butterworth   : 'butter' 
            - Chebyshev I   : 'cheby1' 
            - Chebyshev II  : 'cheby2' 
            - Cauer/elliptic: 'ellip' 
 
    output : {'ba', 'zpk', 'sos'}, optional 
        Filter form of the output: 
 
            - second-order sections (recommended): 'sos' 
            - numerator/denominator (default)    : 'ba' 
            - pole-zero                          : 'zpk' 
 
        In general the second-order sections ('sos') form  is 
        recommended because inferring the coefficients for the 
        numerator/denominator form ('ba') suffers from numerical 
        instabilities. For reasons of backward compatibility the default 
        form is the numerator/denominator form ('ba'), where the 'b' 
        and the 'a' in 'ba' refer to the commonly used names of the 
        coefficients used. 
 
        Note: Using the second-order sections form ('sos') is sometimes 
        associated with additional computational costs: for 
        data-intense use cases it is therefore recommended to also 
        investigate the numerator/denominator form ('ba'). 
 
    fs : float, optional 
        The sampling frequency of the digital system. 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    b, a : ndarray, ndarray 
        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter. 
        Only returned if ``output='ba'``. 
    z, p, k : ndarray, ndarray, float 
        Zeros, poles, and system gain of the IIR filter transfer 
        function.  Only returned if ``output='zpk'``. 
    sos : ndarray 
        Second-order sections representation of the IIR filter. 
        Only returned if ``output='sos'``. 
 
    See Also 
    -------- 
    butter : Filter design using order and critical points 
    cheby1, cheby2, ellip, bessel 
    buttord : Find order and critical points from passband and stopband spec 
    cheb1ord, cheb2ord, ellipord 
    iirfilter : General filter design using order and critical frequencies 
 
    Notes 
    ----- 
    The ``'sos'`` output parameter was added in 0.16.0. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import matplotlib.ticker 
 
    &gt;&gt;&gt; wp = 0.2 
    &gt;&gt;&gt; ws = 0.3 
    &gt;&gt;&gt; gpass = 1 
    &gt;&gt;&gt; gstop = 40 
 
    &gt;&gt;&gt; system = signal.iirdesign(wp, ws, gpass, gstop) 
    &gt;&gt;&gt; w, h = signal.freqz(*system) 
 
    &gt;&gt;&gt; fig, ax1 = plt.subplots() 
    &gt;&gt;&gt; ax1.set_title('Digital filter frequency response') 
    &gt;&gt;&gt; ax1.plot(w, 20 * np.log10(abs(h)), 'b') 
    &gt;&gt;&gt; ax1.set_ylabel('Amplitude [dB]', color='b') 
    &gt;&gt;&gt; ax1.set_xlabel('Frequency [rad/sample]') 
    &gt;&gt;&gt; ax1.grid(True) 
    &gt;&gt;&gt; ax1.set_ylim([-120, 20]) 
    &gt;&gt;&gt; ax2 = ax1.twinx() 
    &gt;&gt;&gt; angles = np.unwrap(np.angle(h)) 
    &gt;&gt;&gt; ax2.plot(w, angles, 'g') 
    &gt;&gt;&gt; ax2.set_ylabel('Angle (radians)', color='g') 
    &gt;&gt;&gt; ax2.grid(True) 
    &gt;&gt;&gt; ax2.axis('tight') 
    &gt;&gt;&gt; ax2.set_ylim([-6, 1]) 
    &gt;&gt;&gt; nticks = 8 
    &gt;&gt;&gt; ax1.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks)) 
    &gt;&gt;&gt; ax2.yaxis.set_major_locator(matplotlib.ticker.LinearLocator(nticks)) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">ordfunc </span><span class="s3">= </span><span class="s1">filter_dict</span><span class="s3">[</span><span class="s1">ftype</span><span class="s3">][</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Invalid IIR filter type: %s&quot; </span><span class="s3">% </span><span class="s1">ftype</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>
    <span class="s2">except </span><span class="s1">IndexError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">((</span><span class="s4">&quot;%s does not have order selection. Use &quot;</span>
                          <span class="s4">&quot;iirfilter function.&quot;</span><span class="s3">) % </span><span class="s1">ftype</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s1">_validate_gpass_gstop</span><span class="s3">(</span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">)</span>

    <span class="s1">wp </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">)</span>
    <span class="s1">ws </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">ws</span><span class="s3">)</span>

    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">wp</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] != </span><span class="s1">ws</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] </span><span class="s2">or </span><span class="s1">wp</span><span class="s3">.</span><span class="s1">shape </span><span class="s2">not in </span><span class="s3">[(</span><span class="s5">1</span><span class="s3">,), (</span><span class="s5">2</span><span class="s3">,)]:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;wp and ws must have one or two elements each, and &quot;</span>
                         <span class="s4">f&quot;the same shape, got </span><span class="s2">{</span><span class="s1">wp</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">} </span><span class="s4">and </span><span class="s2">{</span><span class="s1">ws</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">wp </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or </span><span class="s1">any</span><span class="s3">(</span><span class="s1">ws </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Values for wp, ws must be greater than 0&quot;</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">analog</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">fs </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">wp </span><span class="s3">&gt;= </span><span class="s5">1</span><span class="s3">) </span><span class="s2">or </span><span class="s1">any</span><span class="s3">(</span><span class="s1">ws </span><span class="s3">&gt;= </span><span class="s5">1</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Values for wp, ws must be less than 1&quot;</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">any</span><span class="s3">(</span><span class="s1">wp </span><span class="s3">&gt;= </span><span class="s1">fs</span><span class="s3">/</span><span class="s5">2</span><span class="s3">) </span><span class="s2">or </span><span class="s1">any</span><span class="s3">(</span><span class="s1">ws </span><span class="s3">&gt;= </span><span class="s1">fs</span><span class="s3">/</span><span class="s5">2</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Values for wp, ws must be less than fs/2 &quot;</span>
                             <span class="s4">f&quot;(fs=</span><span class="s2">{</span><span class="s1">fs</span><span class="s2">} </span><span class="s4">-&gt; fs/2=</span><span class="s2">{</span><span class="s1">fs</span><span class="s3">/</span><span class="s5">2</span><span class="s2">}</span><span class="s4">)&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">wp</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">if not </span><span class="s3">((</span><span class="s1">ws</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] &lt; </span><span class="s1">wp</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] </span><span class="s2">and </span><span class="s1">wp</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt; </span><span class="s1">ws</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) </span><span class="s2">or</span>
               <span class="s3">(</span><span class="s1">wp</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] &lt; </span><span class="s1">ws</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] </span><span class="s2">and </span><span class="s1">ws</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] &lt; </span><span class="s1">wp</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Passband must lie strictly inside stopband &quot;</span>
                             <span class="s4">&quot;or vice versa&quot;</span><span class="s3">)</span>

    <span class="s1">band_type </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* (</span><span class="s1">len</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">band_type </span><span class="s3">+= </span><span class="s5">1</span>
    <span class="s2">if </span><span class="s1">wp</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] &gt;= </span><span class="s1">ws</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]:</span>
        <span class="s1">band_type </span><span class="s3">+= </span><span class="s5">1</span>

    <span class="s1">btype </span><span class="s3">= {</span><span class="s5">1</span><span class="s3">: </span><span class="s4">'lowpass'</span><span class="s3">, </span><span class="s5">2</span><span class="s3">: </span><span class="s4">'highpass'</span><span class="s3">,</span>
             <span class="s5">3</span><span class="s3">: </span><span class="s4">'bandstop'</span><span class="s3">, </span><span class="s5">4</span><span class="s3">: </span><span class="s4">'bandpass'</span><span class="s3">}[</span><span class="s1">band_type</span><span class="s3">]</span>

    <span class="s1">N</span><span class="s3">, </span><span class="s1">Wn </span><span class="s3">= </span><span class="s1">ordfunc</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s1">analog</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s1">fs</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">iirfilter</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">Wn</span><span class="s3">, </span><span class="s1">rp</span><span class="s3">=</span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">rs</span><span class="s3">=</span><span class="s1">gstop</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s1">analog</span><span class="s3">, </span><span class="s1">btype</span><span class="s3">=</span><span class="s1">btype</span><span class="s3">,</span>
                     <span class="s1">ftype</span><span class="s3">=</span><span class="s1">ftype</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s1">output</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s1">fs</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">iirfilter</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">Wn</span><span class="s3">, </span><span class="s1">rp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">rs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">btype</span><span class="s3">=</span><span class="s4">'band'</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
              <span class="s1">ftype</span><span class="s3">=</span><span class="s4">'butter'</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s4">'ba'</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    IIR digital and analog filter design given order and critical points. 
 
    Design an Nth-order digital or analog filter and return the filter 
    coefficients. 
 
    Parameters 
    ---------- 
    N : int 
        The order of the filter. 
    Wn : array_like 
        A scalar or length-2 sequence giving the critical frequencies. 
 
        For digital filters, `Wn` are in the same units as `fs`. By default, 
        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1, 
        where 1 is the Nyquist frequency. (`Wn` is thus in 
        half-cycles / sample.) 
 
        For analog filters, `Wn` is an angular frequency (e.g., rad/s). 
 
        When Wn is a length-2 sequence, ``Wn[0]`` must be less than ``Wn[1]``. 
    rp : float, optional 
        For Chebyshev and elliptic filters, provides the maximum ripple 
        in the passband. (dB) 
    rs : float, optional 
        For Chebyshev and elliptic filters, provides the minimum attenuation 
        in the stop band. (dB) 
    btype : {'bandpass', 'lowpass', 'highpass', 'bandstop'}, optional 
        The type of filter.  Default is 'bandpass'. 
    analog : bool, optional 
        When True, return an analog filter, otherwise a digital filter is 
        returned. 
    ftype : str, optional 
        The type of IIR filter to design: 
 
            - Butterworth   : 'butter' 
            - Chebyshev I   : 'cheby1' 
            - Chebyshev II  : 'cheby2' 
            - Cauer/elliptic: 'ellip' 
            - Bessel/Thomson: 'bessel' 
 
    output : {'ba', 'zpk', 'sos'}, optional 
        Filter form of the output: 
 
            - second-order sections (recommended): 'sos' 
            - numerator/denominator (default)    : 'ba' 
            - pole-zero                          : 'zpk' 
 
        In general the second-order sections ('sos') form  is 
        recommended because inferring the coefficients for the 
        numerator/denominator form ('ba') suffers from numerical 
        instabilities. For reasons of backward compatibility the default 
        form is the numerator/denominator form ('ba'), where the 'b' 
        and the 'a' in 'ba' refer to the commonly used names of the 
        coefficients used. 
 
        Note: Using the second-order sections form ('sos') is sometimes 
        associated with additional computational costs: for 
        data-intense use cases it is therefore recommended to also 
        investigate the numerator/denominator form ('ba'). 
 
    fs : float, optional 
        The sampling frequency of the digital system. 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    b, a : ndarray, ndarray 
        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter. 
        Only returned if ``output='ba'``. 
    z, p, k : ndarray, ndarray, float 
        Zeros, poles, and system gain of the IIR filter transfer 
        function.  Only returned if ``output='zpk'``. 
    sos : ndarray 
        Second-order sections representation of the IIR filter. 
        Only returned if ``output='sos'``. 
 
    See Also 
    -------- 
    butter : Filter design using order and critical points 
    cheby1, cheby2, ellip, bessel 
    buttord : Find order and critical points from passband and stopband spec 
    cheb1ord, cheb2ord, ellipord 
    iirdesign : General filter design using passband and stopband spec 
 
    Notes 
    ----- 
    The ``'sos'`` output parameter was added in 0.16.0. 
 
    Examples 
    -------- 
    Generate a 17th-order Chebyshev II analog bandpass filter from 50 Hz to 
    200 Hz and plot the frequency response: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; b, a = signal.iirfilter(17, [2*np.pi*50, 2*np.pi*200], rs=60, 
    ...                         btype='band', analog=True, ftype='cheby2') 
    &gt;&gt;&gt; w, h = signal.freqs(b, a, 1000) 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; ax = fig.add_subplot(1, 1, 1) 
    &gt;&gt;&gt; ax.semilogx(w / (2*np.pi), 20 * np.log10(np.maximum(abs(h), 1e-5))) 
    &gt;&gt;&gt; ax.set_title('Chebyshev Type II bandpass frequency response') 
    &gt;&gt;&gt; ax.set_xlabel('Frequency [Hz]') 
    &gt;&gt;&gt; ax.set_ylabel('Amplitude [dB]') 
    &gt;&gt;&gt; ax.axis((10, 1000, -100, 10)) 
    &gt;&gt;&gt; ax.grid(which='both', axis='both') 
    &gt;&gt;&gt; plt.show() 
 
    Create a digital filter with the same properties, in a system with 
    sampling rate of 2000 Hz, and plot the frequency response. (Second-order 
    sections implementation is required to ensure stability of a filter of 
    this order): 
 
    &gt;&gt;&gt; sos = signal.iirfilter(17, [50, 200], rs=60, btype='band', 
    ...                        analog=False, ftype='cheby2', fs=2000, 
    ...                        output='sos') 
    &gt;&gt;&gt; w, h = signal.sosfreqz(sos, 2000, fs=2000) 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; ax = fig.add_subplot(1, 1, 1) 
    &gt;&gt;&gt; ax.semilogx(w, 20 * np.log10(np.maximum(abs(h), 1e-5))) 
    &gt;&gt;&gt; ax.set_title('Chebyshev Type II bandpass frequency response') 
    &gt;&gt;&gt; ax.set_xlabel('Frequency [Hz]') 
    &gt;&gt;&gt; ax.set_ylabel('Amplitude [dB]') 
    &gt;&gt;&gt; ax.axis((10, 1000, -100, 10)) 
    &gt;&gt;&gt; ax.grid(which='both', axis='both') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">ftype</span><span class="s3">, </span><span class="s1">btype</span><span class="s3">, </span><span class="s1">output </span><span class="s3">= (</span><span class="s1">x</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">() </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s3">(</span><span class="s1">ftype</span><span class="s3">, </span><span class="s1">btype</span><span class="s3">, </span><span class="s1">output</span><span class="s3">))</span>
    <span class="s1">Wn </span><span class="s3">= </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">Wn</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">fs </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">analog</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;fs cannot be specified for an analog filter&quot;</span><span class="s3">)</span>
        <span class="s1">Wn </span><span class="s3">= </span><span class="s1">Wn </span><span class="s3">/ (</span><span class="s1">fs</span><span class="s3">/</span><span class="s5">2</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">Wn </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;filter critical frequencies must be greater than 0&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">Wn</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s5">1 </span><span class="s2">and not </span><span class="s1">Wn</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] &lt; </span><span class="s1">Wn</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Wn[0] must be less than Wn[1]&quot;</span><span class="s3">)</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">btype </span><span class="s3">= </span><span class="s1">band_dict</span><span class="s3">[</span><span class="s1">btype</span><span class="s3">]</span>
    <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;'%s' is an invalid bandtype for filter.&quot; </span><span class="s3">% </span><span class="s1">btype</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">typefunc </span><span class="s3">= </span><span class="s1">filter_dict</span><span class="s3">[</span><span class="s1">ftype</span><span class="s3">][</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;'%s' is not a valid basic IIR filter.&quot; </span><span class="s3">% </span><span class="s1">ftype</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s2">if </span><span class="s1">output </span><span class="s2">not in </span><span class="s3">[</span><span class="s4">'ba'</span><span class="s3">, </span><span class="s4">'zpk'</span><span class="s3">, </span><span class="s4">'sos'</span><span class="s3">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;'%s' is not a valid output form.&quot; </span><span class="s3">% </span><span class="s1">output</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">rp </span><span class="s2">is not None and </span><span class="s1">rp </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;passband ripple (rp) must be positive&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">rs </span><span class="s2">is not None and </span><span class="s1">rs </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;stopband attenuation (rs) must be positive&quot;</span><span class="s3">)</span>

    <span class="s6"># Get analog lowpass prototype</span>
    <span class="s2">if </span><span class="s1">typefunc </span><span class="s3">== </span><span class="s1">buttap</span><span class="s3">:</span>
        <span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">typefunc</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">typefunc </span><span class="s3">== </span><span class="s1">besselap</span><span class="s3">:</span>
        <span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">typefunc</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">norm</span><span class="s3">=</span><span class="s1">bessel_norms</span><span class="s3">[</span><span class="s1">ftype</span><span class="s3">])</span>
    <span class="s2">elif </span><span class="s1">typefunc </span><span class="s3">== </span><span class="s1">cheb1ap</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">rp </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;passband ripple (rp) must be provided to &quot;</span>
                             <span class="s4">&quot;design a Chebyshev I filter.&quot;</span><span class="s3">)</span>
        <span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">typefunc</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">rp</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">typefunc </span><span class="s3">== </span><span class="s1">cheb2ap</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">rs </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;stopband attenuation (rs) must be provided to &quot;</span>
                             <span class="s4">&quot;design an Chebyshev II filter.&quot;</span><span class="s3">)</span>
        <span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">typefunc</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">rs</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">typefunc </span><span class="s3">== </span><span class="s1">ellipap</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">rs </span><span class="s2">is None or </span><span class="s1">rp </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Both rp and rs must be provided to design an &quot;</span>
                             <span class="s4">&quot;elliptic filter.&quot;</span><span class="s3">)</span>
        <span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">typefunc</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">rp</span><span class="s3">, </span><span class="s1">rs</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">&quot;'%s' not implemented in iirfilter.&quot; </span><span class="s3">% </span><span class="s1">ftype</span><span class="s3">)</span>

    <span class="s6"># Pre-warp frequencies for digital filter design</span>
    <span class="s2">if not </span><span class="s1">analog</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">Wn </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">Wn </span><span class="s3">&gt;= </span><span class="s5">1</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">fs </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Digital filter critical frequencies must &quot;</span>
                                 <span class="s4">f&quot;be 0 &lt; Wn &lt; fs/2 (fs=</span><span class="s2">{</span><span class="s1">fs</span><span class="s2">} </span><span class="s4">-&gt; fs/2=</span><span class="s2">{</span><span class="s1">fs</span><span class="s3">/</span><span class="s5">2</span><span class="s2">}</span><span class="s4">)&quot;</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Digital filter critical frequencies &quot;</span>
                             <span class="s4">&quot;must be 0 &lt; Wn &lt; 1&quot;</span><span class="s3">)</span>
        <span class="s1">fs </span><span class="s3">= </span><span class="s5">2.0</span>
        <span class="s1">warped </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">fs </span><span class="s3">* </span><span class="s1">tan</span><span class="s3">(</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">Wn </span><span class="s3">/ </span><span class="s1">fs</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">warped </span><span class="s3">= </span><span class="s1">Wn</span>

    <span class="s6"># transform to lowpass, bandpass, highpass, or bandstop</span>
    <span class="s2">if </span><span class="s1">btype </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'lowpass'</span><span class="s3">, </span><span class="s4">'highpass'</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">size</span><span class="s3">(</span><span class="s1">Wn</span><span class="s3">) != </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Must specify a single critical frequency Wn '</span>
                             <span class="s4">'for lowpass or highpass filter'</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">btype </span><span class="s3">== </span><span class="s4">'lowpass'</span><span class="s3">:</span>
            <span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">lp2lp_zpk</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">wo</span><span class="s3">=</span><span class="s1">warped</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">btype </span><span class="s3">== </span><span class="s4">'highpass'</span><span class="s3">:</span>
            <span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">lp2hp_zpk</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">wo</span><span class="s3">=</span><span class="s1">warped</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">btype </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'bandpass'</span><span class="s3">, </span><span class="s4">'bandstop'</span><span class="s3">):</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">bw </span><span class="s3">= </span><span class="s1">warped</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">warped</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
            <span class="s1">wo </span><span class="s3">= </span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">warped</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">warped</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
        <span class="s2">except </span><span class="s1">IndexError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Wn must specify start and stop frequencies for '</span>
                             <span class="s4">'bandpass or bandstop filter'</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

        <span class="s2">if </span><span class="s1">btype </span><span class="s3">== </span><span class="s4">'bandpass'</span><span class="s3">:</span>
            <span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">lp2bp_zpk</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">wo</span><span class="s3">=</span><span class="s1">wo</span><span class="s3">, </span><span class="s1">bw</span><span class="s3">=</span><span class="s1">bw</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">btype </span><span class="s3">== </span><span class="s4">'bandstop'</span><span class="s3">:</span>
            <span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">lp2bs_zpk</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">wo</span><span class="s3">=</span><span class="s1">wo</span><span class="s3">, </span><span class="s1">bw</span><span class="s3">=</span><span class="s1">bw</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">&quot;'%s' not implemented in iirfilter.&quot; </span><span class="s3">% </span><span class="s1">btype</span><span class="s3">)</span>

    <span class="s6"># Find discrete equivalent if necessary</span>
    <span class="s2">if not </span><span class="s1">analog</span><span class="s3">:</span>
        <span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">bilinear_zpk</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s1">fs</span><span class="s3">)</span>

    <span class="s6"># Transform to proper out type (pole-zero, state-space, numer-denom)</span>
    <span class="s2">if </span><span class="s1">output </span><span class="s3">== </span><span class="s4">'zpk'</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span>
    <span class="s2">elif </span><span class="s1">output </span><span class="s3">== </span><span class="s4">'ba'</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">zpk2tf</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">output </span><span class="s3">== </span><span class="s4">'sos'</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">zpk2sos</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s1">analog</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_relative_degree</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return relative degree of transfer function from zeros and poles 
    &quot;&quot;&quot;</span>
    <span class="s1">degree </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) - </span><span class="s1">len</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">degree </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Improper transfer function. &quot;</span>
                         <span class="s4">&quot;Must have at least as many poles as zeros.&quot;</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">degree</span>


<span class="s2">def </span><span class="s1">bilinear_zpk</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Return a digital IIR filter from an analog one using a bilinear transform. 
 
    Transform a set of poles and zeros from the analog s-plane to the digital 
    z-plane using Tustin's method, which substitutes ``2*fs*(z-1) / (z+1)`` for 
    ``s``, maintaining the shape of the frequency response. 
 
    Parameters 
    ---------- 
    z : array_like 
        Zeros of the analog filter transfer function. 
    p : array_like 
        Poles of the analog filter transfer function. 
    k : float 
        System gain of the analog filter transfer function. 
    fs : float 
        Sample rate, as ordinary frequency (e.g., hertz). No prewarping is 
        done in this function. 
 
    Returns 
    ------- 
    z : ndarray 
        Zeros of the transformed digital filter transfer function. 
    p : ndarray 
        Poles of the transformed digital filter transfer function. 
    k : float 
        System gain of the transformed digital filter. 
 
    See Also 
    -------- 
    lp2lp_zpk, lp2hp_zpk, lp2bp_zpk, lp2bs_zpk 
    bilinear 
 
    Notes 
    ----- 
    .. versionadded:: 1.1.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; fs = 100 
    &gt;&gt;&gt; bf = 2 * np.pi * np.array([7, 13]) 
    &gt;&gt;&gt; filts = signal.lti(*signal.butter(4, bf, btype='bandpass', analog=True, 
    ...                                   output='zpk')) 
    &gt;&gt;&gt; filtz = signal.lti(*signal.bilinear_zpk(filts.zeros, filts.poles, 
    ...                                         filts.gain, fs)) 
    &gt;&gt;&gt; wz, hz = signal.freqz_zpk(filtz.zeros, filtz.poles, filtz.gain) 
    &gt;&gt;&gt; ws, hs = signal.freqs_zpk(filts.zeros, filts.poles, filts.gain, 
    ...                           worN=fs*wz) 
    &gt;&gt;&gt; plt.semilogx(wz*fs/(2*np.pi), 20*np.log10(np.abs(hz).clip(1e-15)), 
    ...              label=r'$|H_z(e^{j \omega})|$') 
    &gt;&gt;&gt; plt.semilogx(wz*fs/(2*np.pi), 20*np.log10(np.abs(hs).clip(1e-15)), 
    ...              label=r'$|H(j \omega)|$') 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.xlabel('Frequency [Hz]') 
    &gt;&gt;&gt; plt.ylabel('Magnitude [dB]') 
    &gt;&gt;&gt; plt.grid(True) 
    &quot;&quot;&quot;</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>

    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s1">degree </span><span class="s3">= </span><span class="s1">_relative_degree</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s1">fs2 </span><span class="s3">= </span><span class="s5">2.0</span><span class="s3">*</span><span class="s1">fs</span>

    <span class="s6"># Bilinear transform the poles and zeros</span>
    <span class="s1">z_z </span><span class="s3">= (</span><span class="s1">fs2 </span><span class="s3">+ </span><span class="s1">z</span><span class="s3">) / (</span><span class="s1">fs2 </span><span class="s3">- </span><span class="s1">z</span><span class="s3">)</span>
    <span class="s1">p_z </span><span class="s3">= (</span><span class="s1">fs2 </span><span class="s3">+ </span><span class="s1">p</span><span class="s3">) / (</span><span class="s1">fs2 </span><span class="s3">- </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s6"># Any zeros that were at infinity get moved to the Nyquist frequency</span>
    <span class="s1">z_z </span><span class="s3">= </span><span class="s1">append</span><span class="s3">(</span><span class="s1">z_z</span><span class="s3">, -</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">degree</span><span class="s3">))</span>

    <span class="s6"># Compensate for gain change</span>
    <span class="s1">k_z </span><span class="s3">= </span><span class="s1">k </span><span class="s3">* </span><span class="s1">real</span><span class="s3">(</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">fs2 </span><span class="s3">- </span><span class="s1">z</span><span class="s3">) / </span><span class="s1">prod</span><span class="s3">(</span><span class="s1">fs2 </span><span class="s3">- </span><span class="s1">p</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">z_z</span><span class="s3">, </span><span class="s1">p_z</span><span class="s3">, </span><span class="s1">k_z</span>


<span class="s2">def </span><span class="s1">lp2lp_zpk</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">wo</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Transform a lowpass filter prototype to a different frequency. 
 
    Return an analog low-pass filter with cutoff frequency `wo` 
    from an analog low-pass filter prototype with unity cutoff frequency, 
    using zeros, poles, and gain ('zpk') representation. 
 
    Parameters 
    ---------- 
    z : array_like 
        Zeros of the analog filter transfer function. 
    p : array_like 
        Poles of the analog filter transfer function. 
    k : float 
        System gain of the analog filter transfer function. 
    wo : float 
        Desired cutoff, as angular frequency (e.g., rad/s). 
        Defaults to no change. 
 
    Returns 
    ------- 
    z : ndarray 
        Zeros of the transformed low-pass filter transfer function. 
    p : ndarray 
        Poles of the transformed low-pass filter transfer function. 
    k : float 
        System gain of the transformed low-pass filter. 
 
    See Also 
    -------- 
    lp2hp_zpk, lp2bp_zpk, lp2bs_zpk, bilinear 
    lp2lp 
 
    Notes 
    ----- 
    This is derived from the s-plane substitution 
 
    .. math:: s \rightarrow \frac{s}{\omega_0} 
 
    .. versionadded:: 1.1.0 
 
    Examples 
    -------- 
    Use the 'zpk' (Zero-Pole-Gain) representation of a lowpass filter to  
    transform it to a new 'zpk' representation associated with a cutoff frequency wo. 
 
    &gt;&gt;&gt; from scipy.signal import lp2lp_zpk 
    &gt;&gt;&gt; z   = [7,   2] 
    &gt;&gt;&gt; p   = [5,   13] 
    &gt;&gt;&gt; k   = 0.8 
    &gt;&gt;&gt; wo  = 0.4 
    &gt;&gt;&gt; lp2lp_zpk(z, p, k, wo) 
    (   array([2.8, 0.8]), array([2. , 5.2]), 0.8) 
    &quot;&quot;&quot;</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
    <span class="s1">wo </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">wo</span><span class="s3">)  </span><span class="s6"># Avoid int wraparound</span>

    <span class="s1">degree </span><span class="s3">= </span><span class="s1">_relative_degree</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s6"># Scale all points radially from origin to shift cutoff frequency</span>
    <span class="s1">z_lp </span><span class="s3">= </span><span class="s1">wo </span><span class="s3">* </span><span class="s1">z</span>
    <span class="s1">p_lp </span><span class="s3">= </span><span class="s1">wo </span><span class="s3">* </span><span class="s1">p</span>

    <span class="s6"># Each shifted pole decreases gain by wo, each shifted zero increases it.</span>
    <span class="s6"># Cancel out the net change to keep overall gain the same</span>
    <span class="s1">k_lp </span><span class="s3">= </span><span class="s1">k </span><span class="s3">* </span><span class="s1">wo</span><span class="s3">**</span><span class="s1">degree</span>

    <span class="s2">return </span><span class="s1">z_lp</span><span class="s3">, </span><span class="s1">p_lp</span><span class="s3">, </span><span class="s1">k_lp</span>


<span class="s2">def </span><span class="s1">lp2hp_zpk</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">wo</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Transform a lowpass filter prototype to a highpass filter. 
 
    Return an analog high-pass filter with cutoff frequency `wo` 
    from an analog low-pass filter prototype with unity cutoff frequency, 
    using zeros, poles, and gain ('zpk') representation. 
 
    Parameters 
    ---------- 
    z : array_like 
        Zeros of the analog filter transfer function. 
    p : array_like 
        Poles of the analog filter transfer function. 
    k : float 
        System gain of the analog filter transfer function. 
    wo : float 
        Desired cutoff, as angular frequency (e.g., rad/s). 
        Defaults to no change. 
 
    Returns 
    ------- 
    z : ndarray 
        Zeros of the transformed high-pass filter transfer function. 
    p : ndarray 
        Poles of the transformed high-pass filter transfer function. 
    k : float 
        System gain of the transformed high-pass filter. 
 
    See Also 
    -------- 
    lp2lp_zpk, lp2bp_zpk, lp2bs_zpk, bilinear 
    lp2hp 
 
    Notes 
    ----- 
    This is derived from the s-plane substitution 
 
    .. math:: s \rightarrow \frac{\omega_0}{s} 
 
    This maintains symmetry of the lowpass and highpass responses on a 
    logarithmic scale. 
 
    .. versionadded:: 1.1.0 
     
    Examples 
    -------- 
    Use the 'zpk' (Zero-Pole-Gain) representation of a lowpass filter to  
    transform it to a highpass filter with a cutoff frequency wo. 
     
    &gt;&gt;&gt; from scipy.signal import lp2hp_zpk 
    &gt;&gt;&gt; z   = [ -2 + 3j ,  -0.5 - 0.8j ] 
    &gt;&gt;&gt; p   = [ -1      ,  -4          ] 
    &gt;&gt;&gt; k   = 10 
    &gt;&gt;&gt; wo  = 0.6 
    &gt;&gt;&gt; lp2hp_zpk(z, p, k, wo) 
    (   array([-0.09230769-0.13846154j, -0.33707865+0.53932584j]), 
        array([-0.6 , -0.15]), 
        8.5) 
    &quot;&quot;&quot;</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
    <span class="s1">wo </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">wo</span><span class="s3">)</span>

    <span class="s1">degree </span><span class="s3">= </span><span class="s1">_relative_degree</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s6"># Invert positions radially about unit circle to convert LPF to HPF</span>
    <span class="s6"># Scale all points radially from origin to shift cutoff frequency</span>
    <span class="s1">z_hp </span><span class="s3">= </span><span class="s1">wo </span><span class="s3">/ </span><span class="s1">z</span>
    <span class="s1">p_hp </span><span class="s3">= </span><span class="s1">wo </span><span class="s3">/ </span><span class="s1">p</span>

    <span class="s6"># If lowpass had zeros at infinity, inverting moves them to origin.</span>
    <span class="s1">z_hp </span><span class="s3">= </span><span class="s1">append</span><span class="s3">(</span><span class="s1">z_hp</span><span class="s3">, </span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">degree</span><span class="s3">))</span>

    <span class="s6"># Cancel out gain change caused by inversion</span>
    <span class="s1">k_hp </span><span class="s3">= </span><span class="s1">k </span><span class="s3">* </span><span class="s1">real</span><span class="s3">(</span><span class="s1">prod</span><span class="s3">(-</span><span class="s1">z</span><span class="s3">) / </span><span class="s1">prod</span><span class="s3">(-</span><span class="s1">p</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">z_hp</span><span class="s3">, </span><span class="s1">p_hp</span><span class="s3">, </span><span class="s1">k_hp</span>


<span class="s2">def </span><span class="s1">lp2bp_zpk</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">wo</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">bw</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Transform a lowpass filter prototype to a bandpass filter. 
 
    Return an analog band-pass filter with center frequency `wo` and 
    bandwidth `bw` from an analog low-pass filter prototype with unity 
    cutoff frequency, using zeros, poles, and gain ('zpk') representation. 
 
    Parameters 
    ---------- 
    z : array_like 
        Zeros of the analog filter transfer function. 
    p : array_like 
        Poles of the analog filter transfer function. 
    k : float 
        System gain of the analog filter transfer function. 
    wo : float 
        Desired passband center, as angular frequency (e.g., rad/s). 
        Defaults to no change. 
    bw : float 
        Desired passband width, as angular frequency (e.g., rad/s). 
        Defaults to 1. 
 
    Returns 
    ------- 
    z : ndarray 
        Zeros of the transformed band-pass filter transfer function. 
    p : ndarray 
        Poles of the transformed band-pass filter transfer function. 
    k : float 
        System gain of the transformed band-pass filter. 
 
    See Also 
    -------- 
    lp2lp_zpk, lp2hp_zpk, lp2bs_zpk, bilinear 
    lp2bp 
 
    Notes 
    ----- 
    This is derived from the s-plane substitution 
 
    .. math:: s \rightarrow \frac{s^2 + {\omega_0}^2}{s \cdot \mathrm{BW}} 
 
    This is the &quot;wideband&quot; transformation, producing a passband with 
    geometric (log frequency) symmetry about `wo`. 
 
    .. versionadded:: 1.1.0 
     
    Examples 
    -------- 
    Use the 'zpk' (Zero-Pole-Gain) representation of a lowpass filter to  
    transform it to a bandpass filter with a center frequency wo and 
    bandwidth bw. 
     
    &gt;&gt;&gt; from scipy.signal import lp2bp_zpk 
    &gt;&gt;&gt; z   = [ 5 + 2j ,  5 - 2j ] 
    &gt;&gt;&gt; p   = [ 7      ,  -16    ] 
    &gt;&gt;&gt; k   = 0.8 
    &gt;&gt;&gt; wo  = 0.62 
    &gt;&gt;&gt; bw  = 15 
    &gt;&gt;&gt; lp2bp_zpk(z, p, k, wo, bw) 
    (   array([7.49955815e+01+3.00017676e+01j, 7.49955815e+01-3.00017676e+01j, 
               4.41850748e-03-1.76761126e-03j, 4.41850748e-03+1.76761126e-03j]),  
        array([1.04996339e+02+0.j, -1.60167736e-03+0.j,  3.66108003e-03+0.j, 
               -2.39998398e+02+0.j]), 0.8) 
    &quot;&quot;&quot;</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
    <span class="s1">wo </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">wo</span><span class="s3">)</span>
    <span class="s1">bw </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">bw</span><span class="s3">)</span>

    <span class="s1">degree </span><span class="s3">= </span><span class="s1">_relative_degree</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s6"># Scale poles and zeros to desired bandwidth</span>
    <span class="s1">z_lp </span><span class="s3">= </span><span class="s1">z </span><span class="s3">* </span><span class="s1">bw</span><span class="s3">/</span><span class="s5">2</span>
    <span class="s1">p_lp </span><span class="s3">= </span><span class="s1">p </span><span class="s3">* </span><span class="s1">bw</span><span class="s3">/</span><span class="s5">2</span>

    <span class="s6"># Square root needs to produce complex result, not NaN</span>
    <span class="s1">z_lp </span><span class="s3">= </span><span class="s1">z_lp</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">complex</span><span class="s3">)</span>
    <span class="s1">p_lp </span><span class="s3">= </span><span class="s1">p_lp</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">complex</span><span class="s3">)</span>

    <span class="s6"># Duplicate poles and zeros and shift from baseband to +wo and -wo</span>
    <span class="s1">z_bp </span><span class="s3">= </span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">z_lp </span><span class="s3">+ </span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">z_lp</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">- </span><span class="s1">wo</span><span class="s3">**</span><span class="s5">2</span><span class="s3">),</span>
                        <span class="s1">z_lp </span><span class="s3">- </span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">z_lp</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">- </span><span class="s1">wo</span><span class="s3">**</span><span class="s5">2</span><span class="s3">)))</span>
    <span class="s1">p_bp </span><span class="s3">= </span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">p_lp </span><span class="s3">+ </span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">p_lp</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">- </span><span class="s1">wo</span><span class="s3">**</span><span class="s5">2</span><span class="s3">),</span>
                        <span class="s1">p_lp </span><span class="s3">- </span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">p_lp</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">- </span><span class="s1">wo</span><span class="s3">**</span><span class="s5">2</span><span class="s3">)))</span>

    <span class="s6"># Move degree zeros to origin, leaving degree zeros at infinity for BPF</span>
    <span class="s1">z_bp </span><span class="s3">= </span><span class="s1">append</span><span class="s3">(</span><span class="s1">z_bp</span><span class="s3">, </span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">degree</span><span class="s3">))</span>

    <span class="s6"># Cancel out gain change from frequency scaling</span>
    <span class="s1">k_bp </span><span class="s3">= </span><span class="s1">k </span><span class="s3">* </span><span class="s1">bw</span><span class="s3">**</span><span class="s1">degree</span>

    <span class="s2">return </span><span class="s1">z_bp</span><span class="s3">, </span><span class="s1">p_bp</span><span class="s3">, </span><span class="s1">k_bp</span>


<span class="s2">def </span><span class="s1">lp2bs_zpk</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">wo</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">bw</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Transform a lowpass filter prototype to a bandstop filter. 
 
    Return an analog band-stop filter with center frequency `wo` and 
    stopband width `bw` from an analog low-pass filter prototype with unity 
    cutoff frequency, using zeros, poles, and gain ('zpk') representation. 
 
    Parameters 
    ---------- 
    z : array_like 
        Zeros of the analog filter transfer function. 
    p : array_like 
        Poles of the analog filter transfer function. 
    k : float 
        System gain of the analog filter transfer function. 
    wo : float 
        Desired stopband center, as angular frequency (e.g., rad/s). 
        Defaults to no change. 
    bw : float 
        Desired stopband width, as angular frequency (e.g., rad/s). 
        Defaults to 1. 
 
    Returns 
    ------- 
    z : ndarray 
        Zeros of the transformed band-stop filter transfer function. 
    p : ndarray 
        Poles of the transformed band-stop filter transfer function. 
    k : float 
        System gain of the transformed band-stop filter. 
 
    See Also 
    -------- 
    lp2lp_zpk, lp2hp_zpk, lp2bp_zpk, bilinear 
    lp2bs 
 
    Notes 
    ----- 
    This is derived from the s-plane substitution 
 
    .. math:: s \rightarrow \frac{s \cdot \mathrm{BW}}{s^2 + {\omega_0}^2} 
 
    This is the &quot;wideband&quot; transformation, producing a stopband with 
    geometric (log frequency) symmetry about `wo`. 
 
    .. versionadded:: 1.1.0 
 
    Examples 
    -------- 
    Transform a low-pass filter represented in 'zpk' (Zero-Pole-Gain) form  
    into a bandstop filter represented in 'zpk' form, with a center frequency wo and 
    bandwidth bw. 
     
    &gt;&gt;&gt; from scipy.signal import lp2bs_zpk 
    &gt;&gt;&gt; z   = [             ] 
    &gt;&gt;&gt; p   = [ 0.7 ,    -1 ] 
    &gt;&gt;&gt; k   = 9 
    &gt;&gt;&gt; wo  = 0.5 
    &gt;&gt;&gt; bw  = 10 
    &gt;&gt;&gt; lp2bs_zpk(z, p, k, wo, bw) 
    (   array([0.+0.5j, 0.+0.5j, 0.-0.5j, 0.-0.5j]),  
        array([14.2681928 +0.j, -0.02506281+0.j,  0.01752149+0.j, -9.97493719+0.j]),  
        -12.857142857142858) 
    &quot;&quot;&quot;</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
    <span class="s1">wo </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">wo</span><span class="s3">)</span>
    <span class="s1">bw </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">bw</span><span class="s3">)</span>

    <span class="s1">degree </span><span class="s3">= </span><span class="s1">_relative_degree</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s6"># Invert to a highpass filter with desired bandwidth</span>
    <span class="s1">z_hp </span><span class="s3">= (</span><span class="s1">bw</span><span class="s3">/</span><span class="s5">2</span><span class="s3">) / </span><span class="s1">z</span>
    <span class="s1">p_hp </span><span class="s3">= (</span><span class="s1">bw</span><span class="s3">/</span><span class="s5">2</span><span class="s3">) / </span><span class="s1">p</span>

    <span class="s6"># Square root needs to produce complex result, not NaN</span>
    <span class="s1">z_hp </span><span class="s3">= </span><span class="s1">z_hp</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">complex</span><span class="s3">)</span>
    <span class="s1">p_hp </span><span class="s3">= </span><span class="s1">p_hp</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">complex</span><span class="s3">)</span>

    <span class="s6"># Duplicate poles and zeros and shift from baseband to +wo and -wo</span>
    <span class="s1">z_bs </span><span class="s3">= </span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">z_hp </span><span class="s3">+ </span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">z_hp</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">- </span><span class="s1">wo</span><span class="s3">**</span><span class="s5">2</span><span class="s3">),</span>
                        <span class="s1">z_hp </span><span class="s3">- </span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">z_hp</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">- </span><span class="s1">wo</span><span class="s3">**</span><span class="s5">2</span><span class="s3">)))</span>
    <span class="s1">p_bs </span><span class="s3">= </span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">p_hp </span><span class="s3">+ </span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">p_hp</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">- </span><span class="s1">wo</span><span class="s3">**</span><span class="s5">2</span><span class="s3">),</span>
                        <span class="s1">p_hp </span><span class="s3">- </span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">p_hp</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">- </span><span class="s1">wo</span><span class="s3">**</span><span class="s5">2</span><span class="s3">)))</span>

    <span class="s6"># Move any zeros that were at infinity to the center of the stopband</span>
    <span class="s1">z_bs </span><span class="s3">= </span><span class="s1">append</span><span class="s3">(</span><span class="s1">z_bs</span><span class="s3">, </span><span class="s1">full</span><span class="s3">(</span><span class="s1">degree</span><span class="s3">, +</span><span class="s5">1j</span><span class="s3">*</span><span class="s1">wo</span><span class="s3">))</span>
    <span class="s1">z_bs </span><span class="s3">= </span><span class="s1">append</span><span class="s3">(</span><span class="s1">z_bs</span><span class="s3">, </span><span class="s1">full</span><span class="s3">(</span><span class="s1">degree</span><span class="s3">, -</span><span class="s5">1j</span><span class="s3">*</span><span class="s1">wo</span><span class="s3">))</span>

    <span class="s6"># Cancel out gain change caused by inversion</span>
    <span class="s1">k_bs </span><span class="s3">= </span><span class="s1">k </span><span class="s3">* </span><span class="s1">real</span><span class="s3">(</span><span class="s1">prod</span><span class="s3">(-</span><span class="s1">z</span><span class="s3">) / </span><span class="s1">prod</span><span class="s3">(-</span><span class="s1">p</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">z_bs</span><span class="s3">, </span><span class="s1">p_bs</span><span class="s3">, </span><span class="s1">k_bs</span>


<span class="s2">def </span><span class="s1">butter</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">Wn</span><span class="s3">, </span><span class="s1">btype</span><span class="s3">=</span><span class="s4">'low'</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s4">'ba'</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Butterworth digital and analog filter design. 
 
    Design an Nth-order digital or analog Butterworth filter and return 
    the filter coefficients. 
 
    Parameters 
    ---------- 
    N : int 
        The order of the filter. For 'bandpass' and 'bandstop' filters, 
        the resulting order of the final second-order sections ('sos') 
        matrix is ``2*N``, with `N` the number of biquad sections 
        of the desired system. 
    Wn : array_like 
        The critical frequency or frequencies. For lowpass and highpass 
        filters, Wn is a scalar; for bandpass and bandstop filters, 
        Wn is a length-2 sequence. 
 
        For a Butterworth filter, this is the point at which the gain 
        drops to 1/sqrt(2) that of the passband (the &quot;-3 dB point&quot;). 
 
        For digital filters, if `fs` is not specified, `Wn` units are 
        normalized from 0 to 1, where 1 is the Nyquist frequency (`Wn` is 
        thus in half cycles / sample and defined as 2*critical frequencies 
        / `fs`). If `fs` is specified, `Wn` is in the same units as `fs`. 
 
        For analog filters, `Wn` is an angular frequency (e.g. rad/s). 
    btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional 
        The type of filter.  Default is 'lowpass'. 
    analog : bool, optional 
        When True, return an analog filter, otherwise a digital filter is 
        returned. 
    output : {'ba', 'zpk', 'sos'}, optional 
        Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or 
        second-order sections ('sos'). Default is 'ba' for backwards 
        compatibility, but 'sos' should be used for general-purpose filtering. 
    fs : float, optional 
        The sampling frequency of the digital system. 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    b, a : ndarray, ndarray 
        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter. 
        Only returned if ``output='ba'``. 
    z, p, k : ndarray, ndarray, float 
        Zeros, poles, and system gain of the IIR filter transfer 
        function.  Only returned if ``output='zpk'``. 
    sos : ndarray 
        Second-order sections representation of the IIR filter. 
        Only returned if ``output='sos'``. 
 
    See Also 
    -------- 
    buttord, buttap 
 
    Notes 
    ----- 
    The Butterworth filter has maximally flat frequency response in the 
    passband. 
 
    The ``'sos'`` output parameter was added in 0.16.0. 
 
    If the transfer function form ``[b, a]`` is requested, numerical 
    problems can occur since the conversion between roots and 
    the polynomial coefficients is a numerically sensitive operation, 
    even for N &gt;= 4. It is recommended to work with the SOS 
    representation. 
 
    .. warning:: 
        Designing high-order and narrowband IIR filters in TF form can 
        result in unstable or incorrect filtering due to floating point 
        numerical precision issues. Consider inspecting output filter 
        characteristics `freqz` or designing the filters with second-order 
        sections via ``output='sos'``. 
 
    Examples 
    -------- 
    Design an analog filter and plot its frequency response, showing the 
    critical points: 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; b, a = signal.butter(4, 100, 'low', analog=True) 
    &gt;&gt;&gt; w, h = signal.freqs(b, a) 
    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h))) 
    &gt;&gt;&gt; plt.title('Butterworth filter frequency response') 
    &gt;&gt;&gt; plt.xlabel('Frequency [radians / second]') 
    &gt;&gt;&gt; plt.ylabel('Amplitude [dB]') 
    &gt;&gt;&gt; plt.margins(0, 0.1) 
    &gt;&gt;&gt; plt.grid(which='both', axis='both') 
    &gt;&gt;&gt; plt.axvline(100, color='green') # cutoff frequency 
    &gt;&gt;&gt; plt.show() 
 
    Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz 
 
    &gt;&gt;&gt; t = np.linspace(0, 1, 1000, False)  # 1 second 
    &gt;&gt;&gt; sig = np.sin(2*np.pi*10*t) + np.sin(2*np.pi*20*t) 
    &gt;&gt;&gt; fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True) 
    &gt;&gt;&gt; ax1.plot(t, sig) 
    &gt;&gt;&gt; ax1.set_title('10 Hz and 20 Hz sinusoids') 
    &gt;&gt;&gt; ax1.axis([0, 1, -2, 2]) 
 
    Design a digital high-pass filter at 15 Hz to remove the 10 Hz tone, and 
    apply it to the signal. (It's recommended to use second-order sections 
    format when filtering, to avoid numerical error with transfer function 
    (``ba``) format): 
 
    &gt;&gt;&gt; sos = signal.butter(10, 15, 'hp', fs=1000, output='sos') 
    &gt;&gt;&gt; filtered = signal.sosfilt(sos, sig) 
    &gt;&gt;&gt; ax2.plot(t, filtered) 
    &gt;&gt;&gt; ax2.set_title('After 15 Hz high-pass filter') 
    &gt;&gt;&gt; ax2.axis([0, 1, -2, 2]) 
    &gt;&gt;&gt; ax2.set_xlabel('Time [seconds]') 
    &gt;&gt;&gt; plt.tight_layout() 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">iirfilter</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">Wn</span><span class="s3">, </span><span class="s1">btype</span><span class="s3">=</span><span class="s1">btype</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s1">analog</span><span class="s3">,</span>
                     <span class="s1">output</span><span class="s3">=</span><span class="s1">output</span><span class="s3">, </span><span class="s1">ftype</span><span class="s3">=</span><span class="s4">'butter'</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s1">fs</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">cheby1</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">rp</span><span class="s3">, </span><span class="s1">Wn</span><span class="s3">, </span><span class="s1">btype</span><span class="s3">=</span><span class="s4">'low'</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s4">'ba'</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Chebyshev type I digital and analog filter design. 
 
    Design an Nth-order digital or analog Chebyshev type I filter and 
    return the filter coefficients. 
 
    Parameters 
    ---------- 
    N : int 
        The order of the filter. 
    rp : float 
        The maximum ripple allowed below unity gain in the passband. 
        Specified in decibels, as a positive number. 
    Wn : array_like 
        A scalar or length-2 sequence giving the critical frequencies. 
        For Type I filters, this is the point in the transition band at which 
        the gain first drops below -`rp`. 
 
        For digital filters, `Wn` are in the same units as `fs`. By default, 
        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1, 
        where 1 is the Nyquist frequency. (`Wn` is thus in 
        half-cycles / sample.) 
 
        For analog filters, `Wn` is an angular frequency (e.g., rad/s). 
    btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional 
        The type of filter.  Default is 'lowpass'. 
    analog : bool, optional 
        When True, return an analog filter, otherwise a digital filter is 
        returned. 
    output : {'ba', 'zpk', 'sos'}, optional 
        Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or 
        second-order sections ('sos'). Default is 'ba' for backwards 
        compatibility, but 'sos' should be used for general-purpose filtering. 
    fs : float, optional 
        The sampling frequency of the digital system. 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    b, a : ndarray, ndarray 
        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter. 
        Only returned if ``output='ba'``. 
    z, p, k : ndarray, ndarray, float 
        Zeros, poles, and system gain of the IIR filter transfer 
        function.  Only returned if ``output='zpk'``. 
    sos : ndarray 
        Second-order sections representation of the IIR filter. 
        Only returned if ``output='sos'``. 
 
    See Also 
    -------- 
    cheb1ord, cheb1ap 
 
    Notes 
    ----- 
    The Chebyshev type I filter maximizes the rate of cutoff between the 
    frequency response's passband and stopband, at the expense of ripple in 
    the passband and increased ringing in the step response. 
 
    Type I filters roll off faster than Type II (`cheby2`), but Type II 
    filters do not have any ripple in the passband. 
 
    The equiripple passband has N maxima or minima (for example, a 
    5th-order filter has 3 maxima and 2 minima). Consequently, the DC gain is 
    unity for odd-order filters, or -rp dB for even-order filters. 
 
    The ``'sos'`` output parameter was added in 0.16.0. 
 
    Examples 
    -------- 
    Design an analog filter and plot its frequency response, showing the 
    critical points: 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; b, a = signal.cheby1(4, 5, 100, 'low', analog=True) 
    &gt;&gt;&gt; w, h = signal.freqs(b, a) 
    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h))) 
    &gt;&gt;&gt; plt.title('Chebyshev Type I frequency response (rp=5)') 
    &gt;&gt;&gt; plt.xlabel('Frequency [radians / second]') 
    &gt;&gt;&gt; plt.ylabel('Amplitude [dB]') 
    &gt;&gt;&gt; plt.margins(0, 0.1) 
    &gt;&gt;&gt; plt.grid(which='both', axis='both') 
    &gt;&gt;&gt; plt.axvline(100, color='green') # cutoff frequency 
    &gt;&gt;&gt; plt.axhline(-5, color='green') # rp 
    &gt;&gt;&gt; plt.show() 
 
    Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz 
 
    &gt;&gt;&gt; t = np.linspace(0, 1, 1000, False)  # 1 second 
    &gt;&gt;&gt; sig = np.sin(2*np.pi*10*t) + np.sin(2*np.pi*20*t) 
    &gt;&gt;&gt; fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True) 
    &gt;&gt;&gt; ax1.plot(t, sig) 
    &gt;&gt;&gt; ax1.set_title('10 Hz and 20 Hz sinusoids') 
    &gt;&gt;&gt; ax1.axis([0, 1, -2, 2]) 
 
    Design a digital high-pass filter at 15 Hz to remove the 10 Hz tone, and 
    apply it to the signal. (It's recommended to use second-order sections 
    format when filtering, to avoid numerical error with transfer function 
    (``ba``) format): 
 
    &gt;&gt;&gt; sos = signal.cheby1(10, 1, 15, 'hp', fs=1000, output='sos') 
    &gt;&gt;&gt; filtered = signal.sosfilt(sos, sig) 
    &gt;&gt;&gt; ax2.plot(t, filtered) 
    &gt;&gt;&gt; ax2.set_title('After 15 Hz high-pass filter') 
    &gt;&gt;&gt; ax2.axis([0, 1, -2, 2]) 
    &gt;&gt;&gt; ax2.set_xlabel('Time [seconds]') 
    &gt;&gt;&gt; plt.tight_layout() 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">iirfilter</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">Wn</span><span class="s3">, </span><span class="s1">rp</span><span class="s3">=</span><span class="s1">rp</span><span class="s3">, </span><span class="s1">btype</span><span class="s3">=</span><span class="s1">btype</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s1">analog</span><span class="s3">,</span>
                     <span class="s1">output</span><span class="s3">=</span><span class="s1">output</span><span class="s3">, </span><span class="s1">ftype</span><span class="s3">=</span><span class="s4">'cheby1'</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s1">fs</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">cheby2</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">rs</span><span class="s3">, </span><span class="s1">Wn</span><span class="s3">, </span><span class="s1">btype</span><span class="s3">=</span><span class="s4">'low'</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s4">'ba'</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Chebyshev type II digital and analog filter design. 
 
    Design an Nth-order digital or analog Chebyshev type II filter and 
    return the filter coefficients. 
 
    Parameters 
    ---------- 
    N : int 
        The order of the filter. 
    rs : float 
        The minimum attenuation required in the stop band. 
        Specified in decibels, as a positive number. 
    Wn : array_like 
        A scalar or length-2 sequence giving the critical frequencies. 
        For Type II filters, this is the point in the transition band at which 
        the gain first reaches -`rs`. 
 
        For digital filters, `Wn` are in the same units as `fs`. By default, 
        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1, 
        where 1 is the Nyquist frequency. (`Wn` is thus in 
        half-cycles / sample.) 
 
        For analog filters, `Wn` is an angular frequency (e.g., rad/s). 
    btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional 
        The type of filter.  Default is 'lowpass'. 
    analog : bool, optional 
        When True, return an analog filter, otherwise a digital filter is 
        returned. 
    output : {'ba', 'zpk', 'sos'}, optional 
        Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or 
        second-order sections ('sos'). Default is 'ba' for backwards 
        compatibility, but 'sos' should be used for general-purpose filtering. 
    fs : float, optional 
        The sampling frequency of the digital system. 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    b, a : ndarray, ndarray 
        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter. 
        Only returned if ``output='ba'``. 
    z, p, k : ndarray, ndarray, float 
        Zeros, poles, and system gain of the IIR filter transfer 
        function.  Only returned if ``output='zpk'``. 
    sos : ndarray 
        Second-order sections representation of the IIR filter. 
        Only returned if ``output='sos'``. 
 
    See Also 
    -------- 
    cheb2ord, cheb2ap 
 
    Notes 
    ----- 
    The Chebyshev type II filter maximizes the rate of cutoff between the 
    frequency response's passband and stopband, at the expense of ripple in 
    the stopband and increased ringing in the step response. 
 
    Type II filters do not roll off as fast as Type I (`cheby1`). 
 
    The ``'sos'`` output parameter was added in 0.16.0. 
 
    Examples 
    -------- 
    Design an analog filter and plot its frequency response, showing the 
    critical points: 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; b, a = signal.cheby2(4, 40, 100, 'low', analog=True) 
    &gt;&gt;&gt; w, h = signal.freqs(b, a) 
    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h))) 
    &gt;&gt;&gt; plt.title('Chebyshev Type II frequency response (rs=40)') 
    &gt;&gt;&gt; plt.xlabel('Frequency [radians / second]') 
    &gt;&gt;&gt; plt.ylabel('Amplitude [dB]') 
    &gt;&gt;&gt; plt.margins(0, 0.1) 
    &gt;&gt;&gt; plt.grid(which='both', axis='both') 
    &gt;&gt;&gt; plt.axvline(100, color='green') # cutoff frequency 
    &gt;&gt;&gt; plt.axhline(-40, color='green') # rs 
    &gt;&gt;&gt; plt.show() 
 
    Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz 
 
    &gt;&gt;&gt; t = np.linspace(0, 1, 1000, False)  # 1 second 
    &gt;&gt;&gt; sig = np.sin(2*np.pi*10*t) + np.sin(2*np.pi*20*t) 
    &gt;&gt;&gt; fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True) 
    &gt;&gt;&gt; ax1.plot(t, sig) 
    &gt;&gt;&gt; ax1.set_title('10 Hz and 20 Hz sinusoids') 
    &gt;&gt;&gt; ax1.axis([0, 1, -2, 2]) 
 
    Design a digital high-pass filter at 17 Hz to remove the 10 Hz tone, and 
    apply it to the signal. (It's recommended to use second-order sections 
    format when filtering, to avoid numerical error with transfer function 
    (``ba``) format): 
 
    &gt;&gt;&gt; sos = signal.cheby2(12, 20, 17, 'hp', fs=1000, output='sos') 
    &gt;&gt;&gt; filtered = signal.sosfilt(sos, sig) 
    &gt;&gt;&gt; ax2.plot(t, filtered) 
    &gt;&gt;&gt; ax2.set_title('After 17 Hz high-pass filter') 
    &gt;&gt;&gt; ax2.axis([0, 1, -2, 2]) 
    &gt;&gt;&gt; ax2.set_xlabel('Time [seconds]') 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">iirfilter</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">Wn</span><span class="s3">, </span><span class="s1">rs</span><span class="s3">=</span><span class="s1">rs</span><span class="s3">, </span><span class="s1">btype</span><span class="s3">=</span><span class="s1">btype</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s1">analog</span><span class="s3">,</span>
                     <span class="s1">output</span><span class="s3">=</span><span class="s1">output</span><span class="s3">, </span><span class="s1">ftype</span><span class="s3">=</span><span class="s4">'cheby2'</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s1">fs</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">ellip</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">rp</span><span class="s3">, </span><span class="s1">rs</span><span class="s3">, </span><span class="s1">Wn</span><span class="s3">, </span><span class="s1">btype</span><span class="s3">=</span><span class="s4">'low'</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s4">'ba'</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Elliptic (Cauer) digital and analog filter design. 
 
    Design an Nth-order digital or analog elliptic filter and return 
    the filter coefficients. 
 
    Parameters 
    ---------- 
    N : int 
        The order of the filter. 
    rp : float 
        The maximum ripple allowed below unity gain in the passband. 
        Specified in decibels, as a positive number. 
    rs : float 
        The minimum attenuation required in the stop band. 
        Specified in decibels, as a positive number. 
    Wn : array_like 
        A scalar or length-2 sequence giving the critical frequencies. 
        For elliptic filters, this is the point in the transition band at 
        which the gain first drops below -`rp`. 
 
        For digital filters, `Wn` are in the same units as `fs`. By default, 
        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1, 
        where 1 is the Nyquist frequency. (`Wn` is thus in 
        half-cycles / sample.) 
 
        For analog filters, `Wn` is an angular frequency (e.g., rad/s). 
    btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional 
        The type of filter. Default is 'lowpass'. 
    analog : bool, optional 
        When True, return an analog filter, otherwise a digital filter is 
        returned. 
    output : {'ba', 'zpk', 'sos'}, optional 
        Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or 
        second-order sections ('sos'). Default is 'ba' for backwards 
        compatibility, but 'sos' should be used for general-purpose filtering. 
    fs : float, optional 
        The sampling frequency of the digital system. 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    b, a : ndarray, ndarray 
        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter. 
        Only returned if ``output='ba'``. 
    z, p, k : ndarray, ndarray, float 
        Zeros, poles, and system gain of the IIR filter transfer 
        function.  Only returned if ``output='zpk'``. 
    sos : ndarray 
        Second-order sections representation of the IIR filter. 
        Only returned if ``output='sos'``. 
 
    See Also 
    -------- 
    ellipord, ellipap 
 
    Notes 
    ----- 
    Also known as Cauer or Zolotarev filters, the elliptical filter maximizes 
    the rate of transition between the frequency response's passband and 
    stopband, at the expense of ripple in both, and increased ringing in the 
    step response. 
 
    As `rp` approaches 0, the elliptical filter becomes a Chebyshev 
    type II filter (`cheby2`). As `rs` approaches 0, it becomes a Chebyshev 
    type I filter (`cheby1`). As both approach 0, it becomes a Butterworth 
    filter (`butter`). 
 
    The equiripple passband has N maxima or minima (for example, a 
    5th-order filter has 3 maxima and 2 minima). Consequently, the DC gain is 
    unity for odd-order filters, or -rp dB for even-order filters. 
 
    The ``'sos'`` output parameter was added in 0.16.0. 
 
    Examples 
    -------- 
    Design an analog filter and plot its frequency response, showing the 
    critical points: 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; b, a = signal.ellip(4, 5, 40, 100, 'low', analog=True) 
    &gt;&gt;&gt; w, h = signal.freqs(b, a) 
    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h))) 
    &gt;&gt;&gt; plt.title('Elliptic filter frequency response (rp=5, rs=40)') 
    &gt;&gt;&gt; plt.xlabel('Frequency [radians / second]') 
    &gt;&gt;&gt; plt.ylabel('Amplitude [dB]') 
    &gt;&gt;&gt; plt.margins(0, 0.1) 
    &gt;&gt;&gt; plt.grid(which='both', axis='both') 
    &gt;&gt;&gt; plt.axvline(100, color='green') # cutoff frequency 
    &gt;&gt;&gt; plt.axhline(-40, color='green') # rs 
    &gt;&gt;&gt; plt.axhline(-5, color='green') # rp 
    &gt;&gt;&gt; plt.show() 
 
    Generate a signal made up of 10 Hz and 20 Hz, sampled at 1 kHz 
 
    &gt;&gt;&gt; t = np.linspace(0, 1, 1000, False)  # 1 second 
    &gt;&gt;&gt; sig = np.sin(2*np.pi*10*t) + np.sin(2*np.pi*20*t) 
    &gt;&gt;&gt; fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True) 
    &gt;&gt;&gt; ax1.plot(t, sig) 
    &gt;&gt;&gt; ax1.set_title('10 Hz and 20 Hz sinusoids') 
    &gt;&gt;&gt; ax1.axis([0, 1, -2, 2]) 
 
    Design a digital high-pass filter at 17 Hz to remove the 10 Hz tone, and 
    apply it to the signal. (It's recommended to use second-order sections 
    format when filtering, to avoid numerical error with transfer function 
    (``ba``) format): 
 
    &gt;&gt;&gt; sos = signal.ellip(8, 1, 100, 17, 'hp', fs=1000, output='sos') 
    &gt;&gt;&gt; filtered = signal.sosfilt(sos, sig) 
    &gt;&gt;&gt; ax2.plot(t, filtered) 
    &gt;&gt;&gt; ax2.set_title('After 17 Hz high-pass filter') 
    &gt;&gt;&gt; ax2.axis([0, 1, -2, 2]) 
    &gt;&gt;&gt; ax2.set_xlabel('Time [seconds]') 
    &gt;&gt;&gt; plt.tight_layout() 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">iirfilter</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">Wn</span><span class="s3">, </span><span class="s1">rs</span><span class="s3">=</span><span class="s1">rs</span><span class="s3">, </span><span class="s1">rp</span><span class="s3">=</span><span class="s1">rp</span><span class="s3">, </span><span class="s1">btype</span><span class="s3">=</span><span class="s1">btype</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s1">analog</span><span class="s3">,</span>
                     <span class="s1">output</span><span class="s3">=</span><span class="s1">output</span><span class="s3">, </span><span class="s1">ftype</span><span class="s3">=</span><span class="s4">'elliptic'</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s1">fs</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">bessel</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">Wn</span><span class="s3">, </span><span class="s1">btype</span><span class="s3">=</span><span class="s4">'low'</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s4">'ba'</span><span class="s3">, </span><span class="s1">norm</span><span class="s3">=</span><span class="s4">'phase'</span><span class="s3">,</span>
           <span class="s1">fs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Bessel/Thomson digital and analog filter design. 
 
    Design an Nth-order digital or analog Bessel filter and return the 
    filter coefficients. 
 
    Parameters 
    ---------- 
    N : int 
        The order of the filter. 
    Wn : array_like 
        A scalar or length-2 sequence giving the critical frequencies (defined 
        by the `norm` parameter). 
        For analog filters, `Wn` is an angular frequency (e.g., rad/s). 
 
        For digital filters, `Wn` are in the same units as `fs`.  By default, 
        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1, 
        where 1 is the Nyquist frequency. (`Wn` is thus in 
        half-cycles / sample.) 
    btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional 
        The type of filter.  Default is 'lowpass'. 
    analog : bool, optional 
        When True, return an analog filter, otherwise a digital filter is 
        returned. (See Notes.) 
    output : {'ba', 'zpk', 'sos'}, optional 
        Type of output:  numerator/denominator ('ba'), pole-zero ('zpk'), or 
        second-order sections ('sos'). Default is 'ba'. 
    norm : {'phase', 'delay', 'mag'}, optional 
        Critical frequency normalization: 
 
        ``phase`` 
            The filter is normalized such that the phase response reaches its 
            midpoint at angular (e.g. rad/s) frequency `Wn`. This happens for 
            both low-pass and high-pass filters, so this is the 
            &quot;phase-matched&quot; case. 
 
            The magnitude response asymptotes are the same as a Butterworth 
            filter of the same order with a cutoff of `Wn`. 
 
            This is the default, and matches MATLAB's implementation. 
 
        ``delay`` 
            The filter is normalized such that the group delay in the passband 
            is 1/`Wn` (e.g., seconds). This is the &quot;natural&quot; type obtained by 
            solving Bessel polynomials. 
 
        ``mag`` 
            The filter is normalized such that the gain magnitude is -3 dB at 
            angular frequency `Wn`. 
 
        .. versionadded:: 0.18.0 
    fs : float, optional 
        The sampling frequency of the digital system. 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    b, a : ndarray, ndarray 
        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter. 
        Only returned if ``output='ba'``. 
    z, p, k : ndarray, ndarray, float 
        Zeros, poles, and system gain of the IIR filter transfer 
        function.  Only returned if ``output='zpk'``. 
    sos : ndarray 
        Second-order sections representation of the IIR filter. 
        Only returned if ``output='sos'``. 
 
    Notes 
    ----- 
    Also known as a Thomson filter, the analog Bessel filter has maximally 
    flat group delay and maximally linear phase response, with very little 
    ringing in the step response. [1]_ 
 
    The Bessel is inherently an analog filter. This function generates digital 
    Bessel filters using the bilinear transform, which does not preserve the 
    phase response of the analog filter. As such, it is only approximately 
    correct at frequencies below about fs/4. To get maximally-flat group 
    delay at higher frequencies, the analog Bessel filter must be transformed 
    using phase-preserving techniques. 
 
    See `besselap` for implementation details and references. 
 
    The ``'sos'`` output parameter was added in 0.16.0. 
 
    References 
    ---------- 
    .. [1] Thomson, W.E., &quot;Delay Networks having Maximally Flat Frequency 
           Characteristics&quot;, Proceedings of the Institution of Electrical 
           Engineers, Part III, November 1949, Vol. 96, No. 44, pp. 487-490. 
 
    Examples 
    -------- 
    Plot the phase-normalized frequency response, showing the relationship 
    to the Butterworth's cutoff frequency (green): 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; b, a = signal.butter(4, 100, 'low', analog=True) 
    &gt;&gt;&gt; w, h = signal.freqs(b, a) 
    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(np.abs(h)), color='silver', ls='dashed') 
    &gt;&gt;&gt; b, a = signal.bessel(4, 100, 'low', analog=True, norm='phase') 
    &gt;&gt;&gt; w, h = signal.freqs(b, a) 
    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(np.abs(h))) 
    &gt;&gt;&gt; plt.title('Bessel filter magnitude response (with Butterworth)') 
    &gt;&gt;&gt; plt.xlabel('Frequency [radians / second]') 
    &gt;&gt;&gt; plt.ylabel('Amplitude [dB]') 
    &gt;&gt;&gt; plt.margins(0, 0.1) 
    &gt;&gt;&gt; plt.grid(which='both', axis='both') 
    &gt;&gt;&gt; plt.axvline(100, color='green')  # cutoff frequency 
    &gt;&gt;&gt; plt.show() 
 
    and the phase midpoint: 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; plt.semilogx(w, np.unwrap(np.angle(h))) 
    &gt;&gt;&gt; plt.axvline(100, color='green')  # cutoff frequency 
    &gt;&gt;&gt; plt.axhline(-np.pi, color='red')  # phase midpoint 
    &gt;&gt;&gt; plt.title('Bessel filter phase response') 
    &gt;&gt;&gt; plt.xlabel('Frequency [radians / second]') 
    &gt;&gt;&gt; plt.ylabel('Phase [radians]') 
    &gt;&gt;&gt; plt.margins(0, 0.1) 
    &gt;&gt;&gt; plt.grid(which='both', axis='both') 
    &gt;&gt;&gt; plt.show() 
 
    Plot the magnitude-normalized frequency response, showing the -3 dB cutoff: 
 
    &gt;&gt;&gt; b, a = signal.bessel(3, 10, 'low', analog=True, norm='mag') 
    &gt;&gt;&gt; w, h = signal.freqs(b, a) 
    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(np.abs(h))) 
    &gt;&gt;&gt; plt.axhline(-3, color='red')  # -3 dB magnitude 
    &gt;&gt;&gt; plt.axvline(10, color='green')  # cutoff frequency 
    &gt;&gt;&gt; plt.title('Magnitude-normalized Bessel filter frequency response') 
    &gt;&gt;&gt; plt.xlabel('Frequency [radians / second]') 
    &gt;&gt;&gt; plt.ylabel('Amplitude [dB]') 
    &gt;&gt;&gt; plt.margins(0, 0.1) 
    &gt;&gt;&gt; plt.grid(which='both', axis='both') 
    &gt;&gt;&gt; plt.show() 
 
    Plot the delay-normalized filter, showing the maximally-flat group delay 
    at 0.1 seconds: 
 
    &gt;&gt;&gt; b, a = signal.bessel(5, 1/0.1, 'low', analog=True, norm='delay') 
    &gt;&gt;&gt; w, h = signal.freqs(b, a) 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; plt.semilogx(w[1:], -np.diff(np.unwrap(np.angle(h)))/np.diff(w)) 
    &gt;&gt;&gt; plt.axhline(0.1, color='red')  # 0.1 seconds group delay 
    &gt;&gt;&gt; plt.title('Bessel filter group delay') 
    &gt;&gt;&gt; plt.xlabel('Frequency [radians / second]') 
    &gt;&gt;&gt; plt.ylabel('Group delay [seconds]') 
    &gt;&gt;&gt; plt.margins(0, 0.1) 
    &gt;&gt;&gt; plt.grid(which='both', axis='both') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">iirfilter</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">Wn</span><span class="s3">, </span><span class="s1">btype</span><span class="s3">=</span><span class="s1">btype</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s1">analog</span><span class="s3">,</span>
                     <span class="s1">output</span><span class="s3">=</span><span class="s1">output</span><span class="s3">, </span><span class="s1">ftype</span><span class="s3">=</span><span class="s4">'bessel_'</span><span class="s3">+</span><span class="s1">norm</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s1">fs</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">maxflat</span><span class="s3">():</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">yulewalk</span><span class="s3">():</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">band_stop_obj</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ind</span><span class="s3">, </span><span class="s1">passb</span><span class="s3">, </span><span class="s1">stopb</span><span class="s3">, </span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">, </span><span class="s1">type</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Band Stop Objective Function for order minimization. 
 
    Returns the non-integer order for an analog band stop filter. 
 
    Parameters 
    ---------- 
    wp : scalar 
        Edge of passband `passb`. 
    ind : int, {0, 1} 
        Index specifying which `passb` edge to vary (0 or 1). 
    passb : ndarray 
        Two element sequence of fixed passband edges. 
    stopb : ndarray 
        Two element sequence of fixed stopband edges. 
    gstop : float 
        Amount of attenuation in stopband in dB. 
    gpass : float 
        Amount of ripple in the passband in dB. 
    type : {'butter', 'cheby', 'ellip'} 
        Type of filter. 
 
    Returns 
    ------- 
    n : scalar 
        Filter order (possibly non-integer). 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_validate_gpass_gstop</span><span class="s3">(</span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">)</span>

    <span class="s1">passbC </span><span class="s3">= </span><span class="s1">passb</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">passbC</span><span class="s3">[</span><span class="s1">ind</span><span class="s3">] = </span><span class="s1">wp</span>
    <span class="s1">nat </span><span class="s3">= (</span><span class="s1">stopb </span><span class="s3">* (</span><span class="s1">passbC</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] - </span><span class="s1">passbC</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) /</span>
           <span class="s3">(</span><span class="s1">stopb </span><span class="s3">** </span><span class="s5">2 </span><span class="s3">- </span><span class="s1">passbC</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">passbC</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]))</span>
    <span class="s1">nat </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">nat</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s1">type </span><span class="s3">== </span><span class="s4">'butter'</span><span class="s3">:</span>
        <span class="s1">GSTOP </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">** (</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">gstop</span><span class="s3">))</span>
        <span class="s1">GPASS </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">** (</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">gpass</span><span class="s3">))</span>
        <span class="s1">n </span><span class="s3">= (</span><span class="s1">log10</span><span class="s3">((</span><span class="s1">GSTOP </span><span class="s3">- </span><span class="s5">1.0</span><span class="s3">) / (</span><span class="s1">GPASS </span><span class="s3">- </span><span class="s5">1.0</span><span class="s3">)) / (</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">log10</span><span class="s3">(</span><span class="s1">nat</span><span class="s3">)))</span>
    <span class="s2">elif </span><span class="s1">type </span><span class="s3">== </span><span class="s4">'cheby'</span><span class="s3">:</span>
        <span class="s1">GSTOP </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">** (</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">gstop</span><span class="s3">))</span>
        <span class="s1">GPASS </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">** (</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">gpass</span><span class="s3">))</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">arccosh</span><span class="s3">(</span><span class="s1">sqrt</span><span class="s3">((</span><span class="s1">GSTOP </span><span class="s3">- </span><span class="s5">1.0</span><span class="s3">) / (</span><span class="s1">GPASS </span><span class="s3">- </span><span class="s5">1.0</span><span class="s3">))) / </span><span class="s1">arccosh</span><span class="s3">(</span><span class="s1">nat</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">type </span><span class="s3">== </span><span class="s4">'ellip'</span><span class="s3">:</span>
        <span class="s1">GSTOP </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">** (</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">gstop</span><span class="s3">)</span>
        <span class="s1">GPASS </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">** (</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">gpass</span><span class="s3">)</span>
        <span class="s1">arg1 </span><span class="s3">= </span><span class="s1">sqrt</span><span class="s3">((</span><span class="s1">GPASS </span><span class="s3">- </span><span class="s5">1.0</span><span class="s3">) / (</span><span class="s1">GSTOP </span><span class="s3">- </span><span class="s5">1.0</span><span class="s3">))</span>
        <span class="s1">arg0 </span><span class="s3">= </span><span class="s5">1.0 </span><span class="s3">/ </span><span class="s1">nat</span>
        <span class="s1">d0 </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">ellipk</span><span class="s3">([</span><span class="s1">arg0 </span><span class="s3">** </span><span class="s5">2</span><span class="s3">, </span><span class="s5">1 </span><span class="s3">- </span><span class="s1">arg0 </span><span class="s3">** </span><span class="s5">2</span><span class="s3">])</span>
        <span class="s1">d1 </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">ellipk</span><span class="s3">([</span><span class="s1">arg1 </span><span class="s3">** </span><span class="s5">2</span><span class="s3">, </span><span class="s5">1 </span><span class="s3">- </span><span class="s1">arg1 </span><span class="s3">** </span><span class="s5">2</span><span class="s3">])</span>
        <span class="s1">n </span><span class="s3">= (</span><span class="s1">d0</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">d1</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] / (</span><span class="s1">d0</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">d1</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Incorrect type: %s&quot; </span><span class="s3">% </span><span class="s1">type</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">n</span>


<span class="s2">def </span><span class="s1">_pre_warp</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">):</span>
    <span class="s6"># Pre-warp frequencies for digital filter design</span>
    <span class="s2">if not </span><span class="s1">analog</span><span class="s3">:</span>
        <span class="s1">passb </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">tan</span><span class="s3">(</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">wp </span><span class="s3">/ </span><span class="s5">2.0</span><span class="s3">)</span>
        <span class="s1">stopb </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">tan</span><span class="s3">(</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">ws </span><span class="s3">/ </span><span class="s5">2.0</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">passb </span><span class="s3">= </span><span class="s1">wp </span><span class="s3">* </span><span class="s5">1.0</span>
        <span class="s1">stopb </span><span class="s3">= </span><span class="s1">ws </span><span class="s3">* </span><span class="s5">1.0</span>
    <span class="s2">return </span><span class="s1">passb</span><span class="s3">, </span><span class="s1">stopb</span>


<span class="s2">def </span><span class="s1">_validate_wp_ws</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">):</span>
    <span class="s1">wp </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">)</span>
    <span class="s1">ws </span><span class="s3">= </span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">ws</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">fs </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">analog</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;fs cannot be specified for an analog filter&quot;</span><span class="s3">)</span>
        <span class="s1">wp </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">wp </span><span class="s3">/ </span><span class="s1">fs</span>
        <span class="s1">ws </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">ws </span><span class="s3">/ </span><span class="s1">fs</span>

    <span class="s1">filter_type </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* (</span><span class="s1">len</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">) + </span><span class="s5">1</span>
    <span class="s2">if </span><span class="s1">wp</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] &gt;= </span><span class="s1">ws</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]:</span>
        <span class="s1">filter_type </span><span class="s3">+= </span><span class="s5">1</span>

    <span class="s2">return </span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">filter_type</span>


<span class="s2">def </span><span class="s1">_find_nat_freq</span><span class="s3">(</span><span class="s1">stopb</span><span class="s3">, </span><span class="s1">passb</span><span class="s3">, </span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">, </span><span class="s1">filter_type</span><span class="s3">, </span><span class="s1">filter_kind</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">filter_type </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:            </span><span class="s6"># low</span>
        <span class="s1">nat </span><span class="s3">= </span><span class="s1">stopb </span><span class="s3">/ </span><span class="s1">passb</span>
    <span class="s2">elif </span><span class="s1">filter_type </span><span class="s3">== </span><span class="s5">2</span><span class="s3">:          </span><span class="s6"># high</span>
        <span class="s1">nat </span><span class="s3">= </span><span class="s1">passb </span><span class="s3">/ </span><span class="s1">stopb</span>
    <span class="s2">elif </span><span class="s1">filter_type </span><span class="s3">== </span><span class="s5">3</span><span class="s3">:          </span><span class="s6"># stop</span>

       <span class="s6">### breakpoint()</span>

        <span class="s1">wp0 </span><span class="s3">= </span><span class="s1">optimize</span><span class="s3">.</span><span class="s1">fminbound</span><span class="s3">(</span><span class="s1">band_stop_obj</span><span class="s3">, </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">stopb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] - </span><span class="s5">1e-12</span><span class="s3">,</span>
                                 <span class="s1">args</span><span class="s3">=(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">passb</span><span class="s3">, </span><span class="s1">stopb</span><span class="s3">, </span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">,</span>
                                       <span class="s1">filter_kind</span><span class="s3">),</span>
                                 <span class="s1">disp</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">wp0</span>
        <span class="s1">wp1 </span><span class="s3">= </span><span class="s1">optimize</span><span class="s3">.</span><span class="s1">fminbound</span><span class="s3">(</span><span class="s1">band_stop_obj</span><span class="s3">, </span><span class="s1">stopb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] + </span><span class="s5">1e-12</span><span class="s3">, </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">],</span>
                                 <span class="s1">args</span><span class="s3">=(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">passb</span><span class="s3">, </span><span class="s1">stopb</span><span class="s3">, </span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">,</span>
                                       <span class="s1">filter_kind</span><span class="s3">),</span>
                                 <span class="s1">disp</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">wp1</span>
        <span class="s1">nat </span><span class="s3">= ((</span><span class="s1">stopb </span><span class="s3">* (</span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] - </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])) /</span>
               <span class="s3">(</span><span class="s1">stopb </span><span class="s3">** </span><span class="s5">2 </span><span class="s3">- </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]))</span>
    <span class="s2">elif </span><span class="s1">filter_type </span><span class="s3">== </span><span class="s5">4</span><span class="s3">:          </span><span class="s6"># pass</span>
        <span class="s1">nat </span><span class="s3">= ((</span><span class="s1">stopb </span><span class="s3">** </span><span class="s5">2 </span><span class="s3">- </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) /</span>
               <span class="s3">(</span><span class="s1">stopb </span><span class="s3">* (</span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] - </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;should not happen: </span><span class="s2">{</span><span class="s1">filter_type </span><span class="s3">=</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s3">)</span>

    <span class="s1">nat </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">nat</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">nat</span><span class="s3">, </span><span class="s1">passb</span>


<span class="s2">def </span><span class="s1">_postprocess_wn</span><span class="s3">(</span><span class="s1">WN</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">):</span>
    <span class="s1">wn </span><span class="s3">= </span><span class="s1">WN </span><span class="s2">if </span><span class="s1">analog </span><span class="s2">else </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arctan</span><span class="s3">(</span><span class="s1">WN</span><span class="s3">) * </span><span class="s5">2.0 </span><span class="s3">/ </span><span class="s1">pi</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">wn</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">wn </span><span class="s3">= </span><span class="s1">wn</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">fs </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">wn </span><span class="s3">= </span><span class="s1">wn </span><span class="s3">* </span><span class="s1">fs </span><span class="s3">/ </span><span class="s5">2</span>
    <span class="s2">return </span><span class="s1">wn</span>


<span class="s2">def </span><span class="s1">buttord</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Butterworth filter order selection. 
 
    Return the order of the lowest order digital or analog Butterworth filter 
    that loses no more than `gpass` dB in the passband and has at least 
    `gstop` dB attenuation in the stopband. 
 
    Parameters 
    ---------- 
    wp, ws : float 
        Passband and stopband edge frequencies. 
 
        For digital filters, these are in the same units as `fs`. By default, 
        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1, 
        where 1 is the Nyquist frequency. (`wp` and `ws` are thus in 
        half-cycles / sample.) For example: 
 
            - Lowpass:   wp = 0.2,          ws = 0.3 
            - Highpass:  wp = 0.3,          ws = 0.2 
            - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6] 
            - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5] 
 
        For analog filters, `wp` and `ws` are angular frequencies (e.g., rad/s). 
    gpass : float 
        The maximum loss in the passband (dB). 
    gstop : float 
        The minimum attenuation in the stopband (dB). 
    analog : bool, optional 
        When True, return an analog filter, otherwise a digital filter is 
        returned. 
    fs : float, optional 
        The sampling frequency of the digital system. 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    ord : int 
        The lowest order for a Butterworth filter which meets specs. 
    wn : ndarray or float 
        The Butterworth natural frequency (i.e. the &quot;3dB frequency&quot;). Should 
        be used with `butter` to give filter results. If `fs` is specified, 
        this is in the same units, and `fs` must also be passed to `butter`. 
 
    See Also 
    -------- 
    butter : Filter design using order and critical points 
    cheb1ord : Find order and critical points from passband and stopband spec 
    cheb2ord, ellipord 
    iirfilter : General filter design using order and critical frequencies 
    iirdesign : General filter design using passband and stopband spec 
 
    Examples 
    -------- 
    Design an analog bandpass filter with passband within 3 dB from 20 to 
    50 rad/s, while rejecting at least -40 dB below 14 and above 60 rad/s. 
    Plot its frequency response, showing the passband and stopband 
    constraints in gray. 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; N, Wn = signal.buttord([20, 50], [14, 60], 3, 40, True) 
    &gt;&gt;&gt; b, a = signal.butter(N, Wn, 'band', True) 
    &gt;&gt;&gt; w, h = signal.freqs(b, a, np.logspace(1, 2, 500)) 
    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h))) 
    &gt;&gt;&gt; plt.title('Butterworth bandpass filter fit to constraints') 
    &gt;&gt;&gt; plt.xlabel('Frequency [radians / second]') 
    &gt;&gt;&gt; plt.ylabel('Amplitude [dB]') 
    &gt;&gt;&gt; plt.grid(which='both', axis='both') 
    &gt;&gt;&gt; plt.fill([1,  14,  14,   1], [-40, -40, 99, 99], '0.9', lw=0) # stop 
    &gt;&gt;&gt; plt.fill([20, 20,  50,  50], [-99, -3, -3, -99], '0.9', lw=0) # pass 
    &gt;&gt;&gt; plt.fill([60, 60, 1e9, 1e9], [99, -40, -40, 99], '0.9', lw=0) # stop 
    &gt;&gt;&gt; plt.axis([10, 100, -60, 3]) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_validate_gpass_gstop</span><span class="s3">(</span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">)</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">filter_type </span><span class="s3">= </span><span class="s1">_validate_wp_ws</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">)</span>
    <span class="s1">passb</span><span class="s3">, </span><span class="s1">stopb </span><span class="s3">= </span><span class="s1">_pre_warp</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">)</span>
    <span class="s1">nat</span><span class="s3">, </span><span class="s1">passb </span><span class="s3">= </span><span class="s1">_find_nat_freq</span><span class="s3">(</span><span class="s1">stopb</span><span class="s3">, </span><span class="s1">passb</span><span class="s3">, </span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">, </span><span class="s1">filter_type</span><span class="s3">, </span><span class="s4">'butter'</span><span class="s3">)</span>

    <span class="s1">GSTOP </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">** (</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">gstop</span><span class="s3">))</span>
    <span class="s1">GPASS </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">** (</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">gpass</span><span class="s3">))</span>
    <span class="s1">ord </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">log10</span><span class="s3">((</span><span class="s1">GSTOP </span><span class="s3">- </span><span class="s5">1.0</span><span class="s3">) / (</span><span class="s1">GPASS </span><span class="s3">- </span><span class="s5">1.0</span><span class="s3">)) / (</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">log10</span><span class="s3">(</span><span class="s1">nat</span><span class="s3">))))</span>

    <span class="s6"># Find the Butterworth natural frequency WN (or the &quot;3dB&quot; frequency&quot;)</span>
    <span class="s6"># to give exactly gpass at passb.</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">W0 </span><span class="s3">= (</span><span class="s1">GPASS </span><span class="s3">- </span><span class="s5">1.0</span><span class="s3">) ** (-</span><span class="s5">1.0 </span><span class="s3">/ (</span><span class="s5">2.0 </span><span class="s3">* </span><span class="s1">ord</span><span class="s3">))</span>
    <span class="s2">except </span><span class="s1">ZeroDivisionError</span><span class="s3">:</span>
        <span class="s1">W0 </span><span class="s3">= </span><span class="s5">1.0</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">&quot;Order is zero...check input parameters.&quot;</span><span class="s3">,</span>
                      <span class="s1">RuntimeWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>

    <span class="s6"># now convert this frequency back from lowpass prototype</span>
    <span class="s6"># to the original analog filter</span>

    <span class="s2">if </span><span class="s1">filter_type </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:  </span><span class="s6"># low</span>
        <span class="s1">WN </span><span class="s3">= </span><span class="s1">W0 </span><span class="s3">* </span><span class="s1">passb</span>
    <span class="s2">elif </span><span class="s1">filter_type </span><span class="s3">== </span><span class="s5">2</span><span class="s3">:  </span><span class="s6"># high</span>
        <span class="s1">WN </span><span class="s3">= </span><span class="s1">passb </span><span class="s3">/ </span><span class="s1">W0</span>
    <span class="s2">elif </span><span class="s1">filter_type </span><span class="s3">== </span><span class="s5">3</span><span class="s3">:  </span><span class="s6"># stop</span>
        <span class="s1">WN </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">float</span><span class="s3">)</span>
        <span class="s1">discr </span><span class="s3">= </span><span class="s1">sqrt</span><span class="s3">((</span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) ** </span><span class="s5">2 </span><span class="s3">+</span>
                     <span class="s5">4 </span><span class="s3">* </span><span class="s1">W0 </span><span class="s3">** </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
        <span class="s1">WN</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = ((</span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) + </span><span class="s1">discr</span><span class="s3">) / (</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">W0</span><span class="s3">)</span>
        <span class="s1">WN</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = ((</span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) - </span><span class="s1">discr</span><span class="s3">) / (</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">W0</span><span class="s3">)</span>
        <span class="s1">WN </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">WN</span><span class="s3">))</span>
    <span class="s2">elif </span><span class="s1">filter_type </span><span class="s3">== </span><span class="s5">4</span><span class="s3">:  </span><span class="s6"># pass</span>
        <span class="s1">W0 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([-</span><span class="s1">W0</span><span class="s3">, </span><span class="s1">W0</span><span class="s3">], </span><span class="s1">float</span><span class="s3">)</span>
        <span class="s1">WN </span><span class="s3">= (-</span><span class="s1">W0 </span><span class="s3">* (</span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) / </span><span class="s5">2.0 </span><span class="s3">+</span>
              <span class="s1">sqrt</span><span class="s3">(</span><span class="s1">W0 </span><span class="s3">** </span><span class="s5">2 </span><span class="s3">/ </span><span class="s5">4.0 </span><span class="s3">* (</span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) ** </span><span class="s5">2 </span><span class="s3">+</span>
                   <span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]))</span>
        <span class="s1">WN </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">WN</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Bad type: %s&quot; </span><span class="s3">% </span><span class="s1">filter_type</span><span class="s3">)</span>

    <span class="s1">wn </span><span class="s3">= </span><span class="s1">_postprocess_wn</span><span class="s3">(</span><span class="s1">WN</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">ord</span><span class="s3">, </span><span class="s1">wn</span>


<span class="s2">def </span><span class="s1">cheb1ord</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Chebyshev type I filter order selection. 
 
    Return the order of the lowest order digital or analog Chebyshev Type I 
    filter that loses no more than `gpass` dB in the passband and has at 
    least `gstop` dB attenuation in the stopband. 
 
    Parameters 
    ---------- 
    wp, ws : float 
        Passband and stopband edge frequencies. 
 
        For digital filters, these are in the same units as `fs`. By default, 
        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1, 
        where 1 is the Nyquist frequency. (`wp` and `ws` are thus in 
        half-cycles / sample.)  For example: 
 
            - Lowpass:   wp = 0.2,          ws = 0.3 
            - Highpass:  wp = 0.3,          ws = 0.2 
            - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6] 
            - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5] 
 
        For analog filters, `wp` and `ws` are angular frequencies (e.g., rad/s). 
    gpass : float 
        The maximum loss in the passband (dB). 
    gstop : float 
        The minimum attenuation in the stopband (dB). 
    analog : bool, optional 
        When True, return an analog filter, otherwise a digital filter is 
        returned. 
    fs : float, optional 
        The sampling frequency of the digital system. 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    ord : int 
        The lowest order for a Chebyshev type I filter that meets specs. 
    wn : ndarray or float 
        The Chebyshev natural frequency (the &quot;3dB frequency&quot;) for use with 
        `cheby1` to give filter results. If `fs` is specified, 
        this is in the same units, and `fs` must also be passed to `cheby1`. 
 
    See Also 
    -------- 
    cheby1 : Filter design using order and critical points 
    buttord : Find order and critical points from passband and stopband spec 
    cheb2ord, ellipord 
    iirfilter : General filter design using order and critical frequencies 
    iirdesign : General filter design using passband and stopband spec 
 
    Examples 
    -------- 
    Design a digital lowpass filter such that the passband is within 3 dB up 
    to 0.2*(fs/2), while rejecting at least -40 dB above 0.3*(fs/2). Plot its 
    frequency response, showing the passband and stopband constraints in gray. 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; N, Wn = signal.cheb1ord(0.2, 0.3, 3, 40) 
    &gt;&gt;&gt; b, a = signal.cheby1(N, 3, Wn, 'low') 
    &gt;&gt;&gt; w, h = signal.freqz(b, a) 
    &gt;&gt;&gt; plt.semilogx(w / np.pi, 20 * np.log10(abs(h))) 
    &gt;&gt;&gt; plt.title('Chebyshev I lowpass filter fit to constraints') 
    &gt;&gt;&gt; plt.xlabel('Normalized frequency') 
    &gt;&gt;&gt; plt.ylabel('Amplitude [dB]') 
    &gt;&gt;&gt; plt.grid(which='both', axis='both') 
    &gt;&gt;&gt; plt.fill([.01, 0.2, 0.2, .01], [-3, -3, -99, -99], '0.9', lw=0) # stop 
    &gt;&gt;&gt; plt.fill([0.3, 0.3,   2,   2], [ 9, -40, -40,  9], '0.9', lw=0) # pass 
    &gt;&gt;&gt; plt.axis([0.08, 1, -60, 3]) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">_validate_gpass_gstop</span><span class="s3">(</span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">)</span>
    <span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">filter_type </span><span class="s3">= </span><span class="s1">_validate_wp_ws</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">)</span>
    <span class="s1">passb</span><span class="s3">, </span><span class="s1">stopb </span><span class="s3">= </span><span class="s1">_pre_warp</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">)</span>
    <span class="s1">nat</span><span class="s3">, </span><span class="s1">passb </span><span class="s3">= </span><span class="s1">_find_nat_freq</span><span class="s3">(</span><span class="s1">stopb</span><span class="s3">, </span><span class="s1">passb</span><span class="s3">, </span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">, </span><span class="s1">filter_type</span><span class="s3">, </span><span class="s4">'cheby'</span><span class="s3">)</span>

    <span class="s1">GSTOP </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">** (</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">gstop</span><span class="s3">))</span>
    <span class="s1">GPASS </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">** (</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">gpass</span><span class="s3">))</span>
    <span class="s1">v_pass_stop </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arccosh</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">((</span><span class="s1">GSTOP </span><span class="s3">- </span><span class="s5">1.0</span><span class="s3">) / (</span><span class="s1">GPASS </span><span class="s3">- </span><span class="s5">1.0</span><span class="s3">)))</span>
    <span class="s1">ord </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">v_pass_stop </span><span class="s3">/ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arccosh</span><span class="s3">(</span><span class="s1">nat</span><span class="s3">)))</span>

    <span class="s6"># Natural frequencies are just the passband edges</span>
    <span class="s1">wn </span><span class="s3">= </span><span class="s1">_postprocess_wn</span><span class="s3">(</span><span class="s1">passb</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">ord</span><span class="s3">, </span><span class="s1">wn</span>


<span class="s2">def </span><span class="s1">cheb2ord</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Chebyshev type II filter order selection. 
 
    Return the order of the lowest order digital or analog Chebyshev Type II 
    filter that loses no more than `gpass` dB in the passband and has at least 
    `gstop` dB attenuation in the stopband. 
 
    Parameters 
    ---------- 
    wp, ws : float 
        Passband and stopband edge frequencies. 
 
        For digital filters, these are in the same units as `fs`. By default, 
        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1, 
        where 1 is the Nyquist frequency. (`wp` and `ws` are thus in 
        half-cycles / sample.)  For example: 
 
            - Lowpass:   wp = 0.2,          ws = 0.3 
            - Highpass:  wp = 0.3,          ws = 0.2 
            - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6] 
            - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5] 
 
        For analog filters, `wp` and `ws` are angular frequencies (e.g., rad/s). 
    gpass : float 
        The maximum loss in the passband (dB). 
    gstop : float 
        The minimum attenuation in the stopband (dB). 
    analog : bool, optional 
        When True, return an analog filter, otherwise a digital filter is 
        returned. 
    fs : float, optional 
        The sampling frequency of the digital system. 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    ord : int 
        The lowest order for a Chebyshev type II filter that meets specs. 
    wn : ndarray or float 
        The Chebyshev natural frequency (the &quot;3dB frequency&quot;) for use with 
        `cheby2` to give filter results. If `fs` is specified, 
        this is in the same units, and `fs` must also be passed to `cheby2`. 
 
    See Also 
    -------- 
    cheby2 : Filter design using order and critical points 
    buttord : Find order and critical points from passband and stopband spec 
    cheb1ord, ellipord 
    iirfilter : General filter design using order and critical frequencies 
    iirdesign : General filter design using passband and stopband spec 
 
    Examples 
    -------- 
    Design a digital bandstop filter which rejects -60 dB from 0.2*(fs/2) to 
    0.5*(fs/2), while staying within 3 dB below 0.1*(fs/2) or above 
    0.6*(fs/2). Plot its frequency response, showing the passband and 
    stopband constraints in gray. 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; N, Wn = signal.cheb2ord([0.1, 0.6], [0.2, 0.5], 3, 60) 
    &gt;&gt;&gt; b, a = signal.cheby2(N, 60, Wn, 'stop') 
    &gt;&gt;&gt; w, h = signal.freqz(b, a) 
    &gt;&gt;&gt; plt.semilogx(w / np.pi, 20 * np.log10(abs(h))) 
    &gt;&gt;&gt; plt.title('Chebyshev II bandstop filter fit to constraints') 
    &gt;&gt;&gt; plt.xlabel('Normalized frequency') 
    &gt;&gt;&gt; plt.ylabel('Amplitude [dB]') 
    &gt;&gt;&gt; plt.grid(which='both', axis='both') 
    &gt;&gt;&gt; plt.fill([.01, .1, .1, .01], [-3,  -3, -99, -99], '0.9', lw=0) # stop 
    &gt;&gt;&gt; plt.fill([.2,  .2, .5,  .5], [ 9, -60, -60,   9], '0.9', lw=0) # pass 
    &gt;&gt;&gt; plt.fill([.6,  .6,  2,   2], [-99, -3,  -3, -99], '0.9', lw=0) # stop 
    &gt;&gt;&gt; plt.axis([0.06, 1, -80, 3]) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">_validate_gpass_gstop</span><span class="s3">(</span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">)</span>
    <span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">filter_type </span><span class="s3">= </span><span class="s1">_validate_wp_ws</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">)</span>
    <span class="s1">passb</span><span class="s3">, </span><span class="s1">stopb </span><span class="s3">= </span><span class="s1">_pre_warp</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">)</span>
    <span class="s1">nat</span><span class="s3">, </span><span class="s1">passb </span><span class="s3">= </span><span class="s1">_find_nat_freq</span><span class="s3">(</span><span class="s1">stopb</span><span class="s3">, </span><span class="s1">passb</span><span class="s3">, </span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">, </span><span class="s1">filter_type</span><span class="s3">, </span><span class="s4">'cheby'</span><span class="s3">)</span>

    <span class="s1">GSTOP </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">** (</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">gstop</span><span class="s3">))</span>
    <span class="s1">GPASS </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">** (</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">gpass</span><span class="s3">))</span>
    <span class="s1">v_pass_stop </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arccosh</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">((</span><span class="s1">GSTOP </span><span class="s3">- </span><span class="s5">1.0</span><span class="s3">) / (</span><span class="s1">GPASS </span><span class="s3">- </span><span class="s5">1.0</span><span class="s3">)))</span>
    <span class="s1">ord </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">v_pass_stop </span><span class="s3">/ </span><span class="s1">arccosh</span><span class="s3">(</span><span class="s1">nat</span><span class="s3">)))</span>

    <span class="s6"># Find frequency where analog response is -gpass dB.</span>
    <span class="s6"># Then convert back from low-pass prototype to the original filter.</span>

    <span class="s1">new_freq </span><span class="s3">= </span><span class="s1">cosh</span><span class="s3">(</span><span class="s5">1.0 </span><span class="s3">/ </span><span class="s1">ord </span><span class="s3">* </span><span class="s1">v_pass_stop</span><span class="s3">)</span>
    <span class="s1">new_freq </span><span class="s3">= </span><span class="s5">1.0 </span><span class="s3">/ </span><span class="s1">new_freq</span>

    <span class="s2">if </span><span class="s1">filter_type </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">nat </span><span class="s3">= </span><span class="s1">passb </span><span class="s3">/ </span><span class="s1">new_freq</span>
    <span class="s2">elif </span><span class="s1">filter_type </span><span class="s3">== </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s1">nat </span><span class="s3">= </span><span class="s1">passb </span><span class="s3">* </span><span class="s1">new_freq</span>
    <span class="s2">elif </span><span class="s1">filter_type </span><span class="s3">== </span><span class="s5">3</span><span class="s3">:</span>
        <span class="s1">nat </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">float</span><span class="s3">)</span>
        <span class="s1">nat</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = (</span><span class="s1">new_freq </span><span class="s3">/ </span><span class="s5">2.0 </span><span class="s3">* (</span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] - </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) +</span>
                  <span class="s1">sqrt</span><span class="s3">(</span><span class="s1">new_freq </span><span class="s3">** </span><span class="s5">2 </span><span class="s3">* (</span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) ** </span><span class="s5">2 </span><span class="s3">/ </span><span class="s5">4.0 </span><span class="s3">+</span>
                       <span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]))</span>
        <span class="s1">nat</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] / </span><span class="s1">nat</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">elif </span><span class="s1">filter_type </span><span class="s3">== </span><span class="s5">4</span><span class="s3">:</span>
        <span class="s1">nat </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">float</span><span class="s3">)</span>
        <span class="s1">nat</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = (</span><span class="s5">1.0 </span><span class="s3">/ (</span><span class="s5">2.0 </span><span class="s3">* </span><span class="s1">new_freq</span><span class="s3">) * (</span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] - </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) +</span>
                  <span class="s1">sqrt</span><span class="s3">((</span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) ** </span><span class="s5">2 </span><span class="s3">/ (</span><span class="s5">4.0 </span><span class="s3">* </span><span class="s1">new_freq </span><span class="s3">** </span><span class="s5">2</span><span class="s3">) +</span>
                       <span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]))</span>
        <span class="s1">nat</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">passb</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] / </span><span class="s1">nat</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s1">wn </span><span class="s3">= </span><span class="s1">_postprocess_wn</span><span class="s3">(</span><span class="s1">nat</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">ord</span><span class="s3">, </span><span class="s1">wn</span>


<span class="s1">_POW10_LOG10 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s5">10</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_pow10m1</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;10 ** x - 1 for x near 0&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">expm1</span><span class="s3">(</span><span class="s1">_POW10_LOG10 </span><span class="s3">* </span><span class="s1">x</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">ellipord</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Elliptic (Cauer) filter order selection. 
 
    Return the order of the lowest order digital or analog elliptic filter 
    that loses no more than `gpass` dB in the passband and has at least 
    `gstop` dB attenuation in the stopband. 
 
    Parameters 
    ---------- 
    wp, ws : float 
        Passband and stopband edge frequencies. 
 
        For digital filters, these are in the same units as `fs`. By default, 
        `fs` is 2 half-cycles/sample, so these are normalized from 0 to 1, 
        where 1 is the Nyquist frequency. (`wp` and `ws` are thus in 
        half-cycles / sample.) For example: 
 
            - Lowpass:   wp = 0.2,          ws = 0.3 
            - Highpass:  wp = 0.3,          ws = 0.2 
            - Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6] 
            - Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5] 
 
        For analog filters, `wp` and `ws` are angular frequencies (e.g., rad/s). 
    gpass : float 
        The maximum loss in the passband (dB). 
    gstop : float 
        The minimum attenuation in the stopband (dB). 
    analog : bool, optional 
        When True, return an analog filter, otherwise a digital filter is 
        returned. 
    fs : float, optional 
        The sampling frequency of the digital system. 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    ord : int 
        The lowest order for an Elliptic (Cauer) filter that meets specs. 
    wn : ndarray or float 
        The Chebyshev natural frequency (the &quot;3dB frequency&quot;) for use with 
        `ellip` to give filter results. If `fs` is specified, 
        this is in the same units, and `fs` must also be passed to `ellip`. 
 
    See Also 
    -------- 
    ellip : Filter design using order and critical points 
    buttord : Find order and critical points from passband and stopband spec 
    cheb1ord, cheb2ord 
    iirfilter : General filter design using order and critical frequencies 
    iirdesign : General filter design using passband and stopband spec 
 
    Examples 
    -------- 
    Design an analog highpass filter such that the passband is within 3 dB 
    above 30 rad/s, while rejecting -60 dB at 10 rad/s. Plot its 
    frequency response, showing the passband and stopband constraints in gray. 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; N, Wn = signal.ellipord(30, 10, 3, 60, True) 
    &gt;&gt;&gt; b, a = signal.ellip(N, 3, 60, Wn, 'high', True) 
    &gt;&gt;&gt; w, h = signal.freqs(b, a, np.logspace(0, 3, 500)) 
    &gt;&gt;&gt; plt.semilogx(w, 20 * np.log10(abs(h))) 
    &gt;&gt;&gt; plt.title('Elliptical highpass filter fit to constraints') 
    &gt;&gt;&gt; plt.xlabel('Frequency [radians / second]') 
    &gt;&gt;&gt; plt.ylabel('Amplitude [dB]') 
    &gt;&gt;&gt; plt.grid(which='both', axis='both') 
    &gt;&gt;&gt; plt.fill([.1, 10,  10,  .1], [1e4, 1e4, -60, -60], '0.9', lw=0) # stop 
    &gt;&gt;&gt; plt.fill([30, 30, 1e9, 1e9], [-99,  -3,  -3, -99], '0.9', lw=0) # pass 
    &gt;&gt;&gt; plt.axis([1, 300, -80, 3]) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">_validate_gpass_gstop</span><span class="s3">(</span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">)</span>
    <span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">filter_type </span><span class="s3">= </span><span class="s1">_validate_wp_ws</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">)</span>
    <span class="s1">passb</span><span class="s3">, </span><span class="s1">stopb </span><span class="s3">= </span><span class="s1">_pre_warp</span><span class="s3">(</span><span class="s1">wp</span><span class="s3">, </span><span class="s1">ws</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">)</span>
    <span class="s1">nat</span><span class="s3">, </span><span class="s1">passb </span><span class="s3">= </span><span class="s1">_find_nat_freq</span><span class="s3">(</span><span class="s1">stopb</span><span class="s3">, </span><span class="s1">passb</span><span class="s3">, </span><span class="s1">gpass</span><span class="s3">, </span><span class="s1">gstop</span><span class="s3">, </span><span class="s1">filter_type</span><span class="s3">, </span><span class="s4">'ellip'</span><span class="s3">)</span>

    <span class="s1">arg1_sq </span><span class="s3">= </span><span class="s1">_pow10m1</span><span class="s3">(</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">gpass</span><span class="s3">) / </span><span class="s1">_pow10m1</span><span class="s3">(</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">gstop</span><span class="s3">)</span>
    <span class="s1">arg0 </span><span class="s3">= </span><span class="s5">1.0 </span><span class="s3">/ </span><span class="s1">nat</span>
    <span class="s1">d0 </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">ellipk</span><span class="s3">(</span><span class="s1">arg0 </span><span class="s3">** </span><span class="s5">2</span><span class="s3">), </span><span class="s1">special</span><span class="s3">.</span><span class="s1">ellipkm1</span><span class="s3">(</span><span class="s1">arg0 </span><span class="s3">** </span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">d1 </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">ellipk</span><span class="s3">(</span><span class="s1">arg1_sq</span><span class="s3">), </span><span class="s1">special</span><span class="s3">.</span><span class="s1">ellipkm1</span><span class="s3">(</span><span class="s1">arg1_sq</span><span class="s3">)</span>
    <span class="s1">ord </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">d0</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">d1</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] / (</span><span class="s1">d0</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">d1</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])))</span>

    <span class="s1">wn </span><span class="s3">= </span><span class="s1">_postprocess_wn</span><span class="s3">(</span><span class="s1">passb</span><span class="s3">, </span><span class="s1">analog</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">ord</span><span class="s3">, </span><span class="s1">wn</span>


<span class="s2">def </span><span class="s1">buttap</span><span class="s3">(</span><span class="s1">N</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return (z,p,k) for analog prototype of Nth-order Butterworth filter. 
 
    The filter will have an angular (e.g., rad/s) cutoff frequency of 1. 
 
    See Also 
    -------- 
    butter : Filter design function using this prototype 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)) != </span><span class="s1">N</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Filter order must be a nonnegative integer&quot;</span><span class="s3">)</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([])</span>
    <span class="s1">m </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(-</span><span class="s1">N</span><span class="s3">+</span><span class="s5">1</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
    <span class="s6"># Middle value is 0 to ensure an exactly real pole</span>
    <span class="s1">p </span><span class="s3">= -</span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">1j </span><span class="s3">* </span><span class="s1">pi </span><span class="s3">* </span><span class="s1">m </span><span class="s3">/ (</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">N</span><span class="s3">))</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">return </span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span>


<span class="s2">def </span><span class="s1">cheb1ap</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">rp</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (z,p,k) for Nth-order Chebyshev type I analog lowpass filter. 
 
    The returned filter prototype has `rp` decibels of ripple in the passband. 
 
    The filter's angular (e.g. rad/s) cutoff frequency is normalized to 1, 
    defined as the point at which the gain first drops below ``-rp``. 
 
    See Also 
    -------- 
    cheby1 : Filter design function using this prototype 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)) != </span><span class="s1">N</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Filter order must be a nonnegative integer&quot;</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">N </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s6"># Avoid divide-by-zero error</span>
        <span class="s6"># Even order filters have DC gain of -rp dB</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([]), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([]), </span><span class="s5">10</span><span class="s3">**(-</span><span class="s1">rp</span><span class="s3">/</span><span class="s5">20</span><span class="s3">)</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([])</span>

    <span class="s6"># Ripple factor (epsilon)</span>
    <span class="s1">eps </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s5">10 </span><span class="s3">** (</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">rp</span><span class="s3">) - </span><span class="s5">1.0</span><span class="s3">)</span>
    <span class="s1">mu </span><span class="s3">= </span><span class="s5">1.0 </span><span class="s3">/ </span><span class="s1">N </span><span class="s3">* </span><span class="s1">arcsinh</span><span class="s3">(</span><span class="s5">1 </span><span class="s3">/ </span><span class="s1">eps</span><span class="s3">)</span>

    <span class="s6"># Arrange poles in an ellipse on the left half of the S-plane</span>
    <span class="s1">m </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(-</span><span class="s1">N</span><span class="s3">+</span><span class="s5">1</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">theta </span><span class="s3">= </span><span class="s1">pi </span><span class="s3">* </span><span class="s1">m </span><span class="s3">/ (</span><span class="s5">2</span><span class="s3">*</span><span class="s1">N</span><span class="s3">)</span>
    <span class="s1">p </span><span class="s3">= -</span><span class="s1">sinh</span><span class="s3">(</span><span class="s1">mu </span><span class="s3">+ </span><span class="s5">1j</span><span class="s3">*</span><span class="s1">theta</span><span class="s3">)</span>

    <span class="s1">k </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(-</span><span class="s1">p</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">).</span><span class="s1">real</span>
    <span class="s2">if </span><span class="s1">N </span><span class="s3">% </span><span class="s5">2 </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">k </span><span class="s3">/ </span><span class="s1">sqrt</span><span class="s3">(</span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">eps </span><span class="s3">* </span><span class="s1">eps</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span>


<span class="s2">def </span><span class="s1">cheb2ap</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">rs</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (z,p,k) for Nth-order Chebyshev type II analog lowpass filter. 
 
    The returned filter prototype has attenuation of at least ``rs`` decibels 
    in the stopband. 
 
    The filter's angular (e.g. rad/s) cutoff frequency is normalized to 1, 
    defined as the point at which the attenuation first reaches ``rs``. 
 
    See Also 
    -------- 
    cheby2 : Filter design function using this prototype 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)) != </span><span class="s1">N</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Filter order must be a nonnegative integer&quot;</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">N </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s6"># Avoid divide-by-zero warning</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([]), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([]), </span><span class="s5">1</span>

    <span class="s6"># Ripple factor (epsilon)</span>
    <span class="s1">de </span><span class="s3">= </span><span class="s5">1.0 </span><span class="s3">/ </span><span class="s1">sqrt</span><span class="s3">(</span><span class="s5">10 </span><span class="s3">** (</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">rs</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">mu </span><span class="s3">= </span><span class="s1">arcsinh</span><span class="s3">(</span><span class="s5">1.0 </span><span class="s3">/ </span><span class="s1">de</span><span class="s3">) / </span><span class="s1">N</span>

    <span class="s2">if </span><span class="s1">N </span><span class="s3">% </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(-</span><span class="s1">N</span><span class="s3">+</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(-</span><span class="s1">N</span><span class="s3">+</span><span class="s5">1</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>

    <span class="s1">z </span><span class="s3">= -</span><span class="s1">conjugate</span><span class="s3">(</span><span class="s5">1j </span><span class="s3">/ </span><span class="s1">sin</span><span class="s3">(</span><span class="s1">m </span><span class="s3">* </span><span class="s1">pi </span><span class="s3">/ (</span><span class="s5">2.0 </span><span class="s3">* </span><span class="s1">N</span><span class="s3">)))</span>

    <span class="s6"># Poles around the unit circle like Butterworth</span>
    <span class="s1">p </span><span class="s3">= -</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">1j </span><span class="s3">* </span><span class="s1">pi </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(-</span><span class="s1">N</span><span class="s3">+</span><span class="s5">1</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s5">2</span><span class="s3">) / (</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">N</span><span class="s3">))</span>
    <span class="s6"># Warp into Chebyshev II</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">sinh</span><span class="s3">(</span><span class="s1">mu</span><span class="s3">) * </span><span class="s1">p</span><span class="s3">.</span><span class="s1">real </span><span class="s3">+ </span><span class="s5">1j </span><span class="s3">* </span><span class="s1">cosh</span><span class="s3">(</span><span class="s1">mu</span><span class="s3">) * </span><span class="s1">p</span><span class="s3">.</span><span class="s1">imag</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s5">1.0 </span><span class="s3">/ </span><span class="s1">p</span>

    <span class="s1">k </span><span class="s3">= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(-</span><span class="s1">p</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">) / </span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(-</span><span class="s1">z</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)).</span><span class="s1">real</span>
    <span class="s2">return </span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span>


<span class="s1">EPSILON </span><span class="s3">= </span><span class="s5">2e-16</span>

<span class="s6"># number of terms in solving degree equation</span>
<span class="s1">_ELLIPDEG_MMAX </span><span class="s3">= </span><span class="s5">7</span>


<span class="s2">def </span><span class="s1">_ellipdeg</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Solve degree equation using nomes 
 
    Given n, m1, solve 
       n * K(m) / K'(m) = K1(m1) / K1'(m1) 
    for m 
 
    See [1], Eq. (49) 
 
    References 
    ---------- 
    .. [1] Orfanidis, &quot;Lecture Notes on Elliptic Filter Design&quot;, 
           https://www.ece.rutgers.edu/~orfanidi/ece521/notes.pdf 
    &quot;&quot;&quot;</span>
    <span class="s1">K1 </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">ellipk</span><span class="s3">(</span><span class="s1">m1</span><span class="s3">)</span>
    <span class="s1">K1p </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">ellipkm1</span><span class="s3">(</span><span class="s1">m1</span><span class="s3">)</span>

    <span class="s1">q1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">K1p </span><span class="s3">/ </span><span class="s1">K1</span><span class="s3">)</span>
    <span class="s1">q </span><span class="s3">= </span><span class="s1">q1 </span><span class="s3">** (</span><span class="s5">1</span><span class="s3">/</span><span class="s1">n</span><span class="s3">)</span>

    <span class="s1">mnum </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">_ELLIPDEG_MMAX </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">mden </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">_ELLIPDEG_MMAX </span><span class="s3">+ </span><span class="s5">2</span><span class="s3">)</span>

    <span class="s1">num </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">q </span><span class="s3">** (</span><span class="s1">mnum </span><span class="s3">* (</span><span class="s1">mnum</span><span class="s3">+</span><span class="s5">1</span><span class="s3">)))</span>
    <span class="s1">den </span><span class="s3">= </span><span class="s5">1 </span><span class="s3">+ </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">q </span><span class="s3">** (</span><span class="s1">mden</span><span class="s3">**</span><span class="s5">2</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s5">16 </span><span class="s3">* </span><span class="s1">q </span><span class="s3">* (</span><span class="s1">num </span><span class="s3">/ </span><span class="s1">den</span><span class="s3">) ** </span><span class="s5">4</span>


<span class="s6"># Maximum number of iterations in Landen transformation recursion</span>
<span class="s6"># sequence.  10 is conservative; unit tests pass with 4, Orfanidis</span>
<span class="s6"># (see _arc_jac_cn [1]) suggests 5.</span>
<span class="s1">_ARC_JAC_SN_MAXITER </span><span class="s3">= </span><span class="s5">10</span>


<span class="s2">def </span><span class="s1">_arc_jac_sn</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">m</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Inverse Jacobian elliptic sn 
 
    Solve for z in w = sn(z, m) 
 
    Parameters 
    ---------- 
    w : complex scalar 
        argument 
 
    m : scalar 
        modulus; in interval [0, 1] 
 
 
    See [1], Eq. (56) 
 
    References 
    ---------- 
    .. [1] Orfanidis, &quot;Lecture Notes on Elliptic Filter Design&quot;, 
           https://www.ece.rutgers.edu/~orfanidi/ece521/notes.pdf 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_complement</span><span class="s3">(</span><span class="s1">kx</span><span class="s3">):</span>
        <span class="s6"># (1-k**2) ** 0.5; the expression below</span>
        <span class="s6"># works for small kx</span>
        <span class="s2">return </span><span class="s3">((</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">kx</span><span class="s3">) * (</span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">kx</span><span class="s3">)) ** </span><span class="s5">0.5</span>

    <span class="s1">k </span><span class="s3">= </span><span class="s1">m </span><span class="s3">** </span><span class="s5">0.5</span>

    <span class="s2">if </span><span class="s1">k </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
    <span class="s2">elif </span><span class="s1">k </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arctanh</span><span class="s3">(</span><span class="s1">w</span><span class="s3">)</span>

    <span class="s1">ks </span><span class="s3">= [</span><span class="s1">k</span><span class="s3">]</span>
    <span class="s1">niter </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">while </span><span class="s1">ks</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] != </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">k_ </span><span class="s3">= </span><span class="s1">ks</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s1">k_p </span><span class="s3">= </span><span class="s1">_complement</span><span class="s3">(</span><span class="s1">k_</span><span class="s3">)</span>
        <span class="s1">ks</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">k_p</span><span class="s3">) / (</span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">k_p</span><span class="s3">))</span>
        <span class="s1">niter </span><span class="s3">+= </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s1">niter </span><span class="s3">&gt; </span><span class="s1">_ARC_JAC_SN_MAXITER</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Landen transformation not converging'</span><span class="s3">)</span>

    <span class="s1">K </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">ks</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:])) * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">/</span><span class="s5">2</span>

    <span class="s1">wns </span><span class="s3">= [</span><span class="s1">w</span><span class="s3">]</span>

    <span class="s2">for </span><span class="s1">kn</span><span class="s3">, </span><span class="s1">knext </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">ks</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">ks</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]):</span>
        <span class="s1">wn </span><span class="s3">= </span><span class="s1">wns</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s1">wnext </span><span class="s3">= (</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">wn </span><span class="s3">/</span>
                 <span class="s3">((</span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">knext</span><span class="s3">) * (</span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">_complement</span><span class="s3">(</span><span class="s1">kn </span><span class="s3">* </span><span class="s1">wn</span><span class="s3">))))</span>
        <span class="s1">wns</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">wnext</span><span class="s3">)</span>

    <span class="s1">u </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">/ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arcsin</span><span class="s3">(</span><span class="s1">wns</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">])</span>

    <span class="s1">z </span><span class="s3">= </span><span class="s1">K </span><span class="s3">* </span><span class="s1">u</span>
    <span class="s2">return </span><span class="s1">z</span>


<span class="s2">def </span><span class="s1">_arc_jac_sc1</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">m</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Real inverse Jacobian sc, with complementary modulus 
 
    Solve for z in w = sc(z, 1-m) 
 
    w - real scalar 
 
    m - modulus 
 
    From [1], sc(z, m) = -i * sn(i * z, 1 - m) 
 
    References 
    ---------- 
    # noqa: E501 
    .. [1] https://functions.wolfram.com/EllipticFunctions/JacobiSC/introductions/JacobiPQs/ShowAll.html, 
       &quot;Representations through other Jacobi functions&quot; 
 
    &quot;&quot;&quot;</span>

    <span class="s1">zcomplex </span><span class="s3">= </span><span class="s1">_arc_jac_sn</span><span class="s3">(</span><span class="s5">1j </span><span class="s3">* </span><span class="s1">w</span><span class="s3">, </span><span class="s1">m</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">zcomplex</span><span class="s3">.</span><span class="s1">real</span><span class="s3">) &gt; </span><span class="s5">1e-14</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span>

    <span class="s2">return </span><span class="s1">zcomplex</span><span class="s3">.</span><span class="s1">imag</span>


<span class="s2">def </span><span class="s1">ellipap</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">rp</span><span class="s3">, </span><span class="s1">rs</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return (z,p,k) of Nth-order elliptic analog lowpass filter. 
 
    The filter is a normalized prototype that has `rp` decibels of ripple 
    in the passband and a stopband `rs` decibels down. 
 
    The filter's angular (e.g., rad/s) cutoff frequency is normalized to 1, 
    defined as the point at which the gain first drops below ``-rp``. 
 
    See Also 
    -------- 
    ellip : Filter design function using this prototype 
 
    References 
    ---------- 
    .. [1] Lutovac, Tosic, and Evans, &quot;Filter Design for Signal Processing&quot;, 
           Chapters 5 and 12. 
 
    .. [2] Orfanidis, &quot;Lecture Notes on Elliptic Filter Design&quot;, 
           https://www.ece.rutgers.edu/~orfanidi/ece521/notes.pdf 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)) != </span><span class="s1">N</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Filter order must be a nonnegative integer&quot;</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">N </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s6"># Avoid divide-by-zero warning</span>
        <span class="s6"># Even order filters have DC gain of -rp dB</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([]), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([]), </span><span class="s5">10</span><span class="s3">**(-</span><span class="s1">rp</span><span class="s3">/</span><span class="s5">20</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">N </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">p </span><span class="s3">= -</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s5">1.0 </span><span class="s3">/ </span><span class="s1">_pow10m1</span><span class="s3">(</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">rp</span><span class="s3">))</span>
        <span class="s1">k </span><span class="s3">= -</span><span class="s1">p</span>
        <span class="s1">z </span><span class="s3">= []</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">z</span><span class="s3">), </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">p</span><span class="s3">), </span><span class="s1">k</span>

    <span class="s1">eps_sq </span><span class="s3">= </span><span class="s1">_pow10m1</span><span class="s3">(</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">rp</span><span class="s3">)</span>

    <span class="s1">eps </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">eps_sq</span><span class="s3">)</span>
    <span class="s1">ck1_sq </span><span class="s3">= </span><span class="s1">eps_sq </span><span class="s3">/ </span><span class="s1">_pow10m1</span><span class="s3">(</span><span class="s5">0.1 </span><span class="s3">* </span><span class="s1">rs</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">ck1_sq </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Cannot design a filter with given rp and rs&quot;</span>
                         <span class="s4">&quot; specifications.&quot;</span><span class="s3">)</span>

    <span class="s1">val </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">ellipk</span><span class="s3">(</span><span class="s1">ck1_sq</span><span class="s3">), </span><span class="s1">special</span><span class="s3">.</span><span class="s1">ellipkm1</span><span class="s3">(</span><span class="s1">ck1_sq</span><span class="s3">)</span>

    <span class="s1">m </span><span class="s3">= </span><span class="s1">_ellipdeg</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">ck1_sq</span><span class="s3">)</span>

    <span class="s1">capk </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">ellipk</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)</span>

    <span class="s1">j </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">N </span><span class="s3">% </span><span class="s5">2</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">jj </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">j</span><span class="s3">)</span>

    <span class="s3">[</span><span class="s1">s</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">] = </span><span class="s1">special</span><span class="s3">.</span><span class="s1">ellipj</span><span class="s3">(</span><span class="s1">j </span><span class="s3">* </span><span class="s1">capk </span><span class="s3">/ </span><span class="s1">N</span><span class="s3">, </span><span class="s1">m </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">jj</span><span class="s3">))</span>
    <span class="s1">snew </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">compress</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">s</span><span class="s3">) &gt; </span><span class="s1">EPSILON</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s5">1.0 </span><span class="s3">/ (</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">m</span><span class="s3">) * </span><span class="s1">snew</span><span class="s3">)</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s5">1j </span><span class="s3">* </span><span class="s1">z</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">z</span><span class="s3">, </span><span class="s1">conjugate</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)))</span>

    <span class="s1">r </span><span class="s3">= </span><span class="s1">_arc_jac_sc1</span><span class="s3">(</span><span class="s5">1. </span><span class="s3">/ </span><span class="s1">eps</span><span class="s3">, </span><span class="s1">ck1_sq</span><span class="s3">)</span>
    <span class="s1">v0 </span><span class="s3">= </span><span class="s1">capk </span><span class="s3">* </span><span class="s1">r </span><span class="s3">/ (</span><span class="s1">N </span><span class="s3">* </span><span class="s1">val</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>

    <span class="s3">[</span><span class="s1">sv</span><span class="s3">, </span><span class="s1">cv</span><span class="s3">, </span><span class="s1">dv</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">] = </span><span class="s1">special</span><span class="s3">.</span><span class="s1">ellipj</span><span class="s3">(</span><span class="s1">v0</span><span class="s3">, </span><span class="s5">1 </span><span class="s3">- </span><span class="s1">m</span><span class="s3">)</span>
    <span class="s1">p </span><span class="s3">= -(</span><span class="s1">c </span><span class="s3">* </span><span class="s1">d </span><span class="s3">* </span><span class="s1">sv </span><span class="s3">* </span><span class="s1">cv </span><span class="s3">+ </span><span class="s5">1j </span><span class="s3">* </span><span class="s1">s </span><span class="s3">* </span><span class="s1">dv</span><span class="s3">) / (</span><span class="s5">1 </span><span class="s3">- (</span><span class="s1">d </span><span class="s3">* </span><span class="s1">sv</span><span class="s3">) ** </span><span class="s5">2.0</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">N </span><span class="s3">% </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s1">newp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">compress</span><span class="s3">(</span>
            <span class="s1">abs</span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">) &gt; </span><span class="s1">EPSILON </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">p </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">conjugate</span><span class="s3">(</span><span class="s1">p</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">).</span><span class="s1">real</span><span class="s3">),</span>
            <span class="s1">p</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span>
        <span class="s3">)</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">p</span><span class="s3">, </span><span class="s1">conjugate</span><span class="s3">(</span><span class="s1">newp</span><span class="s3">)))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">p</span><span class="s3">, </span><span class="s1">conjugate</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)))</span>

    <span class="s1">k </span><span class="s3">= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(-</span><span class="s1">p</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">) / </span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(-</span><span class="s1">z</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)).</span><span class="s1">real</span>
    <span class="s2">if </span><span class="s1">N </span><span class="s3">% </span><span class="s5">2 </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">k </span><span class="s3">/ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">eps_sq</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">z</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span>


<span class="s6"># TODO: Make this a real public function scipy.misc.ff</span>
<span class="s2">def </span><span class="s1">_falling_factorial</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Return the factorial of `x` to the `n` falling. 
 
    This is defined as: 
 
    .. math::   x^\underline n = (x)_n = x (x-1) \cdots (x-n+1) 
 
    This can more efficiently calculate ratios of factorials, since: 
 
    n!/m! == falling_factorial(n, n-m) 
 
    where n &gt;= m 
 
    skipping the factors that cancel out 
 
    the usual factorial n! == ff(n, n) 
    &quot;&quot;&quot;</span>
    <span class="s1">val </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">x </span><span class="s3">- </span><span class="s1">n </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">x </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">val </span><span class="s3">*= </span><span class="s1">k</span>
    <span class="s2">return </span><span class="s1">val</span>


<span class="s2">def </span><span class="s1">_bessel_poly</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">reverse</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the coefficients of Bessel polynomial of degree `n` 
 
    If `reverse` is true, a reverse Bessel polynomial is output. 
 
    Output is a list of coefficients: 
    [1]                   = 1 
    [1,  1]               = 1*s   +  1 
    [1,  3,  3]           = 1*s^2 +  3*s   +  3 
    [1,  6, 15, 15]       = 1*s^3 +  6*s^2 + 15*s   +  15 
    [1, 10, 45, 105, 105] = 1*s^4 + 10*s^3 + 45*s^2 + 105*s + 105 
    etc. 
 
    Output is a Python list of arbitrary precision long ints, so n is only 
    limited by your hardware's memory. 
 
    Sequence is http://oeis.org/A001498, and output can be confirmed to 
    match http://oeis.org/A001498/b001498.txt : 
 
    &gt;&gt;&gt; from scipy.signal._filter_design import _bessel_poly 
    &gt;&gt;&gt; i = 0 
    &gt;&gt;&gt; for n in range(51): 
    ...     for x in _bessel_poly(n, reverse=True): 
    ...         print(i, x) 
    ...         i += 1 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)) != </span><span class="s1">n</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Polynomial order must be a nonnegative integer&quot;</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)  </span><span class="s6"># np.int32 doesn't work, for instance</span>

    <span class="s1">out </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">):</span>
        <span class="s1">num </span><span class="s3">= </span><span class="s1">_falling_factorial</span><span class="s3">(</span><span class="s5">2</span><span class="s3">*</span><span class="s1">n </span><span class="s3">- </span><span class="s1">k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">den </span><span class="s3">= </span><span class="s5">2</span><span class="s3">**(</span><span class="s1">n </span><span class="s3">- </span><span class="s1">k</span><span class="s3">) * </span><span class="s1">math</span><span class="s3">.</span><span class="s1">factorial</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>
        <span class="s1">out</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">num </span><span class="s3">// </span><span class="s1">den</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">reverse</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">out</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">_campos_zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return approximate zero locations of Bessel polynomials y_n(x) for order 
    `n` using polynomial fit (Campos-Calderon 2011) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">([-</span><span class="s5">1</span><span class="s3">+</span><span class="s5">0j</span><span class="s3">])</span>

    <span class="s1">s </span><span class="s3">= </span><span class="s1">npp_polyval</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s3">])</span>
    <span class="s1">b3 </span><span class="s3">= </span><span class="s1">npp_polyval</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, [</span><span class="s5">16</span><span class="s3">, -</span><span class="s5">8</span><span class="s3">]) / </span><span class="s1">s</span>
    <span class="s1">b2 </span><span class="s3">= </span><span class="s1">npp_polyval</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, [-</span><span class="s5">24</span><span class="s3">, -</span><span class="s5">12</span><span class="s3">, </span><span class="s5">12</span><span class="s3">]) / </span><span class="s1">s</span>
    <span class="s1">b1 </span><span class="s3">= </span><span class="s1">npp_polyval</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, [</span><span class="s5">8</span><span class="s3">, </span><span class="s5">24</span><span class="s3">, -</span><span class="s5">12</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">]) / </span><span class="s1">s</span>
    <span class="s1">b0 </span><span class="s3">= </span><span class="s1">npp_polyval</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, [</span><span class="s5">0</span><span class="s3">, -</span><span class="s5">6</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">]) / </span><span class="s1">s</span>

    <span class="s1">r </span><span class="s3">= </span><span class="s1">npp_polyval</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">])</span>
    <span class="s1">a1 </span><span class="s3">= </span><span class="s1">npp_polyval</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, [-</span><span class="s5">6</span><span class="s3">, -</span><span class="s5">6</span><span class="s3">]) / </span><span class="s1">r</span>
    <span class="s1">a2 </span><span class="s3">= </span><span class="s5">6 </span><span class="s3">/ </span><span class="s1">r</span>

    <span class="s1">k </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">npp_polyval</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, [</span><span class="s5">0</span><span class="s3">, </span><span class="s1">a1</span><span class="s3">, </span><span class="s1">a2</span><span class="s3">])</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">npp_polyval</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, [</span><span class="s1">b0</span><span class="s3">, </span><span class="s1">b1</span><span class="s3">, </span><span class="s1">b2</span><span class="s3">, </span><span class="s1">b3</span><span class="s3">])</span>

    <span class="s2">return </span><span class="s1">x </span><span class="s3">+ </span><span class="s5">1j</span><span class="s3">*</span><span class="s1">y</span>


<span class="s2">def </span><span class="s1">_aberth</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s5">1e-15</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">=</span><span class="s5">50</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Given a function `f`, its first derivative `fp`, and a set of initial 
    guesses `x0`, simultaneously find the roots of the polynomial using the 
    Aberth-Ehrlich method. 
 
    ``len(x0)`` should equal the number of roots of `f`. 
 
    (This is not a complete implementation of Bini's algorithm.) 
    &quot;&quot;&quot;</span>

    <span class="s1">N </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x0</span><span class="s3">)</span>

    <span class="s1">x </span><span class="s3">= </span><span class="s1">array</span><span class="s3">(</span><span class="s1">x0</span><span class="s3">, </span><span class="s1">complex</span><span class="s3">)</span>
    <span class="s1">beta </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">x0</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">iteration </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">maxiter</span><span class="s3">):</span>
        <span class="s1">alpha </span><span class="s3">= -</span><span class="s1">f</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) / </span><span class="s1">fp</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)  </span><span class="s6"># Newton's method</span>

        <span class="s6"># Model &quot;repulsion&quot; between zeros</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">N</span><span class="s3">):</span>
            <span class="s1">beta</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s5">1</span><span class="s3">/(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] - </span><span class="s1">x</span><span class="s3">[</span><span class="s1">k</span><span class="s3">+</span><span class="s5">1</span><span class="s3">:]))</span>
            <span class="s1">beta</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] += </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s5">1</span><span class="s3">/(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] - </span><span class="s1">x</span><span class="s3">[:</span><span class="s1">k</span><span class="s3">]))</span>

        <span class="s1">x </span><span class="s3">+= </span><span class="s1">alpha </span><span class="s3">/ (</span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">alpha </span><span class="s3">* </span><span class="s1">beta</span><span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)):</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'Root-finding calculation failed'</span><span class="s3">)</span>

        <span class="s6"># Mekwi: The iterative process can be stopped when |hn| has become</span>
        <span class="s6"># less than the largest error one is willing to permit in the root.</span>
        <span class="s2">if </span><span class="s1">all</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">alpha</span><span class="s3">) &lt;= </span><span class="s1">tol</span><span class="s3">):</span>
            <span class="s2">break</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">Exception</span><span class="s3">(</span><span class="s4">'Zeros failed to converge'</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">x</span>


<span class="s2">def </span><span class="s1">_bessel_zeros</span><span class="s3">(</span><span class="s1">N</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find zeros of ordinary Bessel polynomial of order `N`, by root-finding of 
    modified Bessel function of the second kind 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">N </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">asarray</span><span class="s3">([])</span>

    <span class="s6"># Generate starting points</span>
    <span class="s1">x0 </span><span class="s3">= </span><span class="s1">_campos_zeros</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)</span>

    <span class="s6"># Zeros are the same for exp(1/x)*K_{N+0.5}(1/x) and Nth-order ordinary</span>
    <span class="s6"># Bessel polynomial y_N(x)</span>
    <span class="s2">def </span><span class="s1">f</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">special</span><span class="s3">.</span><span class="s1">kve</span><span class="s3">(</span><span class="s1">N</span><span class="s3">+</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">/</span><span class="s1">x</span><span class="s3">)</span>

    <span class="s6"># First derivative of above</span>
    <span class="s2">def </span><span class="s1">fp</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">special</span><span class="s3">.</span><span class="s1">kve</span><span class="s3">(</span><span class="s1">N</span><span class="s3">-</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">/</span><span class="s1">x</span><span class="s3">)/(</span><span class="s5">2</span><span class="s3">*</span><span class="s1">x</span><span class="s3">**</span><span class="s5">2</span><span class="s3">) -</span>
                <span class="s1">special</span><span class="s3">.</span><span class="s1">kve</span><span class="s3">(</span><span class="s1">N</span><span class="s3">+</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">/</span><span class="s1">x</span><span class="s3">)/(</span><span class="s1">x</span><span class="s3">**</span><span class="s5">2</span><span class="s3">) +</span>
                <span class="s1">special</span><span class="s3">.</span><span class="s1">kve</span><span class="s3">(</span><span class="s1">N</span><span class="s3">+</span><span class="s5">1.5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">/</span><span class="s1">x</span><span class="s3">)/(</span><span class="s5">2</span><span class="s3">*</span><span class="s1">x</span><span class="s3">**</span><span class="s5">2</span><span class="s3">))</span>

    <span class="s6"># Starting points converge to true zeros</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">_aberth</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">)</span>

    <span class="s6"># Improve precision using Newton's method on each</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)):</span>
        <span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">optimize</span><span class="s3">.</span><span class="s1">newton</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s5">1e-15</span><span class="s3">)</span>

    <span class="s6"># Average complex conjugates to make them exactly symmetrical</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">((</span><span class="s1">x</span><span class="s3">, </span><span class="s1">x</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">].</span><span class="s1">conj</span><span class="s3">()), </span><span class="s5">0</span><span class="s3">)</span>

    <span class="s6"># Zeros should sum to -1</span>
    <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) + </span><span class="s5">1</span><span class="s3">) &gt; </span><span class="s5">1e-15</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'Generated zeros are inaccurate'</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">x</span>


<span class="s2">def </span><span class="s1">_norm_factor</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Numerically find frequency shift to apply to delay-normalized filter such 
    that -3 dB point is at 1 rad/sec. 
 
    `p` is an array_like of polynomial poles 
    `k` is a float gain 
 
    First 10 values are listed in &quot;Bessel Scale Factors&quot; table, 
    &quot;Bessel Filters Polynomials, Poles and Circuit Elements 2003, C. Bond.&quot; 
    &quot;&quot;&quot;</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">complex</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">G</span><span class="s3">(</span><span class="s1">w</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Gain of filter 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">k </span><span class="s3">/ </span><span class="s1">prod</span><span class="s3">(</span><span class="s5">1j</span><span class="s3">*</span><span class="s1">w </span><span class="s3">- </span><span class="s1">p</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">cutoff</span><span class="s3">(</span><span class="s1">w</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        When gain = -3 dB, return 0 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">G</span><span class="s3">(</span><span class="s1">w</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">/</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s5">2</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">optimize</span><span class="s3">.</span><span class="s1">newton</span><span class="s3">(</span><span class="s1">cutoff</span><span class="s3">, </span><span class="s5">1.5</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">besselap</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">norm</span><span class="s3">=</span><span class="s4">'phase'</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return (z,p,k) for analog prototype of an Nth-order Bessel filter. 
 
    Parameters 
    ---------- 
    N : int 
        The order of the filter. 
    norm : {'phase', 'delay', 'mag'}, optional 
        Frequency normalization: 
 
        ``phase`` 
            The filter is normalized such that the phase response reaches its 
            midpoint at an angular (e.g., rad/s) cutoff frequency of 1. This 
            happens for both low-pass and high-pass filters, so this is the 
            &quot;phase-matched&quot; case. [6]_ 
 
            The magnitude response asymptotes are the same as a Butterworth 
            filter of the same order with a cutoff of `Wn`. 
 
            This is the default, and matches MATLAB's implementation. 
 
        ``delay`` 
            The filter is normalized such that the group delay in the passband 
            is 1 (e.g., 1 second). This is the &quot;natural&quot; type obtained by 
            solving Bessel polynomials 
 
        ``mag`` 
            The filter is normalized such that the gain magnitude is -3 dB at 
            angular frequency 1. This is called &quot;frequency normalization&quot; by 
            Bond. [1]_ 
 
        .. versionadded:: 0.18.0 
 
    Returns 
    ------- 
    z : ndarray 
        Zeros of the transfer function. Is always an empty array. 
    p : ndarray 
        Poles of the transfer function. 
    k : scalar 
        Gain of the transfer function. For phase-normalized, this is always 1. 
 
    See Also 
    -------- 
    bessel : Filter design function using this prototype 
 
    Notes 
    ----- 
    To find the pole locations, approximate starting points are generated [2]_ 
    for the zeros of the ordinary Bessel polynomial [3]_, then the 
    Aberth-Ehrlich method [4]_ [5]_ is used on the Kv(x) Bessel function to 
    calculate more accurate zeros, and these locations are then inverted about 
    the unit circle. 
 
    References 
    ---------- 
    .. [1] C.R. Bond, &quot;Bessel Filter Constants&quot;, 
           http://www.crbond.com/papers/bsf.pdf 
    .. [2] Campos and Calderon, &quot;Approximate closed-form formulas for the 
           zeros of the Bessel Polynomials&quot;, :arXiv:`1105.0957`. 
    .. [3] Thomson, W.E., &quot;Delay Networks having Maximally Flat Frequency 
           Characteristics&quot;, Proceedings of the Institution of Electrical 
           Engineers, Part III, November 1949, Vol. 96, No. 44, pp. 487-490. 
    .. [4] Aberth, &quot;Iteration Methods for Finding all Zeros of a Polynomial 
           Simultaneously&quot;, Mathematics of Computation, Vol. 27, No. 122, 
           April 1973 
    .. [5] Ehrlich, &quot;A modified Newton method for polynomials&quot;, Communications 
           of the ACM, Vol. 10, Issue 2, pp. 107-108, Feb. 1967, 
           :DOI:`10.1145/363067.363115` 
    .. [6] Miller and Bohn, &quot;A Bessel Filter Crossover, and Its Relation to 
           Others&quot;, RaneNote 147, 1998, 
           https://www.ranecommercial.com/legacy/note147.html 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)) != </span><span class="s1">N</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Filter order must be a nonnegative integer&quot;</span><span class="s3">)</span>

    <span class="s1">N </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)  </span><span class="s6"># calculation below doesn't always fit in np.int64</span>
    <span class="s2">if </span><span class="s1">N </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">p </span><span class="s3">= []</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s6"># Find roots of reverse Bessel polynomial</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s5">1</span><span class="s3">/</span><span class="s1">_bessel_zeros</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)</span>

        <span class="s1">a_last </span><span class="s3">= </span><span class="s1">_falling_factorial</span><span class="s3">(</span><span class="s5">2</span><span class="s3">*</span><span class="s1">N</span><span class="s3">, </span><span class="s1">N</span><span class="s3">) // </span><span class="s5">2</span><span class="s3">**</span><span class="s1">N</span>

        <span class="s6"># Shift them to a different normalization if required</span>
        <span class="s2">if </span><span class="s1">norm </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'delay'</span><span class="s3">, </span><span class="s4">'mag'</span><span class="s3">):</span>
            <span class="s6"># Normalized for group delay of 1</span>
            <span class="s1">k </span><span class="s3">= </span><span class="s1">a_last</span>
            <span class="s2">if </span><span class="s1">norm </span><span class="s3">== </span><span class="s4">'mag'</span><span class="s3">:</span>
                <span class="s6"># -3 dB magnitude point is at 1 rad/sec</span>
                <span class="s1">norm_factor </span><span class="s3">= </span><span class="s1">_norm_factor</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>
                <span class="s1">p </span><span class="s3">/= </span><span class="s1">norm_factor</span>
                <span class="s1">k </span><span class="s3">= </span><span class="s1">norm_factor</span><span class="s3">**-</span><span class="s1">N </span><span class="s3">* </span><span class="s1">a_last</span>
        <span class="s2">elif </span><span class="s1">norm </span><span class="s3">== </span><span class="s4">'phase'</span><span class="s3">:</span>
            <span class="s6"># Phase-matched (1/2 max phase shift at 1 rad/sec)</span>
            <span class="s6"># Asymptotes are same as Butterworth filter</span>
            <span class="s1">p </span><span class="s3">*= </span><span class="s5">10</span><span class="s3">**(-</span><span class="s1">math</span><span class="s3">.</span><span class="s1">log10</span><span class="s3">(</span><span class="s1">a_last</span><span class="s3">)/</span><span class="s1">N</span><span class="s3">)</span>
            <span class="s1">k </span><span class="s3">= </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'normalization not understood'</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">asarray</span><span class="s3">([]), </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">complex</span><span class="s3">), </span><span class="s1">float</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">iirnotch</span><span class="s3">(</span><span class="s1">w0</span><span class="s3">, </span><span class="s1">Q</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">2.0</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Design second-order IIR notch digital filter. 
 
    A notch filter is a band-stop filter with a narrow bandwidth 
    (high quality factor). It rejects a narrow frequency band and 
    leaves the rest of the spectrum little changed. 
 
    Parameters 
    ---------- 
    w0 : float 
        Frequency to remove from a signal. If `fs` is specified, this is in 
        the same units as `fs`. By default, it is a normalized scalar that must 
        satisfy  ``0 &lt; w0 &lt; 1``, with ``w0 = 1`` corresponding to half of the 
        sampling frequency. 
    Q : float 
        Quality factor. Dimensionless parameter that characterizes 
        notch filter -3 dB bandwidth ``bw`` relative to its center 
        frequency, ``Q = w0/bw``. 
    fs : float, optional 
        The sampling frequency of the digital system. 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    b, a : ndarray, ndarray 
        Numerator (``b``) and denominator (``a``) polynomials 
        of the IIR filter. 
 
    See Also 
    -------- 
    iirpeak 
 
    Notes 
    ----- 
    .. versionadded:: 0.19.0 
 
    References 
    ---------- 
    .. [1] Sophocles J. Orfanidis, &quot;Introduction To Signal Processing&quot;, 
           Prentice-Hall, 1996 
 
    Examples 
    -------- 
    Design and plot filter to remove the 60 Hz component from a 
    signal sampled at 200 Hz, using a quality factor Q = 30 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; fs = 200.0  # Sample frequency (Hz) 
    &gt;&gt;&gt; f0 = 60.0  # Frequency to be removed from signal (Hz) 
    &gt;&gt;&gt; Q = 30.0  # Quality factor 
    &gt;&gt;&gt; # Design notch filter 
    &gt;&gt;&gt; b, a = signal.iirnotch(f0, Q, fs) 
 
    &gt;&gt;&gt; # Frequency response 
    &gt;&gt;&gt; freq, h = signal.freqz(b, a, fs=fs) 
    &gt;&gt;&gt; # Plot 
    &gt;&gt;&gt; fig, ax = plt.subplots(2, 1, figsize=(8, 6)) 
    &gt;&gt;&gt; ax[0].plot(freq, 20*np.log10(abs(h)), color='blue') 
    &gt;&gt;&gt; ax[0].set_title(&quot;Frequency Response&quot;) 
    &gt;&gt;&gt; ax[0].set_ylabel(&quot;Amplitude (dB)&quot;, color='blue') 
    &gt;&gt;&gt; ax[0].set_xlim([0, 100]) 
    &gt;&gt;&gt; ax[0].set_ylim([-25, 10]) 
    &gt;&gt;&gt; ax[0].grid(True) 
    &gt;&gt;&gt; ax[1].plot(freq, np.unwrap(np.angle(h))*180/np.pi, color='green') 
    &gt;&gt;&gt; ax[1].set_ylabel(&quot;Angle (degrees)&quot;, color='green') 
    &gt;&gt;&gt; ax[1].set_xlabel(&quot;Frequency (Hz)&quot;) 
    &gt;&gt;&gt; ax[1].set_xlim([0, 100]) 
    &gt;&gt;&gt; ax[1].set_yticks([-90, -60, -30, 0, 30, 60, 90]) 
    &gt;&gt;&gt; ax[1].set_ylim([-90, 90]) 
    &gt;&gt;&gt; ax[1].grid(True) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>

    <span class="s2">return </span><span class="s1">_design_notch_peak_filter</span><span class="s3">(</span><span class="s1">w0</span><span class="s3">, </span><span class="s1">Q</span><span class="s3">, </span><span class="s4">&quot;notch&quot;</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">iirpeak</span><span class="s3">(</span><span class="s1">w0</span><span class="s3">, </span><span class="s1">Q</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">2.0</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Design second-order IIR peak (resonant) digital filter. 
 
    A peak filter is a band-pass filter with a narrow bandwidth 
    (high quality factor). It rejects components outside a narrow 
    frequency band. 
 
    Parameters 
    ---------- 
    w0 : float 
        Frequency to be retained in a signal. If `fs` is specified, this is in 
        the same units as `fs`. By default, it is a normalized scalar that must 
        satisfy  ``0 &lt; w0 &lt; 1``, with ``w0 = 1`` corresponding to half of the 
        sampling frequency. 
    Q : float 
        Quality factor. Dimensionless parameter that characterizes 
        peak filter -3 dB bandwidth ``bw`` relative to its center 
        frequency, ``Q = w0/bw``. 
    fs : float, optional 
        The sampling frequency of the digital system. 
 
        .. versionadded:: 1.2.0 
 
    Returns 
    ------- 
    b, a : ndarray, ndarray 
        Numerator (``b``) and denominator (``a``) polynomials 
        of the IIR filter. 
 
    See Also 
    -------- 
    iirnotch 
 
    Notes 
    ----- 
    .. versionadded:: 0.19.0 
 
    References 
    ---------- 
    .. [1] Sophocles J. Orfanidis, &quot;Introduction To Signal Processing&quot;, 
           Prentice-Hall, 1996 
 
    Examples 
    -------- 
    Design and plot filter to remove the frequencies other than the 300 Hz 
    component from a signal sampled at 1000 Hz, using a quality factor Q = 30 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; fs = 1000.0  # Sample frequency (Hz) 
    &gt;&gt;&gt; f0 = 300.0  # Frequency to be retained (Hz) 
    &gt;&gt;&gt; Q = 30.0  # Quality factor 
    &gt;&gt;&gt; # Design peak filter 
    &gt;&gt;&gt; b, a = signal.iirpeak(f0, Q, fs) 
 
    &gt;&gt;&gt; # Frequency response 
    &gt;&gt;&gt; freq, h = signal.freqz(b, a, fs=fs) 
    &gt;&gt;&gt; # Plot 
    &gt;&gt;&gt; fig, ax = plt.subplots(2, 1, figsize=(8, 6)) 
    &gt;&gt;&gt; ax[0].plot(freq, 20*np.log10(np.maximum(abs(h), 1e-5)), color='blue') 
    &gt;&gt;&gt; ax[0].set_title(&quot;Frequency Response&quot;) 
    &gt;&gt;&gt; ax[0].set_ylabel(&quot;Amplitude (dB)&quot;, color='blue') 
    &gt;&gt;&gt; ax[0].set_xlim([0, 500]) 
    &gt;&gt;&gt; ax[0].set_ylim([-50, 10]) 
    &gt;&gt;&gt; ax[0].grid(True) 
    &gt;&gt;&gt; ax[1].plot(freq, np.unwrap(np.angle(h))*180/np.pi, color='green') 
    &gt;&gt;&gt; ax[1].set_ylabel(&quot;Angle (degrees)&quot;, color='green') 
    &gt;&gt;&gt; ax[1].set_xlabel(&quot;Frequency (Hz)&quot;) 
    &gt;&gt;&gt; ax[1].set_xlim([0, 500]) 
    &gt;&gt;&gt; ax[1].set_yticks([-90, -60, -30, 0, 30, 60, 90]) 
    &gt;&gt;&gt; ax[1].set_ylim([-90, 90]) 
    &gt;&gt;&gt; ax[1].grid(True) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>

    <span class="s2">return </span><span class="s1">_design_notch_peak_filter</span><span class="s3">(</span><span class="s1">w0</span><span class="s3">, </span><span class="s1">Q</span><span class="s3">, </span><span class="s4">&quot;peak&quot;</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_design_notch_peak_filter</span><span class="s3">(</span><span class="s1">w0</span><span class="s3">, </span><span class="s1">Q</span><span class="s3">, </span><span class="s1">ftype</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">2.0</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Design notch or peak digital filter. 
 
    Parameters 
    ---------- 
    w0 : float 
        Normalized frequency to remove from a signal. If `fs` is specified, 
        this is in the same units as `fs`. By default, it is a normalized 
        scalar that must satisfy  ``0 &lt; w0 &lt; 1``, with ``w0 = 1`` 
        corresponding to half of the sampling frequency. 
    Q : float 
        Quality factor. Dimensionless parameter that characterizes 
        notch filter -3 dB bandwidth ``bw`` relative to its center 
        frequency, ``Q = w0/bw``. 
    ftype : str 
        The type of IIR filter to design: 
 
            - notch filter : ``notch`` 
            - peak filter  : ``peak`` 
    fs : float, optional 
        The sampling frequency of the digital system. 
 
        .. versionadded:: 1.2.0: 
 
    Returns 
    ------- 
    b, a : ndarray, ndarray 
        Numerator (``b``) and denominator (``a``) polynomials 
        of the IIR filter. 
    &quot;&quot;&quot;</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s6"># Guarantee that the inputs are floats</span>
    <span class="s1">w0 </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">w0</span><span class="s3">)</span>
    <span class="s1">Q </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">Q</span><span class="s3">)</span>
    <span class="s1">w0 </span><span class="s3">= </span><span class="s5">2</span><span class="s3">*</span><span class="s1">w0</span><span class="s3">/</span><span class="s1">fs</span>

    <span class="s6"># Checks if w0 is within the range</span>
    <span class="s2">if </span><span class="s1">w0 </span><span class="s3">&gt; </span><span class="s5">1.0 </span><span class="s2">or </span><span class="s1">w0 </span><span class="s3">&lt; </span><span class="s5">0.0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;w0 should be such that 0 &lt; w0 &lt; 1&quot;</span><span class="s3">)</span>

    <span class="s6"># Get bandwidth</span>
    <span class="s1">bw </span><span class="s3">= </span><span class="s1">w0</span><span class="s3">/</span><span class="s1">Q</span>

    <span class="s6"># Normalize inputs</span>
    <span class="s1">bw </span><span class="s3">= </span><span class="s1">bw</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span>
    <span class="s1">w0 </span><span class="s3">= </span><span class="s1">w0</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span>

    <span class="s2">if </span><span class="s1">ftype </span><span class="s2">not in </span><span class="s3">(</span><span class="s4">&quot;notch&quot;</span><span class="s3">, </span><span class="s4">&quot;peak&quot;</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Unknown ftype.&quot;</span><span class="s3">)</span>

    <span class="s6"># Compute beta according to Eqs. 11.3.4 (p.575) and 11.3.19 (p.579) from</span>
    <span class="s6"># reference [1]. Due to assuming a -3 dB attenuation value, i.e, assuming</span>
    <span class="s6"># gb = 1 / np.sqrt(2), the following terms simplify to:</span>
    <span class="s6">#   (np.sqrt(1.0 - gb**2.0) / gb) = 1</span>
    <span class="s6">#   (gb / np.sqrt(1.0 - gb**2.0)) = 1</span>
    <span class="s1">beta </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">tan</span><span class="s3">(</span><span class="s1">bw</span><span class="s3">/</span><span class="s5">2.0</span><span class="s3">)</span>

    <span class="s6"># Compute gain: formula 11.3.6 (p.575) from reference [1]</span>
    <span class="s1">gain </span><span class="s3">= </span><span class="s5">1.0</span><span class="s3">/(</span><span class="s5">1.0</span><span class="s3">+</span><span class="s1">beta</span><span class="s3">)</span>

    <span class="s6"># Compute numerator b and denominator a</span>
    <span class="s6"># formulas 11.3.7 (p.575) and 11.3.21 (p.579)</span>
    <span class="s6"># from reference [1]</span>
    <span class="s2">if </span><span class="s1">ftype </span><span class="s3">== </span><span class="s4">&quot;notch&quot;</span><span class="s3">:</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">gain</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">1.0</span><span class="s3">, -</span><span class="s5">2.0</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">w0</span><span class="s3">), </span><span class="s5">1.0</span><span class="s3">])</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">b </span><span class="s3">= (</span><span class="s5">1.0</span><span class="s3">-</span><span class="s1">gain</span><span class="s3">)*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">0.0</span><span class="s3">, -</span><span class="s5">1.0</span><span class="s3">])</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">1.0</span><span class="s3">, -</span><span class="s5">2.0</span><span class="s3">*</span><span class="s1">gain</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">w0</span><span class="s3">), (</span><span class="s5">2.0</span><span class="s3">*</span><span class="s1">gain</span><span class="s3">-</span><span class="s5">1.0</span><span class="s3">)])</span>

    <span class="s2">return </span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span>


<span class="s2">def </span><span class="s1">iircomb</span><span class="s3">(</span><span class="s1">w0</span><span class="s3">, </span><span class="s1">Q</span><span class="s3">, </span><span class="s1">ftype</span><span class="s3">=</span><span class="s4">'notch'</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">2.0</span><span class="s3">, *, </span><span class="s1">pass_zero</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Design IIR notching or peaking digital comb filter. 
 
    A notching comb filter consists of regularly-spaced band-stop filters with 
    a narrow bandwidth (high quality factor). Each rejects a narrow frequency 
    band and leaves the rest of the spectrum little changed. 
 
    A peaking comb filter consists of regularly-spaced band-pass filters with 
    a narrow bandwidth (high quality factor). Each rejects components outside 
    a narrow frequency band. 
 
    Parameters 
    ---------- 
    w0 : float 
        The fundamental frequency of the comb filter (the spacing between its 
        peaks). This must evenly divide the sampling frequency. If `fs` is 
        specified, this is in the same units as `fs`. By default, it is 
        a normalized scalar that must satisfy  ``0 &lt; w0 &lt; 1``, with 
        ``w0 = 1`` corresponding to half of the sampling frequency. 
    Q : float 
        Quality factor. Dimensionless parameter that characterizes 
        notch filter -3 dB bandwidth ``bw`` relative to its center 
        frequency, ``Q = w0/bw``. 
    ftype : {'notch', 'peak'} 
        The type of comb filter generated by the function. If 'notch', then 
        the Q factor applies to the notches. If 'peak', then the Q factor 
        applies to the peaks.  Default is 'notch'. 
    fs : float, optional 
        The sampling frequency of the signal. Default is 2.0. 
    pass_zero : bool, optional 
        If False (default), the notches (nulls) of the filter are centered on 
        frequencies [0, w0, 2*w0, ...], and the peaks are centered on the 
        midpoints [w0/2, 3*w0/2, 5*w0/2, ...].  If True, the peaks are centered 
        on [0, w0, 2*w0, ...] (passing zero frequency) and vice versa. 
 
        .. versionadded:: 1.9.0 
 
    Returns 
    ------- 
    b, a : ndarray, ndarray 
        Numerator (``b``) and denominator (``a``) polynomials 
        of the IIR filter. 
 
    Raises 
    ------ 
    ValueError 
        If `w0` is less than or equal to 0 or greater than or equal to 
        ``fs/2``, if `fs` is not divisible by `w0`, if `ftype` 
        is not 'notch' or 'peak' 
 
    See Also 
    -------- 
    iirnotch 
    iirpeak 
 
    Notes 
    ----- 
    For implementation details, see [1]_. The TF implementation of the 
    comb filter is numerically stable even at higher orders due to the 
    use of a single repeated pole, which won't suffer from precision loss. 
 
    References 
    ---------- 
    .. [1] Sophocles J. Orfanidis, &quot;Introduction To Signal Processing&quot;, 
           Prentice-Hall, 1996, ch. 11, &quot;Digital Filter Design&quot; 
 
    Examples 
    -------- 
    Design and plot notching comb filter at 20 Hz for a 
    signal sampled at 200 Hz, using quality factor Q = 30 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; fs = 200.0  # Sample frequency (Hz) 
    &gt;&gt;&gt; f0 = 20.0  # Frequency to be removed from signal (Hz) 
    &gt;&gt;&gt; Q = 30.0  # Quality factor 
    &gt;&gt;&gt; # Design notching comb filter 
    &gt;&gt;&gt; b, a = signal.iircomb(f0, Q, ftype='notch', fs=fs) 
 
    &gt;&gt;&gt; # Frequency response 
    &gt;&gt;&gt; freq, h = signal.freqz(b, a, fs=fs) 
    &gt;&gt;&gt; response = abs(h) 
    &gt;&gt;&gt; # To avoid divide by zero when graphing 
    &gt;&gt;&gt; response[response == 0] = 1e-20 
    &gt;&gt;&gt; # Plot 
    &gt;&gt;&gt; fig, ax = plt.subplots(2, 1, figsize=(8, 6), sharex=True) 
    &gt;&gt;&gt; ax[0].plot(freq, 20*np.log10(abs(response)), color='blue') 
    &gt;&gt;&gt; ax[0].set_title(&quot;Frequency Response&quot;) 
    &gt;&gt;&gt; ax[0].set_ylabel(&quot;Amplitude (dB)&quot;, color='blue') 
    &gt;&gt;&gt; ax[0].set_xlim([0, 100]) 
    &gt;&gt;&gt; ax[0].set_ylim([-30, 10]) 
    &gt;&gt;&gt; ax[0].grid(True) 
    &gt;&gt;&gt; ax[1].plot(freq, (np.angle(h)*180/np.pi+180)%360 - 180, color='green') 
    &gt;&gt;&gt; ax[1].set_ylabel(&quot;Angle (degrees)&quot;, color='green') 
    &gt;&gt;&gt; ax[1].set_xlabel(&quot;Frequency (Hz)&quot;) 
    &gt;&gt;&gt; ax[1].set_xlim([0, 100]) 
    &gt;&gt;&gt; ax[1].set_yticks([-90, -60, -30, 0, 30, 60, 90]) 
    &gt;&gt;&gt; ax[1].set_ylim([-90, 90]) 
    &gt;&gt;&gt; ax[1].grid(True) 
    &gt;&gt;&gt; plt.show() 
 
    Design and plot peaking comb filter at 250 Hz for a 
    signal sampled at 1000 Hz, using quality factor Q = 30 
 
    &gt;&gt;&gt; fs = 1000.0  # Sample frequency (Hz) 
    &gt;&gt;&gt; f0 = 250.0  # Frequency to be retained (Hz) 
    &gt;&gt;&gt; Q = 30.0  # Quality factor 
    &gt;&gt;&gt; # Design peaking filter 
    &gt;&gt;&gt; b, a = signal.iircomb(f0, Q, ftype='peak', fs=fs, pass_zero=True) 
 
    &gt;&gt;&gt; # Frequency response 
    &gt;&gt;&gt; freq, h = signal.freqz(b, a, fs=fs) 
    &gt;&gt;&gt; response = abs(h) 
    &gt;&gt;&gt; # To avoid divide by zero when graphing 
    &gt;&gt;&gt; response[response == 0] = 1e-20 
    &gt;&gt;&gt; # Plot 
    &gt;&gt;&gt; fig, ax = plt.subplots(2, 1, figsize=(8, 6), sharex=True) 
    &gt;&gt;&gt; ax[0].plot(freq, 20*np.log10(np.maximum(abs(h), 1e-5)), color='blue') 
    &gt;&gt;&gt; ax[0].set_title(&quot;Frequency Response&quot;) 
    &gt;&gt;&gt; ax[0].set_ylabel(&quot;Amplitude (dB)&quot;, color='blue') 
    &gt;&gt;&gt; ax[0].set_xlim([0, 500]) 
    &gt;&gt;&gt; ax[0].set_ylim([-80, 10]) 
    &gt;&gt;&gt; ax[0].grid(True) 
    &gt;&gt;&gt; ax[1].plot(freq, (np.angle(h)*180/np.pi+180)%360 - 180, color='green') 
    &gt;&gt;&gt; ax[1].set_ylabel(&quot;Angle (degrees)&quot;, color='green') 
    &gt;&gt;&gt; ax[1].set_xlabel(&quot;Frequency (Hz)&quot;) 
    &gt;&gt;&gt; ax[1].set_xlim([0, 500]) 
    &gt;&gt;&gt; ax[1].set_yticks([-90, -60, -30, 0, 30, 60, 90]) 
    &gt;&gt;&gt; ax[1].set_ylim([-90, 90]) 
    &gt;&gt;&gt; ax[1].grid(True) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>

    <span class="s6"># Convert w0, Q, and fs to float</span>
    <span class="s1">w0 </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">w0</span><span class="s3">)</span>
    <span class="s1">Q </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">Q</span><span class="s3">)</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s6"># Check for invalid cutoff frequency or filter type</span>
    <span class="s1">ftype </span><span class="s3">= </span><span class="s1">ftype</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">()</span>
    <span class="s2">if not </span><span class="s5">0 </span><span class="s3">&lt; </span><span class="s1">w0 </span><span class="s3">&lt; </span><span class="s1">fs </span><span class="s3">/ </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;w0 must be between 0 and </span><span class="s2">{</span><span class="s1">fs </span><span class="s3">/ </span><span class="s5">2</span><span class="s2">}</span><span class="s4">&quot;</span>
                         <span class="s4">f&quot; (nyquist), but given </span><span class="s2">{</span><span class="s1">w0</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">ftype </span><span class="s2">not in </span><span class="s3">(</span><span class="s4">'notch'</span><span class="s3">, </span><span class="s4">'peak'</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'ftype must be either notch or peak.'</span><span class="s3">)</span>

    <span class="s6"># Compute the order of the filter</span>
    <span class="s1">N </span><span class="s3">= </span><span class="s1">round</span><span class="s3">(</span><span class="s1">fs </span><span class="s3">/ </span><span class="s1">w0</span><span class="s3">)</span>

    <span class="s6"># Check for cutoff frequency divisibility</span>
    <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">w0 </span><span class="s3">- </span><span class="s1">fs</span><span class="s3">/</span><span class="s1">N</span><span class="s3">)/</span><span class="s1">fs </span><span class="s3">&gt; </span><span class="s5">1e-14</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'fs must be divisible by w0.'</span><span class="s3">)</span>

    <span class="s6"># Compute frequency in radians and filter bandwidth</span>
    <span class="s6"># Eq. 11.3.1 (p. 574) from reference [1]</span>
    <span class="s1">w0 </span><span class="s3">= (</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">w0</span><span class="s3">) / </span><span class="s1">fs</span>
    <span class="s1">w_delta </span><span class="s3">= </span><span class="s1">w0 </span><span class="s3">/ </span><span class="s1">Q</span>

    <span class="s6"># Define base gain values depending on notch or peak filter</span>
    <span class="s6"># Compute -3dB attenuation</span>
    <span class="s6"># Eqs. 11.4.1 and 11.4.2 (p. 582) from reference [1]</span>
    <span class="s2">if </span><span class="s1">ftype </span><span class="s3">== </span><span class="s4">'notch'</span><span class="s3">:</span>
        <span class="s1">G0</span><span class="s3">, </span><span class="s1">G </span><span class="s3">= </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span>
    <span class="s2">elif </span><span class="s1">ftype </span><span class="s3">== </span><span class="s4">'peak'</span><span class="s3">:</span>
        <span class="s1">G0</span><span class="s3">, </span><span class="s1">G </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span>

    <span class="s6"># Compute beta according to Eq. 11.5.3 (p. 591) from reference [1]. Due to</span>
    <span class="s6"># assuming a -3 dB attenuation value, i.e, assuming GB = 1 / np.sqrt(2),</span>
    <span class="s6"># the following term simplifies to:</span>
    <span class="s6">#   np.sqrt((GB**2 - G0**2) / (G**2 - GB**2)) = 1</span>
    <span class="s1">beta </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">tan</span><span class="s3">(</span><span class="s1">N </span><span class="s3">* </span><span class="s1">w_delta </span><span class="s3">/ </span><span class="s5">4</span><span class="s3">)</span>

    <span class="s6"># Compute filter coefficients</span>
    <span class="s6"># Eq 11.5.1 (p. 590) variables a, b, c from reference [1]</span>
    <span class="s1">ax </span><span class="s3">= (</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">beta</span><span class="s3">) / (</span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">beta</span><span class="s3">)</span>
    <span class="s1">bx </span><span class="s3">= (</span><span class="s1">G0 </span><span class="s3">+ </span><span class="s1">G </span><span class="s3">* </span><span class="s1">beta</span><span class="s3">) / (</span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">beta</span><span class="s3">)</span>
    <span class="s1">cx </span><span class="s3">= (</span><span class="s1">G0 </span><span class="s3">- </span><span class="s1">G </span><span class="s3">* </span><span class="s1">beta</span><span class="s3">) / (</span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">beta</span><span class="s3">)</span>

    <span class="s6"># Last coefficients are negative to get peaking comb that passes zero or</span>
    <span class="s6"># notching comb that doesn't.</span>
    <span class="s1">negative_coef </span><span class="s3">= ((</span><span class="s1">ftype </span><span class="s3">== </span><span class="s4">'peak' </span><span class="s2">and </span><span class="s1">pass_zero</span><span class="s3">) </span><span class="s2">or</span>
                     <span class="s3">(</span><span class="s1">ftype </span><span class="s3">== </span><span class="s4">'notch' </span><span class="s2">and not </span><span class="s1">pass_zero</span><span class="s3">))</span>

    <span class="s6"># Compute numerator coefficients</span>
    <span class="s6"># Eq 11.5.1 (p. 590) or Eq 11.5.4 (p. 591) from reference [1]</span>
    <span class="s6"># b - cz^-N or b + cz^-N</span>
    <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">N </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">b</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">bx</span>
    <span class="s2">if </span><span class="s1">negative_coef</span><span class="s3">:</span>
        <span class="s1">b</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] = -</span><span class="s1">cx</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">b</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] = +</span><span class="s1">cx</span>

    <span class="s6"># Compute denominator coefficients</span>
    <span class="s6"># Eq 11.5.1 (p. 590) or Eq 11.5.4 (p. 591) from reference [1]</span>
    <span class="s6"># 1 - az^-N or 1 + az^-N</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">N </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">a</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s5">1</span>
    <span class="s2">if </span><span class="s1">negative_coef</span><span class="s3">:</span>
        <span class="s1">a</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] = -</span><span class="s1">ax</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">a</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] = +</span><span class="s1">ax</span>

    <span class="s2">return </span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span>


<span class="s2">def </span><span class="s1">_hz_to_erb</span><span class="s3">(</span><span class="s1">hz</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Utility for converting from frequency (Hz) to the 
    Equivalent Rectangular Bandwidth (ERB) scale 
    ERB = frequency / EarQ + minBW 
    &quot;&quot;&quot;</span>
    <span class="s1">EarQ </span><span class="s3">= </span><span class="s5">9.26449</span>
    <span class="s1">minBW </span><span class="s3">= </span><span class="s5">24.7</span>
    <span class="s2">return </span><span class="s1">hz </span><span class="s3">/ </span><span class="s1">EarQ </span><span class="s3">+ </span><span class="s1">minBW</span>


<span class="s2">def </span><span class="s1">gammatone</span><span class="s3">(</span><span class="s1">freq</span><span class="s3">, </span><span class="s1">ftype</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">numtaps</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Gammatone filter design. 
 
    This function computes the coefficients of an FIR or IIR gammatone 
    digital filter [1]_. 
 
    Parameters 
    ---------- 
    freq : float 
        Center frequency of the filter (expressed in the same units 
        as `fs`). 
    ftype : {'fir', 'iir'} 
        The type of filter the function generates. If 'fir', the function 
        will generate an Nth order FIR gammatone filter. If 'iir', the 
        function will generate an 8th order digital IIR filter, modeled as 
        as 4th order gammatone filter. 
    order : int, optional 
        The order of the filter. Only used when ``ftype='fir'``. 
        Default is 4 to model the human auditory system. Must be between 
        0 and 24. 
    numtaps : int, optional 
        Length of the filter. Only used when ``ftype='fir'``. 
        Default is ``fs*0.015`` if `fs` is greater than 1000, 
        15 if `fs` is less than or equal to 1000. 
    fs : float, optional 
        The sampling frequency of the signal. `freq` must be between 
        0 and ``fs/2``. Default is 2. 
 
    Returns 
    ------- 
    b, a : ndarray, ndarray 
        Numerator (``b``) and denominator (``a``) polynomials of the filter. 
 
    Raises 
    ------ 
    ValueError 
        If `freq` is less than or equal to 0 or greater than or equal to 
        ``fs/2``, if `ftype` is not 'fir' or 'iir', if `order` is less than 
        or equal to 0 or greater than 24 when ``ftype='fir'`` 
 
    See Also 
    -------- 
    firwin 
    iirfilter 
 
    References 
    ---------- 
    .. [1] Slaney, Malcolm, &quot;An Efficient Implementation of the 
        Patterson-Holdsworth Auditory Filter Bank&quot;, Apple Computer 
        Technical Report 35, 1993, pp.3-8, 34-39. 
 
    Examples 
    -------- 
    16-sample 4th order FIR Gammatone filter centered at 440 Hz 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; signal.gammatone(440, 'fir', numtaps=16, fs=16000) 
    (array([ 0.00000000e+00,  2.22196719e-07,  1.64942101e-06,  4.99298227e-06, 
        1.01993969e-05,  1.63125770e-05,  2.14648940e-05,  2.29947263e-05, 
        1.76776931e-05,  2.04980537e-06, -2.72062858e-05, -7.28455299e-05, 
       -1.36651076e-04, -2.19066855e-04, -3.18905076e-04, -4.33156712e-04]), 
       [1.0]) 
 
    IIR Gammatone filter centered at 440 Hz 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; b, a = signal.gammatone(440, 'iir', fs=16000) 
    &gt;&gt;&gt; w, h = signal.freqz(b, a) 
    &gt;&gt;&gt; plt.plot(w / ((2 * np.pi) / 16000), 20 * np.log10(abs(h))) 
    &gt;&gt;&gt; plt.xscale('log') 
    &gt;&gt;&gt; plt.title('Gammatone filter frequency response') 
    &gt;&gt;&gt; plt.xlabel('Frequency') 
    &gt;&gt;&gt; plt.ylabel('Amplitude [dB]') 
    &gt;&gt;&gt; plt.margins(0, 0.1) 
    &gt;&gt;&gt; plt.grid(which='both', axis='both') 
    &gt;&gt;&gt; plt.axvline(440, color='green') # cutoff frequency 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s6"># Converts freq to float</span>
    <span class="s1">freq </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">freq</span><span class="s3">)</span>

    <span class="s6"># Set sampling rate if not passed</span>
    <span class="s2">if </span><span class="s1">fs </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">fs </span><span class="s3">= </span><span class="s5">2</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s6"># Check for invalid cutoff frequency or filter type</span>
    <span class="s1">ftype </span><span class="s3">= </span><span class="s1">ftype</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">()</span>
    <span class="s1">filter_types </span><span class="s3">= [</span><span class="s4">'fir'</span><span class="s3">, </span><span class="s4">'iir'</span><span class="s3">]</span>
    <span class="s2">if not </span><span class="s5">0 </span><span class="s3">&lt; </span><span class="s1">freq </span><span class="s3">&lt; </span><span class="s1">fs </span><span class="s3">/ </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;The frequency must be between 0 and </span><span class="s2">{</span><span class="s1">fs </span><span class="s3">/ </span><span class="s5">2</span><span class="s2">}</span><span class="s4">&quot;</span>
                         <span class="s4">f&quot; (nyquist), but given </span><span class="s2">{</span><span class="s1">freq</span><span class="s2">}</span><span class="s4">.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">ftype </span><span class="s2">not in </span><span class="s1">filter_types</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'ftype must be either fir or iir.'</span><span class="s3">)</span>

    <span class="s6"># Calculate FIR gammatone filter</span>
    <span class="s2">if </span><span class="s1">ftype </span><span class="s3">== </span><span class="s4">'fir'</span><span class="s3">:</span>
        <span class="s6"># Set order and numtaps if not passed</span>
        <span class="s2">if </span><span class="s1">order </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">order </span><span class="s3">= </span><span class="s5">4</span>
        <span class="s1">order </span><span class="s3">= </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">order</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">numtaps </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">numtaps </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">fs </span><span class="s3">* </span><span class="s5">0.015</span><span class="s3">), </span><span class="s5">15</span><span class="s3">)</span>
        <span class="s1">numtaps </span><span class="s3">= </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">numtaps</span><span class="s3">)</span>

        <span class="s6"># Check for invalid order</span>
        <span class="s2">if not </span><span class="s5">0 </span><span class="s3">&lt; </span><span class="s1">order </span><span class="s3">&lt;= </span><span class="s5">24</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Invalid order: order must be &gt; 0 and &lt;= 24.&quot;</span><span class="s3">)</span>

        <span class="s6"># Gammatone impulse response settings</span>
        <span class="s1">t </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">numtaps</span><span class="s3">) / </span><span class="s1">fs</span>
        <span class="s1">bw </span><span class="s3">= </span><span class="s5">1.019 </span><span class="s3">* </span><span class="s1">_hz_to_erb</span><span class="s3">(</span><span class="s1">freq</span><span class="s3">)</span>

        <span class="s6"># Calculate the FIR gammatone filter</span>
        <span class="s1">b </span><span class="s3">= (</span><span class="s1">t </span><span class="s3">** (</span><span class="s1">order </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)) * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(-</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">bw </span><span class="s3">* </span><span class="s1">t</span><span class="s3">)</span>
        <span class="s1">b </span><span class="s3">*= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">freq </span><span class="s3">* </span><span class="s1">t</span><span class="s3">)</span>

        <span class="s6"># Scale the FIR filter so the frequency response is 1 at cutoff</span>
        <span class="s1">scale_factor </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* (</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">bw</span><span class="s3">) ** (</span><span class="s1">order</span><span class="s3">)</span>
        <span class="s1">scale_factor </span><span class="s3">/= </span><span class="s1">float_factorial</span><span class="s3">(</span><span class="s1">order </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">scale_factor </span><span class="s3">/= </span><span class="s1">fs</span>
        <span class="s1">b </span><span class="s3">*= </span><span class="s1">scale_factor</span>
        <span class="s1">a </span><span class="s3">= [</span><span class="s5">1.0</span><span class="s3">]</span>

    <span class="s6"># Calculate IIR gammatone filter</span>
    <span class="s2">elif </span><span class="s1">ftype </span><span class="s3">== </span><span class="s4">'iir'</span><span class="s3">:</span>
        <span class="s6"># Raise warning if order and/or numtaps is passed</span>
        <span class="s2">if </span><span class="s1">order </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">'order is not used for IIR gammatone filter.'</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">numtaps </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">'numtaps is not used for IIR gammatone filter.'</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>

        <span class="s6"># Gammatone impulse response settings</span>
        <span class="s1">T </span><span class="s3">= </span><span class="s5">1.</span><span class="s3">/</span><span class="s1">fs</span>
        <span class="s1">bw </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s5">1.019 </span><span class="s3">* </span><span class="s1">_hz_to_erb</span><span class="s3">(</span><span class="s1">freq</span><span class="s3">)</span>
        <span class="s1">fr </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">freq </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">T</span>
        <span class="s1">bwT </span><span class="s3">= </span><span class="s1">bw </span><span class="s3">* </span><span class="s1">T</span>

        <span class="s6"># Calculate the gain to normalize the volume at the center frequency</span>
        <span class="s1">g1 </span><span class="s3">= -</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">2j </span><span class="s3">* </span><span class="s1">fr</span><span class="s3">) * </span><span class="s1">T</span>
        <span class="s1">g2 </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(-(</span><span class="s1">bwT</span><span class="s3">) + </span><span class="s5">1j </span><span class="s3">* </span><span class="s1">fr</span><span class="s3">) * </span><span class="s1">T</span>
        <span class="s1">g3 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s5">3 </span><span class="s3">+ </span><span class="s5">2 </span><span class="s3">** (</span><span class="s5">3 </span><span class="s3">/ </span><span class="s5">2</span><span class="s3">)) * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sin</span><span class="s3">(</span><span class="s1">fr</span><span class="s3">)</span>
        <span class="s1">g4 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s5">3 </span><span class="s3">- </span><span class="s5">2 </span><span class="s3">** (</span><span class="s5">3 </span><span class="s3">/ </span><span class="s5">2</span><span class="s3">)) * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sin</span><span class="s3">(</span><span class="s1">fr</span><span class="s3">)</span>
        <span class="s1">g5 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">2j </span><span class="s3">* </span><span class="s1">fr</span><span class="s3">)</span>

        <span class="s1">g </span><span class="s3">= </span><span class="s1">g1 </span><span class="s3">+ </span><span class="s1">g2 </span><span class="s3">* (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">fr</span><span class="s3">) - </span><span class="s1">g4</span><span class="s3">)</span>
        <span class="s1">g </span><span class="s3">*= (</span><span class="s1">g1 </span><span class="s3">+ </span><span class="s1">g2 </span><span class="s3">* (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">fr</span><span class="s3">) + </span><span class="s1">g4</span><span class="s3">))</span>
        <span class="s1">g </span><span class="s3">*= (</span><span class="s1">g1 </span><span class="s3">+ </span><span class="s1">g2 </span><span class="s3">* (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">fr</span><span class="s3">) - </span><span class="s1">g3</span><span class="s3">))</span>
        <span class="s1">g </span><span class="s3">*= (</span><span class="s1">g1 </span><span class="s3">+ </span><span class="s1">g2 </span><span class="s3">* (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">fr</span><span class="s3">) + </span><span class="s1">g3</span><span class="s3">))</span>
        <span class="s1">g </span><span class="s3">/= ((-</span><span class="s5">2 </span><span class="s3">/ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">bwT</span><span class="s3">) - </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">g5 </span><span class="s3">+ </span><span class="s5">2 </span><span class="s3">* (</span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">g5</span><span class="s3">) / </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">bwT</span><span class="s3">)) ** </span><span class="s5">4</span><span class="s3">)</span>
        <span class="s1">g </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">g</span><span class="s3">)</span>

        <span class="s6"># Create empty filter coefficient lists</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s5">5</span><span class="s3">)</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s5">9</span><span class="s3">)</span>

        <span class="s6"># Calculate the numerator coefficients</span>
        <span class="s1">b</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = (</span><span class="s1">T </span><span class="s3">** </span><span class="s5">4</span><span class="s3">) / </span><span class="s1">g</span>
        <span class="s1">b</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = -</span><span class="s5">4 </span><span class="s3">* </span><span class="s1">T </span><span class="s3">** </span><span class="s5">4 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">fr</span><span class="s3">) / </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">bw </span><span class="s3">* </span><span class="s1">T</span><span class="s3">) / </span><span class="s1">g</span>
        <span class="s1">b</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = </span><span class="s5">6 </span><span class="s3">* </span><span class="s1">T </span><span class="s3">** </span><span class="s5">4 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">fr</span><span class="s3">) / </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">bw </span><span class="s3">* </span><span class="s1">T</span><span class="s3">) / </span><span class="s1">g</span>
        <span class="s1">b</span><span class="s3">[</span><span class="s5">3</span><span class="s3">] = -</span><span class="s5">4 </span><span class="s3">* </span><span class="s1">T </span><span class="s3">** </span><span class="s5">4 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s5">3 </span><span class="s3">* </span><span class="s1">fr</span><span class="s3">) / </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">3 </span><span class="s3">* </span><span class="s1">bw </span><span class="s3">* </span><span class="s1">T</span><span class="s3">) / </span><span class="s1">g</span>
        <span class="s1">b</span><span class="s3">[</span><span class="s5">4</span><span class="s3">] = </span><span class="s1">T </span><span class="s3">** </span><span class="s5">4 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s5">4 </span><span class="s3">* </span><span class="s1">fr</span><span class="s3">) / </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">4 </span><span class="s3">* </span><span class="s1">bw </span><span class="s3">* </span><span class="s1">T</span><span class="s3">) / </span><span class="s1">g</span>

        <span class="s6"># Calculate the denominator coefficients</span>
        <span class="s1">a</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s5">1</span>
        <span class="s1">a</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = -</span><span class="s5">8 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">fr</span><span class="s3">) / </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">bw </span><span class="s3">* </span><span class="s1">T</span><span class="s3">)</span>
        <span class="s1">a</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = </span><span class="s5">4 </span><span class="s3">* (</span><span class="s5">4 </span><span class="s3">+ </span><span class="s5">3 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">fr</span><span class="s3">)) / </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">bw </span><span class="s3">* </span><span class="s1">T</span><span class="s3">)</span>
        <span class="s1">a</span><span class="s3">[</span><span class="s5">3</span><span class="s3">] = -</span><span class="s5">8 </span><span class="s3">* (</span><span class="s5">6 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">fr</span><span class="s3">) + </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s5">3 </span><span class="s3">* </span><span class="s1">fr</span><span class="s3">))</span>
        <span class="s1">a</span><span class="s3">[</span><span class="s5">3</span><span class="s3">] /= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">3 </span><span class="s3">* </span><span class="s1">bw </span><span class="s3">* </span><span class="s1">T</span><span class="s3">)</span>
        <span class="s1">a</span><span class="s3">[</span><span class="s5">4</span><span class="s3">] = </span><span class="s5">2 </span><span class="s3">* (</span><span class="s5">18 </span><span class="s3">+ </span><span class="s5">16 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">fr</span><span class="s3">) + </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s5">4 </span><span class="s3">* </span><span class="s1">fr</span><span class="s3">))</span>
        <span class="s1">a</span><span class="s3">[</span><span class="s5">4</span><span class="s3">] /= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">4 </span><span class="s3">* </span><span class="s1">bw </span><span class="s3">* </span><span class="s1">T</span><span class="s3">)</span>
        <span class="s1">a</span><span class="s3">[</span><span class="s5">5</span><span class="s3">] = -</span><span class="s5">8 </span><span class="s3">* (</span><span class="s5">6 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">fr</span><span class="s3">) + </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s5">3 </span><span class="s3">* </span><span class="s1">fr</span><span class="s3">))</span>
        <span class="s1">a</span><span class="s3">[</span><span class="s5">5</span><span class="s3">] /= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">5 </span><span class="s3">* </span><span class="s1">bw </span><span class="s3">* </span><span class="s1">T</span><span class="s3">)</span>
        <span class="s1">a</span><span class="s3">[</span><span class="s5">6</span><span class="s3">] = </span><span class="s5">4 </span><span class="s3">* (</span><span class="s5">4 </span><span class="s3">+ </span><span class="s5">3 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">fr</span><span class="s3">)) / </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">6 </span><span class="s3">* </span><span class="s1">bw </span><span class="s3">* </span><span class="s1">T</span><span class="s3">)</span>
        <span class="s1">a</span><span class="s3">[</span><span class="s5">7</span><span class="s3">] = -</span><span class="s5">8 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">fr</span><span class="s3">) / </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">7 </span><span class="s3">* </span><span class="s1">bw </span><span class="s3">* </span><span class="s1">T</span><span class="s3">)</span>
        <span class="s1">a</span><span class="s3">[</span><span class="s5">8</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(-</span><span class="s5">8 </span><span class="s3">* </span><span class="s1">bw </span><span class="s3">* </span><span class="s1">T</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span>


<span class="s1">filter_dict </span><span class="s3">= {</span><span class="s4">'butter'</span><span class="s3">: [</span><span class="s1">buttap</span><span class="s3">, </span><span class="s1">buttord</span><span class="s3">],</span>
               <span class="s4">'butterworth'</span><span class="s3">: [</span><span class="s1">buttap</span><span class="s3">, </span><span class="s1">buttord</span><span class="s3">],</span>

               <span class="s4">'cauer'</span><span class="s3">: [</span><span class="s1">ellipap</span><span class="s3">, </span><span class="s1">ellipord</span><span class="s3">],</span>
               <span class="s4">'elliptic'</span><span class="s3">: [</span><span class="s1">ellipap</span><span class="s3">, </span><span class="s1">ellipord</span><span class="s3">],</span>
               <span class="s4">'ellip'</span><span class="s3">: [</span><span class="s1">ellipap</span><span class="s3">, </span><span class="s1">ellipord</span><span class="s3">],</span>

               <span class="s4">'bessel'</span><span class="s3">: [</span><span class="s1">besselap</span><span class="s3">],</span>
               <span class="s4">'bessel_phase'</span><span class="s3">: [</span><span class="s1">besselap</span><span class="s3">],</span>
               <span class="s4">'bessel_delay'</span><span class="s3">: [</span><span class="s1">besselap</span><span class="s3">],</span>
               <span class="s4">'bessel_mag'</span><span class="s3">: [</span><span class="s1">besselap</span><span class="s3">],</span>

               <span class="s4">'cheby1'</span><span class="s3">: [</span><span class="s1">cheb1ap</span><span class="s3">, </span><span class="s1">cheb1ord</span><span class="s3">],</span>
               <span class="s4">'chebyshev1'</span><span class="s3">: [</span><span class="s1">cheb1ap</span><span class="s3">, </span><span class="s1">cheb1ord</span><span class="s3">],</span>
               <span class="s4">'chebyshevi'</span><span class="s3">: [</span><span class="s1">cheb1ap</span><span class="s3">, </span><span class="s1">cheb1ord</span><span class="s3">],</span>

               <span class="s4">'cheby2'</span><span class="s3">: [</span><span class="s1">cheb2ap</span><span class="s3">, </span><span class="s1">cheb2ord</span><span class="s3">],</span>
               <span class="s4">'chebyshev2'</span><span class="s3">: [</span><span class="s1">cheb2ap</span><span class="s3">, </span><span class="s1">cheb2ord</span><span class="s3">],</span>
               <span class="s4">'chebyshevii'</span><span class="s3">: [</span><span class="s1">cheb2ap</span><span class="s3">, </span><span class="s1">cheb2ord</span><span class="s3">],</span>
               <span class="s3">}</span>

<span class="s1">band_dict </span><span class="s3">= {</span><span class="s4">'band'</span><span class="s3">: </span><span class="s4">'bandpass'</span><span class="s3">,</span>
             <span class="s4">'bandpass'</span><span class="s3">: </span><span class="s4">'bandpass'</span><span class="s3">,</span>
             <span class="s4">'pass'</span><span class="s3">: </span><span class="s4">'bandpass'</span><span class="s3">,</span>
             <span class="s4">'bp'</span><span class="s3">: </span><span class="s4">'bandpass'</span><span class="s3">,</span>

             <span class="s4">'bs'</span><span class="s3">: </span><span class="s4">'bandstop'</span><span class="s3">,</span>
             <span class="s4">'bandstop'</span><span class="s3">: </span><span class="s4">'bandstop'</span><span class="s3">,</span>
             <span class="s4">'bands'</span><span class="s3">: </span><span class="s4">'bandstop'</span><span class="s3">,</span>
             <span class="s4">'stop'</span><span class="s3">: </span><span class="s4">'bandstop'</span><span class="s3">,</span>

             <span class="s4">'l'</span><span class="s3">: </span><span class="s4">'lowpass'</span><span class="s3">,</span>
             <span class="s4">'low'</span><span class="s3">: </span><span class="s4">'lowpass'</span><span class="s3">,</span>
             <span class="s4">'lowpass'</span><span class="s3">: </span><span class="s4">'lowpass'</span><span class="s3">,</span>
             <span class="s4">'lp'</span><span class="s3">: </span><span class="s4">'lowpass'</span><span class="s3">,</span>

             <span class="s4">'high'</span><span class="s3">: </span><span class="s4">'highpass'</span><span class="s3">,</span>
             <span class="s4">'highpass'</span><span class="s3">: </span><span class="s4">'highpass'</span><span class="s3">,</span>
             <span class="s4">'h'</span><span class="s3">: </span><span class="s4">'highpass'</span><span class="s3">,</span>
             <span class="s4">'hp'</span><span class="s3">: </span><span class="s4">'highpass'</span><span class="s3">,</span>
             <span class="s3">}</span>

<span class="s1">bessel_norms </span><span class="s3">= {</span><span class="s4">'bessel'</span><span class="s3">: </span><span class="s4">'phase'</span><span class="s3">,</span>
                <span class="s4">'bessel_phase'</span><span class="s3">: </span><span class="s4">'phase'</span><span class="s3">,</span>
                <span class="s4">'bessel_delay'</span><span class="s3">: </span><span class="s4">'delay'</span><span class="s3">,</span>
                <span class="s4">'bessel_mag'</span><span class="s3">: </span><span class="s4">'mag'</span><span class="s3">}</span>
</pre>
</body>
</html>