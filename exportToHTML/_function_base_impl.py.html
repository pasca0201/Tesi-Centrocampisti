<html>
<head>
<title>_function_base_impl.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_function_base_impl.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">builtins</span>
<span class="s0">import </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span>
<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">numeric </span><span class="s0">as </span><span class="s1">_nx</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core </span><span class="s0">import </span><span class="s1">transpose</span><span class="s2">, </span><span class="s1">overrides</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">numeric </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">ones</span><span class="s2">, </span><span class="s1">zeros_like</span><span class="s2">, </span><span class="s1">arange</span><span class="s2">, </span><span class="s1">concatenate</span><span class="s2">, </span><span class="s1">array</span><span class="s2">, </span><span class="s1">asarray</span><span class="s2">, </span><span class="s1">asanyarray</span><span class="s2">, </span><span class="s1">empty</span><span class="s2">,</span>
    <span class="s1">ndarray</span><span class="s2">, </span><span class="s1">take</span><span class="s2">, </span><span class="s1">dot</span><span class="s2">, </span><span class="s1">where</span><span class="s2">, </span><span class="s1">intp</span><span class="s2">, </span><span class="s1">integer</span><span class="s2">, </span><span class="s1">isscalar</span><span class="s2">, </span><span class="s1">absolute</span>
    <span class="s2">)</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">umath </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">pi</span><span class="s2">, </span><span class="s1">add</span><span class="s2">, </span><span class="s1">arctan2</span><span class="s2">, </span><span class="s1">frompyfunc</span><span class="s2">, </span><span class="s1">cos</span><span class="s2">, </span><span class="s1">less_equal</span><span class="s2">, </span><span class="s1">sqrt</span><span class="s2">, </span><span class="s1">sin</span><span class="s2">,</span>
    <span class="s1">mod</span><span class="s2">, </span><span class="s1">exp</span><span class="s2">, </span><span class="s1">not_equal</span><span class="s2">, </span><span class="s1">subtract</span><span class="s2">, </span><span class="s1">minimum</span>
    <span class="s2">)</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">fromnumeric </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">ravel</span><span class="s2">, </span><span class="s1">nonzero</span><span class="s2">, </span><span class="s1">partition</span><span class="s2">, </span><span class="s1">mean</span><span class="s2">, </span><span class="s1">any</span><span class="s2">, </span><span class="s1">sum</span>
    <span class="s2">)</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">numerictypes </span><span class="s0">import </span><span class="s1">typecodes</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">_twodim_base_impl </span><span class="s0">import </span><span class="s1">diag</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">multiarray </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">_place</span><span class="s2">, </span><span class="s1">bincount</span><span class="s2">, </span><span class="s1">normalize_axis_index</span><span class="s2">, </span><span class="s1">_monotonicity</span><span class="s2">,</span>
    <span class="s1">interp </span><span class="s0">as </span><span class="s1">compiled_interp</span><span class="s2">, </span><span class="s1">interp_complex </span><span class="s0">as </span><span class="s1">compiled_interp_complex</span>
    <span class="s2">)</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">_multiarray_umath </span><span class="s0">import </span><span class="s1">_array_converter</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_utils </span><span class="s0">import </span><span class="s1">set_module</span>

<span class="s3"># needed in this module for compatibility</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">_histograms_impl </span><span class="s0">import </span><span class="s1">histogram</span><span class="s2">, </span><span class="s1">histogramdd  </span><span class="s3"># noqa: F401</span>


<span class="s1">array_function_dispatch </span><span class="s2">= </span><span class="s1">functools</span><span class="s2">.</span><span class="s1">partial</span><span class="s2">(</span>
    <span class="s1">overrides</span><span class="s2">.</span><span class="s1">array_function_dispatch</span><span class="s2">, </span><span class="s1">module</span><span class="s2">=</span><span class="s4">'numpy'</span><span class="s2">)</span>


<span class="s1">__all__ </span><span class="s2">= [</span>
    <span class="s4">'select'</span><span class="s2">, </span><span class="s4">'piecewise'</span><span class="s2">, </span><span class="s4">'trim_zeros'</span><span class="s2">, </span><span class="s4">'copy'</span><span class="s2">, </span><span class="s4">'iterable'</span><span class="s2">, </span><span class="s4">'percentile'</span><span class="s2">,</span>
    <span class="s4">'diff'</span><span class="s2">, </span><span class="s4">'gradient'</span><span class="s2">, </span><span class="s4">'angle'</span><span class="s2">, </span><span class="s4">'unwrap'</span><span class="s2">, </span><span class="s4">'sort_complex'</span><span class="s2">, </span><span class="s4">'flip'</span><span class="s2">,</span>
    <span class="s4">'rot90'</span><span class="s2">, </span><span class="s4">'extract'</span><span class="s2">, </span><span class="s4">'place'</span><span class="s2">, </span><span class="s4">'vectorize'</span><span class="s2">, </span><span class="s4">'asarray_chkfinite'</span><span class="s2">, </span><span class="s4">'average'</span><span class="s2">,</span>
    <span class="s4">'bincount'</span><span class="s2">, </span><span class="s4">'digitize'</span><span class="s2">, </span><span class="s4">'cov'</span><span class="s2">, </span><span class="s4">'corrcoef'</span><span class="s2">,</span>
    <span class="s4">'median'</span><span class="s2">, </span><span class="s4">'sinc'</span><span class="s2">, </span><span class="s4">'hamming'</span><span class="s2">, </span><span class="s4">'hanning'</span><span class="s2">, </span><span class="s4">'bartlett'</span><span class="s2">,</span>
    <span class="s4">'blackman'</span><span class="s2">, </span><span class="s4">'kaiser'</span><span class="s2">, </span><span class="s4">'trapezoid'</span><span class="s2">, </span><span class="s4">'trapz'</span><span class="s2">, </span><span class="s4">'i0'</span><span class="s2">,</span>
    <span class="s4">'meshgrid'</span><span class="s2">, </span><span class="s4">'delete'</span><span class="s2">, </span><span class="s4">'insert'</span><span class="s2">, </span><span class="s4">'append'</span><span class="s2">, </span><span class="s4">'interp'</span><span class="s2">,</span>
    <span class="s4">'quantile'</span>
    <span class="s2">]</span>

<span class="s3"># _QuantileMethods is a dictionary listing all the supported methods to</span>
<span class="s3"># compute quantile/percentile.</span>
<span class="s3">#</span>
<span class="s3"># Below virtual_index refers to the index of the element where the percentile</span>
<span class="s3"># would be found in the sorted sample.</span>
<span class="s3"># When the sample contains exactly the percentile wanted, the virtual_index is</span>
<span class="s3"># an integer to the index of this element.</span>
<span class="s3"># When the percentile wanted is in between two elements, the virtual_index</span>
<span class="s3"># is made of a integer part (a.k.a 'i' or 'left') and a fractional part</span>
<span class="s3"># (a.k.a 'g' or 'gamma')</span>
<span class="s3">#</span>
<span class="s3"># Each method in _QuantileMethods has two properties</span>
<span class="s3"># get_virtual_index : Callable</span>
<span class="s3">#   The function used to compute the virtual_index.</span>
<span class="s3"># fix_gamma : Callable</span>
<span class="s3">#   A function used for discret methods to force the index to a specific value.</span>
<span class="s1">_QuantileMethods </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span>
    <span class="s3"># --- HYNDMAN and FAN METHODS</span>
    <span class="s3"># Discrete methods</span>
    <span class="s1">inverted_cdf</span><span class="s2">=</span><span class="s1">dict</span><span class="s2">(</span>
        <span class="s1">get_virtual_index</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">: </span><span class="s1">_inverted_cdf</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">),</span>
        <span class="s1">fix_gamma</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,  </span><span class="s3"># should never be called</span>
    <span class="s2">),</span>
    <span class="s1">averaged_inverted_cdf</span><span class="s2">=</span><span class="s1">dict</span><span class="s2">(</span>
        <span class="s1">get_virtual_index</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">: (</span><span class="s1">n </span><span class="s2">* </span><span class="s1">quantiles</span><span class="s2">) - </span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">fix_gamma</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">_</span><span class="s2">: </span><span class="s1">_get_gamma_mask</span><span class="s2">(</span>
            <span class="s1">shape</span><span class="s2">=</span><span class="s1">gamma</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">,</span>
            <span class="s1">default_value</span><span class="s2">=</span><span class="s5">1.</span><span class="s2">,</span>
            <span class="s1">conditioned_value</span><span class="s2">=</span><span class="s5">0.5</span><span class="s2">,</span>
            <span class="s1">where</span><span class="s2">=</span><span class="s1">gamma </span><span class="s2">== </span><span class="s5">0</span><span class="s2">),</span>
    <span class="s2">),</span>
    <span class="s1">closest_observation</span><span class="s2">=</span><span class="s1">dict</span><span class="s2">(</span>
        <span class="s1">get_virtual_index</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">: </span><span class="s1">_closest_observation</span><span class="s2">(</span><span class="s1">n</span><span class="s2">,</span>
                                                                    <span class="s1">quantiles</span><span class="s2">),</span>
        <span class="s1">fix_gamma</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,  </span><span class="s3"># should never be called</span>
    <span class="s2">),</span>
    <span class="s3"># Continuous methods</span>
    <span class="s1">interpolated_inverted_cdf</span><span class="s2">=</span><span class="s1">dict</span><span class="s2">(</span>
        <span class="s1">get_virtual_index</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">:</span>
        <span class="s1">_compute_virtual_index</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">),</span>
        <span class="s1">fix_gamma</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">_</span><span class="s2">: </span><span class="s1">gamma</span><span class="s2">,</span>
    <span class="s2">),</span>
    <span class="s1">hazen</span><span class="s2">=</span><span class="s1">dict</span><span class="s2">(</span>
        <span class="s1">get_virtual_index</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">:</span>
        <span class="s1">_compute_virtual_index</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">),</span>
        <span class="s1">fix_gamma</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">_</span><span class="s2">: </span><span class="s1">gamma</span><span class="s2">,</span>
    <span class="s2">),</span>
    <span class="s1">weibull</span><span class="s2">=</span><span class="s1">dict</span><span class="s2">(</span>
        <span class="s1">get_virtual_index</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">:</span>
        <span class="s1">_compute_virtual_index</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">),</span>
        <span class="s1">fix_gamma</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">_</span><span class="s2">: </span><span class="s1">gamma</span><span class="s2">,</span>
    <span class="s2">),</span>
    <span class="s3"># Default method.</span>
    <span class="s3"># To avoid some rounding issues, `(n-1) * quantiles` is preferred to</span>
    <span class="s3"># `_compute_virtual_index(n, quantiles, 1, 1)`.</span>
    <span class="s3"># They are mathematically equivalent.</span>
    <span class="s1">linear</span><span class="s2">=</span><span class="s1">dict</span><span class="s2">(</span>
        <span class="s1">get_virtual_index</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">: (</span><span class="s1">n </span><span class="s2">- </span><span class="s5">1</span><span class="s2">) * </span><span class="s1">quantiles</span><span class="s2">,</span>
        <span class="s1">fix_gamma</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">_</span><span class="s2">: </span><span class="s1">gamma</span><span class="s2">,</span>
    <span class="s2">),</span>
    <span class="s1">median_unbiased</span><span class="s2">=</span><span class="s1">dict</span><span class="s2">(</span>
        <span class="s1">get_virtual_index</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">:</span>
        <span class="s1">_compute_virtual_index</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">, </span><span class="s5">1 </span><span class="s2">/ </span><span class="s5">3.0</span><span class="s2">, </span><span class="s5">1 </span><span class="s2">/ </span><span class="s5">3.0</span><span class="s2">),</span>
        <span class="s1">fix_gamma</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">_</span><span class="s2">: </span><span class="s1">gamma</span><span class="s2">,</span>
    <span class="s2">),</span>
    <span class="s1">normal_unbiased</span><span class="s2">=</span><span class="s1">dict</span><span class="s2">(</span>
        <span class="s1">get_virtual_index</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">:</span>
        <span class="s1">_compute_virtual_index</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">, </span><span class="s5">3 </span><span class="s2">/ </span><span class="s5">8.0</span><span class="s2">, </span><span class="s5">3 </span><span class="s2">/ </span><span class="s5">8.0</span><span class="s2">),</span>
        <span class="s1">fix_gamma</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">_</span><span class="s2">: </span><span class="s1">gamma</span><span class="s2">,</span>
    <span class="s2">),</span>
    <span class="s3"># --- OTHER METHODS</span>
    <span class="s1">lower</span><span class="s2">=</span><span class="s1">dict</span><span class="s2">(</span>
        <span class="s1">get_virtual_index</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">floor</span><span class="s2">(</span>
            <span class="s2">(</span><span class="s1">n </span><span class="s2">- </span><span class="s5">1</span><span class="s2">) * </span><span class="s1">quantiles</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
        <span class="s1">fix_gamma</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,  </span><span class="s3"># should never be called, index dtype is int</span>
    <span class="s2">),</span>
    <span class="s1">higher</span><span class="s2">=</span><span class="s1">dict</span><span class="s2">(</span>
        <span class="s1">get_virtual_index</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ceil</span><span class="s2">(</span>
            <span class="s2">(</span><span class="s1">n </span><span class="s2">- </span><span class="s5">1</span><span class="s2">) * </span><span class="s1">quantiles</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
        <span class="s1">fix_gamma</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,  </span><span class="s3"># should never be called, index dtype is int</span>
    <span class="s2">),</span>
    <span class="s1">midpoint</span><span class="s2">=</span><span class="s1">dict</span><span class="s2">(</span>
        <span class="s1">get_virtual_index</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">: </span><span class="s5">0.5 </span><span class="s2">* (</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">floor</span><span class="s2">((</span><span class="s1">n </span><span class="s2">- </span><span class="s5">1</span><span class="s2">) * </span><span class="s1">quantiles</span><span class="s2">)</span>
                <span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ceil</span><span class="s2">((</span><span class="s1">n </span><span class="s2">- </span><span class="s5">1</span><span class="s2">) * </span><span class="s1">quantiles</span><span class="s2">)),</span>
        <span class="s1">fix_gamma</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">index</span><span class="s2">: </span><span class="s1">_get_gamma_mask</span><span class="s2">(</span>
            <span class="s1">shape</span><span class="s2">=</span><span class="s1">gamma</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">,</span>
            <span class="s1">default_value</span><span class="s2">=</span><span class="s5">0.5</span><span class="s2">,</span>
            <span class="s1">conditioned_value</span><span class="s2">=</span><span class="s5">0.</span><span class="s2">,</span>
            <span class="s1">where</span><span class="s2">=</span><span class="s1">index </span><span class="s2">% </span><span class="s5">1 </span><span class="s2">== </span><span class="s5">0</span><span class="s2">),</span>
    <span class="s2">),</span>
    <span class="s1">nearest</span><span class="s2">=</span><span class="s1">dict</span><span class="s2">(</span>
        <span class="s1">get_virtual_index</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">around</span><span class="s2">(</span>
            <span class="s2">(</span><span class="s1">n </span><span class="s2">- </span><span class="s5">1</span><span class="s2">) * </span><span class="s1">quantiles</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">),</span>
        <span class="s1">fix_gamma</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s3"># should never be called, index dtype is int</span>
    <span class="s2">))</span>


<span class="s0">def </span><span class="s1">_rot90_dispatcher</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">m</span><span class="s2">,)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_rot90_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">rot90</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">)):</span>
    <span class="s6">&quot;&quot;&quot; 
    Rotate an array by 90 degrees in the plane specified by axes. 
 
    Rotation direction is from the first towards the second axis. 
    This means for a 2D array with the default `k` and `axes`, the 
    rotation will be counterclockwise. 
 
    Parameters 
    ---------- 
    m : array_like 
        Array of two or more dimensions. 
    k : integer 
        Number of times the array is rotated by 90 degrees. 
    axes : (2,) array_like 
        The array is rotated in the plane defined by the axes. 
        Axes must be different. 
 
        .. versionadded:: 1.12.0 
 
    Returns 
    ------- 
    y : ndarray 
        A rotated view of `m`. 
 
    See Also 
    -------- 
    flip : Reverse the order of elements in an array along the given axis. 
    fliplr : Flip an array horizontally. 
    flipud : Flip an array vertically. 
 
    Notes 
    ----- 
    ``rot90(m, k=1, axes=(1,0))``  is the reverse of 
    ``rot90(m, k=1, axes=(0,1))`` 
 
    ``rot90(m, k=1, axes=(1,0))`` is equivalent to 
    ``rot90(m, k=-1, axes=(0,1))`` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; m = np.array([[1,2],[3,4]], int) 
    &gt;&gt;&gt; m 
    array([[1, 2], 
           [3, 4]]) 
    &gt;&gt;&gt; np.rot90(m) 
    array([[2, 4], 
           [1, 3]]) 
    &gt;&gt;&gt; np.rot90(m, 2) 
    array([[4, 3], 
           [2, 1]]) 
    &gt;&gt;&gt; m = np.arange(8).reshape((2,2,2)) 
    &gt;&gt;&gt; np.rot90(m, 1, (1,2)) 
    array([[[1, 3], 
            [0, 2]], 
           [[5, 7], 
            [4, 6]]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">axes </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">axes</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">axes</span><span class="s2">) != </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;len(axes) must be 2.&quot;</span><span class="s2">)</span>

    <span class="s1">m </span><span class="s2">= </span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">m</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] == </span><span class="s1">axes</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] </span><span class="s0">or </span><span class="s1">absolute</span><span class="s2">(</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] - </span><span class="s1">axes</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]) == </span><span class="s1">m</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Axes must be different.&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s2">(</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] &gt;= </span><span class="s1">m</span><span class="s2">.</span><span class="s1">ndim </span><span class="s0">or </span><span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] &lt; -</span><span class="s1">m</span><span class="s2">.</span><span class="s1">ndim</span>
        <span class="s0">or </span><span class="s1">axes</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] &gt;= </span><span class="s1">m</span><span class="s2">.</span><span class="s1">ndim </span><span class="s0">or </span><span class="s1">axes</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] &lt; -</span><span class="s1">m</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Axes={} out of range for array of ndim={}.&quot;</span>
            <span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">axes</span><span class="s2">, </span><span class="s1">m</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">))</span>

    <span class="s1">k </span><span class="s2">%= </span><span class="s5">4</span>

    <span class="s0">if </span><span class="s1">k </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">m</span><span class="s2">[:]</span>
    <span class="s0">if </span><span class="s1">k </span><span class="s2">== </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">flip</span><span class="s2">(</span><span class="s1">flip</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]), </span><span class="s1">axes</span><span class="s2">[</span><span class="s5">1</span><span class="s2">])</span>

    <span class="s1">axes_list </span><span class="s2">= </span><span class="s1">arange</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">m</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>
    <span class="s2">(</span><span class="s1">axes_list</span><span class="s2">[</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]], </span><span class="s1">axes_list</span><span class="s2">[</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]]) = (</span><span class="s1">axes_list</span><span class="s2">[</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]],</span>
                                                <span class="s1">axes_list</span><span class="s2">[</span><span class="s1">axes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]])</span>

    <span class="s0">if </span><span class="s1">k </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">transpose</span><span class="s2">(</span><span class="s1">flip</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]), </span><span class="s1">axes_list</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s3"># k == 3</span>
        <span class="s0">return </span><span class="s1">flip</span><span class="s2">(</span><span class="s1">transpose</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">axes_list</span><span class="s2">), </span><span class="s1">axes</span><span class="s2">[</span><span class="s5">1</span><span class="s2">])</span>


<span class="s0">def </span><span class="s1">_flip_dispatcher</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">m</span><span class="s2">,)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_flip_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">flip</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Reverse the order of elements in an array along the given axis. 
 
    The shape of the array is preserved, but the elements are reordered. 
 
    .. versionadded:: 1.12.0 
 
    Parameters 
    ---------- 
    m : array_like 
        Input array. 
    axis : None or int or tuple of ints, optional 
         Axis or axes along which to flip over. The default, 
         axis=None, will flip over all of the axes of the input array. 
         If axis is negative it counts from the last to the first axis. 
 
         If axis is a tuple of ints, flipping is performed on all of the axes 
         specified in the tuple. 
 
         .. versionchanged:: 1.15.0 
            None and tuples of axes are supported 
 
    Returns 
    ------- 
    out : array_like 
        A view of `m` with the entries of axis reversed.  Since a view is 
        returned, this operation is done in constant time. 
 
    See Also 
    -------- 
    flipud : Flip an array vertically (axis=0). 
    fliplr : Flip an array horizontally (axis=1). 
 
    Notes 
    ----- 
    flip(m, 0) is equivalent to flipud(m). 
 
    flip(m, 1) is equivalent to fliplr(m). 
 
    flip(m, n) corresponds to ``m[...,::-1,...]`` with ``::-1`` at position n. 
 
    flip(m) corresponds to ``m[::-1,::-1,...,::-1]`` with ``::-1`` at all 
    positions. 
 
    flip(m, (0, 1)) corresponds to ``m[::-1,::-1,...]`` with ``::-1`` at 
    position 0 and position 1. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; A = np.arange(8).reshape((2,2,2)) 
    &gt;&gt;&gt; A 
    array([[[0, 1], 
            [2, 3]], 
           [[4, 5], 
            [6, 7]]]) 
    &gt;&gt;&gt; np.flip(A, 0) 
    array([[[4, 5], 
            [6, 7]], 
           [[0, 1], 
            [2, 3]]]) 
    &gt;&gt;&gt; np.flip(A, 1) 
    array([[[2, 3], 
            [0, 1]], 
           [[6, 7], 
            [4, 5]]]) 
    &gt;&gt;&gt; np.flip(A) 
    array([[[7, 6], 
            [5, 4]], 
           [[3, 2], 
            [1, 0]]]) 
    &gt;&gt;&gt; np.flip(A, (0, 2)) 
    array([[[5, 4], 
            [7, 6]], 
           [[1, 0], 
            [3, 2]]]) 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; A = rng.normal(size=(3,4,5)) 
    &gt;&gt;&gt; np.all(np.flip(A,2) == A[:,:,::-1,...]) 
    True 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s4">'ndim'</span><span class="s2">):</span>
        <span class="s1">m </span><span class="s2">= </span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">m</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">indexer </span><span class="s2">= (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">s_</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">],) * </span><span class="s1">m</span><span class="s2">.</span><span class="s1">ndim</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">axis </span><span class="s2">= </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">normalize_axis_tuple</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">m</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>
        <span class="s1">indexer </span><span class="s2">= [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">s_</span><span class="s2">[:]] * </span><span class="s1">m</span><span class="s2">.</span><span class="s1">ndim</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axis</span><span class="s2">:</span>
            <span class="s1">indexer</span><span class="s2">[</span><span class="s1">ax</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">s_</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s1">indexer </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">m</span><span class="s2">[</span><span class="s1">indexer</span><span class="s2">]</span>


<span class="s2">@</span><span class="s1">set_module</span><span class="s2">(</span><span class="s4">'numpy'</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">iterable</span><span class="s2">(</span><span class="s1">y</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Check whether or not an object can be iterated over. 
 
    Parameters 
    ---------- 
    y : object 
      Input object. 
 
    Returns 
    ------- 
    b : bool 
      Return ``True`` if the object has an iterator method or is a 
      sequence and ``False`` otherwise. 
 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; np.iterable([1, 2, 3]) 
    True 
    &gt;&gt;&gt; np.iterable(2) 
    False 
 
    Notes 
    ----- 
    In most cases, the results of ``np.iterable(obj)`` are consistent with 
    ``isinstance(obj, collections.abc.Iterable)``. One notable exception is 
    the treatment of 0-dimensional arrays:: 
 
        &gt;&gt;&gt; from collections.abc import Iterable 
        &gt;&gt;&gt; a = np.array(1.0)  # 0-dimensional numpy array 
        &gt;&gt;&gt; isinstance(a, Iterable) 
        True 
        &gt;&gt;&gt; np.iterable(a) 
        False 
 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">iter</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
        <span class="s0">return False</span>
    <span class="s0">return True</span>


<span class="s0">def </span><span class="s1">_weights_are_valid</span><span class="s2">(</span><span class="s1">weights</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Validate weights array. 
     
    We assume, weights is not None. 
    &quot;&quot;&quot;</span>
    <span class="s1">wgt </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">weights</span><span class="s2">)</span>

    <span class="s3"># Sanity checks</span>
    <span class="s0">if </span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">wgt</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s4">&quot;Axis must be specified when shapes of a and weights &quot;</span>
                <span class="s4">&quot;differ.&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">wgt</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">ax</span><span class="s2">] </span><span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axis</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">&quot;Shape of weights must be consistent with &quot;</span>
                <span class="s4">&quot;shape of a along specified axis.&quot;</span><span class="s2">)</span>

        <span class="s3"># setup wgt to broadcast along axis</span>
        <span class="s1">wgt </span><span class="s2">= </span><span class="s1">wgt</span><span class="s2">.</span><span class="s1">transpose</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">argsort</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">))</span>
        <span class="s1">wgt </span><span class="s2">= </span><span class="s1">wgt</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">tuple</span><span class="s2">((</span><span class="s1">s </span><span class="s0">if </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axis </span><span class="s0">else </span><span class="s5">1</span><span class="s2">)</span>
                                <span class="s0">for </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">s </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)))</span>
    <span class="s0">return </span><span class="s1">wgt</span>


<span class="s0">def </span><span class="s1">_average_dispatcher</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">weights</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">returned</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *,</span>
                        <span class="s1">keepdims</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">weights</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_average_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">average</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">weights</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">returned</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, *,</span>
            <span class="s1">keepdims</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">_NoValue</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Compute the weighted average along the specified axis. 
 
    Parameters 
    ---------- 
    a : array_like 
        Array containing data to be averaged. If `a` is not an array, a 
        conversion is attempted. 
    axis : None or int or tuple of ints, optional 
        Axis or axes along which to average `a`.  The default, 
        `axis=None`, will average over all of the elements of the input array. 
        If axis is negative it counts from the last to the first axis. 
 
        .. versionadded:: 1.7.0 
 
        If axis is a tuple of ints, averaging is performed on all of the axes 
        specified in the tuple instead of a single axis or all the axes as 
        before. 
    weights : array_like, optional 
        An array of weights associated with the values in `a`. Each value in 
        `a` contributes to the average according to its associated weight. 
        The array of weights must be the same shape as `a` if no axis is 
        specified, otherwise the weights must have dimensions and shape 
        consistent with `a` along the specified axis. 
        If `weights=None`, then all data in `a` are assumed to have a 
        weight equal to one. 
        The calculation is:: 
 
            avg = sum(a * weights) / sum(weights) 
         
        where the sum is over all included elements. 
        The only constraint on the values of `weights` is that `sum(weights)` 
        must not be 0. 
    returned : bool, optional 
        Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`) 
        is returned, otherwise only the average is returned. 
        If `weights=None`, `sum_of_weights` is equivalent to the number of 
        elements over which the average is taken. 
    keepdims : bool, optional 
        If this is set to True, the axes which are reduced are left 
        in the result as dimensions with size one. With this option, 
        the result will broadcast correctly against the original `a`. 
        *Note:* `keepdims` will not work with instances of `numpy.matrix` 
        or other classes whose methods do not support `keepdims`. 
 
        .. versionadded:: 1.23.0 
 
    Returns 
    ------- 
    retval, [sum_of_weights] : array_type or double 
        Return the average along the specified axis. When `returned` is `True`, 
        return a tuple with the average as the first element and the sum 
        of the weights as the second element. `sum_of_weights` is of the 
        same type as `retval`. The result dtype follows a general pattern. 
        If `weights` is None, the result dtype will be that of `a` , or ``float64`` 
        if `a` is integral. Otherwise, if `weights` is not None and `a` is non- 
        integral, the result type will be the type of lowest precision capable of 
        representing values of both `a` and `weights`. If `a` happens to be 
        integral, the previous rules still applies but the result dtype will 
        at least be ``float64``. 
 
    Raises 
    ------ 
    ZeroDivisionError 
        When all weights along axis are zero. See `numpy.ma.average` for a 
        version robust to this type of error. 
    TypeError 
        When `weights` does not have the same shape as `a`, and `axis=None`. 
    ValueError 
        When `weights` does not have dimensions and shape consistent with `a` 
        along specified `axis`. 
 
    See Also 
    -------- 
    mean 
 
    ma.average : average for masked arrays -- useful if your data contains 
                 &quot;missing&quot; values 
    numpy.result_type : Returns the type that results from applying the 
                        numpy type promotion rules to the arguments. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; data = np.arange(1, 5) 
    &gt;&gt;&gt; data 
    array([1, 2, 3, 4]) 
    &gt;&gt;&gt; np.average(data) 
    2.5 
    &gt;&gt;&gt; np.average(np.arange(1, 11), weights=np.arange(10, 0, -1)) 
    4.0 
 
    &gt;&gt;&gt; data = np.arange(6).reshape((3, 2)) 
    &gt;&gt;&gt; data 
    array([[0, 1], 
           [2, 3], 
           [4, 5]]) 
    &gt;&gt;&gt; np.average(data, axis=1, weights=[1./4, 3./4]) 
    array([0.75, 2.75, 4.75]) 
    &gt;&gt;&gt; np.average(data, weights=[1./4, 3./4]) 
    Traceback (most recent call last): 
        ... 
    TypeError: Axis must be specified when shapes of a and weights differ. 
 
    With ``keepdims=True``, the following result has shape (3, 1). 
 
    &gt;&gt;&gt; np.average(data, axis=1, keepdims=True) 
    array([[0.5], 
           [2.5], 
           [4.5]]) 
 
    &gt;&gt;&gt; data = np.arange(8).reshape((2, 2, 2)) 
    &gt;&gt;&gt; data 
    array([[[0, 1], 
            [2, 3]], 
           [[4, 5], 
            [6, 7]]]) 
    &gt;&gt;&gt; np.average(data, axis=(0, 1), weights=[[1./4, 3./4], [1., 1./2]]) 
    array([3.4, 4.4]) 
    &gt;&gt;&gt; np.average(data, axis=0, weights=[[1./4, 3./4], [1., 1./2]]) 
    Traceback (most recent call last): 
        ... 
    ValueError: Shape of weights must be consistent 
    with shape of a along specified axis. 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">axis </span><span class="s2">= </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">normalize_axis_tuple</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">argname</span><span class="s2">=</span><span class="s4">&quot;axis&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">keepdims </span><span class="s0">is </span><span class="s1">np</span><span class="s2">.</span><span class="s1">_NoValue</span><span class="s2">:</span>
        <span class="s3"># Don't pass on the keepdims argument if one wasn't given.</span>
        <span class="s1">keepdims_kw </span><span class="s2">= {}</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">keepdims_kw </span><span class="s2">= {</span><span class="s4">'keepdims'</span><span class="s2">: </span><span class="s1">keepdims</span><span class="s2">}</span>

    <span class="s0">if </span><span class="s1">weights </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">avg </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, **</span><span class="s1">keepdims_kw</span><span class="s2">)</span>
        <span class="s1">avg_as_array </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">avg</span><span class="s2">)</span>
        <span class="s1">scl </span><span class="s2">= </span><span class="s1">avg_as_array</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">size</span><span class="s2">/</span><span class="s1">avg_as_array</span><span class="s2">.</span><span class="s1">size</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">wgt </span><span class="s2">= </span><span class="s1">_weights_are_valid</span><span class="s2">(</span><span class="s1">weights</span><span class="s2">=</span><span class="s1">weights</span><span class="s2">, </span><span class="s1">a</span><span class="s2">=</span><span class="s1">a</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">integer</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool</span><span class="s2">)):</span>
            <span class="s1">result_dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">result_type</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">wgt</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s4">'f8'</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">result_dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">result_type</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">wgt</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s1">scl </span><span class="s2">= </span><span class="s1">wgt</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">result_dtype</span><span class="s2">, **</span><span class="s1">keepdims_kw</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">scl </span><span class="s2">== </span><span class="s5">0.0</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ZeroDivisionError</span><span class="s2">(</span>
                <span class="s4">&quot;Weights sum to zero, can't be normalized&quot;</span><span class="s2">)</span>

        <span class="s1">avg </span><span class="s2">= </span><span class="s1">avg_as_array </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">wgt</span><span class="s2">,</span>
                          <span class="s1">dtype</span><span class="s2">=</span><span class="s1">result_dtype</span><span class="s2">).</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, **</span><span class="s1">keepdims_kw</span><span class="s2">) / </span><span class="s1">scl</span>

    <span class="s0">if </span><span class="s1">returned</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">scl</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">avg_as_array</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
            <span class="s1">scl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">scl</span><span class="s2">, </span><span class="s1">avg_as_array</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">).</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">avg</span><span class="s2">, </span><span class="s1">scl</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">avg</span>


<span class="s2">@</span><span class="s1">set_module</span><span class="s2">(</span><span class="s4">'numpy'</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">asarray_chkfinite</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Convert the input to an array, checking for NaNs or Infs. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input data, in any form that can be converted to an array.  This 
        includes lists, lists of tuples, tuples, tuples of tuples, tuples 
        of lists and ndarrays.  Success requires no NaNs or Infs. 
    dtype : data-type, optional 
        By default, the data-type is inferred from the input data. 
    order : {'C', 'F', 'A', 'K'}, optional 
        Memory layout.  'A' and 'K' depend on the order of input array a. 
        'C' row-major (C-style), 
        'F' column-major (Fortran-style) memory representation. 
        'A' (any) means 'F' if `a` is Fortran contiguous, 'C' otherwise 
        'K' (keep) preserve input order 
        Defaults to 'C'. 
 
    Returns 
    ------- 
    out : ndarray 
        Array interpretation of `a`.  No copy is performed if the input 
        is already an ndarray.  If `a` is a subclass of ndarray, a base 
        class ndarray is returned. 
 
    Raises 
    ------ 
    ValueError 
        Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity). 
 
    See Also 
    -------- 
    asarray : Create and array. 
    asanyarray : Similar function which passes through subclasses. 
    ascontiguousarray : Convert input to a contiguous array. 
    asfortranarray : Convert input to an ndarray with column-major 
                     memory order. 
    fromiter : Create an array from an iterator. 
    fromfunction : Construct an array by executing a function on grid 
                   positions. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
 
    Convert a list into an array. If all elements are finite, then 
    ``asarray_chkfinite`` is identical to ``asarray``. 
 
    &gt;&gt;&gt; a = [1, 2] 
    &gt;&gt;&gt; np.asarray_chkfinite(a, dtype=float) 
    array([1., 2.]) 
 
    Raises ValueError if array_like contains Nans or Infs. 
 
    &gt;&gt;&gt; a = [1, 2, np.inf] 
    &gt;&gt;&gt; try: 
    ...     np.asarray_chkfinite(a) 
    ... except ValueError: 
    ...     print('ValueError') 
    ... 
    ValueError 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s1">order</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char </span><span class="s0">in </span><span class="s1">typecodes</span><span class="s2">[</span><span class="s4">'AllFloat'</span><span class="s2">] </span><span class="s0">and not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">a</span><span class="s2">).</span><span class="s1">all</span><span class="s2">():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">&quot;array must not contain infs or NaNs&quot;</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">a</span>


<span class="s0">def </span><span class="s1">_piecewise_dispatcher</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">condlist</span><span class="s2">, </span><span class="s1">funclist</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">):</span>
    <span class="s0">yield </span><span class="s1">x</span>
    <span class="s3"># support the undocumented behavior of allowing scalars</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iterable</span><span class="s2">(</span><span class="s1">condlist</span><span class="s2">):</span>
        <span class="s0">yield from </span><span class="s1">condlist</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_piecewise_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">piecewise</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">condlist</span><span class="s2">, </span><span class="s1">funclist</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Evaluate a piecewise-defined function. 
 
    Given a set of conditions and corresponding functions, evaluate each 
    function on the input data wherever its condition is true. 
 
    Parameters 
    ---------- 
    x : ndarray or scalar 
        The input domain. 
    condlist : list of bool arrays or bool scalars 
        Each boolean array corresponds to a function in `funclist`.  Wherever 
        `condlist[i]` is True, `funclist[i](x)` is used as the output value. 
 
        Each boolean array in `condlist` selects a piece of `x`, 
        and should therefore be of the same shape as `x`. 
 
        The length of `condlist` must correspond to that of `funclist`. 
        If one extra function is given, i.e. if 
        ``len(funclist) == len(condlist) + 1``, then that extra function 
        is the default value, used wherever all conditions are false. 
    funclist : list of callables, f(x,*args,**kw), or scalars 
        Each function is evaluated over `x` wherever its corresponding 
        condition is True.  It should take a 1d array as input and give an 1d 
        array or a scalar value as output.  If, instead of a callable, 
        a scalar is provided then a constant function (``lambda x: scalar``) is 
        assumed. 
    args : tuple, optional 
        Any further arguments given to `piecewise` are passed to the functions 
        upon execution, i.e., if called ``piecewise(..., ..., 1, 'a')``, then 
        each function is called as ``f(x, 1, 'a')``. 
    kw : dict, optional 
        Keyword arguments used in calling `piecewise` are passed to the 
        functions upon execution, i.e., if called 
        ``piecewise(..., ..., alpha=1)``, then each function is called as 
        ``f(x, alpha=1)``. 
 
    Returns 
    ------- 
    out : ndarray 
        The output is the same shape and type as x and is found by 
        calling the functions in `funclist` on the appropriate portions of `x`, 
        as defined by the boolean arrays in `condlist`.  Portions not covered 
        by any condition have a default value of 0. 
 
 
    See Also 
    -------- 
    choose, select, where 
 
    Notes 
    ----- 
    This is similar to choose or select, except that functions are 
    evaluated on elements of `x` that satisfy the corresponding condition from 
    `condlist`. 
 
    The result is:: 
 
            |-- 
            |funclist[0](x[condlist[0]]) 
      out = |funclist[1](x[condlist[1]]) 
            |... 
            |funclist[n2](x[condlist[n2]]) 
            |-- 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
 
    Define the signum function, which is -1 for ``x &lt; 0`` and +1 for ``x &gt;= 0``. 
 
    &gt;&gt;&gt; x = np.linspace(-2.5, 2.5, 6) 
    &gt;&gt;&gt; np.piecewise(x, [x &lt; 0, x &gt;= 0], [-1, 1]) 
    array([-1., -1., -1.,  1.,  1.,  1.]) 
 
    Define the absolute value, which is ``-x`` for ``x &lt;0`` and ``x`` for 
    ``x &gt;= 0``. 
 
    &gt;&gt;&gt; np.piecewise(x, [x &lt; 0, x &gt;= 0], [lambda x: -x, lambda x: x]) 
    array([2.5,  1.5,  0.5,  0.5,  1.5,  2.5]) 
 
    Apply the same function to a scalar value. 
 
    &gt;&gt;&gt; y = -2 
    &gt;&gt;&gt; np.piecewise(y, [y &lt; 0, y &gt;= 0], [lambda x: -x, lambda x: x]) 
    array(2) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s1">n2 </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">funclist</span><span class="s2">)</span>

    <span class="s3"># undocumented: single condition is promoted to a list of one condition</span>
    <span class="s0">if </span><span class="s1">isscalar</span><span class="s2">(</span><span class="s1">condlist</span><span class="s2">) </span><span class="s0">or </span><span class="s2">(</span>
            <span class="s0">not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">condlist</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], (</span><span class="s1">list</span><span class="s2">, </span><span class="s1">ndarray</span><span class="s2">)) </span><span class="s0">and </span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">0</span><span class="s2">):</span>
        <span class="s1">condlist </span><span class="s2">= [</span><span class="s1">condlist</span><span class="s2">]</span>

    <span class="s1">condlist </span><span class="s2">= </span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">condlist</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">condlist</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">n </span><span class="s2">== </span><span class="s1">n2 </span><span class="s2">- </span><span class="s5">1</span><span class="s2">:  </span><span class="s3"># compute the &quot;otherwise&quot; condition.</span>
        <span class="s1">condelse </span><span class="s2">= ~</span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">condlist</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">keepdims</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">condlist </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">([</span><span class="s1">condlist</span><span class="s2">, </span><span class="s1">condelse</span><span class="s2">], </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">)</span>
        <span class="s1">n </span><span class="s2">+= </span><span class="s5">1</span>
    <span class="s0">elif </span><span class="s1">n </span><span class="s2">!= </span><span class="s1">n2</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">&quot;with {} condition(s), either {} or {} functions are expected&quot;</span>
            <span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">+</span><span class="s5">1</span><span class="s2">)</span>
        <span class="s2">)</span>

    <span class="s1">y </span><span class="s2">= </span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s0">for </span><span class="s1">cond</span><span class="s2">, </span><span class="s1">func </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">condlist</span><span class="s2">, </span><span class="s1">funclist</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc</span><span class="s2">.</span><span class="s1">Callable</span><span class="s2">):</span>
            <span class="s1">y</span><span class="s2">[</span><span class="s1">cond</span><span class="s2">] = </span><span class="s1">func</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">vals </span><span class="s2">= </span><span class="s1">x</span><span class="s2">[</span><span class="s1">cond</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">vals</span><span class="s2">.</span><span class="s1">size </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s1">y</span><span class="s2">[</span><span class="s1">cond</span><span class="s2">] = </span><span class="s1">func</span><span class="s2">(</span><span class="s1">vals</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kw</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">y</span>


<span class="s0">def </span><span class="s1">_select_dispatcher</span><span class="s2">(</span><span class="s1">condlist</span><span class="s2">, </span><span class="s1">choicelist</span><span class="s2">, </span><span class="s1">default</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">yield from </span><span class="s1">condlist</span>
    <span class="s0">yield from </span><span class="s1">choicelist</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_select_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">select</span><span class="s2">(</span><span class="s1">condlist</span><span class="s2">, </span><span class="s1">choicelist</span><span class="s2">, </span><span class="s1">default</span><span class="s2">=</span><span class="s5">0</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return an array drawn from elements in choicelist, depending on conditions. 
 
    Parameters 
    ---------- 
    condlist : list of bool ndarrays 
        The list of conditions which determine from which array in `choicelist` 
        the output elements are taken. When multiple conditions are satisfied, 
        the first one encountered in `condlist` is used. 
    choicelist : list of ndarrays 
        The list of arrays from which the output elements are taken. It has 
        to be of the same length as `condlist`. 
    default : scalar, optional 
        The element inserted in `output` when all conditions evaluate to False. 
 
    Returns 
    ------- 
    output : ndarray 
        The output at position m is the m-th element of the array in 
        `choicelist` where the m-th element of the corresponding array in 
        `condlist` is True. 
 
    See Also 
    -------- 
    where : Return elements from one of two arrays depending on condition. 
    take, choose, compress, diag, diagonal 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
 
    Beginning with an array of integers from 0 to 5 (inclusive), 
    elements less than ``3`` are negated, elements greater than ``3`` 
    are squared, and elements not meeting either of these conditions 
    (exactly ``3``) are replaced with a `default` value of ``42``. 
 
    &gt;&gt;&gt; x = np.arange(6) 
    &gt;&gt;&gt; condlist = [x&lt;3, x&gt;3] 
    &gt;&gt;&gt; choicelist = [x, x**2] 
    &gt;&gt;&gt; np.select(condlist, choicelist, 42) 
    array([ 0,  1,  2, 42, 16, 25]) 
 
    When multiple conditions are satisfied, the first one encountered in 
    `condlist` is used. 
 
    &gt;&gt;&gt; condlist = [x&lt;=4, x&gt;3] 
    &gt;&gt;&gt; choicelist = [x, x**2] 
    &gt;&gt;&gt; np.select(condlist, choicelist, 55) 
    array([ 0,  1,  2,  3,  4, 25]) 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># Check the size of condlist and choicelist are the same, or abort.</span>
    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">condlist</span><span class="s2">) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">choicelist</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">'list of cases must be same length as list of conditions'</span><span class="s2">)</span>

    <span class="s3"># Now that the dtype is known, handle the deprecated select([], []) case</span>
    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">condlist</span><span class="s2">) == </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;select with an empty condition list is not possible&quot;</span><span class="s2">)</span>

    <span class="s3"># TODO: This preserves the Python int, float, complex manually to get the</span>
    <span class="s3">#       right `result_type` with NEP 50.  Most likely we will grow a better</span>
    <span class="s3">#       way to spell this (and this can be replaced).</span>
    <span class="s1">choicelist </span><span class="s2">= [</span>
        <span class="s1">choice </span><span class="s0">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">choice</span><span class="s2">) </span><span class="s0">in </span><span class="s2">(</span><span class="s1">int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">complex</span><span class="s2">) </span><span class="s0">else </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">choice</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">choice </span><span class="s0">in </span><span class="s1">choicelist</span><span class="s2">]</span>
    <span class="s1">choicelist</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">default </span><span class="s0">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">default</span><span class="s2">) </span><span class="s0">in </span><span class="s2">(</span><span class="s1">int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">complex</span><span class="s2">)</span>
                      <span class="s0">else </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">default</span><span class="s2">))</span>

    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">result_type</span><span class="s2">(*</span><span class="s1">choicelist</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s4">f'Choicelist and default value do not have a common dtype: </span><span class="s0">{</span><span class="s1">e</span><span class="s0">}</span><span class="s4">'</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">) </span><span class="s0">from None</span>

    <span class="s3"># Convert conditions to arrays and broadcast conditions and choices</span>
    <span class="s3"># as the shape is needed for the result. Doing it separately optimizes</span>
    <span class="s3"># for example when all choices are scalars.</span>
    <span class="s1">condlist </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_arrays</span><span class="s2">(*</span><span class="s1">condlist</span><span class="s2">)</span>
    <span class="s1">choicelist </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_arrays</span><span class="s2">(*</span><span class="s1">choicelist</span><span class="s2">)</span>

    <span class="s3"># If cond array is not an ndarray in boolean format or scalar bool, abort.</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">cond </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">condlist</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">cond</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type </span><span class="s0">is not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s4">'invalid entry {} in condlist: should be boolean ndarray'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">i</span><span class="s2">))</span>

    <span class="s0">if </span><span class="s1">choicelist</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s3"># This may be common, so avoid the call.</span>
        <span class="s1">result_shape </span><span class="s2">= </span><span class="s1">condlist</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">shape</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">result_shape </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_arrays</span><span class="s2">(</span><span class="s1">condlist</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">choicelist</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">shape</span>

    <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full</span><span class="s2">(</span><span class="s1">result_shape</span><span class="s2">, </span><span class="s1">choicelist</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s3"># Use np.copyto to burn each choicelist array onto result, using the</span>
    <span class="s3"># corresponding condlist as a boolean mask. This is done in reverse</span>
    <span class="s3"># order since the first choice should take precedence.</span>
    <span class="s1">choicelist </span><span class="s2">= </span><span class="s1">choicelist</span><span class="s2">[-</span><span class="s5">2</span><span class="s2">::-</span><span class="s5">1</span><span class="s2">]</span>
    <span class="s1">condlist </span><span class="s2">= </span><span class="s1">condlist</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">]</span>
    <span class="s0">for </span><span class="s1">choice</span><span class="s2">, </span><span class="s1">cond </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">choicelist</span><span class="s2">, </span><span class="s1">condlist</span><span class="s2">):</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">copyto</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">choice</span><span class="s2">, </span><span class="s1">where</span><span class="s2">=</span><span class="s1">cond</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">_copy_dispatcher</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">subok</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">a</span><span class="s2">,)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_copy_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">copy</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s4">'K'</span><span class="s2">, </span><span class="s1">subok</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return an array copy of the given object. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input data. 
    order : {'C', 'F', 'A', 'K'}, optional 
        Controls the memory layout of the copy. 'C' means C-order, 
        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous, 
        'C' otherwise. 'K' means match the layout of `a` as closely 
        as possible. (Note that this function and :meth:`ndarray.copy` are very 
        similar, but have different default values for their order= 
        arguments.) 
    subok : bool, optional 
        If True, then sub-classes will be passed-through, otherwise the 
        returned array will be forced to be a base-class array (defaults to False). 
 
        .. versionadded:: 1.19.0 
 
    Returns 
    ------- 
    arr : ndarray 
        Array interpretation of `a`. 
 
    See Also 
    -------- 
    ndarray.copy : Preferred method for creating an array copy 
 
    Notes 
    ----- 
    This is equivalent to: 
 
    &gt;&gt;&gt; np.array(a, copy=True)  #doctest: +SKIP 
 
    The copy made of the data is shallow, i.e., for arrays with object dtype, 
    the new array will point to the same objects. 
    See Examples from `ndarray.copy`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
 
    Create an array x, with a reference y and a copy z: 
 
    &gt;&gt;&gt; x = np.array([1, 2, 3]) 
    &gt;&gt;&gt; y = x 
    &gt;&gt;&gt; z = np.copy(x) 
 
    Note that, when we modify x, y changes, but not z: 
 
    &gt;&gt;&gt; x[0] = 10 
    &gt;&gt;&gt; x[0] == y[0] 
    True 
    &gt;&gt;&gt; x[0] == z[0] 
    False 
 
    Note that, np.copy clears previously set WRITEABLE=False flag. 
 
    &gt;&gt;&gt; a = np.array([1, 2, 3]) 
    &gt;&gt;&gt; a.flags[&quot;WRITEABLE&quot;] = False 
    &gt;&gt;&gt; b = np.copy(a) 
    &gt;&gt;&gt; b.flags[&quot;WRITEABLE&quot;] 
    True 
    &gt;&gt;&gt; b[0] = 3 
    &gt;&gt;&gt; b 
    array([3, 2, 3]) 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">array</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s1">order</span><span class="s2">, </span><span class="s1">subok</span><span class="s2">=</span><span class="s1">subok</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

<span class="s3"># Basic operations</span>


<span class="s0">def </span><span class="s1">_gradient_dispatcher</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, *</span><span class="s1">varargs</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">edge_order</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">yield </span><span class="s1">f</span>
    <span class="s0">yield from </span><span class="s1">varargs</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_gradient_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">gradient</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, *</span><span class="s1">varargs</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">edge_order</span><span class="s2">=</span><span class="s5">1</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return the gradient of an N-dimensional array. 
 
    The gradient is computed using second order accurate central differences 
    in the interior points and either first or second order accurate one-sides 
    (forward or backwards) differences at the boundaries. 
    The returned gradient hence has the same shape as the input array. 
 
    Parameters 
    ---------- 
    f : array_like 
        An N-dimensional array containing samples of a scalar function. 
    varargs : list of scalar or array, optional 
        Spacing between f values. Default unitary spacing for all dimensions. 
        Spacing can be specified using: 
 
        1. single scalar to specify a sample distance for all dimensions. 
        2. N scalars to specify a constant sample distance for each dimension. 
           i.e. `dx`, `dy`, `dz`, ... 
        3. N arrays to specify the coordinates of the values along each 
           dimension of F. The length of the array must match the size of 
           the corresponding dimension 
        4. Any combination of N scalars/arrays with the meaning of 2. and 3. 
 
        If `axis` is given, the number of varargs must equal the number of axes. 
        Default: 1. (see Examples below). 
 
    edge_order : {1, 2}, optional 
        Gradient is calculated using N-th order accurate differences 
        at the boundaries. Default: 1. 
 
        .. versionadded:: 1.9.1 
 
    axis : None or int or tuple of ints, optional 
        Gradient is calculated only along the given axis or axes 
        The default (axis = None) is to calculate the gradient for all the axes 
        of the input array. axis may be negative, in which case it counts from 
        the last to the first axis. 
 
        .. versionadded:: 1.11.0 
 
    Returns 
    ------- 
    gradient : ndarray or tuple of ndarray 
        A tuple of ndarrays (or a single ndarray if there is only one 
        dimension) corresponding to the derivatives of f with respect 
        to each dimension. Each derivative has the same shape as f. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; f = np.array([1, 2, 4, 7, 11, 16]) 
    &gt;&gt;&gt; np.gradient(f) 
    array([1. , 1.5, 2.5, 3.5, 4.5, 5. ]) 
    &gt;&gt;&gt; np.gradient(f, 2) 
    array([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ]) 
 
    Spacing can be also specified with an array that represents the coordinates 
    of the values F along the dimensions. 
    For instance a uniform spacing: 
 
    &gt;&gt;&gt; x = np.arange(f.size) 
    &gt;&gt;&gt; np.gradient(f, x) 
    array([1. ,  1.5,  2.5,  3.5,  4.5,  5. ]) 
 
    Or a non uniform one: 
 
    &gt;&gt;&gt; x = np.array([0., 1., 1.5, 3.5, 4., 6.]) 
    &gt;&gt;&gt; np.gradient(f, x) 
    array([1. ,  3. ,  3.5,  6.7,  6.9,  2.5]) 
 
    For two dimensional arrays, the return will be two arrays ordered by 
    axis. In this example the first array stands for the gradient in 
    rows and the second one in columns direction: 
 
    &gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]])) 
    (array([[ 2.,  2., -1.], 
            [ 2.,  2., -1.]]), 
     array([[1. , 2.5, 4. ], 
            [1. , 1. , 1. ]])) 
 
    In this example the spacing is also specified: 
    uniform for axis=0 and non uniform for axis=1 
 
    &gt;&gt;&gt; dx = 2. 
    &gt;&gt;&gt; y = [1., 1.5, 3.5] 
    &gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]]), dx, y) 
    (array([[ 1. ,  1. , -0.5], 
            [ 1. ,  1. , -0.5]]), 
     array([[2. , 2. , 2. ], 
            [2. , 1.7, 0.5]])) 
 
    It is possible to specify how boundaries are treated using `edge_order` 
 
    &gt;&gt;&gt; x = np.array([0, 1, 2, 3, 4]) 
    &gt;&gt;&gt; f = x**2 
    &gt;&gt;&gt; np.gradient(f, edge_order=1) 
    array([1.,  2.,  4.,  6.,  7.]) 
    &gt;&gt;&gt; np.gradient(f, edge_order=2) 
    array([0., 2., 4., 6., 8.]) 
 
    The `axis` keyword can be used to specify a subset of axes of which the 
    gradient is calculated 
 
    &gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]]), axis=0) 
    array([[ 2.,  2., -1.], 
           [ 2.,  2., -1.]]) 
 
    The `varargs` argument defines the spacing between sample points in the 
    input array. It can take two forms: 
 
    1. An array, specifying coordinates, which may be unevenly spaced: 
 
    &gt;&gt;&gt; x = np.array([0., 2., 3., 6., 8.]) 
    &gt;&gt;&gt; y = x ** 2 
    &gt;&gt;&gt; np.gradient(y, x, edge_order=2) 
    array([ 0.,  4.,  6., 12., 16.]) 
 
    2. A scalar, representing the fixed sample distance: 
 
    &gt;&gt;&gt; dx = 2 
    &gt;&gt;&gt; x = np.array([0., 2., 4., 6., 8.]) 
    &gt;&gt;&gt; y = x ** 2 
    &gt;&gt;&gt; np.gradient(y, dx, edge_order=2) 
    array([ 0.,  4.,  8., 12., 16.]) 
 
    It's possible to provide different data for spacing along each dimension. 
    The number of arguments must match the number of dimensions in the input 
    data. 
 
    &gt;&gt;&gt; dx = 2 
    &gt;&gt;&gt; dy = 3 
    &gt;&gt;&gt; x = np.arange(0, 6, dx) 
    &gt;&gt;&gt; y = np.arange(0, 9, dy) 
    &gt;&gt;&gt; xs, ys = np.meshgrid(x, y) 
    &gt;&gt;&gt; zs = xs + 2 * ys 
    &gt;&gt;&gt; np.gradient(zs, dy, dx)  # Passing two scalars 
    (array([[2., 2., 2.], 
            [2., 2., 2.], 
            [2., 2., 2.]]), 
     array([[1., 1., 1.], 
            [1., 1., 1.], 
            [1., 1., 1.]])) 
 
    Mixing scalars and arrays is also allowed: 
 
    &gt;&gt;&gt; np.gradient(zs, y, dx)  # Passing one array and one scalar 
    (array([[2., 2., 2.], 
            [2., 2., 2.], 
            [2., 2., 2.]]), 
     array([[1., 1., 1.], 
            [1., 1., 1.], 
            [1., 1., 1.]])) 
 
    Notes 
    ----- 
    Assuming that :math:`f\\in C^{3}` (i.e., :math:`f` has at least 3 continuous 
    derivatives) and let :math:`h_{*}` be a non-homogeneous stepsize, we 
    minimize the &quot;consistency error&quot; :math:`\\eta_{i}` between the true gradient 
    and its estimate from a linear combination of the neighboring grid-points: 
 
    .. math:: 
 
        \\eta_{i} = f_{i}^{\\left(1\\right)} - 
                    \\left[ \\alpha f\\left(x_{i}\\right) + 
                            \\beta f\\left(x_{i} + h_{d}\\right) + 
                            \\gamma f\\left(x_{i}-h_{s}\\right) 
                    \\right] 
 
    By substituting :math:`f(x_{i} + h_{d})` and :math:`f(x_{i} - h_{s})` 
    with their Taylor series expansion, this translates into solving 
    the following the linear system: 
 
    .. math:: 
 
        \\left\\{ 
            \\begin{array}{r} 
                \\alpha+\\beta+\\gamma=0 \\\\ 
                \\beta h_{d}-\\gamma h_{s}=1 \\\\ 
                \\beta h_{d}^{2}+\\gamma h_{s}^{2}=0 
            \\end{array} 
        \\right. 
 
    The resulting approximation of :math:`f_{i}^{(1)}` is the following: 
 
    .. math:: 
 
        \\hat f_{i}^{(1)} = 
            \\frac{ 
                h_{s}^{2}f\\left(x_{i} + h_{d}\\right) 
                + \\left(h_{d}^{2} - h_{s}^{2}\\right)f\\left(x_{i}\\right) 
                - h_{d}^{2}f\\left(x_{i}-h_{s}\\right)} 
                { h_{s}h_{d}\\left(h_{d} + h_{s}\\right)} 
            + \\mathcal{O}\\left(\\frac{h_{d}h_{s}^{2} 
                                + h_{s}h_{d}^{2}}{h_{d} 
                                + h_{s}}\\right) 
 
    It is worth noting that if :math:`h_{s}=h_{d}` 
    (i.e., data are evenly spaced) 
    we find the standard second order approximation: 
 
    .. math:: 
 
        \\hat f_{i}^{(1)}= 
            \\frac{f\\left(x_{i+1}\\right) - f\\left(x_{i-1}\\right)}{2h} 
            + \\mathcal{O}\\left(h^{2}\\right) 
 
    With a similar procedure the forward/backward approximations used for 
    boundaries can be derived. 
 
    References 
    ---------- 
    .. [1]  Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics 
            (Texts in Applied Mathematics). New York: Springer. 
    .. [2]  Durran D. R. (1999) Numerical Methods for Wave Equations 
            in Geophysical Fluid Dynamics. New York: Springer. 
    .. [3]  Fornberg B. (1988) Generation of Finite Difference Formulas on 
            Arbitrarily Spaced Grids, 
            Mathematics of Computation 51, no. 184 : 699-706. 
            `PDF &lt;https://www.ams.org/journals/mcom/1988-51-184/ 
            S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&gt;`_. 
    &quot;&quot;&quot;</span>
    <span class="s1">f </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">f</span><span class="s2">)</span>
    <span class="s1">N </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">ndim  </span><span class="s3"># number of dimensions</span>

    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">axes </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">N</span><span class="s2">))</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">axes </span><span class="s2">= </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">normalize_axis_tuple</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">N</span><span class="s2">)</span>

    <span class="s1">len_axes </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">axes</span><span class="s2">)</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">varargs</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">n </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s3"># no spacing argument - use 1 in all axes</span>
        <span class="s1">dx </span><span class="s2">= [</span><span class="s5">1.0</span><span class="s2">] * </span><span class="s1">len_axes</span>
    <span class="s0">elif </span><span class="s1">n </span><span class="s2">== </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">(</span><span class="s1">varargs</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]) == </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s3"># single scalar for all axes</span>
        <span class="s1">dx </span><span class="s2">= </span><span class="s1">varargs </span><span class="s2">* </span><span class="s1">len_axes</span>
    <span class="s0">elif </span><span class="s1">n </span><span class="s2">== </span><span class="s1">len_axes</span><span class="s2">:</span>
        <span class="s3"># scalar or 1d array for each axis</span>
        <span class="s1">dx </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">varargs</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">distances </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">dx</span><span class="s2">):</span>
            <span class="s1">distances </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">distances</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">distances</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s0">continue</span>
            <span class="s0">elif </span><span class="s1">distances</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;distances must be either scalars or 1d&quot;</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">distances</span><span class="s2">) != </span><span class="s1">f</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axes</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]]:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;when 1d, distances must match &quot;</span>
                                 <span class="s4">&quot;the length of the corresponding dimension&quot;</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">distances</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">integer</span><span class="s2">):</span>
                <span class="s3"># Convert numpy integer types to float64 to avoid modular</span>
                <span class="s3"># arithmetic in np.diff(distances).</span>
                <span class="s1">distances </span><span class="s2">= </span><span class="s1">distances</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
            <span class="s1">diffx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">distances</span><span class="s2">)</span>
            <span class="s3"># if distances are constant reduce to the scalar case</span>
            <span class="s3"># since it brings a consistent speedup</span>
            <span class="s0">if </span><span class="s2">(</span><span class="s1">diffx </span><span class="s2">== </span><span class="s1">diffx</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]).</span><span class="s1">all</span><span class="s2">():</span>
                <span class="s1">diffx </span><span class="s2">= </span><span class="s1">diffx</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s1">dx</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">diffx</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;invalid number of arguments&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">edge_order </span><span class="s2">&gt; </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;'edge_order' greater than 2 not supported&quot;</span><span class="s2">)</span>

    <span class="s3"># use central differences on interior and one-sided differences on the</span>
    <span class="s3"># endpoints. This preserves second order-accuracy over the full domain.</span>

    <span class="s1">outvals </span><span class="s2">= []</span>

    <span class="s3"># create slice objects --- initially all are [:, :, ..., :]</span>
    <span class="s1">slice1 </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)]*</span><span class="s1">N</span>
    <span class="s1">slice2 </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)]*</span><span class="s1">N</span>
    <span class="s1">slice3 </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)]*</span><span class="s1">N</span>
    <span class="s1">slice4 </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)]*</span><span class="s1">N</span>

    <span class="s1">otype </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">dtype</span>
    <span class="s0">if </span><span class="s1">otype</span><span class="s2">.</span><span class="s1">type </span><span class="s0">is </span><span class="s1">np</span><span class="s2">.</span><span class="s1">datetime64</span><span class="s2">:</span>
        <span class="s3"># the timedelta dtype with the same unit information</span>
        <span class="s1">otype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">otype</span><span class="s2">.</span><span class="s1">name</span><span class="s2">.</span><span class="s1">replace</span><span class="s2">(</span><span class="s4">'datetime'</span><span class="s2">, </span><span class="s4">'timedelta'</span><span class="s2">))</span>
        <span class="s3"># view as timedelta to allow addition</span>
        <span class="s1">f </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">view</span><span class="s2">(</span><span class="s1">otype</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">otype</span><span class="s2">.</span><span class="s1">type </span><span class="s0">is </span><span class="s1">np</span><span class="s2">.</span><span class="s1">timedelta64</span><span class="s2">:</span>
        <span class="s0">pass</span>
    <span class="s0">elif </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">otype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inexact</span><span class="s2">):</span>
        <span class="s0">pass</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s3"># All other types convert to floating point.</span>
        <span class="s3"># First check if f is a numpy integer type; if so, convert f to float64</span>
        <span class="s3"># to avoid modular arithmetic when computing the changes in f.</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">otype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">integer</span><span class="s2">):</span>
            <span class="s1">f </span><span class="s2">= </span><span class="s1">f</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">otype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span>

    <span class="s0">for </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">ax_dx </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">axes</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">f</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] &lt; </span><span class="s1">edge_order </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">&quot;Shape of array too small to calculate a numerical gradient, &quot;</span>
                <span class="s4">&quot;at least (edge_order + 1) elements are required.&quot;</span><span class="s2">)</span>
        <span class="s3"># result allocation</span>
        <span class="s1">out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">otype</span><span class="s2">)</span>

        <span class="s3"># spacing for the current axis</span>
        <span class="s1">uniform_spacing </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">(</span><span class="s1">ax_dx</span><span class="s2">) == </span><span class="s5">0</span>

        <span class="s3"># Numerical differentiation: 2nd order interior</span>
        <span class="s1">slice1</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">)</span>
        <span class="s1">slice2</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, -</span><span class="s5">2</span><span class="s2">)</span>
        <span class="s1">slice3</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">)</span>
        <span class="s1">slice4</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s5">2</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">uniform_spacing</span><span class="s2">:</span>
            <span class="s1">out</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice1</span><span class="s2">)] = (</span><span class="s1">f</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice4</span><span class="s2">)] - </span><span class="s1">f</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice2</span><span class="s2">)]) / (</span><span class="s5">2. </span><span class="s2">* </span><span class="s1">ax_dx</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">dx1 </span><span class="s2">= </span><span class="s1">ax_dx</span><span class="s2">[</span><span class="s5">0</span><span class="s2">:-</span><span class="s5">1</span><span class="s2">]</span>
            <span class="s1">dx2 </span><span class="s2">= </span><span class="s1">ax_dx</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]</span>
            <span class="s1">a </span><span class="s2">= -(</span><span class="s1">dx2</span><span class="s2">)/(</span><span class="s1">dx1 </span><span class="s2">* (</span><span class="s1">dx1 </span><span class="s2">+ </span><span class="s1">dx2</span><span class="s2">))</span>
            <span class="s1">b </span><span class="s2">= (</span><span class="s1">dx2 </span><span class="s2">- </span><span class="s1">dx1</span><span class="s2">) / (</span><span class="s1">dx1 </span><span class="s2">* </span><span class="s1">dx2</span><span class="s2">)</span>
            <span class="s1">c </span><span class="s2">= </span><span class="s1">dx1 </span><span class="s2">/ (</span><span class="s1">dx2 </span><span class="s2">* (</span><span class="s1">dx1 </span><span class="s2">+ </span><span class="s1">dx2</span><span class="s2">))</span>
            <span class="s3"># fix the shape for broadcasting</span>
            <span class="s1">shape </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">N</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">int</span><span class="s2">)</span>
            <span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = -</span><span class="s5">1</span>
            <span class="s1">a</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">c</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= </span><span class="s1">shape</span>
            <span class="s3"># 1D equivalent -- out[1:-1] = a * f[:-2] + b * f[1:-1] + c * f[2:]</span>
            <span class="s1">out</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice1</span><span class="s2">)] = </span><span class="s1">a </span><span class="s2">* </span><span class="s1">f</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice2</span><span class="s2">)] + </span><span class="s1">b </span><span class="s2">* </span><span class="s1">f</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice3</span><span class="s2">)] + </span><span class="s1">c </span><span class="s2">* </span><span class="s1">f</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice4</span><span class="s2">)]</span>

        <span class="s3"># Numerical differentiation: 1st order edges</span>
        <span class="s0">if </span><span class="s1">edge_order </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">slice1</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s5">0</span>
            <span class="s1">slice2</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s5">1</span>
            <span class="s1">slice3</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s5">0</span>
            <span class="s1">dx_0 </span><span class="s2">= </span><span class="s1">ax_dx </span><span class="s0">if </span><span class="s1">uniform_spacing </span><span class="s0">else </span><span class="s1">ax_dx</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s3"># 1D equivalent -- out[0] = (f[1] - f[0]) / (x[1] - x[0])</span>
            <span class="s1">out</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice1</span><span class="s2">)] = (</span><span class="s1">f</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice2</span><span class="s2">)] - </span><span class="s1">f</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice3</span><span class="s2">)]) / </span><span class="s1">dx_0</span>

            <span class="s1">slice1</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = -</span><span class="s5">1</span>
            <span class="s1">slice2</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = -</span><span class="s5">1</span>
            <span class="s1">slice3</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = -</span><span class="s5">2</span>
            <span class="s1">dx_n </span><span class="s2">= </span><span class="s1">ax_dx </span><span class="s0">if </span><span class="s1">uniform_spacing </span><span class="s0">else </span><span class="s1">ax_dx</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span>
            <span class="s3"># 1D equivalent -- out[-1] = (f[-1] - f[-2]) / (x[-1] - x[-2])</span>
            <span class="s1">out</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice1</span><span class="s2">)] = (</span><span class="s1">f</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice2</span><span class="s2">)] - </span><span class="s1">f</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice3</span><span class="s2">)]) / </span><span class="s1">dx_n</span>

        <span class="s3"># Numerical differentiation: 2nd order edges</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">slice1</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s5">0</span>
            <span class="s1">slice2</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s5">0</span>
            <span class="s1">slice3</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s5">1</span>
            <span class="s1">slice4</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s5">2</span>
            <span class="s0">if </span><span class="s1">uniform_spacing</span><span class="s2">:</span>
                <span class="s1">a </span><span class="s2">= -</span><span class="s5">1.5 </span><span class="s2">/ </span><span class="s1">ax_dx</span>
                <span class="s1">b </span><span class="s2">= </span><span class="s5">2. </span><span class="s2">/ </span><span class="s1">ax_dx</span>
                <span class="s1">c </span><span class="s2">= -</span><span class="s5">0.5 </span><span class="s2">/ </span><span class="s1">ax_dx</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">dx1 </span><span class="s2">= </span><span class="s1">ax_dx</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
                <span class="s1">dx2 </span><span class="s2">= </span><span class="s1">ax_dx</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>
                <span class="s1">a </span><span class="s2">= -(</span><span class="s5">2. </span><span class="s2">* </span><span class="s1">dx1 </span><span class="s2">+ </span><span class="s1">dx2</span><span class="s2">)/(</span><span class="s1">dx1 </span><span class="s2">* (</span><span class="s1">dx1 </span><span class="s2">+ </span><span class="s1">dx2</span><span class="s2">))</span>
                <span class="s1">b </span><span class="s2">= (</span><span class="s1">dx1 </span><span class="s2">+ </span><span class="s1">dx2</span><span class="s2">) / (</span><span class="s1">dx1 </span><span class="s2">* </span><span class="s1">dx2</span><span class="s2">)</span>
                <span class="s1">c </span><span class="s2">= - </span><span class="s1">dx1 </span><span class="s2">/ (</span><span class="s1">dx2 </span><span class="s2">* (</span><span class="s1">dx1 </span><span class="s2">+ </span><span class="s1">dx2</span><span class="s2">))</span>
            <span class="s3"># 1D equivalent -- out[0] = a * f[0] + b * f[1] + c * f[2]</span>
            <span class="s1">out</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice1</span><span class="s2">)] = </span><span class="s1">a </span><span class="s2">* </span><span class="s1">f</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice2</span><span class="s2">)] + </span><span class="s1">b </span><span class="s2">* </span><span class="s1">f</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice3</span><span class="s2">)] + </span><span class="s1">c </span><span class="s2">* </span><span class="s1">f</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice4</span><span class="s2">)]</span>

            <span class="s1">slice1</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = -</span><span class="s5">1</span>
            <span class="s1">slice2</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = -</span><span class="s5">3</span>
            <span class="s1">slice3</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = -</span><span class="s5">2</span>
            <span class="s1">slice4</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = -</span><span class="s5">1</span>
            <span class="s0">if </span><span class="s1">uniform_spacing</span><span class="s2">:</span>
                <span class="s1">a </span><span class="s2">= </span><span class="s5">0.5 </span><span class="s2">/ </span><span class="s1">ax_dx</span>
                <span class="s1">b </span><span class="s2">= -</span><span class="s5">2. </span><span class="s2">/ </span><span class="s1">ax_dx</span>
                <span class="s1">c </span><span class="s2">= </span><span class="s5">1.5 </span><span class="s2">/ </span><span class="s1">ax_dx</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">dx1 </span><span class="s2">= </span><span class="s1">ax_dx</span><span class="s2">[-</span><span class="s5">2</span><span class="s2">]</span>
                <span class="s1">dx2 </span><span class="s2">= </span><span class="s1">ax_dx</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span>
                <span class="s1">a </span><span class="s2">= (</span><span class="s1">dx2</span><span class="s2">) / (</span><span class="s1">dx1 </span><span class="s2">* (</span><span class="s1">dx1 </span><span class="s2">+ </span><span class="s1">dx2</span><span class="s2">))</span>
                <span class="s1">b </span><span class="s2">= - (</span><span class="s1">dx2 </span><span class="s2">+ </span><span class="s1">dx1</span><span class="s2">) / (</span><span class="s1">dx1 </span><span class="s2">* </span><span class="s1">dx2</span><span class="s2">)</span>
                <span class="s1">c </span><span class="s2">= (</span><span class="s5">2. </span><span class="s2">* </span><span class="s1">dx2 </span><span class="s2">+ </span><span class="s1">dx1</span><span class="s2">) / (</span><span class="s1">dx2 </span><span class="s2">* (</span><span class="s1">dx1 </span><span class="s2">+ </span><span class="s1">dx2</span><span class="s2">))</span>
            <span class="s3"># 1D equivalent -- out[-1] = a * f[-3] + b * f[-2] + c * f[-1]</span>
            <span class="s1">out</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice1</span><span class="s2">)] = </span><span class="s1">a </span><span class="s2">* </span><span class="s1">f</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice2</span><span class="s2">)] + </span><span class="s1">b </span><span class="s2">* </span><span class="s1">f</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice3</span><span class="s2">)] + </span><span class="s1">c </span><span class="s2">* </span><span class="s1">f</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice4</span><span class="s2">)]</span>

        <span class="s1">outvals</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">out</span><span class="s2">)</span>

        <span class="s3"># reset the slice object in this dimension to &quot;:&quot;</span>
        <span class="s1">slice1</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">slice2</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">slice3</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">slice4</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">len_axes </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">outvals</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
    <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">outvals</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_diff_dispatcher</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">n</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">prepend</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">append</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">prepend</span><span class="s2">, </span><span class="s1">append</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_diff_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">diff</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">n</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">prepend</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">_NoValue</span><span class="s2">, </span><span class="s1">append</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">_NoValue</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Calculate the n-th discrete difference along the given axis. 
 
    The first difference is given by ``out[i] = a[i+1] - a[i]`` along 
    the given axis, higher differences are calculated by using `diff` 
    recursively. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array 
    n : int, optional 
        The number of times values are differenced. If zero, the input 
        is returned as-is. 
    axis : int, optional 
        The axis along which the difference is taken, default is the 
        last axis. 
    prepend, append : array_like, optional 
        Values to prepend or append to `a` along axis prior to 
        performing the difference.  Scalar values are expanded to 
        arrays with length 1 in the direction of axis and the shape 
        of the input array in along all other axes.  Otherwise the 
        dimension and shape must match `a` except along axis. 
 
        .. versionadded:: 1.16.0 
 
    Returns 
    ------- 
    diff : ndarray 
        The n-th differences. The shape of the output is the same as `a` 
        except along `axis` where the dimension is smaller by `n`. The 
        type of the output is the same as the type of the difference 
        between any two elements of `a`. This is the same as the type of 
        `a` in most cases. A notable exception is `datetime64`, which 
        results in a `timedelta64` output array. 
 
    See Also 
    -------- 
    gradient, ediff1d, cumsum 
 
    Notes 
    ----- 
    Type is preserved for boolean arrays, so the result will contain 
    `False` when consecutive elements are the same and `True` when they 
    differ. 
 
    For unsigned integer arrays, the results will also be unsigned. This 
    should not be surprising, as the result is consistent with 
    calculating the difference directly: 
 
    &gt;&gt;&gt; u8_arr = np.array([1, 0], dtype=np.uint8) 
    &gt;&gt;&gt; np.diff(u8_arr) 
    array([255], dtype=uint8) 
    &gt;&gt;&gt; u8_arr[1,...] - u8_arr[0,...] 
    255 
 
    If this is not desirable, then the array should be cast to a larger 
    integer type first: 
 
    &gt;&gt;&gt; i16_arr = u8_arr.astype(np.int16) 
    &gt;&gt;&gt; np.diff(i16_arr) 
    array([-1], dtype=int16) 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.array([1, 2, 4, 7, 0]) 
    &gt;&gt;&gt; np.diff(x) 
    array([ 1,  2,  3, -7]) 
    &gt;&gt;&gt; np.diff(x, n=2) 
    array([  1,   1, -10]) 
 
    &gt;&gt;&gt; x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]]) 
    &gt;&gt;&gt; np.diff(x) 
    array([[2, 3, 4], 
           [5, 1, 2]]) 
    &gt;&gt;&gt; np.diff(x, axis=0) 
    array([[-1,  2,  0, -2]]) 
 
    &gt;&gt;&gt; x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64) 
    &gt;&gt;&gt; np.diff(x) 
    array([1, 1], dtype='timedelta64[D]') 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">n </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">a</span>
    <span class="s0">if </span><span class="s1">n </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">&quot;order must be non-negative but got &quot; </span><span class="s2">+ </span><span class="s1">repr</span><span class="s2">(</span><span class="s1">n</span><span class="s2">))</span>

    <span class="s1">a </span><span class="s2">= </span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
    <span class="s1">nd </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim</span>
    <span class="s0">if </span><span class="s1">nd </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;diff requires input that is at least one dimensional&quot;</span><span class="s2">)</span>
    <span class="s1">axis </span><span class="s2">= </span><span class="s1">normalize_axis_index</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">nd</span><span class="s2">)</span>

    <span class="s1">combined </span><span class="s2">= []</span>
    <span class="s0">if </span><span class="s1">prepend </span><span class="s0">is not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">_NoValue</span><span class="s2">:</span>
        <span class="s1">prepend </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">prepend</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">prepend</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">shape </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
            <span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s5">1</span>
            <span class="s1">prepend </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">prepend</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">))</span>
        <span class="s1">combined</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">prepend</span><span class="s2">)</span>

    <span class="s1">combined</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">append </span><span class="s0">is not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">_NoValue</span><span class="s2">:</span>
        <span class="s1">append </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">append</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">append</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">shape </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
            <span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s5">1</span>
            <span class="s1">append </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">append</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">))</span>
        <span class="s1">combined</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">append</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">combined</span><span class="s2">) &gt; </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">combined</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)</span>

    <span class="s1">slice1 </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)] * </span><span class="s1">nd</span>
    <span class="s1">slice2 </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)] * </span><span class="s1">nd</span>
    <span class="s1">slice1</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
    <span class="s1">slice2</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s1">slice1 </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice1</span><span class="s2">)</span>
    <span class="s1">slice2 </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice2</span><span class="s2">)</span>

    <span class="s1">op </span><span class="s2">= </span><span class="s1">not_equal </span><span class="s0">if </span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool </span><span class="s0">else </span><span class="s1">subtract</span>
    <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">n</span><span class="s2">):</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">op</span><span class="s2">(</span><span class="s1">a</span><span class="s2">[</span><span class="s1">slice1</span><span class="s2">], </span><span class="s1">a</span><span class="s2">[</span><span class="s1">slice2</span><span class="s2">])</span>

    <span class="s0">return </span><span class="s1">a</span>


<span class="s0">def </span><span class="s1">_interp_dispatcher</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">xp</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">, </span><span class="s1">left</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">right</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">period</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">xp</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_interp_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">interp</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">xp</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">, </span><span class="s1">left</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">right</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">period</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    One-dimensional linear interpolation for monotonically increasing sample points. 
 
    Returns the one-dimensional piecewise linear interpolant to a function 
    with given discrete data points (`xp`, `fp`), evaluated at `x`. 
 
    Parameters 
    ---------- 
    x : array_like 
        The x-coordinates at which to evaluate the interpolated values. 
 
    xp : 1-D sequence of floats 
        The x-coordinates of the data points, must be increasing if argument 
        `period` is not specified. Otherwise, `xp` is internally sorted after 
        normalizing the periodic boundaries with ``xp = xp % period``. 
 
    fp : 1-D sequence of float or complex 
        The y-coordinates of the data points, same length as `xp`. 
 
    left : optional float or complex corresponding to fp 
        Value to return for `x &lt; xp[0]`, default is `fp[0]`. 
 
    right : optional float or complex corresponding to fp 
        Value to return for `x &gt; xp[-1]`, default is `fp[-1]`. 
 
    period : None or float, optional 
        A period for the x-coordinates. This parameter allows the proper 
        interpolation of angular x-coordinates. Parameters `left` and `right` 
        are ignored if `period` is specified. 
 
        .. versionadded:: 1.10.0 
 
    Returns 
    ------- 
    y : float or complex (corresponding to fp) or ndarray 
        The interpolated values, same shape as `x`. 
 
    Raises 
    ------ 
    ValueError 
        If `xp` and `fp` have different length 
        If `xp` or `fp` are not 1-D sequences 
        If `period == 0` 
 
    See Also 
    -------- 
    scipy.interpolate 
 
    Warnings 
    -------- 
    The x-coordinate sequence is expected to be increasing, but this is not 
    explicitly enforced.  However, if the sequence `xp` is non-increasing, 
    interpolation results are meaningless. 
 
    Note that, since NaN is unsortable, `xp` also cannot contain NaNs. 
 
    A simple check for `xp` being strictly increasing is:: 
 
        np.all(np.diff(xp) &gt; 0) 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; xp = [1, 2, 3] 
    &gt;&gt;&gt; fp = [3, 2, 0] 
    &gt;&gt;&gt; np.interp(2.5, xp, fp) 
    1.0 
    &gt;&gt;&gt; np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp) 
    array([3.  , 3.  , 2.5 , 0.56, 0.  ]) 
    &gt;&gt;&gt; UNDEF = -99.0 
    &gt;&gt;&gt; np.interp(3.14, xp, fp, right=UNDEF) 
    -99.0 
 
    Plot an interpolant to the sine function: 
 
    &gt;&gt;&gt; x = np.linspace(0, 2*np.pi, 10) 
    &gt;&gt;&gt; y = np.sin(x) 
    &gt;&gt;&gt; xvals = np.linspace(0, 2*np.pi, 50) 
    &gt;&gt;&gt; yinterp = np.interp(xvals, x, y) 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.plot(x, y, 'o') 
    [&lt;matplotlib.lines.Line2D object at 0x...&gt;] 
    &gt;&gt;&gt; plt.plot(xvals, yinterp, '-x') 
    [&lt;matplotlib.lines.Line2D object at 0x...&gt;] 
    &gt;&gt;&gt; plt.show() 
 
    Interpolation with periodic x-coordinates: 
 
    &gt;&gt;&gt; x = [-180, -170, -185, 185, -10, -5, 0, 365] 
    &gt;&gt;&gt; xp = [190, -190, 350, -350] 
    &gt;&gt;&gt; fp = [5, 10, 3, 4] 
    &gt;&gt;&gt; np.interp(x, xp, fp, period=360) 
    array([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75]) 
 
    Complex interpolation: 
 
    &gt;&gt;&gt; x = [1.5, 4.0] 
    &gt;&gt;&gt; xp = [2,3,5] 
    &gt;&gt;&gt; fp = [1.0j, 0, 2+3j] 
    &gt;&gt;&gt; np.interp(x, xp, fp) 
    array([0.+1.j , 1.+1.5j]) 
 
    &quot;&quot;&quot;</span>

    <span class="s1">fp </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">fp</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">fp</span><span class="s2">):</span>
        <span class="s1">interp_func </span><span class="s2">= </span><span class="s1">compiled_interp_complex</span>
        <span class="s1">input_dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">complex128</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">interp_func </span><span class="s2">= </span><span class="s1">compiled_interp</span>
        <span class="s1">input_dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span>

    <span class="s0">if </span><span class="s1">period </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">period </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;period must be a non-zero value&quot;</span><span class="s2">)</span>
        <span class="s1">period </span><span class="s2">= </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">period</span><span class="s2">)</span>
        <span class="s1">left </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">right </span><span class="s2">= </span><span class="s0">None</span>

        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">xp </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">xp</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">fp </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">fp</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">input_dtype</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">xp</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">1 </span><span class="s0">or </span><span class="s1">fp</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Data points must be 1-D sequences&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">xp</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] != </span><span class="s1">fp</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;fp and xp are not of the same length&quot;</span><span class="s2">)</span>
        <span class="s3"># normalizing periodic boundaries</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">x </span><span class="s2">% </span><span class="s1">period</span>
        <span class="s1">xp </span><span class="s2">= </span><span class="s1">xp </span><span class="s2">% </span><span class="s1">period</span>
        <span class="s1">asort_xp </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argsort</span><span class="s2">(</span><span class="s1">xp</span><span class="s2">)</span>
        <span class="s1">xp </span><span class="s2">= </span><span class="s1">xp</span><span class="s2">[</span><span class="s1">asort_xp</span><span class="s2">]</span>
        <span class="s1">fp </span><span class="s2">= </span><span class="s1">fp</span><span class="s2">[</span><span class="s1">asort_xp</span><span class="s2">]</span>
        <span class="s1">xp </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">xp</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">:]-</span><span class="s1">period</span><span class="s2">, </span><span class="s1">xp</span><span class="s2">, </span><span class="s1">xp</span><span class="s2">[</span><span class="s5">0</span><span class="s2">:</span><span class="s5">1</span><span class="s2">]+</span><span class="s1">period</span><span class="s2">))</span>
        <span class="s1">fp </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">fp</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">:], </span><span class="s1">fp</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">[</span><span class="s5">0</span><span class="s2">:</span><span class="s5">1</span><span class="s2">]))</span>

    <span class="s0">return </span><span class="s1">interp_func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">xp</span><span class="s2">, </span><span class="s1">fp</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_angle_dispatcher</span><span class="s2">(</span><span class="s1">z</span><span class="s2">, </span><span class="s1">deg</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">z</span><span class="s2">,)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_angle_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">angle</span><span class="s2">(</span><span class="s1">z</span><span class="s2">, </span><span class="s1">deg</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return the angle of the complex argument. 
 
    Parameters 
    ---------- 
    z : array_like 
        A complex number or sequence of complex numbers. 
    deg : bool, optional 
        Return angle in degrees if True, radians if False (default). 
 
    Returns 
    ------- 
    angle : ndarray or scalar 
        The counterclockwise angle from the positive real axis on the complex 
        plane in the range ``(-pi, pi]``, with dtype as numpy.float64. 
 
        .. versionchanged:: 1.16.0 
            This function works on subclasses of ndarray like `ma.array`. 
 
    See Also 
    -------- 
    arctan2 
    absolute 
 
    Notes 
    ----- 
    This function passes the imaginary and real parts of the argument to 
    `arctan2` to compute the result; consequently, it follows the convention 
    of `arctan2` when the magnitude of the argument is zero. See example. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; np.angle([1.0, 1.0j, 1+1j])               # in radians 
    array([ 0.        ,  1.57079633,  0.78539816]) # may vary 
    &gt;&gt;&gt; np.angle(1+1j, deg=True)                  # in degrees 
    45.0 
    &gt;&gt;&gt; np.angle([0., -0., complex(0., -0.), complex(-0., -0.)])  # convention 
    array([ 0.        ,  3.14159265, -0.        , -3.14159265]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">z </span><span class="s2">= </span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">z</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">z</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">complexfloating</span><span class="s2">):</span>
        <span class="s1">zimag </span><span class="s2">= </span><span class="s1">z</span><span class="s2">.</span><span class="s1">imag</span>
        <span class="s1">zreal </span><span class="s2">= </span><span class="s1">z</span><span class="s2">.</span><span class="s1">real</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">zimag </span><span class="s2">= </span><span class="s5">0</span>
        <span class="s1">zreal </span><span class="s2">= </span><span class="s1">z</span>

    <span class="s1">a </span><span class="s2">= </span><span class="s1">arctan2</span><span class="s2">(</span><span class="s1">zimag</span><span class="s2">, </span><span class="s1">zreal</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">deg</span><span class="s2">:</span>
        <span class="s1">a </span><span class="s2">*= </span><span class="s5">180</span><span class="s2">/</span><span class="s1">pi</span>
    <span class="s0">return </span><span class="s1">a</span>


<span class="s0">def </span><span class="s1">_unwrap_dispatcher</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">discont</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *, </span><span class="s1">period</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">p</span><span class="s2">,)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_unwrap_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">unwrap</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">discont</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">, *, </span><span class="s1">period</span><span class="s2">=</span><span class="s5">2</span><span class="s2">*</span><span class="s1">pi</span><span class="s2">):</span>
    <span class="s6">r&quot;&quot;&quot; 
    Unwrap by taking the complement of large deltas with respect to the period. 
 
    This unwraps a signal `p` by changing elements which have an absolute 
    difference from their predecessor of more than ``max(discont, period/2)`` 
    to their `period`-complementary values. 
 
    For the default case where `period` is :math:`2\pi` and `discont` is 
    :math:`\pi`, this unwraps a radian phase `p` such that adjacent differences 
    are never greater than :math:`\pi` by adding :math:`2k\pi` for some 
    integer :math:`k`. 
 
    Parameters 
    ---------- 
    p : array_like 
        Input array. 
    discont : float, optional 
        Maximum discontinuity between values, default is ``period/2``. 
        Values below ``period/2`` are treated as if they were ``period/2``. 
        To have an effect different from the default, `discont` should be 
        larger than ``period/2``. 
    axis : int, optional 
        Axis along which unwrap will operate, default is the last axis. 
    period : float, optional 
        Size of the range over which the input wraps. By default, it is 
        ``2 pi``. 
 
        .. versionadded:: 1.21.0 
 
    Returns 
    ------- 
    out : ndarray 
        Output array. 
 
    See Also 
    -------- 
    rad2deg, deg2rad 
 
    Notes 
    ----- 
    If the discontinuity in `p` is smaller than ``period/2``, 
    but larger than `discont`, no unwrapping is done because taking 
    the complement would only make the discontinuity larger. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; phase = np.linspace(0, np.pi, num=5) 
    &gt;&gt;&gt; phase[3:] += np.pi 
    &gt;&gt;&gt; phase 
    array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531]) # may vary 
    &gt;&gt;&gt; np.unwrap(phase) 
    array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ]) # may vary 
    &gt;&gt;&gt; np.unwrap([0, 1, 2, -1, 0], period=4) 
    array([0, 1, 2, 3, 4]) 
    &gt;&gt;&gt; np.unwrap([ 1, 2, 3, 4, 5, 6, 1, 2, 3], period=6) 
    array([1, 2, 3, 4, 5, 6, 7, 8, 9]) 
    &gt;&gt;&gt; np.unwrap([2, 3, 4, 5, 2, 3, 4, 5], period=4) 
    array([2, 3, 4, 5, 6, 7, 8, 9]) 
    &gt;&gt;&gt; phase_deg = np.mod(np.linspace(0 ,720, 19), 360) - 180 
    &gt;&gt;&gt; np.unwrap(phase_deg, period=360) 
    array([-180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140., 
            180.,  220.,  260.,  300.,  340.,  380.,  420.,  460.,  500., 
            540.]) 
    &quot;&quot;&quot;</span>
    <span class="s1">p </span><span class="s2">= </span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>
    <span class="s1">nd </span><span class="s2">= </span><span class="s1">p</span><span class="s2">.</span><span class="s1">ndim</span>
    <span class="s1">dd </span><span class="s2">= </span><span class="s1">diff</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">discont </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">discont </span><span class="s2">= </span><span class="s1">period</span><span class="s2">/</span><span class="s5">2</span>
    <span class="s1">slice1 </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)]*</span><span class="s1">nd     </span><span class="s3"># full slices</span>
    <span class="s1">slice1</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
    <span class="s1">slice1 </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice1</span><span class="s2">)</span>
    <span class="s1">dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">result_type</span><span class="s2">(</span><span class="s1">dd</span><span class="s2">, </span><span class="s1">period</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">integer</span><span class="s2">):</span>
        <span class="s1">interval_high</span><span class="s2">, </span><span class="s1">rem </span><span class="s2">= </span><span class="s1">divmod</span><span class="s2">(</span><span class="s1">period</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)</span>
        <span class="s1">boundary_ambiguous </span><span class="s2">= </span><span class="s1">rem </span><span class="s2">== </span><span class="s5">0</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">interval_high </span><span class="s2">= </span><span class="s1">period </span><span class="s2">/ </span><span class="s5">2</span>
        <span class="s1">boundary_ambiguous </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s1">interval_low </span><span class="s2">= -</span><span class="s1">interval_high</span>
    <span class="s1">ddmod </span><span class="s2">= </span><span class="s1">mod</span><span class="s2">(</span><span class="s1">dd </span><span class="s2">- </span><span class="s1">interval_low</span><span class="s2">, </span><span class="s1">period</span><span class="s2">) + </span><span class="s1">interval_low</span>
    <span class="s0">if </span><span class="s1">boundary_ambiguous</span><span class="s2">:</span>
        <span class="s3"># for `mask = (abs(dd) == period/2)`, the above line made</span>
        <span class="s3"># `ddmod[mask] == -period/2`. correct these such that</span>
        <span class="s3"># `ddmod[mask] == sign(dd[mask])*period/2`.</span>
        <span class="s1">_nx</span><span class="s2">.</span><span class="s1">copyto</span><span class="s2">(</span><span class="s1">ddmod</span><span class="s2">, </span><span class="s1">interval_high</span><span class="s2">,</span>
                   <span class="s1">where</span><span class="s2">=(</span><span class="s1">ddmod </span><span class="s2">== </span><span class="s1">interval_low</span><span class="s2">) &amp; (</span><span class="s1">dd </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">))</span>
    <span class="s1">ph_correct </span><span class="s2">= </span><span class="s1">ddmod </span><span class="s2">- </span><span class="s1">dd</span>
    <span class="s1">_nx</span><span class="s2">.</span><span class="s1">copyto</span><span class="s2">(</span><span class="s1">ph_correct</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">where</span><span class="s2">=</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">dd</span><span class="s2">) &lt; </span><span class="s1">discont</span><span class="s2">)</span>
    <span class="s1">up </span><span class="s2">= </span><span class="s1">array</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">up</span><span class="s2">[</span><span class="s1">slice1</span><span class="s2">] = </span><span class="s1">p</span><span class="s2">[</span><span class="s1">slice1</span><span class="s2">] + </span><span class="s1">ph_correct</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">up</span>


<span class="s0">def </span><span class="s1">_sort_complex</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">a</span><span class="s2">,)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_sort_complex</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">sort_complex</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Sort a complex array using the real part first, then the imaginary part. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array 
 
    Returns 
    ------- 
    out : complex ndarray 
        Always returns a sorted complex array. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; np.sort_complex([5, 3, 6, 2, 1]) 
    array([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j]) 
 
    &gt;&gt;&gt; np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j]) 
    array([1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">b </span><span class="s2">= </span><span class="s1">array</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s1">b</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">()</span>
    <span class="s0">if not </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">b</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">complexfloating</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">b</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char </span><span class="s0">in </span><span class="s4">'bhBH'</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">b</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s4">'F'</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">b</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char </span><span class="s2">== </span><span class="s4">'g'</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">b</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s4">'G'</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">b</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s4">'D'</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">b</span>


<span class="s0">def </span><span class="s1">_trim_zeros</span><span class="s2">(</span><span class="s1">filt</span><span class="s2">, </span><span class="s1">trim</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">filt</span><span class="s2">,)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_trim_zeros</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">trim_zeros</span><span class="s2">(</span><span class="s1">filt</span><span class="s2">, </span><span class="s1">trim</span><span class="s2">=</span><span class="s4">'fb'</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Trim the leading and/or trailing zeros from a 1-D array or sequence. 
 
    Parameters 
    ---------- 
    filt : 1-D array or sequence 
        Input array. 
    trim : str, optional 
        A string with 'f' representing trim from front and 'b' to trim from 
        back. Default is 'fb', trim zeros from both front and back of the 
        array. 
 
    Returns 
    ------- 
    trimmed : 1-D array or sequence 
        The result of trimming the input. The input data type is preserved. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0)) 
    &gt;&gt;&gt; np.trim_zeros(a) 
    array([1, 2, 3, 0, 2, 1]) 
 
    &gt;&gt;&gt; np.trim_zeros(a, 'b') 
    array([0, 0, 0, ..., 0, 2, 1]) 
 
    The input data type is preserved, list/tuple in means list/tuple out. 
 
    &gt;&gt;&gt; np.trim_zeros([0, 1, 2, 0]) 
    [1, 2] 
 
    &quot;&quot;&quot;</span>

    <span class="s1">first </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s1">trim </span><span class="s2">= </span><span class="s1">trim</span><span class="s2">.</span><span class="s1">upper</span><span class="s2">()</span>
    <span class="s0">if </span><span class="s4">'F' </span><span class="s0">in </span><span class="s1">trim</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">filt</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">i </span><span class="s2">!= </span><span class="s5">0.</span><span class="s2">:</span>
                <span class="s0">break</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">first </span><span class="s2">= </span><span class="s1">first </span><span class="s2">+ </span><span class="s5">1</span>
    <span class="s1">last </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">filt</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s4">'B' </span><span class="s0">in </span><span class="s1">trim</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">filt</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">]:</span>
            <span class="s0">if </span><span class="s1">i </span><span class="s2">!= </span><span class="s5">0.</span><span class="s2">:</span>
                <span class="s0">break</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">last </span><span class="s2">= </span><span class="s1">last </span><span class="s2">- </span><span class="s5">1</span>
    <span class="s0">return </span><span class="s1">filt</span><span class="s2">[</span><span class="s1">first</span><span class="s2">:</span><span class="s1">last</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">_extract_dispatcher</span><span class="s2">(</span><span class="s1">condition</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">condition</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_extract_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">extract</span><span class="s2">(</span><span class="s1">condition</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return the elements of an array that satisfy some condition. 
 
    This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If 
    `condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``. 
 
    Note that `place` does the exact opposite of `extract`. 
 
    Parameters 
    ---------- 
    condition : array_like 
        An array whose nonzero or True entries indicate the elements of `arr` 
        to extract. 
    arr : array_like 
        Input array of the same size as `condition`. 
 
    Returns 
    ------- 
    extract : ndarray 
        Rank 1 array of values from `arr` where `condition` is True. 
 
    See Also 
    -------- 
    take, put, copyto, compress, place 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; arr = np.arange(12).reshape((3, 4)) 
    &gt;&gt;&gt; arr 
    array([[ 0,  1,  2,  3], 
           [ 4,  5,  6,  7], 
           [ 8,  9, 10, 11]]) 
    &gt;&gt;&gt; condition = np.mod(arr, 3)==0 
    &gt;&gt;&gt; condition 
    array([[ True, False, False,  True], 
           [False, False,  True, False], 
           [False,  True, False, False]]) 
    &gt;&gt;&gt; np.extract(condition, arr) 
    array([0, 3, 6, 9]) 
 
 
    If `condition` is boolean: 
 
    &gt;&gt;&gt; arr[condition] 
    array([0, 3, 6, 9]) 
 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span><span class="s1">ravel</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">), </span><span class="s1">nonzero</span><span class="s2">(</span><span class="s1">ravel</span><span class="s2">(</span><span class="s1">condition</span><span class="s2">))[</span><span class="s5">0</span><span class="s2">])</span>


<span class="s0">def </span><span class="s1">_place_dispatcher</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">vals</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">vals</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_place_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">place</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">vals</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Change elements of an array based on conditional and input values. 
 
    Similar to ``np.copyto(arr, vals, where=mask)``, the difference is that 
    `place` uses the first N elements of `vals`, where N is the number of 
    True values in `mask`, while `copyto` uses the elements where `mask` 
    is True. 
 
    Note that `extract` does the exact opposite of `place`. 
 
    Parameters 
    ---------- 
    arr : ndarray 
        Array to put data into. 
    mask : array_like 
        Boolean mask array. Must have the same size as `a`. 
    vals : 1-D sequence 
        Values to put into `a`. Only the first N elements are used, where 
        N is the number of True values in `mask`. If `vals` is smaller 
        than N, it will be repeated, and if elements of `a` are to be masked, 
        this sequence must be non-empty. 
 
    See Also 
    -------- 
    copyto, put, take, extract 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; arr = np.arange(6).reshape(2, 3) 
    &gt;&gt;&gt; np.place(arr, arr&gt;2, [44, 55]) 
    &gt;&gt;&gt; arr 
    array([[ 0,  1,  2], 
           [44, 55, 44]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">_place</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">vals</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">disp</span><span class="s2">(</span><span class="s1">mesg</span><span class="s2">, </span><span class="s1">device</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">linefeed</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Display a message on a device. 
 
    .. deprecated:: 2.0 
        Use your own printing function instead. 
 
    Parameters 
    ---------- 
    mesg : str 
        Message to display. 
    device : object 
        Device to write message. If None, defaults to ``sys.stdout`` which is 
        very similar to ``print``. `device` needs to have ``write()`` and 
        ``flush()`` methods. 
    linefeed : bool, optional 
        Option whether to print a line feed or not. Defaults to True. 
 
    Raises 
    ------ 
    AttributeError 
        If `device` does not have a ``write()`` or ``flush()`` method. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
 
    Besides ``sys.stdout``, a file-like object can also be used as it has 
    both required methods: 
 
    &gt;&gt;&gt; from io import StringIO 
    &gt;&gt;&gt; buf = StringIO() 
    &gt;&gt;&gt; np.disp('&quot;Display&quot; in a file', device=buf) 
    &gt;&gt;&gt; buf.getvalue() 
    '&quot;Display&quot; in a file\\n' 
 
    &quot;&quot;&quot;</span>

    <span class="s3"># Deprecated in NumPy 2.0, 2023-07-11</span>
    <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
        <span class="s4">&quot;`disp` is deprecated, &quot;</span>
        <span class="s4">&quot;use your own printing function instead. &quot;</span>
        <span class="s4">&quot;(deprecated in NumPy 2.0)&quot;</span><span class="s2">,</span>
        <span class="s1">DeprecationWarning</span><span class="s2">,</span>
        <span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span>
    <span class="s2">)    </span>

    <span class="s0">if </span><span class="s1">device </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">device </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">stdout</span>
    <span class="s0">if </span><span class="s1">linefeed</span><span class="s2">:</span>
        <span class="s1">device</span><span class="s2">.</span><span class="s1">write</span><span class="s2">(</span><span class="s4">'%s</span><span class="s0">\n</span><span class="s4">' </span><span class="s2">% </span><span class="s1">mesg</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">device</span><span class="s2">.</span><span class="s1">write</span><span class="s2">(</span><span class="s4">'%s' </span><span class="s2">% </span><span class="s1">mesg</span><span class="s2">)</span>
    <span class="s1">device</span><span class="s2">.</span><span class="s1">flush</span><span class="s2">()</span>
    <span class="s0">return</span>


<span class="s3"># See https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html</span>
<span class="s1">_DIMENSION_NAME </span><span class="s2">= </span><span class="s4">r'\w+'</span>
<span class="s1">_CORE_DIMENSION_LIST </span><span class="s2">= </span><span class="s4">'(?:{0:}(?:,{0:})*)?'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">_DIMENSION_NAME</span><span class="s2">)</span>
<span class="s1">_ARGUMENT </span><span class="s2">= </span><span class="s4">r'\({}\)'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">_CORE_DIMENSION_LIST</span><span class="s2">)</span>
<span class="s1">_ARGUMENT_LIST </span><span class="s2">= </span><span class="s4">'{0:}(?:,{0:})*'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">_ARGUMENT</span><span class="s2">)</span>
<span class="s1">_SIGNATURE </span><span class="s2">= </span><span class="s4">'^{0:}-&gt;{0:}$'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">_ARGUMENT_LIST</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_parse_gufunc_signature</span><span class="s2">(</span><span class="s1">signature</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Parse string signatures for a generalized universal function. 
 
    Arguments 
    --------- 
    signature : string 
        Generalized universal function signature, e.g., ``(m,n),(n,p)-&gt;(m,p)`` 
        for ``np.matmul``. 
 
    Returns 
    ------- 
    Tuple of input and output core dimensions parsed from the signature, each 
    of the form List[Tuple[str, ...]]. 
    &quot;&quot;&quot;</span>
    <span class="s1">signature </span><span class="s2">= </span><span class="s1">re</span><span class="s2">.</span><span class="s1">sub</span><span class="s2">(</span><span class="s4">r'\s+'</span><span class="s2">, </span><span class="s4">''</span><span class="s2">, </span><span class="s1">signature</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">re</span><span class="s2">.</span><span class="s1">match</span><span class="s2">(</span><span class="s1">_SIGNATURE</span><span class="s2">, </span><span class="s1">signature</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">'not a valid gufunc signature: {}'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">signature</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s1">tuple</span><span class="s2">([</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">re</span><span class="s2">.</span><span class="s1">findall</span><span class="s2">(</span><span class="s1">_DIMENSION_NAME</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">))</span>
                  <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">re</span><span class="s2">.</span><span class="s1">findall</span><span class="s2">(</span><span class="s1">_ARGUMENT</span><span class="s2">, </span><span class="s1">arg_list</span><span class="s2">)]</span>
                 <span class="s0">for </span><span class="s1">arg_list </span><span class="s0">in </span><span class="s1">signature</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s4">'-&gt;'</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">_update_dim_sizes</span><span class="s2">(</span><span class="s1">dim_sizes</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">core_dims</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Incrementally check and update core dimension sizes for a single argument. 
 
    Arguments 
    --------- 
    dim_sizes : Dict[str, int] 
        Sizes of existing core dimensions. Will be updated in-place. 
    arg : ndarray 
        Argument to examine. 
    core_dims : Tuple[str, ...] 
        Core dimensions for this argument. 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">core_dims</span><span class="s2">:</span>
        <span class="s0">return</span>

    <span class="s1">num_core_dims </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">core_dims</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&lt; </span><span class="s1">num_core_dims</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">'%d-dimensional argument does not have enough '</span>
            <span class="s4">'dimensions for all core dimensions %r'</span>
            <span class="s2">% (</span><span class="s1">arg</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">core_dims</span><span class="s2">))</span>

    <span class="s1">core_shape </span><span class="s2">= </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s1">num_core_dims</span><span class="s2">:]</span>
    <span class="s0">for </span><span class="s1">dim</span><span class="s2">, </span><span class="s1">size </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">core_dims</span><span class="s2">, </span><span class="s1">core_shape</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">dim </span><span class="s0">in </span><span class="s1">dim_sizes</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">size </span><span class="s2">!= </span><span class="s1">dim_sizes</span><span class="s2">[</span><span class="s1">dim</span><span class="s2">]:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s4">'inconsistent size for core dimension %r: %r vs %r'</span>
                    <span class="s2">% (</span><span class="s1">dim</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">dim_sizes</span><span class="s2">[</span><span class="s1">dim</span><span class="s2">]))</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">dim_sizes</span><span class="s2">[</span><span class="s1">dim</span><span class="s2">] = </span><span class="s1">size</span>


<span class="s0">def </span><span class="s1">_parse_input_dimensions</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">input_core_dims</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Parse broadcast and core dimensions for vectorize with a signature. 
 
    Arguments 
    --------- 
    args : Tuple[ndarray, ...] 
        Tuple of input arguments to examine. 
    input_core_dims : List[Tuple[str, ...]] 
        List of core dimensions corresponding to each input. 
 
    Returns 
    ------- 
    broadcast_shape : Tuple[int, ...] 
        Common shape to broadcast all non-core dimensions to. 
    dim_sizes : Dict[str, int] 
        Common sizes for named core dimensions. 
    &quot;&quot;&quot;</span>
    <span class="s1">broadcast_args </span><span class="s2">= []</span>
    <span class="s1">dim_sizes </span><span class="s2">= {}</span>
    <span class="s0">for </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">core_dims </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">input_core_dims</span><span class="s2">):</span>
        <span class="s1">_update_dim_sizes</span><span class="s2">(</span><span class="s1">dim_sizes</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">core_dims</span><span class="s2">)</span>
        <span class="s1">ndim </span><span class="s2">= </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">- </span><span class="s1">len</span><span class="s2">(</span><span class="s1">core_dims</span><span class="s2">)</span>
        <span class="s1">dummy_array </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">stride_tricks</span><span class="s2">.</span><span class="s1">as_strided</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[:</span><span class="s1">ndim</span><span class="s2">])</span>
        <span class="s1">broadcast_args</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">dummy_array</span><span class="s2">)</span>
    <span class="s1">broadcast_shape </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">_stride_tricks_impl</span><span class="s2">.</span><span class="s1">_broadcast_shape</span><span class="s2">(</span>
        <span class="s2">*</span><span class="s1">broadcast_args</span>
    <span class="s2">)</span>
    <span class="s0">return </span><span class="s1">broadcast_shape</span><span class="s2">, </span><span class="s1">dim_sizes</span>


<span class="s0">def </span><span class="s1">_calculate_shapes</span><span class="s2">(</span><span class="s1">broadcast_shape</span><span class="s2">, </span><span class="s1">dim_sizes</span><span class="s2">, </span><span class="s1">list_of_core_dims</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Helper for calculating broadcast shapes with core dimensions.&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s2">[</span><span class="s1">broadcast_shape </span><span class="s2">+ </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">dim_sizes</span><span class="s2">[</span><span class="s1">dim</span><span class="s2">] </span><span class="s0">for </span><span class="s1">dim </span><span class="s0">in </span><span class="s1">core_dims</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">core_dims </span><span class="s0">in </span><span class="s1">list_of_core_dims</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">_create_arrays</span><span class="s2">(</span><span class="s1">broadcast_shape</span><span class="s2">, </span><span class="s1">dim_sizes</span><span class="s2">, </span><span class="s1">list_of_core_dims</span><span class="s2">, </span><span class="s1">dtypes</span><span class="s2">,</span>
                   <span class="s1">results</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Helper for creating output arrays in vectorize.&quot;&quot;&quot;</span>
    <span class="s1">shapes </span><span class="s2">= </span><span class="s1">_calculate_shapes</span><span class="s2">(</span><span class="s1">broadcast_shape</span><span class="s2">, </span><span class="s1">dim_sizes</span><span class="s2">, </span><span class="s1">list_of_core_dims</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">dtypes </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">dtypes </span><span class="s2">= [</span><span class="s0">None</span><span class="s2">] * </span><span class="s1">len</span><span class="s2">(</span><span class="s1">shapes</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">results </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">arrays </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">=</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
                       <span class="s0">for </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">shapes</span><span class="s2">, </span><span class="s1">dtypes</span><span class="s2">))</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">arrays </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
                       <span class="s0">for </span><span class="s1">result</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span>
                       <span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">results</span><span class="s2">, </span><span class="s1">shapes</span><span class="s2">, </span><span class="s1">dtypes</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s1">arrays</span>


<span class="s0">def </span><span class="s1">_get_vectorize_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char </span><span class="s0">in </span><span class="s4">&quot;SU&quot;</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span>
    <span class="s0">return </span><span class="s1">dtype</span>


<span class="s2">@</span><span class="s1">set_module</span><span class="s2">(</span><span class="s4">'numpy'</span><span class="s2">)</span>
<span class="s0">class </span><span class="s1">vectorize</span><span class="s2">:</span>
    <span class="s6">&quot;&quot;&quot; 
    vectorize(pyfunc=np._NoValue, otypes=None, doc=None, excluded=None, 
    cache=False, signature=None) 
 
    Returns an object that acts like pyfunc, but takes arrays as input. 
 
    Define a vectorized function which takes a nested sequence of objects or 
    numpy arrays as inputs and returns a single numpy array or a tuple of numpy 
    arrays. The vectorized function evaluates `pyfunc` over successive tuples 
    of the input arrays like the python map function, except it uses the 
    broadcasting rules of numpy. 
 
    The data type of the output of `vectorized` is determined by calling 
    the function with the first element of the input.  This can be avoided 
    by specifying the `otypes` argument. 
 
    Parameters 
    ---------- 
    pyfunc : callable, optional 
        A python function or method. 
        Can be omitted to produce a decorator with keyword arguments. 
    otypes : str or list of dtypes, optional 
        The output data type. It must be specified as either a string of 
        typecode characters or a list of data type specifiers. There should 
        be one data type specifier for each output. 
    doc : str, optional 
        The docstring for the function. If None, the docstring will be the 
        ``pyfunc.__doc__``. 
    excluded : set, optional 
        Set of strings or integers representing the positional or keyword 
        arguments for which the function will not be vectorized.  These will be 
        passed directly to `pyfunc` unmodified. 
 
        .. versionadded:: 1.7.0 
 
    cache : bool, optional 
        If `True`, then cache the first function call that determines the number 
        of outputs if `otypes` is not provided. 
 
        .. versionadded:: 1.7.0 
 
    signature : string, optional 
        Generalized universal function signature, e.g., ``(m,n),(n)-&gt;(m)`` for 
        vectorized matrix-vector multiplication. If provided, ``pyfunc`` will 
        be called with (and expected to return) arrays with shapes given by the 
        size of corresponding core dimensions. By default, ``pyfunc`` is 
        assumed to take scalars as input and output. 
 
        .. versionadded:: 1.12.0 
 
    Returns 
    ------- 
    out : callable 
        A vectorized function if ``pyfunc`` was provided, 
        a decorator otherwise. 
 
    See Also 
    -------- 
    frompyfunc : Takes an arbitrary Python function and returns a ufunc 
 
    Notes 
    ----- 
    The `vectorize` function is provided primarily for convenience, not for 
    performance. The implementation is essentially a for loop. 
 
    If `otypes` is not specified, then a call to the function with the 
    first argument will be used to determine the number of outputs.  The 
    results of this call will be cached if `cache` is `True` to prevent 
    calling the function twice.  However, to implement the cache, the 
    original function must be wrapped which will slow down subsequent 
    calls, so only do this if your function is expensive. 
 
    The new keyword argument interface and `excluded` argument support 
    further degrades performance. 
 
    References 
    ---------- 
    .. [1] :doc:`/reference/c-api/generalized-ufuncs` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; def myfunc(a, b): 
    ...     &quot;Return a-b if a&gt;b, otherwise return a+b&quot; 
    ...     if a &gt; b: 
    ...         return a - b 
    ...     else: 
    ...         return a + b 
 
    &gt;&gt;&gt; vfunc = np.vectorize(myfunc) 
    &gt;&gt;&gt; vfunc([1, 2, 3, 4], 2) 
    array([3, 4, 1, 2]) 
 
    The docstring is taken from the input function to `vectorize` unless it 
    is specified: 
 
    &gt;&gt;&gt; vfunc.__doc__ 
    'Return a-b if a&gt;b, otherwise return a+b' 
    &gt;&gt;&gt; vfunc = np.vectorize(myfunc, doc='Vectorized `myfunc`') 
    &gt;&gt;&gt; vfunc.__doc__ 
    'Vectorized `myfunc`' 
 
    The output type is determined by evaluating the first element of the input, 
    unless it is specified: 
 
    &gt;&gt;&gt; out = vfunc([1, 2, 3, 4], 2) 
    &gt;&gt;&gt; type(out[0]) 
    &lt;class 'numpy.int64'&gt; 
    &gt;&gt;&gt; vfunc = np.vectorize(myfunc, otypes=[float]) 
    &gt;&gt;&gt; out = vfunc([1, 2, 3, 4], 2) 
    &gt;&gt;&gt; type(out[0]) 
    &lt;class 'numpy.float64'&gt; 
 
    The `excluded` argument can be used to prevent vectorizing over certain 
    arguments.  This can be useful for array-like arguments of a fixed length 
    such as the coefficients for a polynomial as in `polyval`: 
 
    &gt;&gt;&gt; def mypolyval(p, x): 
    ...     _p = list(p) 
    ...     res = _p.pop(0) 
    ...     while _p: 
    ...         res = res*x + _p.pop(0) 
    ...     return res 
    &gt;&gt;&gt; vpolyval = np.vectorize(mypolyval, excluded=['p']) 
    &gt;&gt;&gt; vpolyval(p=[1, 2, 3], x=[0, 1]) 
    array([3, 6]) 
 
    Positional arguments may also be excluded by specifying their position: 
 
    &gt;&gt;&gt; vpolyval.excluded.add(0) 
    &gt;&gt;&gt; vpolyval([1, 2, 3], x=[0, 1]) 
    array([3, 6]) 
 
    The `signature` argument allows for vectorizing functions that act on 
    non-scalar arrays of fixed length. For example, you can use it for a 
    vectorized calculation of Pearson correlation coefficient and its p-value: 
 
    &gt;&gt;&gt; import scipy.stats 
    &gt;&gt;&gt; pearsonr = np.vectorize(scipy.stats.pearsonr, 
    ...                 signature='(n),(n)-&gt;(),()') 
    &gt;&gt;&gt; pearsonr([[0, 1, 2, 3]], [[1, 2, 3, 4], [4, 3, 2, 1]]) 
    (array([ 1., -1.]), array([ 0.,  0.])) 
 
    Or for a vectorized convolution: 
 
    &gt;&gt;&gt; convolve = np.vectorize(np.convolve, signature='(n),(m)-&gt;(k)') 
    &gt;&gt;&gt; convolve(np.eye(4), [1, 2, 1]) 
    array([[1., 2., 1., 0., 0., 0.], 
           [0., 1., 2., 1., 0., 0.], 
           [0., 0., 1., 2., 1., 0.], 
           [0., 0., 0., 1., 2., 1.]]) 
 
    Decorator syntax is supported.  The decorator can be called as 
    a function to provide keyword arguments: 
 
    &gt;&gt;&gt; @np.vectorize 
    ... def identity(x): 
    ...     return x 
    ... 
    &gt;&gt;&gt; identity([0, 1, 2]) 
    array([0, 1, 2]) 
    &gt;&gt;&gt; @np.vectorize(otypes=[float]) 
    ... def as_float(x): 
    ...     return x 
    ... 
    &gt;&gt;&gt; as_float([0, 1, 2]) 
    array([0., 1., 2.]) 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">pyfunc</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">_NoValue</span><span class="s2">, </span><span class="s1">otypes</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                 <span class="s1">excluded</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">signature</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>

        <span class="s0">if </span><span class="s2">(</span><span class="s1">pyfunc </span><span class="s2">!= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">_NoValue</span><span class="s2">) </span><span class="s0">and </span><span class="s2">(</span><span class="s0">not </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">pyfunc</span><span class="s2">)):</span>
            <span class="s3">#Splitting the error message to keep</span>
            <span class="s3">#the length below 79 characters.</span>
            <span class="s1">part1 </span><span class="s2">= </span><span class="s4">&quot;When used as a decorator, &quot;</span>
            <span class="s1">part2 </span><span class="s2">= </span><span class="s4">&quot;only accepts keyword arguments.&quot;</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">part1 </span><span class="s2">+ </span><span class="s1">part2</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">pyfunc </span><span class="s2">= </span><span class="s1">pyfunc</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">cache </span><span class="s2">= </span><span class="s1">cache</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">signature </span><span class="s2">= </span><span class="s1">signature</span>
        <span class="s0">if </span><span class="s1">pyfunc </span><span class="s2">!= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">_NoValue </span><span class="s0">and </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">pyfunc</span><span class="s2">, </span><span class="s4">'__name__'</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s2">= </span><span class="s1">pyfunc</span><span class="s2">.</span><span class="s1">__name__</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_ufunc </span><span class="s2">= {}    </span><span class="s3"># Caching to improve default performance</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_doc </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">doc</span>
        <span class="s0">if </span><span class="s1">doc </span><span class="s0">is None and </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">pyfunc</span><span class="s2">, </span><span class="s4">'__doc__'</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">pyfunc</span><span class="s2">.</span><span class="s1">__doc__</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_doc </span><span class="s2">= </span><span class="s1">doc</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">otypes</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s0">for </span><span class="s1">char </span><span class="s0">in </span><span class="s1">otypes</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">char </span><span class="s0">not in </span><span class="s1">typecodes</span><span class="s2">[</span><span class="s4">'All'</span><span class="s2">]:</span>
                    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Invalid otype specified: %s&quot; </span><span class="s2">% (</span><span class="s1">char</span><span class="s2">,))</span>
        <span class="s0">elif </span><span class="s1">iterable</span><span class="s2">(</span><span class="s1">otypes</span><span class="s2">):</span>
            <span class="s1">otypes </span><span class="s2">= [</span><span class="s1">_get_vectorize_dtype</span><span class="s2">(</span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">otypes</span><span class="s2">]</span>
        <span class="s0">elif </span><span class="s1">otypes </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Invalid otype specification&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">otypes </span><span class="s2">= </span><span class="s1">otypes</span>

        <span class="s3"># Excluded variable support</span>
        <span class="s0">if </span><span class="s1">excluded </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">excluded </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">excluded </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">excluded</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">signature </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_in_and_out_core_dims </span><span class="s2">= </span><span class="s1">_parse_gufunc_signature</span><span class="s2">(</span><span class="s1">signature</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_in_and_out_core_dims </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_init_stage_2</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">pyfunc</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s2">= </span><span class="s1">pyfunc</span><span class="s2">.</span><span class="s1">__name__</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">pyfunc </span><span class="s2">= </span><span class="s1">pyfunc</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_doc </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">pyfunc</span><span class="s2">.</span><span class="s1">__doc__</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_doc</span>

    <span class="s0">def </span><span class="s1">_call_as_normal</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot; 
        Return arrays with the results of `pyfunc` broadcast (vectorized) over 
        `args` and `kwargs` not in `excluded`. 
        &quot;&quot;&quot;</span>
        <span class="s1">excluded </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">excluded</span>
        <span class="s0">if not </span><span class="s1">kwargs </span><span class="s0">and not </span><span class="s1">excluded</span><span class="s2">:</span>
            <span class="s1">func </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pyfunc</span>
            <span class="s1">vargs </span><span class="s2">= </span><span class="s1">args</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s3"># The wrapper accepts only positional arguments: we use `names` and</span>
            <span class="s3"># `inds` to mutate `the_args` and `kwargs` to pass to the original</span>
            <span class="s3"># function.</span>
            <span class="s1">nargs </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>

            <span class="s1">names </span><span class="s2">= [</span><span class="s1">_n </span><span class="s0">for </span><span class="s1">_n </span><span class="s0">in </span><span class="s1">kwargs </span><span class="s0">if </span><span class="s1">_n </span><span class="s0">not in </span><span class="s1">excluded</span><span class="s2">]</span>
            <span class="s1">inds </span><span class="s2">= [</span><span class="s1">_i </span><span class="s0">for </span><span class="s1">_i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">nargs</span><span class="s2">) </span><span class="s0">if </span><span class="s1">_i </span><span class="s0">not in </span><span class="s1">excluded</span><span class="s2">]</span>
            <span class="s1">the_args </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>

            <span class="s0">def </span><span class="s1">func</span><span class="s2">(*</span><span class="s1">vargs</span><span class="s2">):</span>
                <span class="s0">for </span><span class="s1">_n</span><span class="s2">, </span><span class="s1">_i </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">inds</span><span class="s2">):</span>
                    <span class="s1">the_args</span><span class="s2">[</span><span class="s1">_i</span><span class="s2">] = </span><span class="s1">vargs</span><span class="s2">[</span><span class="s1">_n</span><span class="s2">]</span>
                <span class="s1">kwargs</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">names</span><span class="s2">, </span><span class="s1">vargs</span><span class="s2">[</span><span class="s1">len</span><span class="s2">(</span><span class="s1">inds</span><span class="s2">):]))</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pyfunc</span><span class="s2">(*</span><span class="s1">the_args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

            <span class="s1">vargs </span><span class="s2">= [</span><span class="s1">args</span><span class="s2">[</span><span class="s1">_i</span><span class="s2">] </span><span class="s0">for </span><span class="s1">_i </span><span class="s0">in </span><span class="s1">inds</span><span class="s2">]</span>
            <span class="s1">vargs</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">([</span><span class="s1">kwargs</span><span class="s2">[</span><span class="s1">_n</span><span class="s2">] </span><span class="s0">for </span><span class="s1">_n </span><span class="s0">in </span><span class="s1">names</span><span class="s2">])</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_vectorize_call</span><span class="s2">(</span><span class="s1">func</span><span class="s2">=</span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">vargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pyfunc </span><span class="s0">is </span><span class="s1">np</span><span class="s2">.</span><span class="s1">_NoValue</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_init_stage_2</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_call_as_normal</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_get_ufunc_and_otypes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Return (ufunc, otypes).&quot;&quot;&quot;</span>
        <span class="s3"># frompyfunc will fail if args is empty</span>
        <span class="s0">if not </span><span class="s1">args</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">'args can not be empty'</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">otypes </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">otypes </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">otypes</span>

            <span class="s3"># self._ufunc is a dictionary whose keys are the number of</span>
            <span class="s3"># arguments (i.e. len(args)) and whose values are ufuncs created</span>
            <span class="s3"># by frompyfunc. len(args) can be different for different calls if</span>
            <span class="s3"># self.pyfunc has parameters with default values.  We only use the</span>
            <span class="s3"># cache when func is self.pyfunc, which occurs when the call uses</span>
            <span class="s3"># only positional arguments and no arguments are excluded.</span>

            <span class="s1">nin </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s1">nout </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">otypes</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">func </span><span class="s0">is not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pyfunc </span><span class="s0">or </span><span class="s1">nin </span><span class="s0">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ufunc</span><span class="s2">:</span>
                <span class="s1">ufunc </span><span class="s2">= </span><span class="s1">frompyfunc</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">nin</span><span class="s2">, </span><span class="s1">nout</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">ufunc </span><span class="s2">= </span><span class="s0">None  </span><span class="s3"># We'll get it from self._ufunc</span>
            <span class="s0">if </span><span class="s1">func </span><span class="s0">is </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pyfunc</span><span class="s2">:</span>
                <span class="s1">ufunc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ufunc</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s1">nin</span><span class="s2">, </span><span class="s1">ufunc</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s3"># Get number of outputs and output types by calling the function on</span>
            <span class="s3"># the first entries of args.  We also cache the result to prevent</span>
            <span class="s3"># the subsequent call when the ufunc is evaluated.</span>
            <span class="s3"># Assumes that ufunc first evaluates the 0th elements in the input</span>
            <span class="s3"># arrays (the input values are not checked to ensure this)</span>
            <span class="s1">args </span><span class="s2">= [</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">) </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">args</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">builtins</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s5">0 </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">args</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">'cannot call `vectorize` on size 0 inputs '</span>
                                 <span class="s4">'unless `otypes` is set'</span><span class="s2">)</span>

            <span class="s1">inputs </span><span class="s2">= [</span><span class="s1">arg</span><span class="s2">.</span><span class="s1">flat</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">args</span><span class="s2">]</span>
            <span class="s1">outputs </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*</span><span class="s1">inputs</span><span class="s2">)</span>

            <span class="s3"># Performance note: profiling indicates that -- for simple</span>
            <span class="s3"># functions at least -- this wrapping can almost double the</span>
            <span class="s3"># execution time.</span>
            <span class="s3"># Hence we make it optional.</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cache</span><span class="s2">:</span>
                <span class="s1">_cache </span><span class="s2">= [</span><span class="s1">outputs</span><span class="s2">]</span>

                <span class="s0">def </span><span class="s1">_func</span><span class="s2">(*</span><span class="s1">vargs</span><span class="s2">):</span>
                    <span class="s0">if </span><span class="s1">_cache</span><span class="s2">:</span>
                        <span class="s0">return </span><span class="s1">_cache</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">()</span>
                    <span class="s0">else</span><span class="s2">:</span>
                        <span class="s0">return </span><span class="s1">func</span><span class="s2">(*</span><span class="s1">vargs</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">_func </span><span class="s2">= </span><span class="s1">func</span>

            <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">outputs</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s1">nout </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">outputs</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">nout </span><span class="s2">= </span><span class="s5">1</span>
                <span class="s1">outputs </span><span class="s2">= (</span><span class="s1">outputs</span><span class="s2">,)</span>

            <span class="s1">otypes </span><span class="s2">= </span><span class="s4">''</span><span class="s2">.</span><span class="s1">join</span><span class="s2">([</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">outputs</span><span class="s2">[</span><span class="s1">_k</span><span class="s2">]).</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span>
                              <span class="s0">for </span><span class="s1">_k </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">nout</span><span class="s2">)])</span>

            <span class="s3"># Performance note: profiling indicates that creating the ufunc is</span>
            <span class="s3"># not a significant cost compared with wrapping so it seems not</span>
            <span class="s3"># worth trying to cache this.</span>
            <span class="s1">ufunc </span><span class="s2">= </span><span class="s1">frompyfunc</span><span class="s2">(</span><span class="s1">_func</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">), </span><span class="s1">nout</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">otypes</span>

    <span class="s0">def </span><span class="s1">_vectorize_call</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Vectorized call to `func` over positional `args`.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">signature </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_vectorize_call_with_signature</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>
        <span class="s0">elif not </span><span class="s1">args</span><span class="s2">:</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">func</span><span class="s2">()</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">ufunc</span><span class="s2">, </span><span class="s1">otypes </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_ufunc_and_otypes</span><span class="s2">(</span><span class="s1">func</span><span class="s2">=</span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">)</span>

            <span class="s3"># Convert args to object arrays first</span>
            <span class="s1">inputs </span><span class="s2">= [</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">object</span><span class="s2">) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args</span><span class="s2">]</span>

            <span class="s1">outputs </span><span class="s2">= </span><span class="s1">ufunc</span><span class="s2">(*</span><span class="s1">inputs</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">nout </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s1">res </span><span class="s2">= </span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">outputs</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">otypes</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">res </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">([</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">t</span><span class="s2">)</span>
                             <span class="s0">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">outputs</span><span class="s2">, </span><span class="s1">otypes</span><span class="s2">)])</span>
        <span class="s0">return </span><span class="s1">res</span>

    <span class="s0">def </span><span class="s1">_vectorize_call_with_signature</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Vectorized call over positional arguments with a signature.&quot;&quot;&quot;</span>
        <span class="s1">input_core_dims</span><span class="s2">, </span><span class="s1">output_core_dims </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_in_and_out_core_dims</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">input_core_dims</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">'wrong number of positional arguments: '</span>
                            <span class="s4">'expected %r, got %r'</span>
                            <span class="s2">% (</span><span class="s1">len</span><span class="s2">(</span><span class="s1">input_core_dims</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)))</span>
        <span class="s1">args </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">) </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">args</span><span class="s2">)</span>

        <span class="s1">broadcast_shape</span><span class="s2">, </span><span class="s1">dim_sizes </span><span class="s2">= </span><span class="s1">_parse_input_dimensions</span><span class="s2">(</span>
            <span class="s1">args</span><span class="s2">, </span><span class="s1">input_core_dims</span><span class="s2">)</span>
        <span class="s1">input_shapes </span><span class="s2">= </span><span class="s1">_calculate_shapes</span><span class="s2">(</span><span class="s1">broadcast_shape</span><span class="s2">, </span><span class="s1">dim_sizes</span><span class="s2">,</span>
                                         <span class="s1">input_core_dims</span><span class="s2">)</span>
        <span class="s1">args </span><span class="s2">= [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">arg</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">subok</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
                <span class="s0">for </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">shape </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">input_shapes</span><span class="s2">)]</span>

        <span class="s1">outputs </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">otypes </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">otypes</span>
        <span class="s1">nout </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">output_core_dims</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndindex</span><span class="s2">(*</span><span class="s1">broadcast_shape</span><span class="s2">):</span>
            <span class="s1">results </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*(</span><span class="s1">arg</span><span class="s2">[</span><span class="s1">index</span><span class="s2">] </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">args</span><span class="s2">))</span>

            <span class="s1">n_results </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">results</span><span class="s2">) </span><span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">results</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">) </span><span class="s0">else </span><span class="s5">1</span>

            <span class="s0">if </span><span class="s1">nout </span><span class="s2">!= </span><span class="s1">n_results</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s4">'wrong number of outputs from pyfunc: expected %r, got %r'</span>
                    <span class="s2">% (</span><span class="s1">nout</span><span class="s2">, </span><span class="s1">n_results</span><span class="s2">))</span>

            <span class="s0">if </span><span class="s1">nout </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s1">results </span><span class="s2">= (</span><span class="s1">results</span><span class="s2">,)</span>

            <span class="s0">if </span><span class="s1">outputs </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s0">for </span><span class="s1">result</span><span class="s2">, </span><span class="s1">core_dims </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">results</span><span class="s2">, </span><span class="s1">output_core_dims</span><span class="s2">):</span>
                    <span class="s1">_update_dim_sizes</span><span class="s2">(</span><span class="s1">dim_sizes</span><span class="s2">, </span><span class="s1">result</span><span class="s2">, </span><span class="s1">core_dims</span><span class="s2">)</span>

                <span class="s1">outputs </span><span class="s2">= </span><span class="s1">_create_arrays</span><span class="s2">(</span><span class="s1">broadcast_shape</span><span class="s2">, </span><span class="s1">dim_sizes</span><span class="s2">,</span>
                                         <span class="s1">output_core_dims</span><span class="s2">, </span><span class="s1">otypes</span><span class="s2">, </span><span class="s1">results</span><span class="s2">)</span>

            <span class="s0">for </span><span class="s1">output</span><span class="s2">, </span><span class="s1">result </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">outputs</span><span class="s2">, </span><span class="s1">results</span><span class="s2">):</span>
                <span class="s1">output</span><span class="s2">[</span><span class="s1">index</span><span class="s2">] = </span><span class="s1">result</span>

        <span class="s0">if </span><span class="s1">outputs </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s3"># did not call the function even once</span>
            <span class="s0">if </span><span class="s1">otypes </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">'cannot call `vectorize` on size 0 inputs '</span>
                                 <span class="s4">'unless `otypes` is set'</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">builtins</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">dim </span><span class="s0">not in </span><span class="s1">dim_sizes</span>
                            <span class="s0">for </span><span class="s1">dims </span><span class="s0">in </span><span class="s1">output_core_dims</span>
                            <span class="s0">for </span><span class="s1">dim </span><span class="s0">in </span><span class="s1">dims</span><span class="s2">):</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">'cannot call `vectorize` with a signature '</span>
                                 <span class="s4">'including new output dimensions on size 0 '</span>
                                 <span class="s4">'inputs'</span><span class="s2">)</span>
            <span class="s1">outputs </span><span class="s2">= </span><span class="s1">_create_arrays</span><span class="s2">(</span><span class="s1">broadcast_shape</span><span class="s2">, </span><span class="s1">dim_sizes</span><span class="s2">,</span>
                                     <span class="s1">output_core_dims</span><span class="s2">, </span><span class="s1">otypes</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">outputs</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] </span><span class="s0">if </span><span class="s1">nout </span><span class="s2">== </span><span class="s5">1 </span><span class="s0">else </span><span class="s1">outputs</span>


<span class="s0">def </span><span class="s1">_cov_dispatcher</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">y</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">rowvar</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">bias</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">ddof</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                    <span class="s1">fweights</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">aweights</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">fweights</span><span class="s2">, </span><span class="s1">aweights</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_cov_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">cov</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">y</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">rowvar</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">bias</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">ddof</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">fweights</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">aweights</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Estimate a covariance matrix, given data and weights. 
 
    Covariance indicates the level to which two variables vary together. 
    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`, 
    then the covariance matrix element :math:`C_{ij}` is the covariance of 
    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance 
    of :math:`x_i`. 
 
    See the notes for an outline of the algorithm. 
 
    Parameters 
    ---------- 
    m : array_like 
        A 1-D or 2-D array containing multiple variables and observations. 
        Each row of `m` represents a variable, and each column a single 
        observation of all those variables. Also see `rowvar` below. 
    y : array_like, optional 
        An additional set of variables and observations. `y` has the same form 
        as that of `m`. 
    rowvar : bool, optional 
        If `rowvar` is True (default), then each row represents a 
        variable, with observations in the columns. Otherwise, the relationship 
        is transposed: each column represents a variable, while the rows 
        contain observations. 
    bias : bool, optional 
        Default normalization (False) is by ``(N - 1)``, where ``N`` is the 
        number of observations given (unbiased estimate). If `bias` is True, 
        then normalization is by ``N``. These values can be overridden by using 
        the keyword ``ddof`` in numpy versions &gt;= 1.5. 
    ddof : int, optional 
        If not ``None`` the default value implied by `bias` is overridden. 
        Note that ``ddof=1`` will return the unbiased estimate, even if both 
        `fweights` and `aweights` are specified, and ``ddof=0`` will return 
        the simple average. See the notes for the details. The default value 
        is ``None``. 
 
        .. versionadded:: 1.5 
    fweights : array_like, int, optional 
        1-D array of integer frequency weights; the number of times each 
        observation vector should be repeated. 
 
        .. versionadded:: 1.10 
    aweights : array_like, optional 
        1-D array of observation vector weights. These relative weights are 
        typically large for observations considered &quot;important&quot; and smaller for 
        observations considered less &quot;important&quot;. If ``ddof=0`` the array of 
        weights can be used to assign probabilities to observation vectors. 
 
        .. versionadded:: 1.10 
    dtype : data-type, optional 
        Data-type of the result. By default, the return data-type will have 
        at least `numpy.float64` precision. 
 
        .. versionadded:: 1.20 
 
    Returns 
    ------- 
    out : ndarray 
        The covariance matrix of the variables. 
 
    See Also 
    -------- 
    corrcoef : Normalized covariance matrix 
 
    Notes 
    ----- 
    Assume that the observations are in the columns of the observation 
    array `m` and let ``f = fweights`` and ``a = aweights`` for brevity. The 
    steps to compute the weighted covariance are as follows:: 
 
        &gt;&gt;&gt; m = np.arange(10, dtype=np.float64) 
        &gt;&gt;&gt; f = np.arange(10) * 2 
        &gt;&gt;&gt; a = np.arange(10) ** 2. 
        &gt;&gt;&gt; ddof = 1 
        &gt;&gt;&gt; w = f * a 
        &gt;&gt;&gt; v1 = np.sum(w) 
        &gt;&gt;&gt; v2 = np.sum(w * a) 
        &gt;&gt;&gt; m -= np.sum(m * w, axis=None, keepdims=True) / v1 
        &gt;&gt;&gt; cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2) 
 
    Note that when ``a == 1``, the normalization factor 
    ``v1 / (v1**2 - ddof * v2)`` goes over to ``1 / (np.sum(f) - ddof)`` 
    as it should. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
 
    Consider two variables, :math:`x_0` and :math:`x_1`, which 
    correlate perfectly, but in opposite directions: 
 
    &gt;&gt;&gt; x = np.array([[0, 2], [1, 1], [2, 0]]).T 
    &gt;&gt;&gt; x 
    array([[0, 1, 2], 
           [2, 1, 0]]) 
 
    Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance 
    matrix shows this clearly: 
 
    &gt;&gt;&gt; np.cov(x) 
    array([[ 1., -1.], 
           [-1.,  1.]]) 
 
    Note that element :math:`C_{0,1}`, which shows the correlation between 
    :math:`x_0` and :math:`x_1`, is negative. 
 
    Further, note how `x` and `y` are combined: 
 
    &gt;&gt;&gt; x = [-2.1, -1,  4.3] 
    &gt;&gt;&gt; y = [3,  1.1,  0.12] 
    &gt;&gt;&gt; X = np.stack((x, y), axis=0) 
    &gt;&gt;&gt; np.cov(X) 
    array([[11.71      , -4.286     ], # may vary 
           [-4.286     ,  2.144133]]) 
    &gt;&gt;&gt; np.cov(x, y) 
    array([[11.71      , -4.286     ], # may vary 
           [-4.286     ,  2.144133]]) 
    &gt;&gt;&gt; np.cov(x) 
    array(11.71) 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># Check inputs</span>
    <span class="s0">if </span><span class="s1">ddof </span><span class="s0">is not None and </span><span class="s1">ddof </span><span class="s2">!= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">ddof</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">&quot;ddof must be integer&quot;</span><span class="s2">)</span>

    <span class="s3"># Handles complex arrays too</span>
    <span class="s1">m </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">m</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">m</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;m has more than 2 dimensions&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">y </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">y</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;y has more than 2 dimensions&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">y </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">result_type</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">dtype </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">result_type</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>

    <span class="s1">X </span><span class="s2">= </span><span class="s1">array</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">ndmin</span><span class="s2">=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s1">rowvar </span><span class="s0">and </span><span class="s1">X</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] != </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s1">X </span><span class="s2">= </span><span class="s1">X</span><span class="s2">.</span><span class="s1">T</span>
    <span class="s0">if </span><span class="s1">X</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] == </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([]).</span><span class="s1">reshape</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">y </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">array</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">ndmin</span><span class="s2">=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">rowvar </span><span class="s0">and </span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] != </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">y </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">T</span>
        <span class="s1">X </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">), </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">ddof </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">bias </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">ddof </span><span class="s2">= </span><span class="s5">1</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">ddof </span><span class="s2">= </span><span class="s5">0</span>

    <span class="s3"># Get the product of frequencies and weights</span>
    <span class="s1">w </span><span class="s2">= </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s1">fweights </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">fweights </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">fweights</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">fweights </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">around</span><span class="s2">(</span><span class="s1">fweights</span><span class="s2">)):</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s4">&quot;fweights must be integer&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">fweights</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span>
                <span class="s4">&quot;cannot handle multidimensional fweights&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">fweights</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] != </span><span class="s1">X</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span>
                <span class="s4">&quot;incompatible numbers of samples and fweights&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">any</span><span class="s2">(</span><span class="s1">fweights </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">&quot;fweights cannot be negative&quot;</span><span class="s2">)</span>
        <span class="s1">w </span><span class="s2">= </span><span class="s1">fweights</span>
    <span class="s0">if </span><span class="s1">aweights </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">aweights </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">aweights</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">aweights</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span>
                <span class="s4">&quot;cannot handle multidimensional aweights&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">aweights</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] != </span><span class="s1">X</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span>
                <span class="s4">&quot;incompatible numbers of samples and aweights&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">any</span><span class="s2">(</span><span class="s1">aweights </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">&quot;aweights cannot be negative&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">w </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">w </span><span class="s2">= </span><span class="s1">aweights</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">w </span><span class="s2">*= </span><span class="s1">aweights</span>

    <span class="s1">avg</span><span class="s2">, </span><span class="s1">w_sum </span><span class="s2">= </span><span class="s1">average</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">weights</span><span class="s2">=</span><span class="s1">w</span><span class="s2">, </span><span class="s1">returned</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s1">w_sum </span><span class="s2">= </span><span class="s1">w_sum</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>

    <span class="s3"># Determine the normalization</span>
    <span class="s0">if </span><span class="s1">w </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">fact </span><span class="s2">= </span><span class="s1">X</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] - </span><span class="s1">ddof</span>
    <span class="s0">elif </span><span class="s1">ddof </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">fact </span><span class="s2">= </span><span class="s1">w_sum</span>
    <span class="s0">elif </span><span class="s1">aweights </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">fact </span><span class="s2">= </span><span class="s1">w_sum </span><span class="s2">- </span><span class="s1">ddof</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">fact </span><span class="s2">= </span><span class="s1">w_sum </span><span class="s2">- </span><span class="s1">ddof</span><span class="s2">*</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">w</span><span class="s2">*</span><span class="s1">aweights</span><span class="s2">)/</span><span class="s1">w_sum</span>

    <span class="s0">if </span><span class="s1">fact </span><span class="s2">&lt;= </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s4">&quot;Degrees of freedom &lt;= 0 for slice&quot;</span><span class="s2">,</span>
                      <span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>
        <span class="s1">fact </span><span class="s2">= </span><span class="s5">0.0</span>

    <span class="s1">X </span><span class="s2">-= </span><span class="s1">avg</span><span class="s2">[:, </span><span class="s0">None</span><span class="s2">]</span>
    <span class="s0">if </span><span class="s1">w </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">X_T </span><span class="s2">= </span><span class="s1">X</span><span class="s2">.</span><span class="s1">T</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">X_T </span><span class="s2">= (</span><span class="s1">X</span><span class="s2">*</span><span class="s1">w</span><span class="s2">).</span><span class="s1">T</span>
    <span class="s1">c </span><span class="s2">= </span><span class="s1">dot</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">X_T</span><span class="s2">.</span><span class="s1">conj</span><span class="s2">())</span>
    <span class="s1">c </span><span class="s2">*= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">true_divide</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">fact</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">c</span><span class="s2">.</span><span class="s1">squeeze</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">_corrcoef_dispatcher</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">rowvar</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">bias</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">ddof</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *,</span>
                         <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_corrcoef_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">corrcoef</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">rowvar</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">bias</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">_NoValue</span><span class="s2">, </span><span class="s1">ddof</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">_NoValue</span><span class="s2">, *,</span>
             <span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return Pearson product-moment correlation coefficients. 
 
    Please refer to the documentation for `cov` for more detail.  The 
    relationship between the correlation coefficient matrix, `R`, and the 
    covariance matrix, `C`, is 
 
    .. math:: R_{ij} = \\frac{ C_{ij} } { \\sqrt{ C_{ii} C_{jj} } } 
 
    The values of `R` are between -1 and 1, inclusive. 
 
    Parameters 
    ---------- 
    x : array_like 
        A 1-D or 2-D array containing multiple variables and observations. 
        Each row of `x` represents a variable, and each column a single 
        observation of all those variables. Also see `rowvar` below. 
    y : array_like, optional 
        An additional set of variables and observations. `y` has the same 
        shape as `x`. 
    rowvar : bool, optional 
        If `rowvar` is True (default), then each row represents a 
        variable, with observations in the columns. Otherwise, the relationship 
        is transposed: each column represents a variable, while the rows 
        contain observations. 
    bias : _NoValue, optional 
        Has no effect, do not use. 
 
        .. deprecated:: 1.10.0 
    ddof : _NoValue, optional 
        Has no effect, do not use. 
 
        .. deprecated:: 1.10.0 
    dtype : data-type, optional 
        Data-type of the result. By default, the return data-type will have 
        at least `numpy.float64` precision. 
 
        .. versionadded:: 1.20 
 
    Returns 
    ------- 
    R : ndarray 
        The correlation coefficient matrix of the variables. 
 
    See Also 
    -------- 
    cov : Covariance matrix 
 
    Notes 
    ----- 
    Due to floating point rounding the resulting array may not be Hermitian, 
    the diagonal elements may not be 1, and the elements may not satisfy the 
    inequality abs(a) &lt;= 1. The real and imaginary parts are clipped to the 
    interval [-1,  1] in an attempt to improve on that situation but is not 
    much help in the complex case. 
 
    This function accepts but discards arguments `bias` and `ddof`.  This is 
    for backwards compatibility with previous versions of this function.  These 
    arguments had no effect on the return values of the function and can be 
    safely ignored in this and previous versions of numpy. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
 
    In this example we generate two random arrays, ``xarr`` and ``yarr``, and 
    compute the row-wise and column-wise Pearson correlation coefficients, 
    ``R``. Since ``rowvar`` is  true by  default, we first find the row-wise 
    Pearson correlation coefficients between the variables of ``xarr``. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; rng = np.random.default_rng(seed=42) 
    &gt;&gt;&gt; xarr = rng.random((3, 3)) 
    &gt;&gt;&gt; xarr 
    array([[0.77395605, 0.43887844, 0.85859792], 
           [0.69736803, 0.09417735, 0.97562235], 
           [0.7611397 , 0.78606431, 0.12811363]]) 
    &gt;&gt;&gt; R1 = np.corrcoef(xarr) 
    &gt;&gt;&gt; R1 
    array([[ 1.        ,  0.99256089, -0.68080986], 
           [ 0.99256089,  1.        , -0.76492172], 
           [-0.68080986, -0.76492172,  1.        ]]) 
 
    If we add another set of variables and observations ``yarr``, we can 
    compute the row-wise Pearson correlation coefficients between the 
    variables in ``xarr`` and ``yarr``. 
 
    &gt;&gt;&gt; yarr = rng.random((3, 3)) 
    &gt;&gt;&gt; yarr 
    array([[0.45038594, 0.37079802, 0.92676499], 
           [0.64386512, 0.82276161, 0.4434142 ], 
           [0.22723872, 0.55458479, 0.06381726]]) 
    &gt;&gt;&gt; R2 = np.corrcoef(xarr, yarr) 
    &gt;&gt;&gt; R2 
    array([[ 1.        ,  0.99256089, -0.68080986,  0.75008178, -0.934284  , 
            -0.99004057], 
           [ 0.99256089,  1.        , -0.76492172,  0.82502011, -0.97074098, 
            -0.99981569], 
           [-0.68080986, -0.76492172,  1.        , -0.99507202,  0.89721355, 
             0.77714685], 
           [ 0.75008178,  0.82502011, -0.99507202,  1.        , -0.93657855, 
            -0.83571711], 
           [-0.934284  , -0.97074098,  0.89721355, -0.93657855,  1.        , 
             0.97517215], 
           [-0.99004057, -0.99981569,  0.77714685, -0.83571711,  0.97517215, 
             1.        ]]) 
 
    Finally if we use the option ``rowvar=False``, the columns are now 
    being treated as the variables and we will find the column-wise Pearson 
    correlation coefficients between variables in ``xarr`` and ``yarr``. 
 
    &gt;&gt;&gt; R3 = np.corrcoef(xarr, yarr, rowvar=False) 
    &gt;&gt;&gt; R3 
    array([[ 1.        ,  0.77598074, -0.47458546, -0.75078643, -0.9665554 , 
             0.22423734], 
           [ 0.77598074,  1.        , -0.92346708, -0.99923895, -0.58826587, 
            -0.44069024], 
           [-0.47458546, -0.92346708,  1.        ,  0.93773029,  0.23297648, 
             0.75137473], 
           [-0.75078643, -0.99923895,  0.93773029,  1.        ,  0.55627469, 
             0.47536961], 
           [-0.9665554 , -0.58826587,  0.23297648,  0.55627469,  1.        , 
            -0.46666491], 
           [ 0.22423734, -0.44069024,  0.75137473,  0.47536961, -0.46666491, 
             1.        ]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">bias </span><span class="s0">is not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">_NoValue </span><span class="s0">or </span><span class="s1">ddof </span><span class="s0">is not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">_NoValue</span><span class="s2">:</span>
        <span class="s3"># 2015-03-15, 1.10</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s4">'bias and ddof have no effect and are deprecated'</span><span class="s2">,</span>
                      <span class="s1">DeprecationWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>
    <span class="s1">c </span><span class="s2">= </span><span class="s1">cov</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">rowvar</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">diag</span><span class="s2">(</span><span class="s1">c</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">ValueError</span><span class="s2">:</span>
        <span class="s3"># scalar covariance</span>
        <span class="s3"># nan if incorrect value (nan, inf, 0), 1 otherwise</span>
        <span class="s0">return </span><span class="s1">c </span><span class="s2">/ </span><span class="s1">c</span>
    <span class="s1">stddev </span><span class="s2">= </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">d</span><span class="s2">.</span><span class="s1">real</span><span class="s2">)</span>
    <span class="s1">c </span><span class="s2">/= </span><span class="s1">stddev</span><span class="s2">[:, </span><span class="s0">None</span><span class="s2">]</span>
    <span class="s1">c </span><span class="s2">/= </span><span class="s1">stddev</span><span class="s2">[</span><span class="s0">None</span><span class="s2">, :]</span>

    <span class="s3"># Clip real and imaginary parts to [-1, 1].  This does not guarantee</span>
    <span class="s3"># abs(a[i,j]) &lt;= 1 for complex arrays, but is the best we can do without</span>
    <span class="s3"># excessive work.</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">c</span><span class="s2">.</span><span class="s1">real</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">c</span><span class="s2">.</span><span class="s1">real</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">c</span><span class="s2">):</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">c</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">c</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">c</span>


<span class="s2">@</span><span class="s1">set_module</span><span class="s2">(</span><span class="s4">'numpy'</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">blackman</span><span class="s2">(</span><span class="s1">M</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return the Blackman window. 
 
    The Blackman window is a taper formed by using the first three 
    terms of a summation of cosines. It was designed to have close to the 
    minimal leakage possible.  It is close to optimal, only slightly worse 
    than a Kaiser window. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero or less, an empty 
        array is returned. 
 
    Returns 
    ------- 
    out : ndarray 
        The window, with the maximum value normalized to one (the value one 
        appears only if the number of samples is odd). 
 
    See Also 
    -------- 
    bartlett, hamming, hanning, kaiser 
 
    Notes 
    ----- 
    The Blackman window is defined as 
 
    .. math::  w(n) = 0.42 - 0.5 \\cos(2\\pi n/M) + 0.08 \\cos(4\\pi n/M) 
 
    Most references to the Blackman window come from the signal processing 
    literature, where it is used as one of many windowing functions for 
    smoothing values.  It is also known as an apodization (which means 
    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning 
    and end of the sampled signal) or tapering function. It is known as a 
    &quot;near optimal&quot; tapering function, almost as good (by some measures) 
    as the kaiser window. 
 
    References 
    ---------- 
    Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra, 
    Dover Publications, New York. 
 
    Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing. 
    Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; np.blackman(12) 
    array([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary 
            4.14397981e-01,   7.36045180e-01,   9.67046769e-01, 
            9.67046769e-01,   7.36045180e-01,   4.14397981e-01, 
            1.59903635e-01,   3.26064346e-02,  -1.38777878e-17]) 
 
    Plot the window and the frequency response. 
 
    .. plot:: 
        :include-source: 
 
        import matplotlib.pyplot as plt 
        from numpy.fft import fft, fftshift 
        window = np.blackman(51) 
        plt.plot(window) 
        plt.title(&quot;Blackman window&quot;) 
        plt.ylabel(&quot;Amplitude&quot;) 
        plt.xlabel(&quot;Sample&quot;) 
        plt.show()  # doctest: +SKIP 
 
        plt.figure() 
        A = fft(window, 2048) / 25.5 
        mag = np.abs(fftshift(A)) 
        freq = np.linspace(-0.5, 0.5, len(A)) 
        with np.errstate(divide='ignore', invalid='ignore'): 
            response = 20 * np.log10(mag) 
        response = np.clip(response, -100, 100) 
        plt.plot(freq, response) 
        plt.title(&quot;Frequency response of Blackman window&quot;) 
        plt.ylabel(&quot;Magnitude [dB]&quot;) 
        plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
        plt.axis('tight') 
        plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># Ensures at least float64 via 0.0.  M should be an integer, but conversion</span>
    <span class="s3"># to double is safe for a range.</span>
    <span class="s1">values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">M</span><span class="s2">])</span>
    <span class="s1">M </span><span class="s2">= </span><span class="s1">values</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>

    <span class="s0">if </span><span class="s1">M </span><span class="s2">&lt; </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">array</span><span class="s2">([], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">M </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">ones</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">arange</span><span class="s2">(</span><span class="s5">1</span><span class="s2">-</span><span class="s1">M</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s5">0.42 </span><span class="s2">+ </span><span class="s5">0.5</span><span class="s2">*</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">pi</span><span class="s2">*</span><span class="s1">n</span><span class="s2">/(</span><span class="s1">M</span><span class="s2">-</span><span class="s5">1</span><span class="s2">)) + </span><span class="s5">0.08</span><span class="s2">*</span><span class="s1">cos</span><span class="s2">(</span><span class="s5">2.0</span><span class="s2">*</span><span class="s1">pi</span><span class="s2">*</span><span class="s1">n</span><span class="s2">/(</span><span class="s1">M</span><span class="s2">-</span><span class="s5">1</span><span class="s2">))</span>


<span class="s2">@</span><span class="s1">set_module</span><span class="s2">(</span><span class="s4">'numpy'</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">bartlett</span><span class="s2">(</span><span class="s1">M</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return the Bartlett window. 
 
    The Bartlett window is very similar to a triangular window, except 
    that the end points are at zero.  It is often used in signal 
    processing for tapering a signal, without generating too much 
    ripple in the frequency domain. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero or less, an 
        empty array is returned. 
 
    Returns 
    ------- 
    out : array 
        The triangular window, with the maximum value normalized to one 
        (the value one appears only if the number of samples is odd), with 
        the first and last samples equal to zero. 
 
    See Also 
    -------- 
    blackman, hamming, hanning, kaiser 
 
    Notes 
    ----- 
    The Bartlett window is defined as 
 
    .. math:: w(n) = \\frac{2}{M-1} \\left( 
              \\frac{M-1}{2} - \\left|n - \\frac{M-1}{2}\\right| 
              \\right) 
 
    Most references to the Bartlett window come from the signal processing 
    literature, where it is used as one of many windowing functions for 
    smoothing values.  Note that convolution with this window produces linear 
    interpolation.  It is also known as an apodization (which means &quot;removing 
    the foot&quot;, i.e. smoothing discontinuities at the beginning and end of the 
    sampled signal) or tapering function. The Fourier transform of the 
    Bartlett window is the product of two sinc functions. Note the excellent 
    discussion in Kanasewich [2]_. 
 
    References 
    ---------- 
    .. [1] M.S. Bartlett, &quot;Periodogram Analysis and Continuous Spectra&quot;, 
           Biometrika 37, 1-16, 1950. 
    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, 
           The University of Alberta Press, 1975, pp. 109-110. 
    .. [3] A.V. Oppenheim and R.W. Schafer, &quot;Discrete-Time Signal 
           Processing&quot;, Prentice-Hall, 1999, pp. 468-471. 
    .. [4] Wikipedia, &quot;Window function&quot;, 
           https://en.wikipedia.org/wiki/Window_function 
    .. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling, 
           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 429. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; np.bartlett(12) 
    array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary 
            0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636, 
            0.18181818,  0.        ]) 
 
    Plot the window and its frequency response (requires SciPy and matplotlib). 
 
    .. plot:: 
        :include-source: 
 
        import matplotlib.pyplot as plt 
        from numpy.fft import fft, fftshift 
        window = np.bartlett(51) 
        plt.plot(window) 
        plt.title(&quot;Bartlett window&quot;) 
        plt.ylabel(&quot;Amplitude&quot;) 
        plt.xlabel(&quot;Sample&quot;) 
        plt.show() 
        plt.figure() 
        A = fft(window, 2048) / 25.5 
        mag = np.abs(fftshift(A)) 
        freq = np.linspace(-0.5, 0.5, len(A)) 
        with np.errstate(divide='ignore', invalid='ignore'): 
            response = 20 * np.log10(mag) 
        response = np.clip(response, -100, 100) 
        plt.plot(freq, response) 
        plt.title(&quot;Frequency response of Bartlett window&quot;) 
        plt.ylabel(&quot;Magnitude [dB]&quot;) 
        plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
        plt.axis('tight') 
        plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># Ensures at least float64 via 0.0.  M should be an integer, but conversion</span>
    <span class="s3"># to double is safe for a range.</span>
    <span class="s1">values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">M</span><span class="s2">])</span>
    <span class="s1">M </span><span class="s2">= </span><span class="s1">values</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>

    <span class="s0">if </span><span class="s1">M </span><span class="s2">&lt; </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">array</span><span class="s2">([], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">M </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">ones</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">arange</span><span class="s2">(</span><span class="s5">1</span><span class="s2">-</span><span class="s1">M</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">where</span><span class="s2">(</span><span class="s1">less_equal</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), </span><span class="s5">1 </span><span class="s2">+ </span><span class="s1">n</span><span class="s2">/(</span><span class="s1">M</span><span class="s2">-</span><span class="s5">1</span><span class="s2">), </span><span class="s5">1 </span><span class="s2">- </span><span class="s1">n</span><span class="s2">/(</span><span class="s1">M</span><span class="s2">-</span><span class="s5">1</span><span class="s2">))</span>


<span class="s2">@</span><span class="s1">set_module</span><span class="s2">(</span><span class="s4">'numpy'</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">hanning</span><span class="s2">(</span><span class="s1">M</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return the Hanning window. 
 
    The Hanning window is a taper formed by using a weighted cosine. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero or less, an 
        empty array is returned. 
 
    Returns 
    ------- 
    out : ndarray, shape(M,) 
        The window, with the maximum value normalized to one (the value 
        one appears only if `M` is odd). 
 
    See Also 
    -------- 
    bartlett, blackman, hamming, kaiser 
 
    Notes 
    ----- 
    The Hanning window is defined as 
 
    .. math::  w(n) = 0.5 - 0.5\\cos\\left(\\frac{2\\pi{n}}{M-1}\\right) 
               \\qquad 0 \\leq n \\leq M-1 
 
    The Hanning was named for Julius von Hann, an Austrian meteorologist. 
    It is also known as the Cosine Bell. Some authors prefer that it be 
    called a Hann window, to help avoid confusion with the very similar 
    Hamming window. 
 
    Most references to the Hanning window come from the signal processing 
    literature, where it is used as one of many windowing functions for 
    smoothing values.  It is also known as an apodization (which means 
    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning 
    and end of the sampled signal) or tapering function. 
 
    References 
    ---------- 
    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power 
           spectra, Dover Publications, New York. 
    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, 
           The University of Alberta Press, 1975, pp. 106-108. 
    .. [3] Wikipedia, &quot;Window function&quot;, 
           https://en.wikipedia.org/wiki/Window_function 
    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling, 
           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 425. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; np.hanning(12) 
    array([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037, 
           0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249, 
           0.07937323, 0.        ]) 
 
    Plot the window and its frequency response. 
 
    .. plot:: 
        :include-source: 
 
        import matplotlib.pyplot as plt 
        from numpy.fft import fft, fftshift 
        window = np.hanning(51) 
        plt.plot(window) 
        plt.title(&quot;Hann window&quot;) 
        plt.ylabel(&quot;Amplitude&quot;) 
        plt.xlabel(&quot;Sample&quot;) 
        plt.show() 
 
        plt.figure() 
        A = fft(window, 2048) / 25.5 
        mag = np.abs(fftshift(A)) 
        freq = np.linspace(-0.5, 0.5, len(A)) 
        with np.errstate(divide='ignore', invalid='ignore'): 
            response = 20 * np.log10(mag) 
        response = np.clip(response, -100, 100) 
        plt.plot(freq, response) 
        plt.title(&quot;Frequency response of the Hann window&quot;) 
        plt.ylabel(&quot;Magnitude [dB]&quot;) 
        plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
        plt.axis('tight') 
        plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># Ensures at least float64 via 0.0.  M should be an integer, but conversion</span>
    <span class="s3"># to double is safe for a range.</span>
    <span class="s1">values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">M</span><span class="s2">])</span>
    <span class="s1">M </span><span class="s2">= </span><span class="s1">values</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>

    <span class="s0">if </span><span class="s1">M </span><span class="s2">&lt; </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">array</span><span class="s2">([], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">M </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">ones</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">arange</span><span class="s2">(</span><span class="s5">1</span><span class="s2">-</span><span class="s1">M</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s5">0.5 </span><span class="s2">+ </span><span class="s5">0.5</span><span class="s2">*</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">pi</span><span class="s2">*</span><span class="s1">n</span><span class="s2">/(</span><span class="s1">M</span><span class="s2">-</span><span class="s5">1</span><span class="s2">))</span>


<span class="s2">@</span><span class="s1">set_module</span><span class="s2">(</span><span class="s4">'numpy'</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">hamming</span><span class="s2">(</span><span class="s1">M</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return the Hamming window. 
 
    The Hamming window is a taper formed by using a weighted cosine. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero or less, an 
        empty array is returned. 
 
    Returns 
    ------- 
    out : ndarray 
        The window, with the maximum value normalized to one (the value 
        one appears only if the number of samples is odd). 
 
    See Also 
    -------- 
    bartlett, blackman, hanning, kaiser 
 
    Notes 
    ----- 
    The Hamming window is defined as 
 
    .. math::  w(n) = 0.54 - 0.46\\cos\\left(\\frac{2\\pi{n}}{M-1}\\right) 
               \\qquad 0 \\leq n \\leq M-1 
 
    The Hamming was named for R. W. Hamming, an associate of J. W. Tukey 
    and is described in Blackman and Tukey. It was recommended for 
    smoothing the truncated autocovariance function in the time domain. 
    Most references to the Hamming window come from the signal processing 
    literature, where it is used as one of many windowing functions for 
    smoothing values.  It is also known as an apodization (which means 
    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning 
    and end of the sampled signal) or tapering function. 
 
    References 
    ---------- 
    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power 
           spectra, Dover Publications, New York. 
    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, The 
           University of Alberta Press, 1975, pp. 109-110. 
    .. [3] Wikipedia, &quot;Window function&quot;, 
           https://en.wikipedia.org/wiki/Window_function 
    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling, 
           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 425. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; np.hamming(12) 
    array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary 
            0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909, 
            0.15302337,  0.08      ]) 
 
    Plot the window and the frequency response. 
 
    .. plot:: 
        :include-source: 
 
        import matplotlib.pyplot as plt 
        from numpy.fft import fft, fftshift 
        window = np.hamming(51) 
        plt.plot(window) 
        plt.title(&quot;Hamming window&quot;) 
        plt.ylabel(&quot;Amplitude&quot;) 
        plt.xlabel(&quot;Sample&quot;) 
        plt.show() 
 
        plt.figure() 
        A = fft(window, 2048) / 25.5 
        mag = np.abs(fftshift(A)) 
        freq = np.linspace(-0.5, 0.5, len(A)) 
        response = 20 * np.log10(mag) 
        response = np.clip(response, -100, 100) 
        plt.plot(freq, response) 
        plt.title(&quot;Frequency response of Hamming window&quot;) 
        plt.ylabel(&quot;Magnitude [dB]&quot;) 
        plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
        plt.axis('tight') 
        plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># Ensures at least float64 via 0.0.  M should be an integer, but conversion</span>
    <span class="s3"># to double is safe for a range.</span>
    <span class="s1">values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">M</span><span class="s2">])</span>
    <span class="s1">M </span><span class="s2">= </span><span class="s1">values</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>

    <span class="s0">if </span><span class="s1">M </span><span class="s2">&lt; </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">array</span><span class="s2">([], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">M </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">ones</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">arange</span><span class="s2">(</span><span class="s5">1</span><span class="s2">-</span><span class="s1">M</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s5">0.54 </span><span class="s2">+ </span><span class="s5">0.46</span><span class="s2">*</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">pi</span><span class="s2">*</span><span class="s1">n</span><span class="s2">/(</span><span class="s1">M</span><span class="s2">-</span><span class="s5">1</span><span class="s2">))</span>


<span class="s3">## Code from cephes for i0</span>

<span class="s1">_i0A </span><span class="s2">= [</span>
    <span class="s2">-</span><span class="s5">4.41534164647933937950E-18</span><span class="s2">,</span>
    <span class="s5">3.33079451882223809783E-17</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">2.43127984654795469359E-16</span><span class="s2">,</span>
    <span class="s5">1.71539128555513303061E-15</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">1.16853328779934516808E-14</span><span class="s2">,</span>
    <span class="s5">7.67618549860493561688E-14</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">4.85644678311192946090E-13</span><span class="s2">,</span>
    <span class="s5">2.95505266312963983461E-12</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">1.72682629144155570723E-11</span><span class="s2">,</span>
    <span class="s5">9.67580903537323691224E-11</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">5.18979560163526290666E-10</span><span class="s2">,</span>
    <span class="s5">2.65982372468238665035E-9</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">1.30002500998624804212E-8</span><span class="s2">,</span>
    <span class="s5">6.04699502254191894932E-8</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">2.67079385394061173391E-7</span><span class="s2">,</span>
    <span class="s5">1.11738753912010371815E-6</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">4.41673835845875056359E-6</span><span class="s2">,</span>
    <span class="s5">1.64484480707288970893E-5</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">5.75419501008210370398E-5</span><span class="s2">,</span>
    <span class="s5">1.88502885095841655729E-4</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">5.76375574538582365885E-4</span><span class="s2">,</span>
    <span class="s5">1.63947561694133579842E-3</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">4.32430999505057594430E-3</span><span class="s2">,</span>
    <span class="s5">1.05464603945949983183E-2</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">2.37374148058994688156E-2</span><span class="s2">,</span>
    <span class="s5">4.93052842396707084878E-2</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">9.49010970480476444210E-2</span><span class="s2">,</span>
    <span class="s5">1.71620901522208775349E-1</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">3.04682672343198398683E-1</span><span class="s2">,</span>
    <span class="s5">6.76795274409476084995E-1</span>
    <span class="s2">]</span>

<span class="s1">_i0B </span><span class="s2">= [</span>
    <span class="s2">-</span><span class="s5">7.23318048787475395456E-18</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">4.83050448594418207126E-18</span><span class="s2">,</span>
    <span class="s5">4.46562142029675999901E-17</span><span class="s2">,</span>
    <span class="s5">3.46122286769746109310E-17</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">2.82762398051658348494E-16</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">3.42548561967721913462E-16</span><span class="s2">,</span>
    <span class="s5">1.77256013305652638360E-15</span><span class="s2">,</span>
    <span class="s5">3.81168066935262242075E-15</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">9.55484669882830764870E-15</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">4.15056934728722208663E-14</span><span class="s2">,</span>
    <span class="s5">1.54008621752140982691E-14</span><span class="s2">,</span>
    <span class="s5">3.85277838274214270114E-13</span><span class="s2">,</span>
    <span class="s5">7.18012445138366623367E-13</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">1.79417853150680611778E-12</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">1.32158118404477131188E-11</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">3.14991652796324136454E-11</span><span class="s2">,</span>
    <span class="s5">1.18891471078464383424E-11</span><span class="s2">,</span>
    <span class="s5">4.94060238822496958910E-10</span><span class="s2">,</span>
    <span class="s5">3.39623202570838634515E-9</span><span class="s2">,</span>
    <span class="s5">2.26666899049817806459E-8</span><span class="s2">,</span>
    <span class="s5">2.04891858946906374183E-7</span><span class="s2">,</span>
    <span class="s5">2.89137052083475648297E-6</span><span class="s2">,</span>
    <span class="s5">6.88975834691682398426E-5</span><span class="s2">,</span>
    <span class="s5">3.36911647825569408990E-3</span><span class="s2">,</span>
    <span class="s5">8.04490411014108831608E-1</span>
    <span class="s2">]</span>


<span class="s0">def </span><span class="s1">_chbevl</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">vals</span><span class="s2">):</span>
    <span class="s1">b0 </span><span class="s2">= </span><span class="s1">vals</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
    <span class="s1">b1 </span><span class="s2">= </span><span class="s5">0.0</span>

    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">vals</span><span class="s2">)):</span>
        <span class="s1">b2 </span><span class="s2">= </span><span class="s1">b1</span>
        <span class="s1">b1 </span><span class="s2">= </span><span class="s1">b0</span>
        <span class="s1">b0 </span><span class="s2">= </span><span class="s1">x</span><span class="s2">*</span><span class="s1">b1 </span><span class="s2">- </span><span class="s1">b2 </span><span class="s2">+ </span><span class="s1">vals</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>

    <span class="s0">return </span><span class="s5">0.5</span><span class="s2">*(</span><span class="s1">b0 </span><span class="s2">- </span><span class="s1">b2</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_i0_1</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">exp</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) * </span><span class="s1">_chbevl</span><span class="s2">(</span><span class="s1">x</span><span class="s2">/</span><span class="s5">2.0</span><span class="s2">-</span><span class="s5">2</span><span class="s2">, </span><span class="s1">_i0A</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_i0_2</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">exp</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) * </span><span class="s1">_chbevl</span><span class="s2">(</span><span class="s5">32.0</span><span class="s2">/</span><span class="s1">x </span><span class="s2">- </span><span class="s5">2.0</span><span class="s2">, </span><span class="s1">_i0B</span><span class="s2">) / </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_i0_dispatcher</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">x</span><span class="s2">,)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_i0_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">i0</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Modified Bessel function of the first kind, order 0. 
 
    Usually denoted :math:`I_0`. 
 
    Parameters 
    ---------- 
    x : array_like of float 
        Argument of the Bessel function. 
 
    Returns 
    ------- 
    out : ndarray, shape = x.shape, dtype = float 
        The modified Bessel function evaluated at each of the elements of `x`. 
 
    See Also 
    -------- 
    scipy.special.i0, scipy.special.iv, scipy.special.ive 
 
    Notes 
    ----- 
    The scipy implementation is recommended over this function: it is a 
    proper ufunc written in C, and more than an order of magnitude faster. 
 
    We use the algorithm published by Clenshaw [1]_ and referenced by 
    Abramowitz and Stegun [2]_, for which the function domain is 
    partitioned into the two intervals [0,8] and (8,inf), and Chebyshev 
    polynomial expansions are employed in each interval. Relative error on 
    the domain [0,30] using IEEE arithmetic is documented [3]_ as having a 
    peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000). 
 
    References 
    ---------- 
    .. [1] C. W. Clenshaw, &quot;Chebyshev series for mathematical functions&quot;, in 
           *National Physical Laboratory Mathematical Tables*, vol. 5, London: 
           Her Majesty's Stationery Office, 1962. 
    .. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical 
           Functions*, 10th printing, New York: Dover, 1964, pp. 379. 
           https://personal.math.ubc.ca/~cbm/aands/page_379.htm 
    .. [3] https://metacpan.org/pod/distribution/Math-Cephes/lib/Math/Cephes.pod#i0:-Modified-Bessel-function-of-order-zero 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; np.i0(0.) 
    array(1.0) 
    &gt;&gt;&gt; np.i0([0, 1, 2, 3]) 
    array([1.        , 1.26606588, 2.2795853 , 4.88079259]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s4">'c'</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;i0 not supported for complex values&quot;</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">!= </span><span class="s4">'f'</span><span class="s2">:</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">float</span><span class="s2">)</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">piecewise</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, [</span><span class="s1">x </span><span class="s2">&lt;= </span><span class="s5">8.0</span><span class="s2">], [</span><span class="s1">_i0_1</span><span class="s2">, </span><span class="s1">_i0_2</span><span class="s2">])</span>

<span class="s3">## End of cephes code for i0</span>


<span class="s2">@</span><span class="s1">set_module</span><span class="s2">(</span><span class="s4">'numpy'</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">kaiser</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return the Kaiser window. 
 
    The Kaiser window is a taper formed by using a Bessel function. 
 
    Parameters 
    ---------- 
    M : int 
        Number of points in the output window. If zero or less, an 
        empty array is returned. 
    beta : float 
        Shape parameter for window. 
 
    Returns 
    ------- 
    out : array 
        The window, with the maximum value normalized to one (the value 
        one appears only if the number of samples is odd). 
 
    See Also 
    -------- 
    bartlett, blackman, hamming, hanning 
 
    Notes 
    ----- 
    The Kaiser window is defined as 
 
    .. math::  w(n) = I_0\\left( \\beta \\sqrt{1-\\frac{4n^2}{(M-1)^2}} 
               \\right)/I_0(\\beta) 
 
    with 
 
    .. math:: \\quad -\\frac{M-1}{2} \\leq n \\leq \\frac{M-1}{2}, 
 
    where :math:`I_0` is the modified zeroth-order Bessel function. 
 
    The Kaiser was named for Jim Kaiser, who discovered a simple 
    approximation to the DPSS window based on Bessel functions.  The Kaiser 
    window is a very good approximation to the Digital Prolate Spheroidal 
    Sequence, or Slepian window, which is the transform which maximizes the 
    energy in the main lobe of the window relative to total energy. 
 
    The Kaiser can approximate many other windows by varying the beta 
    parameter. 
 
    ====  ======================= 
    beta  Window shape 
    ====  ======================= 
    0     Rectangular 
    5     Similar to a Hamming 
    6     Similar to a Hanning 
    8.6   Similar to a Blackman 
    ====  ======================= 
 
    A beta value of 14 is probably a good starting point. Note that as beta 
    gets large, the window narrows, and so the number of samples needs to be 
    large enough to sample the increasingly narrow spike, otherwise NaNs will 
    get returned. 
 
    Most references to the Kaiser window come from the signal processing 
    literature, where it is used as one of many windowing functions for 
    smoothing values.  It is also known as an apodization (which means 
    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning 
    and end of the sampled signal) or tapering function. 
 
    References 
    ---------- 
    .. [1] J. F. Kaiser, &quot;Digital Filters&quot; - Ch 7 in &quot;Systems analysis by 
           digital computer&quot;, Editors: F.F. Kuo and J.F. Kaiser, p 218-285. 
           John Wiley and Sons, New York, (1966). 
    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, The 
           University of Alberta Press, 1975, pp. 177-178. 
    .. [3] Wikipedia, &quot;Window function&quot;, 
           https://en.wikipedia.org/wiki/Window_function 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; np.kaiser(12, 14) 
     array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary 
            2.29737120e-01, 5.99885316e-01, 9.45674898e-01, 
            9.45674898e-01, 5.99885316e-01, 2.29737120e-01, 
            4.65200189e-02, 3.46009194e-03, 7.72686684e-06]) 
 
 
    Plot the window and the frequency response. 
 
    .. plot:: 
        :include-source: 
 
        import matplotlib.pyplot as plt 
        from numpy.fft import fft, fftshift 
        window = np.kaiser(51, 14) 
        plt.plot(window) 
        plt.title(&quot;Kaiser window&quot;) 
        plt.ylabel(&quot;Amplitude&quot;) 
        plt.xlabel(&quot;Sample&quot;) 
        plt.show() 
 
        plt.figure() 
        A = fft(window, 2048) / 25.5 
        mag = np.abs(fftshift(A)) 
        freq = np.linspace(-0.5, 0.5, len(A)) 
        response = 20 * np.log10(mag) 
        response = np.clip(response, -100, 100) 
        plt.plot(freq, response) 
        plt.title(&quot;Frequency response of Kaiser window&quot;) 
        plt.ylabel(&quot;Magnitude [dB]&quot;) 
        plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;) 
        plt.axis('tight') 
        plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># Ensures at least float64 via 0.0.  M should be an integer, but conversion</span>
    <span class="s3"># to double is safe for a range.  (Simplified result_type with 0.0</span>
    <span class="s3"># strongly typed.  result-type is not/less order sensitive, but that mainly</span>
    <span class="s3"># matters for integers anyway.)</span>
    <span class="s1">values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">])</span>
    <span class="s1">M </span><span class="s2">= </span><span class="s1">values</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>
    <span class="s1">beta </span><span class="s2">= </span><span class="s1">values</span><span class="s2">[</span><span class="s5">2</span><span class="s2">]</span>

    <span class="s0">if </span><span class="s1">M </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">values</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">arange</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">M</span><span class="s2">)</span>
    <span class="s1">alpha </span><span class="s2">= (</span><span class="s1">M</span><span class="s2">-</span><span class="s5">1</span><span class="s2">)/</span><span class="s5">2.0</span>
    <span class="s0">return </span><span class="s1">i0</span><span class="s2">(</span><span class="s1">beta </span><span class="s2">* </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s5">1</span><span class="s2">-((</span><span class="s1">n</span><span class="s2">-</span><span class="s1">alpha</span><span class="s2">)/</span><span class="s1">alpha</span><span class="s2">)**</span><span class="s5">2.0</span><span class="s2">))/</span><span class="s1">i0</span><span class="s2">(</span><span class="s1">beta</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_sinc_dispatcher</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">x</span><span class="s2">,)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_sinc_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">sinc</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s6">r&quot;&quot;&quot; 
    Return the normalized sinc function. 
 
    The sinc function is equal to :math:`\sin(\pi x)/(\pi x)` for any argument 
    :math:`x\ne 0`. ``sinc(0)`` takes the limit value 1, making ``sinc`` not 
    only everywhere continuous but also infinitely differentiable. 
 
    .. note:: 
 
        Note the normalization factor of ``pi`` used in the definition. 
        This is the most commonly used definition in signal processing. 
        Use ``sinc(x / np.pi)`` to obtain the unnormalized sinc function 
        :math:`\sin(x)/x` that is more common in mathematics. 
 
    Parameters 
    ---------- 
    x : ndarray 
        Array (possibly multi-dimensional) of values for which to calculate 
        ``sinc(x)``. 
 
    Returns 
    ------- 
    out : ndarray 
        ``sinc(x)``, which has the same shape as the input. 
 
    Notes 
    ----- 
    The name sinc is short for &quot;sine cardinal&quot; or &quot;sinus cardinalis&quot;. 
 
    The sinc function is used in various signal processing applications, 
    including in anti-aliasing, in the construction of a Lanczos resampling 
    filter, and in interpolation. 
 
    For bandlimited interpolation of discrete-time signals, the ideal 
    interpolation kernel is proportional to the sinc function. 
 
    References 
    ---------- 
    .. [1] Weisstein, Eric W. &quot;Sinc Function.&quot; From MathWorld--A Wolfram Web 
           Resource. https://mathworld.wolfram.com/SincFunction.html 
    .. [2] Wikipedia, &quot;Sinc function&quot;, 
           https://en.wikipedia.org/wiki/Sinc_function 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.linspace(-4, 4, 41) 
    &gt;&gt;&gt; np.sinc(x) 
     array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary 
            -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17, 
            6.68206631e-02,   1.16434881e-01,   1.26137788e-01, 
            8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01, 
            -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01, 
            3.89804309e-17,   2.33872321e-01,   5.04551152e-01, 
            7.56826729e-01,   9.35489284e-01,   1.00000000e+00, 
            9.35489284e-01,   7.56826729e-01,   5.04551152e-01, 
            2.33872321e-01,   3.89804309e-17,  -1.55914881e-01, 
           -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01, 
           -3.89804309e-17,   8.50444803e-02,   1.26137788e-01, 
            1.16434881e-01,   6.68206631e-02,   3.89804309e-17, 
            -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02, 
            -4.92362781e-02,  -3.89804309e-17]) 
 
    &gt;&gt;&gt; plt.plot(x, np.sinc(x)) 
    [&lt;matplotlib.lines.Line2D object at 0x...&gt;] 
    &gt;&gt;&gt; plt.title(&quot;Sinc Function&quot;) 
    Text(0.5, 1.0, 'Sinc Function') 
    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;) 
    Text(0, 0.5, 'Amplitude') 
    &gt;&gt;&gt; plt.xlabel(&quot;X&quot;) 
    Text(0.5, 0, 'X') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">pi </span><span class="s2">* </span><span class="s1">where</span><span class="s2">(</span><span class="s1">x </span><span class="s2">== </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1.0e-20</span><span class="s2">, </span><span class="s1">x</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">sin</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)/</span><span class="s1">y</span>


<span class="s0">def </span><span class="s1">_ureduce</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">keepdims</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Internal Function. 
    Call `func` with `a` as first argument swapping the axes to use extended 
    axis on functions that don't support it natively. 
 
    Returns result and a.shape with axis dims set to 1. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array or object that can be converted to an array. 
    func : callable 
        Reduction function capable of receiving a single axis argument. 
        It is called with `a` as first argument followed by `kwargs`. 
    kwargs : keyword arguments 
        additional keyword arguments to pass to `func`. 
 
    Returns 
    ------- 
    result : tuple 
        Result of func(a, **kwargs) and a.shape with axis dims set to 1 
        which can be used to reshape the result to the same shape a ufunc with 
        keepdims=True would produce. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
    <span class="s1">axis </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">'axis'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
    <span class="s1">out </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">'out'</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">keepdims </span><span class="s0">is </span><span class="s1">np</span><span class="s2">.</span><span class="s1">_NoValue</span><span class="s2">:</span>
        <span class="s1">keepdims </span><span class="s2">= </span><span class="s0">False</span>

    <span class="s1">nd </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">axis </span><span class="s2">= </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">normalize_axis_tuple</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">nd</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">keepdims</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">out </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">index_out </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span>
                    <span class="s5">0 </span><span class="s0">if </span><span class="s1">i </span><span class="s0">in </span><span class="s1">axis </span><span class="s0">else </span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">nd</span><span class="s2">))</span>
                <span class="s1">kwargs</span><span class="s2">[</span><span class="s4">'out'</span><span class="s2">] = </span><span class="s1">out</span><span class="s2">[(</span><span class="s1">Ellipsis</span><span class="s2">, ) + </span><span class="s1">index_out</span><span class="s2">]</span>

        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">) == </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">kwargs</span><span class="s2">[</span><span class="s4">'axis'</span><span class="s2">] = </span><span class="s1">axis</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">keep </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">nd</span><span class="s2">)) - </span><span class="s1">set</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">)</span>
            <span class="s1">nkeep </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">keep</span><span class="s2">)</span>
            <span class="s3"># swap axis that should not be reduced to front</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">s </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">keep</span><span class="s2">)):</span>
                <span class="s1">a </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">swapaxes</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">s</span><span class="s2">)</span>
            <span class="s3"># merge reduced axis</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[:</span><span class="s1">nkeep</span><span class="s2">] + (-</span><span class="s5">1</span><span class="s2">,))</span>
            <span class="s1">kwargs</span><span class="s2">[</span><span class="s4">'axis'</span><span class="s2">] = -</span><span class="s5">1</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">keepdims</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">out </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">index_out </span><span class="s2">= (</span><span class="s5">0</span><span class="s2">, ) * </span><span class="s1">nd</span>
                <span class="s1">kwargs</span><span class="s2">[</span><span class="s4">'out'</span><span class="s2">] = </span><span class="s1">out</span><span class="s2">[(</span><span class="s1">Ellipsis</span><span class="s2">, ) + </span><span class="s1">index_out</span><span class="s2">]</span>

    <span class="s1">r </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">out </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">out</span>

    <span class="s0">if </span><span class="s1">keepdims</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">index_r </span><span class="s2">= (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">, ) * </span><span class="s1">nd</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">index_r </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis </span><span class="s0">if </span><span class="s1">i </span><span class="s0">in </span><span class="s1">axis </span><span class="s0">else </span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
                <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">nd</span><span class="s2">))</span>
        <span class="s1">r </span><span class="s2">= </span><span class="s1">r</span><span class="s2">[(</span><span class="s1">Ellipsis</span><span class="s2">, ) + </span><span class="s1">index_r</span><span class="s2">]</span>

    <span class="s0">return </span><span class="s1">r</span>


<span class="s0">def </span><span class="s1">_median_dispatcher</span><span class="s2">(</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">overwrite_input</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">keepdims</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">out</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_median_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">median</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">overwrite_input</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">keepdims</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Compute the median along the specified axis. 
 
    Returns the median of the array elements. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array or object that can be converted to an array. 
    axis : {int, sequence of int, None}, optional 
        Axis or axes along which the medians are computed. The default, 
        axis=None, will compute the median along a flattened version of 
        the array. 
         
        .. versionadded:: 1.9.0 
 
        If a sequence of axes, the array is first flattened along the 
        given axes, then the median is computed along the resulting 
        flattened axis. 
    out : ndarray, optional 
        Alternative output array in which to place the result. It must 
        have the same shape and buffer length as the expected output, 
        but the type (of the output) will be cast if necessary. 
    overwrite_input : bool, optional 
       If True, then allow use of memory of input array `a` for 
       calculations. The input array will be modified by the call to 
       `median`. This will save memory when you do not need to preserve 
       the contents of the input array. Treat the input as undefined, 
       but it will probably be fully or partially sorted. Default is 
       False. If `overwrite_input` is ``True`` and `a` is not already an 
       `ndarray`, an error will be raised. 
    keepdims : bool, optional 
        If this is set to True, the axes which are reduced are left 
        in the result as dimensions with size one. With this option, 
        the result will broadcast correctly against the original `arr`. 
 
        .. versionadded:: 1.9.0 
 
    Returns 
    ------- 
    median : ndarray 
        A new array holding the result. If the input contains integers 
        or floats smaller than ``float64``, then the output data-type is 
        ``np.float64``.  Otherwise, the data-type of the output is the 
        same as that of the input. If `out` is specified, that array is 
        returned instead. 
 
    See Also 
    -------- 
    mean, percentile 
 
    Notes 
    ----- 
    Given a vector ``V`` of length ``N``, the median of ``V`` is the 
    middle value of a sorted copy of ``V``, ``V_sorted`` - i 
    e., ``V_sorted[(N-1)/2]``, when ``N`` is odd, and the average of the 
    two middle values of ``V_sorted`` when ``N`` is even. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]]) 
    &gt;&gt;&gt; a 
    array([[10,  7,  4], 
           [ 3,  2,  1]]) 
    &gt;&gt;&gt; np.median(a) 
    np.float64(3.5) 
    &gt;&gt;&gt; np.median(a, axis=0) 
    array([6.5, 4.5, 2.5]) 
    &gt;&gt;&gt; np.median(a, axis=1) 
    array([7.,  2.]) 
    &gt;&gt;&gt; np.median(a, axis=(0, 1)) 
    np.float64(3.5) 
    &gt;&gt;&gt; m = np.median(a, axis=0) 
    &gt;&gt;&gt; out = np.zeros_like(m) 
    &gt;&gt;&gt; np.median(a, axis=0, out=m) 
    array([6.5,  4.5,  2.5]) 
    &gt;&gt;&gt; m 
    array([6.5,  4.5,  2.5]) 
    &gt;&gt;&gt; b = a.copy() 
    &gt;&gt;&gt; np.median(b, axis=1, overwrite_input=True) 
    array([7.,  2.]) 
    &gt;&gt;&gt; assert not np.all(a==b) 
    &gt;&gt;&gt; b = a.copy() 
    &gt;&gt;&gt; np.median(b, axis=None, overwrite_input=True) 
    np.float64(3.5) 
    &gt;&gt;&gt; assert not np.all(a==b) 
 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">_ureduce</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">func</span><span class="s2">=</span><span class="s1">_median</span><span class="s2">, </span><span class="s1">keepdims</span><span class="s2">=</span><span class="s1">keepdims</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">out</span><span class="s2">,</span>
                    <span class="s1">overwrite_input</span><span class="s2">=</span><span class="s1">overwrite_input</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_median</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">overwrite_input</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
    <span class="s3"># can't be reasonably be implemented in terms of percentile as we have to</span>
    <span class="s3"># call mean to not break astropy</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

    <span class="s3"># Set the partition indexes</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">sz </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">size</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">sz </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
    <span class="s0">if </span><span class="s1">sz </span><span class="s2">% </span><span class="s5">2 </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">szh </span><span class="s2">= </span><span class="s1">sz </span><span class="s2">// </span><span class="s5">2</span>
        <span class="s1">kth </span><span class="s2">= [</span><span class="s1">szh </span><span class="s2">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">szh</span><span class="s2">]</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">kth </span><span class="s2">= [(</span><span class="s1">sz </span><span class="s2">- </span><span class="s5">1</span><span class="s2">) // </span><span class="s5">2</span><span class="s2">]</span>

    <span class="s3"># We have to check for NaNs (as of writing 'M' doesn't actually work).</span>
    <span class="s1">supports_nans </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inexact</span><span class="s2">) </span><span class="s0">or </span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">in </span><span class="s4">'Mm'</span>
    <span class="s0">if </span><span class="s1">supports_nans</span><span class="s2">:</span>
        <span class="s1">kth</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(-</span><span class="s5">1</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">overwrite_input</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">part </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">()</span>
            <span class="s1">part</span><span class="s2">.</span><span class="s1">partition</span><span class="s2">(</span><span class="s1">kth</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">a</span><span class="s2">.</span><span class="s1">partition</span><span class="s2">(</span><span class="s1">kth</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
            <span class="s1">part </span><span class="s2">= </span><span class="s1">a</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">part </span><span class="s2">= </span><span class="s1">partition</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">kth</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">part</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== ():</span>
        <span class="s3"># make 0-D arrays work</span>
        <span class="s0">return </span><span class="s1">part</span><span class="s2">.</span><span class="s1">item</span><span class="s2">()</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">axis </span><span class="s2">= </span><span class="s5">0</span>

    <span class="s1">indexer </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)] * </span><span class="s1">part</span><span class="s2">.</span><span class="s1">ndim</span>
    <span class="s1">index </span><span class="s2">= </span><span class="s1">part</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] // </span><span class="s5">2</span>
    <span class="s0">if </span><span class="s1">part</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] % </span><span class="s5">2 </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s3"># index with slice to allow mean (below) to work</span>
        <span class="s1">indexer</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">index</span><span class="s2">, </span><span class="s1">index</span><span class="s2">+</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">indexer</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">index</span><span class="s2">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">index</span><span class="s2">+</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s1">indexer </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">)</span>

    <span class="s3"># Use mean in both odd and even case to coerce data type,</span>
    <span class="s3"># using out array if needed.</span>
    <span class="s1">rout </span><span class="s2">= </span><span class="s1">mean</span><span class="s2">(</span><span class="s1">part</span><span class="s2">[</span><span class="s1">indexer</span><span class="s2">], </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">out</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">supports_nans </span><span class="s0">and </span><span class="s1">sz </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s3"># If nans are possible, warn and replace by nans like mean would.</span>
        <span class="s1">rout </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">_utils_impl</span><span class="s2">.</span><span class="s1">_median_nancheck</span><span class="s2">(</span><span class="s1">part</span><span class="s2">, </span><span class="s1">rout</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">rout</span>


<span class="s0">def </span><span class="s1">_percentile_dispatcher</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">overwrite_input</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                           <span class="s1">method</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">keepdims</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *, </span><span class="s1">weights</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                           <span class="s1">interpolation</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">out</span><span class="s2">, </span><span class="s1">weights</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_percentile_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">percentile</span><span class="s2">(</span><span class="s1">a</span><span class="s2">,</span>
               <span class="s1">q</span><span class="s2">,</span>
               <span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
               <span class="s1">out</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
               <span class="s1">overwrite_input</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
               <span class="s1">method</span><span class="s2">=</span><span class="s4">&quot;linear&quot;</span><span class="s2">,</span>
               <span class="s1">keepdims</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
               <span class="s2">*,</span>
               <span class="s1">weights</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
               <span class="s1">interpolation</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Compute the q-th percentile of the data along the specified axis. 
 
    Returns the q-th percentile(s) of the array elements. 
 
    Parameters 
    ---------- 
    a : array_like of real numbers 
        Input array or object that can be converted to an array. 
    q : array_like of float 
        Percentage or sequence of percentages for the percentiles to compute. 
        Values must be between 0 and 100 inclusive. 
    axis : {int, tuple of int, None}, optional 
        Axis or axes along which the percentiles are computed. The 
        default is to compute the percentile(s) along a flattened 
        version of the array. 
 
        .. versionchanged:: 1.9.0 
            A tuple of axes is supported 
    out : ndarray, optional 
        Alternative output array in which to place the result. It must 
        have the same shape and buffer length as the expected output, 
        but the type (of the output) will be cast if necessary. 
    overwrite_input : bool, optional 
        If True, then allow the input array `a` to be modified by intermediate 
        calculations, to save memory. In this case, the contents of the input 
        `a` after this function completes is undefined. 
    method : str, optional 
        This parameter specifies the method to use for estimating the 
        percentile.  There are many different methods, some unique to NumPy. 
        See the notes for explanation.  The options sorted by their R type 
        as summarized in the H&amp;F paper [1]_ are: 
 
        1. 'inverted_cdf' 
        2. 'averaged_inverted_cdf' 
        3. 'closest_observation' 
        4. 'interpolated_inverted_cdf' 
        5. 'hazen' 
        6. 'weibull' 
        7. 'linear'  (default) 
        8. 'median_unbiased' 
        9. 'normal_unbiased' 
 
        The first three methods are discontinuous.  NumPy further defines the 
        following discontinuous variations of the default 'linear' (7.) option: 
 
        * 'lower' 
        * 'higher', 
        * 'midpoint' 
        * 'nearest' 
 
        .. versionchanged:: 1.22.0 
            This argument was previously called &quot;interpolation&quot; and only 
            offered the &quot;linear&quot; default and last four options. 
 
    keepdims : bool, optional 
        If this is set to True, the axes which are reduced are left in 
        the result as dimensions with size one. With this option, the 
        result will broadcast correctly against the original array `a`. 
 
        .. versionadded:: 1.9.0 
 
     weights : array_like, optional 
        An array of weights associated with the values in `a`. Each value in 
        `a` contributes to the percentile according to its associated weight. 
        The weights array can either be 1-D (in which case its length must be 
        the size of `a` along the given axis) or of the same shape as `a`. 
        If `weights=None`, then all data in `a` are assumed to have a 
        weight equal to one. 
        Only `method=&quot;inverted_cdf&quot;` supports weights. 
        See the notes for more details. 
 
        .. versionadded:: 2.0.0 
 
    interpolation : str, optional 
        Deprecated name for the method keyword argument. 
 
        .. deprecated:: 1.22.0 
 
    Returns 
    ------- 
    percentile : scalar or ndarray 
        If `q` is a single percentile and `axis=None`, then the result 
        is a scalar. If multiple percentiles are given, first axis of 
        the result corresponds to the percentiles. The other axes are 
        the axes that remain after the reduction of `a`. If the input 
        contains integers or floats smaller than ``float64``, the output 
        data-type is ``float64``. Otherwise, the output data-type is the 
        same as that of the input. If `out` is specified, that array is 
        returned instead. 
 
    See Also 
    -------- 
    mean 
    median : equivalent to ``percentile(..., 50)`` 
    nanpercentile 
    quantile : equivalent to percentile, except q in the range [0, 1]. 
 
    Notes 
    ----- 
    The behavior of `numpy.percentile` with percentage `q` is 
    that of `numpy.quantile` with argument ``q/100``. 
    For more information, please see `numpy.quantile`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]]) 
    &gt;&gt;&gt; a 
    array([[10,  7,  4], 
           [ 3,  2,  1]]) 
    &gt;&gt;&gt; np.percentile(a, 50) 
    3.5 
    &gt;&gt;&gt; np.percentile(a, 50, axis=0) 
    array([6.5, 4.5, 2.5]) 
    &gt;&gt;&gt; np.percentile(a, 50, axis=1) 
    array([7.,  2.]) 
    &gt;&gt;&gt; np.percentile(a, 50, axis=1, keepdims=True) 
    array([[7.], 
           [2.]]) 
 
    &gt;&gt;&gt; m = np.percentile(a, 50, axis=0) 
    &gt;&gt;&gt; out = np.zeros_like(m) 
    &gt;&gt;&gt; np.percentile(a, 50, axis=0, out=out) 
    array([6.5, 4.5, 2.5]) 
    &gt;&gt;&gt; m 
    array([6.5, 4.5, 2.5]) 
 
    &gt;&gt;&gt; b = a.copy() 
    &gt;&gt;&gt; np.percentile(b, 50, axis=1, overwrite_input=True) 
    array([7.,  2.]) 
    &gt;&gt;&gt; assert not np.all(a == b) 
 
    The different methods can be visualized graphically: 
 
    .. plot:: 
 
        import matplotlib.pyplot as plt 
 
        a = np.arange(4) 
        p = np.linspace(0, 100, 6001) 
        ax = plt.gca() 
        lines = [ 
            ('linear', '-', 'C0'), 
            ('inverted_cdf', ':', 'C1'), 
            # Almost the same as `inverted_cdf`: 
            ('averaged_inverted_cdf', '-.', 'C1'), 
            ('closest_observation', ':', 'C2'), 
            ('interpolated_inverted_cdf', '--', 'C1'), 
            ('hazen', '--', 'C3'), 
            ('weibull', '-.', 'C4'), 
            ('median_unbiased', '--', 'C5'), 
            ('normal_unbiased', '-.', 'C6'), 
            ] 
        for method, style, color in lines: 
            ax.plot( 
                p, np.percentile(a, p, method=method), 
                label=method, linestyle=style, color=color) 
        ax.set( 
            title='Percentiles for different methods and data: ' + str(a), 
            xlabel='Percentile', 
            ylabel='Estimated percentile value', 
            yticks=a) 
        ax.legend(bbox_to_anchor=(1.03, 1)) 
        plt.tight_layout() 
        plt.show() 
 
    References 
    ---------- 
    .. [1] R. J. Hyndman and Y. Fan, 
       &quot;Sample quantiles in statistical packages,&quot; 
       The American Statistician, 50(4), pp. 361-365, 1996 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">interpolation </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">method </span><span class="s2">= </span><span class="s1">_check_interpolation_as_method</span><span class="s2">(</span>
            <span class="s1">method</span><span class="s2">, </span><span class="s1">interpolation</span><span class="s2">, </span><span class="s4">&quot;percentile&quot;</span><span class="s2">)</span>

    <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s4">&quot;c&quot;</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;a must be an array of real numbers&quot;</span><span class="s2">)</span>

    <span class="s3"># Use dtype of array if possible (e.g., if q is a python int or float)</span>
    <span class="s3"># by making the divisor have the dtype of the data array.</span>
    <span class="s1">q </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">true_divide</span><span class="s2">(</span><span class="s1">q</span><span class="s2">, </span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">(</span><span class="s5">100</span><span class="s2">) </span><span class="s0">if </span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s4">&quot;f&quot; </span><span class="s0">else </span><span class="s5">100</span><span class="s2">)</span>
    <span class="s1">q </span><span class="s2">= </span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">q</span><span class="s2">)  </span><span class="s3"># undo any decay that the ufunc performed (see gh-13105)</span>
    <span class="s0">if not </span><span class="s1">_quantile_is_valid</span><span class="s2">(</span><span class="s1">q</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Percentiles must be in the range [0, 100]&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">weights </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">method </span><span class="s2">!= </span><span class="s4">&quot;inverted_cdf&quot;</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= (</span><span class="s4">&quot;Only method 'inverted_cdf' supports weights. &quot;</span>
                   <span class="s4">f&quot;Got: </span><span class="s0">{</span><span class="s1">method</span><span class="s0">}</span><span class="s4">.&quot;</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">axis </span><span class="s2">= </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">normalize_axis_tuple</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">argname</span><span class="s2">=</span><span class="s4">&quot;axis&quot;</span><span class="s2">)</span>
        <span class="s1">weights </span><span class="s2">= </span><span class="s1">_weights_are_valid</span><span class="s2">(</span><span class="s1">weights</span><span class="s2">=</span><span class="s1">weights</span><span class="s2">, </span><span class="s1">a</span><span class="s2">=</span><span class="s1">a</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">weights </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Weights must be non-negative.&quot;</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">_quantile_unchecked</span><span class="s2">(</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">out</span><span class="s2">, </span><span class="s1">overwrite_input</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">keepdims</span><span class="s2">, </span><span class="s1">weights</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_quantile_dispatcher</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">overwrite_input</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                         <span class="s1">method</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">keepdims</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, *, </span><span class="s1">weights</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                         <span class="s1">interpolation</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">out</span><span class="s2">, </span><span class="s1">weights</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_quantile_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">quantile</span><span class="s2">(</span><span class="s1">a</span><span class="s2">,</span>
             <span class="s1">q</span><span class="s2">,</span>
             <span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
             <span class="s1">out</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
             <span class="s1">overwrite_input</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
             <span class="s1">method</span><span class="s2">=</span><span class="s4">&quot;linear&quot;</span><span class="s2">,</span>
             <span class="s1">keepdims</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
             <span class="s2">*,</span>
             <span class="s1">weights</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
             <span class="s1">interpolation</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Compute the q-th quantile of the data along the specified axis. 
 
    .. versionadded:: 1.15.0 
 
    Parameters 
    ---------- 
    a : array_like of real numbers 
        Input array or object that can be converted to an array. 
    q : array_like of float 
        Probability or sequence of probabilities of the quantiles to compute. 
        Values must be between 0 and 1 inclusive. 
    axis : {int, tuple of int, None}, optional 
        Axis or axes along which the quantiles are computed. The default is 
        to compute the quantile(s) along a flattened version of the array. 
    out : ndarray, optional 
        Alternative output array in which to place the result. It must have 
        the same shape and buffer length as the expected output, but the 
        type (of the output) will be cast if necessary. 
    overwrite_input : bool, optional 
        If True, then allow the input array `a` to be modified by 
        intermediate calculations, to save memory. In this case, the 
        contents of the input `a` after this function completes is 
        undefined. 
    method : str, optional 
        This parameter specifies the method to use for estimating the 
        quantile.  There are many different methods, some unique to NumPy. 
        The recommended options, numbered as they appear in [1]_, are: 
 
        1. 'inverted_cdf' 
        2. 'averaged_inverted_cdf' 
        3. 'closest_observation' 
        4. 'interpolated_inverted_cdf' 
        5. 'hazen' 
        6. 'weibull' 
        7. 'linear'  (default) 
        8. 'median_unbiased' 
        9. 'normal_unbiased' 
 
        The first three methods are discontinuous. For backward compatibility 
        with previous versions of NumPy, the following discontinuous variations 
        of the default 'linear' (7.) option are available: 
 
        * 'lower' 
        * 'higher', 
        * 'midpoint' 
        * 'nearest' 
 
        See Notes for details. 
 
        .. versionchanged:: 1.22.0 
            This argument was previously called &quot;interpolation&quot; and only 
            offered the &quot;linear&quot; default and last four options. 
 
    keepdims : bool, optional 
        If this is set to True, the axes which are reduced are left in 
        the result as dimensions with size one. With this option, the 
        result will broadcast correctly against the original array `a`. 
 
    weights : array_like, optional 
        An array of weights associated with the values in `a`. Each value in 
        `a` contributes to the quantile according to its associated weight. 
        The weights array can either be 1-D (in which case its length must be 
        the size of `a` along the given axis) or of the same shape as `a`. 
        If `weights=None`, then all data in `a` are assumed to have a 
        weight equal to one. 
        Only `method=&quot;inverted_cdf&quot;` supports weights. 
        See the notes for more details. 
 
        .. versionadded:: 2.0.0 
 
    interpolation : str, optional 
        Deprecated name for the method keyword argument. 
 
        .. deprecated:: 1.22.0 
 
    Returns 
    ------- 
    quantile : scalar or ndarray 
        If `q` is a single probability and `axis=None`, then the result 
        is a scalar. If multiple probability levels are given, first axis 
        of the result corresponds to the quantiles. The other axes are 
        the axes that remain after the reduction of `a`. If the input 
        contains integers or floats smaller than ``float64``, the output 
        data-type is ``float64``. Otherwise, the output data-type is the 
        same as that of the input. If `out` is specified, that array is 
        returned instead. 
 
    See Also 
    -------- 
    mean 
    percentile : equivalent to quantile, but with q in the range [0, 100]. 
    median : equivalent to ``quantile(..., 0.5)`` 
    nanquantile 
 
    Notes 
    ----- 
    Given a sample `a` from an underlying distribution, `quantile` provides a 
    nonparametric estimate of the inverse cumulative distribution function. 
 
    By default, this is done by interpolating between adjacent elements in 
    ``y``, a sorted copy of `a`:: 
 
        (1-g)*y[j] + g*y[j+1] 
 
    where the index ``j`` and coefficient ``g`` are the integral and 
    fractional components of ``q * (n-1)``, and ``n`` is the number of 
    elements in the sample. 
 
    This is a special case of Equation 1 of H&amp;F [1]_. More generally, 
 
    - ``j = (q*n + m - 1) // 1``, and 
    - ``g = (q*n + m - 1) % 1``, 
 
    where ``m`` may be defined according to several different conventions. 
    The preferred convention may be selected using the ``method`` parameter: 
 
    =============================== =============== =============== 
    ``method``                      number in H&amp;F   ``m`` 
    =============================== =============== =============== 
    ``interpolated_inverted_cdf``   4               ``0`` 
    ``hazen``                       5               ``1/2`` 
    ``weibull``                     6               ``q`` 
    ``linear`` (default)            7               ``1 - q`` 
    ``median_unbiased``             8               ``q/3 + 1/3`` 
    ``normal_unbiased``             9               ``q/4 + 3/8`` 
    =============================== =============== =============== 
 
    Note that indices ``j`` and ``j + 1`` are clipped to the range ``0`` to 
    ``n - 1`` when the results of the formula would be outside the allowed 
    range of non-negative indices. The ``- 1`` in the formulas for ``j`` and 
    ``g`` accounts for Python's 0-based indexing. 
 
    The table above includes only the estimators from H&amp;F that are continuous 
    functions of probability `q` (estimators 4-9). NumPy also provides the 
    three discontinuous estimators from H&amp;F (estimators 1-3), where ``j`` is 
    defined as above, ``m`` is defined as follows, and ``g`` is a function 
    of the real-valued ``index = q*n + m - 1`` and ``j``. 
 
    1. ``inverted_cdf``: ``m = 0`` and ``g = int(index - j &gt; 0)`` 
    2. ``averaged_inverted_cdf``: ``m = 0`` and 
       ``g = (1 + int(index - j &gt; 0)) / 2`` 
    3. ``closest_observation``: ``m = -1/2`` and 
       ``g = 1 - int((index == j) &amp; (j%2 == 1))`` 
 
    For backward compatibility with previous versions of NumPy, `quantile` 
    provides four additional discontinuous estimators. Like 
    ``method='linear'``, all have ``m = 1 - q`` so that ``j = q*(n-1) // 1``, 
    but ``g`` is defined as follows. 
 
    - ``lower``: ``g = 0`` 
    - ``midpoint``: ``g = 0.5`` 
    - ``higher``: ``g = 1`` 
    - ``nearest``: ``g = (q*(n-1) % 1) &gt; 0.5`` 
 
    **Weighted quantiles:** 
    More formally, the quantile at probability level :math:`q` of a cumulative 
    distribution function :math:`F(y)=P(Y \\leq y)` with probability measure 
    :math:`P` is defined as any number :math:`x` that fulfills the 
    *coverage conditions* 
 
    .. math:: P(Y &lt; x) \\leq q \\quad\\text{and}\\quad P(Y \\leq x) \\geq q 
 
    with random variable :math:`Y\\sim P`. 
    Sample quantiles, the result of `quantile`, provide nonparametric 
    estimation of the underlying population counterparts, represented by the 
    unknown :math:`F`, given a data vector `a` of length ``n``. 
 
    Some of the estimators above arise when one considers :math:`F` as the 
    empirical distribution function of the data, i.e. 
    :math:`F(y) = \\frac{1}{n} \\sum_i 1_{a_i \\leq y}`. 
    Then, different methods correspond to different choices of :math:`x` that 
    fulfill the above coverage conditions. Methods that follow this approach 
    are ``inverted_cdf`` and ``averaged_inverted_cdf``. 
 
    For weighted quantiles, the coverage conditions still hold. The 
    empirical cumulative distribution is simply replaced by its weighted 
    version, i.e.  
    :math:`P(Y \\leq t) = \\frac{1}{\\sum_i w_i} \\sum_i w_i 1_{x_i \\leq t}`. 
    Only ``method=&quot;inverted_cdf&quot;`` supports weights. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]]) 
    &gt;&gt;&gt; a 
    array([[10,  7,  4], 
           [ 3,  2,  1]]) 
    &gt;&gt;&gt; np.quantile(a, 0.5) 
    3.5 
    &gt;&gt;&gt; np.quantile(a, 0.5, axis=0) 
    array([6.5, 4.5, 2.5]) 
    &gt;&gt;&gt; np.quantile(a, 0.5, axis=1) 
    array([7.,  2.]) 
    &gt;&gt;&gt; np.quantile(a, 0.5, axis=1, keepdims=True) 
    array([[7.], 
           [2.]]) 
    &gt;&gt;&gt; m = np.quantile(a, 0.5, axis=0) 
    &gt;&gt;&gt; out = np.zeros_like(m) 
    &gt;&gt;&gt; np.quantile(a, 0.5, axis=0, out=out) 
    array([6.5, 4.5, 2.5]) 
    &gt;&gt;&gt; m 
    array([6.5, 4.5, 2.5]) 
    &gt;&gt;&gt; b = a.copy() 
    &gt;&gt;&gt; np.quantile(b, 0.5, axis=1, overwrite_input=True) 
    array([7.,  2.]) 
    &gt;&gt;&gt; assert not np.all(a == b) 
 
    See also `numpy.percentile` for a visualization of most methods. 
 
    References 
    ---------- 
    .. [1] R. J. Hyndman and Y. Fan, 
       &quot;Sample quantiles in statistical packages,&quot; 
       The American Statistician, 50(4), pp. 361-365, 1996 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">interpolation </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">method </span><span class="s2">= </span><span class="s1">_check_interpolation_as_method</span><span class="s2">(</span>
            <span class="s1">method</span><span class="s2">, </span><span class="s1">interpolation</span><span class="s2">, </span><span class="s4">&quot;quantile&quot;</span><span class="s2">)</span>

    <span class="s1">a </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s4">&quot;c&quot;</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;a must be an array of real numbers&quot;</span><span class="s2">)</span>

    <span class="s3"># Use dtype of array if possible (e.g., if q is a python int or float).</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">q</span><span class="s2">, (</span><span class="s1">int</span><span class="s2">, </span><span class="s1">float</span><span class="s2">)) </span><span class="s0">and </span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s4">&quot;f&quot;</span><span class="s2">:</span>
        <span class="s1">q </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">q</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">a</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">q </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">q</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">_quantile_is_valid</span><span class="s2">(</span><span class="s1">q</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Quantiles must be in the range [0, 1]&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">weights </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">method </span><span class="s2">!= </span><span class="s4">&quot;inverted_cdf&quot;</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= (</span><span class="s4">&quot;Only method 'inverted_cdf' supports weights. &quot;</span>
                   <span class="s4">f&quot;Got: </span><span class="s0">{</span><span class="s1">method</span><span class="s0">}</span><span class="s4">.&quot;</span><span class="s2">)</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">axis </span><span class="s2">= </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">normalize_axis_tuple</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">argname</span><span class="s2">=</span><span class="s4">&quot;axis&quot;</span><span class="s2">)</span>
        <span class="s1">weights </span><span class="s2">= </span><span class="s1">_weights_are_valid</span><span class="s2">(</span><span class="s1">weights</span><span class="s2">=</span><span class="s1">weights</span><span class="s2">, </span><span class="s1">a</span><span class="s2">=</span><span class="s1">a</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">weights </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Weights must be non-negative.&quot;</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">_quantile_unchecked</span><span class="s2">(</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">out</span><span class="s2">, </span><span class="s1">overwrite_input</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">keepdims</span><span class="s2">, </span><span class="s1">weights</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_quantile_unchecked</span><span class="s2">(</span><span class="s1">a</span><span class="s2">,</span>
                        <span class="s1">q</span><span class="s2">,</span>
                        <span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                        <span class="s1">out</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                        <span class="s1">overwrite_input</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
                        <span class="s1">method</span><span class="s2">=</span><span class="s4">&quot;linear&quot;</span><span class="s2">,</span>
                        <span class="s1">keepdims</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
                        <span class="s1">weights</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Assumes that q is in [0, 1], and is an ndarray&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">_ureduce</span><span class="s2">(</span><span class="s1">a</span><span class="s2">,</span>
                    <span class="s1">func</span><span class="s2">=</span><span class="s1">_quantile_ureduce_func</span><span class="s2">,</span>
                    <span class="s1">q</span><span class="s2">=</span><span class="s1">q</span><span class="s2">,</span>
                    <span class="s1">weights</span><span class="s2">=</span><span class="s1">weights</span><span class="s2">,</span>
                    <span class="s1">keepdims</span><span class="s2">=</span><span class="s1">keepdims</span><span class="s2">,</span>
                    <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
                    <span class="s1">out</span><span class="s2">=</span><span class="s1">out</span><span class="s2">,</span>
                    <span class="s1">overwrite_input</span><span class="s2">=</span><span class="s1">overwrite_input</span><span class="s2">,</span>
                    <span class="s1">method</span><span class="s2">=</span><span class="s1">method</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_quantile_is_valid</span><span class="s2">(</span><span class="s1">q</span><span class="s2">):</span>
    <span class="s3"># avoid expensive reductions, relevant for arrays with &lt; O(1000) elements</span>
    <span class="s0">if </span><span class="s1">q</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">q</span><span class="s2">.</span><span class="s1">size </span><span class="s2">&lt; </span><span class="s5">10</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">q</span><span class="s2">.</span><span class="s1">size</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s2">(</span><span class="s5">0.0 </span><span class="s2">&lt;= </span><span class="s1">q</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] &lt;= </span><span class="s5">1.0</span><span class="s2">):</span>
                <span class="s0">return False</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">if not </span><span class="s2">(</span><span class="s1">q</span><span class="s2">.</span><span class="s1">min</span><span class="s2">() &gt;= </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">q</span><span class="s2">.</span><span class="s1">max</span><span class="s2">() &lt;= </span><span class="s5">1</span><span class="s2">):</span>
            <span class="s0">return False</span>
    <span class="s0">return True</span>


<span class="s0">def </span><span class="s1">_check_interpolation_as_method</span><span class="s2">(</span><span class="s1">method</span><span class="s2">, </span><span class="s1">interpolation</span><span class="s2">, </span><span class="s1">fname</span><span class="s2">):</span>
    <span class="s3"># Deprecated NumPy 1.22, 2021-11-08</span>
    <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
        <span class="s4">f&quot;the `interpolation=` argument to </span><span class="s0">{</span><span class="s1">fname</span><span class="s0">} </span><span class="s4">was renamed to &quot;</span>
        <span class="s4">&quot;`method=`, which has additional options.</span><span class="s0">\n</span><span class="s4">&quot;</span>
        <span class="s4">&quot;Users of the modes 'nearest', 'lower', 'higher', or &quot;</span>
        <span class="s4">&quot;'midpoint' are encouraged to review the method they used. &quot;</span>
        <span class="s4">&quot;(Deprecated NumPy 1.22)&quot;</span><span class="s2">,</span>
        <span class="s1">DeprecationWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">4</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">method </span><span class="s2">!= </span><span class="s4">&quot;linear&quot;</span><span class="s2">:</span>
        <span class="s3"># sanity check, we assume this basically never happens</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
            <span class="s4">&quot;You shall not pass both `method` and `interpolation`!</span><span class="s0">\n</span><span class="s4">&quot;</span>
            <span class="s4">&quot;(`interpolation` is Deprecated in favor of `method`)&quot;</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">interpolation</span>


<span class="s0">def </span><span class="s1">_compute_virtual_index</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">: </span><span class="s1">float</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">: </span><span class="s1">float</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Compute the floating point indexes of an array for the linear 
    interpolation of quantiles. 
    n : array_like 
        The sample sizes. 
    quantiles : array_like 
        The quantiles values. 
    alpha : float 
        A constant used to correct the index computed. 
    beta : float 
        A constant used to correct the index computed. 
 
    alpha and beta values depend on the chosen method 
    (see quantile documentation) 
 
    Reference: 
    Hyndman&amp;Fan paper &quot;Sample Quantiles in Statistical Packages&quot;, 
    DOI: 10.1080/00031305.1996.10473566 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">n </span><span class="s2">* </span><span class="s1">quantiles </span><span class="s2">+ (</span>
            <span class="s1">alpha </span><span class="s2">+ </span><span class="s1">quantiles </span><span class="s2">* (</span><span class="s5">1 </span><span class="s2">- </span><span class="s1">alpha </span><span class="s2">- </span><span class="s1">beta</span><span class="s2">)</span>
    <span class="s2">) - </span><span class="s5">1</span>


<span class="s0">def </span><span class="s1">_get_gamma</span><span class="s2">(</span><span class="s1">virtual_indexes</span><span class="s2">, </span><span class="s1">previous_indexes</span><span class="s2">, </span><span class="s1">method</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Compute gamma (a.k.a 'm' or 'weight') for the linear interpolation 
    of quantiles. 
 
    virtual_indexes : array_like 
        The indexes where the percentile is supposed to be found in the sorted 
        sample. 
    previous_indexes : array_like 
        The floor values of virtual_indexes. 
    interpolation : dict 
        The interpolation method chosen, which may have a specific rule 
        modifying gamma. 
 
    gamma is usually the fractional part of virtual_indexes but can be modified 
    by the interpolation method. 
    &quot;&quot;&quot;</span>
    <span class="s1">gamma </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">virtual_indexes </span><span class="s2">- </span><span class="s1">previous_indexes</span><span class="s2">)</span>
    <span class="s1">gamma </span><span class="s2">= </span><span class="s1">method</span><span class="s2">[</span><span class="s4">&quot;fix_gamma&quot;</span><span class="s2">](</span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">virtual_indexes</span><span class="s2">)</span>
    <span class="s3"># Ensure both that we have an array, and that we keep the dtype</span>
    <span class="s3"># (which may have been matched to the input array).</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">virtual_indexes</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_lerp</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Compute the linear interpolation weighted by gamma on each point of 
    two same shape array. 
 
    a : array_like 
        Left bound. 
    b : array_like 
        Right bound. 
    t : array_like 
        The interpolation weight. 
    out : array_like 
        Output array. 
    &quot;&quot;&quot;</span>
    <span class="s1">diff_b_a </span><span class="s2">= </span><span class="s1">subtract</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">a</span><span class="s2">)</span>
    <span class="s3"># asanyarray is a stop-gap until gh-13105</span>
    <span class="s1">lerp_interpolation </span><span class="s2">= </span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">add</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">diff_b_a </span><span class="s2">* </span><span class="s1">t</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">out</span><span class="s2">))</span>
    <span class="s1">subtract</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">diff_b_a </span><span class="s2">* (</span><span class="s5">1 </span><span class="s2">- </span><span class="s1">t</span><span class="s2">), </span><span class="s1">out</span><span class="s2">=</span><span class="s1">lerp_interpolation</span><span class="s2">, </span><span class="s1">where</span><span class="s2">=</span><span class="s1">t </span><span class="s2">&gt;= </span><span class="s5">0.5</span><span class="s2">,</span>
             <span class="s1">casting</span><span class="s2">=</span><span class="s4">'unsafe'</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">type</span><span class="s2">(</span><span class="s1">lerp_interpolation</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">))</span>
    <span class="s0">if </span><span class="s1">lerp_interpolation</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">out </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">lerp_interpolation </span><span class="s2">= </span><span class="s1">lerp_interpolation</span><span class="s2">[()]  </span><span class="s3"># unpack 0d arrays</span>
    <span class="s0">return </span><span class="s1">lerp_interpolation</span>


<span class="s0">def </span><span class="s1">_get_gamma_mask</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">default_value</span><span class="s2">, </span><span class="s1">conditioned_value</span><span class="s2">, </span><span class="s1">where</span><span class="s2">):</span>
    <span class="s1">out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">default_value</span><span class="s2">)</span>
    <span class="s1">np</span><span class="s2">.</span><span class="s1">copyto</span><span class="s2">(</span><span class="s1">out</span><span class="s2">, </span><span class="s1">conditioned_value</span><span class="s2">, </span><span class="s1">where</span><span class="s2">=</span><span class="s1">where</span><span class="s2">, </span><span class="s1">casting</span><span class="s2">=</span><span class="s4">&quot;unsafe&quot;</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">out</span>


<span class="s0">def </span><span class="s1">_discret_interpolation_to_boundaries</span><span class="s2">(</span><span class="s1">index</span><span class="s2">, </span><span class="s1">gamma_condition_fun</span><span class="s2">):</span>
    <span class="s1">previous </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">floor</span><span class="s2">(</span><span class="s1">index</span><span class="s2">)</span>
    <span class="s1">next </span><span class="s2">= </span><span class="s1">previous </span><span class="s2">+ </span><span class="s5">1</span>
    <span class="s1">gamma </span><span class="s2">= </span><span class="s1">index </span><span class="s2">- </span><span class="s1">previous</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">_get_gamma_mask</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">=</span><span class="s1">index</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">,</span>
                          <span class="s1">default_value</span><span class="s2">=</span><span class="s1">next</span><span class="s2">,</span>
                          <span class="s1">conditioned_value</span><span class="s2">=</span><span class="s1">previous</span><span class="s2">,</span>
                          <span class="s1">where</span><span class="s2">=</span><span class="s1">gamma_condition_fun</span><span class="s2">(</span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">index</span><span class="s2">)</span>
                          <span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">)</span>
    <span class="s3"># Some methods can lead to out-of-bound integers, clip them:</span>
    <span class="s1">res</span><span class="s2">[</span><span class="s1">res </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">] = </span><span class="s5">0</span>
    <span class="s0">return </span><span class="s1">res</span>


<span class="s0">def </span><span class="s1">_closest_observation</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">):</span>
    <span class="s3"># &quot;choose the nearest even order statistic at g=0&quot; (H&amp;F (1996) pp. 362).</span>
    <span class="s3"># Order is 1-based so for zero-based indexing round to nearest odd index.</span>
    <span class="s1">gamma_fun </span><span class="s2">= </span><span class="s0">lambda </span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">index</span><span class="s2">: (</span><span class="s1">gamma </span><span class="s2">== </span><span class="s5">0</span><span class="s2">) &amp; (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">floor</span><span class="s2">(</span><span class="s1">index</span><span class="s2">) % </span><span class="s5">2 </span><span class="s2">== </span><span class="s5">1</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">_discret_interpolation_to_boundaries</span><span class="s2">((</span><span class="s1">n </span><span class="s2">* </span><span class="s1">quantiles</span><span class="s2">) - </span><span class="s5">1 </span><span class="s2">- </span><span class="s5">0.5</span><span class="s2">,</span>
                                                <span class="s1">gamma_fun</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_inverted_cdf</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">):</span>
    <span class="s1">gamma_fun </span><span class="s2">= </span><span class="s0">lambda </span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">_</span><span class="s2">: (</span><span class="s1">gamma </span><span class="s2">== </span><span class="s5">0</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">_discret_interpolation_to_boundaries</span><span class="s2">((</span><span class="s1">n </span><span class="s2">* </span><span class="s1">quantiles</span><span class="s2">) - </span><span class="s5">1</span><span class="s2">,</span>
                                                <span class="s1">gamma_fun</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_quantile_ureduce_func</span><span class="s2">(</span>
        <span class="s1">a</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">,</span>
        <span class="s1">q</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">,</span>
        <span class="s1">weights</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">out</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">overwrite_input</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">method</span><span class="s2">=</span><span class="s4">&quot;linear&quot;</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">:</span>
    <span class="s0">if </span><span class="s1">q</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s3"># The code below works fine for nd, but it might not have useful</span>
        <span class="s3"># semantics. For now, keep the supported dimensions the same as it was</span>
        <span class="s3"># before.</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;q must be a scalar or 1d&quot;</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">overwrite_input</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">axis </span><span class="s2">= </span><span class="s5">0</span>
            <span class="s1">arr </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">()</span>
            <span class="s1">wgt </span><span class="s2">= </span><span class="s0">None if </span><span class="s1">weights </span><span class="s0">is None else </span><span class="s1">weights</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">()</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">arr </span><span class="s2">= </span><span class="s1">a</span>
            <span class="s1">wgt </span><span class="s2">= </span><span class="s1">weights</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">axis </span><span class="s2">= </span><span class="s5">0</span>
            <span class="s1">arr </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">flatten</span><span class="s2">()</span>
            <span class="s1">wgt </span><span class="s2">= </span><span class="s0">None if </span><span class="s1">weights </span><span class="s0">is None else </span><span class="s1">weights</span><span class="s2">.</span><span class="s1">flatten</span><span class="s2">()</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">arr </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s1">wgt </span><span class="s2">= </span><span class="s1">weights</span>
    <span class="s1">result </span><span class="s2">= </span><span class="s1">_quantile</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">,</span>
                       <span class="s1">quantiles</span><span class="s2">=</span><span class="s1">q</span><span class="s2">,</span>
                       <span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">,</span>
                       <span class="s1">method</span><span class="s2">=</span><span class="s1">method</span><span class="s2">,</span>
                       <span class="s1">out</span><span class="s2">=</span><span class="s1">out</span><span class="s2">,</span>
                       <span class="s1">weights</span><span class="s2">=</span><span class="s1">wgt</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">_get_indexes</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">virtual_indexes</span><span class="s2">, </span><span class="s1">valid_values_count</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Get the valid indexes of arr neighbouring virtual_indexes. 
    Note 
    This is a companion function to linear interpolation of 
    Quantiles 
 
    Returns 
    ------- 
    (previous_indexes, next_indexes): Tuple 
        A Tuple of virtual_indexes neighbouring indexes 
    &quot;&quot;&quot;</span>
    <span class="s1">previous_indexes </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">floor</span><span class="s2">(</span><span class="s1">virtual_indexes</span><span class="s2">))</span>
    <span class="s1">next_indexes </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">previous_indexes </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">)</span>
    <span class="s1">indexes_above_bounds </span><span class="s2">= </span><span class="s1">virtual_indexes </span><span class="s2">&gt;= </span><span class="s1">valid_values_count </span><span class="s2">- </span><span class="s5">1</span>
    <span class="s3"># When indexes is above max index, take the max value of the array</span>
    <span class="s0">if </span><span class="s1">indexes_above_bounds</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s1">previous_indexes</span><span class="s2">[</span><span class="s1">indexes_above_bounds</span><span class="s2">] = -</span><span class="s5">1</span>
        <span class="s1">next_indexes</span><span class="s2">[</span><span class="s1">indexes_above_bounds</span><span class="s2">] = -</span><span class="s5">1</span>
    <span class="s3"># When indexes is below min index, take the min value of the array</span>
    <span class="s1">indexes_below_bounds </span><span class="s2">= </span><span class="s1">virtual_indexes </span><span class="s2">&lt; </span><span class="s5">0</span>
    <span class="s0">if </span><span class="s1">indexes_below_bounds</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s1">previous_indexes</span><span class="s2">[</span><span class="s1">indexes_below_bounds</span><span class="s2">] = </span><span class="s5">0</span>
        <span class="s1">next_indexes</span><span class="s2">[</span><span class="s1">indexes_below_bounds</span><span class="s2">] = </span><span class="s5">0</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inexact</span><span class="s2">):</span>
        <span class="s3"># After the sort, slices having NaNs will have for last element a NaN</span>
        <span class="s1">virtual_indexes_nans </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">virtual_indexes</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">virtual_indexes_nans</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
            <span class="s1">previous_indexes</span><span class="s2">[</span><span class="s1">virtual_indexes_nans</span><span class="s2">] = -</span><span class="s5">1</span>
            <span class="s1">next_indexes</span><span class="s2">[</span><span class="s1">virtual_indexes_nans</span><span class="s2">] = -</span><span class="s5">1</span>
    <span class="s1">previous_indexes </span><span class="s2">= </span><span class="s1">previous_indexes</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">)</span>
    <span class="s1">next_indexes </span><span class="s2">= </span><span class="s1">next_indexes</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">previous_indexes</span><span class="s2">, </span><span class="s1">next_indexes</span>


<span class="s0">def </span><span class="s1">_quantile</span><span class="s2">(</span>
        <span class="s1">arr</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">,</span>
        <span class="s1">quantiles</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">,</span>
        <span class="s1">axis</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= -</span><span class="s5">1</span><span class="s2">,</span>
        <span class="s1">method</span><span class="s2">=</span><span class="s4">&quot;linear&quot;</span><span class="s2">,</span>
        <span class="s1">out</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">weights</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
<span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Private function that doesn't support extended axis or keepdims. 
    These methods are extended to this function using _ureduce 
    See nanpercentile for parameter usage 
    It computes the quantiles of the array for the given axis. 
    A linear interpolation is performed based on the `interpolation`. 
 
    By default, the method is &quot;linear&quot; where alpha == beta == 1 which 
    performs the 7th method of Hyndman&amp;Fan. 
    With &quot;median_unbiased&quot; we get alpha == beta == 1/3 
    thus the 8th method of Hyndman&amp;Fan. 
    &quot;&quot;&quot;</span>
    <span class="s3"># --- Setup</span>
    <span class="s1">arr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">)</span>
    <span class="s1">values_count </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
    <span class="s3"># The dimensions of `q` are prepended to the output shape, so we need the</span>
    <span class="s3"># axis being sampled from `arr` to be last.</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s2">!= </span><span class="s5">0</span><span class="s2">:  </span><span class="s3"># But moveaxis is slow, so only call it if necessary.</span>
        <span class="s1">arr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">moveaxis</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">destination</span><span class="s2">=</span><span class="s5">0</span><span class="s2">)</span>
    <span class="s1">supports_nans </span><span class="s2">= (</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inexact</span><span class="s2">) </span><span class="s0">or </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">in </span><span class="s4">'Mm'</span>
    <span class="s2">)</span>

    <span class="s0">if </span><span class="s1">weights </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s3"># --- Computation of indexes</span>
        <span class="s3"># Index where to find the value in the sorted array.</span>
        <span class="s3"># Virtual because it is a floating point value, not an valid index.</span>
        <span class="s3"># The nearest neighbours are used for interpolation</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">method_props </span><span class="s2">= </span><span class="s1">_QuantileMethods</span><span class="s2">[</span><span class="s1">method</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">method</span><span class="s0">!r} </span><span class="s4">is not a valid method. Use one of: &quot;</span>
                <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">_QuantileMethods</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s2">) </span><span class="s0">from None</span>
        <span class="s1">virtual_indexes </span><span class="s2">= </span><span class="s1">method_props</span><span class="s2">[</span><span class="s4">&quot;get_virtual_index&quot;</span><span class="s2">](</span><span class="s1">values_count</span><span class="s2">,</span>
                                                            <span class="s1">quantiles</span><span class="s2">)</span>
        <span class="s1">virtual_indexes </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">virtual_indexes</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">method_props</span><span class="s2">[</span><span class="s4">&quot;fix_gamma&quot;</span><span class="s2">] </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">supports_integers </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">int_virtual_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">virtual_indexes</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">,</span>
                                                <span class="s1">np</span><span class="s2">.</span><span class="s1">integer</span><span class="s2">)</span>
            <span class="s1">supports_integers </span><span class="s2">= </span><span class="s1">method </span><span class="s2">== </span><span class="s4">'linear' </span><span class="s0">and </span><span class="s1">int_virtual_indices</span>

        <span class="s0">if </span><span class="s1">supports_integers</span><span class="s2">:</span>
            <span class="s3"># No interpolation needed, take the points along axis</span>
            <span class="s0">if </span><span class="s1">supports_nans</span><span class="s2">:</span>
                <span class="s3"># may contain nan, which would sort to the end</span>
                <span class="s1">arr</span><span class="s2">.</span><span class="s1">partition</span><span class="s2">(</span>
                    <span class="s1">concatenate</span><span class="s2">((</span><span class="s1">virtual_indexes</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">(), [-</span><span class="s5">1</span><span class="s2">])), </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">,</span>
                <span class="s2">)</span>
                <span class="s1">slices_having_nans </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">, ...])</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s3"># cannot contain nan</span>
                <span class="s1">arr</span><span class="s2">.</span><span class="s1">partition</span><span class="s2">(</span><span class="s1">virtual_indexes</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">(), </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">)</span>
                <span class="s1">slices_having_nans </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s0">False</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">take</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">virtual_indexes</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">out</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">previous_indexes</span><span class="s2">, </span><span class="s1">next_indexes </span><span class="s2">= </span><span class="s1">_get_indexes</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">,</span>
                                                          <span class="s1">virtual_indexes</span><span class="s2">,</span>
                                                          <span class="s1">values_count</span><span class="s2">)</span>
            <span class="s3"># --- Sorting</span>
            <span class="s1">arr</span><span class="s2">.</span><span class="s1">partition</span><span class="s2">(</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">unique</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(([</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">],</span>
                                          <span class="s1">previous_indexes</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">(),</span>
                                          <span class="s1">next_indexes</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">(),</span>
                                          <span class="s2">))),</span>
                <span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">supports_nans</span><span class="s2">:</span>
                <span class="s1">slices_having_nans </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">, ...])</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">slices_having_nans </span><span class="s2">= </span><span class="s0">None</span>
            <span class="s3"># --- Get values from indexes</span>
            <span class="s1">previous </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">[</span><span class="s1">previous_indexes</span><span class="s2">]</span>
            <span class="s1">next </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">[</span><span class="s1">next_indexes</span><span class="s2">]</span>
            <span class="s3"># --- Linear interpolation</span>
            <span class="s1">gamma </span><span class="s2">= </span><span class="s1">_get_gamma</span><span class="s2">(</span><span class="s1">virtual_indexes</span><span class="s2">, </span><span class="s1">previous_indexes</span><span class="s2">, </span><span class="s1">method_props</span><span class="s2">)</span>
            <span class="s1">result_shape </span><span class="s2">= </span><span class="s1">virtual_indexes</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">+ (</span><span class="s5">1</span><span class="s2">,) * (</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">- </span><span class="s5">1</span><span class="s2">)</span>
            <span class="s1">gamma </span><span class="s2">= </span><span class="s1">gamma</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">result_shape</span><span class="s2">)</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">_lerp</span><span class="s2">(</span><span class="s1">previous</span><span class="s2">,</span>
                        <span class="s1">next</span><span class="s2">,</span>
                        <span class="s1">gamma</span><span class="s2">,</span>
                        <span class="s1">out</span><span class="s2">=</span><span class="s1">out</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s3"># Weighted case</span>
        <span class="s3"># This implements method=&quot;inverted_cdf&quot;, the only supported weighted</span>
        <span class="s3"># method, which needs to sort anyway.</span>
        <span class="s1">weights </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">weights</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s2">!= </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">weights </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">moveaxis</span><span class="s2">(</span><span class="s1">weights</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">destination</span><span class="s2">=</span><span class="s5">0</span><span class="s2">)</span>
        <span class="s1">index_array </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argsort</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">=</span><span class="s4">&quot;stable&quot;</span><span class="s2">)</span>

        <span class="s3"># arr = arr[index_array, ...]  # but this adds trailing dimensions of</span>
        <span class="s3"># 1.</span>
        <span class="s1">arr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">take_along_axis</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">index_array</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">weights</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
            <span class="s1">weights </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">take_along_axis</span><span class="s2">(</span><span class="s1">weights</span><span class="s2">, </span><span class="s1">index_array</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s3"># weights is 1d</span>
            <span class="s1">weights </span><span class="s2">= </span><span class="s1">weights</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s5">1</span><span class="s2">)[</span><span class="s1">index_array</span><span class="s2">, ...]</span>

        <span class="s0">if </span><span class="s1">supports_nans</span><span class="s2">:</span>
            <span class="s3"># may contain nan, which would sort to the end</span>
            <span class="s1">slices_having_nans </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">, ...])</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s3"># cannot contain nan</span>
            <span class="s1">slices_having_nans </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s0">False</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>

        <span class="s3"># We use the weights to calculate the empirical cumulative</span>
        <span class="s3"># distribution function cdf</span>
        <span class="s1">cdf </span><span class="s2">= </span><span class="s1">weights</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
        <span class="s1">cdf </span><span class="s2">/= </span><span class="s1">cdf</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">, ...]  </span><span class="s3"># normalization to 1</span>
        <span class="s3"># Search index i such that</span>
        <span class="s3">#   sum(weights[j], j=0..i-1) &lt; quantile &lt;= sum(weights[j], j=0..i)</span>
        <span class="s3"># is then equivalent to</span>
        <span class="s3">#   cdf[i-1] &lt; quantile &lt;= cdf[i]</span>
        <span class="s3"># Unfortunately, searchsorted only accepts 1-d arrays as first</span>
        <span class="s3"># argument, so we will need to iterate over dimensions.</span>

        <span class="s3"># Without the following cast, searchsorted can return surprising</span>
        <span class="s3"># results, e.g.</span>
        <span class="s3">#   np.searchsorted(np.array([0.2, 0.4, 0.6, 0.8, 1.]),</span>
        <span class="s3">#                   np.array(0.4, dtype=np.float32), side=&quot;left&quot;)</span>
        <span class="s3"># returns 2 instead of 1 because 0.4 is not binary representable.</span>
        <span class="s0">if </span><span class="s1">quantiles</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">== </span><span class="s4">&quot;f&quot;</span><span class="s2">:</span>
            <span class="s1">cdf </span><span class="s2">= </span><span class="s1">cdf</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">quantiles</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">find_cdf_1d</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">cdf</span><span class="s2">):</span>
            <span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">searchsorted</span><span class="s2">(</span><span class="s1">cdf</span><span class="s2">, </span><span class="s1">quantiles</span><span class="s2">, </span><span class="s1">side</span><span class="s2">=</span><span class="s4">&quot;left&quot;</span><span class="s2">)</span>
            <span class="s3"># We might have reached the maximum with i = len(arr), e.g. for</span>
            <span class="s3"># quantiles = 1, and need to cut it to len(arr) - 1.</span>
            <span class="s1">indices </span><span class="s2">= </span><span class="s1">minimum</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">values_count </span><span class="s2">- </span><span class="s5">1</span><span class="s2">)</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">take</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">result</span>

        <span class="s1">r_shape </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]</span>
        <span class="s0">if </span><span class="s1">quantiles</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">: </span>
            <span class="s1">r_shape </span><span class="s2">= </span><span class="s1">quantiles</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">+ </span><span class="s1">r_shape</span>
        <span class="s0">if </span><span class="s1">out </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">r_shape</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">out</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">r_shape</span><span class="s2">:</span>
                <span class="s1">msg </span><span class="s2">= (</span><span class="s4">f&quot;Wrong shape of argument 'out', shape=</span><span class="s0">{</span><span class="s1">r_shape</span><span class="s0">} </span><span class="s4">is &quot;</span>
                       <span class="s4">f&quot;required; got shape=</span><span class="s0">{</span><span class="s1">out</span><span class="s2">.</span><span class="s1">shape</span><span class="s0">}</span><span class="s4">.&quot;</span><span class="s2">)</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">out</span>

        <span class="s3"># See apply_along_axis, which we do for axis=0. Note that Ni = (,)</span>
        <span class="s3"># always, so we remove it here.</span>
        <span class="s1">Nk </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]</span>
        <span class="s0">for </span><span class="s1">kk </span><span class="s0">in </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndindex</span><span class="s2">(</span><span class="s1">Nk</span><span class="s2">):</span>
            <span class="s1">result</span><span class="s2">[(...,) + </span><span class="s1">kk</span><span class="s2">] = </span><span class="s1">find_cdf_1d</span><span class="s2">(</span>
                <span class="s1">arr</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">s_</span><span class="s2">[:, ] + </span><span class="s1">kk</span><span class="s2">], </span><span class="s1">cdf</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">s_</span><span class="s2">[:, ] + </span><span class="s1">kk</span><span class="s2">]</span>
            <span class="s2">)</span>

        <span class="s3"># Make result the same as in unweighted inverted_cdf.</span>
        <span class="s0">if </span><span class="s1">result</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== () </span><span class="s0">and </span><span class="s1">result</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s4">&quot;O&quot;</span><span class="s2">):</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">item</span><span class="s2">()</span>

    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">slices_having_nans</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">result</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">out </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s3"># can't write to a scalar, but indexing will be correct</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">copyto</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">, ...], </span><span class="s1">where</span><span class="s2">=</span><span class="s1">slices_having_nans</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">_trapezoid_dispatcher</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_trapezoid_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">trapezoid</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">=</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">):</span>
    <span class="s6">r&quot;&quot;&quot; 
    Integrate along the given axis using the composite trapezoidal rule. 
 
    If `x` is provided, the integration happens in sequence along its 
    elements - they are not sorted. 
 
    Integrate `y` (`x`) along each 1d slice on the given axis, compute 
    :math:`\int y(x) dx`. 
    When `x` is specified, this integrates along the parametric curve, 
    computing :math:`\int_t y(t) dt = 
    \int_t y(t) \left.\frac{dx}{dt}\right|_{x=x(t)} dt`. 
 
    .. versionadded:: 2.0.0 
 
    Parameters 
    ---------- 
    y : array_like 
        Input array to integrate. 
    x : array_like, optional 
        The sample points corresponding to the `y` values. If `x` is None, 
        the sample points are assumed to be evenly spaced `dx` apart. The 
        default is None. 
    dx : scalar, optional 
        The spacing between sample points when `x` is None. The default is 1. 
    axis : int, optional 
        The axis along which to integrate. 
 
    Returns 
    ------- 
    trapezoid : float or ndarray 
        Definite integral of `y` = n-dimensional array as approximated along 
        a single axis by the trapezoidal rule. If `y` is a 1-dimensional array, 
        then the result is a float. If `n` is greater than 1, then the result 
        is an `n`-1 dimensional array. 
 
    See Also 
    -------- 
    sum, cumsum 
 
    Notes 
    ----- 
    Image [2]_ illustrates trapezoidal rule -- y-axis locations of points 
    will be taken from `y` array, by default x-axis distances between 
    points will be 1.0, alternatively they can be provided with `x` array 
    or with `dx` scalar.  Return value will be equal to combined area under 
    the red lines. 
 
 
    References 
    ---------- 
    .. [1] Wikipedia page: https://en.wikipedia.org/wiki/Trapezoidal_rule 
 
    .. [2] Illustration image: 
           https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
 
    Use the trapezoidal rule on evenly spaced points: 
 
    &gt;&gt;&gt; np.trapezoid([1, 2, 3]) 
    4.0 
 
    The spacing between sample points can be selected by either the 
    ``x`` or ``dx`` arguments: 
 
    &gt;&gt;&gt; np.trapezoid([1, 2, 3], x=[4, 6, 8]) 
    8.0 
    &gt;&gt;&gt; np.trapezoid([1, 2, 3], dx=2) 
    8.0 
 
    Using a decreasing ``x`` corresponds to integrating in reverse: 
 
    &gt;&gt;&gt; np.trapezoid([1, 2, 3], x=[8, 6, 4]) 
    -8.0 
 
    More generally ``x`` is used to integrate along a parametric curve. We can 
    estimate the integral :math:`\int_0^1 x^2 = 1/3` using: 
 
    &gt;&gt;&gt; x = np.linspace(0, 1, num=50) 
    &gt;&gt;&gt; y = x**2 
    &gt;&gt;&gt; np.trapezoid(y, x) 
    0.33340274885464394 
 
    Or estimate the area of a circle, noting we repeat the sample which closes 
    the curve: 
 
    &gt;&gt;&gt; theta = np.linspace(0, 2 * np.pi, num=1000, endpoint=True) 
    &gt;&gt;&gt; np.trapezoid(np.cos(theta), x=np.sin(theta)) 
    3.141571941375841 
 
    ``np.trapezoid`` can be applied along a specified axis to do multiple 
    computations in one call: 
 
    &gt;&gt;&gt; a = np.arange(6).reshape(2, 3) 
    &gt;&gt;&gt; a 
    array([[0, 1, 2], 
           [3, 4, 5]]) 
    &gt;&gt;&gt; np.trapezoid(a, axis=0) 
    array([1.5, 2.5, 3.5]) 
    &gt;&gt;&gt; np.trapezoid(a, axis=1) 
    array([2.,  8.]) 
    &quot;&quot;&quot;</span>

    <span class="s1">y </span><span class="s2">= </span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">x </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">dx</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">d </span><span class="s2">= </span><span class="s1">diff</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
            <span class="s3"># reshape to correct shape</span>
            <span class="s1">shape </span><span class="s2">= [</span><span class="s5">1</span><span class="s2">]*</span><span class="s1">y</span><span class="s2">.</span><span class="s1">ndim</span>
            <span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">d</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s1">d </span><span class="s2">= </span><span class="s1">d</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">d </span><span class="s2">= </span><span class="s1">diff</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s1">nd </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">ndim</span>
    <span class="s1">slice1 </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)]*</span><span class="s1">nd</span>
    <span class="s1">slice2 </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)]*</span><span class="s1">nd</span>
    <span class="s1">slice1</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
    <span class="s1">slice2</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">ret </span><span class="s2">= (</span><span class="s1">d </span><span class="s2">* (</span><span class="s1">y</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice1</span><span class="s2">)] + </span><span class="s1">y</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice2</span><span class="s2">)]) / </span><span class="s5">2.0</span><span class="s2">).</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">ValueError</span><span class="s2">:</span>
        <span class="s3"># Operations didn't work, cast to ndarray</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">d</span><span class="s2">)</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
        <span class="s1">ret </span><span class="s2">= </span><span class="s1">add</span><span class="s2">.</span><span class="s1">reduce</span><span class="s2">(</span><span class="s1">d </span><span class="s2">* (</span><span class="s1">y</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice1</span><span class="s2">)]+</span><span class="s1">y</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slice2</span><span class="s2">)])/</span><span class="s5">2.0</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">ret</span>


<span class="s2">@</span><span class="s1">set_module</span><span class="s2">(</span><span class="s4">'numpy'</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">trapz</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">=</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    `trapz` is deprecated in NumPy 2.0. 
 
    Please use `trapezoid` instead, or one of the numerical integration 
    functions in `scipy.integrate`. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Deprecated in NumPy 2.0, 2023-08-18</span>
    <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
        <span class="s4">&quot;`trapz` is deprecated. Use `trapezoid` instead, or one of the &quot;</span>
        <span class="s4">&quot;numerical integration functions in `scipy.integrate`.&quot;</span><span class="s2">,</span>
        <span class="s1">DeprecationWarning</span><span class="s2">,</span>
        <span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span>
    <span class="s2">)</span>
    <span class="s0">return </span><span class="s1">trapezoid</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">=</span><span class="s1">x</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">=</span><span class="s1">dx</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_meshgrid_dispatcher</span><span class="s2">(*</span><span class="s1">xi</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">sparse</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">indexing</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">xi</span>


<span class="s3"># Based on scitools meshgrid</span>
<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_meshgrid_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">meshgrid</span><span class="s2">(*</span><span class="s1">xi</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">sparse</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">indexing</span><span class="s2">=</span><span class="s4">'xy'</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return a tuple of coordinate matrices from coordinate vectors. 
 
    Make N-D coordinate arrays for vectorized evaluations of 
    N-D scalar/vector fields over N-D grids, given 
    one-dimensional coordinate arrays x1, x2,..., xn. 
 
    .. versionchanged:: 1.9 
       1-D and 0-D cases are allowed. 
 
    Parameters 
    ---------- 
    x1, x2,..., xn : array_like 
        1-D arrays representing the coordinates of a grid. 
    indexing : {'xy', 'ij'}, optional 
        Cartesian ('xy', default) or matrix ('ij') indexing of output. 
        See Notes for more details. 
 
        .. versionadded:: 1.7.0 
    sparse : bool, optional 
        If True the shape of the returned coordinate array for dimension *i* 
        is reduced from ``(N1, ..., Ni, ... Nn)`` to 
        ``(1, ..., 1, Ni, 1, ..., 1)``.  These sparse coordinate grids are 
        intended to be use with :ref:`basics.broadcasting`.  When all 
        coordinates are used in an expression, broadcasting still leads to a 
        fully-dimensonal result array. 
 
        Default is False. 
 
        .. versionadded:: 1.7.0 
    copy : bool, optional 
        If False, a view into the original arrays are returned in order to 
        conserve memory.  Default is True.  Please note that 
        ``sparse=False, copy=False`` will likely return non-contiguous 
        arrays.  Furthermore, more than one element of a broadcast array 
        may refer to a single memory location.  If you need to write to the 
        arrays, make copies first. 
 
        .. versionadded:: 1.7.0 
 
    Returns 
    ------- 
    X1, X2,..., XN : tuple of ndarrays 
        For vectors `x1`, `x2`,..., `xn` with lengths ``Ni=len(xi)``, 
        returns ``(N1, N2, N3,..., Nn)`` shaped arrays if indexing='ij' 
        or ``(N2, N1, N3,..., Nn)`` shaped arrays if indexing='xy' 
        with the elements of `xi` repeated to fill the matrix along 
        the first dimension for `x1`, the second for `x2` and so on. 
 
    Notes 
    ----- 
    This function supports both indexing conventions through the indexing 
    keyword argument.  Giving the string 'ij' returns a meshgrid with 
    matrix indexing, while 'xy' returns a meshgrid with Cartesian indexing. 
    In the 2-D case with inputs of length M and N, the outputs are of shape 
    (N, M) for 'xy' indexing and (M, N) for 'ij' indexing.  In the 3-D case 
    with inputs of length M, N and P, outputs are of shape (N, M, P) for 
    'xy' indexing and (M, N, P) for 'ij' indexing.  The difference is 
    illustrated by the following code snippet:: 
 
        xv, yv = np.meshgrid(x, y, indexing='ij') 
        for i in range(nx): 
            for j in range(ny): 
                # treat xv[i,j], yv[i,j] 
 
        xv, yv = np.meshgrid(x, y, indexing='xy') 
        for i in range(nx): 
            for j in range(ny): 
                # treat xv[j,i], yv[j,i] 
 
    In the 1-D and 0-D case, the indexing and sparse keywords have no effect. 
 
    See Also 
    -------- 
    mgrid : Construct a multi-dimensional &quot;meshgrid&quot; using indexing notation. 
    ogrid : Construct an open multi-dimensional &quot;meshgrid&quot; using indexing 
            notation. 
    :ref:`how-to-index` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; nx, ny = (3, 2) 
    &gt;&gt;&gt; x = np.linspace(0, 1, nx) 
    &gt;&gt;&gt; y = np.linspace(0, 1, ny) 
    &gt;&gt;&gt; xv, yv = np.meshgrid(x, y) 
    &gt;&gt;&gt; xv 
    array([[0. , 0.5, 1. ], 
           [0. , 0.5, 1. ]]) 
    &gt;&gt;&gt; yv 
    array([[0.,  0.,  0.], 
           [1.,  1.,  1.]]) 
 
    The result of `meshgrid` is a coordinate grid: 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.plot(xv, yv, marker='o', color='k', linestyle='none') 
    &gt;&gt;&gt; plt.show() 
 
    You can create sparse output arrays to save memory and computation time. 
 
    &gt;&gt;&gt; xv, yv = np.meshgrid(x, y, sparse=True) 
    &gt;&gt;&gt; xv 
    array([[0. ,  0.5,  1. ]]) 
    &gt;&gt;&gt; yv 
    array([[0.], 
           [1.]]) 
 
    `meshgrid` is very useful to evaluate functions on a grid. If the 
    function depends on all coordinates, both dense and sparse outputs can be 
    used. 
 
    &gt;&gt;&gt; x = np.linspace(-5, 5, 101) 
    &gt;&gt;&gt; y = np.linspace(-5, 5, 101) 
    &gt;&gt;&gt; # full coordinate arrays 
    &gt;&gt;&gt; xx, yy = np.meshgrid(x, y) 
    &gt;&gt;&gt; zz = np.sqrt(xx**2 + yy**2) 
    &gt;&gt;&gt; xx.shape, yy.shape, zz.shape 
    ((101, 101), (101, 101), (101, 101)) 
    &gt;&gt;&gt; # sparse coordinate arrays 
    &gt;&gt;&gt; xs, ys = np.meshgrid(x, y, sparse=True) 
    &gt;&gt;&gt; zs = np.sqrt(xs**2 + ys**2) 
    &gt;&gt;&gt; xs.shape, ys.shape, zs.shape 
    ((1, 101), (101, 1), (101, 101)) 
    &gt;&gt;&gt; np.array_equal(zz, zs) 
    True 
 
    &gt;&gt;&gt; h = plt.contourf(x, y, zs) 
    &gt;&gt;&gt; plt.axis('scaled') 
    &gt;&gt;&gt; plt.colorbar() 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">ndim </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">xi</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">indexing </span><span class="s0">not in </span><span class="s2">[</span><span class="s4">'xy'</span><span class="s2">, </span><span class="s4">'ij'</span><span class="s2">]:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">&quot;Valid values for `indexing` are 'xy' and 'ij'.&quot;</span><span class="s2">)</span>

    <span class="s1">s0 </span><span class="s2">= (</span><span class="s5">1</span><span class="s2">,) * </span><span class="s1">ndim</span>
    <span class="s1">output </span><span class="s2">= [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">s0</span><span class="s2">[:</span><span class="s1">i</span><span class="s2">] + (-</span><span class="s5">1</span><span class="s2">,) + </span><span class="s1">s0</span><span class="s2">[</span><span class="s1">i </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">:])</span>
              <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">xi</span><span class="s2">)]</span>

    <span class="s0">if </span><span class="s1">indexing </span><span class="s2">== </span><span class="s4">'xy' </span><span class="s0">and </span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s3"># switch first and second axis</span>
        <span class="s1">output</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">shape </span><span class="s2">= (</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">) + </span><span class="s1">s0</span><span class="s2">[</span><span class="s5">2</span><span class="s2">:]</span>
        <span class="s1">output</span><span class="s2">[</span><span class="s5">1</span><span class="s2">].</span><span class="s1">shape </span><span class="s2">= (-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">) + </span><span class="s1">s0</span><span class="s2">[</span><span class="s5">2</span><span class="s2">:]</span>

    <span class="s0">if not </span><span class="s1">sparse</span><span class="s2">:</span>
        <span class="s3"># Return the full N-D matrix (not only the 1-D vector)</span>
        <span class="s1">output </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_arrays</span><span class="s2">(*</span><span class="s1">output</span><span class="s2">, </span><span class="s1">subok</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">copy</span><span class="s2">:</span>
        <span class="s1">output </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">() </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">output</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">output</span>


<span class="s0">def </span><span class="s1">_delete_dispatcher</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_delete_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">delete</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return a new array with sub-arrays along an axis deleted. For a one 
    dimensional array, this returns those entries not returned by 
    `arr[obj]`. 
 
    Parameters 
    ---------- 
    arr : array_like 
        Input array. 
    obj : slice, int or array of ints 
        Indicate indices of sub-arrays to remove along the specified axis. 
 
        .. versionchanged:: 1.19.0 
            Boolean indices are now treated as a mask of elements to remove, 
            rather than being cast to the integers 0 and 1. 
 
    axis : int, optional 
        The axis along which to delete the subarray defined by `obj`. 
        If `axis` is None, `obj` is applied to the flattened array. 
 
    Returns 
    ------- 
    out : ndarray 
        A copy of `arr` with the elements specified by `obj` removed. Note 
        that `delete` does not occur in-place. If `axis` is None, `out` is 
        a flattened array. 
 
    See Also 
    -------- 
    insert : Insert elements into an array. 
    append : Append elements at the end of an array. 
 
    Notes 
    ----- 
    Often it is preferable to use a boolean mask. For example: 
 
    &gt;&gt;&gt; arr = np.arange(12) + 1 
    &gt;&gt;&gt; mask = np.ones(len(arr), dtype=bool) 
    &gt;&gt;&gt; mask[[0,2,4]] = False 
    &gt;&gt;&gt; result = arr[mask,...] 
 
    Is equivalent to ``np.delete(arr, [0,2,4], axis=0)``, but allows further 
    use of `mask`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]]) 
    &gt;&gt;&gt; arr 
    array([[ 1,  2,  3,  4], 
           [ 5,  6,  7,  8], 
           [ 9, 10, 11, 12]]) 
    &gt;&gt;&gt; np.delete(arr, 1, 0) 
    array([[ 1,  2,  3,  4], 
           [ 9, 10, 11, 12]]) 
 
    &gt;&gt;&gt; np.delete(arr, np.s_[::2], 1) 
    array([[ 2,  4], 
           [ 6,  8], 
           [10, 12]]) 
    &gt;&gt;&gt; np.delete(arr, [1,3,5], None) 
    array([ 1,  3,  5,  7,  8,  9, 10, 11, 12]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">conv </span><span class="s2">= </span><span class="s1">_array_converter</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">)</span>
    <span class="s1">arr</span><span class="s2">, = </span><span class="s1">conv</span><span class="s2">.</span><span class="s1">as_arrays</span><span class="s2">(</span><span class="s1">subok</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s1">ndim </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ndim</span>
    <span class="s1">arrorder </span><span class="s2">= </span><span class="s4">'F' </span><span class="s0">if </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">fnc </span><span class="s0">else </span><span class="s4">'C'</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">arr </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">()</span>
        <span class="s3"># needed for np.matrix, which is still not 1d after being ravelled</span>
        <span class="s1">ndim </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ndim</span>
        <span class="s1">axis </span><span class="s2">= </span><span class="s1">ndim </span><span class="s2">- </span><span class="s5">1</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">axis </span><span class="s2">= </span><span class="s1">normalize_axis_index</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">)</span>

    <span class="s1">slobj </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)]*</span><span class="s1">ndim</span>
    <span class="s1">N </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
    <span class="s1">newshape </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">):</span>
        <span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">(</span><span class="s1">N</span><span class="s2">)</span>
        <span class="s1">xr </span><span class="s2">= </span><span class="s1">range</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step</span><span class="s2">)</span>
        <span class="s1">numtodel </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">xr</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">numtodel </span><span class="s2">&lt;= </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">conv</span><span class="s2">.</span><span class="s1">wrap</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">order</span><span class="s2">=</span><span class="s1">arrorder</span><span class="s2">), </span><span class="s1">to_scalar</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

        <span class="s3"># Invert if step is negative:</span>
        <span class="s0">if </span><span class="s1">step </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">step </span><span class="s2">= -</span><span class="s1">step</span>
            <span class="s1">start </span><span class="s2">= </span><span class="s1">xr</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span>
            <span class="s1">stop </span><span class="s2">= </span><span class="s1">xr</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] + </span><span class="s5">1</span>

        <span class="s1">newshape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] -= </span><span class="s1">numtodel</span>
        <span class="s1">new </span><span class="s2">= </span><span class="s1">empty</span><span class="s2">(</span><span class="s1">newshape</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">arrorder</span><span class="s2">)</span>
        <span class="s3"># copy initial chunk</span>
        <span class="s0">if </span><span class="s1">start </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">slobj</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, </span><span class="s1">start</span><span class="s2">)</span>
            <span class="s1">new</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj</span><span class="s2">)] = </span><span class="s1">arr</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj</span><span class="s2">)]</span>
        <span class="s3"># copy end chunk</span>
        <span class="s0">if </span><span class="s1">stop </span><span class="s2">== </span><span class="s1">N</span><span class="s2">:</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">slobj</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">stop</span><span class="s2">-</span><span class="s1">numtodel</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s1">slobj2 </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)]*</span><span class="s1">ndim</span>
            <span class="s1">slobj2</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">stop</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s1">new</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj</span><span class="s2">)] = </span><span class="s1">arr</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj2</span><span class="s2">)]</span>
        <span class="s3"># copy middle pieces</span>
        <span class="s0">if </span><span class="s1">step </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s2">:  </span><span class="s3"># use array indexing.</span>
            <span class="s1">keep </span><span class="s2">= </span><span class="s1">ones</span><span class="s2">(</span><span class="s1">stop</span><span class="s2">-</span><span class="s1">start</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
            <span class="s1">keep</span><span class="s2">[:</span><span class="s1">stop</span><span class="s2">-</span><span class="s1">start</span><span class="s2">:</span><span class="s1">step</span><span class="s2">] = </span><span class="s0">False</span>
            <span class="s1">slobj</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">-</span><span class="s1">numtodel</span><span class="s2">)</span>
            <span class="s1">slobj2 </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)]*</span><span class="s1">ndim</span>
            <span class="s1">slobj2</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">)</span>
            <span class="s1">arr </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj2</span><span class="s2">)]</span>
            <span class="s1">slobj2</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">keep</span>
            <span class="s1">new</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj</span><span class="s2">)] = </span><span class="s1">arr</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj2</span><span class="s2">)]</span>

        <span class="s0">return </span><span class="s1">conv</span><span class="s2">.</span><span class="s1">wrap</span><span class="s2">(</span><span class="s1">new</span><span class="s2">, </span><span class="s1">to_scalar</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, (</span><span class="s1">int</span><span class="s2">, </span><span class="s1">integer</span><span class="s2">)) </span><span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">):</span>
        <span class="s1">single_value </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">single_value </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s1">_obj </span><span class="s2">= </span><span class="s1">obj</span>
        <span class="s1">obj </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">)</span>
        <span class="s3"># `size == 0` to allow empty lists similar to indexing, but (as there)</span>
        <span class="s3"># is really too generic:</span>
        <span class="s0">if </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s5">0 </span><span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">_obj</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">):</span>
            <span class="s1">obj </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">intp</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s0">in </span><span class="s4">&quot;ui&quot;</span><span class="s2">:</span>
            <span class="s3"># For a size 1 integer array we can use the single-value path</span>
            <span class="s3"># (most dtypes, except boolean, should just fail later).</span>
            <span class="s1">obj </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">item</span><span class="s2">()</span>
            <span class="s1">single_value </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s0">if </span><span class="s1">single_value</span><span class="s2">:</span>
        <span class="s3"># optimization for a single value</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">obj </span><span class="s2">&lt; -</span><span class="s1">N </span><span class="s0">or </span><span class="s1">obj </span><span class="s2">&gt;= </span><span class="s1">N</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">IndexError</span><span class="s2">(</span>
                <span class="s4">&quot;index %i is out of bounds for axis %i with &quot;</span>
                <span class="s4">&quot;size %i&quot; </span><span class="s2">% (</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">N</span><span class="s2">))</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">obj </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">):</span>
            <span class="s1">obj </span><span class="s2">+= </span><span class="s1">N</span>
        <span class="s1">newshape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] -= </span><span class="s5">1</span>
        <span class="s1">new </span><span class="s2">= </span><span class="s1">empty</span><span class="s2">(</span><span class="s1">newshape</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">arrorder</span><span class="s2">)</span>
        <span class="s1">slobj</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">)</span>
        <span class="s1">new</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj</span><span class="s2">)] = </span><span class="s1">arr</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj</span><span class="s2">)]</span>
        <span class="s1">slobj</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">slobj2 </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)]*</span><span class="s1">ndim</span>
        <span class="s1">slobj2</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">+</span><span class="s5">1</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">new</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj</span><span class="s2">)] = </span><span class="s1">arr</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj2</span><span class="s2">)]</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">bool</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= (</span><span class="s1">N</span><span class="s2">,):</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">'boolean array argument obj to delete '</span>
                                 <span class="s4">'must be one dimensional and match the axis '</span>
                                 <span class="s4">'length of {}'</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">N</span><span class="s2">))</span>

            <span class="s3"># optimization, the other branch is slower</span>
            <span class="s1">keep </span><span class="s2">= ~</span><span class="s1">obj</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">keep </span><span class="s2">= </span><span class="s1">ones</span><span class="s2">(</span><span class="s1">N</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
            <span class="s1">keep</span><span class="s2">[</span><span class="s1">obj</span><span class="s2">,] = </span><span class="s0">False</span>

        <span class="s1">slobj</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">keep</span>
        <span class="s1">new </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj</span><span class="s2">)]</span>

    <span class="s0">return </span><span class="s1">conv</span><span class="s2">.</span><span class="s1">wrap</span><span class="s2">(</span><span class="s1">new</span><span class="s2">, </span><span class="s1">to_scalar</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_insert_dispatcher</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">values</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_insert_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">insert</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Insert values along the given axis before the given indices. 
 
    Parameters 
    ---------- 
    arr : array_like 
        Input array. 
    obj : int, slice or sequence of ints 
        Object that defines the index or indices before which `values` is 
        inserted. 
 
        .. versionadded:: 1.8.0 
 
        Support for multiple insertions when `obj` is a single scalar or a 
        sequence with one element (similar to calling insert multiple 
        times). 
    values : array_like 
        Values to insert into `arr`. If the type of `values` is different 
        from that of `arr`, `values` is converted to the type of `arr`. 
        `values` should be shaped so that ``arr[...,obj,...] = values`` 
        is legal. 
    axis : int, optional 
        Axis along which to insert `values`.  If `axis` is None then `arr` 
        is flattened first. 
 
    Returns 
    ------- 
    out : ndarray 
        A copy of `arr` with `values` inserted.  Note that `insert` 
        does not occur in-place: a new array is returned. If 
        `axis` is None, `out` is a flattened array. 
 
    See Also 
    -------- 
    append : Append elements at the end of an array. 
    concatenate : Join a sequence of arrays along an existing axis. 
    delete : Delete elements from an array. 
 
    Notes 
    ----- 
    Note that for higher dimensional inserts ``obj=0`` behaves very different 
    from ``obj=[0]`` just like ``arr[:,0,:] = values`` is different from 
    ``arr[:,[0],:] = values``. This is because of the difference between basic 
    and advanced :ref:`indexing &lt;basics.indexing&gt;`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.arange(6).reshape(3, 2) 
    &gt;&gt;&gt; a 
    array([[0, 1], 
           [2, 3], 
           [4, 5]]) 
    &gt;&gt;&gt; np.insert(a, 1, 6) 
    array([0, 6, 1, 2, 3, 4, 5]) 
    &gt;&gt;&gt; np.insert(a, 1, 6, axis=1) 
    array([[0, 6, 1], 
           [2, 6, 3], 
           [4, 6, 5]]) 
 
    Difference between sequence and scalars, 
    showing how ``obj=[1]`` behaves different from ``obj=1``: 
 
    &gt;&gt;&gt; np.insert(a, [1], [[7],[8],[9]], axis=1) 
    array([[0, 7, 1], 
           [2, 8, 3], 
           [4, 9, 5]]) 
    &gt;&gt;&gt; np.insert(a, 1, [[7],[8],[9]], axis=1) 
    array([[0, 7, 8, 9, 1], 
           [2, 7, 8, 9, 3], 
           [4, 7, 8, 9, 5]]) 
    &gt;&gt;&gt; np.array_equal(np.insert(a, 1, [7, 8, 9], axis=1), 
    ...                np.insert(a, [1], [[7],[8],[9]], axis=1)) 
    True 
 
    &gt;&gt;&gt; b = a.flatten() 
    &gt;&gt;&gt; b 
    array([0, 1, 2, 3, 4, 5]) 
    &gt;&gt;&gt; np.insert(b, [2, 2], [6, 7]) 
    array([0, 1, 6, 7, 2, 3, 4, 5]) 
 
    &gt;&gt;&gt; np.insert(b, slice(2, 4), [7, 8]) 
    array([0, 1, 7, 2, 8, 3, 4, 5]) 
 
    &gt;&gt;&gt; np.insert(b, [2, 2], [7.13, False]) # type casting 
    array([0, 1, 7, 0, 2, 3, 4, 5]) 
 
    &gt;&gt;&gt; x = np.arange(8).reshape(2, 4) 
    &gt;&gt;&gt; idx = (1, 3) 
    &gt;&gt;&gt; np.insert(x, idx, 999, axis=1) 
    array([[  0, 999,   1,   2, 999,   3], 
           [  4, 999,   5,   6, 999,   7]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">conv </span><span class="s2">= </span><span class="s1">_array_converter</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">)</span>
    <span class="s1">arr</span><span class="s2">, = </span><span class="s1">conv</span><span class="s2">.</span><span class="s1">as_arrays</span><span class="s2">(</span><span class="s1">subok</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s1">ndim </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ndim</span>
    <span class="s1">arrorder </span><span class="s2">= </span><span class="s4">'F' </span><span class="s0">if </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">fnc </span><span class="s0">else </span><span class="s4">'C'</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">arr </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">()</span>
        <span class="s3"># needed for np.matrix, which is still not 1d after being ravelled</span>
        <span class="s1">ndim </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ndim</span>
        <span class="s1">axis </span><span class="s2">= </span><span class="s1">ndim </span><span class="s2">- </span><span class="s5">1</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">axis </span><span class="s2">= </span><span class="s1">normalize_axis_index</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">ndim</span><span class="s2">)</span>
    <span class="s1">slobj </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)]*</span><span class="s1">ndim</span>
    <span class="s1">N </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
    <span class="s1">newshape </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">):</span>
        <span class="s3"># turn it into a range object</span>
        <span class="s1">indices </span><span class="s2">= </span><span class="s1">arange</span><span class="s2">(*</span><span class="s1">obj</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">(</span><span class="s1">N</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">intp</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s3"># need to copy obj, because indices will be changed in-place</span>
        <span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">indices</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">bool</span><span class="s2">:</span>
            <span class="s3"># See also delete</span>
            <span class="s3"># 2012-10-11, NumPy 1.8</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s4">&quot;in the future insert will treat boolean arrays and &quot;</span>
                <span class="s4">&quot;array-likes as a boolean index instead of casting it to &quot;</span>
                <span class="s4">&quot;integer&quot;</span><span class="s2">, </span><span class="s1">FutureWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>
            <span class="s1">indices </span><span class="s2">= </span><span class="s1">indices</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">intp</span><span class="s2">)</span>
            <span class="s3"># Code after warning period:</span>
            <span class="s3">#if obj.ndim != 1:</span>
            <span class="s3">#    raise ValueError('boolean array argument obj to insert '</span>
            <span class="s3">#                     'must be one dimensional')</span>
            <span class="s3">#indices = np.flatnonzero(obj)</span>
        <span class="s0">elif </span><span class="s1">indices</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">&quot;index array argument obj to insert must be one dimensional &quot;</span>
                <span class="s4">&quot;or scalar&quot;</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">indices</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s1">index </span><span class="s2">= </span><span class="s1">indices</span><span class="s2">.</span><span class="s1">item</span><span class="s2">()</span>
        <span class="s0">if </span><span class="s1">index </span><span class="s2">&lt; -</span><span class="s1">N </span><span class="s0">or </span><span class="s1">index </span><span class="s2">&gt; </span><span class="s1">N</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s4">f&quot;index </span><span class="s0">{</span><span class="s1">obj</span><span class="s0">} </span><span class="s4">is out of bounds for axis </span><span class="s0">{</span><span class="s1">axis</span><span class="s0">} </span><span class="s4">&quot;</span>
                             <span class="s4">f&quot;with size </span><span class="s0">{</span><span class="s1">N</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">index </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">):</span>
            <span class="s1">index </span><span class="s2">+= </span><span class="s1">N</span>

        <span class="s3"># There are some object array corner cases here, but we cannot avoid</span>
        <span class="s3"># that:</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">array</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">ndmin</span><span class="s2">=</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">arr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">indices</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s3"># broadcasting is very different here, since a[:,0,:] = ... behaves</span>
            <span class="s3"># very different from a[:,[0],:] = ...! This changes values so that</span>
            <span class="s3"># it works likes the second case. (here a[:,0:1,:])</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">moveaxis</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)</span>
        <span class="s1">numnew </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
        <span class="s1">newshape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] += </span><span class="s1">numnew</span>
        <span class="s1">new </span><span class="s2">= </span><span class="s1">empty</span><span class="s2">(</span><span class="s1">newshape</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">arrorder</span><span class="s2">)</span>
        <span class="s1">slobj</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, </span><span class="s1">index</span><span class="s2">)</span>
        <span class="s1">new</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj</span><span class="s2">)] = </span><span class="s1">arr</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj</span><span class="s2">)]</span>
        <span class="s1">slobj</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">index</span><span class="s2">, </span><span class="s1">index</span><span class="s2">+</span><span class="s1">numnew</span><span class="s2">)</span>
        <span class="s1">new</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj</span><span class="s2">)] = </span><span class="s1">values</span>
        <span class="s1">slobj</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">index</span><span class="s2">+</span><span class="s1">numnew</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">slobj2 </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)] * </span><span class="s1">ndim</span>
        <span class="s1">slobj2</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">index</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
        <span class="s1">new</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj</span><span class="s2">)] = </span><span class="s1">arr</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj2</span><span class="s2">)]</span>

        <span class="s0">return </span><span class="s1">conv</span><span class="s2">.</span><span class="s1">wrap</span><span class="s2">(</span><span class="s1">new</span><span class="s2">, </span><span class="s1">to_scalar</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s0">elif </span><span class="s1">indices</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s5">0 </span><span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">obj</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">):</span>
        <span class="s3"># Can safely cast the empty list to intp</span>
        <span class="s1">indices </span><span class="s2">= </span><span class="s1">indices</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">intp</span><span class="s2">)</span>

    <span class="s1">indices</span><span class="s2">[</span><span class="s1">indices </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">] += </span><span class="s1">N</span>

    <span class="s1">numnew </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">)</span>
    <span class="s1">order </span><span class="s2">= </span><span class="s1">indices</span><span class="s2">.</span><span class="s1">argsort</span><span class="s2">(</span><span class="s1">kind</span><span class="s2">=</span><span class="s4">'mergesort'</span><span class="s2">)   </span><span class="s3"># stable sort</span>
    <span class="s1">indices</span><span class="s2">[</span><span class="s1">order</span><span class="s2">] += </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">numnew</span><span class="s2">)</span>

    <span class="s1">newshape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] += </span><span class="s1">numnew</span>
    <span class="s1">old_mask </span><span class="s2">= </span><span class="s1">ones</span><span class="s2">(</span><span class="s1">newshape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
    <span class="s1">old_mask</span><span class="s2">[</span><span class="s1">indices</span><span class="s2">] = </span><span class="s0">False</span>

    <span class="s1">new </span><span class="s2">= </span><span class="s1">empty</span><span class="s2">(</span><span class="s1">newshape</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">arrorder</span><span class="s2">)</span>
    <span class="s1">slobj2 </span><span class="s2">= [</span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)]*</span><span class="s1">ndim</span>
    <span class="s1">slobj</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">indices</span>
    <span class="s1">slobj2</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">] = </span><span class="s1">old_mask</span>
    <span class="s1">new</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj</span><span class="s2">)] = </span><span class="s1">values</span>
    <span class="s1">new</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">slobj2</span><span class="s2">)] = </span><span class="s1">arr</span>

    <span class="s0">return </span><span class="s1">conv</span><span class="s2">.</span><span class="s1">wrap</span><span class="s2">(</span><span class="s1">new</span><span class="s2">, </span><span class="s1">to_scalar</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_append_dispatcher</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">values</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_append_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">append</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Append values to the end of an array. 
 
    Parameters 
    ---------- 
    arr : array_like 
        Values are appended to a copy of this array. 
    values : array_like 
        These values are appended to a copy of `arr`.  It must be of the 
        correct shape (the same shape as `arr`, excluding `axis`).  If 
        `axis` is not specified, `values` can be any shape and will be 
        flattened before use. 
    axis : int, optional 
        The axis along which `values` are appended.  If `axis` is not 
        given, both `arr` and `values` are flattened before use. 
 
    Returns 
    ------- 
    append : ndarray 
        A copy of `arr` with `values` appended to `axis`.  Note that 
        `append` does not occur in-place: a new array is allocated and 
        filled.  If `axis` is None, `out` is a flattened array. 
 
    See Also 
    -------- 
    insert : Insert elements into an array. 
    delete : Delete elements from an array. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]]) 
    array([1, 2, 3, ..., 7, 8, 9]) 
 
    When `axis` is specified, `values` must have the correct shape. 
 
    &gt;&gt;&gt; np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0) 
    array([[1, 2, 3], 
           [4, 5, 6], 
           [7, 8, 9]]) 
 
    &gt;&gt;&gt; np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0) 
    Traceback (most recent call last): 
        ... 
    ValueError: all the input arrays must have same number of dimensions, but 
    the array at index 0 has 2 dimension(s) and the array at index 1 has 1 
    dimension(s) 
 
    &gt;&gt;&gt; a = np.array([1, 2], dtype=int) 
    &gt;&gt;&gt; c = np.append(a, []) 
    &gt;&gt;&gt; c 
    array([1., 2.]) 
    &gt;&gt;&gt; c.dtype 
    float64 
 
    Default dtype for empty ndarrays is `float64` thus making the output of dtype 
    `float64` when appended with dtype `int64` 
 
    &quot;&quot;&quot;</span>
    <span class="s1">arr </span><span class="s2">= </span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">arr </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">()</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">ravel</span><span class="s2">(</span><span class="s1">values</span><span class="s2">)</span>
        <span class="s1">axis </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">-</span><span class="s5">1</span>
    <span class="s0">return </span><span class="s1">concatenate</span><span class="s2">((</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">values</span><span class="s2">), </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_digitize_dispatcher</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">, </span><span class="s1">right</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_digitize_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">digitize</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">, </span><span class="s1">right</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Return the indices of the bins to which each value in input array belongs. 
 
    =========  =============  ============================ 
    `right`    order of bins  returned index `i` satisfies 
    =========  =============  ============================ 
    ``False``  increasing     ``bins[i-1] &lt;= x &lt; bins[i]`` 
    ``True``   increasing     ``bins[i-1] &lt; x &lt;= bins[i]`` 
    ``False``  decreasing     ``bins[i-1] &gt; x &gt;= bins[i]`` 
    ``True``   decreasing     ``bins[i-1] &gt;= x &gt; bins[i]`` 
    =========  =============  ============================ 
 
    If values in `x` are beyond the bounds of `bins`, 0 or ``len(bins)`` is 
    returned as appropriate. 
 
    Parameters 
    ---------- 
    x : array_like 
        Input array to be binned. Prior to NumPy 1.10.0, this array had to 
        be 1-dimensional, but can now have any shape. 
    bins : array_like 
        Array of bins. It has to be 1-dimensional and monotonic. 
    right : bool, optional 
        Indicating whether the intervals include the right or the left bin 
        edge. Default behavior is (right==False) indicating that the interval 
        does not include the right edge. The left bin end is open in this 
        case, i.e., bins[i-1] &lt;= x &lt; bins[i] is the default behavior for 
        monotonically increasing bins. 
 
    Returns 
    ------- 
    indices : ndarray of ints 
        Output array of indices, of same shape as `x`. 
 
    Raises 
    ------ 
    ValueError 
        If `bins` is not monotonic. 
    TypeError 
        If the type of the input is complex. 
 
    See Also 
    -------- 
    bincount, histogram, unique, searchsorted 
 
    Notes 
    ----- 
    If values in `x` are such that they fall outside the bin range, 
    attempting to index `bins` with the indices that `digitize` returns 
    will result in an IndexError. 
 
    .. versionadded:: 1.10.0 
 
    `numpy.digitize` is  implemented in terms of `numpy.searchsorted`. 
    This means that a binary search is used to bin the values, which scales 
    much better for larger number of bins than the previous linear search. 
    It also removes the requirement for the input array to be 1-dimensional. 
 
    For monotonically *increasing* `bins`, the following are equivalent:: 
 
        np.digitize(x, bins, right=True) 
        np.searchsorted(bins, x, side='left') 
 
    Note that as the order of the arguments are reversed, the side must be too. 
    The `searchsorted` call is marginally faster, as it does not do any 
    monotonicity checks. Perhaps more importantly, it supports all dtypes. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.array([0.2, 6.4, 3.0, 1.6]) 
    &gt;&gt;&gt; bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0]) 
    &gt;&gt;&gt; inds = np.digitize(x, bins) 
    &gt;&gt;&gt; inds 
    array([1, 4, 3, 2]) 
    &gt;&gt;&gt; for n in range(x.size): 
    ...   print(bins[inds[n]-1], &quot;&lt;=&quot;, x[n], &quot;&lt;&quot;, bins[inds[n]]) 
    ... 
    0.0 &lt;= 0.2 &lt; 1.0 
    4.0 &lt;= 6.4 &lt; 10.0 
    2.5 &lt;= 3.0 &lt; 4.0 
    1.0 &lt;= 1.6 &lt; 2.5 
 
    &gt;&gt;&gt; x = np.array([1.2, 10.0, 12.4, 15.5, 20.]) 
    &gt;&gt;&gt; bins = np.array([0, 5, 10, 15, 20]) 
    &gt;&gt;&gt; np.digitize(x,bins,right=True) 
    array([1, 2, 3, 4, 4]) 
    &gt;&gt;&gt; np.digitize(x,bins,right=False) 
    array([1, 3, 3, 4, 5]) 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s1">bins </span><span class="s2">= </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">bins</span><span class="s2">)</span>

    <span class="s3"># here for compatibility, searchsorted below is happy to take this</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">complexfloating</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s4">&quot;x may not be complex&quot;</span><span class="s2">)</span>

    <span class="s1">mono </span><span class="s2">= </span><span class="s1">_monotonicity</span><span class="s2">(</span><span class="s1">bins</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">mono </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;bins must be monotonically increasing or decreasing&quot;</span><span class="s2">)</span>

    <span class="s3"># this is backwards because the arguments below are swapped</span>
    <span class="s1">side </span><span class="s2">= </span><span class="s4">'left' </span><span class="s0">if </span><span class="s1">right </span><span class="s0">else </span><span class="s4">'right'</span>
    <span class="s0">if </span><span class="s1">mono </span><span class="s2">== -</span><span class="s5">1</span><span class="s2">:</span>
        <span class="s3"># reverse the bins, and invert the results</span>
        <span class="s0">return </span><span class="s1">len</span><span class="s2">(</span><span class="s1">bins</span><span class="s2">) - </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">searchsorted</span><span class="s2">(</span><span class="s1">bins</span><span class="s2">[::-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">x</span><span class="s2">, </span><span class="s1">side</span><span class="s2">=</span><span class="s1">side</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">searchsorted</span><span class="s2">(</span><span class="s1">bins</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">side</span><span class="s2">=</span><span class="s1">side</span><span class="s2">)</span>
</pre>
</body>
</html>