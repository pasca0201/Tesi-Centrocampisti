<html>
<head>
<title>_linprog_simplex.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #7a7e85;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_linprog_simplex.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Simplex method for  linear programming 
 
The *simplex* method uses a traditional, full-tableau implementation of 
Dantzig's simplex algorithm [1]_, [2]_ (*not* the Nelder-Mead simplex). 
This algorithm is included for backwards compatibility and educational 
purposes. 
 
    .. versionadded:: 0.15.0 
 
Warnings 
-------- 
 
The simplex method may encounter numerical difficulties when pivot 
values are close to the specified tolerance. If encountered try 
remove any redundant constraints, change the pivot strategy to Bland's 
rule or increase the tolerance value. 
 
Alternatively, more robust methods maybe be used. See 
:ref:`'interior-point' &lt;optimize.linprog-interior-point&gt;` and 
:ref:`'revised simplex' &lt;optimize.linprog-revised_simplex&gt;`. 
 
References 
---------- 
.. [1] Dantzig, George B., Linear programming and extensions. Rand 
       Corporation Research Study Princeton Univ. Press, Princeton, NJ, 
       1963 
.. [2] Hillier, S.H. and Lieberman, G.J. (1995), &quot;Introduction to 
       Mathematical Programming&quot;, McGraw-Hill, Chapter 4. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">warnings </span><span class="s2">import </span><span class="s1">warn</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_optimize </span><span class="s2">import </span><span class="s1">OptimizeResult</span><span class="s3">, </span><span class="s1">OptimizeWarning</span><span class="s3">, </span><span class="s1">_check_unknown_options</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_linprog_util </span><span class="s2">import </span><span class="s1">_postsolve</span>


<span class="s2">def </span><span class="s1">_pivot_col</span><span class="s3">(</span><span class="s1">T</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s4">1e-9</span><span class="s3">, </span><span class="s1">bland</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Given a linear programming simplex tableau, determine the column 
    of the variable to enter the basis. 
 
    Parameters 
    ---------- 
    T : 2-D array 
        A 2-D array representing the simplex tableau, T, corresponding to the 
        linear programming problem. It should have the form: 
 
        [[A[0, 0], A[0, 1], ..., A[0, n_total], b[0]], 
         [A[1, 0], A[1, 1], ..., A[1, n_total], b[1]], 
         . 
         . 
         . 
         [A[m, 0], A[m, 1], ..., A[m, n_total], b[m]], 
         [c[0],   c[1], ...,   c[n_total],    0]] 
 
        for a Phase 2 problem, or the form: 
 
        [[A[0, 0], A[0, 1], ..., A[0, n_total], b[0]], 
         [A[1, 0], A[1, 1], ..., A[1, n_total], b[1]], 
         . 
         . 
         . 
         [A[m, 0], A[m, 1], ..., A[m, n_total], b[m]], 
         [c[0],   c[1], ...,   c[n_total],   0], 
         [c'[0],  c'[1], ...,  c'[n_total],  0]] 
 
         for a Phase 1 problem (a problem in which a basic feasible solution is 
         sought prior to maximizing the actual objective. ``T`` is modified in 
         place by ``_solve_simplex``. 
    tol : float 
        Elements in the objective row larger than -tol will not be considered 
        for pivoting. Nominally this value is zero, but numerical issues 
        cause a tolerance about zero to be necessary. 
    bland : bool 
        If True, use Bland's rule for selection of the column (select the 
        first column with a negative coefficient in the objective row, 
        regardless of magnitude). 
 
    Returns 
    ------- 
    status: bool 
        True if a suitable pivot column was found, otherwise False. 
        A return of False indicates that the linear programming simplex 
        algorithm is complete. 
    col: int 
        The index of the column of the pivot element. 
        If status is False, col will be returned as nan. 
    &quot;&quot;&quot;</span>
    <span class="s1">ma </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">masked_where</span><span class="s3">(</span><span class="s1">T</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">, :-</span><span class="s4">1</span><span class="s3">] &gt;= -</span><span class="s1">tol</span><span class="s3">, </span><span class="s1">T</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">, :-</span><span class="s4">1</span><span class="s3">], </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">count</span><span class="s3">() == </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">return False</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
    <span class="s2">if </span><span class="s1">bland</span><span class="s3">:</span>
        <span class="s5"># ma.mask is sometimes 0d</span>
        <span class="s2">return True</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">logical_not</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">mask</span><span class="s3">)))[</span><span class="s4">0</span><span class="s3">][</span><span class="s4">0</span><span class="s3">]</span>
    <span class="s2">return True</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">(</span><span class="s1">ma </span><span class="s3">== </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">min</span><span class="s3">())[</span><span class="s4">0</span><span class="s3">][</span><span class="s4">0</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">_pivot_row</span><span class="s3">(</span><span class="s1">T</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">pivcol</span><span class="s3">, </span><span class="s1">phase</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s4">1e-9</span><span class="s3">, </span><span class="s1">bland</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Given a linear programming simplex tableau, determine the row for the 
    pivot operation. 
 
    Parameters 
    ---------- 
    T : 2-D array 
        A 2-D array representing the simplex tableau, T, corresponding to the 
        linear programming problem. It should have the form: 
 
        [[A[0, 0], A[0, 1], ..., A[0, n_total], b[0]], 
         [A[1, 0], A[1, 1], ..., A[1, n_total], b[1]], 
         . 
         . 
         . 
         [A[m, 0], A[m, 1], ..., A[m, n_total], b[m]], 
         [c[0],   c[1], ...,   c[n_total],    0]] 
 
        for a Phase 2 problem, or the form: 
 
        [[A[0, 0], A[0, 1], ..., A[0, n_total], b[0]], 
         [A[1, 0], A[1, 1], ..., A[1, n_total], b[1]], 
         . 
         . 
         . 
         [A[m, 0], A[m, 1], ..., A[m, n_total], b[m]], 
         [c[0],   c[1], ...,   c[n_total],   0], 
         [c'[0],  c'[1], ...,  c'[n_total],  0]] 
 
         for a Phase 1 problem (a Problem in which a basic feasible solution is 
         sought prior to maximizing the actual objective. ``T`` is modified in 
         place by ``_solve_simplex``. 
    basis : array 
        A list of the current basic variables. 
    pivcol : int 
        The index of the pivot column. 
    phase : int 
        The phase of the simplex algorithm (1 or 2). 
    tol : float 
        Elements in the pivot column smaller than tol will not be considered 
        for pivoting. Nominally this value is zero, but numerical issues 
        cause a tolerance about zero to be necessary. 
    bland : bool 
        If True, use Bland's rule for selection of the row (if more than one 
        row can be used, choose the one with the lowest variable index). 
 
    Returns 
    ------- 
    status: bool 
        True if a suitable pivot row was found, otherwise False. A return 
        of False indicates that the linear programming problem is unbounded. 
    row: int 
        The index of the row of the pivot element. If status is False, row 
        will be returned as nan. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">phase </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s4">2</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s4">1</span>
    <span class="s1">ma </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">masked_where</span><span class="s3">(</span><span class="s1">T</span><span class="s3">[:-</span><span class="s1">k</span><span class="s3">, </span><span class="s1">pivcol</span><span class="s3">] &lt;= </span><span class="s1">tol</span><span class="s3">, </span><span class="s1">T</span><span class="s3">[:-</span><span class="s1">k</span><span class="s3">, </span><span class="s1">pivcol</span><span class="s3">], </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">count</span><span class="s3">() == </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">return False</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
    <span class="s1">mb </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">masked_where</span><span class="s3">(</span><span class="s1">T</span><span class="s3">[:-</span><span class="s1">k</span><span class="s3">, </span><span class="s1">pivcol</span><span class="s3">] &lt;= </span><span class="s1">tol</span><span class="s3">, </span><span class="s1">T</span><span class="s3">[:-</span><span class="s1">k</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">], </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">q </span><span class="s3">= </span><span class="s1">mb </span><span class="s3">/ </span><span class="s1">ma</span>
    <span class="s1">min_rows </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">(</span><span class="s1">q </span><span class="s3">== </span><span class="s1">q</span><span class="s3">.</span><span class="s1">min</span><span class="s3">())[</span><span class="s4">0</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">bland</span><span class="s3">:</span>
        <span class="s2">return True</span><span class="s3">, </span><span class="s1">min_rows</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s1">basis</span><span class="s3">, </span><span class="s1">min_rows</span><span class="s3">))]</span>
    <span class="s2">return True</span><span class="s3">, </span><span class="s1">min_rows</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">_apply_pivot</span><span class="s3">(</span><span class="s1">T</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">pivrow</span><span class="s3">, </span><span class="s1">pivcol</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s4">1e-9</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Pivot the simplex tableau inplace on the element given by (pivrow, pivol). 
    The entering variable corresponds to the column given by pivcol forcing 
    the variable basis[pivrow] to leave the basis. 
 
    Parameters 
    ---------- 
    T : 2-D array 
        A 2-D array representing the simplex tableau, T, corresponding to the 
        linear programming problem. It should have the form: 
 
        [[A[0, 0], A[0, 1], ..., A[0, n_total], b[0]], 
         [A[1, 0], A[1, 1], ..., A[1, n_total], b[1]], 
         . 
         . 
         . 
         [A[m, 0], A[m, 1], ..., A[m, n_total], b[m]], 
         [c[0],   c[1], ...,   c[n_total],    0]] 
 
        for a Phase 2 problem, or the form: 
 
        [[A[0, 0], A[0, 1], ..., A[0, n_total], b[0]], 
         [A[1, 0], A[1, 1], ..., A[1, n_total], b[1]], 
         . 
         . 
         . 
         [A[m, 0], A[m, 1], ..., A[m, n_total], b[m]], 
         [c[0],   c[1], ...,   c[n_total],   0], 
         [c'[0],  c'[1], ...,  c'[n_total],  0]] 
 
         for a Phase 1 problem (a problem in which a basic feasible solution is 
         sought prior to maximizing the actual objective. ``T`` is modified in 
         place by ``_solve_simplex``. 
    basis : 1-D array 
        An array of the indices of the basic variables, such that basis[i] 
        contains the column corresponding to the basic variable for row i. 
        Basis is modified in place by _apply_pivot. 
    pivrow : int 
        Row index of the pivot. 
    pivcol : int 
        Column index of the pivot. 
    &quot;&quot;&quot;</span>
    <span class="s1">basis</span><span class="s3">[</span><span class="s1">pivrow</span><span class="s3">] = </span><span class="s1">pivcol</span>
    <span class="s1">pivval </span><span class="s3">= </span><span class="s1">T</span><span class="s3">[</span><span class="s1">pivrow</span><span class="s3">, </span><span class="s1">pivcol</span><span class="s3">]</span>
    <span class="s1">T</span><span class="s3">[</span><span class="s1">pivrow</span><span class="s3">] = </span><span class="s1">T</span><span class="s3">[</span><span class="s1">pivrow</span><span class="s3">] / </span><span class="s1">pivval</span>
    <span class="s2">for </span><span class="s1">irow </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">T</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]):</span>
        <span class="s2">if </span><span class="s1">irow </span><span class="s3">!= </span><span class="s1">pivrow</span><span class="s3">:</span>
            <span class="s1">T</span><span class="s3">[</span><span class="s1">irow</span><span class="s3">] = </span><span class="s1">T</span><span class="s3">[</span><span class="s1">irow</span><span class="s3">] - </span><span class="s1">T</span><span class="s3">[</span><span class="s1">pivrow</span><span class="s3">] * </span><span class="s1">T</span><span class="s3">[</span><span class="s1">irow</span><span class="s3">, </span><span class="s1">pivcol</span><span class="s3">]</span>

    <span class="s5"># The selected pivot should never lead to a pivot value less than the tol.</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isclose</span><span class="s3">(</span><span class="s1">pivval</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s4">1e4</span><span class="s3">):</span>
        <span class="s1">message </span><span class="s3">= (</span>
            <span class="s6">f&quot;The pivot operation produces a pivot value of:</span><span class="s2">{</span><span class="s1">pivval</span><span class="s2">: </span><span class="s6">.1e</span><span class="s2">}</span><span class="s6">, &quot;</span>
            <span class="s6">&quot;which is only slightly greater than the specified &quot;</span>
            <span class="s6">f&quot;tolerance</span><span class="s2">{</span><span class="s1">tol</span><span class="s2">: </span><span class="s6">.1e</span><span class="s2">}</span><span class="s6">. This may lead to issues regarding the &quot;</span>
            <span class="s6">&quot;numerical stability of the simplex method. &quot;</span>
            <span class="s6">&quot;Removing redundant constraints, changing the pivot strategy &quot;</span>
            <span class="s6">&quot;via Bland's rule or increasing the tolerance may &quot;</span>
            <span class="s6">&quot;help reduce the issue.&quot;</span><span class="s3">)</span>
        <span class="s1">warn</span><span class="s3">(</span><span class="s1">message</span><span class="s3">, </span><span class="s1">OptimizeWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s4">5</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_solve_simplex</span><span class="s3">(</span><span class="s1">T</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">postsolve_args</span><span class="s3">,</span>
                   <span class="s1">maxiter</span><span class="s3">=</span><span class="s4">1000</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s4">1e-9</span><span class="s3">, </span><span class="s1">phase</span><span class="s3">=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">bland</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">nit0</span><span class="s3">=</span><span class="s4">0</span><span class="s3">,</span>
                   <span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Solve a linear programming problem in &quot;standard form&quot; using the Simplex 
    Method. Linear Programming is intended to solve the following problem form: 
 
    Minimize:: 
 
        c @ x 
 
    Subject to:: 
 
        A @ x == b 
            x &gt;= 0 
 
    Parameters 
    ---------- 
    T : 2-D array 
        A 2-D array representing the simplex tableau, T, corresponding to the 
        linear programming problem. It should have the form: 
 
        [[A[0, 0], A[0, 1], ..., A[0, n_total], b[0]], 
         [A[1, 0], A[1, 1], ..., A[1, n_total], b[1]], 
         . 
         . 
         . 
         [A[m, 0], A[m, 1], ..., A[m, n_total], b[m]], 
         [c[0],   c[1], ...,   c[n_total],    0]] 
 
        for a Phase 2 problem, or the form: 
 
        [[A[0, 0], A[0, 1], ..., A[0, n_total], b[0]], 
         [A[1, 0], A[1, 1], ..., A[1, n_total], b[1]], 
         . 
         . 
         . 
         [A[m, 0], A[m, 1], ..., A[m, n_total], b[m]], 
         [c[0],   c[1], ...,   c[n_total],   0], 
         [c'[0],  c'[1], ...,  c'[n_total],  0]] 
 
         for a Phase 1 problem (a problem in which a basic feasible solution is 
         sought prior to maximizing the actual objective. ``T`` is modified in 
         place by ``_solve_simplex``. 
    n : int 
        The number of true variables in the problem. 
    basis : 1-D array 
        An array of the indices of the basic variables, such that basis[i] 
        contains the column corresponding to the basic variable for row i. 
        Basis is modified in place by _solve_simplex 
    callback : callable, optional 
        If a callback function is provided, it will be called within each 
        iteration of the algorithm. The callback must accept a 
        `scipy.optimize.OptimizeResult` consisting of the following fields: 
 
            x : 1-D array 
                Current solution vector 
            fun : float 
                Current value of the objective function 
            success : bool 
                True only when a phase has completed successfully. This 
                will be False for most iterations. 
            slack : 1-D array 
                The values of the slack variables. Each slack variable 
                corresponds to an inequality constraint. If the slack is zero, 
                the corresponding constraint is active. 
            con : 1-D array 
                The (nominally zero) residuals of the equality constraints, 
                that is, ``b - A_eq @ x`` 
            phase : int 
                The phase of the optimization being executed. In phase 1 a basic 
                feasible solution is sought and the T has an additional row 
                representing an alternate objective function. 
            status : int 
                An integer representing the exit status of the optimization:: 
 
                     0 : Optimization terminated successfully 
                     1 : Iteration limit reached 
                     2 : Problem appears to be infeasible 
                     3 : Problem appears to be unbounded 
                     4 : Serious numerical difficulties encountered 
 
            nit : int 
                The number of iterations performed. 
            message : str 
                A string descriptor of the exit status of the optimization. 
    postsolve_args : tuple 
        Data needed by _postsolve to convert the solution to the standard-form 
        problem into the solution to the original problem. 
    maxiter : int 
        The maximum number of iterations to perform before aborting the 
        optimization. 
    tol : float 
        The tolerance which determines when a solution is &quot;close enough&quot; to 
        zero in Phase 1 to be considered a basic feasible solution or close 
        enough to positive to serve as an optimal solution. 
    phase : int 
        The phase of the optimization being executed. In phase 1 a basic 
        feasible solution is sought and the T has an additional row 
        representing an alternate objective function. 
    bland : bool 
        If True, choose pivots using Bland's rule [3]_. In problems which 
        fail to converge due to cycling, using Bland's rule can provide 
        convergence at the expense of a less optimal path about the simplex. 
    nit0 : int 
        The initial iteration number used to keep an accurate iteration total 
        in a two-phase problem. 
 
    Returns 
    ------- 
    nit : int 
        The number of iterations. Used to keep an accurate iteration total 
        in the two-phase problem. 
    status : int 
        An integer representing the exit status of the optimization:: 
 
         0 : Optimization terminated successfully 
         1 : Iteration limit reached 
         2 : Problem appears to be infeasible 
         3 : Problem appears to be unbounded 
         4 : Serious numerical difficulties encountered 
 
    &quot;&quot;&quot;</span>
    <span class="s1">nit </span><span class="s3">= </span><span class="s1">nit0</span>
    <span class="s1">status </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s1">message </span><span class="s3">= </span><span class="s6">''</span>
    <span class="s1">complete </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s2">if </span><span class="s1">phase </span><span class="s3">== </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">T</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]-</span><span class="s4">2</span>
    <span class="s2">elif </span><span class="s1">phase </span><span class="s3">== </span><span class="s4">2</span><span class="s3">:</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">T</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]-</span><span class="s4">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;Argument 'phase' to _solve_simplex must be 1 or 2&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">phase </span><span class="s3">== </span><span class="s4">2</span><span class="s3">:</span>
        <span class="s5"># Check if any artificial variables are still in the basis.</span>
        <span class="s5"># If yes, check if any coefficients from this row and a column</span>
        <span class="s5"># corresponding to one of the non-artificial variable is non-zero.</span>
        <span class="s5"># If found, pivot at this term. If not, start phase 2.</span>
        <span class="s5"># Do this for all artificial variables in the basis.</span>
        <span class="s5"># Ref: &quot;An Introduction to Linear Programming and Game Theory&quot;</span>
        <span class="s5"># by Paul R. Thie, Gerard E. Keough, 3rd Ed,</span>
        <span class="s5"># Chapter 3.7 Redundant Systems (pag 102)</span>
        <span class="s2">for </span><span class="s1">pivrow </span><span class="s2">in </span><span class="s3">[</span><span class="s1">row </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">basis</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
                       <span class="s2">if </span><span class="s1">basis</span><span class="s3">[</span><span class="s1">row</span><span class="s3">] &gt; </span><span class="s1">T</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] - </span><span class="s4">2</span><span class="s3">]:</span>
            <span class="s1">non_zero_row </span><span class="s3">= [</span><span class="s1">col </span><span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">T</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] - </span><span class="s4">1</span><span class="s3">)</span>
                            <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">T</span><span class="s3">[</span><span class="s1">pivrow</span><span class="s3">, </span><span class="s1">col</span><span class="s3">]) &gt; </span><span class="s1">tol</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">non_zero_row</span><span class="s3">) &gt; </span><span class="s4">0</span><span class="s3">:</span>
                <span class="s1">pivcol </span><span class="s3">= </span><span class="s1">non_zero_row</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
                <span class="s1">_apply_pivot</span><span class="s3">(</span><span class="s1">T</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">pivrow</span><span class="s3">, </span><span class="s1">pivcol</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">)</span>
                <span class="s1">nit </span><span class="s3">+= </span><span class="s4">1</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">basis</span><span class="s3">[:</span><span class="s1">m</span><span class="s3">]) == </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s1">solution </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">T</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] - </span><span class="s4">1</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">solution </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">max</span><span class="s3">(</span><span class="s1">T</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] - </span><span class="s4">1</span><span class="s3">, </span><span class="s1">max</span><span class="s3">(</span><span class="s1">basis</span><span class="s3">[:</span><span class="s1">m</span><span class="s3">]) + </span><span class="s4">1</span><span class="s3">),</span>
                            <span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s2">while not </span><span class="s1">complete</span><span class="s3">:</span>
        <span class="s5"># Find the pivot column</span>
        <span class="s1">pivcol_found</span><span class="s3">, </span><span class="s1">pivcol </span><span class="s3">= </span><span class="s1">_pivot_col</span><span class="s3">(</span><span class="s1">T</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">, </span><span class="s1">bland</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">pivcol_found</span><span class="s3">:</span>
            <span class="s1">pivcol </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
            <span class="s1">pivrow </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
            <span class="s1">status </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">complete </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s5"># Find the pivot row</span>
            <span class="s1">pivrow_found</span><span class="s3">, </span><span class="s1">pivrow </span><span class="s3">= </span><span class="s1">_pivot_row</span><span class="s3">(</span><span class="s1">T</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">pivcol</span><span class="s3">, </span><span class="s1">phase</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">, </span><span class="s1">bland</span><span class="s3">)</span>
            <span class="s2">if not </span><span class="s1">pivrow_found</span><span class="s3">:</span>
                <span class="s1">status </span><span class="s3">= </span><span class="s4">3</span>
                <span class="s1">complete </span><span class="s3">= </span><span class="s2">True</span>

        <span class="s2">if </span><span class="s1">callback </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">solution</span><span class="s3">[:] = </span><span class="s4">0</span>
            <span class="s1">solution</span><span class="s3">[</span><span class="s1">basis</span><span class="s3">[:</span><span class="s1">n</span><span class="s3">]] = </span><span class="s1">T</span><span class="s3">[:</span><span class="s1">n</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">]</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">solution</span><span class="s3">[:</span><span class="s1">m</span><span class="s3">]</span>
            <span class="s1">x</span><span class="s3">, </span><span class="s1">fun</span><span class="s3">, </span><span class="s1">slack</span><span class="s3">, </span><span class="s1">con </span><span class="s3">= </span><span class="s1">_postsolve</span><span class="s3">(</span>
                <span class="s1">x</span><span class="s3">, </span><span class="s1">postsolve_args</span>
            <span class="s3">)</span>
            <span class="s1">res </span><span class="s3">= </span><span class="s1">OptimizeResult</span><span class="s3">({</span>
                <span class="s6">'x'</span><span class="s3">: </span><span class="s1">x</span><span class="s3">,</span>
                <span class="s6">'fun'</span><span class="s3">: </span><span class="s1">fun</span><span class="s3">,</span>
                <span class="s6">'slack'</span><span class="s3">: </span><span class="s1">slack</span><span class="s3">,</span>
                <span class="s6">'con'</span><span class="s3">: </span><span class="s1">con</span><span class="s3">,</span>
                <span class="s6">'status'</span><span class="s3">: </span><span class="s1">status</span><span class="s3">,</span>
                <span class="s6">'message'</span><span class="s3">: </span><span class="s1">message</span><span class="s3">,</span>
                <span class="s6">'nit'</span><span class="s3">: </span><span class="s1">nit</span><span class="s3">,</span>
                <span class="s6">'success'</span><span class="s3">: </span><span class="s1">status </span><span class="s3">== </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">complete</span><span class="s3">,</span>
                <span class="s6">'phase'</span><span class="s3">: </span><span class="s1">phase</span><span class="s3">,</span>
                <span class="s6">'complete'</span><span class="s3">: </span><span class="s1">complete</span><span class="s3">,</span>
                <span class="s3">})</span>
            <span class="s1">callback</span><span class="s3">(</span><span class="s1">res</span><span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">complete</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">nit </span><span class="s3">&gt;= </span><span class="s1">maxiter</span><span class="s3">:</span>
                <span class="s5"># Iteration limit exceeded</span>
                <span class="s1">status </span><span class="s3">= </span><span class="s4">1</span>
                <span class="s1">complete </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">_apply_pivot</span><span class="s3">(</span><span class="s1">T</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">pivrow</span><span class="s3">, </span><span class="s1">pivcol</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">)</span>
                <span class="s1">nit </span><span class="s3">+= </span><span class="s4">1</span>
    <span class="s2">return </span><span class="s1">nit</span><span class="s3">, </span><span class="s1">status</span>


<span class="s2">def </span><span class="s1">_linprog_simplex</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s1">c0</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">postsolve_args</span><span class="s3">,</span>
                     <span class="s1">maxiter</span><span class="s3">=</span><span class="s4">1000</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s4">1e-9</span><span class="s3">, </span><span class="s1">disp</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">bland</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                     <span class="s3">**</span><span class="s1">unknown_options</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Minimize a linear objective function subject to linear equality and 
    non-negativity constraints using the two phase simplex method. 
    Linear programming is intended to solve problems of the following form: 
 
    Minimize:: 
 
        c @ x 
 
    Subject to:: 
 
        A @ x == b 
            x &gt;= 0 
 
    User-facing documentation is in _linprog_doc.py. 
 
    Parameters 
    ---------- 
    c : 1-D array 
        Coefficients of the linear objective function to be minimized. 
    c0 : float 
        Constant term in objective function due to fixed (and eliminated) 
        variables. (Purely for display.) 
    A : 2-D array 
        2-D array such that ``A @ x``, gives the values of the equality 
        constraints at ``x``. 
    b : 1-D array 
        1-D array of values representing the right hand side of each equality 
        constraint (row) in ``A``. 
    callback : callable, optional 
        If a callback function is provided, it will be called within each 
        iteration of the algorithm. The callback function must accept a single 
        `scipy.optimize.OptimizeResult` consisting of the following fields: 
 
            x : 1-D array 
                Current solution vector 
            fun : float 
                Current value of the objective function 
            success : bool 
                True when an algorithm has completed successfully. 
            slack : 1-D array 
                The values of the slack variables. Each slack variable 
                corresponds to an inequality constraint. If the slack is zero, 
                the corresponding constraint is active. 
            con : 1-D array 
                The (nominally zero) residuals of the equality constraints, 
                that is, ``b - A_eq @ x`` 
            phase : int 
                The phase of the algorithm being executed. 
            status : int 
                An integer representing the status of the optimization:: 
 
                     0 : Algorithm proceeding nominally 
                     1 : Iteration limit reached 
                     2 : Problem appears to be infeasible 
                     3 : Problem appears to be unbounded 
                     4 : Serious numerical difficulties encountered 
            nit : int 
                The number of iterations performed. 
            message : str 
                A string descriptor of the exit status of the optimization. 
    postsolve_args : tuple 
        Data needed by _postsolve to convert the solution to the standard-form 
        problem into the solution to the original problem. 
 
    Options 
    ------- 
    maxiter : int 
       The maximum number of iterations to perform. 
    disp : bool 
        If True, print exit status message to sys.stdout 
    tol : float 
        The tolerance which determines when a solution is &quot;close enough&quot; to 
        zero in Phase 1 to be considered a basic feasible solution or close 
        enough to positive to serve as an optimal solution. 
    bland : bool 
        If True, use Bland's anti-cycling rule [3]_ to choose pivots to 
        prevent cycling. If False, choose pivots which should lead to a 
        converged solution more quickly. The latter method is subject to 
        cycling (non-convergence) in rare instances. 
    unknown_options : dict 
        Optional arguments not used by this particular solver. If 
        `unknown_options` is non-empty a warning is issued listing all 
        unused options. 
 
    Returns 
    ------- 
    x : 1-D array 
        Solution vector. 
    status : int 
        An integer representing the exit status of the optimization:: 
 
         0 : Optimization terminated successfully 
         1 : Iteration limit reached 
         2 : Problem appears to be infeasible 
         3 : Problem appears to be unbounded 
         4 : Serious numerical difficulties encountered 
 
    message : str 
        A string descriptor of the exit status of the optimization. 
    iteration : int 
        The number of iterations taken to solve the problem. 
 
    References 
    ---------- 
    .. [1] Dantzig, George B., Linear programming and extensions. Rand 
           Corporation Research Study Princeton Univ. Press, Princeton, NJ, 
           1963 
    .. [2] Hillier, S.H. and Lieberman, G.J. (1995), &quot;Introduction to 
           Mathematical Programming&quot;, McGraw-Hill, Chapter 4. 
    .. [3] Bland, Robert G. New finite pivoting rules for the simplex method. 
           Mathematics of Operations Research (2), 1977: pp. 103-107. 
 
 
    Notes 
    ----- 
    The expected problem formulation differs between the top level ``linprog`` 
    module and the method specific solvers. The method specific solvers expect a 
    problem in standard form: 
 
    Minimize:: 
 
        c @ x 
 
    Subject to:: 
 
        A @ x == b 
            x &gt;= 0 
 
    Whereas the top level ``linprog`` module expects a problem of form: 
 
    Minimize:: 
 
        c @ x 
 
    Subject to:: 
 
        A_ub @ x &lt;= b_ub 
        A_eq @ x == b_eq 
         lb &lt;= x &lt;= ub 
 
    where ``lb = 0`` and ``ub = None`` unless set in ``bounds``. 
 
    The original problem contains equality, upper-bound and variable constraints 
    whereas the method specific solver requires equality constraints and 
    variable non-negativity. 
 
    ``linprog`` module converts the original problem to standard form by 
    converting the simple bounds to upper bound constraints, introducing 
    non-negative slack variables for inequality constraints, and expressing 
    unbounded variables as the difference between two non-negative variables. 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_unknown_options</span><span class="s3">(</span><span class="s1">unknown_options</span><span class="s3">)</span>

    <span class="s1">status </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s1">messages </span><span class="s3">= {</span><span class="s4">0</span><span class="s3">: </span><span class="s6">&quot;Optimization terminated successfully.&quot;</span><span class="s3">,</span>
                <span class="s4">1</span><span class="s3">: </span><span class="s6">&quot;Iteration limit reached.&quot;</span><span class="s3">,</span>
                <span class="s4">2</span><span class="s3">: </span><span class="s6">&quot;Optimization failed. Unable to find a feasible&quot;</span>
                   <span class="s6">&quot; starting point.&quot;</span><span class="s3">,</span>
                <span class="s4">3</span><span class="s3">: </span><span class="s6">&quot;Optimization failed. The problem appears to be unbounded.&quot;</span><span class="s3">,</span>
                <span class="s4">4</span><span class="s3">: </span><span class="s6">&quot;Optimization failed. Singular matrix encountered.&quot;</span><span class="s3">}</span>

    <span class="s1">n</span><span class="s3">, </span><span class="s1">m </span><span class="s3">= </span><span class="s1">A</span><span class="s3">.</span><span class="s1">shape</span>

    <span class="s5"># All constraints must have b &gt;= 0.</span>
    <span class="s1">is_negative_constraint </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">less</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">A</span><span class="s3">[</span><span class="s1">is_negative_constraint</span><span class="s3">] *= -</span><span class="s4">1</span>
    <span class="s1">b</span><span class="s3">[</span><span class="s1">is_negative_constraint</span><span class="s3">] *= -</span><span class="s4">1</span>

    <span class="s5"># As all constraints are equality constraints the artificial variables</span>
    <span class="s5"># will also be basic variables.</span>
    <span class="s1">av </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) + </span><span class="s1">m</span>
    <span class="s1">basis </span><span class="s3">= </span><span class="s1">av</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

    <span class="s5"># Format the phase one tableau by adding artificial variables and stacking</span>
    <span class="s5"># the constraints, the objective row and pseudo-objective row.</span>
    <span class="s1">row_constraints </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">((</span><span class="s1">A</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">eye</span><span class="s3">(</span><span class="s1">n</span><span class="s3">), </span><span class="s1">b</span><span class="s3">[:, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">newaxis</span><span class="s3">]))</span>
    <span class="s1">row_objective </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">((</span><span class="s1">c</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">), </span><span class="s1">c0</span><span class="s3">))</span>
    <span class="s1">row_pseudo_objective </span><span class="s3">= -</span><span class="s1">row_constraints</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">row_pseudo_objective</span><span class="s3">[</span><span class="s1">av</span><span class="s3">] = </span><span class="s4">0</span>
    <span class="s1">T </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">((</span><span class="s1">row_constraints</span><span class="s3">, </span><span class="s1">row_objective</span><span class="s3">, </span><span class="s1">row_pseudo_objective</span><span class="s3">))</span>

    <span class="s1">nit1</span><span class="s3">, </span><span class="s1">status </span><span class="s3">= </span><span class="s1">_solve_simplex</span><span class="s3">(</span><span class="s1">T</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">=</span><span class="s1">callback</span><span class="s3">,</span>
                                  <span class="s1">postsolve_args</span><span class="s3">=</span><span class="s1">postsolve_args</span><span class="s3">,</span>
                                  <span class="s1">maxiter</span><span class="s3">=</span><span class="s1">maxiter</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s1">tol</span><span class="s3">, </span><span class="s1">phase</span><span class="s3">=</span><span class="s4">1</span><span class="s3">,</span>
                                  <span class="s1">bland</span><span class="s3">=</span><span class="s1">bland</span>
                                  <span class="s3">)</span>
    <span class="s5"># if pseudo objective is zero, remove the last row from the tableau and</span>
    <span class="s5"># proceed to phase 2</span>
    <span class="s1">nit2 </span><span class="s3">= </span><span class="s1">nit1</span>
    <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">T</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">]) &lt; </span><span class="s1">tol</span><span class="s3">:</span>
        <span class="s5"># Remove the pseudo-objective row from the tableau</span>
        <span class="s1">T </span><span class="s3">= </span><span class="s1">T</span><span class="s3">[:-</span><span class="s4">1</span><span class="s3">, :]</span>
        <span class="s5"># Remove the artificial variable columns from the tableau</span>
        <span class="s1">T </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">T</span><span class="s3">, </span><span class="s1">av</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s5"># Failure to find a feasible starting point</span>
        <span class="s1">status </span><span class="s3">= </span><span class="s4">2</span>
        <span class="s1">messages</span><span class="s3">[</span><span class="s1">status</span><span class="s3">] = (</span>
            <span class="s6">&quot;Phase 1 of the simplex method failed to find a feasible &quot;</span>
            <span class="s6">&quot;solution. The pseudo-objective function evaluates to {0:.1e} &quot;</span>
            <span class="s6">&quot;which exceeds the required tolerance of {1} for a solution to be &quot;</span>
            <span class="s6">&quot;considered 'close enough' to zero to be a basic solution. &quot;</span>
            <span class="s6">&quot;Consider increasing the tolerance to be greater than {0:.1e}. &quot;</span>
            <span class="s6">&quot;If this tolerance is unacceptably  large the problem may be &quot;</span>
            <span class="s6">&quot;infeasible.&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">T</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">]), </span><span class="s1">tol</span><span class="s3">)</span>
        <span class="s3">)</span>

    <span class="s2">if </span><span class="s1">status </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s5"># Phase 2</span>
        <span class="s1">nit2</span><span class="s3">, </span><span class="s1">status </span><span class="s3">= </span><span class="s1">_solve_simplex</span><span class="s3">(</span><span class="s1">T</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">=</span><span class="s1">callback</span><span class="s3">,</span>
                                      <span class="s1">postsolve_args</span><span class="s3">=</span><span class="s1">postsolve_args</span><span class="s3">,</span>
                                      <span class="s1">maxiter</span><span class="s3">=</span><span class="s1">maxiter</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s1">tol</span><span class="s3">, </span><span class="s1">phase</span><span class="s3">=</span><span class="s4">2</span><span class="s3">,</span>
                                      <span class="s1">bland</span><span class="s3">=</span><span class="s1">bland</span><span class="s3">, </span><span class="s1">nit0</span><span class="s3">=</span><span class="s1">nit1</span>
                                      <span class="s3">)</span>

    <span class="s1">solution </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n </span><span class="s3">+ </span><span class="s1">m</span><span class="s3">)</span>
    <span class="s1">solution</span><span class="s3">[</span><span class="s1">basis</span><span class="s3">[:</span><span class="s1">n</span><span class="s3">]] = </span><span class="s1">T</span><span class="s3">[:</span><span class="s1">n</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">]</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">solution</span><span class="s3">[:</span><span class="s1">m</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">messages</span><span class="s3">[</span><span class="s1">status</span><span class="s3">], </span><span class="s1">int</span><span class="s3">(</span><span class="s1">nit2</span><span class="s3">)</span>
</pre>
</body>
</html>