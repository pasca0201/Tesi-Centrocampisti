<html>
<head>
<title>_libsvm.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_libsvm.pyx</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Binding for libsvm_skl 
---------------------- 
 
These are the bindings for libsvm_skl, which is a fork of libsvm[1] 
that adds to libsvm some capabilities, like index of support vectors 
and efficient representation of dense matrices. 
 
These are low-level routines, but can be used for flexibility or 
performance reasons. See sklearn.svm for a higher-level API. 
 
Low-level memory management is done in libsvm_helper.c. If we happen 
to run out of memory a MemoryError will be raised. In practice this is 
not very helpful since high chances are malloc fails inside svm.cpp, 
where no sort of memory checks are done. 
 
[1] https://www.csie.ntu.edu.tw/~cjlin/libsvm/ 
 
Notes 
----- 
The signature mode='c' is somewhat superficial, since we already 
check that arrays are C-contiguous in svm.py 
 
Authors 
------- 
2010: Fabian Pedregosa &lt;fabian.pedregosa@inria.fr&gt; 
      Gael Varoquaux &lt;gael.varoquaux@normalesup.org&gt; 
&quot;&quot;&quot;</span>

<span class="s2">import  </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">libc</span><span class="s3">.</span><span class="s1">stdlib </span><span class="s2">cimport </span><span class="s1">free</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_cython_blas </span><span class="s2">cimport </span><span class="s1">_dot</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_typedefs </span><span class="s2">cimport </span><span class="s1">float64_t</span><span class="s3">, </span><span class="s1">int32_t</span><span class="s3">, </span><span class="s1">intp_t</span>

<span class="s2">include </span><span class="s4">&quot;_libsvm.pxi&quot;</span>

<span class="s2">cdef </span><span class="s1">extern </span><span class="s2">from </span><span class="s3">*:</span>
    <span class="s2">ctypedef </span><span class="s1">struct svm_parameter</span><span class="s3">:</span>
        <span class="s2">pass</span>


<span class="s5">################################################################################</span>
<span class="s5"># Internal variables</span>
<span class="s1">LIBSVM_KERNEL_TYPES </span><span class="s3">= [</span><span class="s4">'linear'</span><span class="s3">, </span><span class="s4">'poly'</span><span class="s3">, </span><span class="s4">'rbf'</span><span class="s3">, </span><span class="s4">'sigmoid'</span><span class="s3">, </span><span class="s4">'precomputed'</span><span class="s3">]</span>


<span class="s5">################################################################################</span>
<span class="s5"># Wrapper functions</span>

<span class="s2">def </span><span class="s1">fit</span><span class="s3">(</span>
    <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">X</span><span class="s3">,</span>
    <span class="s1">const float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">Y</span><span class="s3">,</span>
    <span class="s1">int svm_type</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
    <span class="s1">kernel</span><span class="s3">=</span><span class="s4">'rbf'</span><span class="s3">,</span>
    <span class="s1">int degree</span><span class="s3">=</span><span class="s6">3</span><span class="s3">,</span>
    <span class="s1">double gamma</span><span class="s3">=</span><span class="s6">0.1</span><span class="s3">,</span>
    <span class="s1">double coef0</span><span class="s3">=</span><span class="s6">0.0</span><span class="s3">,</span>
    <span class="s1">double tol</span><span class="s3">=</span><span class="s6">1e-3</span><span class="s3">,</span>
    <span class="s1">double C</span><span class="s3">=</span><span class="s6">1.0</span><span class="s3">,</span>
    <span class="s1">double nu</span><span class="s3">=</span><span class="s6">0.5</span><span class="s3">,</span>
    <span class="s1">double epsilon</span><span class="s3">=</span><span class="s6">0.1</span><span class="s3">,</span>
    <span class="s1">const float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">class_weight</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">),</span>
    <span class="s1">const float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">),</span>
    <span class="s1">int shrinking</span><span class="s3">=</span><span class="s6">1</span><span class="s3">,</span>
    <span class="s1">int probability</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
    <span class="s1">double cache_size</span><span class="s3">=</span><span class="s6">100.</span><span class="s3">,</span>
    <span class="s1">int max_iter</span><span class="s3">=-</span><span class="s6">1</span><span class="s3">,</span>
    <span class="s1">int random_seed</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Train the model using libsvm (low-level method) 
 
    Parameters 
    ---------- 
    X : array-like, dtype=float64 of shape (n_samples, n_features) 
 
    Y : array, dtype=float64 of shape (n_samples,) 
        target vector 
 
    svm_type : {0, 1, 2, 3, 4}, default=0 
        Type of SVM: C_SVC, NuSVC, OneClassSVM, EpsilonSVR or NuSVR 
        respectively. 
 
    kernel : {'linear', 'rbf', 'poly', 'sigmoid', 'precomputed'}, default=&quot;rbf&quot; 
        Kernel to use in the model: linear, polynomial, RBF, sigmoid 
        or precomputed. 
 
    degree : int32, default=3 
        Degree of the polynomial kernel (only relevant if kernel is 
        set to polynomial). 
 
    gamma : float64, default=0.1 
        Gamma parameter in rbf, poly and sigmoid kernels. Ignored by other 
        kernels. 
 
    coef0 : float64, default=0 
        Independent parameter in poly/sigmoid kernel. 
 
    tol : float64, default=1e-3 
        Numeric stopping criterion (WRITEME). 
 
    C : float64, default=1 
        C parameter in C-Support Vector Classification. 
 
    nu : float64, default=0.5 
        An upper bound on the fraction of training errors and a lower bound of 
        the fraction of support vectors. Should be in the interval (0, 1]. 
 
    epsilon : double, default=0.1 
        Epsilon parameter in the epsilon-insensitive loss function. 
 
    class_weight : array, dtype=float64, shape (n_classes,), \ 
            default=np.empty(0) 
        Set the parameter C of class i to class_weight[i]*C for 
        SVC. If not given, all classes are supposed to have 
        weight one. 
 
    sample_weight : array, dtype=float64, shape (n_samples,), \ 
            default=np.empty(0) 
        Weights assigned to each sample. 
 
    shrinking : int, default=1 
        Whether to use the shrinking heuristic. 
 
    probability : int, default=0 
        Whether to enable probability estimates. 
 
    cache_size : float64, default=100 
        Cache size for gram matrix columns (in megabytes). 
 
    max_iter : int (-1 for no limit), default=-1 
        Stop solver after this many iterations regardless of accuracy 
        (XXX Currently there is no API to know whether this kicked in.) 
 
    random_seed : int, default=0 
        Seed for the random number generator used for probability estimates. 
 
    Returns 
    ------- 
    support : array of shape (n_support,) 
        Index of support vectors. 
 
    support_vectors : array of shape (n_support, n_features) 
        Support vectors (equivalent to X[support]). Will return an 
        empty array in the case of precomputed kernel. 
 
    n_class_SV : array of shape (n_class,) 
        Number of support vectors in each class. 
 
    sv_coef : array of shape (n_class-1, n_support) 
        Coefficients of support vectors in decision function. 
 
    intercept : array of shape (n_class*(n_class-1)/2,) 
        Intercept in decision function. 
 
    probA, probB : array of shape (n_class*(n_class-1)/2,) 
        Probability estimates, empty array for probability=False. 
 
    n_iter : ndarray of shape (max(1, (n_class * (n_class - 1) // 2)),) 
        Number of iterations run by the optimization routine to fit the model. 
    &quot;&quot;&quot;</span>

    <span class="s2">cdef </span><span class="s1">svm_parameter param</span>
    <span class="s2">cdef </span><span class="s1">svm_problem problem</span>
    <span class="s2">cdef </span><span class="s1">svm_model </span><span class="s3">*</span><span class="s1">model</span>
    <span class="s2">cdef </span><span class="s1">const char </span><span class="s3">*</span><span class="s1">error_msg</span>
    <span class="s2">cdef </span><span class="s1">intp_t SV_len</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">sample_weight</span><span class="s3">) == </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">sample_weight</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] == </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], (</span>
            <span class="s4">f&quot;sample_weight and X have incompatible shapes: sample_weight has &quot;</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">sample_weight</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span><span class="s2">} </span><span class="s4">samples while X has </span><span class="s2">{</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s3">)</span>

    <span class="s1">kernel_index </span><span class="s3">= </span><span class="s1">LIBSVM_KERNEL_TYPES</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">kernel</span><span class="s3">)</span>
    <span class="s1">set_problem</span><span class="s3">(</span>
        <span class="s3">&amp;</span><span class="s1">problem</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">X</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">Y</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
        <span class="s1">kernel_index</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">problem</span><span class="s3">.</span><span class="s1">x </span><span class="s3">== </span><span class="s1">NULL</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">MemoryError</span><span class="s3">(</span><span class="s4">&quot;Seems we've run out of memory&quot;</span><span class="s3">)</span>
    <span class="s2">cdef </span><span class="s1">int32_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">class_weight_label </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span>
        <span class="s1">class_weight</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span>
    <span class="s3">)</span>
    <span class="s1">set_parameter</span><span class="s3">(</span>
        <span class="s3">&amp;</span><span class="s1">param</span><span class="s3">,</span>
        <span class="s1">svm_type</span><span class="s3">,</span>
        <span class="s1">kernel_index</span><span class="s3">,</span>
        <span class="s1">degree</span><span class="s3">,</span>
        <span class="s1">gamma</span><span class="s3">,</span>
        <span class="s1">coef0</span><span class="s3">,</span>
        <span class="s1">nu</span><span class="s3">,</span>
        <span class="s1">cache_size</span><span class="s3">,</span>
        <span class="s1">C</span><span class="s3">,</span>
        <span class="s1">tol</span><span class="s3">,</span>
        <span class="s1">epsilon</span><span class="s3">,</span>
        <span class="s1">shrinking</span><span class="s3">,</span>
        <span class="s1">probability</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">int</span><span class="s3">&gt; </span><span class="s1">class_weight</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">class_weight_label</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">class_weight_label</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">class_weight</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">class_weight</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
        <span class="s1">max_iter</span><span class="s3">,</span>
        <span class="s1">random_seed</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s1">error_msg </span><span class="s3">= </span><span class="s1">svm_check_parameter</span><span class="s3">(&amp;</span><span class="s1">problem</span><span class="s3">, &amp;</span><span class="s1">param</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">error_msg</span><span class="s3">:</span>
        <span class="s5"># for SVR: epsilon is called p in libsvm</span>
        <span class="s1">error_repl </span><span class="s3">= </span><span class="s1">error_msg</span><span class="s3">.</span><span class="s1">decode</span><span class="s3">(</span><span class="s4">'utf-8'</span><span class="s3">).</span><span class="s1">replace</span><span class="s3">(</span><span class="s4">&quot;p &lt; 0&quot;</span><span class="s3">, </span><span class="s4">&quot;epsilon &lt; 0&quot;</span><span class="s3">)</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">error_repl</span><span class="s3">)</span>
    <span class="s2">cdef </span><span class="s1">BlasFunctions blas_functions</span>
    <span class="s1">blas_functions</span><span class="s3">.</span><span class="s1">dot </span><span class="s3">= </span><span class="s1">_dot</span><span class="s3">[</span><span class="s1">double</span><span class="s3">]</span>
    <span class="s5"># this does the real work</span>
    <span class="s2">cdef </span><span class="s1">int fit_status </span><span class="s3">= </span><span class="s6">0</span>
    <span class="s2">with </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s1">model </span><span class="s3">= </span><span class="s1">svm_train</span><span class="s3">(&amp;</span><span class="s1">problem</span><span class="s3">, &amp;</span><span class="s1">param</span><span class="s3">, &amp;</span><span class="s1">fit_status</span><span class="s3">, &amp;</span><span class="s1">blas_functions</span><span class="s3">)</span>

    <span class="s5"># from here until the end, we just copy the data returned by</span>
    <span class="s5"># svm_train</span>
    <span class="s1">SV_len </span><span class="s3">= </span><span class="s1">get_l</span><span class="s3">(</span><span class="s1">model</span><span class="s3">)</span>
    <span class="s1">n_class </span><span class="s3">= </span><span class="s1">get_nr</span><span class="s3">(</span><span class="s1">model</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">int</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">n_iter </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">max</span><span class="s3">(</span><span class="s6">1</span><span class="s3">, </span><span class="s1">n_class </span><span class="s3">* (</span><span class="s1">n_class </span><span class="s3">- </span><span class="s6">1</span><span class="s3">) // </span><span class="s6">2</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intc</span><span class="s3">)</span>
    <span class="s1">copy_n_iter</span><span class="s3">(&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">n_iter</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">model</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">float64_t</span><span class="s3">[:, ::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">sv_coef </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n_class</span><span class="s3">-</span><span class="s6">1</span><span class="s3">, </span><span class="s1">SV_len</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s1">copy_sv_coef</span><span class="s3">(&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">sv_coef</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">sv_coef</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">, </span><span class="s1">model</span><span class="s3">)</span>

    <span class="s5"># the intercept is just model.rho but with sign changed</span>
    <span class="s2">cdef </span><span class="s1">float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">intercept </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span>
        <span class="s1">int</span><span class="s3">((</span><span class="s1">n_class</span><span class="s3">*(</span><span class="s1">n_class</span><span class="s3">-</span><span class="s6">1</span><span class="s3">))/</span><span class="s6">2</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span>
    <span class="s3">)</span>
    <span class="s1">copy_intercept</span><span class="s3">(&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">intercept</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">model</span><span class="s3">, &lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">intercept</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">int32_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">support </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">SV_len</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
    <span class="s1">copy_support</span><span class="s3">(&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">support</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">support</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">, </span><span class="s1">model</span><span class="s3">)</span>

    <span class="s5"># copy model.SV</span>
    <span class="s2">cdef </span><span class="s1">float64_t</span><span class="s3">[:, ::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">support_vectors</span>
    <span class="s2">if </span><span class="s1">kernel_index </span><span class="s3">== </span><span class="s6">4</span><span class="s3">:</span>
        <span class="s5"># precomputed kernel</span>
        <span class="s1">support_vectors </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">support_vectors </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">SV_len</span><span class="s3">, </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s1">copy_SV</span><span class="s3">(</span>
            <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">support_vectors</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">support_vectors</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
            <span class="s1">model</span><span class="s3">,</span>
            <span class="s3">&lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">support_vectors</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">int32_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">n_class_SV</span>
    <span class="s2">if </span><span class="s1">svm_type </span><span class="s3">== </span><span class="s6">0 </span><span class="s2">or </span><span class="s1">svm_type </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s1">n_class_SV </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n_class</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
        <span class="s1">copy_nSV</span><span class="s3">(&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">n_class_SV</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">n_class_SV</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">, </span><span class="s1">model</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s5"># OneClass and SVR are considered to have 2 classes</span>
        <span class="s1">n_class_SV </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">SV_len</span><span class="s3">, </span><span class="s1">SV_len</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">probA</span>
    <span class="s2">cdef </span><span class="s1">float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">probB</span>
    <span class="s2">if </span><span class="s1">probability </span><span class="s3">!= </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">svm_type </span><span class="s3">&lt; </span><span class="s6">2</span><span class="s3">:  </span><span class="s5"># SVC and NuSVC</span>
            <span class="s1">probA </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">n_class</span><span class="s3">*(</span><span class="s1">n_class</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)/</span><span class="s6">2</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
            <span class="s1">probB </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">n_class</span><span class="s3">*(</span><span class="s1">n_class</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)/</span><span class="s6">2</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
            <span class="s1">copy_probB</span><span class="s3">(&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">probB</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">model</span><span class="s3">, &lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">probB</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">probA </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">1</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
            <span class="s1">probB </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s1">copy_probA</span><span class="s3">(&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">probA</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">model</span><span class="s3">, &lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">probA</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">probA </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s1">probB </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s1">svm_free_and_destroy_model</span><span class="s3">(&amp;</span><span class="s1">model</span><span class="s3">)</span>
    <span class="s1">free</span><span class="s3">(</span><span class="s1">problem</span><span class="s3">.</span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s3">(</span>
        <span class="s1">support</span><span class="s3">.</span><span class="s1">base</span><span class="s3">,</span>
        <span class="s1">support_vectors</span><span class="s3">.</span><span class="s1">base</span><span class="s3">,</span>
        <span class="s1">n_class_SV</span><span class="s3">.</span><span class="s1">base</span><span class="s3">,</span>
        <span class="s1">sv_coef</span><span class="s3">.</span><span class="s1">base</span><span class="s3">,</span>
        <span class="s1">intercept</span><span class="s3">.</span><span class="s1">base</span><span class="s3">,</span>
        <span class="s1">probA</span><span class="s3">.</span><span class="s1">base</span><span class="s3">,</span>
        <span class="s1">probB</span><span class="s3">.</span><span class="s1">base</span><span class="s3">,</span>
        <span class="s1">fit_status</span><span class="s3">,</span>
        <span class="s1">n_iter</span><span class="s3">.</span><span class="s1">base</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">cdef </span><span class="s1">void set_predict_params</span><span class="s3">(</span>
    <span class="s1">svm_parameter </span><span class="s3">*</span><span class="s1">param</span><span class="s3">,</span>
    <span class="s1">int svm_type</span><span class="s3">,</span>
    <span class="s1">kernel</span><span class="s3">,</span>
    <span class="s1">int degree</span><span class="s3">,</span>
    <span class="s1">double gamma</span><span class="s3">,</span>
    <span class="s1">double coef0</span><span class="s3">,</span>
    <span class="s1">double cache_size</span><span class="s3">,</span>
    <span class="s1">int probability</span><span class="s3">,</span>
    <span class="s1">int nr_weight</span><span class="s3">,</span>
    <span class="s1">char </span><span class="s3">*</span><span class="s1">weight_label</span><span class="s3">,</span>
    <span class="s1">char </span><span class="s3">*</span><span class="s1">weight</span><span class="s3">,</span>
<span class="s3">) </span><span class="s2">except </span><span class="s3">*:</span>
    <span class="s4">&quot;&quot;&quot;Fill param with prediction time-only parameters.&quot;&quot;&quot;</span>

    <span class="s5"># training-time only parameters</span>
    <span class="s2">cdef </span><span class="s1">double C </span><span class="s3">= </span><span class="s6">0.0</span>
    <span class="s2">cdef </span><span class="s1">double epsilon </span><span class="s3">= </span><span class="s6">0.1</span>
    <span class="s2">cdef </span><span class="s1">int max_iter </span><span class="s3">= </span><span class="s6">0</span>
    <span class="s2">cdef </span><span class="s1">double nu </span><span class="s3">= </span><span class="s6">0.5</span>
    <span class="s2">cdef </span><span class="s1">int shrinking </span><span class="s3">= </span><span class="s6">0</span>
    <span class="s2">cdef </span><span class="s1">double tol </span><span class="s3">= </span><span class="s6">0.1</span>
    <span class="s2">cdef </span><span class="s1">int random_seed </span><span class="s3">= -</span><span class="s6">1</span>

    <span class="s1">kernel_index </span><span class="s3">= </span><span class="s1">LIBSVM_KERNEL_TYPES</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">kernel</span><span class="s3">)</span>

    <span class="s1">set_parameter</span><span class="s3">(</span>
        <span class="s1">param</span><span class="s3">,</span>
        <span class="s1">svm_type</span><span class="s3">,</span>
        <span class="s1">kernel_index</span><span class="s3">,</span>
        <span class="s1">degree</span><span class="s3">,</span>
        <span class="s1">gamma</span><span class="s3">,</span>
        <span class="s1">coef0</span><span class="s3">,</span>
        <span class="s1">nu</span><span class="s3">,</span>
        <span class="s1">cache_size</span><span class="s3">,</span>
        <span class="s1">C</span><span class="s3">,</span>
        <span class="s1">tol</span><span class="s3">,</span>
        <span class="s1">epsilon</span><span class="s3">,</span>
        <span class="s1">shrinking</span><span class="s3">,</span>
        <span class="s1">probability</span><span class="s3">,</span>
        <span class="s1">nr_weight</span><span class="s3">,</span>
        <span class="s1">weight_label</span><span class="s3">,</span>
        <span class="s1">weight</span><span class="s3">,</span>
        <span class="s1">max_iter</span><span class="s3">,</span>
        <span class="s1">random_seed</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">predict</span><span class="s3">(</span>
    <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">X</span><span class="s3">,</span>
    <span class="s1">const int32_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">support</span><span class="s3">,</span>
    <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">SV</span><span class="s3">,</span>
    <span class="s1">const int32_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">nSV</span><span class="s3">,</span>
    <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">sv_coef</span><span class="s3">,</span>
    <span class="s1">const float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">intercept</span><span class="s3">,</span>
    <span class="s1">const float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">probA</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">),</span>
    <span class="s1">const float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">probB</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">),</span>
    <span class="s1">int svm_type</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
    <span class="s1">kernel</span><span class="s3">=</span><span class="s4">'rbf'</span><span class="s3">,</span>
    <span class="s1">int degree</span><span class="s3">=</span><span class="s6">3</span><span class="s3">,</span>
    <span class="s1">double gamma</span><span class="s3">=</span><span class="s6">0.1</span><span class="s3">,</span>
    <span class="s1">double coef0</span><span class="s3">=</span><span class="s6">0.0</span><span class="s3">,</span>
    <span class="s1">const float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">class_weight</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">),</span>
    <span class="s1">const float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">),</span>
    <span class="s1">double cache_size</span><span class="s3">=</span><span class="s6">100.0</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Predict target values of X given a model (low-level method) 
 
    Parameters 
    ---------- 
    X : array-like, dtype=float of shape (n_samples, n_features) 
 
    support : array of shape (n_support,) 
        Index of support vectors in training set. 
 
    SV : array of shape (n_support, n_features) 
        Support vectors. 
 
    nSV : array of shape (n_class,) 
        Number of support vectors in each class. 
 
    sv_coef : array of shape (n_class-1, n_support) 
        Coefficients of support vectors in decision function. 
 
    intercept : array of shape (n_class*(n_class-1)/2) 
        Intercept in decision function. 
 
    probA, probB : array of shape (n_class*(n_class-1)/2,) 
        Probability estimates. 
 
    svm_type : {0, 1, 2, 3, 4}, default=0 
        Type of SVM: C_SVC, NuSVC, OneClassSVM, EpsilonSVR or NuSVR 
        respectively. 
 
    kernel : {'linear', 'rbf', 'poly', 'sigmoid', 'precomputed'}, default=&quot;rbf&quot; 
        Kernel to use in the model: linear, polynomial, RBF, sigmoid 
        or precomputed. 
 
    degree : int32, default=3 
        Degree of the polynomial kernel (only relevant if kernel is 
        set to polynomial). 
 
    gamma : float64, default=0.1 
        Gamma parameter in rbf, poly and sigmoid kernels. Ignored by other 
        kernels. 
 
    coef0 : float64, default=0.0 
        Independent parameter in poly/sigmoid kernel. 
 
    Returns 
    ------- 
    dec_values : array 
        Predicted values. 
    &quot;&quot;&quot;</span>
    <span class="s2">cdef </span><span class="s1">float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">dec_values</span>
    <span class="s2">cdef </span><span class="s1">svm_parameter param</span>
    <span class="s2">cdef </span><span class="s1">svm_model </span><span class="s3">*</span><span class="s1">model</span>
    <span class="s2">cdef </span><span class="s1">int rv</span>

    <span class="s2">cdef </span><span class="s1">int32_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">class_weight_label </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span>
        <span class="s1">class_weight</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span>
    <span class="s3">)</span>

    <span class="s1">set_predict_params</span><span class="s3">(</span>
        <span class="s3">&amp;</span><span class="s1">param</span><span class="s3">,</span>
        <span class="s1">svm_type</span><span class="s3">,</span>
        <span class="s1">kernel</span><span class="s3">,</span>
        <span class="s1">degree</span><span class="s3">,</span>
        <span class="s1">gamma</span><span class="s3">,</span>
        <span class="s1">coef0</span><span class="s3">,</span>
        <span class="s1">cache_size</span><span class="s3">,</span>
        <span class="s6">0</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">int</span><span class="s3">&gt;</span><span class="s1">class_weight</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">class_weight_label</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">class_weight_label</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">class_weight</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">class_weight</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">model </span><span class="s3">= </span><span class="s1">set_model</span><span class="s3">(</span>
        <span class="s3">&amp;</span><span class="s1">param</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">int</span><span class="s3">&gt; </span><span class="s1">nSV</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">SV</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">SV</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">SV</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">support</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">support</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">support</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">sv_coef</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">sv_coef</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">sv_coef</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">intercept</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">nSV</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">probA</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">probA</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">probB</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">probB</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">cdef </span><span class="s1">BlasFunctions blas_functions</span>
    <span class="s1">blas_functions</span><span class="s3">.</span><span class="s1">dot </span><span class="s3">= </span><span class="s1">_dot</span><span class="s3">[</span><span class="s1">double</span><span class="s3">]</span>
    <span class="s5"># TODO: use check_model</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">dec_values </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>
        <span class="s2">with </span><span class="s1">nogil</span><span class="s3">:</span>
            <span class="s1">rv </span><span class="s3">= </span><span class="s1">copy_predict</span><span class="s3">(</span>
                <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">X</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">],</span>
                <span class="s1">model</span><span class="s3">,</span>
                <span class="s3">&lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
                <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">dec_values</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
                <span class="s3">&amp;</span><span class="s1">blas_functions</span><span class="s3">,</span>
            <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">rv </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">MemoryError</span><span class="s3">(</span><span class="s4">&quot;We've run out of memory&quot;</span><span class="s3">)</span>
    <span class="s2">finally</span><span class="s3">:</span>
        <span class="s1">free_model</span><span class="s3">(</span><span class="s1">model</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">dec_values</span><span class="s3">.</span><span class="s1">base</span>


<span class="s2">def </span><span class="s1">predict_proba</span><span class="s3">(</span>
    <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">X</span><span class="s3">,</span>
    <span class="s1">const int32_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">support</span><span class="s3">,</span>
    <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">SV</span><span class="s3">,</span>
    <span class="s1">const int32_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">nSV</span><span class="s3">,</span>
    <span class="s1">float64_t</span><span class="s3">[:, ::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">sv_coef</span><span class="s3">,</span>
    <span class="s1">float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">intercept</span><span class="s3">,</span>
    <span class="s1">float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">probA</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">),</span>
    <span class="s1">float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">probB</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">),</span>
    <span class="s1">int svm_type</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
    <span class="s1">kernel</span><span class="s3">=</span><span class="s4">'rbf'</span><span class="s3">,</span>
    <span class="s1">int degree</span><span class="s3">=</span><span class="s6">3</span><span class="s3">,</span>
    <span class="s1">double gamma</span><span class="s3">=</span><span class="s6">0.1</span><span class="s3">,</span>
    <span class="s1">double coef0</span><span class="s3">=</span><span class="s6">0.0</span><span class="s3">,</span>
    <span class="s1">float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">class_weight</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">),</span>
    <span class="s1">float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">),</span>
    <span class="s1">double cache_size</span><span class="s3">=</span><span class="s6">100.0</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Predict probabilities 
 
    svm_model stores all parameters needed to predict a given value. 
 
    For speed, all real work is done at the C level in function 
    copy_predict (libsvm_helper.c). 
 
    We have to reconstruct model and parameters to make sure we stay 
    in sync with the python object. 
 
    See sklearn.svm.predict for a complete list of parameters. 
 
    Parameters 
    ---------- 
    X : array-like, dtype=float of shape (n_samples, n_features) 
 
    support : array of shape (n_support,) 
        Index of support vectors in training set. 
 
    SV : array of shape (n_support, n_features) 
        Support vectors. 
 
    nSV : array of shape (n_class,) 
        Number of support vectors in each class. 
 
    sv_coef : array of shape (n_class-1, n_support) 
        Coefficients of support vectors in decision function. 
 
    intercept : array of shape (n_class*(n_class-1)/2,) 
        Intercept in decision function. 
 
    probA, probB : array of shape (n_class*(n_class-1)/2,) 
        Probability estimates. 
 
    svm_type : {0, 1, 2, 3, 4}, default=0 
        Type of SVM: C_SVC, NuSVC, OneClassSVM, EpsilonSVR or NuSVR 
        respectively. 
 
    kernel : {'linear', 'rbf', 'poly', 'sigmoid', 'precomputed'}, default=&quot;rbf&quot; 
        Kernel to use in the model: linear, polynomial, RBF, sigmoid 
        or precomputed. 
 
    degree : int32, default=3 
        Degree of the polynomial kernel (only relevant if kernel is 
        set to polynomial). 
 
    gamma : float64, default=0.1 
        Gamma parameter in rbf, poly and sigmoid kernels. Ignored by other 
        kernels. 
 
    coef0 : float64, default=0.0 
        Independent parameter in poly/sigmoid kernel. 
 
    Returns 
    ------- 
    dec_values : array 
        Predicted values. 
    &quot;&quot;&quot;</span>
    <span class="s2">cdef </span><span class="s1">float64_t</span><span class="s3">[:, ::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">dec_values</span>
    <span class="s2">cdef </span><span class="s1">svm_parameter param</span>
    <span class="s2">cdef </span><span class="s1">svm_model </span><span class="s3">*</span><span class="s1">model</span>
    <span class="s2">cdef </span><span class="s1">int32_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">class_weight_label </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span>
        <span class="s1">class_weight</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span>
    <span class="s3">)</span>
    <span class="s2">cdef </span><span class="s1">int rv</span>

    <span class="s1">set_predict_params</span><span class="s3">(</span>
        <span class="s3">&amp;</span><span class="s1">param</span><span class="s3">,</span>
        <span class="s1">svm_type</span><span class="s3">,</span>
        <span class="s1">kernel</span><span class="s3">,</span>
        <span class="s1">degree</span><span class="s3">,</span>
        <span class="s1">gamma</span><span class="s3">,</span>
        <span class="s1">coef0</span><span class="s3">,</span>
        <span class="s1">cache_size</span><span class="s3">,</span>
        <span class="s6">1</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">int</span><span class="s3">&gt; </span><span class="s1">class_weight</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">class_weight_label</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">class_weight_label</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">class_weight</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">class_weight</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">model </span><span class="s3">= </span><span class="s1">set_model</span><span class="s3">(</span>
        <span class="s3">&amp;</span><span class="s1">param</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">int</span><span class="s3">&gt; </span><span class="s1">nSV</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">SV</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">SV</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">SV</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">support</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">support</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">sv_coef</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">sv_coef</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">intercept</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">nSV</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">probA</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">probA</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">probB</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">probB</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">intp_t n_class </span><span class="s3">= </span><span class="s1">get_nr</span><span class="s3">(</span><span class="s1">model</span><span class="s3">)</span>
    <span class="s2">cdef </span><span class="s1">BlasFunctions blas_functions</span>
    <span class="s1">blas_functions</span><span class="s3">.</span><span class="s1">dot </span><span class="s3">= </span><span class="s1">_dot</span><span class="s3">[</span><span class="s1">double</span><span class="s3">]</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">dec_values </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">n_class</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">nogil</span><span class="s3">:</span>
            <span class="s1">rv </span><span class="s3">= </span><span class="s1">copy_predict_proba</span><span class="s3">(</span>
                <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">X</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">],</span>
                <span class="s1">model</span><span class="s3">,</span>
                <span class="s3">&lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
                <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">dec_values</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">],</span>
                <span class="s3">&amp;</span><span class="s1">blas_functions</span><span class="s3">,</span>
            <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">rv </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">MemoryError</span><span class="s3">(</span><span class="s4">&quot;We've run out of memory&quot;</span><span class="s3">)</span>
    <span class="s2">finally</span><span class="s3">:</span>
        <span class="s1">free_model</span><span class="s3">(</span><span class="s1">model</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">dec_values</span><span class="s3">.</span><span class="s1">base</span>


<span class="s2">def </span><span class="s1">decision_function</span><span class="s3">(</span>
    <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">X</span><span class="s3">,</span>
    <span class="s1">const int32_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">support</span><span class="s3">,</span>
    <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">SV</span><span class="s3">,</span>
    <span class="s1">const int32_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">nSV</span><span class="s3">,</span>
    <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">sv_coef</span><span class="s3">,</span>
    <span class="s1">const float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">intercept</span><span class="s3">,</span>
    <span class="s1">const float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">probA</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">),</span>
    <span class="s1">const float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">probB</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">),</span>
    <span class="s1">int svm_type</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
    <span class="s1">kernel</span><span class="s3">=</span><span class="s4">'rbf'</span><span class="s3">,</span>
    <span class="s1">int degree</span><span class="s3">=</span><span class="s6">3</span><span class="s3">,</span>
    <span class="s1">double gamma</span><span class="s3">=</span><span class="s6">0.1</span><span class="s3">,</span>
    <span class="s1">double coef0</span><span class="s3">=</span><span class="s6">0.0</span><span class="s3">,</span>
    <span class="s1">const float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">class_weight</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">),</span>
    <span class="s1">const float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">),</span>
    <span class="s1">double cache_size</span><span class="s3">=</span><span class="s6">100.0</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Predict margin (libsvm name for this is predict_values) 
 
    We have to reconstruct model and parameters to make sure we stay 
    in sync with the python object. 
 
    Parameters 
    ---------- 
    X : array-like, dtype=float, size=[n_samples, n_features] 
 
    support : array, shape=[n_support] 
        Index of support vectors in training set. 
 
    SV : array, shape=[n_support, n_features] 
        Support vectors. 
 
    nSV : array, shape=[n_class] 
        Number of support vectors in each class. 
 
    sv_coef : array, shape=[n_class-1, n_support] 
        Coefficients of support vectors in decision function. 
 
    intercept : array, shape=[n_class*(n_class-1)/2] 
        Intercept in decision function. 
 
    probA, probB : array, shape=[n_class*(n_class-1)/2] 
        Probability estimates. 
 
    svm_type : {0, 1, 2, 3, 4}, optional 
        Type of SVM: C_SVC, NuSVC, OneClassSVM, EpsilonSVR or NuSVR 
        respectively. 0 by default. 
 
    kernel : {'linear', 'rbf', 'poly', 'sigmoid', 'precomputed'}, optional 
        Kernel to use in the model: linear, polynomial, RBF, sigmoid 
        or precomputed. 'rbf' by default. 
 
    degree : int32, optional 
        Degree of the polynomial kernel (only relevant if kernel is 
        set to polynomial), 3 by default. 
 
    gamma : float64, optional 
        Gamma parameter in rbf, poly and sigmoid kernels. Ignored by other 
        kernels. 0.1 by default. 
 
    coef0 : float64, optional 
        Independent parameter in poly/sigmoid kernel. 0 by default. 
 
    Returns 
    ------- 
    dec_values : array 
        Predicted values. 
    &quot;&quot;&quot;</span>
    <span class="s2">cdef </span><span class="s1">float64_t</span><span class="s3">[:, ::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">dec_values</span>
    <span class="s2">cdef </span><span class="s1">svm_parameter param</span>
    <span class="s2">cdef </span><span class="s1">svm_model </span><span class="s3">*</span><span class="s1">model</span>
    <span class="s2">cdef </span><span class="s1">intp_t n_class</span>

    <span class="s2">cdef </span><span class="s1">int32_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">class_weight_label </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span>
        <span class="s1">class_weight</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span>
    <span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">int rv</span>

    <span class="s1">set_predict_params</span><span class="s3">(</span>
        <span class="s3">&amp;</span><span class="s1">param</span><span class="s3">,</span>
        <span class="s1">svm_type</span><span class="s3">,</span>
        <span class="s1">kernel</span><span class="s3">,</span>
        <span class="s1">degree</span><span class="s3">,</span>
        <span class="s1">gamma</span><span class="s3">,</span>
        <span class="s1">coef0</span><span class="s3">,</span>
        <span class="s1">cache_size</span><span class="s3">,</span>
        <span class="s6">0</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">int</span><span class="s3">&gt; </span><span class="s1">class_weight</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">class_weight_label</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">class_weight_label</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">class_weight</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">class_weight</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s1">model </span><span class="s3">= </span><span class="s1">set_model</span><span class="s3">(</span>
        <span class="s3">&amp;</span><span class="s1">param</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">int</span><span class="s3">&gt; </span><span class="s1">nSV</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">SV</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">SV</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">SV</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">support</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">support</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">sv_coef</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">sv_coef</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">intercept</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">nSV</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">probA</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">probA</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">probB</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">probB</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">if </span><span class="s1">svm_type </span><span class="s3">&gt; </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s1">n_class </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">n_class </span><span class="s3">= </span><span class="s1">get_nr</span><span class="s3">(</span><span class="s1">model</span><span class="s3">)</span>
        <span class="s1">n_class </span><span class="s3">= </span><span class="s1">n_class </span><span class="s3">* (</span><span class="s1">n_class </span><span class="s3">- </span><span class="s6">1</span><span class="s3">) // </span><span class="s6">2</span>
    <span class="s2">cdef </span><span class="s1">BlasFunctions blas_functions</span>
    <span class="s1">blas_functions</span><span class="s3">.</span><span class="s1">dot </span><span class="s3">= </span><span class="s1">_dot</span><span class="s3">[</span><span class="s1">double</span><span class="s3">]</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">dec_values </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">n_class</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">nogil</span><span class="s3">:</span>
            <span class="s1">rv </span><span class="s3">= </span><span class="s1">copy_predict_values</span><span class="s3">(</span>
                <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">X</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">],</span>
                <span class="s1">model</span><span class="s3">,</span>
                <span class="s3">&lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
                <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">dec_values</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">],</span>
                <span class="s1">n_class</span><span class="s3">,</span>
                <span class="s3">&amp;</span><span class="s1">blas_functions</span><span class="s3">,</span>
            <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">rv </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">MemoryError</span><span class="s3">(</span><span class="s4">&quot;We've run out of memory&quot;</span><span class="s3">)</span>
    <span class="s2">finally</span><span class="s3">:</span>
        <span class="s1">free_model</span><span class="s3">(</span><span class="s1">model</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">dec_values</span><span class="s3">.</span><span class="s1">base</span>


<span class="s2">def </span><span class="s1">cross_validation</span><span class="s3">(</span>
    <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">X</span><span class="s3">,</span>
    <span class="s1">const float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">Y</span><span class="s3">,</span>
    <span class="s1">int n_fold</span><span class="s3">,</span>
    <span class="s1">int svm_type</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
    <span class="s1">kernel</span><span class="s3">=</span><span class="s4">'rbf'</span><span class="s3">,</span>
    <span class="s1">int degree</span><span class="s3">=</span><span class="s6">3</span><span class="s3">,</span>
    <span class="s1">double gamma</span><span class="s3">=</span><span class="s6">0.1</span><span class="s3">,</span>
    <span class="s1">double coef0</span><span class="s3">=</span><span class="s6">0.0</span><span class="s3">,</span>
    <span class="s1">double tol</span><span class="s3">=</span><span class="s6">1e-3</span><span class="s3">,</span>
    <span class="s1">double C</span><span class="s3">=</span><span class="s6">1.0</span><span class="s3">,</span>
    <span class="s1">double nu</span><span class="s3">=</span><span class="s6">0.5</span><span class="s3">,</span>
    <span class="s1">double epsilon</span><span class="s3">=</span><span class="s6">0.1</span><span class="s3">,</span>
    <span class="s1">float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">class_weight</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">),</span>
    <span class="s1">float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s6">0</span><span class="s3">),</span>
    <span class="s1">int shrinking</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
    <span class="s1">int probability</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
    <span class="s1">double cache_size</span><span class="s3">=</span><span class="s6">100.0</span><span class="s3">,</span>
    <span class="s1">int max_iter</span><span class="s3">=-</span><span class="s6">1</span><span class="s3">,</span>
    <span class="s1">int random_seed</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Binding of the cross-validation routine (low-level routine) 
 
    Parameters 
    ---------- 
 
    X : array-like, dtype=float of shape (n_samples, n_features) 
 
    Y : array, dtype=float of shape (n_samples,) 
        target vector 
 
    n_fold : int32 
        Number of folds for cross validation. 
 
    svm_type : {0, 1, 2, 3, 4}, default=0 
        Type of SVM: C_SVC, NuSVC, OneClassSVM, EpsilonSVR or NuSVR 
        respectively. 
 
    kernel : {'linear', 'rbf', 'poly', 'sigmoid', 'precomputed'}, default='rbf' 
        Kernel to use in the model: linear, polynomial, RBF, sigmoid 
        or precomputed. 
 
    degree : int32, default=3 
        Degree of the polynomial kernel (only relevant if kernel is 
        set to polynomial). 
 
    gamma : float64, default=0.1 
        Gamma parameter in rbf, poly and sigmoid kernels. Ignored by other 
        kernels. 
 
    coef0 : float64, default=0.0 
        Independent parameter in poly/sigmoid kernel. 
 
    tol : float64, default=1e-3 
        Numeric stopping criterion (WRITEME). 
 
    C : float64, default=1 
        C parameter in C-Support Vector Classification. 
 
    nu : float64, default=0.5 
        An upper bound on the fraction of training errors and a lower bound of 
        the fraction of support vectors. Should be in the interval (0, 1]. 
 
    epsilon : double, default=0.1 
        Epsilon parameter in the epsilon-insensitive loss function. 
 
    class_weight : array, dtype=float64, shape (n_classes,), \ 
            default=np.empty(0) 
        Set the parameter C of class i to class_weight[i]*C for 
        SVC. If not given, all classes are supposed to have 
        weight one. 
 
    sample_weight : array, dtype=float64, shape (n_samples,), \ 
            default=np.empty(0) 
        Weights assigned to each sample. 
 
    shrinking : int, default=1 
        Whether to use the shrinking heuristic. 
 
    probability : int, default=0 
        Whether to enable probability estimates. 
 
    cache_size : float64, default=100 
        Cache size for gram matrix columns (in megabytes). 
 
    max_iter : int (-1 for no limit), default=-1 
        Stop solver after this many iterations regardless of accuracy 
        (XXX Currently there is no API to know whether this kicked in.) 
 
    random_seed : int, default=0 
        Seed for the random number generator used for probability estimates. 
 
    Returns 
    ------- 
    target : array, float 
 
    &quot;&quot;&quot;</span>

    <span class="s2">cdef </span><span class="s1">svm_parameter param</span>
    <span class="s2">cdef </span><span class="s1">svm_problem problem</span>
    <span class="s2">cdef </span><span class="s1">const char </span><span class="s3">*</span><span class="s1">error_msg</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">sample_weight</span><span class="s3">) == </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">sample_weight</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] == </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], (</span>
            <span class="s4">f&quot;sample_weight and X have incompatible shapes: sample_weight has &quot;</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">sample_weight</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span><span class="s2">} </span><span class="s4">samples while X has </span><span class="s2">{</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s3">)</span>

    <span class="s2">if </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] &lt; </span><span class="s1">n_fold</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Number of samples is less than number of folds&quot;</span><span class="s3">)</span>

    <span class="s5"># set problem</span>
    <span class="s1">kernel_index </span><span class="s3">= </span><span class="s1">LIBSVM_KERNEL_TYPES</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">kernel</span><span class="s3">)</span>
    <span class="s1">set_problem</span><span class="s3">(</span>
        <span class="s3">&amp;</span><span class="s1">problem</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">X</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">Y</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">sample_weight</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">intp_t</span><span class="s3">*&gt; </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
        <span class="s1">kernel_index</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">problem</span><span class="s3">.</span><span class="s1">x </span><span class="s3">== </span><span class="s1">NULL</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">MemoryError</span><span class="s3">(</span><span class="s4">&quot;Seems we've run out of memory&quot;</span><span class="s3">)</span>
    <span class="s2">cdef </span><span class="s1">int32_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">class_weight_label </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span>
        <span class="s1">class_weight</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span>
    <span class="s3">)</span>

    <span class="s5"># set parameters</span>
    <span class="s1">set_parameter</span><span class="s3">(</span>
        <span class="s3">&amp;</span><span class="s1">param</span><span class="s3">,</span>
        <span class="s1">svm_type</span><span class="s3">,</span>
        <span class="s1">kernel_index</span><span class="s3">,</span>
        <span class="s1">degree</span><span class="s3">,</span>
        <span class="s1">gamma</span><span class="s3">,</span>
        <span class="s1">coef0</span><span class="s3">,</span>
        <span class="s1">nu</span><span class="s3">,</span>
        <span class="s1">cache_size</span><span class="s3">,</span>
        <span class="s1">C</span><span class="s3">,</span>
        <span class="s1">tol</span><span class="s3">,</span>
        <span class="s1">tol</span><span class="s3">,</span>
        <span class="s1">shrinking</span><span class="s3">,</span>
        <span class="s1">probability</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">int</span><span class="s3">&gt; </span><span class="s1">class_weight</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">class_weight_label</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">class_weight_label</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
        <span class="s3">&lt;</span><span class="s1">char</span><span class="s3">*&gt; &amp;</span><span class="s1">class_weight</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s2">if </span><span class="s1">class_weight</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s2">else </span><span class="s1">NULL</span><span class="s3">,</span>
        <span class="s1">max_iter</span><span class="s3">,</span>
        <span class="s1">random_seed</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s1">error_msg </span><span class="s3">= </span><span class="s1">svm_check_parameter</span><span class="s3">(&amp;</span><span class="s1">problem</span><span class="s3">, &amp;</span><span class="s1">param</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">error_msg</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">error_msg</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">float64_t</span><span class="s3">[::</span><span class="s6">1</span><span class="s3">] </span><span class="s1">target</span>
    <span class="s2">cdef </span><span class="s1">BlasFunctions blas_functions</span>
    <span class="s1">blas_functions</span><span class="s3">.</span><span class="s1">dot </span><span class="s3">= </span><span class="s1">_dot</span><span class="s3">[</span><span class="s1">double</span><span class="s3">]</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">target </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">nogil</span><span class="s3">:</span>
            <span class="s1">svm_cross_validation</span><span class="s3">(</span>
                <span class="s3">&amp;</span><span class="s1">problem</span><span class="s3">,</span>
                <span class="s3">&amp;</span><span class="s1">param</span><span class="s3">,</span>
                <span class="s1">n_fold</span><span class="s3">,</span>
                <span class="s3">&lt;</span><span class="s1">double </span><span class="s3">*&gt; &amp;</span><span class="s1">target</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
                <span class="s3">&amp;</span><span class="s1">blas_functions</span><span class="s3">,</span>
            <span class="s3">)</span>
    <span class="s2">finally</span><span class="s3">:</span>
        <span class="s1">free</span><span class="s3">(</span><span class="s1">problem</span><span class="s3">.</span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">target</span><span class="s3">.</span><span class="s1">base</span>


<span class="s2">def </span><span class="s1">set_verbosity_wrap</span><span class="s3">(</span><span class="s1">int verbosity</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Control verbosity of libsvm library 
    &quot;&quot;&quot;</span>
    <span class="s1">set_verbosity</span><span class="s3">(</span><span class="s1">verbosity</span><span class="s3">)</span>
</pre>
</body>
</html>