<html>
<head>
<title>test_mio.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_mio.py</font>
</center></td></tr></table>
<pre><span class="s0">''' Nose test generators 
 
Need function load / save / roundtrip tests 
 
'''</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">OrderedDict</span>
<span class="s2">from </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path </span><span class="s2">import </span><span class="s1">join </span><span class="s2">as </span><span class="s1">pjoin</span><span class="s3">, </span><span class="s1">dirname</span>
<span class="s2">from </span><span class="s1">glob </span><span class="s2">import </span><span class="s1">glob</span>
<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">BytesIO</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">from </span><span class="s1">tempfile </span><span class="s2">import </span><span class="s1">mkdtemp</span>

<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">shutil</span>
<span class="s2">import </span><span class="s1">gzip</span>

<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">testing </span><span class="s2">import </span><span class="s3">(</span><span class="s1">assert_array_equal</span><span class="s3">, </span><span class="s1">assert_array_almost_equal</span><span class="s3">,</span>
                           <span class="s1">assert_equal</span><span class="s3">, </span><span class="s1">assert_</span><span class="s3">, </span><span class="s1">assert_warns</span><span class="s3">, </span><span class="s1">assert_allclose</span><span class="s3">)</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">pytest </span><span class="s2">import </span><span class="s1">raises </span><span class="s2">as </span><span class="s1">assert_raises</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">array</span>
<span class="s2">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">sparse </span><span class="s2">as </span><span class="s1">SP</span>

<span class="s2">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">io</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">io</span><span class="s3">.</span><span class="s1">matlab </span><span class="s2">import </span><span class="s1">MatlabOpaque</span><span class="s3">, </span><span class="s1">MatlabFunction</span><span class="s3">, </span><span class="s1">MatlabObject</span>
<span class="s2">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">io</span><span class="s3">.</span><span class="s1">matlab</span><span class="s3">.</span><span class="s1">_byteordercodes </span><span class="s2">as </span><span class="s1">boc</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">io</span><span class="s3">.</span><span class="s1">matlab</span><span class="s3">.</span><span class="s1">_miobase </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">matdims</span><span class="s3">, </span><span class="s1">MatWriteError</span><span class="s3">, </span><span class="s1">MatReadError</span><span class="s3">, </span><span class="s1">matfile_version</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">io</span><span class="s3">.</span><span class="s1">matlab</span><span class="s3">.</span><span class="s1">_mio </span><span class="s2">import </span><span class="s1">mat_reader_factory</span><span class="s3">, </span><span class="s1">loadmat</span><span class="s3">, </span><span class="s1">savemat</span><span class="s3">, </span><span class="s1">whosmat</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">io</span><span class="s3">.</span><span class="s1">matlab</span><span class="s3">.</span><span class="s1">_mio5 </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">MatFile5Writer</span><span class="s3">, </span><span class="s1">MatFile5Reader</span><span class="s3">, </span><span class="s1">varmats_from_mat</span><span class="s3">, </span><span class="s1">to_writeable</span><span class="s3">,</span>
    <span class="s1">EmptyStructMarker</span><span class="s3">)</span>
<span class="s2">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">io</span><span class="s3">.</span><span class="s1">matlab</span><span class="s3">.</span><span class="s1">_mio5_params </span><span class="s2">as </span><span class="s1">mio5p</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">_lib</span><span class="s3">.</span><span class="s1">_util </span><span class="s2">import </span><span class="s1">VisibleDeprecationWarning</span>


<span class="s1">test_data_path </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">dirname</span><span class="s3">(</span><span class="s1">__file__</span><span class="s3">), </span><span class="s4">'data'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">mlarr</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Convenience function to return matlab-compatible 2-D array.&quot;&quot;&quot;</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
    <span class="s1">arr</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">= </span><span class="s1">matdims</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">arr</span>


<span class="s5"># Define cases to test</span>
<span class="s1">theta </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">/</span><span class="s6">4</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">9</span><span class="s3">,</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s6">1</span><span class="s3">,</span><span class="s6">9</span><span class="s3">)</span>
<span class="s1">case_table4 </span><span class="s3">= [</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'double'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'testdouble'</span><span class="s3">: </span><span class="s4">'double'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'testdouble'</span><span class="s3">: </span><span class="s1">theta</span><span class="s3">}</span>
     <span class="s3">}]</span>
<span class="s1">case_table4</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'string'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'teststring'</span><span class="s3">: </span><span class="s4">'char'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'teststring'</span><span class="s3">:</span>
                  <span class="s1">array</span><span class="s3">([</span><span class="s4">'&quot;Do nine men interpret?&quot; &quot;Nine men,&quot; I nod.'</span><span class="s3">])}</span>
     <span class="s3">})</span>
<span class="s1">case_table4</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'complex'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'testcomplex'</span><span class="s3">: </span><span class="s4">'double'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'testcomplex'</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">theta</span><span class="s3">) + </span><span class="s6">1j</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sin</span><span class="s3">(</span><span class="s1">theta</span><span class="s3">)}</span>
     <span class="s3">})</span>
<span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s6">3</span><span class="s3">,</span><span class="s6">5</span><span class="s3">))</span>
<span class="s1">A</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">list</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s6">1</span><span class="s3">,</span><span class="s6">6</span><span class="s3">))</span>
<span class="s1">A</span><span class="s3">[:,</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">list</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s6">1</span><span class="s3">,</span><span class="s6">4</span><span class="s3">))</span>
<span class="s1">case_table4</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'matrix'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'testmatrix'</span><span class="s3">: </span><span class="s4">'double'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'testmatrix'</span><span class="s3">: </span><span class="s1">A</span><span class="s3">},</span>
     <span class="s3">})</span>
<span class="s1">case_table4</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'sparse'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'testsparse'</span><span class="s3">: </span><span class="s4">'sparse'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'testsparse'</span><span class="s3">: </span><span class="s1">SP</span><span class="s3">.</span><span class="s1">coo_matrix</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)},</span>
     <span class="s3">})</span>
<span class="s1">B </span><span class="s3">= </span><span class="s1">A</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">complex</span><span class="s3">)</span>
<span class="s1">B</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">] += </span><span class="s6">1j</span>
<span class="s1">case_table4</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'sparsecomplex'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'testsparsecomplex'</span><span class="s3">: </span><span class="s4">'sparse'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'testsparsecomplex'</span><span class="s3">: </span><span class="s1">SP</span><span class="s3">.</span><span class="s1">coo_matrix</span><span class="s3">(</span><span class="s1">B</span><span class="s3">)},</span>
     <span class="s3">})</span>
<span class="s1">case_table4</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'multi'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'theta'</span><span class="s3">: </span><span class="s4">'double'</span><span class="s3">, </span><span class="s4">'a'</span><span class="s3">: </span><span class="s4">'double'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'theta'</span><span class="s3">: </span><span class="s1">theta</span><span class="s3">, </span><span class="s4">'a'</span><span class="s3">: </span><span class="s1">A</span><span class="s3">},</span>
     <span class="s3">})</span>
<span class="s1">case_table4</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'minus'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'testminus'</span><span class="s3">: </span><span class="s4">'double'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'testminus'</span><span class="s3">: </span><span class="s1">mlarr</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">)},</span>
     <span class="s3">})</span>
<span class="s1">case_table4</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'onechar'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'testonechar'</span><span class="s3">: </span><span class="s4">'char'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'testonechar'</span><span class="s3">: </span><span class="s1">array</span><span class="s3">([</span><span class="s4">'r'</span><span class="s3">])},</span>
     <span class="s3">})</span>
<span class="s5"># Cell arrays stored as object arrays</span>
<span class="s1">CA </span><span class="s3">= </span><span class="s1">mlarr</span><span class="s3">((  </span><span class="s5"># tuple for object array creation</span>
        <span class="s3">[],</span>
        <span class="s1">mlarr</span><span class="s3">([</span><span class="s6">1</span><span class="s3">]),</span>
        <span class="s1">mlarr</span><span class="s3">([[</span><span class="s6">1</span><span class="s3">,</span><span class="s6">2</span><span class="s3">]]),</span>
        <span class="s1">mlarr</span><span class="s3">([[</span><span class="s6">1</span><span class="s3">,</span><span class="s6">2</span><span class="s3">,</span><span class="s6">3</span><span class="s3">]])), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s6">1</span><span class="s3">,-</span><span class="s6">1</span><span class="s3">)</span>
<span class="s1">CA</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">array</span><span class="s3">(</span>
    <span class="s3">[</span><span class="s4">'This cell contains this string and 3 arrays of increasing length'</span><span class="s3">])</span>
<span class="s1">case_table5 </span><span class="s3">= [</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'cell'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'testcell'</span><span class="s3">: </span><span class="s4">'cell'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'testcell'</span><span class="s3">: </span><span class="s1">CA</span><span class="s3">}}]</span>
<span class="s1">CAE </span><span class="s3">= </span><span class="s1">mlarr</span><span class="s3">((  </span><span class="s5"># tuple for object array creation</span>
    <span class="s1">mlarr</span><span class="s3">(</span><span class="s6">1</span><span class="s3">),</span>
    <span class="s1">mlarr</span><span class="s3">(</span><span class="s6">2</span><span class="s3">),</span>
    <span class="s1">mlarr</span><span class="s3">([]),</span>
    <span class="s1">mlarr</span><span class="s3">([]),</span>
    <span class="s1">mlarr</span><span class="s3">(</span><span class="s6">3</span><span class="s3">)), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s6">1</span><span class="s3">,-</span><span class="s6">1</span><span class="s3">)</span>
<span class="s1">objarr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">),</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">)</span>
<span class="s1">objarr</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">mlarr</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span>
<span class="s1">case_table5</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'scalarcell'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'testscalarcell'</span><span class="s3">: </span><span class="s4">'cell'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'testscalarcell'</span><span class="s3">: </span><span class="s1">objarr</span><span class="s3">}</span>
     <span class="s3">})</span>
<span class="s1">case_table5</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'emptycell'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'testemptycell'</span><span class="s3">: </span><span class="s4">'cell'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'testemptycell'</span><span class="s3">: </span><span class="s1">CAE</span><span class="s3">}})</span>
<span class="s1">case_table5</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'stringarray'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'teststringarray'</span><span class="s3">: </span><span class="s4">'char'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'teststringarray'</span><span class="s3">: </span><span class="s1">array</span><span class="s3">(</span>
    <span class="s3">[</span><span class="s4">'one  '</span><span class="s3">, </span><span class="s4">'two  '</span><span class="s3">, </span><span class="s4">'three'</span><span class="s3">])},</span>
     <span class="s3">})</span>
<span class="s1">case_table5</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'3dmatrix'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'test3dmatrix'</span><span class="s3">: </span><span class="s4">'double'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span>
    <span class="s4">'test3dmatrix'</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">list</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s6">1</span><span class="s3">,</span><span class="s6">25</span><span class="s3">)), (</span><span class="s6">4</span><span class="s3">,</span><span class="s6">3</span><span class="s3">,</span><span class="s6">2</span><span class="s3">)))}</span>
     <span class="s3">})</span>
<span class="s1">st_sub_arr </span><span class="s3">= </span><span class="s1">array</span><span class="s3">([</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s6">2</span><span class="s3">),</span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s6">1</span><span class="s3">),</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">]).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s6">1</span><span class="s3">,</span><span class="s6">3</span><span class="s3">)</span>
<span class="s1">dtype </span><span class="s3">= [(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">object</span><span class="s3">) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'stringfield'</span><span class="s3">, </span><span class="s4">'doublefield'</span><span class="s3">, </span><span class="s4">'complexfield'</span><span class="s3">]]</span>
<span class="s1">st1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">)</span>
<span class="s1">st1</span><span class="s3">[</span><span class="s4">'stringfield'</span><span class="s3">][</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">array</span><span class="s3">([</span><span class="s4">'Rats live on no evil star.'</span><span class="s3">])</span>
<span class="s1">st1</span><span class="s3">[</span><span class="s4">'doublefield'</span><span class="s3">][</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">st_sub_arr</span>
<span class="s1">st1</span><span class="s3">[</span><span class="s4">'complexfield'</span><span class="s3">][</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">st_sub_arr </span><span class="s3">* (</span><span class="s6">1 </span><span class="s3">+ </span><span class="s6">1j</span><span class="s3">)</span>
<span class="s1">case_table5</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'struct'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'teststruct'</span><span class="s3">: </span><span class="s4">'struct'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'teststruct'</span><span class="s3">: </span><span class="s1">st1</span><span class="s3">}</span>
     <span class="s3">})</span>
<span class="s1">CN </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">2</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">)</span>
<span class="s1">CN</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">mlarr</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span>
<span class="s1">CN</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">1</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">3</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">)</span>
<span class="s1">CN</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">1</span><span class="s3">][</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">mlarr</span><span class="s3">(</span><span class="s6">2</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint8</span><span class="s3">)</span>
<span class="s1">CN</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">1</span><span class="s3">][</span><span class="s6">0</span><span class="s3">,</span><span class="s6">1</span><span class="s3">] = </span><span class="s1">mlarr</span><span class="s3">([[</span><span class="s6">3</span><span class="s3">]], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint8</span><span class="s3">)</span>
<span class="s1">CN</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">1</span><span class="s3">][</span><span class="s6">0</span><span class="s3">,</span><span class="s6">2</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">2</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">)</span>
<span class="s1">CN</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">1</span><span class="s3">][</span><span class="s6">0</span><span class="s3">,</span><span class="s6">2</span><span class="s3">][</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">mlarr</span><span class="s3">(</span><span class="s6">4</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint8</span><span class="s3">)</span>
<span class="s1">CN</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">1</span><span class="s3">][</span><span class="s6">0</span><span class="s3">,</span><span class="s6">2</span><span class="s3">][</span><span class="s6">0</span><span class="s3">,</span><span class="s6">1</span><span class="s3">] = </span><span class="s1">mlarr</span><span class="s3">(</span><span class="s6">5</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint8</span><span class="s3">)</span>
<span class="s1">case_table5</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'cellnest'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'testcellnest'</span><span class="s3">: </span><span class="s4">'cell'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'testcellnest'</span><span class="s3">: </span><span class="s1">CN</span><span class="s3">},</span>
     <span class="s3">})</span>
<span class="s1">st2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=[(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">object</span><span class="s3">) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'one'</span><span class="s3">, </span><span class="s4">'two'</span><span class="s3">]])</span>
<span class="s1">st2</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">][</span><span class="s4">'one'</span><span class="s3">] = </span><span class="s1">mlarr</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span>
<span class="s1">st2</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">][</span><span class="s4">'two'</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=[(</span><span class="s4">'three'</span><span class="s3">, </span><span class="s1">object</span><span class="s3">)])</span>
<span class="s1">st2</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">][</span><span class="s4">'two'</span><span class="s3">][</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">][</span><span class="s4">'three'</span><span class="s3">] = </span><span class="s1">array</span><span class="s3">([</span><span class="s4">'number 3'</span><span class="s3">])</span>
<span class="s1">case_table5</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'structnest'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'teststructnest'</span><span class="s3">: </span><span class="s4">'struct'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'teststructnest'</span><span class="s3">: </span><span class="s1">st2</span><span class="s3">}</span>
     <span class="s3">})</span>
<span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">2</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=[(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">object</span><span class="s3">) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'one'</span><span class="s3">, </span><span class="s4">'two'</span><span class="s3">]])</span>
<span class="s1">a</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">][</span><span class="s4">'one'</span><span class="s3">] = </span><span class="s1">mlarr</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span>
<span class="s1">a</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">][</span><span class="s4">'two'</span><span class="s3">] = </span><span class="s1">mlarr</span><span class="s3">(</span><span class="s6">2</span><span class="s3">)</span>
<span class="s1">a</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">1</span><span class="s3">][</span><span class="s4">'one'</span><span class="s3">] = </span><span class="s1">array</span><span class="s3">([</span><span class="s4">'number 1'</span><span class="s3">])</span>
<span class="s1">a</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">1</span><span class="s3">][</span><span class="s4">'two'</span><span class="s3">] = </span><span class="s1">array</span><span class="s3">([</span><span class="s4">'number 2'</span><span class="s3">])</span>
<span class="s1">case_table5</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'structarr'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'teststructarr'</span><span class="s3">: </span><span class="s4">'struct'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'teststructarr'</span><span class="s3">: </span><span class="s1">a</span><span class="s3">}</span>
     <span class="s3">})</span>
<span class="s1">ODT </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">([(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">object</span><span class="s3">) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in</span>
                 <span class="s3">[</span><span class="s4">'expr'</span><span class="s3">, </span><span class="s4">'inputExpr'</span><span class="s3">, </span><span class="s4">'args'</span><span class="s3">,</span>
                  <span class="s4">'isEmpty'</span><span class="s3">, </span><span class="s4">'numArgs'</span><span class="s3">, </span><span class="s4">'version'</span><span class="s3">]])</span>
<span class="s1">MO </span><span class="s3">= </span><span class="s1">MatlabObject</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">ODT</span><span class="s3">), </span><span class="s4">'inline'</span><span class="s3">)</span>
<span class="s1">m0 </span><span class="s3">= </span><span class="s1">MO</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">]</span>
<span class="s1">m0</span><span class="s3">[</span><span class="s4">'expr'</span><span class="s3">] = </span><span class="s1">array</span><span class="s3">([</span><span class="s4">'x'</span><span class="s3">])</span>
<span class="s1">m0</span><span class="s3">[</span><span class="s4">'inputExpr'</span><span class="s3">] = </span><span class="s1">array</span><span class="s3">([</span><span class="s4">' x = INLINE_INPUTS_{1};'</span><span class="s3">])</span>
<span class="s1">m0</span><span class="s3">[</span><span class="s4">'args'</span><span class="s3">] = </span><span class="s1">array</span><span class="s3">([</span><span class="s4">'x'</span><span class="s3">])</span>
<span class="s1">m0</span><span class="s3">[</span><span class="s4">'isEmpty'</span><span class="s3">] = </span><span class="s1">mlarr</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
<span class="s1">m0</span><span class="s3">[</span><span class="s4">'numArgs'</span><span class="s3">] = </span><span class="s1">mlarr</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span>
<span class="s1">m0</span><span class="s3">[</span><span class="s4">'version'</span><span class="s3">] = </span><span class="s1">mlarr</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span>
<span class="s1">case_table5</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'object'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'testobject'</span><span class="s3">: </span><span class="s4">'object'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'testobject'</span><span class="s3">: </span><span class="s1">MO</span><span class="s3">}</span>
     <span class="s3">})</span>
<span class="s1">fp_u_str </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'japanese_utf8.txt'</span><span class="s3">), </span><span class="s4">'rb'</span><span class="s3">)</span>
<span class="s1">u_str </span><span class="s3">= </span><span class="s1">fp_u_str</span><span class="s3">.</span><span class="s1">read</span><span class="s3">().</span><span class="s1">decode</span><span class="s3">(</span><span class="s4">'utf-8'</span><span class="s3">)</span>
<span class="s1">fp_u_str</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
<span class="s1">case_table5</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'unicode'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'testunicode'</span><span class="s3">: </span><span class="s4">'char'</span><span class="s3">},</span>
    <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'testunicode'</span><span class="s3">: </span><span class="s1">array</span><span class="s3">([</span><span class="s1">u_str</span><span class="s3">])}</span>
     <span class="s3">})</span>
<span class="s1">case_table5</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'sparse'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'testsparse'</span><span class="s3">: </span><span class="s4">'sparse'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'testsparse'</span><span class="s3">: </span><span class="s1">SP</span><span class="s3">.</span><span class="s1">coo_matrix</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)},</span>
     <span class="s3">})</span>
<span class="s1">case_table5</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'sparsecomplex'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'testsparsecomplex'</span><span class="s3">: </span><span class="s4">'sparse'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'testsparsecomplex'</span><span class="s3">: </span><span class="s1">SP</span><span class="s3">.</span><span class="s1">coo_matrix</span><span class="s3">(</span><span class="s1">B</span><span class="s3">)},</span>
     <span class="s3">})</span>
<span class="s1">case_table5</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'bool'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'testbools'</span><span class="s3">: </span><span class="s4">'logical'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'testbools'</span><span class="s3">:</span>
                  <span class="s1">array</span><span class="s3">([[</span><span class="s2">True</span><span class="s3">], [</span><span class="s2">False</span><span class="s3">]])},</span>
     <span class="s3">})</span>

<span class="s1">case_table5_rt </span><span class="s3">= </span><span class="s1">case_table5</span><span class="s3">[:]</span>
<span class="s5"># Inline functions can't be concatenated in matlab, so RT only</span>
<span class="s1">case_table5_rt</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
    <span class="s3">{</span><span class="s4">'name'</span><span class="s3">: </span><span class="s4">'objectarray'</span><span class="s3">,</span>
     <span class="s4">'classes'</span><span class="s3">: {</span><span class="s4">'testobjectarray'</span><span class="s3">: </span><span class="s4">'object'</span><span class="s3">},</span>
     <span class="s4">'expected'</span><span class="s3">: {</span><span class="s4">'testobjectarray'</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">repeat</span><span class="s3">(</span><span class="s1">MO</span><span class="s3">, </span><span class="s6">2</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s6">1</span><span class="s3">,</span><span class="s6">2</span><span class="s3">)}})</span>


<span class="s2">def </span><span class="s1">types_compatible</span><span class="s3">(</span><span class="s1">var1</span><span class="s3">, </span><span class="s1">var2</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check if types are same or compatible. 
 
    0-D numpy scalars are compatible with bare python scalars. 
    &quot;&quot;&quot;</span>
    <span class="s1">type1 </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s1">var1</span><span class="s3">)</span>
    <span class="s1">type2 </span><span class="s3">= </span><span class="s1">type</span><span class="s3">(</span><span class="s1">var2</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">type1 </span><span class="s2">is </span><span class="s1">type2</span><span class="s3">:</span>
        <span class="s2">return True</span>
    <span class="s2">if </span><span class="s1">type1 </span><span class="s2">is </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray </span><span class="s2">and </span><span class="s1">var1</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== ():</span>
        <span class="s2">return </span><span class="s1">type</span><span class="s3">(</span><span class="s1">var1</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()) </span><span class="s2">is </span><span class="s1">type2</span>
    <span class="s2">if </span><span class="s1">type2 </span><span class="s2">is </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray </span><span class="s2">and </span><span class="s1">var2</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== ():</span>
        <span class="s2">return </span><span class="s1">type</span><span class="s3">(</span><span class="s1">var2</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()) </span><span class="s2">is </span><span class="s1">type1</span>
    <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">_check_level</span><span class="s3">(</span><span class="s1">label</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">, </span><span class="s1">actual</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; Check one level of a potentially nested array &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">SP</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">):  </span><span class="s5"># allow different types of sparse matrices</span>
        <span class="s1">assert_</span><span class="s3">(</span><span class="s1">SP</span><span class="s3">.</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">actual</span><span class="s3">))</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">actual</span><span class="s3">.</span><span class="s1">toarray</span><span class="s3">(),</span>
                                  <span class="s1">expected</span><span class="s3">.</span><span class="s1">toarray</span><span class="s3">(),</span>
                                  <span class="s1">err_msg</span><span class="s3">=</span><span class="s1">label</span><span class="s3">,</span>
                                  <span class="s1">decimal</span><span class="s3">=</span><span class="s6">5</span><span class="s3">)</span>
        <span class="s2">return</span>
    <span class="s5"># Check types are as expected</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">types_compatible</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">, </span><span class="s1">actual</span><span class="s3">),</span>
            <span class="s4">f&quot;Expected type </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">)</span><span class="s2">}</span><span class="s4">, got </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">actual</span><span class="s3">)</span><span class="s2">} </span><span class="s4">at </span><span class="s2">{</span><span class="s1">label</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>
    <span class="s5"># A field in a record array may not be an ndarray</span>
    <span class="s5"># A scalar from a record array will be type np.void</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">,</span>
                      <span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">void</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">, </span><span class="s1">MatlabObject</span><span class="s3">)):</span>
        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">, </span><span class="s1">actual</span><span class="s3">)</span>
        <span class="s2">return</span>
    <span class="s5"># This is an ndarray-like thing</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== </span><span class="s1">actual</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
            <span class="s1">msg</span><span class="s3">=</span><span class="s4">f'Expected shape </span><span class="s2">{</span><span class="s1">expected</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">, got </span><span class="s2">{</span><span class="s1">actual</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">} </span><span class="s4">at </span><span class="s2">{</span><span class="s1">label</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
    <span class="s1">ex_dtype </span><span class="s3">= </span><span class="s1">expected</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s2">if </span><span class="s1">ex_dtype</span><span class="s3">.</span><span class="s1">hasobject</span><span class="s3">:  </span><span class="s5"># array of objects</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">, </span><span class="s1">MatlabObject</span><span class="s3">):</span>
            <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">.</span><span class="s1">classname</span><span class="s3">, </span><span class="s1">actual</span><span class="s3">.</span><span class="s1">classname</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">ev </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">expected</span><span class="s3">):</span>
            <span class="s1">level_label </span><span class="s3">= </span><span class="s4">&quot;%s, [%d], &quot; </span><span class="s3">% (</span><span class="s1">label</span><span class="s3">, </span><span class="s1">i</span><span class="s3">)</span>
            <span class="s1">_check_level</span><span class="s3">(</span><span class="s1">level_label</span><span class="s3">, </span><span class="s1">ev</span><span class="s3">, </span><span class="s1">actual</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
        <span class="s2">return</span>
    <span class="s2">if </span><span class="s1">ex_dtype</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">:  </span><span class="s5"># probably recarray</span>
        <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">ex_dtype</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">:</span>
            <span class="s1">level_label </span><span class="s3">= </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">label</span><span class="s2">}</span><span class="s4">, field </span><span class="s2">{</span><span class="s1">fn</span><span class="s2">}</span><span class="s4">, &quot;</span>
            <span class="s1">_check_level</span><span class="s3">(</span><span class="s1">level_label</span><span class="s3">,</span>
                         <span class="s1">expected</span><span class="s3">[</span><span class="s1">fn</span><span class="s3">], </span><span class="s1">actual</span><span class="s3">[</span><span class="s1">fn</span><span class="s3">])</span>
        <span class="s2">return</span>
    <span class="s2">if </span><span class="s1">ex_dtype</span><span class="s3">.</span><span class="s1">type </span><span class="s2">in </span><span class="s3">(</span><span class="s1">str</span><span class="s3">,  </span><span class="s5"># string or bool</span>
                         <span class="s1">np</span><span class="s3">.</span><span class="s1">str_</span><span class="s3">,</span>
                         <span class="s1">np</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">):</span>
        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">actual</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">label</span><span class="s3">)</span>
        <span class="s2">return</span>
    <span class="s5"># Something numeric</span>
    <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">actual</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">label</span><span class="s3">, </span><span class="s1">decimal</span><span class="s3">=</span><span class="s6">5</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_load_check_case</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">files</span><span class="s3">, </span><span class="s1">case</span><span class="s3">):</span>
    <span class="s2">for </span><span class="s1">file_name </span><span class="s2">in </span><span class="s1">files</span><span class="s3">:</span>
        <span class="s1">matdict </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">file_name</span><span class="s3">, </span><span class="s1">struct_as_record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">label </span><span class="s3">= </span><span class="s4">f&quot;test </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">; file </span><span class="s2">{</span><span class="s1">file_name</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">expected </span><span class="s2">in </span><span class="s1">case</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">k_label </span><span class="s3">= </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">label</span><span class="s2">}</span><span class="s4">, variable </span><span class="s2">{</span><span class="s1">k</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s1">assert_</span><span class="s3">(</span><span class="s1">k </span><span class="s2">in </span><span class="s1">matdict</span><span class="s3">, </span><span class="s4">&quot;Missing key at %s&quot; </span><span class="s3">% </span><span class="s1">k_label</span><span class="s3">)</span>
            <span class="s1">_check_level</span><span class="s3">(</span><span class="s1">k_label</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">, </span><span class="s1">matdict</span><span class="s3">[</span><span class="s1">k</span><span class="s3">])</span>


<span class="s2">def </span><span class="s1">_whos_check_case</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">files</span><span class="s3">, </span><span class="s1">case</span><span class="s3">, </span><span class="s1">classes</span><span class="s3">):</span>
    <span class="s2">for </span><span class="s1">file_name </span><span class="s2">in </span><span class="s1">files</span><span class="s3">:</span>
        <span class="s1">label </span><span class="s3">= </span><span class="s4">f&quot;test </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">; file </span><span class="s2">{</span><span class="s1">file_name</span><span class="s2">}</span><span class="s4">&quot;</span>

        <span class="s1">whos </span><span class="s3">= </span><span class="s1">whosmat</span><span class="s3">(</span><span class="s1">file_name</span><span class="s3">)</span>

        <span class="s1">expected_whos </span><span class="s3">= [</span>
            <span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">classes</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]) </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">expected </span><span class="s2">in </span><span class="s1">case</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()]</span>

        <span class="s1">whos</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">()</span>
        <span class="s1">expected_whos</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">()</span>
        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">whos</span><span class="s3">, </span><span class="s1">expected_whos</span><span class="s3">,</span>
                     <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">label</span><span class="s2">}</span><span class="s4">: </span><span class="s2">{</span><span class="s1">whos</span><span class="s2">!r} </span><span class="s4">!= </span><span class="s2">{</span><span class="s1">expected_whos</span><span class="s2">!r}</span><span class="s4">&quot;</span>
                     <span class="s3">)</span>


<span class="s5"># Round trip tests</span>
<span class="s2">def </span><span class="s1">_rt_check_case</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">, </span><span class="s1">format</span><span class="s3">):</span>
    <span class="s1">mat_stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">mat_stream</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">, </span><span class="s1">format</span><span class="s3">=</span><span class="s1">format</span><span class="s3">)</span>
    <span class="s1">mat_stream</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">_load_check_case</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, [</span><span class="s1">mat_stream</span><span class="s3">], </span><span class="s1">expected</span><span class="s3">)</span>


<span class="s5"># generator for tests</span>
<span class="s2">def </span><span class="s1">_cases</span><span class="s3">(</span><span class="s1">version</span><span class="s3">, </span><span class="s1">filt</span><span class="s3">=</span><span class="s4">'test%(name)s_*.mat'</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">version </span><span class="s3">== </span><span class="s4">'4'</span><span class="s3">:</span>
        <span class="s1">cases </span><span class="s3">= </span><span class="s1">case_table4</span>
    <span class="s2">elif </span><span class="s1">version </span><span class="s3">== </span><span class="s4">'5'</span><span class="s3">:</span>
        <span class="s1">cases </span><span class="s3">= </span><span class="s1">case_table5</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">version </span><span class="s3">== </span><span class="s4">'5_rt'</span>
        <span class="s1">cases </span><span class="s3">= </span><span class="s1">case_table5_rt</span>
    <span class="s2">for </span><span class="s1">case </span><span class="s2">in </span><span class="s1">cases</span><span class="s3">:</span>
        <span class="s1">name </span><span class="s3">= </span><span class="s1">case</span><span class="s3">[</span><span class="s4">'name'</span><span class="s3">]</span>
        <span class="s1">expected </span><span class="s3">= </span><span class="s1">case</span><span class="s3">[</span><span class="s4">'expected'</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">filt </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">files </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">use_filt </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s1">filt </span><span class="s3">% </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">))</span>
            <span class="s1">files </span><span class="s3">= </span><span class="s1">glob</span><span class="s3">(</span><span class="s1">use_filt</span><span class="s3">)</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">files</span><span class="s3">) &gt; </span><span class="s6">0</span><span class="s3">, </span><span class="s1">\</span>
                <span class="s4">f&quot;No files for test </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">using filter </span><span class="s2">{</span><span class="s1">filt</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s1">classes </span><span class="s3">= </span><span class="s1">case</span><span class="s3">[</span><span class="s4">'classes'</span><span class="s3">]</span>
        <span class="s2">yield </span><span class="s1">name</span><span class="s3">, </span><span class="s1">files</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">, </span><span class="s1">classes</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">'version'</span><span class="s3">, (</span><span class="s4">'4'</span><span class="s3">, </span><span class="s4">'5'</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">test_load</span><span class="s3">(</span><span class="s1">version</span><span class="s3">):</span>
    <span class="s2">for </span><span class="s1">case </span><span class="s2">in </span><span class="s1">_cases</span><span class="s3">(</span><span class="s1">version</span><span class="s3">):</span>
        <span class="s1">_load_check_case</span><span class="s3">(*</span><span class="s1">case</span><span class="s3">[:</span><span class="s6">3</span><span class="s3">])</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">'version'</span><span class="s3">, (</span><span class="s4">'4'</span><span class="s3">, </span><span class="s4">'5'</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">test_whos</span><span class="s3">(</span><span class="s1">version</span><span class="s3">):</span>
    <span class="s2">for </span><span class="s1">case </span><span class="s2">in </span><span class="s1">_cases</span><span class="s3">(</span><span class="s1">version</span><span class="s3">):</span>
        <span class="s1">_whos_check_case</span><span class="s3">(*</span><span class="s1">case</span><span class="s3">)</span>


<span class="s5"># generator for round trip tests</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">'version, fmts'</span><span class="s3">, [</span>
    <span class="s3">(</span><span class="s4">'4'</span><span class="s3">, [</span><span class="s4">'4'</span><span class="s3">, </span><span class="s4">'5'</span><span class="s3">]),</span>
    <span class="s3">(</span><span class="s4">'5_rt'</span><span class="s3">, [</span><span class="s4">'5'</span><span class="s3">]),</span>
<span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_round_trip</span><span class="s3">(</span><span class="s1">version</span><span class="s3">, </span><span class="s1">fmts</span><span class="s3">):</span>
    <span class="s2">for </span><span class="s1">case </span><span class="s2">in </span><span class="s1">_cases</span><span class="s3">(</span><span class="s1">version</span><span class="s3">, </span><span class="s1">filt</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">fmt </span><span class="s2">in </span><span class="s1">fmts</span><span class="s3">:</span>
            <span class="s1">_rt_check_case</span><span class="s3">(</span><span class="s1">case</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">case</span><span class="s3">[</span><span class="s6">2</span><span class="s3">], </span><span class="s1">fmt</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_gzip_simple</span><span class="s3">():</span>
    <span class="s1">xdense </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s6">20</span><span class="s3">,</span><span class="s6">20</span><span class="s3">))</span>
    <span class="s1">xdense</span><span class="s3">[</span><span class="s6">2</span><span class="s3">,</span><span class="s6">3</span><span class="s3">] = </span><span class="s6">2.3</span>
    <span class="s1">xdense</span><span class="s3">[</span><span class="s6">4</span><span class="s3">,</span><span class="s6">5</span><span class="s3">] = </span><span class="s6">4.5</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">SP</span><span class="s3">.</span><span class="s1">csc_matrix</span><span class="s3">(</span><span class="s1">xdense</span><span class="s3">)</span>

    <span class="s1">name </span><span class="s3">= </span><span class="s4">'gzip_test'</span>
    <span class="s1">expected </span><span class="s3">= {</span><span class="s4">'x'</span><span class="s3">:</span><span class="s1">x</span><span class="s3">}</span>
    <span class="s1">format </span><span class="s3">= </span><span class="s4">'4'</span>

    <span class="s1">tmpdir </span><span class="s3">= </span><span class="s1">mkdtemp</span><span class="s3">()</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">fname </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">tmpdir</span><span class="s3">,</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s1">mat_stream </span><span class="s3">= </span><span class="s1">gzip</span><span class="s3">.</span><span class="s1">open</span><span class="s3">(</span><span class="s1">fname</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'wb'</span><span class="s3">)</span>
        <span class="s1">savemat</span><span class="s3">(</span><span class="s1">mat_stream</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">, </span><span class="s1">format</span><span class="s3">=</span><span class="s1">format</span><span class="s3">)</span>
        <span class="s1">mat_stream</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>

        <span class="s1">mat_stream </span><span class="s3">= </span><span class="s1">gzip</span><span class="s3">.</span><span class="s1">open</span><span class="s3">(</span><span class="s1">fname</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'rb'</span><span class="s3">)</span>
        <span class="s1">actual </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">mat_stream</span><span class="s3">, </span><span class="s1">struct_as_record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">mat_stream</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
    <span class="s2">finally</span><span class="s3">:</span>
        <span class="s1">shutil</span><span class="s3">.</span><span class="s1">rmtree</span><span class="s3">(</span><span class="s1">tmpdir</span><span class="s3">)</span>

    <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">actual</span><span class="s3">[</span><span class="s4">'x'</span><span class="s3">].</span><span class="s1">toarray</span><span class="s3">(),</span>
                              <span class="s1">expected</span><span class="s3">[</span><span class="s4">'x'</span><span class="s3">].</span><span class="s1">toarray</span><span class="s3">(),</span>
                              <span class="s1">err_msg</span><span class="s3">=</span><span class="s1">repr</span><span class="s3">(</span><span class="s1">actual</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_multiple_open</span><span class="s3">():</span>
    <span class="s5"># Ticket #1039, on Windows: check that files are not left open</span>
    <span class="s1">tmpdir </span><span class="s3">= </span><span class="s1">mkdtemp</span><span class="s3">()</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">x</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s6">2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">)))</span>

        <span class="s1">fname </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">tmpdir</span><span class="s3">, </span><span class="s4">&quot;a.mat&quot;</span><span class="s3">)</span>

        <span class="s5"># Check that file is not left open</span>
        <span class="s1">savemat</span><span class="s3">(</span><span class="s1">fname</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">os</span><span class="s3">.</span><span class="s1">unlink</span><span class="s3">(</span><span class="s1">fname</span><span class="s3">)</span>
        <span class="s1">savemat</span><span class="s3">(</span><span class="s1">fname</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">loadmat</span><span class="s3">(</span><span class="s1">fname</span><span class="s3">)</span>
        <span class="s1">os</span><span class="s3">.</span><span class="s1">unlink</span><span class="s3">(</span><span class="s1">fname</span><span class="s3">)</span>

        <span class="s5"># Check that stream is left open</span>
        <span class="s1">f </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">fname</span><span class="s3">, </span><span class="s4">'wb'</span><span class="s3">)</span>
        <span class="s1">savemat</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">f</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">f</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>

        <span class="s1">f </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">fname</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s3">)</span>
        <span class="s1">loadmat</span><span class="s3">(</span><span class="s1">f</span><span class="s3">)</span>
        <span class="s1">f</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">f</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
    <span class="s2">finally</span><span class="s3">:</span>
        <span class="s1">shutil</span><span class="s3">.</span><span class="s1">rmtree</span><span class="s3">(</span><span class="s1">tmpdir</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_mat73</span><span class="s3">():</span>
    <span class="s5"># Check any hdf5 files raise an error</span>
    <span class="s1">filenames </span><span class="s3">= </span><span class="s1">glob</span><span class="s3">(</span>
        <span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'testhdf5*.mat'</span><span class="s3">))</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">filenames</span><span class="s3">) &gt; </span><span class="s6">0</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">filenames</span><span class="s3">:</span>
        <span class="s1">fp </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s3">)</span>
        <span class="s1">assert_raises</span><span class="s3">(</span><span class="s1">NotImplementedError</span><span class="s3">,</span>
                      <span class="s1">loadmat</span><span class="s3">,</span>
                      <span class="s1">fp</span><span class="s3">,</span>
                      <span class="s1">struct_as_record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">fp</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">test_warnings</span><span class="s3">():</span>
    <span class="s5"># This test is an echo of the previous behavior, which was to raise a</span>
    <span class="s5"># warning if the user triggered a search for mat files on the Python system</span>
    <span class="s5"># path. We can remove the test in the next version after upcoming (0.13).</span>
    <span class="s1">fname </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'testdouble_7.1_GLNX86.mat'</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">():</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">simplefilter</span><span class="s3">(</span><span class="s4">'error'</span><span class="s3">)</span>
        <span class="s5"># This should not generate a warning</span>
        <span class="s1">loadmat</span><span class="s3">(</span><span class="s1">fname</span><span class="s3">, </span><span class="s1">struct_as_record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s5"># This neither</span>
        <span class="s1">loadmat</span><span class="s3">(</span><span class="s1">fname</span><span class="s3">, </span><span class="s1">struct_as_record</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_regression_653</span><span class="s3">():</span>
    <span class="s5"># Saving a dictionary with only invalid keys used to raise an error. Now we</span>
    <span class="s5"># save this as an empty struct in matlab space.</span>
    <span class="s1">sio </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">sio</span><span class="s3">, {</span><span class="s4">'d'</span><span class="s3">:{</span><span class="s6">1</span><span class="s3">:</span><span class="s6">2</span><span class="s3">}}, </span><span class="s1">format</span><span class="s3">=</span><span class="s4">'5'</span><span class="s3">)</span>
    <span class="s1">back </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">sio</span><span class="s3">)[</span><span class="s4">'d'</span><span class="s3">]</span>
    <span class="s5"># Check we got an empty struct equivalent</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">back</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, (</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">))</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">back</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">object</span><span class="s3">))</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">back</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">] </span><span class="s2">is None</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_structname_len</span><span class="s3">():</span>
    <span class="s5"># Test limit for length of field names in structs</span>
    <span class="s1">lim </span><span class="s3">= </span><span class="s6">31</span>
    <span class="s1">fldname </span><span class="s3">= </span><span class="s4">'a' </span><span class="s3">* </span><span class="s1">lim</span>
    <span class="s1">st1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=[(</span><span class="s1">fldname</span><span class="s3">, </span><span class="s1">object</span><span class="s3">)])</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">BytesIO</span><span class="s3">(), {</span><span class="s4">'longstruct'</span><span class="s3">: </span><span class="s1">st1</span><span class="s3">}, </span><span class="s1">format</span><span class="s3">=</span><span class="s4">'5'</span><span class="s3">)</span>
    <span class="s1">fldname </span><span class="s3">= </span><span class="s4">'a' </span><span class="s3">* (</span><span class="s1">lim</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">st1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=[(</span><span class="s1">fldname</span><span class="s3">, </span><span class="s1">object</span><span class="s3">)])</span>
    <span class="s1">assert_raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">savemat</span><span class="s3">, </span><span class="s1">BytesIO</span><span class="s3">(),</span>
                  <span class="s3">{</span><span class="s4">'longstruct'</span><span class="s3">: </span><span class="s1">st1</span><span class="s3">}, </span><span class="s1">format</span><span class="s3">=</span><span class="s4">'5'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_4_and_long_field_names_incompatible</span><span class="s3">():</span>
    <span class="s5"># Long field names option not supported in 4</span>
    <span class="s1">my_struct </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">),</span><span class="s1">dtype</span><span class="s3">=[(</span><span class="s4">'my_fieldname'</span><span class="s3">,</span><span class="s1">object</span><span class="s3">)])</span>
    <span class="s1">assert_raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">savemat</span><span class="s3">, </span><span class="s1">BytesIO</span><span class="s3">(),</span>
                  <span class="s3">{</span><span class="s4">'my_struct'</span><span class="s3">:</span><span class="s1">my_struct</span><span class="s3">}, </span><span class="s1">format</span><span class="s3">=</span><span class="s4">'4'</span><span class="s3">, </span><span class="s1">long_field_names</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_long_field_names</span><span class="s3">():</span>
    <span class="s5"># Test limit for length of field names in structs</span>
    <span class="s1">lim </span><span class="s3">= </span><span class="s6">63</span>
    <span class="s1">fldname </span><span class="s3">= </span><span class="s4">'a' </span><span class="s3">* </span><span class="s1">lim</span>
    <span class="s1">st1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=[(</span><span class="s1">fldname</span><span class="s3">, </span><span class="s1">object</span><span class="s3">)])</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">BytesIO</span><span class="s3">(), {</span><span class="s4">'longstruct'</span><span class="s3">: </span><span class="s1">st1</span><span class="s3">}, </span><span class="s1">format</span><span class="s3">=</span><span class="s4">'5'</span><span class="s3">,</span><span class="s1">long_field_names</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">fldname </span><span class="s3">= </span><span class="s4">'a' </span><span class="s3">* (</span><span class="s1">lim</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">st1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=[(</span><span class="s1">fldname</span><span class="s3">, </span><span class="s1">object</span><span class="s3">)])</span>
    <span class="s1">assert_raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">savemat</span><span class="s3">, </span><span class="s1">BytesIO</span><span class="s3">(),</span>
                  <span class="s3">{</span><span class="s4">'longstruct'</span><span class="s3">: </span><span class="s1">st1</span><span class="s3">}, </span><span class="s1">format</span><span class="s3">=</span><span class="s4">'5'</span><span class="s3">,</span><span class="s1">long_field_names</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_long_field_names_in_struct</span><span class="s3">():</span>
    <span class="s5"># Regression test - long_field_names was erased if you passed a struct</span>
    <span class="s5"># within a struct</span>
    <span class="s1">lim </span><span class="s3">= </span><span class="s6">63</span>
    <span class="s1">fldname </span><span class="s3">= </span><span class="s4">'a' </span><span class="s3">* </span><span class="s1">lim</span>
    <span class="s1">cell </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">2</span><span class="s3">),</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">)</span>
    <span class="s1">st1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=[(</span><span class="s1">fldname</span><span class="s3">, </span><span class="s1">object</span><span class="s3">)])</span>
    <span class="s1">cell</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">st1</span>
    <span class="s1">cell</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">1</span><span class="s3">] = </span><span class="s1">st1</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">BytesIO</span><span class="s3">(), {</span><span class="s4">'longstruct'</span><span class="s3">: </span><span class="s1">cell</span><span class="s3">}, </span><span class="s1">format</span><span class="s3">=</span><span class="s4">'5'</span><span class="s3">,</span><span class="s1">long_field_names</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s5">#</span>
    <span class="s5"># Check to make sure it fails with long field names off</span>
    <span class="s5">#</span>
    <span class="s1">assert_raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">savemat</span><span class="s3">, </span><span class="s1">BytesIO</span><span class="s3">(),</span>
                  <span class="s3">{</span><span class="s4">'longstruct'</span><span class="s3">: </span><span class="s1">cell</span><span class="s3">}, </span><span class="s1">format</span><span class="s3">=</span><span class="s4">'5'</span><span class="s3">, </span><span class="s1">long_field_names</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_cell_with_one_thing_in_it</span><span class="s3">():</span>
    <span class="s5"># Regression test - make a cell array that's 1 x 2 and put two</span>
    <span class="s5"># strings in it. It works. Make a cell array that's 1 x 1 and put</span>
    <span class="s5"># a string in it. It should work but, in the old days, it didn't.</span>
    <span class="s1">cells </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">2</span><span class="s3">),</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">)</span>
    <span class="s1">cells</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">] = </span><span class="s4">'Hello'</span>
    <span class="s1">cells</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">1</span><span class="s3">] = </span><span class="s4">'World'</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">BytesIO</span><span class="s3">(), {</span><span class="s4">'x'</span><span class="s3">: </span><span class="s1">cells</span><span class="s3">}, </span><span class="s1">format</span><span class="s3">=</span><span class="s4">'5'</span><span class="s3">)</span>

    <span class="s1">cells </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">((</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">),</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">)</span>
    <span class="s1">cells</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">] = </span><span class="s4">'Hello, world'</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">BytesIO</span><span class="s3">(), {</span><span class="s4">'x'</span><span class="s3">: </span><span class="s1">cells</span><span class="s3">}, </span><span class="s1">format</span><span class="s3">=</span><span class="s4">'5'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_writer_properties</span><span class="s3">():</span>
    <span class="s5"># Tests getting, setting of properties of matrix writer</span>
    <span class="s1">mfw </span><span class="s3">= </span><span class="s1">MatFile5Writer</span><span class="s3">(</span><span class="s1">BytesIO</span><span class="s3">())</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">mfw</span><span class="s3">.</span><span class="s1">global_vars</span><span class="s3">, [])</span>
    <span class="s1">mfw</span><span class="s3">.</span><span class="s1">global_vars </span><span class="s3">= [</span><span class="s4">'avar'</span><span class="s3">]</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">mfw</span><span class="s3">.</span><span class="s1">global_vars</span><span class="s3">, [</span><span class="s4">'avar'</span><span class="s3">])</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">mfw</span><span class="s3">.</span><span class="s1">unicode_strings</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">mfw</span><span class="s3">.</span><span class="s1">unicode_strings </span><span class="s3">= </span><span class="s2">True</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">mfw</span><span class="s3">.</span><span class="s1">unicode_strings</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">mfw</span><span class="s3">.</span><span class="s1">long_field_names</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">mfw</span><span class="s3">.</span><span class="s1">long_field_names </span><span class="s3">= </span><span class="s2">True</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">mfw</span><span class="s3">.</span><span class="s1">long_field_names</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_use_small_element</span><span class="s3">():</span>
    <span class="s5"># Test whether we're using small data element or not</span>
    <span class="s1">sio </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">wtr </span><span class="s3">= </span><span class="s1">MatFile5Writer</span><span class="s3">(</span><span class="s1">sio</span><span class="s3">)</span>
    <span class="s5"># First check size for no sde for name</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s6">10</span><span class="s3">)</span>
    <span class="s1">wtr</span><span class="s3">.</span><span class="s1">put_variables</span><span class="s3">({</span><span class="s4">'aaaaa'</span><span class="s3">: </span><span class="s1">arr</span><span class="s3">})</span>
    <span class="s1">w_sz </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">sio</span><span class="s3">.</span><span class="s1">getvalue</span><span class="s3">())</span>
    <span class="s5"># Check small name results in largish difference in size</span>
    <span class="s1">sio</span><span class="s3">.</span><span class="s1">truncate</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">sio</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">wtr</span><span class="s3">.</span><span class="s1">put_variables</span><span class="s3">({</span><span class="s4">'aaaa'</span><span class="s3">: </span><span class="s1">arr</span><span class="s3">})</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">w_sz </span><span class="s3">- </span><span class="s1">len</span><span class="s3">(</span><span class="s1">sio</span><span class="s3">.</span><span class="s1">getvalue</span><span class="s3">()) &gt; </span><span class="s6">4</span><span class="s3">)</span>
    <span class="s5"># Whereas increasing name size makes less difference</span>
    <span class="s1">sio</span><span class="s3">.</span><span class="s1">truncate</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">sio</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">wtr</span><span class="s3">.</span><span class="s1">put_variables</span><span class="s3">({</span><span class="s4">'aaaaaa'</span><span class="s3">: </span><span class="s1">arr</span><span class="s3">})</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">sio</span><span class="s3">.</span><span class="s1">getvalue</span><span class="s3">()) - </span><span class="s1">w_sz </span><span class="s3">&lt; </span><span class="s6">4</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_save_dict</span><span class="s3">():</span>
    <span class="s5"># Test that both dict and OrderedDict can be saved (as recarray),</span>
    <span class="s5"># loaded as matstruct, and preserve order</span>
    <span class="s1">ab_exp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[(</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">)]], </span><span class="s1">dtype</span><span class="s3">=[(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s1">object</span><span class="s3">), (</span><span class="s4">'b'</span><span class="s3">, </span><span class="s1">object</span><span class="s3">)])</span>
    <span class="s2">for </span><span class="s1">dict_type </span><span class="s2">in </span><span class="s3">(</span><span class="s1">dict</span><span class="s3">, </span><span class="s1">OrderedDict</span><span class="s3">):</span>
        <span class="s5"># Initialize with tuples to keep order</span>
        <span class="s1">d </span><span class="s3">= </span><span class="s1">dict_type</span><span class="s3">([(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s6">1</span><span class="s3">), (</span><span class="s4">'b'</span><span class="s3">, </span><span class="s6">2</span><span class="s3">)])</span>
        <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
        <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'dict'</span><span class="s3">: </span><span class="s1">d</span><span class="s3">})</span>
        <span class="s1">stream</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">vals </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)[</span><span class="s4">'dict'</span><span class="s3">]</span>
        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">names</span><span class="s3">, (</span><span class="s4">'a'</span><span class="s3">, </span><span class="s4">'b'</span><span class="s3">))</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">, </span><span class="s1">ab_exp</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_1d_shape</span><span class="s3">():</span>
    <span class="s5"># New 5 behavior is 1D -&gt; row vector</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">5</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">format </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'4'</span><span class="s3">, </span><span class="s4">'5'</span><span class="s3">):</span>
        <span class="s5"># Column is the default</span>
        <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
        <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'oned'</span><span class="s3">: </span><span class="s1">arr</span><span class="s3">}, </span><span class="s1">format</span><span class="s3">=</span><span class="s1">format</span><span class="s3">)</span>
        <span class="s1">vals </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">[</span><span class="s4">'oned'</span><span class="s3">].</span><span class="s1">shape</span><span class="s3">, (</span><span class="s6">1</span><span class="s3">, </span><span class="s6">5</span><span class="s3">))</span>
        <span class="s5"># can be explicitly 'column' for oned_as</span>
        <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
        <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'oned'</span><span class="s3">:</span><span class="s1">arr</span><span class="s3">},</span>
                <span class="s1">format</span><span class="s3">=</span><span class="s1">format</span><span class="s3">,</span>
                <span class="s1">oned_as</span><span class="s3">=</span><span class="s4">'column'</span><span class="s3">)</span>
        <span class="s1">vals </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">[</span><span class="s4">'oned'</span><span class="s3">].</span><span class="s1">shape</span><span class="s3">, (</span><span class="s6">5</span><span class="s3">,</span><span class="s6">1</span><span class="s3">))</span>
        <span class="s5"># but different from 'row'</span>
        <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
        <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'oned'</span><span class="s3">:</span><span class="s1">arr</span><span class="s3">},</span>
                <span class="s1">format</span><span class="s3">=</span><span class="s1">format</span><span class="s3">,</span>
                <span class="s1">oned_as</span><span class="s3">=</span><span class="s4">'row'</span><span class="s3">)</span>
        <span class="s1">vals </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">[</span><span class="s4">'oned'</span><span class="s3">].</span><span class="s1">shape</span><span class="s3">, (</span><span class="s6">1</span><span class="s3">,</span><span class="s6">5</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_compression</span><span class="s3">():</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s6">100</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">((</span><span class="s6">5</span><span class="s3">,</span><span class="s6">20</span><span class="s3">))</span>
    <span class="s1">arr</span><span class="s3">[</span><span class="s6">2</span><span class="s3">,</span><span class="s6">10</span><span class="s3">] = </span><span class="s6">1</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'arr'</span><span class="s3">:</span><span class="s1">arr</span><span class="s3">})</span>
    <span class="s1">raw_len </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">.</span><span class="s1">getvalue</span><span class="s3">())</span>
    <span class="s1">vals </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">[</span><span class="s4">'arr'</span><span class="s3">], </span><span class="s1">arr</span><span class="s3">)</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'arr'</span><span class="s3">:</span><span class="s1">arr</span><span class="s3">}, </span><span class="s1">do_compression</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">compressed_len </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">.</span><span class="s1">getvalue</span><span class="s3">())</span>
    <span class="s1">vals </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">[</span><span class="s4">'arr'</span><span class="s3">], </span><span class="s1">arr</span><span class="s3">)</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">raw_len </span><span class="s3">&gt; </span><span class="s1">compressed_len</span><span class="s3">)</span>
    <span class="s5"># Concatenate, test later</span>
    <span class="s1">arr2 </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">arr2</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">] = </span><span class="s6">1</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'arr'</span><span class="s3">:</span><span class="s1">arr</span><span class="s3">, </span><span class="s4">'arr2'</span><span class="s3">:</span><span class="s1">arr2</span><span class="s3">}, </span><span class="s1">do_compression</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">vals </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">[</span><span class="s4">'arr2'</span><span class="s3">], </span><span class="s1">arr2</span><span class="s3">)</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'arr'</span><span class="s3">:</span><span class="s1">arr</span><span class="s3">, </span><span class="s4">'arr2'</span><span class="s3">:</span><span class="s1">arr2</span><span class="s3">}, </span><span class="s1">do_compression</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">vals </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">[</span><span class="s4">'arr2'</span><span class="s3">], </span><span class="s1">arr2</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_single_object</span><span class="s3">():</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'A'</span><span class="s3">:</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s6">1</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">)})</span>


<span class="s2">def </span><span class="s1">test_skip_variable</span><span class="s3">():</span>
    <span class="s5"># Test skipping over the first of two variables in a MAT file</span>
    <span class="s5"># using mat_reader_factory and put_variables to read them in.</span>
    <span class="s5">#</span>
    <span class="s5"># This is a regression test of a problem that's caused by</span>
    <span class="s5"># using the compressed file reader seek instead of the raw file</span>
    <span class="s5"># I/O seek when skipping over a compressed chunk.</span>
    <span class="s5">#</span>
    <span class="s5"># The problem arises when the chunk is large: this file has</span>
    <span class="s5"># a 256x256 array of random (uncompressible) doubles.</span>
    <span class="s5">#</span>
    <span class="s1">filename </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">,</span><span class="s4">'test_skip_variable.mat'</span><span class="s3">)</span>
    <span class="s5">#</span>
    <span class="s5"># Prove that it loads with loadmat</span>
    <span class="s5">#</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">struct_as_record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s4">'first' </span><span class="s2">in </span><span class="s1">d</span><span class="s3">)</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s4">'second' </span><span class="s2">in </span><span class="s1">d</span><span class="s3">)</span>
    <span class="s5">#</span>
    <span class="s5"># Make the factory</span>
    <span class="s5">#</span>
    <span class="s1">factory</span><span class="s3">, </span><span class="s1">file_opened </span><span class="s3">= </span><span class="s1">mat_reader_factory</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">struct_as_record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s5">#</span>
    <span class="s5"># This is where the factory breaks with an error in MatMatrixGetter.to_next</span>
    <span class="s5">#</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">factory</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">(</span><span class="s4">'second'</span><span class="s3">)</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s4">'second' </span><span class="s2">in </span><span class="s1">d</span><span class="s3">)</span>
    <span class="s1">factory</span><span class="s3">.</span><span class="s1">mat_stream</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">test_empty_struct</span><span class="s3">():</span>
    <span class="s5"># ticket 885</span>
    <span class="s1">filename </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">,</span><span class="s4">'test_empty_struct.mat'</span><span class="s3">)</span>
    <span class="s5"># before ticket fix, this would crash with ValueError, empty data</span>
    <span class="s5"># type</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">struct_as_record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s4">'a'</span><span class="s3">]</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, (</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">))</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">object</span><span class="s3">))</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">a</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">] </span><span class="s2">is None</span><span class="s3">)</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">((), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s4">'U'</span><span class="s3">)</span>
    <span class="s5"># before ticket fix, this used to give data type not understood</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'arr'</span><span class="s3">:</span><span class="s1">arr</span><span class="s3">})</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s1">a2 </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s4">'arr'</span><span class="s3">]</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">a2</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_save_empty_dict</span><span class="s3">():</span>
    <span class="s5"># saving empty dict also gives empty struct</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'arr'</span><span class="s3">: {}})</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s4">'arr'</span><span class="s3">]</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, (</span><span class="s6">1</span><span class="s3">,</span><span class="s6">1</span><span class="s3">))</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">object</span><span class="s3">))</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">a</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">] </span><span class="s2">is None</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">assert_any_equal</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">alternatives</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; Assert `output` is equal to at least one element in `alternatives` 
    &quot;&quot;&quot;</span>
    <span class="s1">one_equal </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s2">for </span><span class="s1">expected </span><span class="s2">in </span><span class="s1">alternatives</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">output </span><span class="s3">== </span><span class="s1">expected</span><span class="s3">):</span>
            <span class="s1">one_equal </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">break</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">one_equal</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_to_writeable</span><span class="s3">():</span>
    <span class="s5"># Test to_writeable function</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">to_writeable</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s6">1</span><span class="s3">]))  </span><span class="s5"># pass through ndarrays</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, (</span><span class="s6">1</span><span class="s3">,))</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s5"># Dict fields can be written in any order</span>
    <span class="s1">expected1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([(</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">)], </span><span class="s1">dtype</span><span class="s3">=[(</span><span class="s4">'a'</span><span class="s3">, </span><span class="s4">'|O8'</span><span class="s3">), (</span><span class="s4">'b'</span><span class="s3">, </span><span class="s4">'|O8'</span><span class="s3">)])</span>
    <span class="s1">expected2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([(</span><span class="s6">2</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)], </span><span class="s1">dtype</span><span class="s3">=[(</span><span class="s4">'b'</span><span class="s3">, </span><span class="s4">'|O8'</span><span class="s3">), (</span><span class="s4">'a'</span><span class="s3">, </span><span class="s4">'|O8'</span><span class="s3">)])</span>
    <span class="s1">alternatives </span><span class="s3">= (</span><span class="s1">expected1</span><span class="s3">, </span><span class="s1">expected2</span><span class="s3">)</span>
    <span class="s1">assert_any_equal</span><span class="s3">(</span><span class="s1">to_writeable</span><span class="s3">({</span><span class="s4">'a'</span><span class="s3">:</span><span class="s6">1</span><span class="s3">,</span><span class="s4">'b'</span><span class="s3">:</span><span class="s6">2</span><span class="s3">}), </span><span class="s1">alternatives</span><span class="s3">)</span>
    <span class="s5"># Fields with underscores discarded</span>
    <span class="s1">assert_any_equal</span><span class="s3">(</span><span class="s1">to_writeable</span><span class="s3">({</span><span class="s4">'a'</span><span class="s3">:</span><span class="s6">1</span><span class="s3">,</span><span class="s4">'b'</span><span class="s3">:</span><span class="s6">2</span><span class="s3">, </span><span class="s4">'_c'</span><span class="s3">:</span><span class="s6">3</span><span class="s3">}), </span><span class="s1">alternatives</span><span class="s3">)</span>
    <span class="s5"># Not-string fields discarded</span>
    <span class="s1">assert_any_equal</span><span class="s3">(</span><span class="s1">to_writeable</span><span class="s3">({</span><span class="s4">'a'</span><span class="s3">:</span><span class="s6">1</span><span class="s3">,</span><span class="s4">'b'</span><span class="s3">:</span><span class="s6">2</span><span class="s3">, </span><span class="s6">100</span><span class="s3">:</span><span class="s6">3</span><span class="s3">}), </span><span class="s1">alternatives</span><span class="s3">)</span>
    <span class="s5"># String fields that are valid Python identifiers discarded</span>
    <span class="s1">assert_any_equal</span><span class="s3">(</span><span class="s1">to_writeable</span><span class="s3">({</span><span class="s4">'a'</span><span class="s3">:</span><span class="s6">1</span><span class="s3">,</span><span class="s4">'b'</span><span class="s3">:</span><span class="s6">2</span><span class="s3">, </span><span class="s4">'99'</span><span class="s3">:</span><span class="s6">3</span><span class="s3">}), </span><span class="s1">alternatives</span><span class="s3">)</span>
    <span class="s5"># Object with field names is equivalent</span>

    <span class="s2">class </span><span class="s1">klass</span><span class="s3">:</span>
        <span class="s2">pass</span>

    <span class="s1">c </span><span class="s3">= </span><span class="s1">klass</span>
    <span class="s1">c</span><span class="s3">.</span><span class="s1">a </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s1">c</span><span class="s3">.</span><span class="s1">b </span><span class="s3">= </span><span class="s6">2</span>
    <span class="s1">assert_any_equal</span><span class="s3">(</span><span class="s1">to_writeable</span><span class="s3">(</span><span class="s1">c</span><span class="s3">), </span><span class="s1">alternatives</span><span class="s3">)</span>
    <span class="s5"># empty list and tuple go to empty array</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">to_writeable</span><span class="s3">([])</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">,))</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">to_writeable</span><span class="s3">(())</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">,))</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s5"># None -&gt; None</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">to_writeable</span><span class="s3">(</span><span class="s2">None</span><span class="s3">) </span><span class="s2">is None</span><span class="s3">)</span>
    <span class="s5"># String to strings</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">to_writeable</span><span class="s3">(</span><span class="s4">'a string'</span><span class="s3">).</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">str_</span><span class="s3">)</span>
    <span class="s5"># Scalars to numpy to NumPy scalars</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">to_writeable</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, ())</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s6">1</span><span class="s3">).</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s5"># Empty dict returns EmptyStructMarker</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">to_writeable</span><span class="s3">({}) </span><span class="s2">is </span><span class="s1">EmptyStructMarker</span><span class="s3">)</span>
    <span class="s5"># Object does not have (even empty) __dict__</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">to_writeable</span><span class="s3">(</span><span class="s1">object</span><span class="s3">()) </span><span class="s2">is None</span><span class="s3">)</span>
    <span class="s5"># Custom object does have empty __dict__, returns EmptyStructMarker</span>

    <span class="s2">class </span><span class="s1">C</span><span class="s3">:</span>
        <span class="s2">pass</span>

    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">to_writeable</span><span class="s3">(</span><span class="s1">c</span><span class="s3">()) </span><span class="s2">is </span><span class="s1">EmptyStructMarker</span><span class="s3">)</span>
    <span class="s5"># dict keys with legal characters are convertible</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">to_writeable</span><span class="s3">({</span><span class="s4">'a'</span><span class="s3">: </span><span class="s6">1</span><span class="s3">})[</span><span class="s4">'a'</span><span class="s3">]</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, (</span><span class="s6">1</span><span class="s3">,))</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">object_</span><span class="s3">)</span>
    <span class="s5"># Only fields with illegal characters, falls back to EmptyStruct</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">to_writeable</span><span class="s3">({</span><span class="s4">'1'</span><span class="s3">:</span><span class="s6">1</span><span class="s3">}) </span><span class="s2">is </span><span class="s1">EmptyStructMarker</span><span class="s3">)</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">to_writeable</span><span class="s3">({</span><span class="s4">'_a'</span><span class="s3">:</span><span class="s6">1</span><span class="s3">}) </span><span class="s2">is </span><span class="s1">EmptyStructMarker</span><span class="s3">)</span>
    <span class="s5"># Unless there are valid fields, in which case structured array</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">to_writeable</span><span class="s3">({</span><span class="s4">'1'</span><span class="s3">:</span><span class="s6">1</span><span class="s3">, </span><span class="s4">'f'</span><span class="s3">: </span><span class="s6">2</span><span class="s3">}),</span>
                 <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([(</span><span class="s6">2</span><span class="s3">,)], </span><span class="s1">dtype</span><span class="s3">=[(</span><span class="s4">'f'</span><span class="s3">, </span><span class="s4">'|O8'</span><span class="s3">)]))</span>


<span class="s2">def </span><span class="s1">test_recarray</span><span class="s3">():</span>
    <span class="s5"># check roundtrip of structured array</span>
    <span class="s1">dt </span><span class="s3">= [(</span><span class="s4">'f1'</span><span class="s3">, </span><span class="s4">'f8'</span><span class="s3">),</span>
          <span class="s3">(</span><span class="s4">'f2'</span><span class="s3">, </span><span class="s4">'S10'</span><span class="s3">)]</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s6">2</span><span class="s3">,), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dt</span><span class="s3">)</span>
    <span class="s1">arr</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s4">'f1'</span><span class="s3">] = </span><span class="s6">0.5</span>
    <span class="s1">arr</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s4">'f2'</span><span class="s3">] = </span><span class="s4">'python'</span>
    <span class="s1">arr</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][</span><span class="s4">'f1'</span><span class="s3">] = </span><span class="s6">99</span>
    <span class="s1">arr</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][</span><span class="s4">'f2'</span><span class="s3">] = </span><span class="s4">'not perl'</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'arr'</span><span class="s3">: </span><span class="s1">arr</span><span class="s3">})</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">struct_as_record</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">a20 </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s4">'arr'</span><span class="s3">][</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">]</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">a20</span><span class="s3">.</span><span class="s1">f1</span><span class="s3">, </span><span class="s6">0.5</span><span class="s3">)</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">a20</span><span class="s3">.</span><span class="s1">f2</span><span class="s3">, </span><span class="s4">'python'</span><span class="s3">)</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">struct_as_record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">a20 </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s4">'arr'</span><span class="s3">][</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">]</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">a20</span><span class="s3">[</span><span class="s4">'f1'</span><span class="s3">], </span><span class="s6">0.5</span><span class="s3">)</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">a20</span><span class="s3">[</span><span class="s4">'f2'</span><span class="s3">], </span><span class="s4">'python'</span><span class="s3">)</span>
    <span class="s5"># structs always come back as object types</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">a20</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">([(</span><span class="s4">'f1'</span><span class="s3">, </span><span class="s4">'O'</span><span class="s3">),</span>
                                      <span class="s3">(</span><span class="s4">'f2'</span><span class="s3">, </span><span class="s4">'O'</span><span class="s3">)]))</span>
    <span class="s1">a21 </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s4">'arr'</span><span class="s3">].</span><span class="s1">flat</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">a21</span><span class="s3">[</span><span class="s4">'f1'</span><span class="s3">], </span><span class="s6">99</span><span class="s3">)</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">a21</span><span class="s3">[</span><span class="s4">'f2'</span><span class="s3">], </span><span class="s4">'not perl'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_save_object</span><span class="s3">():</span>
    <span class="s2">class </span><span class="s1">C</span><span class="s3">:</span>
        <span class="s2">pass</span>
    <span class="s1">c </span><span class="s3">= </span><span class="s1">C</span><span class="s3">()</span>
    <span class="s1">c</span><span class="s3">.</span><span class="s1">field1 </span><span class="s3">= </span><span class="s6">1</span>
    <span class="s1">c</span><span class="s3">.</span><span class="s1">field2 </span><span class="s3">= </span><span class="s4">'a string'</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'c'</span><span class="s3">: </span><span class="s1">c</span><span class="s3">})</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">struct_as_record</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">c2 </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s4">'c'</span><span class="s3">][</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">]</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">c2</span><span class="s3">.</span><span class="s1">field1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">c2</span><span class="s3">.</span><span class="s1">field2</span><span class="s3">, </span><span class="s4">'a string'</span><span class="s3">)</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">struct_as_record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">c2 </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s4">'c'</span><span class="s3">][</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">]</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">c2</span><span class="s3">[</span><span class="s4">'field1'</span><span class="s3">], </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">c2</span><span class="s3">[</span><span class="s4">'field2'</span><span class="s3">], </span><span class="s4">'a string'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_read_opts</span><span class="s3">():</span>
    <span class="s5"># tests if read is seeing option sets, at initialization and after</span>
    <span class="s5"># initialization</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">6</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s6">1</span><span class="s3">,</span><span class="s6">6</span><span class="s3">)</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'a'</span><span class="s3">: </span><span class="s1">arr</span><span class="s3">})</span>
    <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s1">back_dict </span><span class="s3">= </span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()</span>
    <span class="s1">rarr </span><span class="s3">= </span><span class="s1">back_dict</span><span class="s3">[</span><span class="s4">'a'</span><span class="s3">]</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">rarr</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">)</span>
    <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">squeeze_me</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()[</span><span class="s4">'a'</span><span class="s3">], </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">((</span><span class="s6">6</span><span class="s3">,)))</span>
    <span class="s1">rdr</span><span class="s3">.</span><span class="s1">squeeze_me </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">rarr</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">)</span>
    <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">byte_order</span><span class="s3">=</span><span class="s1">boc</span><span class="s3">.</span><span class="s1">native_code</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()[</span><span class="s4">'a'</span><span class="s3">], </span><span class="s1">arr</span><span class="s3">)</span>
    <span class="s5"># inverted byte code leads to error on read because of swapped</span>
    <span class="s5"># header etc.</span>
    <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">byte_order</span><span class="s3">=</span><span class="s1">boc</span><span class="s3">.</span><span class="s1">swapped_code</span><span class="s3">)</span>
    <span class="s1">assert_raises</span><span class="s3">(</span><span class="s1">Exception</span><span class="s3">, </span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">)</span>
    <span class="s1">rdr</span><span class="s3">.</span><span class="s1">byte_order </span><span class="s3">= </span><span class="s1">boc</span><span class="s3">.</span><span class="s1">native_code</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()[</span><span class="s4">'a'</span><span class="s3">], </span><span class="s1">arr</span><span class="s3">)</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">'a string'</span><span class="s3">])</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">truncate</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'a'</span><span class="s3">: </span><span class="s1">arr</span><span class="s3">})</span>
    <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()[</span><span class="s4">'a'</span><span class="s3">], </span><span class="s1">arr</span><span class="s3">)</span>
    <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">chars_as_strings</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">carr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_2d</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">list</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s4">'U1'</span><span class="s3">))</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()[</span><span class="s4">'a'</span><span class="s3">], </span><span class="s1">carr</span><span class="s3">)</span>
    <span class="s1">rdr</span><span class="s3">.</span><span class="s1">chars_as_strings </span><span class="s3">= </span><span class="s2">True</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()[</span><span class="s4">'a'</span><span class="s3">], </span><span class="s1">arr</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_empty_string</span><span class="s3">():</span>
    <span class="s5"># make sure reading empty string does not raise error</span>
    <span class="s1">estring_fname </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'single_empty_string.mat'</span><span class="s3">)</span>
    <span class="s1">fp </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">estring_fname</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s3">)</span>
    <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">fp</span><span class="s3">)</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()</span>
    <span class="s1">fp</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">d</span><span class="s3">[</span><span class="s4">'a'</span><span class="s3">], </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s4">'U1'</span><span class="s3">))</span>
    <span class="s5"># Empty string round trip. Matlab cannot distinguish</span>
    <span class="s5"># between a string array that is empty, and a string array</span>
    <span class="s5"># containing a single empty string, because it stores strings as</span>
    <span class="s5"># arrays of char. There is no way of having an array of char that</span>
    <span class="s5"># is not empty, but contains an empty string.</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'a'</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">''</span><span class="s3">])})</span>
    <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">d</span><span class="s3">[</span><span class="s4">'a'</span><span class="s3">], </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s4">'U1'</span><span class="s3">))</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">truncate</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'a'</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s4">'U1'</span><span class="s3">)})</span>
    <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">d</span><span class="s3">[</span><span class="s4">'a'</span><span class="s3">], </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s4">'U1'</span><span class="s3">))</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">test_corrupted_data</span><span class="s3">():</span>
    <span class="s2">import </span><span class="s1">zlib</span>
    <span class="s2">for </span><span class="s1">exc</span><span class="s3">, </span><span class="s1">fname </span><span class="s2">in </span><span class="s3">[(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s4">'corrupted_zlib_data.mat'</span><span class="s3">),</span>
                       <span class="s3">(</span><span class="s1">zlib</span><span class="s3">.</span><span class="s1">error</span><span class="s3">, </span><span class="s4">'corrupted_zlib_checksum.mat'</span><span class="s3">)]:</span>
        <span class="s2">with </span><span class="s1">open</span><span class="s3">(</span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s1">fname</span><span class="s3">), </span><span class="s4">'rb'</span><span class="s3">) </span><span class="s2">as </span><span class="s1">fp</span><span class="s3">:</span>
            <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">fp</span><span class="s3">)</span>
            <span class="s1">assert_raises</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">, </span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_corrupted_data_check_can_be_disabled</span><span class="s3">():</span>
    <span class="s2">with </span><span class="s1">open</span><span class="s3">(</span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'corrupted_zlib_data.mat'</span><span class="s3">), </span><span class="s4">'rb'</span><span class="s3">) </span><span class="s2">as </span><span class="s1">fp</span><span class="s3">:</span>
        <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">fp</span><span class="s3">, </span><span class="s1">verify_compressed_data_integrity</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">test_read_both_endian</span><span class="s3">():</span>
    <span class="s5"># make sure big- and little- endian data is read correctly</span>
    <span class="s2">for </span><span class="s1">fname </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'big_endian.mat'</span><span class="s3">, </span><span class="s4">'little_endian.mat'</span><span class="s3">):</span>
        <span class="s1">fp </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s1">fname</span><span class="s3">), </span><span class="s4">'rb'</span><span class="s3">)</span>
        <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">fp</span><span class="s3">)</span>
        <span class="s1">d </span><span class="s3">= </span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()</span>
        <span class="s1">fp</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">d</span><span class="s3">[</span><span class="s4">'strings'</span><span class="s3">],</span>
                           <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s4">'hello'</span><span class="s3">],</span>
                                     <span class="s3">[</span><span class="s4">'world'</span><span class="s3">]], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">))</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">d</span><span class="s3">[</span><span class="s4">'floats'</span><span class="s3">],</span>
                           <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s6">2.</span><span class="s3">, </span><span class="s6">3.</span><span class="s3">],</span>
                                     <span class="s3">[</span><span class="s6">3.</span><span class="s3">, </span><span class="s6">4.</span><span class="s3">]], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_write_opposite_endian</span><span class="s3">():</span>
    <span class="s5"># We don't support writing opposite endian .mat files, but we need to behave</span>
    <span class="s5"># correctly if the user supplies an other-endian NumPy array to write out.</span>
    <span class="s1">float_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s6">2.</span><span class="s3">, </span><span class="s6">3.</span><span class="s3">],</span>
                          <span class="s3">[</span><span class="s6">3.</span><span class="s3">, </span><span class="s6">4.</span><span class="s3">]])</span>
    <span class="s1">int_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">6</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">((</span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s3">))</span>
    <span class="s1">uni_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">'hello'</span><span class="s3">, </span><span class="s4">'world'</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s4">'U'</span><span class="s3">)</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span>
        <span class="s4">'floats'</span><span class="s3">: </span><span class="s1">float_arr</span><span class="s3">.</span><span class="s1">byteswap</span><span class="s3">().</span><span class="s1">view</span><span class="s3">(</span><span class="s1">float_arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">newbyteorder</span><span class="s3">()),</span>
        <span class="s4">'ints'</span><span class="s3">: </span><span class="s1">int_arr</span><span class="s3">.</span><span class="s1">byteswap</span><span class="s3">().</span><span class="s1">view</span><span class="s3">(</span><span class="s1">int_arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">newbyteorder</span><span class="s3">()),</span>
        <span class="s4">'uni_arr'</span><span class="s3">: </span><span class="s1">uni_arr</span><span class="s3">.</span><span class="s1">byteswap</span><span class="s3">().</span><span class="s1">view</span><span class="s3">(</span><span class="s1">uni_arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">newbyteorder</span><span class="s3">()),</span>
    <span class="s3">})</span>
    <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">d</span><span class="s3">[</span><span class="s4">'floats'</span><span class="s3">], </span><span class="s1">float_arr</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">d</span><span class="s3">[</span><span class="s4">'ints'</span><span class="s3">], </span><span class="s1">int_arr</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">d</span><span class="s3">[</span><span class="s4">'uni_arr'</span><span class="s3">], </span><span class="s1">uni_arr</span><span class="s3">)</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">test_logical_array</span><span class="s3">():</span>
    <span class="s5"># The roundtrip test doesn't verify that we load the data up with the</span>
    <span class="s5"># correct (bool) dtype</span>
    <span class="s2">with </span><span class="s1">open</span><span class="s3">(</span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'testbool_8_WIN64.mat'</span><span class="s3">), </span><span class="s4">'rb'</span><span class="s3">) </span><span class="s2">as </span><span class="s1">fobj</span><span class="s3">:</span>
        <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">fobj</span><span class="s3">, </span><span class="s1">mat_dtype</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">d </span><span class="s3">= </span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s2">True</span><span class="s3">], [</span><span class="s2">False</span><span class="s3">]], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">d</span><span class="s3">[</span><span class="s4">'testbools'</span><span class="s3">], </span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">d</span><span class="s3">[</span><span class="s4">'testbools'</span><span class="s3">].</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_logical_out_type</span><span class="s3">():</span>
    <span class="s5"># Confirm that bool type written as uint8, uint8 class</span>
    <span class="s5"># See gh-4022</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">barr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s2">False</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">])</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'barray'</span><span class="s3">: </span><span class="s1">barr</span><span class="s3">})</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">reader </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s1">reader</span><span class="s3">.</span><span class="s1">initialize_read</span><span class="s3">()</span>
    <span class="s1">reader</span><span class="s3">.</span><span class="s1">read_file_header</span><span class="s3">()</span>
    <span class="s1">hdr</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">reader</span><span class="s3">.</span><span class="s1">read_var_header</span><span class="s3">()</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">hdr</span><span class="s3">.</span><span class="s1">mclass</span><span class="s3">, </span><span class="s1">mio5p</span><span class="s3">.</span><span class="s1">mxUINT8_CLASS</span><span class="s3">)</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">hdr</span><span class="s3">.</span><span class="s1">is_logical</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">var </span><span class="s3">= </span><span class="s1">reader</span><span class="s3">.</span><span class="s1">read_var_array</span><span class="s3">(</span><span class="s1">hdr</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">var</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">uint8</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_roundtrip_zero_dimensions</span><span class="s3">():</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'d'</span><span class="s3">:</span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s6">10</span><span class="s3">, </span><span class="s6">0</span><span class="s3">))})</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">d</span><span class="s3">[</span><span class="s4">'d'</span><span class="s3">].</span><span class="s1">shape </span><span class="s3">== (</span><span class="s6">10</span><span class="s3">, </span><span class="s6">0</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_mat4_3d</span><span class="s3">():</span>
    <span class="s5"># test behavior when writing 3-D arrays to matlab 4 files</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">24</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">((</span><span class="s6">2</span><span class="s3">,</span><span class="s6">3</span><span class="s3">,</span><span class="s6">4</span><span class="s3">))</span>
    <span class="s1">assert_raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">savemat</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'a'</span><span class="s3">: </span><span class="s1">arr</span><span class="s3">}, </span><span class="s2">True</span><span class="s3">, </span><span class="s4">'4'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_func_read</span><span class="s3">():</span>
    <span class="s1">func_eg </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'testfunc_7.4_GLNX86.mat'</span><span class="s3">)</span>
    <span class="s1">fp </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">func_eg</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s3">)</span>
    <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">fp</span><span class="s3">)</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()</span>
    <span class="s1">fp</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">d</span><span class="s3">[</span><span class="s4">'testfunc'</span><span class="s3">], </span><span class="s1">MatlabFunction</span><span class="s3">)</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">wtr </span><span class="s3">= </span><span class="s1">MatFile5Writer</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s1">assert_raises</span><span class="s3">(</span><span class="s1">MatWriteError</span><span class="s3">, </span><span class="s1">wtr</span><span class="s3">.</span><span class="s1">put_variables</span><span class="s3">, </span><span class="s1">d</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_mat_dtype</span><span class="s3">():</span>
    <span class="s1">double_eg </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'testmatrix_6.1_SOL2.mat'</span><span class="s3">)</span>
    <span class="s1">fp </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">double_eg</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s3">)</span>
    <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">fp</span><span class="s3">, </span><span class="s1">mat_dtype</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()</span>
    <span class="s1">fp</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">d</span><span class="s3">[</span><span class="s4">'testmatrix'</span><span class="s3">].</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind</span><span class="s3">, </span><span class="s4">'u'</span><span class="s3">)</span>

    <span class="s1">fp </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">double_eg</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s3">)</span>
    <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">fp</span><span class="s3">, </span><span class="s1">mat_dtype</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()</span>
    <span class="s1">fp</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">d</span><span class="s3">[</span><span class="s4">'testmatrix'</span><span class="s3">].</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind</span><span class="s3">, </span><span class="s4">'f'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_sparse_in_struct</span><span class="s3">():</span>
    <span class="s5"># reproduces bug found by DC where Cython code was insisting on</span>
    <span class="s5"># ndarray return type, but getting sparse matrix</span>
    <span class="s1">st </span><span class="s3">= {</span><span class="s4">'sparsefield'</span><span class="s3">: </span><span class="s1">SP</span><span class="s3">.</span><span class="s1">coo_matrix</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">eye</span><span class="s3">(</span><span class="s6">4</span><span class="s3">))}</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'a'</span><span class="s3">:</span><span class="s1">st</span><span class="s3">})</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">struct_as_record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">d</span><span class="s3">[</span><span class="s4">'a'</span><span class="s3">][</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">][</span><span class="s4">'sparsefield'</span><span class="s3">].</span><span class="s1">toarray</span><span class="s3">(), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">eye</span><span class="s3">(</span><span class="s6">4</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_mat_struct_squeeze</span><span class="s3">():</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">in_d </span><span class="s3">= {</span><span class="s4">'st'</span><span class="s3">:{</span><span class="s4">'one'</span><span class="s3">:</span><span class="s6">1</span><span class="s3">, </span><span class="s4">'two'</span><span class="s3">:</span><span class="s6">2</span><span class="s3">}}</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">in_d</span><span class="s3">)</span>
    <span class="s5"># no error without squeeze</span>
    <span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">struct_as_record</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s5"># previous error was with squeeze, with mat_struct</span>
    <span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">struct_as_record</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">squeeze_me</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_scalar_squeeze</span><span class="s3">():</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">in_d </span><span class="s3">= {</span><span class="s4">'scalar'</span><span class="s3">: [[</span><span class="s6">0.1</span><span class="s3">]], </span><span class="s4">'string'</span><span class="s3">: </span><span class="s4">'my name'</span><span class="s3">, </span><span class="s4">'st'</span><span class="s3">:{</span><span class="s4">'one'</span><span class="s3">:</span><span class="s6">1</span><span class="s3">, </span><span class="s4">'two'</span><span class="s3">:</span><span class="s6">2</span><span class="s3">}}</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">in_d</span><span class="s3">)</span>
    <span class="s1">out_d </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">squeeze_me</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">out_d</span><span class="s3">[</span><span class="s4">'scalar'</span><span class="s3">], </span><span class="s1">float</span><span class="s3">))</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">out_d</span><span class="s3">[</span><span class="s4">'string'</span><span class="s3">], </span><span class="s1">str</span><span class="s3">))</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">out_d</span><span class="s3">[</span><span class="s4">'st'</span><span class="s3">], </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_str_round</span><span class="s3">():</span>
    <span class="s5"># from report by Angus McMorland on mailing list 3 May 2010</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">in_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">'Hello'</span><span class="s3">, </span><span class="s4">'Foob'</span><span class="s3">])</span>
    <span class="s1">out_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">'Hello'</span><span class="s3">, </span><span class="s4">'Foob '</span><span class="s3">])</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">a</span><span class="s3">=</span><span class="s1">in_arr</span><span class="s3">))</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s5"># resulted in ['HloolFoa', 'elWrdobr']</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">[</span><span class="s4">'a'</span><span class="s3">], </span><span class="s1">out_arr</span><span class="s3">)</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">truncate</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s5"># Make Fortran ordered version of string</span>
    <span class="s1">in_str </span><span class="s3">= </span><span class="s1">in_arr</span><span class="s3">.</span><span class="s1">tobytes</span><span class="s3">(</span><span class="s1">order</span><span class="s3">=</span><span class="s4">'F'</span><span class="s3">)</span>
    <span class="s1">in_from_str </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
                             <span class="s1">dtype</span><span class="s3">=</span><span class="s1">in_arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">,</span>
                             <span class="s1">order</span><span class="s3">=</span><span class="s4">'F'</span><span class="s3">,</span>
                             <span class="s1">buffer</span><span class="s3">=</span><span class="s1">in_str</span><span class="s3">)</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">a</span><span class="s3">=</span><span class="s1">in_from_str</span><span class="s3">))</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">[</span><span class="s4">'a'</span><span class="s3">], </span><span class="s1">out_arr</span><span class="s3">)</span>
    <span class="s5"># unicode save did lead to buffer too small error</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">truncate</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">stream</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">in_arr_u </span><span class="s3">= </span><span class="s1">in_arr</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">'U'</span><span class="s3">)</span>
    <span class="s1">out_arr_u </span><span class="s3">= </span><span class="s1">out_arr</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">'U'</span><span class="s3">)</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'a'</span><span class="s3">: </span><span class="s1">in_arr_u</span><span class="s3">})</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">[</span><span class="s4">'a'</span><span class="s3">], </span><span class="s1">out_arr_u</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_fieldnames</span><span class="s3">():</span>
    <span class="s5"># Check that field names are as expected</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'a'</span><span class="s3">: {</span><span class="s4">'a'</span><span class="s3">:</span><span class="s6">1</span><span class="s3">, </span><span class="s4">'b'</span><span class="s3">:</span><span class="s6">2</span><span class="s3">}})</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s1">field_names </span><span class="s3">= </span><span class="s1">res</span><span class="s3">[</span><span class="s4">'a'</span><span class="s3">].</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">names</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">field_names</span><span class="s3">), {</span><span class="s4">'a'</span><span class="s3">, </span><span class="s4">'b'</span><span class="s3">})</span>


<span class="s2">def </span><span class="s1">test_loadmat_varnames</span><span class="s3">():</span>
    <span class="s5"># Test that we can get just one variable from a mat file using loadmat</span>
    <span class="s1">mat5_sys_names </span><span class="s3">= [</span><span class="s4">'__globals__'</span><span class="s3">,</span>
                      <span class="s4">'__header__'</span><span class="s3">,</span>
                      <span class="s4">'__version__'</span><span class="s3">]</span>
    <span class="s2">for </span><span class="s1">eg_file</span><span class="s3">, </span><span class="s1">sys_v_names </span><span class="s2">in </span><span class="s3">(</span>
        <span class="s3">(</span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'testmulti_4.2c_SOL2.mat'</span><span class="s3">), []), (</span><span class="s1">pjoin</span><span class="s3">(</span>
            <span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'testmulti_7.4_GLNX86.mat'</span><span class="s3">), </span><span class="s1">mat5_sys_names</span><span class="s3">)):</span>
        <span class="s1">vars </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">eg_file</span><span class="s3">)</span>
        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">vars</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()), </span><span class="s1">set</span><span class="s3">([</span><span class="s4">'a'</span><span class="s3">, </span><span class="s4">'theta'</span><span class="s3">] + </span><span class="s1">sys_v_names</span><span class="s3">))</span>
        <span class="s1">vars </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">eg_file</span><span class="s3">, </span><span class="s1">variable_names</span><span class="s3">=</span><span class="s4">'a'</span><span class="s3">)</span>
        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">vars</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()), </span><span class="s1">set</span><span class="s3">([</span><span class="s4">'a'</span><span class="s3">] + </span><span class="s1">sys_v_names</span><span class="s3">))</span>
        <span class="s1">vars </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">eg_file</span><span class="s3">, </span><span class="s1">variable_names</span><span class="s3">=[</span><span class="s4">'a'</span><span class="s3">])</span>
        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">vars</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()), </span><span class="s1">set</span><span class="s3">([</span><span class="s4">'a'</span><span class="s3">] + </span><span class="s1">sys_v_names</span><span class="s3">))</span>
        <span class="s1">vars </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">eg_file</span><span class="s3">, </span><span class="s1">variable_names</span><span class="s3">=[</span><span class="s4">'theta'</span><span class="s3">])</span>
        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">vars</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()), </span><span class="s1">set</span><span class="s3">([</span><span class="s4">'theta'</span><span class="s3">] + </span><span class="s1">sys_v_names</span><span class="s3">))</span>
        <span class="s1">vars </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">eg_file</span><span class="s3">, </span><span class="s1">variable_names</span><span class="s3">=(</span><span class="s4">'theta'</span><span class="s3">,))</span>
        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">vars</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()), </span><span class="s1">set</span><span class="s3">([</span><span class="s4">'theta'</span><span class="s3">] + </span><span class="s1">sys_v_names</span><span class="s3">))</span>
        <span class="s1">vars </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">eg_file</span><span class="s3">, </span><span class="s1">variable_names</span><span class="s3">=[])</span>
        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">vars</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()), </span><span class="s1">set</span><span class="s3">(</span><span class="s1">sys_v_names</span><span class="s3">))</span>
        <span class="s1">vnames </span><span class="s3">= [</span><span class="s4">'theta'</span><span class="s3">]</span>
        <span class="s1">vars </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">eg_file</span><span class="s3">, </span><span class="s1">variable_names</span><span class="s3">=</span><span class="s1">vnames</span><span class="s3">)</span>
        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">vnames</span><span class="s3">, [</span><span class="s4">'theta'</span><span class="s3">])</span>


<span class="s2">def </span><span class="s1">test_round_types</span><span class="s3">():</span>
    <span class="s5"># Check that saving, loading preserves dtype in most cases</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">10</span><span class="s3">)</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s2">for </span><span class="s1">dts </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'f8'</span><span class="s3">,</span><span class="s4">'f4'</span><span class="s3">,</span><span class="s4">'i8'</span><span class="s3">,</span><span class="s4">'i4'</span><span class="s3">,</span><span class="s4">'i2'</span><span class="s3">,</span><span class="s4">'i1'</span><span class="s3">,</span>
                <span class="s4">'u8'</span><span class="s3">,</span><span class="s4">'u4'</span><span class="s3">,</span><span class="s4">'u2'</span><span class="s3">,</span><span class="s4">'u1'</span><span class="s3">,</span><span class="s4">'c16'</span><span class="s3">,</span><span class="s4">'c8'</span><span class="s3">):</span>
        <span class="s1">stream</span><span class="s3">.</span><span class="s1">truncate</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">stream</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)  </span><span class="s5"># needed for BytesIO in Python 3</span>
        <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, {</span><span class="s4">'arr'</span><span class="s3">: </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dts</span><span class="s3">)})</span>
        <span class="s1">vars </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">dts</span><span class="s3">), </span><span class="s1">vars</span><span class="s3">[</span><span class="s4">'arr'</span><span class="s3">].</span><span class="s1">dtype</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_varmats_from_mat</span><span class="s3">():</span>
    <span class="s5"># Make a mat file with several variables, write it, read it back</span>
    <span class="s1">names_vars </span><span class="s3">= ((</span><span class="s4">'arr'</span><span class="s3">, </span><span class="s1">mlarr</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">10</span><span class="s3">))),</span>
                  <span class="s3">(</span><span class="s4">'mystr'</span><span class="s3">, </span><span class="s1">mlarr</span><span class="s3">(</span><span class="s4">'a string'</span><span class="s3">)),</span>
                  <span class="s3">(</span><span class="s4">'mynum'</span><span class="s3">, </span><span class="s1">mlarr</span><span class="s3">(</span><span class="s6">10</span><span class="s3">)))</span>

    <span class="s5"># Dict like thing to give variables in defined order</span>
    <span class="s2">class </span><span class="s1">C</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">items</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">names_vars</span>
    <span class="s1">stream </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">, </span><span class="s1">C</span><span class="s3">())</span>
    <span class="s1">varmats </span><span class="s3">= </span><span class="s1">varmats_from_mat</span><span class="s3">(</span><span class="s1">stream</span><span class="s3">)</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">varmats</span><span class="s3">), </span><span class="s6">3</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s6">3</span><span class="s3">):</span>
        <span class="s1">name</span><span class="s3">, </span><span class="s1">var_stream </span><span class="s3">= </span><span class="s1">varmats</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s1">exp_name</span><span class="s3">, </span><span class="s1">exp_res </span><span class="s3">= </span><span class="s1">names_vars</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">exp_name</span><span class="s3">)</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">var_stream</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">[</span><span class="s1">name</span><span class="s3">], </span><span class="s1">exp_res</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_one_by_zero</span><span class="s3">():</span>
    <span class="s5"># Test 1x0 chars get read correctly</span>
    <span class="s1">func_eg </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'one_by_zero_char.mat'</span><span class="s3">)</span>
    <span class="s1">fp </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">func_eg</span><span class="s3">, </span><span class="s4">'rb'</span><span class="s3">)</span>
    <span class="s1">rdr </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">fp</span><span class="s3">)</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">rdr</span><span class="s3">.</span><span class="s1">get_variables</span><span class="s3">()</span>
    <span class="s1">fp</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">d</span><span class="s3">[</span><span class="s4">'var'</span><span class="s3">].</span><span class="s1">shape</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">,))</span>


<span class="s2">def </span><span class="s1">test_load_mat4_le</span><span class="s3">():</span>
    <span class="s5"># We were getting byte order wrong when reading little-endian floa64 dense</span>
    <span class="s5"># matrices on big-endian platforms</span>
    <span class="s1">mat4_fname </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'test_mat4_le_floats.mat'</span><span class="s3">)</span>
    <span class="s1">vars </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">mat4_fname</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">vars</span><span class="s3">[</span><span class="s4">'a'</span><span class="s3">], [[</span><span class="s6">0.1</span><span class="s3">, </span><span class="s6">1.2</span><span class="s3">]])</span>


<span class="s2">def </span><span class="s1">test_unicode_mat4</span><span class="s3">():</span>
    <span class="s5"># Mat4 should save unicode as latin1</span>
    <span class="s1">bio </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">var </span><span class="s3">= {</span><span class="s4">'second_cat'</span><span class="s3">: </span><span class="s4">'Schrödinger'</span><span class="s3">}</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">bio</span><span class="s3">, </span><span class="s1">var</span><span class="s3">, </span><span class="s1">format</span><span class="s3">=</span><span class="s4">'4'</span><span class="s3">)</span>
    <span class="s1">var_back </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">bio</span><span class="s3">)</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">var_back</span><span class="s3">[</span><span class="s4">'second_cat'</span><span class="s3">], </span><span class="s1">var</span><span class="s3">[</span><span class="s4">'second_cat'</span><span class="s3">])</span>


<span class="s2">def </span><span class="s1">test_logical_sparse</span><span class="s3">():</span>
    <span class="s5"># Test we can read logical sparse stored in mat file as bytes.</span>
    <span class="s5"># See https://github.com/scipy/scipy/issues/3539.</span>
    <span class="s5"># In some files saved by MATLAB, the sparse data elements (Real Part</span>
    <span class="s5"># Subelement in MATLAB speak) are stored with apparent type double</span>
    <span class="s5"># (miDOUBLE) but are in fact single bytes.</span>
    <span class="s1">filename </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">,</span><span class="s4">'logical_sparse.mat'</span><span class="s3">)</span>
    <span class="s5"># Before fix, this would crash with:</span>
    <span class="s5"># ValueError: indices and data should have the same size</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">struct_as_record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">log_sp </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[</span><span class="s4">'sp_log_5_4'</span><span class="s3">]</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">log_sp</span><span class="s3">, </span><span class="s1">SP</span><span class="s3">.</span><span class="s1">csc_matrix</span><span class="s3">))</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">log_sp</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">log_sp</span><span class="s3">.</span><span class="s1">toarray</span><span class="s3">(),</span>
                       <span class="s3">[[</span><span class="s2">True</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">],</span>
                        <span class="s3">[</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">],</span>
                        <span class="s3">[</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">],</span>
                        <span class="s3">[</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">],</span>
                        <span class="s3">[</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">]])</span>


<span class="s2">def </span><span class="s1">test_empty_sparse</span><span class="s3">():</span>
    <span class="s5"># Can we read empty sparse matrices?</span>
    <span class="s1">sio </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s2">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">sparse</span>
    <span class="s1">empty_sparse </span><span class="s3">= </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">sparse</span><span class="s3">.</span><span class="s1">csr_matrix</span><span class="s3">([[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">],[</span><span class="s6">0</span><span class="s3">,</span><span class="s6">0</span><span class="s3">]])</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">sio</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">x</span><span class="s3">=</span><span class="s1">empty_sparse</span><span class="s3">))</span>
    <span class="s1">sio</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">sio</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">[</span><span class="s4">'x'</span><span class="s3">].</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">empty_sparse</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">[</span><span class="s4">'x'</span><span class="s3">].</span><span class="s1">toarray</span><span class="s3">(), </span><span class="s6">0</span><span class="s3">)</span>
    <span class="s5"># Do empty sparse matrices get written with max nnz 1?</span>
    <span class="s5"># See https://github.com/scipy/scipy/issues/4208</span>
    <span class="s1">sio</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">reader </span><span class="s3">= </span><span class="s1">MatFile5Reader</span><span class="s3">(</span><span class="s1">sio</span><span class="s3">)</span>
    <span class="s1">reader</span><span class="s3">.</span><span class="s1">initialize_read</span><span class="s3">()</span>
    <span class="s1">reader</span><span class="s3">.</span><span class="s1">read_file_header</span><span class="s3">()</span>
    <span class="s1">hdr</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">reader</span><span class="s3">.</span><span class="s1">read_var_header</span><span class="s3">()</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">hdr</span><span class="s3">.</span><span class="s1">nzmax</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_empty_mat_error</span><span class="s3">():</span>
    <span class="s5"># Test we get a specific warning for an empty mat file</span>
    <span class="s1">sio </span><span class="s3">= </span><span class="s1">BytesIO</span><span class="s3">()</span>
    <span class="s1">assert_raises</span><span class="s3">(</span><span class="s1">MatReadError</span><span class="s3">, </span><span class="s1">loadmat</span><span class="s3">, </span><span class="s1">sio</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_miuint32_compromise</span><span class="s3">():</span>
    <span class="s5"># Reader should accept miUINT32 for miINT32, but check signs</span>
    <span class="s5"># mat file with miUINT32 for miINT32, but OK values</span>
    <span class="s1">filename </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'miuint32_for_miint32.mat'</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">)</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">[</span><span class="s4">'an_array'</span><span class="s3">], </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">10</span><span class="s3">)[</span><span class="s2">None</span><span class="s3">, :])</span>
    <span class="s5"># mat file with miUINT32 for miINT32, with negative value</span>
    <span class="s1">filename </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'bad_miuint32.mat'</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">assert_raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">loadmat</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_miutf8_for_miint8_compromise</span><span class="s3">():</span>
    <span class="s5"># Check reader accepts ascii as miUTF8 for array names</span>
    <span class="s1">filename </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'miutf8_array_name.mat'</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">)</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">[</span><span class="s4">'array_name'</span><span class="s3">], [[</span><span class="s6">1</span><span class="s3">]])</span>
    <span class="s5"># mat file with non-ascii utf8 name raises error</span>
    <span class="s1">filename </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'bad_miutf8_array_name.mat'</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">assert_raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">loadmat</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_bad_utf8</span><span class="s3">():</span>
    <span class="s5"># Check that reader reads bad UTF with 'replace' option</span>
    <span class="s1">filename </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">,</span><span class="s4">'broken_utf8.mat'</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">)</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">res</span><span class="s3">[</span><span class="s4">'bad_string'</span><span class="s3">],</span>
                 <span class="s7">b'</span><span class="s2">\x80 </span><span class="s7">am broken'</span><span class="s3">.</span><span class="s1">decode</span><span class="s3">(</span><span class="s4">'utf8'</span><span class="s3">, </span><span class="s4">'replace'</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_save_unicode_field</span><span class="s3">(</span><span class="s1">tmpdir</span><span class="s3">):</span>
    <span class="s1">filename </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">tmpdir</span><span class="s3">), </span><span class="s4">'test.mat'</span><span class="s3">)</span>
    <span class="s1">test_dict </span><span class="s3">= {</span><span class="s4">'a'</span><span class="s3">:{</span><span class="s4">'b'</span><span class="s3">:</span><span class="s6">1</span><span class="s3">,</span><span class="s4">'c'</span><span class="s3">:</span><span class="s4">'test_str'</span><span class="s3">}}</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">test_dict</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_save_custom_array_type</span><span class="s3">(</span><span class="s1">tmpdir</span><span class="s3">):</span>
    <span class="s2">class </span><span class="s1">CustomArray</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">__array__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">6.0</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s6">2</span><span class="s3">, </span><span class="s6">3</span><span class="s3">)</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">CustomArray</span><span class="s3">()</span>
    <span class="s1">filename </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">tmpdir</span><span class="s3">), </span><span class="s4">'test.mat'</span><span class="s3">)</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, {</span><span class="s4">'a'</span><span class="s3">: </span><span class="s1">a</span><span class="s3">})</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">out</span><span class="s3">[</span><span class="s4">'a'</span><span class="s3">], </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">a</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_filenotfound</span><span class="s3">():</span>
    <span class="s5"># Check the correct error is thrown</span>
    <span class="s1">assert_raises</span><span class="s3">(</span><span class="s1">OSError</span><span class="s3">, </span><span class="s1">loadmat</span><span class="s3">, </span><span class="s4">&quot;NotExistentFile00.mat&quot;</span><span class="s3">)</span>
    <span class="s1">assert_raises</span><span class="s3">(</span><span class="s1">OSError</span><span class="s3">, </span><span class="s1">loadmat</span><span class="s3">, </span><span class="s4">&quot;NotExistentFile00&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_simplify_cells</span><span class="s3">():</span>
    <span class="s5"># Test output when simplify_cells=True</span>
    <span class="s1">filename </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'testsimplecell.mat'</span><span class="s3">)</span>
    <span class="s1">res1 </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">simplify_cells</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">res2 </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">filename</span><span class="s3">, </span><span class="s1">simplify_cells</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">res1</span><span class="s3">[</span><span class="s4">&quot;s&quot;</span><span class="s3">], </span><span class="s1">dict</span><span class="s3">))</span>
    <span class="s1">assert_</span><span class="s3">(</span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">res2</span><span class="s3">[</span><span class="s4">&quot;s&quot;</span><span class="s3">], </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">))</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">res1</span><span class="s3">[</span><span class="s4">&quot;s&quot;</span><span class="s3">][</span><span class="s4">&quot;mycell&quot;</span><span class="s3">], </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">&quot;a&quot;</span><span class="s3">, </span><span class="s4">&quot;b&quot;</span><span class="s3">, </span><span class="s4">&quot;c&quot;</span><span class="s3">]))</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">'version, filt, regex'</span><span class="s3">, [</span>
    <span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s4">'_4*_*'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s6">1</span><span class="s3">, </span><span class="s4">'_5*_*'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s6">1</span><span class="s3">, </span><span class="s4">'_6*_*'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s6">1</span><span class="s3">, </span><span class="s4">'_7*_*'</span><span class="s3">, </span><span class="s4">'^((?!hdf5).)*$'</span><span class="s3">),  </span><span class="s5"># not containing hdf5</span>
    <span class="s3">(</span><span class="s6">2</span><span class="s3">, </span><span class="s4">'_7*_*'</span><span class="s3">, </span><span class="s4">'.*hdf5.*'</span><span class="s3">),</span>
    <span class="s3">(</span><span class="s6">1</span><span class="s3">, </span><span class="s4">'8*_*'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
<span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_matfile_version</span><span class="s3">(</span><span class="s1">version</span><span class="s3">, </span><span class="s1">filt</span><span class="s3">, </span><span class="s1">regex</span><span class="s3">):</span>
    <span class="s1">use_filt </span><span class="s3">= </span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'test*%s.mat' </span><span class="s3">% </span><span class="s1">filt</span><span class="s3">)</span>
    <span class="s1">files </span><span class="s3">= </span><span class="s1">glob</span><span class="s3">(</span><span class="s1">use_filt</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">regex </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">files </span><span class="s3">= [</span><span class="s1">file </span><span class="s2">for </span><span class="s1">file </span><span class="s2">in </span><span class="s1">files </span><span class="s2">if </span><span class="s1">re</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">regex</span><span class="s3">, </span><span class="s1">file</span><span class="s3">) </span><span class="s2">is not None</span><span class="s3">]</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">files</span><span class="s3">) &gt; </span><span class="s6">0</span><span class="s3">, </span><span class="s1">\</span>
        <span class="s4">f&quot;No files for version </span><span class="s2">{</span><span class="s1">version</span><span class="s2">} </span><span class="s4">using filter </span><span class="s2">{</span><span class="s1">filt</span><span class="s2">}</span><span class="s4">&quot;</span>
    <span class="s2">for </span><span class="s1">file </span><span class="s2">in </span><span class="s1">files</span><span class="s3">:</span>
        <span class="s1">got_version </span><span class="s3">= </span><span class="s1">matfile_version</span><span class="s3">(</span><span class="s1">file</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">got_version</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] == </span><span class="s1">version</span>


<span class="s2">def </span><span class="s1">test_opaque</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Test that we can read a MatlabOpaque object.&quot;&quot;&quot;</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'parabola.mat'</span><span class="s3">))</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">data</span><span class="s3">[</span><span class="s4">'parabola'</span><span class="s3">], </span><span class="s1">MatlabFunction</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">data</span><span class="s3">[</span><span class="s4">'parabola'</span><span class="s3">].</span><span class="s1">item</span><span class="s3">()[</span><span class="s6">3</span><span class="s3">].</span><span class="s1">item</span><span class="s3">()[</span><span class="s6">3</span><span class="s3">], </span><span class="s1">MatlabOpaque</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_opaque_simplify</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Test that we can read a MatlabOpaque object when simplify_cells=True.&quot;&quot;&quot;</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">loadmat</span><span class="s3">(</span><span class="s1">pjoin</span><span class="s3">(</span><span class="s1">test_data_path</span><span class="s3">, </span><span class="s4">'parabola.mat'</span><span class="s3">), </span><span class="s1">simplify_cells</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">data</span><span class="s3">[</span><span class="s4">'parabola'</span><span class="s3">], </span><span class="s1">MatlabFunction</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_deprecation</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Test that access to previous attributes still works.&quot;&quot;&quot;</span>
    <span class="s5"># This should be accessible immediately from scipy.io import</span>
    <span class="s2">with </span><span class="s1">assert_warns</span><span class="s3">(</span><span class="s1">DeprecationWarning</span><span class="s3">):</span>
        <span class="s1">scipy</span><span class="s3">.</span><span class="s1">io</span><span class="s3">.</span><span class="s1">matlab</span><span class="s3">.</span><span class="s1">mio5_params</span><span class="s3">.</span><span class="s1">MatlabOpaque</span>

    <span class="s5"># These should be importable but warn as well</span>
    <span class="s2">with </span><span class="s1">assert_warns</span><span class="s3">(</span><span class="s1">DeprecationWarning</span><span class="s3">):</span>
        <span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">io</span><span class="s3">.</span><span class="s1">matlab</span><span class="s3">.</span><span class="s1">miobase </span><span class="s2">import </span><span class="s1">MatReadError  </span><span class="s5"># noqa: F401</span>


<span class="s2">def </span><span class="s1">test_gh_17992</span><span class="s3">(</span><span class="s1">tmp_path</span><span class="s3">):</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">default_rng</span><span class="s3">(</span><span class="s6">12345</span><span class="s3">)</span>
    <span class="s1">outfile </span><span class="s3">= </span><span class="s1">tmp_path </span><span class="s3">/ </span><span class="s4">&quot;lists.mat&quot;</span>
    <span class="s1">array_one </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">random</span><span class="s3">((</span><span class="s6">5</span><span class="s3">,</span><span class="s6">3</span><span class="s3">))</span>
    <span class="s1">array_two </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">random</span><span class="s3">((</span><span class="s6">6</span><span class="s3">,</span><span class="s6">3</span><span class="s3">))</span>
    <span class="s1">list_of_arrays </span><span class="s3">= [</span><span class="s1">array_one</span><span class="s3">, </span><span class="s1">array_two</span><span class="s3">]</span>
    <span class="s5"># warning suppression only needed for NumPy &lt; 1.24.0</span>
    <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">suppress_warnings</span><span class="s3">() </span><span class="s2">as </span><span class="s1">sup</span><span class="s3">:</span>
        <span class="s1">sup</span><span class="s3">.</span><span class="s1">filter</span><span class="s3">(</span><span class="s1">VisibleDeprecationWarning</span><span class="s3">)</span>
        <span class="s1">savemat</span><span class="s3">(</span><span class="s1">outfile</span><span class="s3">,</span>
                <span class="s3">{</span><span class="s4">'data'</span><span class="s3">: </span><span class="s1">list_of_arrays</span><span class="s3">},</span>
                <span class="s1">long_field_names</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                <span class="s1">do_compression</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s5"># round trip check</span>
    <span class="s1">new_dict </span><span class="s3">= {}</span>
    <span class="s1">loadmat</span><span class="s3">(</span><span class="s1">outfile</span><span class="s3">,</span>
            <span class="s1">new_dict</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">new_dict</span><span class="s3">[</span><span class="s4">&quot;data&quot;</span><span class="s3">][</span><span class="s6">0</span><span class="s3">][</span><span class="s6">0</span><span class="s3">], </span><span class="s1">array_one</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">new_dict</span><span class="s3">[</span><span class="s4">&quot;data&quot;</span><span class="s3">][</span><span class="s6">0</span><span class="s3">][</span><span class="s6">1</span><span class="s3">], </span><span class="s1">array_two</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_gh_19659</span><span class="s3">(</span><span class="s1">tmp_path</span><span class="s3">):</span>
    <span class="s1">d </span><span class="s3">= {</span>
        <span class="s4">&quot;char_array&quot;</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">list</span><span class="s3">(</span><span class="s4">&quot;char&quot;</span><span class="s3">), </span><span class="s1">list</span><span class="s3">(</span><span class="s4">&quot;char&quot;</span><span class="s3">)], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s4">&quot;U1&quot;</span><span class="s3">),</span>
        <span class="s4">&quot;string_array&quot;</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">&quot;string&quot;</span><span class="s3">, </span><span class="s4">&quot;string&quot;</span><span class="s3">]),</span>
        <span class="s3">}</span>
    <span class="s1">outfile </span><span class="s3">= </span><span class="s1">tmp_path </span><span class="s3">/ </span><span class="s4">&quot;tmp.mat&quot;</span>
    <span class="s5"># should not error:</span>
    <span class="s1">savemat</span><span class="s3">(</span><span class="s1">outfile</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">format</span><span class="s3">=</span><span class="s4">&quot;4&quot;</span><span class="s3">)</span>
</pre>
</body>
</html>