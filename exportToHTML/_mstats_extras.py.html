<html>
<head>
<title>_mstats_extras.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #cf8e6d;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_mstats_extras.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Additional statistics functions with support for masked arrays. 
 
&quot;&quot;&quot;</span>

<span class="s2"># Original author (2007): Pierre GF Gerard-Marchant</span>


<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">'compare_medians_ms'</span><span class="s3">,</span>
           <span class="s4">'hdquantiles'</span><span class="s3">, </span><span class="s4">'hdmedian'</span><span class="s3">, </span><span class="s4">'hdquantiles_sd'</span><span class="s3">,</span>
           <span class="s4">'idealfourths'</span><span class="s3">,</span>
           <span class="s4">'median_cihs'</span><span class="s3">,</span><span class="s4">'mjci'</span><span class="s3">,</span><span class="s4">'mquantiles_cimj'</span><span class="s3">,</span>
           <span class="s4">'rsh'</span><span class="s3">,</span>
           <span class="s4">'trimmed_mean_ci'</span><span class="s3">,]</span>


<span class="s5">import </span><span class="s1">numpy </span><span class="s5">as </span><span class="s1">np</span>
<span class="s5">from </span><span class="s1">numpy </span><span class="s5">import </span><span class="s1">float64</span><span class="s3">, </span><span class="s1">ndarray</span>

<span class="s5">import </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">ma </span><span class="s5">as </span><span class="s1">ma</span>
<span class="s5">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">ma </span><span class="s5">import </span><span class="s1">MaskedArray</span>

<span class="s5">from </span><span class="s3">. </span><span class="s5">import </span><span class="s1">_mstats_basic </span><span class="s5">as </span><span class="s1">mstats</span>

<span class="s5">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats</span><span class="s3">.</span><span class="s1">distributions </span><span class="s5">import </span><span class="s1">norm</span><span class="s3">, </span><span class="s1">beta</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">binom</span>


<span class="s5">def </span><span class="s1">hdquantiles</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">=</span><span class="s1">list</span><span class="s3">([</span><span class="s6">.25</span><span class="s3">,</span><span class="s6">.5</span><span class="s3">,</span><span class="s6">.75</span><span class="s3">]), </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">var</span><span class="s3">=</span><span class="s5">False</span><span class="s3">,):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes quantile estimates with the Harrell-Davis method. 
 
    The quantile estimates are calculated as a weighted linear combination 
    of order statistics. 
 
    Parameters 
    ---------- 
    data : array_like 
        Data array. 
    prob : sequence, optional 
        Sequence of probabilities at which to compute the quantiles. 
    axis : int or None, optional 
        Axis along which to compute the quantiles. If None, use a flattened 
        array. 
    var : bool, optional 
        Whether to return the variance of the estimate. 
 
    Returns 
    ------- 
    hdquantiles : MaskedArray 
        A (p,) array of quantiles (if `var` is False), or a (2,p) array of 
        quantiles and variances (if `var` is True), where ``p`` is the 
        number of quantiles. 
 
    See Also 
    -------- 
    hdquantiles_sd 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats.mstats import hdquantiles 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Sample data 
    &gt;&gt;&gt; data = np.array([1.2, 2.5, 3.7, 4.0, 5.1, 6.3, 7.0, 8.2, 9.4]) 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Probabilities at which to compute quantiles 
    &gt;&gt;&gt; probabilities = [0.25, 0.5, 0.75] 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Compute Harrell-Davis quantile estimates 
    &gt;&gt;&gt; quantile_estimates = hdquantiles(data, prob=probabilities) 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Display the quantile estimates 
    &gt;&gt;&gt; for i, quantile in enumerate(probabilities): 
    ...     print(f&quot;{int(quantile * 100)}th percentile: {quantile_estimates[i]}&quot;) 
    25th percentile: 3.1505820231763066 # may vary 
    50th percentile: 5.194344084883956 
    75th percentile: 7.430626414674935 
 
    &quot;&quot;&quot;</span>
    <span class="s5">def </span><span class="s1">_hd_1D</span><span class="s3">(</span><span class="s1">data</span><span class="s3">,</span><span class="s1">prob</span><span class="s3">,</span><span class="s1">var</span><span class="s3">):</span>
        <span class="s0">&quot;Computes the HD quantiles for a 1D array. Returns nan for invalid data.&quot;</span>
        <span class="s1">xsorted </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">squeeze</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">compressed</span><span class="s3">().</span><span class="s1">view</span><span class="s3">(</span><span class="s1">ndarray</span><span class="s3">)))</span>
        <span class="s2"># Don't use length here, in case we have a numpy scalar</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">xsorted</span><span class="s3">.</span><span class="s1">size</span>

        <span class="s1">hd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s6">2</span><span class="s3">,</span><span class="s1">len</span><span class="s3">(</span><span class="s1">prob</span><span class="s3">)), </span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">hd</span><span class="s3">.</span><span class="s1">flat </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
            <span class="s5">if </span><span class="s1">var</span><span class="s3">:</span>
                <span class="s5">return </span><span class="s1">hd</span>
            <span class="s5">return </span><span class="s1">hd</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>

        <span class="s1">v </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">) / </span><span class="s1">float</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">betacdf </span><span class="s3">= </span><span class="s1">beta</span><span class="s3">.</span><span class="s1">cdf</span>
        <span class="s5">for </span><span class="s3">(</span><span class="s1">i</span><span class="s3">,</span><span class="s1">p</span><span class="s3">) </span><span class="s5">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">prob</span><span class="s3">):</span>
            <span class="s1">_w </span><span class="s3">= </span><span class="s1">betacdf</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, (</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)*</span><span class="s1">p</span><span class="s3">, (</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)*(</span><span class="s6">1</span><span class="s3">-</span><span class="s1">p</span><span class="s3">))</span>
            <span class="s1">w </span><span class="s3">= </span><span class="s1">_w</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:] - </span><span class="s1">_w</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">]</span>
            <span class="s1">hd_mean </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">xsorted</span><span class="s3">)</span>
            <span class="s1">hd</span><span class="s3">[</span><span class="s6">0</span><span class="s3">,</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">hd_mean</span>
            <span class="s2">#</span>
            <span class="s1">hd</span><span class="s3">[</span><span class="s6">1</span><span class="s3">,</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, (</span><span class="s1">xsorted</span><span class="s3">-</span><span class="s1">hd_mean</span><span class="s3">)**</span><span class="s6">2</span><span class="s3">)</span>
            <span class="s2">#</span>
        <span class="s1">hd</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s1">prob </span><span class="s3">== </span><span class="s6">0</span><span class="s3">] = </span><span class="s1">xsorted</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">hd</span><span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s1">prob </span><span class="s3">== </span><span class="s6">1</span><span class="s3">] = </span><span class="s1">xsorted</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s5">if </span><span class="s1">var</span><span class="s3">:</span>
            <span class="s1">hd</span><span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s1">prob </span><span class="s3">== </span><span class="s6">0</span><span class="s3">] = </span><span class="s1">hd</span><span class="s3">[</span><span class="s6">1</span><span class="s3">, </span><span class="s1">prob </span><span class="s3">== </span><span class="s6">1</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
            <span class="s5">return </span><span class="s1">hd</span>
        <span class="s5">return </span><span class="s1">hd</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
    <span class="s2"># Initialization &amp; checks</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">False</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">prob</span><span class="s3">))</span>
    <span class="s2"># Computes quantiles along axis (or globally)</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s1">axis </span><span class="s5">is None</span><span class="s3">) </span><span class="s5">or </span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s6">1</span><span class="s3">):</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">_hd_1D</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">var</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Array 'data' must be at most two dimensional, &quot;</span>
                             <span class="s4">&quot;but got data.ndim = %d&quot; </span><span class="s3">% </span><span class="s1">data</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">apply_along_axis</span><span class="s3">(</span><span class="s1">_hd_1D</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">var</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">fix_invalid</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">False</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">hdmedian</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s6">1</span><span class="s3">, </span><span class="s1">var</span><span class="s3">=</span><span class="s5">False</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns the Harrell-Davis estimate of the median along the given axis. 
 
    Parameters 
    ---------- 
    data : ndarray 
        Data array. 
    axis : int, optional 
        Axis along which to compute the quantiles. If None, use a flattened 
        array. 
    var : bool, optional 
        Whether to return the variance of the estimate. 
 
    Returns 
    ------- 
    hdmedian : MaskedArray 
        The median values.  If ``var=True``, the variance is returned inside 
        the masked array.  E.g. for a 1-D array the shape change from (1,) to 
        (2,). 
 
    &quot;&quot;&quot;</span>
    <span class="s1">result </span><span class="s3">= </span><span class="s1">hdquantiles</span><span class="s3">(</span><span class="s1">data</span><span class="s3">,[</span><span class="s6">0.5</span><span class="s3">], </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">var</span><span class="s3">=</span><span class="s1">var</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s1">result</span><span class="s3">.</span><span class="s1">squeeze</span><span class="s3">()</span>


<span class="s5">def </span><span class="s1">hdquantiles_sd</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">=</span><span class="s1">list</span><span class="s3">([</span><span class="s6">.25</span><span class="s3">,</span><span class="s6">.5</span><span class="s3">,</span><span class="s6">.75</span><span class="s3">]), </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    The standard error of the Harrell-Davis quantile estimates by jackknife. 
 
    Parameters 
    ---------- 
    data : array_like 
        Data array. 
    prob : sequence, optional 
        Sequence of quantiles to compute. 
    axis : int, optional 
        Axis along which to compute the quantiles. If None, use a flattened 
        array. 
 
    Returns 
    ------- 
    hdquantiles_sd : MaskedArray 
        Standard error of the Harrell-Davis quantile estimates. 
 
    See Also 
    -------- 
    hdquantiles 
 
    &quot;&quot;&quot;</span>
    <span class="s5">def </span><span class="s1">_hdsd_1D</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">):</span>
        <span class="s0">&quot;Computes the std error for 1D arrays.&quot;</span>
        <span class="s1">xsorted </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">compressed</span><span class="s3">())</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">xsorted</span><span class="s3">)</span>

        <span class="s1">hdsd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">prob</span><span class="s3">), </span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">hdsd</span><span class="s3">.</span><span class="s1">flat </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>

        <span class="s1">vv </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) / </span><span class="s1">float</span><span class="s3">(</span><span class="s1">n</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)</span>
        <span class="s1">betacdf </span><span class="s3">= </span><span class="s1">beta</span><span class="s3">.</span><span class="s1">cdf</span>

        <span class="s5">for </span><span class="s3">(</span><span class="s1">i</span><span class="s3">,</span><span class="s1">p</span><span class="s3">) </span><span class="s5">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">prob</span><span class="s3">):</span>
            <span class="s1">_w </span><span class="s3">= </span><span class="s1">betacdf</span><span class="s3">(</span><span class="s1">vv</span><span class="s3">, </span><span class="s1">n</span><span class="s3">*</span><span class="s1">p</span><span class="s3">, </span><span class="s1">n</span><span class="s3">*(</span><span class="s6">1</span><span class="s3">-</span><span class="s1">p</span><span class="s3">))</span>
            <span class="s1">w </span><span class="s3">= </span><span class="s1">_w</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:] - </span><span class="s1">_w</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">]</span>
            <span class="s2"># cumulative sum of weights and data points if</span>
            <span class="s2"># ith point is left out for jackknife</span>
            <span class="s1">mx_ </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">xsorted</span><span class="s3">)</span>
            <span class="s1">mx_</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cumsum</span><span class="s3">(</span><span class="s1">w </span><span class="s3">* </span><span class="s1">xsorted</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">])</span>
            <span class="s2"># similar but from the right</span>
            <span class="s1">mx_</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">] += </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cumsum</span><span class="s3">(</span><span class="s1">w</span><span class="s3">[::-</span><span class="s6">1</span><span class="s3">] * </span><span class="s1">xsorted</span><span class="s3">[:</span><span class="s6">0</span><span class="s3">:-</span><span class="s6">1</span><span class="s3">])[::-</span><span class="s6">1</span><span class="s3">]</span>
            <span class="s1">hdsd</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">mx_</span><span class="s3">.</span><span class="s1">var</span><span class="s3">() * (</span><span class="s1">n </span><span class="s3">- </span><span class="s6">1</span><span class="s3">))</span>
        <span class="s5">return </span><span class="s1">hdsd</span>

    <span class="s2"># Initialization &amp; checks</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">False</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">prob</span><span class="s3">))</span>
    <span class="s2"># Computes quantiles along axis (or globally)</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s1">axis </span><span class="s5">is None</span><span class="s3">):</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">_hdsd_1D</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Array 'data' must be at most two dimensional, &quot;</span>
                             <span class="s4">&quot;but got data.ndim = %d&quot; </span><span class="s3">% </span><span class="s1">data</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">apply_along_axis</span><span class="s3">(</span><span class="s1">_hdsd_1D</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">fix_invalid</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">False</span><span class="s3">).</span><span class="s1">ravel</span><span class="s3">()</span>


<span class="s5">def </span><span class="s1">trimmed_mean_ci</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=(</span><span class="s6">0.2</span><span class="s3">,</span><span class="s6">0.2</span><span class="s3">), </span><span class="s1">inclusive</span><span class="s3">=(</span><span class="s5">True</span><span class="s3">,</span><span class="s5">True</span><span class="s3">),</span>
                    <span class="s1">alpha</span><span class="s3">=</span><span class="s6">0.05</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Selected confidence interval of the trimmed mean along the given axis. 
 
    Parameters 
    ---------- 
    data : array_like 
        Input data. 
    limits : {None, tuple}, optional 
        None or a two item tuple. 
        Tuple of the percentages to cut on each side of the array, with respect 
        to the number of unmasked data, as floats between 0. and 1. If ``n`` 
        is the number of unmasked data before trimming, then 
        (``n * limits[0]``)th smallest data and (``n * limits[1]``)th 
        largest data are masked.  The total number of unmasked data after 
        trimming is ``n * (1. - sum(limits))``. 
        The value of one limit can be set to None to indicate an open interval. 
 
        Defaults to (0.2, 0.2). 
    inclusive : (2,) tuple of boolean, optional 
        If relative==False, tuple indicating whether values exactly equal to 
        the absolute limits are allowed. 
        If relative==True, tuple indicating whether the number of data being 
        masked on each side should be rounded (True) or truncated (False). 
 
        Defaults to (True, True). 
    alpha : float, optional 
        Confidence level of the intervals. 
 
        Defaults to 0.05. 
    axis : int, optional 
        Axis along which to cut. If None, uses a flattened version of `data`. 
 
        Defaults to None. 
 
    Returns 
    ------- 
    trimmed_mean_ci : (2,) ndarray 
        The lower and upper confidence intervals of the trimmed data. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">False</span><span class="s3">)</span>
    <span class="s1">trimmed </span><span class="s3">= </span><span class="s1">mstats</span><span class="s3">.</span><span class="s1">trimr</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">limits</span><span class="s3">=</span><span class="s1">limits</span><span class="s3">, </span><span class="s1">inclusive</span><span class="s3">=</span><span class="s1">inclusive</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">tmean </span><span class="s3">= </span><span class="s1">trimmed</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">tstde </span><span class="s3">= </span><span class="s1">mstats</span><span class="s3">.</span><span class="s1">trimmed_stde</span><span class="s3">(</span><span class="s1">data</span><span class="s3">,</span><span class="s1">limits</span><span class="s3">=</span><span class="s1">limits</span><span class="s3">,</span><span class="s1">inclusive</span><span class="s3">=</span><span class="s1">inclusive</span><span class="s3">,</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">df </span><span class="s3">= </span><span class="s1">trimmed</span><span class="s3">.</span><span class="s1">count</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">) - </span><span class="s6">1</span>
    <span class="s1">tppf </span><span class="s3">= </span><span class="s1">t</span><span class="s3">.</span><span class="s1">ppf</span><span class="s3">(</span><span class="s6">1</span><span class="s3">-</span><span class="s1">alpha</span><span class="s3">/</span><span class="s6">2.</span><span class="s3">,</span><span class="s1">df</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">((</span><span class="s1">tmean </span><span class="s3">- </span><span class="s1">tppf</span><span class="s3">*</span><span class="s1">tstde</span><span class="s3">, </span><span class="s1">tmean</span><span class="s3">+</span><span class="s1">tppf</span><span class="s3">*</span><span class="s1">tstde</span><span class="s3">))</span>


<span class="s5">def </span><span class="s1">mjci</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">=[</span><span class="s6">0.25</span><span class="s3">,</span><span class="s6">0.5</span><span class="s3">,</span><span class="s6">0.75</span><span class="s3">], </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns the Maritz-Jarrett estimators of the standard error of selected 
    experimental quantiles of the data. 
 
    Parameters 
    ---------- 
    data : ndarray 
        Data array. 
    prob : sequence, optional 
        Sequence of quantiles to compute. 
    axis : int or None, optional 
        Axis along which to compute the quantiles. If None, use a flattened 
        array. 
 
    &quot;&quot;&quot;</span>
    <span class="s5">def </span><span class="s1">_mjci_1D</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">compressed</span><span class="s3">())</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">size</span>
        <span class="s1">prob </span><span class="s3">= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) * </span><span class="s1">n </span><span class="s3">+ </span><span class="s6">0.5</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
        <span class="s1">betacdf </span><span class="s3">= </span><span class="s1">beta</span><span class="s3">.</span><span class="s1">cdf</span>

        <span class="s1">mj </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">prob</span><span class="s3">), </span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">1</span><span class="s3">,</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float64</span><span class="s3">) / </span><span class="s1">n</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">x </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">/</span><span class="s1">n</span>
        <span class="s5">for </span><span class="s3">(</span><span class="s1">i</span><span class="s3">,</span><span class="s1">m</span><span class="s3">) </span><span class="s5">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">prob</span><span class="s3">):</span>
            <span class="s1">W </span><span class="s3">= </span><span class="s1">betacdf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">,</span><span class="s1">m</span><span class="s3">-</span><span class="s6">1</span><span class="s3">,</span><span class="s1">n</span><span class="s3">-</span><span class="s1">m</span><span class="s3">) - </span><span class="s1">betacdf</span><span class="s3">(</span><span class="s1">y</span><span class="s3">,</span><span class="s1">m</span><span class="s3">-</span><span class="s6">1</span><span class="s3">,</span><span class="s1">n</span><span class="s3">-</span><span class="s1">m</span><span class="s3">)</span>
            <span class="s1">C1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">W</span><span class="s3">,</span><span class="s1">data</span><span class="s3">)</span>
            <span class="s1">C2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">W</span><span class="s3">,</span><span class="s1">data</span><span class="s3">**</span><span class="s6">2</span><span class="s3">)</span>
            <span class="s1">mj</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">C2 </span><span class="s3">- </span><span class="s1">C1</span><span class="s3">**</span><span class="s6">2</span><span class="s3">)</span>
        <span class="s5">return </span><span class="s1">mj</span>

    <span class="s1">data </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">False</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s6">2</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Array 'data' must be at most two dimensional, &quot;</span>
                         <span class="s4">&quot;but got data.ndim = %d&quot; </span><span class="s3">% </span><span class="s1">data</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>

    <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">prob</span><span class="s3">))</span>
    <span class="s2"># Computes quantiles along axis (or globally)</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s1">axis </span><span class="s5">is None</span><span class="s3">):</span>
        <span class="s5">return </span><span class="s1">_mjci_1D</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">apply_along_axis</span><span class="s3">(</span><span class="s1">_mjci_1D</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">mquantiles_cimj</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">=[</span><span class="s6">0.25</span><span class="s3">,</span><span class="s6">0.50</span><span class="s3">,</span><span class="s6">0.75</span><span class="s3">], </span><span class="s1">alpha</span><span class="s3">=</span><span class="s6">0.05</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes the alpha confidence interval for the selected quantiles of the 
    data, with Maritz-Jarrett estimators. 
 
    Parameters 
    ---------- 
    data : ndarray 
        Data array. 
    prob : sequence, optional 
        Sequence of quantiles to compute. 
    alpha : float, optional 
        Confidence level of the intervals. 
    axis : int or None, optional 
        Axis along which to compute the quantiles. 
        If None, use a flattened array. 
 
    Returns 
    ------- 
    ci_lower : ndarray 
        The lower boundaries of the confidence interval.  Of the same length as 
        `prob`. 
    ci_upper : ndarray 
        The upper boundaries of the confidence interval.  Of the same length as 
        `prob`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">alpha </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">alpha</span><span class="s3">, </span><span class="s6">1 </span><span class="s3">- </span><span class="s1">alpha</span><span class="s3">)</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">norm</span><span class="s3">.</span><span class="s1">ppf</span><span class="s3">(</span><span class="s6">1 </span><span class="s3">- </span><span class="s1">alpha</span><span class="s3">/</span><span class="s6">2.</span><span class="s3">)</span>
    <span class="s1">xq </span><span class="s3">= </span><span class="s1">mstats</span><span class="s3">.</span><span class="s1">mquantiles</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">, </span><span class="s1">alphap</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">betap</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">smj </span><span class="s3">= </span><span class="s1">mjci</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s3">(</span><span class="s1">xq </span><span class="s3">- </span><span class="s1">z </span><span class="s3">* </span><span class="s1">smj</span><span class="s3">, </span><span class="s1">xq </span><span class="s3">+ </span><span class="s1">z </span><span class="s3">* </span><span class="s1">smj</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">median_cihs</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">=</span><span class="s6">0.05</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes the alpha-level confidence interval for the median of the data. 
 
    Uses the Hettmasperger-Sheather method. 
 
    Parameters 
    ---------- 
    data : array_like 
        Input data. Masked values are discarded. The input should be 1D only, 
        or `axis` should be set to None. 
    alpha : float, optional 
        Confidence level of the intervals. 
    axis : int or None, optional 
        Axis along which to compute the quantiles. If None, use a flattened 
        array. 
 
    Returns 
    ------- 
    median_cihs 
        Alpha level confidence interval. 
 
    &quot;&quot;&quot;</span>
    <span class="s5">def </span><span class="s1">_cihs_1D</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">):</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">compressed</span><span class="s3">())</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
        <span class="s1">alpha </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">alpha</span><span class="s3">, </span><span class="s6">1</span><span class="s3">-</span><span class="s1">alpha</span><span class="s3">)</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">binom</span><span class="s3">.</span><span class="s1">_ppf</span><span class="s3">(</span><span class="s1">alpha</span><span class="s3">/</span><span class="s6">2.</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s6">0.5</span><span class="s3">))</span>
        <span class="s1">gk </span><span class="s3">= </span><span class="s1">binom</span><span class="s3">.</span><span class="s1">cdf</span><span class="s3">(</span><span class="s1">n</span><span class="s3">-</span><span class="s1">k</span><span class="s3">,</span><span class="s1">n</span><span class="s3">,</span><span class="s6">0.5</span><span class="s3">) - </span><span class="s1">binom</span><span class="s3">.</span><span class="s1">cdf</span><span class="s3">(</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">,</span><span class="s1">n</span><span class="s3">,</span><span class="s6">0.5</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">gk </span><span class="s3">&lt; </span><span class="s6">1</span><span class="s3">-</span><span class="s1">alpha</span><span class="s3">:</span>
            <span class="s1">k </span><span class="s3">-= </span><span class="s6">1</span>
            <span class="s1">gk </span><span class="s3">= </span><span class="s1">binom</span><span class="s3">.</span><span class="s1">cdf</span><span class="s3">(</span><span class="s1">n</span><span class="s3">-</span><span class="s1">k</span><span class="s3">,</span><span class="s1">n</span><span class="s3">,</span><span class="s6">0.5</span><span class="s3">) - </span><span class="s1">binom</span><span class="s3">.</span><span class="s1">cdf</span><span class="s3">(</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">,</span><span class="s1">n</span><span class="s3">,</span><span class="s6">0.5</span><span class="s3">)</span>
        <span class="s1">gkk </span><span class="s3">= </span><span class="s1">binom</span><span class="s3">.</span><span class="s1">cdf</span><span class="s3">(</span><span class="s1">n</span><span class="s3">-</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">,</span><span class="s1">n</span><span class="s3">,</span><span class="s6">0.5</span><span class="s3">) - </span><span class="s1">binom</span><span class="s3">.</span><span class="s1">cdf</span><span class="s3">(</span><span class="s1">k</span><span class="s3">,</span><span class="s1">n</span><span class="s3">,</span><span class="s6">0.5</span><span class="s3">)</span>
        <span class="s1">I </span><span class="s3">= (</span><span class="s1">gk </span><span class="s3">- </span><span class="s6">1 </span><span class="s3">+ </span><span class="s1">alpha</span><span class="s3">)/(</span><span class="s1">gk </span><span class="s3">- </span><span class="s1">gkk</span><span class="s3">)</span>
        <span class="s1">lambd </span><span class="s3">= (</span><span class="s1">n</span><span class="s3">-</span><span class="s1">k</span><span class="s3">) * </span><span class="s1">I </span><span class="s3">/ </span><span class="s1">float</span><span class="s3">(</span><span class="s1">k </span><span class="s3">+ (</span><span class="s1">n</span><span class="s3">-</span><span class="s6">2</span><span class="s3">*</span><span class="s1">k</span><span class="s3">)*</span><span class="s1">I</span><span class="s3">)</span>
        <span class="s1">lims </span><span class="s3">= (</span><span class="s1">lambd</span><span class="s3">*</span><span class="s1">data</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] + (</span><span class="s6">1</span><span class="s3">-</span><span class="s1">lambd</span><span class="s3">)*</span><span class="s1">data</span><span class="s3">[</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">],</span>
                <span class="s1">lambd</span><span class="s3">*</span><span class="s1">data</span><span class="s3">[</span><span class="s1">n</span><span class="s3">-</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">] + (</span><span class="s6">1</span><span class="s3">-</span><span class="s1">lambd</span><span class="s3">)*</span><span class="s1">data</span><span class="s3">[</span><span class="s1">n</span><span class="s3">-</span><span class="s1">k</span><span class="s3">])</span>
        <span class="s5">return </span><span class="s1">lims</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">False</span><span class="s3">)</span>
    <span class="s2"># Computes quantiles along axis (or globally)</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s1">axis </span><span class="s5">is None</span><span class="s3">):</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">_cihs_1D</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Array 'data' must be at most two dimensional, &quot;</span>
                             <span class="s4">&quot;but got data.ndim = %d&quot; </span><span class="s3">% </span><span class="s1">data</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">apply_along_axis</span><span class="s3">(</span><span class="s1">_cihs_1D</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">)</span>

    <span class="s5">return </span><span class="s1">result</span>


<span class="s5">def </span><span class="s1">compare_medians_ms</span><span class="s3">(</span><span class="s1">group_1</span><span class="s3">, </span><span class="s1">group_2</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compares the medians from two independent groups along the given axis. 
 
    The comparison is performed using the McKean-Schrader estimate of the 
    standard error of the medians. 
 
    Parameters 
    ---------- 
    group_1 : array_like 
        First dataset.  Has to be of size &gt;=7. 
    group_2 : array_like 
        Second dataset.  Has to be of size &gt;=7. 
    axis : int, optional 
        Axis along which the medians are estimated. If None, the arrays are 
        flattened.  If `axis` is not None, then `group_1` and `group_2` 
        should have the same shape. 
 
    Returns 
    ------- 
    compare_medians_ms : {float, ndarray} 
        If `axis` is None, then returns a float, otherwise returns a 1-D 
        ndarray of floats with a length equal to the length of `group_1` 
        along `axis`. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6, 7] 
    &gt;&gt;&gt; b = [8, 9, 10, 11, 12, 13, 14] 
    &gt;&gt;&gt; stats.mstats.compare_medians_ms(a, b, axis=None) 
    1.0693225866553746e-05 
 
    The function is vectorized to compute along a given axis. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; x = rng.random(size=(3, 7)) 
    &gt;&gt;&gt; y = rng.random(size=(3, 8)) 
    &gt;&gt;&gt; stats.mstats.compare_medians_ms(x, y, axis=1) 
    array([0.36908985, 0.36092538, 0.2765313 ]) 
 
    References 
    ---------- 
    .. [1] McKean, Joseph W., and Ronald M. Schrader. &quot;A comparison of methods 
       for studentizing the sample median.&quot; Communications in 
       Statistics-Simulation and Computation 13.6 (1984): 751-773. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">(</span><span class="s1">med_1</span><span class="s3">, </span><span class="s1">med_2</span><span class="s3">) = (</span><span class="s1">ma</span><span class="s3">.</span><span class="s1">median</span><span class="s3">(</span><span class="s1">group_1</span><span class="s3">,</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">), </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">median</span><span class="s3">(</span><span class="s1">group_2</span><span class="s3">,</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">))</span>
    <span class="s3">(</span><span class="s1">std_1</span><span class="s3">, </span><span class="s1">std_2</span><span class="s3">) = (</span><span class="s1">mstats</span><span class="s3">.</span><span class="s1">stde_median</span><span class="s3">(</span><span class="s1">group_1</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">),</span>
                      <span class="s1">mstats</span><span class="s3">.</span><span class="s1">stde_median</span><span class="s3">(</span><span class="s1">group_2</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">))</span>
    <span class="s1">W </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">med_1 </span><span class="s3">- </span><span class="s1">med_2</span><span class="s3">) / </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">std_1</span><span class="s3">**</span><span class="s6">2 </span><span class="s3">+ </span><span class="s1">std_2</span><span class="s3">**</span><span class="s6">2</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s6">1 </span><span class="s3">- </span><span class="s1">norm</span><span class="s3">.</span><span class="s1">cdf</span><span class="s3">(</span><span class="s1">W</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">idealfourths</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns an estimate of the lower and upper quartiles. 
 
    Uses the ideal fourths algorithm. 
 
    Parameters 
    ---------- 
    data : array_like 
        Input array. 
    axis : int, optional 
        Axis along which the quartiles are estimated. If None, the arrays are 
        flattened. 
 
    Returns 
    ------- 
    idealfourths : {list of floats, masked array} 
        Returns the two internal values that divide `data` into four parts 
        using the ideal fourths algorithm either along the flattened array 
        (if `axis` is None) or along `axis` of `data`. 
 
    &quot;&quot;&quot;</span>
    <span class="s5">def </span><span class="s1">_idf</span><span class="s3">(</span><span class="s1">data</span><span class="s3">):</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">compressed</span><span class="s3">()</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">n </span><span class="s3">&lt; </span><span class="s6">3</span><span class="s3">:</span>
            <span class="s5">return </span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">,</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">]</span>
        <span class="s3">(</span><span class="s1">j</span><span class="s3">,</span><span class="s1">h</span><span class="s3">) = </span><span class="s1">divmod</span><span class="s3">(</span><span class="s1">n</span><span class="s3">/</span><span class="s6">4. </span><span class="s3">+ </span><span class="s6">5</span><span class="s3">/</span><span class="s6">12.</span><span class="s3">,</span><span class="s6">1</span><span class="s3">)</span>
        <span class="s1">j </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">j</span><span class="s3">)</span>
        <span class="s1">qlo </span><span class="s3">= (</span><span class="s6">1</span><span class="s3">-</span><span class="s1">h</span><span class="s3">)*</span><span class="s1">x</span><span class="s3">[</span><span class="s1">j</span><span class="s3">-</span><span class="s6">1</span><span class="s3">] + </span><span class="s1">h</span><span class="s3">*</span><span class="s1">x</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">n </span><span class="s3">- </span><span class="s1">j</span>
        <span class="s1">qup </span><span class="s3">= (</span><span class="s6">1</span><span class="s3">-</span><span class="s1">h</span><span class="s3">)*</span><span class="s1">x</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] + </span><span class="s1">h</span><span class="s3">*</span><span class="s1">x</span><span class="s3">[</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s5">return </span><span class="s3">[</span><span class="s1">qlo</span><span class="s3">, </span><span class="s1">qup</span><span class="s3">]</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">).</span><span class="s1">view</span><span class="s3">(</span><span class="s1">MaskedArray</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s3">(</span><span class="s1">axis </span><span class="s5">is None</span><span class="s3">):</span>
        <span class="s5">return </span><span class="s1">_idf</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s5">return </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">apply_along_axis</span><span class="s3">(</span><span class="s1">_idf</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">data</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">rsh</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">points</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Evaluates Rosenblatt's shifted histogram estimators for each data point. 
 
    Rosenblatt's estimator is a centered finite-difference approximation to the 
    derivative of the empirical cumulative distribution function. 
 
    Parameters 
    ---------- 
    data : sequence 
        Input data, should be 1-D. Masked values are ignored. 
    points : sequence or None, optional 
        Sequence of points where to evaluate Rosenblatt shifted histogram. 
        If None, use the data. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">ma</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s5">False</span><span class="s3">)</span>
    <span class="s5">if </span><span class="s1">points </span><span class="s5">is None</span><span class="s3">:</span>
        <span class="s1">points </span><span class="s3">= </span><span class="s1">data</span>
    <span class="s5">else</span><span class="s3">:</span>
        <span class="s1">points </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">points</span><span class="s3">))</span>

    <span class="s5">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">AttributeError</span><span class="s3">(</span><span class="s4">&quot;The input array should be 1D only !&quot;</span><span class="s3">)</span>

    <span class="s1">n </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">count</span><span class="s3">()</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s1">idealfourths</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">None</span><span class="s3">)</span>
    <span class="s1">h </span><span class="s3">= </span><span class="s6">1.2 </span><span class="s3">* (</span><span class="s1">r</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]-</span><span class="s1">r</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]) / </span><span class="s1">n</span><span class="s3">**(</span><span class="s6">1.</span><span class="s3">/</span><span class="s6">5</span><span class="s3">)</span>
    <span class="s1">nhi </span><span class="s3">= (</span><span class="s1">data</span><span class="s3">[:,</span><span class="s5">None</span><span class="s3">] &lt;= </span><span class="s1">points</span><span class="s3">[</span><span class="s5">None</span><span class="s3">,:] + </span><span class="s1">h</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s1">nlo </span><span class="s3">= (</span><span class="s1">data</span><span class="s3">[:,</span><span class="s5">None</span><span class="s3">] &lt; </span><span class="s1">points</span><span class="s3">[</span><span class="s5">None</span><span class="s3">,:] - </span><span class="s1">h</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">(</span><span class="s6">0</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s3">(</span><span class="s1">nhi</span><span class="s3">-</span><span class="s1">nlo</span><span class="s3">) / (</span><span class="s6">2.</span><span class="s3">*</span><span class="s1">n</span><span class="s3">*</span><span class="s1">h</span><span class="s3">)</span>
</pre>
</body>
</html>