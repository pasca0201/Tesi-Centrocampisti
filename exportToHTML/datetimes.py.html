<html>
<head>
<title>datetimes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
datetimes.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">datetime </span><span class="s0">as </span><span class="s1">dt</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytz</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">Period</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">index </span><span class="s0">as </span><span class="s1">libindex</span><span class="s2">,</span>
    <span class="s1">lib</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs</span><span class="s2">.</span><span class="s1">tslibs </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">Resolution</span><span class="s2">,</span>
    <span class="s1">Tick</span><span class="s2">,</span>
    <span class="s1">Timedelta</span><span class="s2">,</span>
    <span class="s1">periods_per_day</span><span class="s2">,</span>
    <span class="s1">timezones</span><span class="s2">,</span>
    <span class="s1">to_offset</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs</span><span class="s2">.</span><span class="s1">tslibs</span><span class="s2">.</span><span class="s1">offsets </span><span class="s0">import </span><span class="s1">prefix_mapping</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">util</span><span class="s2">.</span><span class="s1">_decorators </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">cache_readonly</span><span class="s2">,</span>
    <span class="s1">doc</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">util</span><span class="s2">.</span><span class="s1">_exceptions </span><span class="s0">import </span><span class="s1">find_stack_level</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">common </span><span class="s0">import </span><span class="s1">is_scalar</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">dtypes </span><span class="s0">import </span><span class="s1">DatetimeTZDtype</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">generic </span><span class="s0">import </span><span class="s1">ABCSeries</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">dtypes</span><span class="s2">.</span><span class="s1">missing </span><span class="s0">import </span><span class="s1">is_valid_na_for_dtype</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">arrays</span><span class="s2">.</span><span class="s1">datetimes </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">DatetimeArray</span><span class="s2">,</span>
    <span class="s1">tz_to_dtype</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">import </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">common </span><span class="s0">as </span><span class="s1">com</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">indexes</span><span class="s2">.</span><span class="s1">base </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">maybe_extract_name</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">indexes</span><span class="s2">.</span><span class="s1">datetimelike </span><span class="s0">import </span><span class="s1">DatetimeTimedeltaMixin</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">indexes</span><span class="s2">.</span><span class="s1">extension </span><span class="s0">import </span><span class="s1">inherit_names</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">tools</span><span class="s2">.</span><span class="s1">times </span><span class="s0">import </span><span class="s1">to_time</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s1">Hashable</span>

    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_typing </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">Dtype</span><span class="s2">,</span>
        <span class="s1">DtypeObj</span><span class="s2">,</span>
        <span class="s1">Frequency</span><span class="s2">,</span>
        <span class="s1">IntervalClosedType</span><span class="s2">,</span>
        <span class="s1">Self</span><span class="s2">,</span>
        <span class="s1">TimeAmbiguous</span><span class="s2">,</span>
        <span class="s1">TimeNonexistent</span><span class="s2">,</span>
        <span class="s1">npt</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">api </span><span class="s0">import </span><span class="s2">(</span>
        <span class="s1">DataFrame</span><span class="s2">,</span>
        <span class="s1">PeriodIndex</span><span class="s2">,</span>
    <span class="s2">)</span>

<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_libs</span><span class="s2">.</span><span class="s1">tslibs</span><span class="s2">.</span><span class="s1">dtypes </span><span class="s0">import </span><span class="s1">OFFSET_TO_PERIOD_FREQSTR</span>


<span class="s0">def </span><span class="s1">_new_DatetimeIndex</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">d</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    This is called upon unpickling, rather than the default which doesn't 
    have arguments and breaks __new__ 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s4">&quot;data&quot; </span><span class="s0">in </span><span class="s1">d </span><span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">d</span><span class="s2">[</span><span class="s4">&quot;data&quot;</span><span class="s2">], </span><span class="s1">DatetimeIndex</span><span class="s2">):</span>
        <span class="s5"># Avoid need to verify integrity by calling simple_new directly</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">d</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s4">&quot;data&quot;</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">DatetimeArray</span><span class="s2">):</span>
            <span class="s5"># For backward compat with older pickles, we may need to construct</span>
            <span class="s5">#  a DatetimeArray to adapt to the newer _simple_new signature</span>
            <span class="s1">tz </span><span class="s2">= </span><span class="s1">d</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s4">&quot;tz&quot;</span><span class="s2">)</span>
            <span class="s1">freq </span><span class="s2">= </span><span class="s1">d</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s4">&quot;freq&quot;</span><span class="s2">)</span>
            <span class="s1">dta </span><span class="s2">= </span><span class="s1">DatetimeArray</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">tz_to_dtype</span><span class="s2">(</span><span class="s1">tz</span><span class="s2">), </span><span class="s1">freq</span><span class="s2">=</span><span class="s1">freq</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">dta </span><span class="s2">= </span><span class="s1">data</span>
            <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s2">[</span><span class="s4">&quot;tz&quot;</span><span class="s2">, </span><span class="s4">&quot;freq&quot;</span><span class="s2">]:</span>
                <span class="s5"># These are already stored in our DatetimeArray; if they are</span>
                <span class="s5">#  also in the pickle and don't match, we have a problem.</span>
                <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">d</span><span class="s2">:</span>
                    <span class="s0">assert </span><span class="s1">d</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] == </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">dta</span><span class="s2">, </span><span class="s1">key</span><span class="s2">)</span>
                    <span class="s1">d</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">dta</span><span class="s2">, **</span><span class="s1">d</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">warnings</span><span class="s2">.</span><span class="s1">catch_warnings</span><span class="s2">():</span>
            <span class="s5"># TODO: If we knew what was going in to **d, we might be able to</span>
            <span class="s5">#  go through _simple_new instead</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">simplefilter</span><span class="s2">(</span><span class="s4">&quot;ignore&quot;</span><span class="s2">)</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__new__</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, **</span><span class="s1">d</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s2">@</span><span class="s1">inherit_names</span><span class="s2">(</span>
    <span class="s1">DatetimeArray</span><span class="s2">.</span><span class="s1">_field_ops</span>
    <span class="s2">+ [</span>
        <span class="s1">method</span>
        <span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s1">DatetimeArray</span><span class="s2">.</span><span class="s1">_datetimelike_methods</span>
        <span class="s0">if </span><span class="s1">method </span><span class="s0">not in </span><span class="s2">(</span><span class="s4">&quot;tz_localize&quot;</span><span class="s2">, </span><span class="s4">&quot;tz_convert&quot;</span><span class="s2">, </span><span class="s4">&quot;strftime&quot;</span><span class="s2">)</span>
    <span class="s2">],</span>
    <span class="s1">DatetimeArray</span><span class="s2">,</span>
    <span class="s1">wrap</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s2">@</span><span class="s1">inherit_names</span><span class="s2">([</span><span class="s4">&quot;is_normalized&quot;</span><span class="s2">], </span><span class="s1">DatetimeArray</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
<span class="s2">@</span><span class="s1">inherit_names</span><span class="s2">(</span>
    <span class="s2">[</span>
        <span class="s4">&quot;tz&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;tzinfo&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;dtype&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;to_pydatetime&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;date&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;time&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;timetz&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;std&quot;</span><span class="s2">,</span>
    <span class="s2">]</span>
    <span class="s2">+ </span><span class="s1">DatetimeArray</span><span class="s2">.</span><span class="s1">_bool_ops</span><span class="s2">,</span>
    <span class="s1">DatetimeArray</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">class </span><span class="s1">DatetimeIndex</span><span class="s2">(</span><span class="s1">DatetimeTimedeltaMixin</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Immutable ndarray-like of datetime64 data. 
 
    Represented internally as int64, and which can be boxed to Timestamp objects 
    that are subclasses of datetime and carry metadata. 
 
    .. versionchanged:: 2.0.0 
        The various numeric date/time attributes (:attr:`~DatetimeIndex.day`, 
        :attr:`~DatetimeIndex.month`, :attr:`~DatetimeIndex.year` etc.) now have dtype 
        ``int32``. Previously they had dtype ``int64``. 
 
    Parameters 
    ---------- 
    data : array-like (1-dimensional) 
        Datetime-like data to construct index with. 
    freq : str or pandas offset object, optional 
        One of pandas date offset strings or corresponding objects. The string 
        'infer' can be passed in order to set the frequency of the index as the 
        inferred frequency upon creation. 
    tz : pytz.timezone or dateutil.tz.tzfile or datetime.tzinfo or str 
        Set the Timezone of the data. 
    normalize : bool, default False 
        Normalize start/end dates to midnight before generating date range. 
 
        .. deprecated:: 2.1.0 
 
    closed : {'left', 'right'}, optional 
        Set whether to include `start` and `end` that are on the 
        boundary. The default includes boundary points on either end. 
 
        .. deprecated:: 2.1.0 
 
    ambiguous : 'infer', bool-ndarray, 'NaT', default 'raise' 
        When clocks moved backward due to DST, ambiguous times may arise. 
        For example in Central European Time (UTC+01), when going from 03:00 
        DST to 02:00 non-DST, 02:30:00 local time occurs both at 00:30:00 UTC 
        and at 01:30:00 UTC. In such a situation, the `ambiguous` parameter 
        dictates how ambiguous times should be handled. 
 
        - 'infer' will attempt to infer fall dst-transition hours based on 
          order 
        - bool-ndarray where True signifies a DST time, False signifies a 
          non-DST time (note that this flag is only applicable for ambiguous 
          times) 
        - 'NaT' will return NaT where there are ambiguous times 
        - 'raise' will raise an AmbiguousTimeError if there are ambiguous times. 
    dayfirst : bool, default False 
        If True, parse dates in `data` with the day first order. 
    yearfirst : bool, default False 
        If True parse dates in `data` with the year first order. 
    dtype : numpy.dtype or DatetimeTZDtype or str, default None 
        Note that the only NumPy dtype allowed is `datetime64[ns]`. 
    copy : bool, default False 
        Make a copy of input ndarray. 
    name : label, default None 
        Name to be stored in the index. 
 
    Attributes 
    ---------- 
    year 
    month 
    day 
    hour 
    minute 
    second 
    microsecond 
    nanosecond 
    date 
    time 
    timetz 
    dayofyear 
    day_of_year 
    dayofweek 
    day_of_week 
    weekday 
    quarter 
    tz 
    freq 
    freqstr 
    is_month_start 
    is_month_end 
    is_quarter_start 
    is_quarter_end 
    is_year_start 
    is_year_end 
    is_leap_year 
    inferred_freq 
 
    Methods 
    ------- 
    normalize 
    strftime 
    snap 
    tz_convert 
    tz_localize 
    round 
    floor 
    ceil 
    to_period 
    to_pydatetime 
    to_series 
    to_frame 
    month_name 
    day_name 
    mean 
    std 
 
    See Also 
    -------- 
    Index : The base pandas Index type. 
    TimedeltaIndex : Index of timedelta64 data. 
    PeriodIndex : Index of Period data. 
    to_datetime : Convert argument to datetime. 
    date_range : Create a fixed-frequency DatetimeIndex. 
 
    Notes 
    ----- 
    To learn more about the frequency strings, please see `this link 
    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`__. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; idx = pd.DatetimeIndex([&quot;1/1/2020 10:00:00+00:00&quot;, &quot;2/1/2020 11:00:00+00:00&quot;]) 
    &gt;&gt;&gt; idx 
    DatetimeIndex(['2020-01-01 10:00:00+00:00', '2020-02-01 11:00:00+00:00'], 
    dtype='datetime64[ns, UTC]', freq=None) 
    &quot;&quot;&quot;</span>

    <span class="s1">_typ </span><span class="s2">= </span><span class="s4">&quot;datetimeindex&quot;</span>

    <span class="s1">_data_cls </span><span class="s2">= </span><span class="s1">DatetimeArray</span>
    <span class="s1">_supports_partial_string_indexing </span><span class="s2">= </span><span class="s0">True</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">_engine_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; type</span><span class="s2">[</span><span class="s1">libindex</span><span class="s2">.</span><span class="s1">DatetimeEngine</span><span class="s2">]:</span>
        <span class="s0">return </span><span class="s1">libindex</span><span class="s2">.</span><span class="s1">DatetimeEngine</span>

    <span class="s1">_data</span><span class="s2">: </span><span class="s1">DatetimeArray</span>
    <span class="s1">_values</span><span class="s2">: </span><span class="s1">DatetimeArray</span>
    <span class="s1">tz</span><span class="s2">: </span><span class="s1">dt</span><span class="s2">.</span><span class="s1">tzinfo </span><span class="s2">| </span><span class="s0">None</span>

    <span class="s5"># --------------------------------------------------------------------</span>
    <span class="s5"># methods that dispatch to DatetimeArray and wrap result</span>

    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">DatetimeArray</span><span class="s2">.</span><span class="s1">strftime</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">strftime</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">date_format</span><span class="s2">) </span><span class="s1">-&gt; Index</span><span class="s2">:</span>
        <span class="s1">arr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">strftime</span><span class="s2">(</span><span class="s1">date_format</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">Index</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">object</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">DatetimeArray</span><span class="s2">.</span><span class="s1">tz_convert</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">tz_convert</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">tz</span><span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s1">arr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">tz_convert</span><span class="s2">(</span><span class="s1">tz</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_references</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">DatetimeArray</span><span class="s2">.</span><span class="s1">tz_localize</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">tz_localize</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">tz</span><span class="s2">,</span>
        <span class="s1">ambiguous</span><span class="s2">: </span><span class="s1">TimeAmbiguous </span><span class="s2">= </span><span class="s4">&quot;raise&quot;</span><span class="s2">,</span>
        <span class="s1">nonexistent</span><span class="s2">: </span><span class="s1">TimeNonexistent </span><span class="s2">= </span><span class="s4">&quot;raise&quot;</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s1">arr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">tz_localize</span><span class="s2">(</span><span class="s1">tz</span><span class="s2">, </span><span class="s1">ambiguous</span><span class="s2">, </span><span class="s1">nonexistent</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">DatetimeArray</span><span class="s2">.</span><span class="s1">to_period</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">to_period</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">freq</span><span class="s2">=</span><span class="s0">None</span><span class="s2">) </span><span class="s1">-&gt; PeriodIndex</span><span class="s2">:</span>
        <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">core</span><span class="s2">.</span><span class="s1">indexes</span><span class="s2">.</span><span class="s1">api </span><span class="s0">import </span><span class="s1">PeriodIndex</span>

        <span class="s1">arr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">to_period</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">PeriodIndex</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">DatetimeArray</span><span class="s2">.</span><span class="s1">to_julian_date</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">to_julian_date</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Index</span><span class="s2">:</span>
        <span class="s1">arr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">to_julian_date</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">Index</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">DatetimeArray</span><span class="s2">.</span><span class="s1">isocalendar</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">isocalendar</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; DataFrame</span><span class="s2">:</span>
        <span class="s1">df </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">isocalendar</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">df</span><span class="s2">.</span><span class="s1">set_index</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">cache_readonly</span>
    <span class="s0">def </span><span class="s1">_resolution_obj</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; Resolution</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">_resolution_obj</span>

    <span class="s5"># --------------------------------------------------------------------</span>
    <span class="s5"># Constructors</span>

    <span class="s0">def </span><span class="s1">__new__</span><span class="s2">(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">data</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">freq</span><span class="s2">: </span><span class="s1">Frequency </span><span class="s2">| </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">NoDefault </span><span class="s2">= </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">,</span>
        <span class="s1">tz</span><span class="s2">=</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">,</span>
        <span class="s1">normalize</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">| </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">NoDefault </span><span class="s2">= </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">,</span>
        <span class="s1">closed</span><span class="s2">=</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">,</span>
        <span class="s1">ambiguous</span><span class="s2">: </span><span class="s1">TimeAmbiguous </span><span class="s2">= </span><span class="s4">&quot;raise&quot;</span><span class="s2">,</span>
        <span class="s1">dayfirst</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">yearfirst</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">dtype</span><span class="s2">: </span><span class="s1">Dtype </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">copy</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">Hashable </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">) </span><span class="s1">-&gt; Self</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">closed </span><span class="s0">is not </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">:</span>
            <span class="s5"># GH#52628</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s4">f&quot;The 'closed' keyword in </span><span class="s0">{</span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">} </span><span class="s4">construction is &quot;</span>
                <span class="s4">&quot;deprecated and will be removed in a future version.&quot;</span><span class="s2">,</span>
                <span class="s1">FutureWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">normalize </span><span class="s0">is not </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span><span class="s2">:</span>
            <span class="s5"># GH#52628</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
                <span class="s4">f&quot;The 'normalize' keyword in </span><span class="s0">{</span><span class="s1">cls</span><span class="s2">.</span><span class="s1">__name__</span><span class="s0">} </span><span class="s4">construction is &quot;</span>
                <span class="s4">&quot;deprecated and will be removed in a future version.&quot;</span><span class="s2">,</span>
                <span class="s1">FutureWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel</span><span class="s2">=</span><span class="s1">find_stack_level</span><span class="s2">(),</span>
            <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">is_scalar</span><span class="s2">(</span><span class="s1">data</span><span class="s2">):</span>
            <span class="s1">cls</span><span class="s2">.</span><span class="s1">_raise_scalar_data_error</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

        <span class="s5"># - Cases checked above all return/raise before reaching here - #</span>

        <span class="s1">name </span><span class="s2">= </span><span class="s1">maybe_extract_name</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">cls</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">isinstance</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">DatetimeArray</span><span class="s2">)</span>
            <span class="s0">and </span><span class="s1">freq </span><span class="s0">is </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span>
            <span class="s0">and </span><span class="s1">tz </span><span class="s0">is </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">no_default</span>
            <span class="s0">and </span><span class="s1">dtype </span><span class="s0">is None</span>
        <span class="s2">):</span>
            <span class="s5"># fastpath, similar logic in TimedeltaIndex.__new__;</span>
            <span class="s5"># Note in this particular case we retain non-nano.</span>
            <span class="s0">if </span><span class="s1">copy</span><span class="s2">:</span>
                <span class="s1">data </span><span class="s2">= </span><span class="s1">data</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s0">return </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">)</span>

        <span class="s1">dtarr </span><span class="s2">= </span><span class="s1">DatetimeArray</span><span class="s2">.</span><span class="s1">_from_sequence_not_strict</span><span class="s2">(</span>
            <span class="s1">data</span><span class="s2">,</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">,</span>
            <span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">,</span>
            <span class="s1">tz</span><span class="s2">=</span><span class="s1">tz</span><span class="s2">,</span>
            <span class="s1">freq</span><span class="s2">=</span><span class="s1">freq</span><span class="s2">,</span>
            <span class="s1">dayfirst</span><span class="s2">=</span><span class="s1">dayfirst</span><span class="s2">,</span>
            <span class="s1">yearfirst</span><span class="s2">=</span><span class="s1">yearfirst</span><span class="s2">,</span>
            <span class="s1">ambiguous</span><span class="s2">=</span><span class="s1">ambiguous</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">refs </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">if not </span><span class="s1">copy </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, (</span><span class="s1">Index</span><span class="s2">, </span><span class="s1">ABCSeries</span><span class="s2">)):</span>
            <span class="s1">refs </span><span class="s2">= </span><span class="s1">data</span><span class="s2">.</span><span class="s1">_references</span>

        <span class="s1">subarr </span><span class="s2">= </span><span class="s1">cls</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">dtarr</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">, </span><span class="s1">refs</span><span class="s2">=</span><span class="s1">refs</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">subarr</span>

    <span class="s5"># --------------------------------------------------------------------</span>

    <span class="s2">@</span><span class="s1">cache_readonly</span>
    <span class="s0">def </span><span class="s1">_is_dates_only</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return a boolean if we are only dates (and don't have a timezone) 
 
        Returns 
        ------- 
        bool 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">Tick</span><span class="s2">):</span>
            <span class="s1">delta </span><span class="s2">= </span><span class="s1">Timedelta</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">freq</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">delta </span><span class="s2">% </span><span class="s1">dt</span><span class="s2">.</span><span class="s1">timedelta</span><span class="s2">(</span><span class="s1">days</span><span class="s2">=</span><span class="s6">1</span><span class="s2">) != </span><span class="s1">dt</span><span class="s2">.</span><span class="s1">timedelta</span><span class="s2">(</span><span class="s1">days</span><span class="s2">=</span><span class="s6">0</span><span class="s2">):</span>
                <span class="s0">return False</span>

        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_values</span><span class="s2">.</span><span class="s1">_is_dates_only</span>

    <span class="s0">def </span><span class="s1">__reduce__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">d </span><span class="s2">= {</span><span class="s4">&quot;data&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">, </span><span class="s4">&quot;name&quot;</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">}</span>
        <span class="s0">return </span><span class="s1">_new_DatetimeIndex</span><span class="s2">, (</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">), </span><span class="s1">d</span><span class="s2">), </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_is_comparable_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">: </span><span class="s1">DtypeObj</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Can we compare values of the given dtype to our own? 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tz </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s5"># If we have tz, we can compare to tzaware</span>
            <span class="s0">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">DatetimeTZDtype</span><span class="s2">)</span>
        <span class="s5"># if we dont have tz, we can only compare to tznaive</span>
        <span class="s0">return </span><span class="s1">lib</span><span class="s2">.</span><span class="s1">is_np_dtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s4">&quot;M&quot;</span><span class="s2">)</span>

    <span class="s5"># --------------------------------------------------------------------</span>
    <span class="s5"># Rendering Methods</span>

    <span class="s2">@</span><span class="s1">cache_readonly</span>
    <span class="s0">def </span><span class="s1">_formatter_func</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5"># Note this is equivalent to the DatetimeIndexOpsMixin method but</span>
        <span class="s5">#  uses the maybe-cached self._is_dates_only instead of re-computing it.</span>
        <span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">io</span><span class="s2">.</span><span class="s1">formats</span><span class="s2">.</span><span class="s1">format </span><span class="s0">import </span><span class="s1">get_format_datetime64</span>

        <span class="s1">formatter </span><span class="s2">= </span><span class="s1">get_format_datetime64</span><span class="s2">(</span><span class="s1">is_dates_only</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_is_dates_only</span><span class="s2">)</span>
        <span class="s0">return lambda </span><span class="s1">x</span><span class="s2">: </span><span class="s4">f&quot;'</span><span class="s0">{</span><span class="s1">formatter</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span><span class="s0">}</span><span class="s4">'&quot;</span>

    <span class="s5"># --------------------------------------------------------------------</span>
    <span class="s5"># Set Operation Methods</span>

    <span class="s0">def </span><span class="s1">_can_range_setop</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s5"># GH 46702: If self or other have non-UTC tzs, DST transitions prevent</span>
        <span class="s5"># range representation due to no singular step</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">tz </span><span class="s0">is not None</span>
            <span class="s0">and not </span><span class="s1">timezones</span><span class="s2">.</span><span class="s1">is_utc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">tz</span><span class="s2">)</span>
            <span class="s0">and not </span><span class="s1">timezones</span><span class="s2">.</span><span class="s1">is_fixed_offset</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">tz</span><span class="s2">)</span>
        <span class="s2">):</span>
            <span class="s0">return False</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">other</span><span class="s2">.</span><span class="s1">tz </span><span class="s0">is not None</span>
            <span class="s0">and not </span><span class="s1">timezones</span><span class="s2">.</span><span class="s1">is_utc</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">tz</span><span class="s2">)</span>
            <span class="s0">and not </span><span class="s1">timezones</span><span class="s2">.</span><span class="s1">is_fixed_offset</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">tz</span><span class="s2">)</span>
        <span class="s2">):</span>
            <span class="s0">return False</span>
        <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">_can_range_setop</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>

    <span class="s5"># --------------------------------------------------------------------</span>

    <span class="s0">def </span><span class="s1">_get_time_micros</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return the number of microseconds since midnight. 
 
        Returns 
        ------- 
        ndarray[int64_t] 
        &quot;&quot;&quot;</span>
        <span class="s1">values </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">_local_timestamps</span><span class="s2">()</span>

        <span class="s1">ppd </span><span class="s2">= </span><span class="s1">periods_per_day</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">_creso</span><span class="s2">)</span>

        <span class="s1">frac </span><span class="s2">= </span><span class="s1">values </span><span class="s2">% </span><span class="s1">ppd</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">unit </span><span class="s2">== </span><span class="s4">&quot;ns&quot;</span><span class="s2">:</span>
            <span class="s1">micros </span><span class="s2">= </span><span class="s1">frac </span><span class="s2">// </span><span class="s6">1000</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">unit </span><span class="s2">== </span><span class="s4">&quot;us&quot;</span><span class="s2">:</span>
            <span class="s1">micros </span><span class="s2">= </span><span class="s1">frac</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">unit </span><span class="s2">== </span><span class="s4">&quot;ms&quot;</span><span class="s2">:</span>
            <span class="s1">micros </span><span class="s2">= </span><span class="s1">frac </span><span class="s2">* </span><span class="s6">1000</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">unit </span><span class="s2">== </span><span class="s4">&quot;s&quot;</span><span class="s2">:</span>
            <span class="s1">micros </span><span class="s2">= </span><span class="s1">frac </span><span class="s2">* </span><span class="s6">1_000_000</span>
        <span class="s0">else</span><span class="s2">:  </span><span class="s5"># pragma: no cover</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">unit</span><span class="s2">)</span>

        <span class="s1">micros</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_isnan</span><span class="s2">] = -</span><span class="s6">1</span>
        <span class="s0">return </span><span class="s1">micros</span>

    <span class="s0">def </span><span class="s1">snap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">freq</span><span class="s2">: </span><span class="s1">Frequency </span><span class="s2">= </span><span class="s4">&quot;S&quot;</span><span class="s2">) </span><span class="s1">-&gt; DatetimeIndex</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Snap time stamps to nearest occurring frequency. 
 
        Returns 
        ------- 
        DatetimeIndex 
 
        Examples 
        -------- 
        &gt;&gt;&gt; idx = pd.DatetimeIndex(['2023-01-01', '2023-01-02', 
        ...                        '2023-02-01', '2023-02-02']) 
        &gt;&gt;&gt; idx 
        DatetimeIndex(['2023-01-01', '2023-01-02', '2023-02-01', '2023-02-02'], 
        dtype='datetime64[ns]', freq=None) 
        &gt;&gt;&gt; idx.snap('MS') 
        DatetimeIndex(['2023-01-01', '2023-01-01', '2023-02-01', '2023-02-01'], 
        dtype='datetime64[ns]', freq=None) 
        &quot;&quot;&quot;</span>
        <span class="s5"># Superdumb, punting on any optimizing</span>
        <span class="s1">freq </span><span class="s2">= </span><span class="s1">to_offset</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">)</span>

        <span class="s1">dta </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s1">s </span><span class="s2">= </span><span class="s1">v</span>
            <span class="s0">if not </span><span class="s1">freq</span><span class="s2">.</span><span class="s1">is_on_offset</span><span class="s2">(</span><span class="s1">s</span><span class="s2">):</span>
                <span class="s1">t0 </span><span class="s2">= </span><span class="s1">freq</span><span class="s2">.</span><span class="s1">rollback</span><span class="s2">(</span><span class="s1">s</span><span class="s2">)</span>
                <span class="s1">t1 </span><span class="s2">= </span><span class="s1">freq</span><span class="s2">.</span><span class="s1">rollforward</span><span class="s2">(</span><span class="s1">s</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">s </span><span class="s2">- </span><span class="s1">t0</span><span class="s2">) &lt; </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">t1 </span><span class="s2">- </span><span class="s1">s</span><span class="s2">):</span>
                    <span class="s1">s </span><span class="s2">= </span><span class="s1">t0</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">s </span><span class="s2">= </span><span class="s1">t1</span>
            <span class="s1">dta</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">s</span>

        <span class="s0">return </span><span class="s1">DatetimeIndex</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">dta</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">name</span><span class="s2">)</span>

    <span class="s5"># --------------------------------------------------------------------</span>
    <span class="s5"># Indexing Methods</span>

    <span class="s0">def </span><span class="s1">_parsed_string_to_bounds</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">reso</span><span class="s2">: </span><span class="s1">Resolution</span><span class="s2">, </span><span class="s1">parsed</span><span class="s2">: </span><span class="s1">dt</span><span class="s2">.</span><span class="s1">datetime</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Calculate datetime bounds for parsed time string and its resolution. 
 
        Parameters 
        ---------- 
        reso : Resolution 
            Resolution provided by parsed string. 
        parsed : datetime 
            Datetime from parsed string. 
 
        Returns 
        ------- 
        lower, upper: pd.Timestamp 
        &quot;&quot;&quot;</span>
        <span class="s1">freq </span><span class="s2">= </span><span class="s1">OFFSET_TO_PERIOD_FREQSTR</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">reso</span><span class="s2">.</span><span class="s1">attr_abbrev</span><span class="s2">, </span><span class="s1">reso</span><span class="s2">.</span><span class="s1">attr_abbrev</span><span class="s2">)</span>
        <span class="s1">per </span><span class="s2">= </span><span class="s1">Period</span><span class="s2">(</span><span class="s1">parsed</span><span class="s2">, </span><span class="s1">freq</span><span class="s2">=</span><span class="s1">freq</span><span class="s2">)</span>
        <span class="s1">start</span><span class="s2">, </span><span class="s1">end </span><span class="s2">= </span><span class="s1">per</span><span class="s2">.</span><span class="s1">start_time</span><span class="s2">, </span><span class="s1">per</span><span class="s2">.</span><span class="s1">end_time</span>

        <span class="s5"># GH 24076</span>
        <span class="s5"># If an incoming date string contained a UTC offset, need to localize</span>
        <span class="s5"># the parsed date to this offset first before aligning with the index's</span>
        <span class="s5"># timezone</span>
        <span class="s1">start </span><span class="s2">= </span><span class="s1">start</span><span class="s2">.</span><span class="s1">tz_localize</span><span class="s2">(</span><span class="s1">parsed</span><span class="s2">.</span><span class="s1">tzinfo</span><span class="s2">)</span>
        <span class="s1">end </span><span class="s2">= </span><span class="s1">end</span><span class="s2">.</span><span class="s1">tz_localize</span><span class="s2">(</span><span class="s1">parsed</span><span class="s2">.</span><span class="s1">tzinfo</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">parsed</span><span class="s2">.</span><span class="s1">tzinfo </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tz </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s4">&quot;The index must be timezone aware when indexing &quot;</span>
                    <span class="s4">&quot;with a date string with a UTC offset&quot;</span>
                <span class="s2">)</span>
        <span class="s5"># The flipped case with parsed.tz is None and self.tz is not None</span>
        <span class="s5">#  is ruled out bc parsed and reso are produced by _parse_with_reso,</span>
        <span class="s5">#  which localizes parsed.</span>
        <span class="s0">return </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span>

    <span class="s0">def </span><span class="s1">_parse_with_reso</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">label</span><span class="s2">: </span><span class="s1">str</span><span class="s2">):</span>
        <span class="s1">parsed</span><span class="s2">, </span><span class="s1">reso </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">_parse_with_reso</span><span class="s2">(</span><span class="s1">label</span><span class="s2">)</span>

        <span class="s1">parsed </span><span class="s2">= </span><span class="s1">Timestamp</span><span class="s2">(</span><span class="s1">parsed</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tz </span><span class="s0">is not None and </span><span class="s1">parsed</span><span class="s2">.</span><span class="s1">tzinfo </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s5"># we special-case timezone-naive strings and timezone-aware</span>
            <span class="s5">#  DatetimeIndex</span>
            <span class="s5"># https://github.com/pandas-dev/pandas/pull/36148#issuecomment-687883081</span>
            <span class="s1">parsed </span><span class="s2">= </span><span class="s1">parsed</span><span class="s2">.</span><span class="s1">tz_localize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">tz</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">parsed</span><span class="s2">, </span><span class="s1">reso</span>

    <span class="s0">def </span><span class="s1">_disallow_mismatched_indexing</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s3">&quot;&quot;&quot; 
        Check for mismatched-tzawareness indexing and re-raise as KeyError. 
        &quot;&quot;&quot;</span>
        <span class="s5"># we get here with isinstance(key, self._data._recognized_scalars)</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s5"># GH#36148</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">_assert_tzawareness_compat</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">err</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">(</span><span class="s1">key</span><span class="s2">) </span><span class="s0">from </span><span class="s1">err</span>

    <span class="s0">def </span><span class="s1">get_loc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Get integer location for requested label 
 
        Returns 
        ------- 
        loc : int 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_check_indexing_error</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>

        <span class="s1">orig_key </span><span class="s2">= </span><span class="s1">key</span>
        <span class="s0">if </span><span class="s1">is_valid_na_for_dtype</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">):</span>
            <span class="s1">key </span><span class="s2">= </span><span class="s1">NaT</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">_recognized_scalars</span><span class="s2">):</span>
            <span class="s5"># needed to localize naive datetimes</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_disallow_mismatched_indexing</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
            <span class="s1">key </span><span class="s2">= </span><span class="s1">Timestamp</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>

        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">parsed</span><span class="s2">, </span><span class="s1">reso </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_parse_with_reso</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">pytz</span><span class="s2">.</span><span class="s1">NonExistentTimeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">err</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">(</span><span class="s1">key</span><span class="s2">) </span><span class="s0">from </span><span class="s1">err</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_disallow_mismatched_indexing</span><span class="s2">(</span><span class="s1">parsed</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_can_partial_date_slice</span><span class="s2">(</span><span class="s1">reso</span><span class="s2">):</span>
                <span class="s0">try</span><span class="s2">:</span>
                    <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_partial_date_slice</span><span class="s2">(</span><span class="s1">reso</span><span class="s2">, </span><span class="s1">parsed</span><span class="s2">)</span>
                <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">err</span><span class="s2">:</span>
                    <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">(</span><span class="s1">key</span><span class="s2">) </span><span class="s0">from </span><span class="s1">err</span>

            <span class="s1">key </span><span class="s2">= </span><span class="s1">parsed</span>

        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">.</span><span class="s1">timedelta</span><span class="s2">):</span>
            <span class="s5"># GH#20464</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s4">f&quot;Cannot index </span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">} </span><span class="s4">with </span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">key</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">}</span><span class="s4">&quot;</span>
            <span class="s2">)</span>

        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">.</span><span class="s1">time</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indexer_at_time</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>

        <span class="s0">else</span><span class="s2">:</span>
            <span class="s5"># unrecognized type</span>
            <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">Index</span><span class="s2">.</span><span class="s1">get_loc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">err</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">(</span><span class="s1">orig_key</span><span class="s2">) </span><span class="s0">from </span><span class="s1">err</span>

    <span class="s2">@</span><span class="s1">doc</span><span class="s2">(</span><span class="s1">DatetimeTimedeltaMixin</span><span class="s2">.</span><span class="s1">_maybe_cast_slice_bound</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">_maybe_cast_slice_bound</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">side</span><span class="s2">: </span><span class="s1">str</span><span class="s2">):</span>
        <span class="s5"># GH#42855 handle date here instead of get_slice_bound</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">label</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">.</span><span class="s1">date</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">label</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">.</span><span class="s1">datetime</span><span class="s2">):</span>
            <span class="s5"># Pandas supports slicing with dates, treated as datetimes at midnight.</span>
            <span class="s5"># https://github.com/pandas-dev/pandas/issues/31501</span>
            <span class="s1">label </span><span class="s2">= </span><span class="s1">Timestamp</span><span class="s2">(</span><span class="s1">label</span><span class="s2">).</span><span class="s1">to_pydatetime</span><span class="s2">()</span>

        <span class="s1">label </span><span class="s2">= </span><span class="s1">super</span><span class="s2">().</span><span class="s1">_maybe_cast_slice_bound</span><span class="s2">(</span><span class="s1">label</span><span class="s2">, </span><span class="s1">side</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">_assert_tzawareness_compat</span><span class="s2">(</span><span class="s1">label</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">Timestamp</span><span class="s2">(</span><span class="s1">label</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">slice_indexer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">end</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">step</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return indexer for specified label slice. 
        Index.slice_indexer, customized to handle time slicing. 
 
        In addition to functionality provided by Index.slice_indexer, does the 
        following: 
 
        - if both `start` and `end` are instances of `datetime.time`, it 
          invokes `indexer_between_time` 
        - if `start` and `end` are both either string or None perform 
          value-based selection in non-monotonic cases. 
 
        &quot;&quot;&quot;</span>
        <span class="s5"># For historical reasons DatetimeIndex supports slices between two</span>
        <span class="s5"># instances of datetime.time as if it were applying a slice mask to</span>
        <span class="s5"># an array of (self.hour, self.minute, self.seconds, self.microsecond).</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">.</span><span class="s1">time</span><span class="s2">) </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">end</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">.</span><span class="s1">time</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">step </span><span class="s0">is not None and </span><span class="s1">step </span><span class="s2">!= </span><span class="s6">1</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Must have step size of 1 with time slices&quot;</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indexer_between_time</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">.</span><span class="s1">time</span><span class="s2">) </span><span class="s0">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">end</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">.</span><span class="s1">time</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">(</span><span class="s4">&quot;Cannot mix time and non-time slice keys&quot;</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">check_str_or_none</span><span class="s2">(</span><span class="s1">point</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">point </span><span class="s0">is not None and not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">point</span><span class="s2">, </span><span class="s1">str</span><span class="s2">)</span>

        <span class="s5"># GH#33146 if start and end are combinations of str and None and Index is not</span>
        <span class="s5"># monotonic, we can not use Index.slice_indexer because it does not honor the</span>
        <span class="s5"># actual elements, is only searching for start and end</span>
        <span class="s0">if </span><span class="s2">(</span>
            <span class="s1">check_str_or_none</span><span class="s2">(</span><span class="s1">start</span><span class="s2">)</span>
            <span class="s0">or </span><span class="s1">check_str_or_none</span><span class="s2">(</span><span class="s1">end</span><span class="s2">)</span>
            <span class="s0">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">is_monotonic_increasing</span>
        <span class="s2">):</span>
            <span class="s0">return </span><span class="s1">Index</span><span class="s2">.</span><span class="s1">slice_indexer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">step</span><span class="s2">)</span>

        <span class="s1">mask </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">in_index </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">if </span><span class="s1">start </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">start_casted </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_cast_slice_bound</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s4">&quot;left&quot;</span><span class="s2">)</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">start_casted </span><span class="s2">&lt;= </span><span class="s1">self</span>
            <span class="s1">in_index </span><span class="s2">&amp;= (</span><span class="s1">start_casted </span><span class="s2">== </span><span class="s1">self</span><span class="s2">).</span><span class="s1">any</span><span class="s2">()</span>

        <span class="s0">if </span><span class="s1">end </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">end_casted </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maybe_cast_slice_bound</span><span class="s2">(</span><span class="s1">end</span><span class="s2">, </span><span class="s4">&quot;right&quot;</span><span class="s2">)</span>
            <span class="s1">mask </span><span class="s2">= (</span><span class="s1">self </span><span class="s2">&lt;= </span><span class="s1">end_casted</span><span class="s2">) &amp; </span><span class="s1">mask</span>
            <span class="s1">in_index </span><span class="s2">&amp;= (</span><span class="s1">end_casted </span><span class="s2">== </span><span class="s1">self</span><span class="s2">).</span><span class="s1">any</span><span class="s2">()</span>

        <span class="s0">if not </span><span class="s1">in_index</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">KeyError</span><span class="s2">(</span>
                <span class="s4">&quot;Value based partial slicing on non-monotonic DatetimeIndexes &quot;</span>
                <span class="s4">&quot;with non-existing keys is not allowed.&quot;</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s1">indexer </span><span class="s2">= </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">()[</span><span class="s6">0</span><span class="s2">][::</span><span class="s1">step</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">indexer</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">indexer</span>

    <span class="s5"># --------------------------------------------------------------------</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">inferred_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; str</span><span class="s2">:</span>
        <span class="s5"># b/c datetime is represented as microseconds since the epoch, make</span>
        <span class="s5"># sure we can't have ambiguous indexing</span>
        <span class="s0">return </span><span class="s4">&quot;datetime64&quot;</span>

    <span class="s0">def </span><span class="s1">indexer_at_time</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">time</span><span class="s2">, </span><span class="s1">asof</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">) </span><span class="s1">-&gt; npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return index locations of values at particular time of day. 
 
        Parameters 
        ---------- 
        time : datetime.time or str 
            Time passed in either as object (datetime.time) or as string in 
            appropriate format (&quot;%H:%M&quot;, &quot;%H%M&quot;, &quot;%I:%M%p&quot;, &quot;%I%M%p&quot;, 
            &quot;%H:%M:%S&quot;, &quot;%H%M%S&quot;, &quot;%I:%M:%S%p&quot;, &quot;%I%M%S%p&quot;). 
 
        Returns 
        ------- 
        np.ndarray[np.intp] 
 
        See Also 
        -------- 
        indexer_between_time : Get index locations of values between particular 
            times of day. 
        DataFrame.at_time : Select values at particular time of day. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; idx = pd.DatetimeIndex([&quot;1/1/2020 10:00&quot;, &quot;2/1/2020 11:00&quot;, 
        ...                         &quot;3/1/2020 10:00&quot;]) 
        &gt;&gt;&gt; idx.indexer_at_time(&quot;10:00&quot;) 
        array([0, 2]) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">asof</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s4">&quot;'asof' argument is not supported&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">time</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s0">from </span><span class="s1">dateutil</span><span class="s2">.</span><span class="s1">parser </span><span class="s0">import </span><span class="s1">parse</span>

            <span class="s1">time </span><span class="s2">= </span><span class="s1">parse</span><span class="s2">(</span><span class="s1">time</span><span class="s2">).</span><span class="s1">time</span><span class="s2">()</span>

        <span class="s0">if </span><span class="s1">time</span><span class="s2">.</span><span class="s1">tzinfo</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tz </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Index must be timezone aware.&quot;</span><span class="s2">)</span>
            <span class="s1">time_micros </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tz_convert</span><span class="s2">(</span><span class="s1">time</span><span class="s2">.</span><span class="s1">tzinfo</span><span class="s2">).</span><span class="s1">_get_time_micros</span><span class="s2">()</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">time_micros </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_time_micros</span><span class="s2">()</span>
        <span class="s1">micros </span><span class="s2">= </span><span class="s1">_time_to_micros</span><span class="s2">(</span><span class="s1">time</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">time_micros </span><span class="s2">== </span><span class="s1">micros</span><span class="s2">).</span><span class="s1">nonzero</span><span class="s2">()[</span><span class="s6">0</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">indexer_between_time</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">start_time</span><span class="s2">, </span><span class="s1">end_time</span><span class="s2">, </span><span class="s1">include_start</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">, </span><span class="s1">include_end</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span>
    <span class="s2">) </span><span class="s1">-&gt; npt</span><span class="s2">.</span><span class="s1">NDArray</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">]:</span>
        <span class="s3">&quot;&quot;&quot; 
        Return index locations of values between particular times of day. 
 
        Parameters 
        ---------- 
        start_time, end_time : datetime.time, str 
            Time passed either as object (datetime.time) or as string in 
            appropriate format (&quot;%H:%M&quot;, &quot;%H%M&quot;, &quot;%I:%M%p&quot;, &quot;%I%M%p&quot;, 
            &quot;%H:%M:%S&quot;, &quot;%H%M%S&quot;, &quot;%I:%M:%S%p&quot;,&quot;%I%M%S%p&quot;). 
        include_start : bool, default True 
        include_end : bool, default True 
 
        Returns 
        ------- 
        np.ndarray[np.intp] 
 
        See Also 
        -------- 
        indexer_at_time : Get index locations of values at particular time of day. 
        DataFrame.between_time : Select values between particular times of day. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; idx = pd.date_range(&quot;2023-01-01&quot;, periods=4, freq=&quot;h&quot;) 
        &gt;&gt;&gt; idx 
        DatetimeIndex(['2023-01-01 00:00:00', '2023-01-01 01:00:00', 
                           '2023-01-01 02:00:00', '2023-01-01 03:00:00'], 
                          dtype='datetime64[ns]', freq='h') 
        &gt;&gt;&gt; idx.indexer_between_time(&quot;00:00&quot;, &quot;2:00&quot;, include_end=False) 
        array([0, 1]) 
        &quot;&quot;&quot;</span>
        <span class="s1">start_time </span><span class="s2">= </span><span class="s1">to_time</span><span class="s2">(</span><span class="s1">start_time</span><span class="s2">)</span>
        <span class="s1">end_time </span><span class="s2">= </span><span class="s1">to_time</span><span class="s2">(</span><span class="s1">end_time</span><span class="s2">)</span>
        <span class="s1">time_micros </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_time_micros</span><span class="s2">()</span>
        <span class="s1">start_micros </span><span class="s2">= </span><span class="s1">_time_to_micros</span><span class="s2">(</span><span class="s1">start_time</span><span class="s2">)</span>
        <span class="s1">end_micros </span><span class="s2">= </span><span class="s1">_time_to_micros</span><span class="s2">(</span><span class="s1">end_time</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">include_start </span><span class="s0">and </span><span class="s1">include_end</span><span class="s2">:</span>
            <span class="s1">lop </span><span class="s2">= </span><span class="s1">rop </span><span class="s2">= </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">le</span>
        <span class="s0">elif </span><span class="s1">include_start</span><span class="s2">:</span>
            <span class="s1">lop </span><span class="s2">= </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">le</span>
            <span class="s1">rop </span><span class="s2">= </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">lt</span>
        <span class="s0">elif </span><span class="s1">include_end</span><span class="s2">:</span>
            <span class="s1">lop </span><span class="s2">= </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">lt</span>
            <span class="s1">rop </span><span class="s2">= </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">le</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">lop </span><span class="s2">= </span><span class="s1">rop </span><span class="s2">= </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">lt</span>

        <span class="s0">if </span><span class="s1">start_time </span><span class="s2">&lt;= </span><span class="s1">end_time</span><span class="s2">:</span>
            <span class="s1">join_op </span><span class="s2">= </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">and_</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">join_op </span><span class="s2">= </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">or_</span>

        <span class="s1">mask </span><span class="s2">= </span><span class="s1">join_op</span><span class="s2">(</span><span class="s1">lop</span><span class="s2">(</span><span class="s1">start_micros</span><span class="s2">, </span><span class="s1">time_micros</span><span class="s2">), </span><span class="s1">rop</span><span class="s2">(</span><span class="s1">time_micros</span><span class="s2">, </span><span class="s1">end_micros</span><span class="s2">))</span>

        <span class="s0">return </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">()[</span><span class="s6">0</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">date_range</span><span class="s2">(</span>
    <span class="s1">start</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">end</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">periods</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">freq</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">tz</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">normalize</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">name</span><span class="s2">: </span><span class="s1">Hashable </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">inclusive</span><span class="s2">: </span><span class="s1">IntervalClosedType </span><span class="s2">= </span><span class="s4">&quot;both&quot;</span><span class="s2">,</span>
    <span class="s2">*,</span>
    <span class="s1">unit</span><span class="s2">: </span><span class="s1">str </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; DatetimeIndex</span><span class="s2">:</span>
    <span class="s3">&quot;&quot;&quot; 
    Return a fixed frequency DatetimeIndex. 
 
    Returns the range of equally spaced time points (where the difference between any 
    two adjacent points is specified by the given frequency) such that they all 
    satisfy `start &lt;[=] x &lt;[=] end`, where the first one and the last one are, resp., 
    the first and last time points in that range that fall on the boundary of ``freq`` 
    (if given as a frequency string) or that are valid for ``freq`` (if given as a 
    :class:`pandas.tseries.offsets.DateOffset`). (If exactly one of ``start``, 
    ``end``, or ``freq`` is *not* specified, this missing parameter can be computed 
    given ``periods``, the number of timesteps in the range. See the note below.) 
 
    Parameters 
    ---------- 
    start : str or datetime-like, optional 
        Left bound for generating dates. 
    end : str or datetime-like, optional 
        Right bound for generating dates. 
    periods : int, optional 
        Number of periods to generate. 
    freq : str, Timedelta, datetime.timedelta, or DateOffset, default 'D' 
        Frequency strings can have multiples, e.g. '5h'. See 
        :ref:`here &lt;timeseries.offset_aliases&gt;` for a list of 
        frequency aliases. 
    tz : str or tzinfo, optional 
        Time zone name for returning localized DatetimeIndex, for example 
        'Asia/Hong_Kong'. By default, the resulting DatetimeIndex is 
        timezone-naive unless timezone-aware datetime-likes are passed. 
    normalize : bool, default False 
        Normalize start/end dates to midnight before generating date range. 
    name : str, default None 
        Name of the resulting DatetimeIndex. 
    inclusive : {&quot;both&quot;, &quot;neither&quot;, &quot;left&quot;, &quot;right&quot;}, default &quot;both&quot; 
        Include boundaries; Whether to set each bound as closed or open. 
 
        .. versionadded:: 1.4.0 
    unit : str, default None 
        Specify the desired resolution of the result. 
 
        .. versionadded:: 2.0.0 
    **kwargs 
        For compatibility. Has no effect on the result. 
 
    Returns 
    ------- 
    DatetimeIndex 
 
    See Also 
    -------- 
    DatetimeIndex : An immutable container for datetimes. 
    timedelta_range : Return a fixed frequency TimedeltaIndex. 
    period_range : Return a fixed frequency PeriodIndex. 
    interval_range : Return a fixed frequency IntervalIndex. 
 
    Notes 
    ----- 
    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``, 
    exactly three must be specified. If ``freq`` is omitted, the resulting 
    ``DatetimeIndex`` will have ``periods`` linearly spaced elements between 
    ``start`` and ``end`` (closed on both sides). 
 
    To learn more about the frequency strings, please see `this link 
    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`__. 
 
    Examples 
    -------- 
    **Specifying the values** 
 
    The next four examples generate the same `DatetimeIndex`, but vary 
    the combination of `start`, `end` and `periods`. 
 
    Specify `start` and `end`, with the default daily frequency. 
 
    &gt;&gt;&gt; pd.date_range(start='1/1/2018', end='1/08/2018') 
    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04', 
                   '2018-01-05', '2018-01-06', '2018-01-07', '2018-01-08'], 
                  dtype='datetime64[ns]', freq='D') 
 
    Specify timezone-aware `start` and `end`, with the default daily frequency. 
 
    &gt;&gt;&gt; pd.date_range( 
    ...     start=pd.to_datetime(&quot;1/1/2018&quot;).tz_localize(&quot;Europe/Berlin&quot;), 
    ...     end=pd.to_datetime(&quot;1/08/2018&quot;).tz_localize(&quot;Europe/Berlin&quot;), 
    ... ) 
    DatetimeIndex(['2018-01-01 00:00:00+01:00', '2018-01-02 00:00:00+01:00', 
                   '2018-01-03 00:00:00+01:00', '2018-01-04 00:00:00+01:00', 
                   '2018-01-05 00:00:00+01:00', '2018-01-06 00:00:00+01:00', 
                   '2018-01-07 00:00:00+01:00', '2018-01-08 00:00:00+01:00'], 
                  dtype='datetime64[ns, Europe/Berlin]', freq='D') 
 
    Specify `start` and `periods`, the number of periods (days). 
 
    &gt;&gt;&gt; pd.date_range(start='1/1/2018', periods=8) 
    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04', 
                   '2018-01-05', '2018-01-06', '2018-01-07', '2018-01-08'], 
                  dtype='datetime64[ns]', freq='D') 
 
    Specify `end` and `periods`, the number of periods (days). 
 
    &gt;&gt;&gt; pd.date_range(end='1/1/2018', periods=8) 
    DatetimeIndex(['2017-12-25', '2017-12-26', '2017-12-27', '2017-12-28', 
                   '2017-12-29', '2017-12-30', '2017-12-31', '2018-01-01'], 
                  dtype='datetime64[ns]', freq='D') 
 
    Specify `start`, `end`, and `periods`; the frequency is generated 
    automatically (linearly spaced). 
 
    &gt;&gt;&gt; pd.date_range(start='2018-04-24', end='2018-04-27', periods=3) 
    DatetimeIndex(['2018-04-24 00:00:00', '2018-04-25 12:00:00', 
                   '2018-04-27 00:00:00'], 
                  dtype='datetime64[ns]', freq=None) 
 
    **Other Parameters** 
 
    Changed the `freq` (frequency) to ``'ME'`` (month end frequency). 
 
    &gt;&gt;&gt; pd.date_range(start='1/1/2018', periods=5, freq='ME') 
    DatetimeIndex(['2018-01-31', '2018-02-28', '2018-03-31', '2018-04-30', 
                   '2018-05-31'], 
                  dtype='datetime64[ns]', freq='ME') 
 
    Multiples are allowed 
 
    &gt;&gt;&gt; pd.date_range(start='1/1/2018', periods=5, freq='3ME') 
    DatetimeIndex(['2018-01-31', '2018-04-30', '2018-07-31', '2018-10-31', 
                   '2019-01-31'], 
                  dtype='datetime64[ns]', freq='3ME') 
 
    `freq` can also be specified as an Offset object. 
 
    &gt;&gt;&gt; pd.date_range(start='1/1/2018', periods=5, freq=pd.offsets.MonthEnd(3)) 
    DatetimeIndex(['2018-01-31', '2018-04-30', '2018-07-31', '2018-10-31', 
                   '2019-01-31'], 
                  dtype='datetime64[ns]', freq='3ME') 
 
    Specify `tz` to set the timezone. 
 
    &gt;&gt;&gt; pd.date_range(start='1/1/2018', periods=5, tz='Asia/Tokyo') 
    DatetimeIndex(['2018-01-01 00:00:00+09:00', '2018-01-02 00:00:00+09:00', 
                   '2018-01-03 00:00:00+09:00', '2018-01-04 00:00:00+09:00', 
                   '2018-01-05 00:00:00+09:00'], 
                  dtype='datetime64[ns, Asia/Tokyo]', freq='D') 
 
    `inclusive` controls whether to include `start` and `end` that are on the 
    boundary. The default, &quot;both&quot;, includes boundary points on either end. 
 
    &gt;&gt;&gt; pd.date_range(start='2017-01-01', end='2017-01-04', inclusive=&quot;both&quot;) 
    DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03', '2017-01-04'], 
                  dtype='datetime64[ns]', freq='D') 
 
    Use ``inclusive='left'`` to exclude `end` if it falls on the boundary. 
 
    &gt;&gt;&gt; pd.date_range(start='2017-01-01', end='2017-01-04', inclusive='left') 
    DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03'], 
                  dtype='datetime64[ns]', freq='D') 
 
    Use ``inclusive='right'`` to exclude `start` if it falls on the boundary, and 
    similarly ``inclusive='neither'`` will exclude both `start` and `end`. 
 
    &gt;&gt;&gt; pd.date_range(start='2017-01-01', end='2017-01-04', inclusive='right') 
    DatetimeIndex(['2017-01-02', '2017-01-03', '2017-01-04'], 
                  dtype='datetime64[ns]', freq='D') 
 
    **Specify a unit** 
 
    &gt;&gt;&gt; pd.date_range(start=&quot;2017-01-01&quot;, periods=10, freq=&quot;100YS&quot;, unit=&quot;s&quot;) 
    DatetimeIndex(['2017-01-01', '2117-01-01', '2217-01-01', '2317-01-01', 
                   '2417-01-01', '2517-01-01', '2617-01-01', '2717-01-01', 
                   '2817-01-01', '2917-01-01'], 
                  dtype='datetime64[s]', freq='100YS-JAN') 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">freq </span><span class="s0">is None and </span><span class="s1">com</span><span class="s2">.</span><span class="s1">any_none</span><span class="s2">(</span><span class="s1">periods</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">):</span>
        <span class="s1">freq </span><span class="s2">= </span><span class="s4">&quot;D&quot;</span>

    <span class="s1">dtarr </span><span class="s2">= </span><span class="s1">DatetimeArray</span><span class="s2">.</span><span class="s1">_generate_range</span><span class="s2">(</span>
        <span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">,</span>
        <span class="s1">end</span><span class="s2">=</span><span class="s1">end</span><span class="s2">,</span>
        <span class="s1">periods</span><span class="s2">=</span><span class="s1">periods</span><span class="s2">,</span>
        <span class="s1">freq</span><span class="s2">=</span><span class="s1">freq</span><span class="s2">,</span>
        <span class="s1">tz</span><span class="s2">=</span><span class="s1">tz</span><span class="s2">,</span>
        <span class="s1">normalize</span><span class="s2">=</span><span class="s1">normalize</span><span class="s2">,</span>
        <span class="s1">inclusive</span><span class="s2">=</span><span class="s1">inclusive</span><span class="s2">,</span>
        <span class="s1">unit</span><span class="s2">=</span><span class="s1">unit</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s0">return </span><span class="s1">DatetimeIndex</span><span class="s2">.</span><span class="s1">_simple_new</span><span class="s2">(</span><span class="s1">dtarr</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">bdate_range</span><span class="s2">(</span>
    <span class="s1">start</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">end</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">periods</span><span class="s2">: </span><span class="s1">int </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">freq</span><span class="s2">: </span><span class="s1">Frequency </span><span class="s2">| </span><span class="s1">dt</span><span class="s2">.</span><span class="s1">timedelta </span><span class="s2">= </span><span class="s4">&quot;B&quot;</span><span class="s2">,</span>
    <span class="s1">tz</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">normalize</span><span class="s2">: </span><span class="s1">bool </span><span class="s2">= </span><span class="s0">True</span><span class="s2">,</span>
    <span class="s1">name</span><span class="s2">: </span><span class="s1">Hashable </span><span class="s2">| </span><span class="s0">None </span><span class="s2">= </span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">weekmask</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">holidays</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s1">inclusive</span><span class="s2">: </span><span class="s1">IntervalClosedType </span><span class="s2">= </span><span class="s4">&quot;both&quot;</span><span class="s2">,</span>
    <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
<span class="s2">) </span><span class="s1">-&gt; DatetimeIndex</span><span class="s2">:</span>
    <span class="s3">&quot;&quot;&quot; 
    Return a fixed frequency DatetimeIndex with business day as the default. 
 
    Parameters 
    ---------- 
    start : str or datetime-like, default None 
        Left bound for generating dates. 
    end : str or datetime-like, default None 
        Right bound for generating dates. 
    periods : int, default None 
        Number of periods to generate. 
    freq : str, Timedelta, datetime.timedelta, or DateOffset, default 'B' 
        Frequency strings can have multiples, e.g. '5h'. The default is 
        business daily ('B'). 
    tz : str or None 
        Time zone name for returning localized DatetimeIndex, for example 
        Asia/Beijing. 
    normalize : bool, default False 
        Normalize start/end dates to midnight before generating date range. 
    name : str, default None 
        Name of the resulting DatetimeIndex. 
    weekmask : str or None, default None 
        Weekmask of valid business days, passed to ``numpy.busdaycalendar``, 
        only used when custom frequency strings are passed.  The default 
        value None is equivalent to 'Mon Tue Wed Thu Fri'. 
    holidays : list-like or None, default None 
        Dates to exclude from the set of valid business days, passed to 
        ``numpy.busdaycalendar``, only used when custom frequency strings 
        are passed. 
    inclusive : {&quot;both&quot;, &quot;neither&quot;, &quot;left&quot;, &quot;right&quot;}, default &quot;both&quot; 
        Include boundaries; Whether to set each bound as closed or open. 
 
        .. versionadded:: 1.4.0 
    **kwargs 
        For compatibility. Has no effect on the result. 
 
    Returns 
    ------- 
    DatetimeIndex 
 
    Notes 
    ----- 
    Of the four parameters: ``start``, ``end``, ``periods``, and ``freq``, 
    exactly three must be specified.  Specifying ``freq`` is a requirement 
    for ``bdate_range``.  Use ``date_range`` if specifying ``freq`` is not 
    desired. 
 
    To learn more about the frequency strings, please see `this link 
    &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;`__. 
 
    Examples 
    -------- 
    Note how the two weekend days are skipped in the result. 
 
    &gt;&gt;&gt; pd.bdate_range(start='1/1/2018', end='1/08/2018') 
    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04', 
               '2018-01-05', '2018-01-08'], 
              dtype='datetime64[ns]', freq='B') 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">freq </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s4">&quot;freq must be specified for bdate_range; use date_range instead&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">freq</span><span class="s2">, </span><span class="s1">str</span><span class="s2">) </span><span class="s0">and </span><span class="s1">freq</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s4">&quot;C&quot;</span><span class="s2">):</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">weekmask </span><span class="s2">= </span><span class="s1">weekmask </span><span class="s0">or </span><span class="s4">&quot;Mon Tue Wed Thu Fri&quot;</span>
            <span class="s1">freq </span><span class="s2">= </span><span class="s1">prefix_mapping</span><span class="s2">[</span><span class="s1">freq</span><span class="s2">](</span><span class="s1">holidays</span><span class="s2">=</span><span class="s1">holidays</span><span class="s2">, </span><span class="s1">weekmask</span><span class="s2">=</span><span class="s1">weekmask</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s2">(</span><span class="s1">KeyError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">err</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s4">f&quot;invalid custom frequency string: </span><span class="s0">{</span><span class="s1">freq</span><span class="s0">}</span><span class="s4">&quot;</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">) </span><span class="s0">from </span><span class="s1">err</span>
    <span class="s0">elif </span><span class="s1">holidays </span><span class="s0">or </span><span class="s1">weekmask</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= (</span>
            <span class="s4">&quot;a custom frequency string is required when holidays or &quot;</span>
            <span class="s4">f&quot;weekmask are passed, got frequency </span><span class="s0">{</span><span class="s1">freq</span><span class="s0">}</span><span class="s4">&quot;</span>
        <span class="s2">)</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">date_range</span><span class="s2">(</span>
        <span class="s1">start</span><span class="s2">=</span><span class="s1">start</span><span class="s2">,</span>
        <span class="s1">end</span><span class="s2">=</span><span class="s1">end</span><span class="s2">,</span>
        <span class="s1">periods</span><span class="s2">=</span><span class="s1">periods</span><span class="s2">,</span>
        <span class="s1">freq</span><span class="s2">=</span><span class="s1">freq</span><span class="s2">,</span>
        <span class="s1">tz</span><span class="s2">=</span><span class="s1">tz</span><span class="s2">,</span>
        <span class="s1">normalize</span><span class="s2">=</span><span class="s1">normalize</span><span class="s2">,</span>
        <span class="s1">name</span><span class="s2">=</span><span class="s1">name</span><span class="s2">,</span>
        <span class="s1">inclusive</span><span class="s2">=</span><span class="s1">inclusive</span><span class="s2">,</span>
        <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">,</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">_time_to_micros</span><span class="s2">(</span><span class="s1">time_obj</span><span class="s2">: </span><span class="s1">dt</span><span class="s2">.</span><span class="s1">time</span><span class="s2">) </span><span class="s1">-&gt; int</span><span class="s2">:</span>
    <span class="s1">seconds </span><span class="s2">= </span><span class="s1">time_obj</span><span class="s2">.</span><span class="s1">hour </span><span class="s2">* </span><span class="s6">60 </span><span class="s2">* </span><span class="s6">60 </span><span class="s2">+ </span><span class="s6">60 </span><span class="s2">* </span><span class="s1">time_obj</span><span class="s2">.</span><span class="s1">minute </span><span class="s2">+ </span><span class="s1">time_obj</span><span class="s2">.</span><span class="s1">second</span>
    <span class="s0">return </span><span class="s6">1_000_000 </span><span class="s2">* </span><span class="s1">seconds </span><span class="s2">+ </span><span class="s1">time_obj</span><span class="s2">.</span><span class="s1">microsecond</span>
</pre>
</body>
</html>