<html>
<head>
<title>test_json.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_json.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">import </span><span class="s1">sys</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">import </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">_testing </span><span class="s0">as </span><span class="s1">tm</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">tests</span><span class="s2">.</span><span class="s1">extension </span><span class="s0">import </span><span class="s1">base</span>
<span class="s0">from </span><span class="s1">pandas</span><span class="s2">.</span><span class="s1">tests</span><span class="s2">.</span><span class="s1">extension</span><span class="s2">.</span><span class="s1">json</span><span class="s2">.</span><span class="s1">array </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">JSONArray</span><span class="s2">,</span>
    <span class="s1">JSONDtype</span><span class="s2">,</span>
    <span class="s1">make_data</span><span class="s2">,</span>
<span class="s2">)</span>

<span class="s3"># We intentionally don't run base.BaseSetitemTests because pandas'</span>
<span class="s3"># internals has trouble setting sequences of values into scalar positions.</span>
<span class="s1">unhashable </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;Unhashable&quot;</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">fixture</span>
<span class="s0">def </span><span class="s1">dtype</span><span class="s2">():</span>
    <span class="s0">return </span><span class="s1">JSONDtype</span><span class="s2">()</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">fixture</span>
<span class="s0">def </span><span class="s1">data</span><span class="s2">():</span>
    <span class="s5">&quot;&quot;&quot;Length-100 PeriodArray for semantics test.&quot;&quot;&quot;</span>
    <span class="s1">data </span><span class="s2">= </span><span class="s1">make_data</span><span class="s2">()</span>

    <span class="s3"># Why the while loop? NumPy is unable to construct an ndarray from</span>
    <span class="s3"># equal-length ndarrays. Many of our operations involve coercing the</span>
    <span class="s3"># EA to an ndarray of objects. To avoid random test failures, we ensure</span>
    <span class="s3"># that our data is coercible to an ndarray. Several tests deal with only</span>
    <span class="s3"># the first two elements, so that's what we'll check.</span>

    <span class="s0">while </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]):</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">make_data</span><span class="s2">()</span>

    <span class="s0">return </span><span class="s1">JSONArray</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">fixture</span>
<span class="s0">def </span><span class="s1">data_missing</span><span class="s2">():</span>
    <span class="s5">&quot;&quot;&quot;Length 2 array with [NA, Valid]&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">JSONArray</span><span class="s2">([{}, {</span><span class="s4">&quot;a&quot;</span><span class="s2">: </span><span class="s6">10</span><span class="s2">}])</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">fixture</span>
<span class="s0">def </span><span class="s1">data_for_sorting</span><span class="s2">():</span>
    <span class="s0">return </span><span class="s1">JSONArray</span><span class="s2">([{</span><span class="s4">&quot;b&quot;</span><span class="s2">: </span><span class="s6">1</span><span class="s2">}, {</span><span class="s4">&quot;c&quot;</span><span class="s2">: </span><span class="s6">4</span><span class="s2">}, {</span><span class="s4">&quot;a&quot;</span><span class="s2">: </span><span class="s6">2</span><span class="s2">, </span><span class="s4">&quot;c&quot;</span><span class="s2">: </span><span class="s6">3</span><span class="s2">}])</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">fixture</span>
<span class="s0">def </span><span class="s1">data_missing_for_sorting</span><span class="s2">():</span>
    <span class="s0">return </span><span class="s1">JSONArray</span><span class="s2">([{</span><span class="s4">&quot;b&quot;</span><span class="s2">: </span><span class="s6">1</span><span class="s2">}, {}, {</span><span class="s4">&quot;a&quot;</span><span class="s2">: </span><span class="s6">4</span><span class="s2">}])</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">fixture</span>
<span class="s0">def </span><span class="s1">na_cmp</span><span class="s2">():</span>
    <span class="s0">return </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">eq</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">fixture</span>
<span class="s0">def </span><span class="s1">data_for_grouping</span><span class="s2">():</span>
    <span class="s0">return </span><span class="s1">JSONArray</span><span class="s2">(</span>
        <span class="s2">[</span>
            <span class="s2">{</span><span class="s4">&quot;b&quot;</span><span class="s2">: </span><span class="s6">1</span><span class="s2">},</span>
            <span class="s2">{</span><span class="s4">&quot;b&quot;</span><span class="s2">: </span><span class="s6">1</span><span class="s2">},</span>
            <span class="s2">{},</span>
            <span class="s2">{},</span>
            <span class="s2">{</span><span class="s4">&quot;a&quot;</span><span class="s2">: </span><span class="s6">0</span><span class="s2">, </span><span class="s4">&quot;c&quot;</span><span class="s2">: </span><span class="s6">2</span><span class="s2">},</span>
            <span class="s2">{</span><span class="s4">&quot;a&quot;</span><span class="s2">: </span><span class="s6">0</span><span class="s2">, </span><span class="s4">&quot;c&quot;</span><span class="s2">: </span><span class="s6">2</span><span class="s2">},</span>
            <span class="s2">{</span><span class="s4">&quot;b&quot;</span><span class="s2">: </span><span class="s6">1</span><span class="s2">},</span>
            <span class="s2">{</span><span class="s4">&quot;c&quot;</span><span class="s2">: </span><span class="s6">2</span><span class="s2">},</span>
        <span class="s2">]</span>
    <span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestJSONArray</span><span class="s2">(</span><span class="s1">base</span><span class="s2">.</span><span class="s1">ExtensionTests</span><span class="s2">):</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span>
        <span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;comparison method not implemented for JSONArray (GH-37867)&quot;</span>
    <span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_contains</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s3"># GH-37867</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_contains</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;not implemented constructor from dtype&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_from_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s3"># construct from our dtype &amp; string dtype</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_from_dtype</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;RecursionError, GH-33900&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_series_constructor_no_data_with_index</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">):</span>
        <span class="s3"># RecursionError: maximum recursion depth exceeded in comparison</span>
        <span class="s1">rec_limit </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">getrecursionlimit</span><span class="s2">()</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s3"># Limit to avoid stack overflow on Windows CI</span>
            <span class="s1">sys</span><span class="s2">.</span><span class="s1">setrecursionlimit</span><span class="s2">(</span><span class="s6">100</span><span class="s2">)</span>
            <span class="s1">super</span><span class="s2">().</span><span class="s1">test_series_constructor_no_data_with_index</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">)</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s1">sys</span><span class="s2">.</span><span class="s1">setrecursionlimit</span><span class="s2">(</span><span class="s1">rec_limit</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;RecursionError, GH-33900&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_series_constructor_scalar_na_with_index</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">):</span>
        <span class="s3"># RecursionError: maximum recursion depth exceeded in comparison</span>
        <span class="s1">rec_limit </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">getrecursionlimit</span><span class="s2">()</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s3"># Limit to avoid stack overflow on Windows CI</span>
            <span class="s1">sys</span><span class="s2">.</span><span class="s1">setrecursionlimit</span><span class="s2">(</span><span class="s6">100</span><span class="s2">)</span>
            <span class="s1">super</span><span class="s2">().</span><span class="s1">test_series_constructor_scalar_na_with_index</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">)</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s1">sys</span><span class="s2">.</span><span class="s1">setrecursionlimit</span><span class="s2">(</span><span class="s1">rec_limit</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;collection as scalar, GH-33901&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_series_constructor_scalar_with_index</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
        <span class="s3"># TypeError: All values must be of type &lt;class 'collections.abc.Mapping'&gt;</span>
        <span class="s1">rec_limit </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">getrecursionlimit</span><span class="s2">()</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s3"># Limit to avoid stack overflow on Windows CI</span>
            <span class="s1">sys</span><span class="s2">.</span><span class="s1">setrecursionlimit</span><span class="s2">(</span><span class="s6">100</span><span class="s2">)</span>
            <span class="s1">super</span><span class="s2">().</span><span class="s1">test_series_constructor_scalar_with_index</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s0">finally</span><span class="s2">:</span>
            <span class="s1">sys</span><span class="s2">.</span><span class="s1">setrecursionlimit</span><span class="s2">(</span><span class="s1">rec_limit</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;Different definitions of NA&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_stack</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        The test does .astype(object).stack(future_stack=True). If we happen to have 
        any missing values in `data`, then we'll end up with different 
        rows since we consider `{}` NA, but `.astype(object)` doesn't. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_stack</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;dict for NA&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_unstack</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">index</span><span class="s2">):</span>
        <span class="s3"># The base test has NaN for the expected NA value.</span>
        <span class="s3"># this matches otherwise</span>
        <span class="s0">return </span><span class="s1">super</span><span class="s2">().</span><span class="s1">test_unstack</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">index</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;Setting a dict as a scalar&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_fillna_series</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;We treat dictionaries as a mapping in fillna, not a scalar.&quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_fillna_series</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;Setting a dict as a scalar&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_fillna_frame</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;We treat dictionaries as a mapping in fillna, not a scalar.&quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_fillna_frame</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span>
        <span class="s4">&quot;limit_area, input_ilocs, expected_ilocs&quot;</span><span class="s2">,</span>
        <span class="s2">[</span>
            <span class="s2">(</span><span class="s4">&quot;outside&quot;</span><span class="s2">, [</span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">], [</span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">]),</span>
            <span class="s2">(</span><span class="s4">&quot;outside&quot;</span><span class="s2">, [</span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">], [</span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">]),</span>
            <span class="s2">(</span><span class="s4">&quot;outside&quot;</span><span class="s2">, [</span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">], [</span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">]),</span>
            <span class="s2">(</span><span class="s4">&quot;outside&quot;</span><span class="s2">, [</span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">], [</span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">]),</span>
            <span class="s2">(</span><span class="s4">&quot;inside&quot;</span><span class="s2">, [</span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">], [</span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">]),</span>
            <span class="s2">(</span><span class="s4">&quot;inside&quot;</span><span class="s2">, [</span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">], [</span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">]),</span>
            <span class="s2">(</span><span class="s4">&quot;inside&quot;</span><span class="s2">, [</span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">], [</span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">]),</span>
            <span class="s2">(</span><span class="s4">&quot;inside&quot;</span><span class="s2">, [</span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">], [</span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">]),</span>
        <span class="s2">],</span>
    <span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_ffill_limit_area</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">data_missing</span><span class="s2">, </span><span class="s1">limit_area</span><span class="s2">, </span><span class="s1">input_ilocs</span><span class="s2">, </span><span class="s1">expected_ilocs</span>
    <span class="s2">):</span>
        <span class="s3"># GH#56616</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s4">&quot;JSONArray does not implement limit_area&quot;</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">NotImplementedError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">):</span>
            <span class="s1">super</span><span class="s2">().</span><span class="s1">test_ffill_limit_area</span><span class="s2">(</span>
                <span class="s1">data_missing</span><span class="s2">, </span><span class="s1">limit_area</span><span class="s2">, </span><span class="s1">input_ilocs</span><span class="s2">, </span><span class="s1">expected_ilocs</span>
            <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">unhashable</span>
    <span class="s0">def </span><span class="s1">test_value_counts</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">all_data</span><span class="s2">, </span><span class="s1">dropna</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_value_counts</span><span class="s2">(</span><span class="s1">all_data</span><span class="s2">, </span><span class="s1">dropna</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">unhashable</span>
    <span class="s0">def </span><span class="s1">test_value_counts_with_normalize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_value_counts_with_normalize</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">unhashable</span>
    <span class="s0">def </span><span class="s1">test_sort_values_frame</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3"># TODO (EA.factorize): see if _values_for_factorize allows this.</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_sort_values_frame</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s4">&quot;ascending&quot;</span><span class="s2">, [</span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_sort_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data_for_sorting</span><span class="s2">, </span><span class="s1">ascending</span><span class="s2">, </span><span class="s1">sort_by_key</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_sort_values</span><span class="s2">(</span><span class="s1">data_for_sorting</span><span class="s2">, </span><span class="s1">ascending</span><span class="s2">, </span><span class="s1">sort_by_key</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s4">&quot;ascending&quot;</span><span class="s2">, [</span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_sort_values_missing</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">data_missing_for_sorting</span><span class="s2">, </span><span class="s1">ascending</span><span class="s2">, </span><span class="s1">sort_by_key</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_sort_values_missing</span><span class="s2">(</span>
            <span class="s1">data_missing_for_sorting</span><span class="s2">, </span><span class="s1">ascending</span><span class="s2">, </span><span class="s1">sort_by_key</span>
        <span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;combine for JSONArray not supported&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_combine_le</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data_repeated</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_combine_le</span><span class="s2">(</span><span class="s1">data_repeated</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span>
        <span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;combine for JSONArray not supported - &quot;</span>
        <span class="s4">&quot;may pass depending on random data&quot;</span><span class="s2">,</span>
        <span class="s1">strict</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
        <span class="s1">raises</span><span class="s2">=</span><span class="s1">AssertionError</span><span class="s2">,</span>
    <span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_combine_first</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_combine_first</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;broadcasting error&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_where_series</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">):</span>
        <span class="s3"># Fails with</span>
        <span class="s3"># *** ValueError: operands could not be broadcast together</span>
        <span class="s3"># with shapes (4,) (4,) (0,)</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_where_series</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;Can't compare dicts.&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_searchsorted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data_for_sorting</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_searchsorted</span><span class="s2">(</span><span class="s1">data_for_sorting</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;Can't compare dicts.&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_equals</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">, </span><span class="s1">as_series</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_equals</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">na_value</span><span class="s2">, </span><span class="s1">as_series</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">skip</span><span class="s2">(</span><span class="s4">&quot;fill-value is interpreted as a dict of values&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_fillna_copy_frame</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data_missing</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_fillna_copy_frame</span><span class="s2">(</span><span class="s1">data_missing</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_equals_same_data_different_object</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">using_copy_on_write</span><span class="s2">, </span><span class="s1">request</span>
    <span class="s2">):</span>
        <span class="s0">if </span><span class="s1">using_copy_on_write</span><span class="s2">:</span>
            <span class="s1">mark </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;Fails with CoW&quot;</span><span class="s2">)</span>
            <span class="s1">request</span><span class="s2">.</span><span class="s1">applymarker</span><span class="s2">(</span><span class="s1">mark</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_equals_same_data_different_object</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;failing on np.array(self, dtype=str)&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_astype_str</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot;This currently fails in NumPy on np.array(self, dtype=str) with 
 
        *** ValueError: setting an array element with a sequence 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_astype_str</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">unhashable</span>
    <span class="s0">def </span><span class="s1">test_groupby_extension_transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        This currently fails in Series.name.setter, since the 
        name must be hashable, but the value is a dictionary. 
        I think this is what we want, i.e. `.name` should be the original 
        values, and not the values for factorization. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_groupby_extension_transform</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">unhashable</span>
    <span class="s0">def </span><span class="s1">test_groupby_extension_apply</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        This fails in Index._do_unique_check with 
 
        &gt;   hash(val) 
        E   TypeError: unhashable type: 'UserDict' with 
 
        I suspect that once we support Index[ExtensionArray], 
        we'll be able to dispatch unique. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_groupby_extension_apply</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">unhashable</span>
    <span class="s0">def </span><span class="s1">test_groupby_extension_agg</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        This fails when we get to tm.assert_series_equal when left.index 
        contains dictionaries, which are not hashable. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_groupby_extension_agg</span><span class="s2">()</span>

    <span class="s2">@</span><span class="s1">unhashable</span>
    <span class="s0">def </span><span class="s1">test_groupby_extension_no_sort</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; 
        This fails when we get to tm.assert_series_equal when left.index 
        contains dictionaries, which are not hashable. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_groupby_extension_no_sort</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">test_arith_frame_with_scalar</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators</span><span class="s2">, </span><span class="s1">request</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]) != </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">mark </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;raises in coercing to Series&quot;</span><span class="s2">)</span>
            <span class="s1">request</span><span class="s2">.</span><span class="s1">applymarker</span><span class="s2">(</span><span class="s1">mark</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_arith_frame_with_scalar</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">all_arithmetic_operators</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_compare_array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">comparison_op</span><span class="s2">, </span><span class="s1">request</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">comparison_op</span><span class="s2">.</span><span class="s1">__name__ </span><span class="s0">in </span><span class="s2">[</span><span class="s4">&quot;eq&quot;</span><span class="s2">, </span><span class="s4">&quot;ne&quot;</span><span class="s2">]:</span>
            <span class="s1">mark </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;Comparison methods not implemented&quot;</span><span class="s2">)</span>
            <span class="s1">request</span><span class="s2">.</span><span class="s1">applymarker</span><span class="s2">(</span><span class="s1">mark</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_compare_array</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">comparison_op</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;ValueError: Must have equal len keys and value&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_setitem_loc_scalar_mixed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_loc_scalar_mixed</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;ValueError: Must have equal len keys and value&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_setitem_loc_scalar_multiple_homogoneous</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_loc_scalar_multiple_homogoneous</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;ValueError: Must have equal len keys and value&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_setitem_iloc_scalar_mixed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_iloc_scalar_mixed</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;ValueError: Must have equal len keys and value&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_setitem_iloc_scalar_multiple_homogoneous</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_iloc_scalar_multiple_homogoneous</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span>
        <span class="s4">&quot;mask&quot;</span><span class="s2">,</span>
        <span class="s2">[</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s0">True</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">]),</span>
            <span class="s1">pd</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s0">True</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">, </span><span class="s0">False</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">&quot;boolean&quot;</span><span class="s2">),</span>
            <span class="s1">pd</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s0">True</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s0">True</span><span class="s2">, </span><span class="s1">pd</span><span class="s2">.</span><span class="s1">NA</span><span class="s2">, </span><span class="s1">pd</span><span class="s2">.</span><span class="s1">NA</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">&quot;boolean&quot;</span><span class="s2">),</span>
        <span class="s2">],</span>
        <span class="s1">ids</span><span class="s2">=[</span><span class="s4">&quot;numpy-array&quot;</span><span class="s2">, </span><span class="s4">&quot;boolean-array&quot;</span><span class="s2">, </span><span class="s4">&quot;boolean-array-na&quot;</span><span class="s2">],</span>
    <span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_setitem_mask</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">box_in_series</span><span class="s2">, </span><span class="s1">request</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">box_in_series</span><span class="s2">:</span>
            <span class="s1">mark </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span>
                <span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;cannot set using a list-like indexer with a different length&quot;</span>
            <span class="s2">)</span>
            <span class="s1">request</span><span class="s2">.</span><span class="s1">applymarker</span><span class="s2">(</span><span class="s1">mark</span><span class="s2">)</span>
        <span class="s0">elif not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">mask</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">):</span>
            <span class="s1">mark </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;Issues unwanted DeprecationWarning&quot;</span><span class="s2">)</span>
            <span class="s1">request</span><span class="s2">.</span><span class="s1">applymarker</span><span class="s2">(</span><span class="s1">mark</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_mask</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">box_in_series</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_setitem_mask_raises</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">box_in_series</span><span class="s2">, </span><span class="s1">request</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">box_in_series</span><span class="s2">:</span>
            <span class="s1">mark </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;Fails to raise&quot;</span><span class="s2">)</span>
            <span class="s1">request</span><span class="s2">.</span><span class="s1">applymarker</span><span class="s2">(</span><span class="s1">mark</span><span class="s2">)</span>

        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_mask_raises</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">box_in_series</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span>
        <span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;cannot set using a list-like indexer with a different length&quot;</span>
    <span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_setitem_mask_boolean_array_with_na</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">box_in_series</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_mask_boolean_array_with_na</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">box_in_series</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span>
        <span class="s4">&quot;idx&quot;</span><span class="s2">,</span>
        <span class="s2">[[</span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">2</span><span class="s2">], </span><span class="s1">pd</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">2</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">&quot;Int64&quot;</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">2</span><span class="s2">])],</span>
        <span class="s1">ids</span><span class="s2">=[</span><span class="s4">&quot;list&quot;</span><span class="s2">, </span><span class="s4">&quot;integer-array&quot;</span><span class="s2">, </span><span class="s4">&quot;numpy-array&quot;</span><span class="s2">],</span>
    <span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_setitem_integer_array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">box_in_series</span><span class="s2">, </span><span class="s1">request</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">box_in_series</span><span class="s2">:</span>
            <span class="s1">mark </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span>
                <span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;cannot set using a list-like indexer with a different length&quot;</span>
            <span class="s2">)</span>
            <span class="s1">request</span><span class="s2">.</span><span class="s1">applymarker</span><span class="s2">(</span><span class="s1">mark</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_integer_array</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">box_in_series</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;list indices must be integers or slices, not NAType&quot;</span><span class="s2">)</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span>
        <span class="s4">&quot;idx, box_in_series&quot;</span><span class="s2">,</span>
        <span class="s2">[</span>
            <span class="s2">([</span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">2</span><span class="s2">, </span><span class="s1">pd</span><span class="s2">.</span><span class="s1">NA</span><span class="s2">], </span><span class="s0">False</span><span class="s2">),</span>
            <span class="s1">pytest</span><span class="s2">.</span><span class="s1">param</span><span class="s2">(</span>
                <span class="s2">[</span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">2</span><span class="s2">, </span><span class="s1">pd</span><span class="s2">.</span><span class="s1">NA</span><span class="s2">], </span><span class="s0">True</span><span class="s2">, </span><span class="s1">marks</span><span class="s2">=</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;GH-31948&quot;</span><span class="s2">)</span>
            <span class="s2">),</span>
            <span class="s2">(</span><span class="s1">pd</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">2</span><span class="s2">, </span><span class="s1">pd</span><span class="s2">.</span><span class="s1">NA</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">&quot;Int64&quot;</span><span class="s2">), </span><span class="s0">False</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s1">pd</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s6">2</span><span class="s2">, </span><span class="s1">pd</span><span class="s2">.</span><span class="s1">NA</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">&quot;Int64&quot;</span><span class="s2">), </span><span class="s0">False</span><span class="s2">),</span>
        <span class="s2">],</span>
        <span class="s1">ids</span><span class="s2">=[</span><span class="s4">&quot;list-False&quot;</span><span class="s2">, </span><span class="s4">&quot;list-True&quot;</span><span class="s2">, </span><span class="s4">&quot;integer-array-False&quot;</span><span class="s2">, </span><span class="s4">&quot;integer-array-True&quot;</span><span class="s2">],</span>
    <span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_setitem_integer_with_missing_raises</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">box_in_series</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_integer_with_missing_raises</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">box_in_series</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;Fails to raise&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_setitem_scalar_key_sequence_raise</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_scalar_key_sequence_raise</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_setitem_with_expansion_dataframe_column</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">full_indexer</span><span class="s2">, </span><span class="s1">request</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s4">&quot;full_slice&quot; </span><span class="s0">in </span><span class="s1">request</span><span class="s2">.</span><span class="s1">node</span><span class="s2">.</span><span class="s1">name</span><span class="s2">:</span>
            <span class="s1">mark </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;slice is not iterable&quot;</span><span class="s2">)</span>
            <span class="s1">request</span><span class="s2">.</span><span class="s1">applymarker</span><span class="s2">(</span><span class="s1">mark</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_with_expansion_dataframe_column</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">full_indexer</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;slice is not iterable&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_setitem_frame_2d_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_frame_2d_values</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span>
        <span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;cannot set using a list-like indexer with a different length&quot;</span>
    <span class="s2">)</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s4">&quot;setter&quot;</span><span class="s2">, [</span><span class="s4">&quot;loc&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_setitem_mask_broadcast</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">setter</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_mask_broadcast</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">setter</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span>
        <span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;cannot set using a slice indexer with a different length&quot;</span>
    <span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_setitem_slice</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">box_in_series</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_slice</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">box_in_series</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;slice object is not iterable&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_setitem_loc_iloc_slice</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_loc_iloc_slice</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;slice object is not iterable&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_setitem_slice_mismatch_length_raises</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_slice_mismatch_length_raises</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;slice object is not iterable&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_setitem_slice_array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_slice_array</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;Fail to raise&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_setitem_invalid</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">invalid_scalar</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_invalid</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">invalid_scalar</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;only integer scalar arrays can be converted&quot;</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_setitem_2d_values</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_setitem_2d_values</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">xfail</span><span class="s2">(</span><span class="s1">reason</span><span class="s2">=</span><span class="s4">&quot;data type 'json' not understood&quot;</span><span class="s2">)</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s4">&quot;engine&quot;</span><span class="s2">, [</span><span class="s4">&quot;c&quot;</span><span class="s2">, </span><span class="s4">&quot;python&quot;</span><span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_EA_types</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">engine</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">request</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">test_EA_types</span><span class="s2">(</span><span class="s1">engine</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">request</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">custom_assert_series_equal</span><span class="s2">(</span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
    <span class="s3"># NumPy doesn't handle an array of equal-length UserDicts.</span>
    <span class="s3"># The default assert_series_equal eventually does a</span>
    <span class="s3"># Series.values, which raises. We work around it by</span>
    <span class="s3"># converting the UserDicts to dicts.</span>
    <span class="s0">if </span><span class="s1">left</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">name </span><span class="s2">== </span><span class="s4">&quot;json&quot;</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">left</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">right</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s1">left </span><span class="s2">= </span><span class="s1">pd</span><span class="s2">.</span><span class="s1">Series</span><span class="s2">(</span>
            <span class="s1">JSONArray</span><span class="s2">(</span><span class="s1">left</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">object</span><span class="s2">)), </span><span class="s1">index</span><span class="s2">=</span><span class="s1">left</span><span class="s2">.</span><span class="s1">index</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">left</span><span class="s2">.</span><span class="s1">name</span>
        <span class="s2">)</span>
        <span class="s1">right </span><span class="s2">= </span><span class="s1">pd</span><span class="s2">.</span><span class="s1">Series</span><span class="s2">(</span>
            <span class="s1">JSONArray</span><span class="s2">(</span><span class="s1">right</span><span class="s2">.</span><span class="s1">values</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">object</span><span class="s2">)),</span>
            <span class="s1">index</span><span class="s2">=</span><span class="s1">right</span><span class="s2">.</span><span class="s1">index</span><span class="s2">,</span>
            <span class="s1">name</span><span class="s2">=</span><span class="s1">right</span><span class="s2">.</span><span class="s1">name</span><span class="s2">,</span>
        <span class="s2">)</span>
    <span class="s1">tm</span><span class="s2">.</span><span class="s1">assert_series_equal</span><span class="s2">(</span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">custom_assert_frame_equal</span><span class="s2">(</span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
    <span class="s1">obj_type </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">&quot;obj&quot;</span><span class="s2">, </span><span class="s4">&quot;DataFrame&quot;</span><span class="s2">)</span>
    <span class="s1">tm</span><span class="s2">.</span><span class="s1">assert_index_equal</span><span class="s2">(</span>
        <span class="s1">left</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">,</span>
        <span class="s1">right</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">,</span>
        <span class="s1">exact</span><span class="s2">=</span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">&quot;check_column_type&quot;</span><span class="s2">, </span><span class="s4">&quot;equiv&quot;</span><span class="s2">),</span>
        <span class="s1">check_names</span><span class="s2">=</span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">&quot;check_names&quot;</span><span class="s2">, </span><span class="s0">True</span><span class="s2">),</span>
        <span class="s1">check_exact</span><span class="s2">=</span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">&quot;check_exact&quot;</span><span class="s2">, </span><span class="s0">False</span><span class="s2">),</span>
        <span class="s1">check_categorical</span><span class="s2">=</span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s4">&quot;check_categorical&quot;</span><span class="s2">, </span><span class="s0">True</span><span class="s2">),</span>
        <span class="s1">obj</span><span class="s2">=</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">obj_type</span><span class="s0">}</span><span class="s4">.columns&quot;</span><span class="s2">,</span>
    <span class="s2">)</span>

    <span class="s1">jsons </span><span class="s2">= (</span><span class="s1">left</span><span class="s2">.</span><span class="s1">dtypes </span><span class="s2">== </span><span class="s4">&quot;json&quot;</span><span class="s2">).</span><span class="s1">index</span>

    <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">jsons</span><span class="s2">:</span>
        <span class="s1">custom_assert_series_equal</span><span class="s2">(</span><span class="s1">left</span><span class="s2">[</span><span class="s1">col</span><span class="s2">], </span><span class="s1">right</span><span class="s2">[</span><span class="s1">col</span><span class="s2">], *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s1">left </span><span class="s2">= </span><span class="s1">left</span><span class="s2">.</span><span class="s1">drop</span><span class="s2">(</span><span class="s1">columns</span><span class="s2">=</span><span class="s1">jsons</span><span class="s2">)</span>
    <span class="s1">right </span><span class="s2">= </span><span class="s1">right</span><span class="s2">.</span><span class="s1">drop</span><span class="s2">(</span><span class="s1">columns</span><span class="s2">=</span><span class="s1">jsons</span><span class="s2">)</span>
    <span class="s1">tm</span><span class="s2">.</span><span class="s1">assert_frame_equal</span><span class="s2">(</span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_custom_asserts</span><span class="s2">():</span>
    <span class="s3"># This would always trigger the KeyError from trying to put</span>
    <span class="s3"># an array of equal-length UserDicts inside an ndarray.</span>
    <span class="s1">data </span><span class="s2">= </span><span class="s1">JSONArray</span><span class="s2">(</span>
        <span class="s2">[</span>
            <span class="s1">collections</span><span class="s2">.</span><span class="s1">UserDict</span><span class="s2">({</span><span class="s4">&quot;a&quot;</span><span class="s2">: </span><span class="s6">1</span><span class="s2">}),</span>
            <span class="s1">collections</span><span class="s2">.</span><span class="s1">UserDict</span><span class="s2">({</span><span class="s4">&quot;b&quot;</span><span class="s2">: </span><span class="s6">2</span><span class="s2">}),</span>
            <span class="s1">collections</span><span class="s2">.</span><span class="s1">UserDict</span><span class="s2">({</span><span class="s4">&quot;c&quot;</span><span class="s2">: </span><span class="s6">3</span><span class="s2">}),</span>
        <span class="s2">]</span>
    <span class="s2">)</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">pd</span><span class="s2">.</span><span class="s1">Series</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
    <span class="s1">custom_assert_series_equal</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">a</span><span class="s2">)</span>
    <span class="s1">custom_assert_frame_equal</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">to_frame</span><span class="s2">(), </span><span class="s1">a</span><span class="s2">.</span><span class="s1">to_frame</span><span class="s2">())</span>

    <span class="s1">b </span><span class="s2">= </span><span class="s1">pd</span><span class="s2">.</span><span class="s1">Series</span><span class="s2">(</span><span class="s1">data</span><span class="s2">.</span><span class="s1">take</span><span class="s2">([</span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">]))</span>
    <span class="s1">msg </span><span class="s2">= </span><span class="s4">r&quot;Series are different&quot;</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">AssertionError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">):</span>
        <span class="s1">custom_assert_series_equal</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">AssertionError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">):</span>
        <span class="s1">custom_assert_frame_equal</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">to_frame</span><span class="s2">(), </span><span class="s1">b</span><span class="s2">.</span><span class="s1">to_frame</span><span class="s2">())</span>
</pre>
</body>
</html>