<html>
<head>
<title>_discrete_distns.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_discrete_distns.py</font>
</center></td></tr></table>
<pre><span class="s0">#</span>
<span class="s0"># Author:  Travis Oliphant  2002-2011 with contributions from</span>
<span class="s0">#          SciPy Developers 2004-2011</span>
<span class="s0">#</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>

<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">special</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special </span><span class="s2">import </span><span class="s1">entr</span><span class="s3">, </span><span class="s1">logsumexp</span><span class="s3">, </span><span class="s1">betaln</span><span class="s3">, </span><span class="s1">gammaln </span><span class="s2">as </span><span class="s1">gamln</span><span class="s3">, </span><span class="s1">zeta</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">_lib</span><span class="s3">.</span><span class="s1">_util </span><span class="s2">import </span><span class="s1">_lazywhere</span><span class="s3">, </span><span class="s1">rng_integers</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">interpolate </span><span class="s2">import </span><span class="s1">interp1d</span>

<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">floor</span><span class="s3">, </span><span class="s1">ceil</span><span class="s3">, </span><span class="s1">log</span><span class="s3">, </span><span class="s1">exp</span><span class="s3">, </span><span class="s1">sqrt</span><span class="s3">, </span><span class="s1">log1p</span><span class="s3">, </span><span class="s1">expm1</span><span class="s3">, </span><span class="s1">tanh</span><span class="s3">, </span><span class="s1">cosh</span><span class="s3">, </span><span class="s1">sinh</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">_distn_infrastructure </span><span class="s2">import </span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">, </span><span class="s1">get_distribution_names</span><span class="s3">,</span>
                                    <span class="s1">_vectorize_rvs_over_shapes</span><span class="s3">,</span>
                                    <span class="s1">_ShapeInfo</span><span class="s3">, </span><span class="s1">_isintegral</span><span class="s3">)</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_biasedurn </span><span class="s2">import </span><span class="s3">(</span><span class="s1">_PyFishersNCHypergeometric</span><span class="s3">,</span>
                         <span class="s1">_PyWalleniusNCHypergeometric</span><span class="s3">,</span>
                         <span class="s1">_PyStochasticLib3</span><span class="s3">)</span>
<span class="s2">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special</span><span class="s3">.</span><span class="s1">_ufuncs </span><span class="s2">as </span><span class="s1">scu</span>



<span class="s2">class </span><span class="s1">binom_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A binomial discrete random variable. 
 
    %(before_notes)s 
 
    Notes 
    ----- 
    The probability mass function for `binom` is: 
 
    .. math:: 
 
       f(k) = \binom{n}{k} p^k (1-p)^{n-k} 
 
    for :math:`k \in \{0, 1, \dots, n\}`, :math:`0 \leq p \leq 1` 
 
    `binom` takes :math:`n` and :math:`p` as shape parameters, 
    where :math:`p` is the probability of a single success 
    and :math:`1-p` is the probability of a single failure. 
 
    %(after_notes)s 
 
    %(example)s 
 
    See Also 
    -------- 
    hypergeom, nbinom, nhypergeom 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;n&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)),</span>
                <span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;p&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">True</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">binomial</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_argcheck</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">) &amp; </span><span class="s1">_isintegral</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) &amp; (</span><span class="s1">p </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">) &amp; (</span><span class="s1">p </span><span class="s3">&lt;= </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_support</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">a</span><span class="s3">, </span><span class="s1">n</span>

    <span class="s2">def </span><span class="s1">_logpmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">combiln </span><span class="s3">= (</span><span class="s1">gamln</span><span class="s3">(</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">) - (</span><span class="s1">gamln</span><span class="s3">(</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1</span><span class="s3">) + </span><span class="s1">gamln</span><span class="s3">(</span><span class="s1">n</span><span class="s3">-</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)))</span>
        <span class="s2">return </span><span class="s1">combiln </span><span class="s3">+ </span><span class="s1">special</span><span class="s3">.</span><span class="s1">xlogy</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">p</span><span class="s3">) + </span><span class="s1">special</span><span class="s3">.</span><span class="s1">xlog1py</span><span class="s3">(</span><span class="s1">n</span><span class="s3">-</span><span class="s1">k</span><span class="s3">, -</span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s0"># binom.pmf(k) = choose(n, k) * p**k * (1-p)**(n-k)</span>
        <span class="s2">return </span><span class="s1">scu</span><span class="s3">.</span><span class="s1">_binom_pmf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">scu</span><span class="s3">.</span><span class="s1">_binom_cdf</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_sf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">scu</span><span class="s3">.</span><span class="s1">_binom_sf</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_isf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">scu</span><span class="s3">.</span><span class="s1">_binom_isf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_ppf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">scu</span><span class="s3">.</span><span class="s1">_binom_ppf</span><span class="s3">(</span><span class="s1">q</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">moments</span><span class="s3">=</span><span class="s5">'mv'</span><span class="s3">):</span>
        <span class="s1">mu </span><span class="s3">= </span><span class="s1">n </span><span class="s3">* </span><span class="s1">p</span>
        <span class="s1">var </span><span class="s3">= </span><span class="s1">mu </span><span class="s3">- </span><span class="s1">n </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">square</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
        <span class="s1">g1</span><span class="s3">, </span><span class="s1">g2 </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s5">'s' </span><span class="s2">in </span><span class="s1">moments</span><span class="s3">:</span>
            <span class="s1">pq </span><span class="s3">= </span><span class="s1">p </span><span class="s3">- </span><span class="s1">np</span><span class="s3">.</span><span class="s1">square</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
            <span class="s1">npq_sqrt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">n </span><span class="s3">* </span><span class="s1">pq</span><span class="s3">)</span>
            <span class="s1">t1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">reciprocal</span><span class="s3">(</span><span class="s1">npq_sqrt</span><span class="s3">)</span>
            <span class="s1">t2 </span><span class="s3">= (</span><span class="s6">2.0 </span><span class="s3">* </span><span class="s1">p</span><span class="s3">) / </span><span class="s1">npq_sqrt</span>
            <span class="s1">g1 </span><span class="s3">= </span><span class="s1">t1 </span><span class="s3">- </span><span class="s1">t2</span>
        <span class="s2">if </span><span class="s5">'k' </span><span class="s2">in </span><span class="s1">moments</span><span class="s3">:</span>
            <span class="s1">pq </span><span class="s3">= </span><span class="s1">p </span><span class="s3">- </span><span class="s1">np</span><span class="s3">.</span><span class="s1">square</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
            <span class="s1">npq </span><span class="s3">= </span><span class="s1">n </span><span class="s3">* </span><span class="s1">pq</span>
            <span class="s1">t1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">reciprocal</span><span class="s3">(</span><span class="s1">npq</span><span class="s3">)</span>
            <span class="s1">t2 </span><span class="s3">= </span><span class="s6">6.0</span><span class="s3">/</span><span class="s1">n</span>
            <span class="s1">g2 </span><span class="s3">= </span><span class="s1">t1 </span><span class="s3">- </span><span class="s1">t2</span>
        <span class="s2">return </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var</span><span class="s3">, </span><span class="s1">g1</span><span class="s3">, </span><span class="s1">g2</span>

    <span class="s2">def </span><span class="s1">_entropy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">r_</span><span class="s3">[</span><span class="s6">0</span><span class="s3">:</span><span class="s1">n </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">vals </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">entr</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)</span>


<span class="s1">binom </span><span class="s3">= </span><span class="s1">binom_gen</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s5">'binom'</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">bernoulli_gen</span><span class="s3">(</span><span class="s1">binom_gen</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A Bernoulli discrete random variable. 
 
    %(before_notes)s 
 
    Notes 
    ----- 
    The probability mass function for `bernoulli` is: 
 
    .. math:: 
 
       f(k) = \begin{cases}1-p  &amp;\text{if } k = 0\\ 
                           p    &amp;\text{if } k = 1\end{cases} 
 
    for :math:`k` in :math:`\{0, 1\}`, :math:`0 \leq p \leq 1` 
 
    `bernoulli` takes :math:`p` as shape parameter, 
    where :math:`p` is the probability of a single success 
    and :math:`1-p` is the probability of a single failure. 
 
    %(after_notes)s 
 
    %(example)s 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;p&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">True</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">binom_gen</span><span class="s3">.</span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">size</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">random_state</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_argcheck</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">p </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">) &amp; (</span><span class="s1">p </span><span class="s3">&lt;= </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_support</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s0"># Overrides binom_gen._get_support!x</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">a</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">b</span>

    <span class="s2">def </span><span class="s1">_logpmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">binom</span><span class="s3">.</span><span class="s1">_logpmf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s0"># bernoulli.pmf(k) = 1-p  if k = 0</span>
        <span class="s0">#                  = p    if k = 1</span>
        <span class="s2">return </span><span class="s1">binom</span><span class="s3">.</span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">binom</span><span class="s3">.</span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_sf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">binom</span><span class="s3">.</span><span class="s1">_sf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_isf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">binom</span><span class="s3">.</span><span class="s1">_isf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_ppf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">binom</span><span class="s3">.</span><span class="s1">_ppf</span><span class="s3">(</span><span class="s1">q</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">binom</span><span class="s3">.</span><span class="s1">_stats</span><span class="s3">(</span><span class="s6">1</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_entropy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">entr</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) + </span><span class="s1">entr</span><span class="s3">(</span><span class="s6">1</span><span class="s3">-</span><span class="s1">p</span><span class="s3">)</span>


<span class="s1">bernoulli </span><span class="s3">= </span><span class="s1">bernoulli_gen</span><span class="s3">(</span><span class="s1">b</span><span class="s3">=</span><span class="s6">1</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s5">'bernoulli'</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">betabinom_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A beta-binomial discrete random variable. 
 
    %(before_notes)s 
 
    Notes 
    ----- 
    The beta-binomial distribution is a binomial distribution with a 
    probability of success `p` that follows a beta distribution. 
 
    The probability mass function for `betabinom` is: 
 
    .. math:: 
 
       f(k) = \binom{n}{k} \frac{B(k + a, n - k + b)}{B(a, b)} 
 
    for :math:`k \in \{0, 1, \dots, n\}`, :math:`n \geq 0`, :math:`a &gt; 0`, 
    :math:`b &gt; 0`, where :math:`B(a, b)` is the beta function. 
 
    `betabinom` takes :math:`n`, :math:`a`, and :math:`b` as shape parameters. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Beta-binomial_distribution 
 
    %(after_notes)s 
 
    .. versionadded:: 1.4.0 
 
    See Also 
    -------- 
    beta, binom 
 
    %(example)s 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;n&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)),</span>
                <span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;a&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)),</span>
                <span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;b&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">beta</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">binomial</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_support</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s3">, </span><span class="s1">n</span>

    <span class="s2">def </span><span class="s1">_argcheck</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">) &amp; </span><span class="s1">_isintegral</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) &amp; (</span><span class="s1">a </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">) &amp; (</span><span class="s1">b </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_logpmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">combiln </span><span class="s3">= -</span><span class="s1">log</span><span class="s3">(</span><span class="s1">n </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">) - </span><span class="s1">betaln</span><span class="s3">(</span><span class="s1">n </span><span class="s3">- </span><span class="s1">k </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">, </span><span class="s1">k </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">combiln </span><span class="s3">+ </span><span class="s1">betaln</span><span class="s3">(</span><span class="s1">k </span><span class="s3">+ </span><span class="s1">a</span><span class="s3">, </span><span class="s1">n </span><span class="s3">- </span><span class="s1">k </span><span class="s3">+ </span><span class="s1">b</span><span class="s3">) - </span><span class="s1">betaln</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">exp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_logpmf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">moments</span><span class="s3">=</span><span class="s5">'mv'</span><span class="s3">):</span>
        <span class="s1">e_p </span><span class="s3">= </span><span class="s1">a </span><span class="s3">/ (</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b</span><span class="s3">)</span>
        <span class="s1">e_q </span><span class="s3">= </span><span class="s6">1 </span><span class="s3">- </span><span class="s1">e_p</span>
        <span class="s1">mu </span><span class="s3">= </span><span class="s1">n </span><span class="s3">* </span><span class="s1">e_p</span>
        <span class="s1">var </span><span class="s3">= </span><span class="s1">n </span><span class="s3">* (</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b </span><span class="s3">+ </span><span class="s1">n</span><span class="s3">) * </span><span class="s1">e_p </span><span class="s3">* </span><span class="s1">e_q </span><span class="s3">/ (</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">)</span>
        <span class="s1">g1</span><span class="s3">, </span><span class="s1">g2 </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s5">'s' </span><span class="s2">in </span><span class="s1">moments</span><span class="s3">:</span>
            <span class="s1">g1 </span><span class="s3">= </span><span class="s6">1.0 </span><span class="s3">/ </span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">var</span><span class="s3">)</span>
            <span class="s1">g1 </span><span class="s3">*= (</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b </span><span class="s3">+ </span><span class="s6">2 </span><span class="s3">* </span><span class="s1">n</span><span class="s3">) * (</span><span class="s1">b </span><span class="s3">- </span><span class="s1">a</span><span class="s3">)</span>
            <span class="s1">g1 </span><span class="s3">/= (</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b </span><span class="s3">+ </span><span class="s6">2</span><span class="s3">) * (</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s5">'k' </span><span class="s2">in </span><span class="s1">moments</span><span class="s3">:</span>
            <span class="s1">g2 </span><span class="s3">= (</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">e_p</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">g2 </span><span class="s3">*= (</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b </span><span class="s3">- </span><span class="s6">1 </span><span class="s3">+ </span><span class="s6">6 </span><span class="s3">* </span><span class="s1">n</span><span class="s3">)</span>
            <span class="s1">g2 </span><span class="s3">+= </span><span class="s6">3 </span><span class="s3">* </span><span class="s1">a </span><span class="s3">* </span><span class="s1">b </span><span class="s3">* (</span><span class="s1">n </span><span class="s3">- </span><span class="s6">2</span><span class="s3">)</span>
            <span class="s1">g2 </span><span class="s3">+= </span><span class="s6">6 </span><span class="s3">* </span><span class="s1">n </span><span class="s3">** </span><span class="s6">2</span>
            <span class="s1">g2 </span><span class="s3">-= </span><span class="s6">3 </span><span class="s3">* </span><span class="s1">e_p </span><span class="s3">* </span><span class="s1">b </span><span class="s3">* </span><span class="s1">n </span><span class="s3">* (</span><span class="s6">6 </span><span class="s3">- </span><span class="s1">n</span><span class="s3">)</span>
            <span class="s1">g2 </span><span class="s3">-= </span><span class="s6">18 </span><span class="s3">* </span><span class="s1">e_p </span><span class="s3">* </span><span class="s1">e_q </span><span class="s3">* </span><span class="s1">n </span><span class="s3">** </span><span class="s6">2</span>
            <span class="s1">g2 </span><span class="s3">*= (</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b</span><span class="s3">) ** </span><span class="s6">2 </span><span class="s3">* (</span><span class="s6">1 </span><span class="s3">+ </span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b</span><span class="s3">)</span>
            <span class="s1">g2 </span><span class="s3">/= (</span><span class="s1">n </span><span class="s3">* </span><span class="s1">a </span><span class="s3">* </span><span class="s1">b </span><span class="s3">* (</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b </span><span class="s3">+ </span><span class="s6">2</span><span class="s3">) * (</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b </span><span class="s3">+ </span><span class="s6">3</span><span class="s3">) * (</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b </span><span class="s3">+ </span><span class="s1">n</span><span class="s3">))</span>
            <span class="s1">g2 </span><span class="s3">-= </span><span class="s6">3</span>
        <span class="s2">return </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var</span><span class="s3">, </span><span class="s1">g1</span><span class="s3">, </span><span class="s1">g2</span>


<span class="s1">betabinom </span><span class="s3">= </span><span class="s1">betabinom_gen</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s5">'betabinom'</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">nbinom_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A negative binomial discrete random variable. 
 
    %(before_notes)s 
 
    Notes 
    ----- 
    Negative binomial distribution describes a sequence of i.i.d. Bernoulli 
    trials, repeated until a predefined, non-random number of successes occurs. 
 
    The probability mass function of the number of failures for `nbinom` is: 
 
    .. math:: 
 
       f(k) = \binom{k+n-1}{n-1} p^n (1-p)^k 
 
    for :math:`k \ge 0`, :math:`0 &lt; p \leq 1` 
 
    `nbinom` takes :math:`n` and :math:`p` as shape parameters where :math:`n` 
    is the number of successes, :math:`p` is the probability of a single 
    success, and :math:`1-p` is the probability of a single failure. 
 
    Another common parameterization of the negative binomial distribution is 
    in terms of the mean number of failures :math:`\mu` to achieve :math:`n` 
    successes. The mean :math:`\mu` is related to the probability of success 
    as 
 
    .. math:: 
 
       p = \frac{n}{n + \mu} 
 
    The number of successes :math:`n` may also be specified in terms of a 
    &quot;dispersion&quot;, &quot;heterogeneity&quot;, or &quot;aggregation&quot; parameter :math:`\alpha`, 
    which relates the mean :math:`\mu` to the variance :math:`\sigma^2`, 
    e.g. :math:`\sigma^2 = \mu + \alpha \mu^2`. Regardless of the convention 
    used for :math:`\alpha`, 
 
    .. math:: 
 
       p &amp;= \frac{\mu}{\sigma^2} \\ 
       n &amp;= \frac{\mu^2}{\sigma^2 - \mu} 
 
    %(after_notes)s 
 
    %(example)s 
 
    See Also 
    -------- 
    hypergeom, binom, nhypergeom 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;n&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)),</span>
                <span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;p&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">True</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">negative_binomial</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_argcheck</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">) &amp; (</span><span class="s1">p </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">) &amp; (</span><span class="s1">p </span><span class="s3">&lt;= </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s0"># nbinom.pmf(k) = choose(k+n-1, n-1) * p**n * (1-p)**k</span>
        <span class="s2">return </span><span class="s1">scu</span><span class="s3">.</span><span class="s1">_nbinom_pmf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_logpmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s1">coeff </span><span class="s3">= </span><span class="s1">gamln</span><span class="s3">(</span><span class="s1">n</span><span class="s3">+</span><span class="s1">x</span><span class="s3">) - </span><span class="s1">gamln</span><span class="s3">(</span><span class="s1">x</span><span class="s3">+</span><span class="s6">1</span><span class="s3">) - </span><span class="s1">gamln</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">coeff </span><span class="s3">+ </span><span class="s1">n</span><span class="s3">*</span><span class="s1">log</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) + </span><span class="s1">special</span><span class="s3">.</span><span class="s1">xlog1py</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, -</span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">scu</span><span class="s3">.</span><span class="s1">_nbinom_cdf</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_logcdf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_arrays</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>
        <span class="s1">cdf </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>
        <span class="s1">cond </span><span class="s3">= </span><span class="s1">cdf </span><span class="s3">&gt; </span><span class="s6">0.5</span>
        <span class="s2">def </span><span class="s1">f1</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log1p</span><span class="s3">(-</span><span class="s1">special</span><span class="s3">.</span><span class="s1">betainc</span><span class="s3">(</span><span class="s1">k </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s6">1 </span><span class="s3">- </span><span class="s1">p</span><span class="s3">))</span>

        <span class="s0"># do calc in place</span>
        <span class="s1">logcdf </span><span class="s3">= </span><span class="s1">cdf</span>
        <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">divide</span><span class="s3">=</span><span class="s5">'ignore'</span><span class="s3">):</span>
            <span class="s1">logcdf</span><span class="s3">[</span><span class="s1">cond</span><span class="s3">] = </span><span class="s1">f1</span><span class="s3">(</span><span class="s1">k</span><span class="s3">[</span><span class="s1">cond</span><span class="s3">], </span><span class="s1">n</span><span class="s3">[</span><span class="s1">cond</span><span class="s3">], </span><span class="s1">p</span><span class="s3">[</span><span class="s1">cond</span><span class="s3">])</span>
            <span class="s1">logcdf</span><span class="s3">[~</span><span class="s1">cond</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">cdf</span><span class="s3">[~</span><span class="s1">cond</span><span class="s3">])</span>
        <span class="s2">return </span><span class="s1">logcdf</span>

    <span class="s2">def </span><span class="s1">_sf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">scu</span><span class="s3">.</span><span class="s1">_nbinom_sf</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_isf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">over</span><span class="s3">=</span><span class="s5">'ignore'</span><span class="s3">):  </span><span class="s0"># see gh-17432</span>
            <span class="s2">return </span><span class="s1">scu</span><span class="s3">.</span><span class="s1">_nbinom_isf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_ppf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">over</span><span class="s3">=</span><span class="s5">'ignore'</span><span class="s3">):  </span><span class="s0"># see gh-17432</span>
            <span class="s2">return </span><span class="s1">scu</span><span class="s3">.</span><span class="s1">_nbinom_ppf</span><span class="s3">(</span><span class="s1">q</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span>
            <span class="s1">scu</span><span class="s3">.</span><span class="s1">_nbinom_mean</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">),</span>
            <span class="s1">scu</span><span class="s3">.</span><span class="s1">_nbinom_variance</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">),</span>
            <span class="s1">scu</span><span class="s3">.</span><span class="s1">_nbinom_skewness</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">),</span>
            <span class="s1">scu</span><span class="s3">.</span><span class="s1">_nbinom_kurtosis_excess</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">),</span>
        <span class="s3">)</span>


<span class="s1">nbinom </span><span class="s3">= </span><span class="s1">nbinom_gen</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s5">'nbinom'</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">betanbinom_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A beta-negative-binomial discrete random variable. 
 
    %(before_notes)s 
 
    Notes 
    ----- 
    The beta-negative-binomial distribution is a negative binomial 
    distribution with a probability of success `p` that follows a 
    beta distribution. 
 
    The probability mass function for `betanbinom` is: 
 
    .. math:: 
 
       f(k) = \binom{n + k - 1}{k} \frac{B(a + n, b + k)}{B(a, b)} 
 
    for :math:`k \ge 0`, :math:`n \geq 0`, :math:`a &gt; 0`, 
    :math:`b &gt; 0`, where :math:`B(a, b)` is the beta function. 
 
    `betanbinom` takes :math:`n`, :math:`a`, and :math:`b` as shape parameters. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Beta_negative_binomial_distribution 
 
    %(after_notes)s 
 
    .. versionadded:: 1.12.0 
 
    See Also 
    -------- 
    betabinom : Beta binomial distribution 
 
    %(example)s 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;n&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)),</span>
                <span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;a&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)),</span>
                <span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;b&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">beta</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">negative_binomial</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_argcheck</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">n </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">) &amp; </span><span class="s1">_isintegral</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) &amp; (</span><span class="s1">a </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">) &amp; (</span><span class="s1">b </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_logpmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">combiln </span><span class="s3">= -</span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">n </span><span class="s3">+ </span><span class="s1">k</span><span class="s3">) - </span><span class="s1">betaln</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">k </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">combiln </span><span class="s3">+ </span><span class="s1">betaln</span><span class="s3">(</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">n</span><span class="s3">, </span><span class="s1">b </span><span class="s3">+ </span><span class="s1">k</span><span class="s3">) - </span><span class="s1">betaln</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">exp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_logpmf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">moments</span><span class="s3">=</span><span class="s5">'mv'</span><span class="s3">):</span>
        <span class="s0"># reference: Wolfram Alpha input</span>
        <span class="s0"># BetaNegativeBinomialDistribution[a, b, n]</span>
        <span class="s2">def </span><span class="s1">mean</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">n </span><span class="s3">* </span><span class="s1">b </span><span class="s3">/ (</span><span class="s1">a </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">)</span>
        <span class="s1">mu </span><span class="s3">= </span><span class="s1">_lazywhere</span><span class="s3">(</span><span class="s1">a </span><span class="s3">&gt; </span><span class="s6">1</span><span class="s3">, (</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">), </span><span class="s1">f</span><span class="s3">=</span><span class="s1">mean</span><span class="s3">, </span><span class="s1">fillvalue</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">var</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s3">(</span><span class="s1">n </span><span class="s3">* </span><span class="s1">b </span><span class="s3">* (</span><span class="s1">n </span><span class="s3">+ </span><span class="s1">a </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">) * (</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">)</span>
                    <span class="s3">/ ((</span><span class="s1">a </span><span class="s3">- </span><span class="s6">2.</span><span class="s3">) * (</span><span class="s1">a </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">)**</span><span class="s6">2.</span><span class="s3">))</span>
        <span class="s1">var </span><span class="s3">= </span><span class="s1">_lazywhere</span><span class="s3">(</span><span class="s1">a </span><span class="s3">&gt; </span><span class="s6">2</span><span class="s3">, (</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">), </span><span class="s1">f</span><span class="s3">=</span><span class="s1">var</span><span class="s3">, </span><span class="s1">fillvalue</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">)</span>
        <span class="s1">g1</span><span class="s3">, </span><span class="s1">g2 </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span>
        <span class="s2">def </span><span class="s1">skew</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s3">((</span><span class="s6">2 </span><span class="s3">* </span><span class="s1">n </span><span class="s3">+ </span><span class="s1">a </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">) * (</span><span class="s6">2 </span><span class="s3">* </span><span class="s1">b </span><span class="s3">+ </span><span class="s1">a </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">)</span>
                    <span class="s3">/ (</span><span class="s1">a </span><span class="s3">- </span><span class="s6">3.</span><span class="s3">) / </span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">n </span><span class="s3">* </span><span class="s1">b </span><span class="s3">* (</span><span class="s1">n </span><span class="s3">+ </span><span class="s1">a </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">) * (</span><span class="s1">b </span><span class="s3">+ </span><span class="s1">a </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">)</span>
                    <span class="s3">/ (</span><span class="s1">a </span><span class="s3">- </span><span class="s6">2.</span><span class="s3">)))</span>
        <span class="s2">if </span><span class="s5">'s' </span><span class="s2">in </span><span class="s1">moments</span><span class="s3">:</span>
            <span class="s1">g1 </span><span class="s3">= </span><span class="s1">_lazywhere</span><span class="s3">(</span><span class="s1">a </span><span class="s3">&gt; </span><span class="s6">3</span><span class="s3">, (</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">), </span><span class="s1">f</span><span class="s3">=</span><span class="s1">skew</span><span class="s3">, </span><span class="s1">fillvalue</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">)</span>
        <span class="s2">def </span><span class="s1">kurtosis</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
            <span class="s1">term </span><span class="s3">= (</span><span class="s1">a </span><span class="s3">- </span><span class="s6">2.</span><span class="s3">)</span>
            <span class="s1">term_2 </span><span class="s3">= ((</span><span class="s1">a </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">)**</span><span class="s6">2. </span><span class="s3">* (</span><span class="s1">a</span><span class="s3">**</span><span class="s6">2. </span><span class="s3">+ </span><span class="s1">a </span><span class="s3">* (</span><span class="s6">6 </span><span class="s3">* </span><span class="s1">b </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">)</span>
                      <span class="s3">+ </span><span class="s6">6. </span><span class="s3">* (</span><span class="s1">b </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">) * </span><span class="s1">b</span><span class="s3">)</span>
                      <span class="s3">+ </span><span class="s6">3. </span><span class="s3">* </span><span class="s1">n</span><span class="s3">**</span><span class="s6">2. </span><span class="s3">* ((</span><span class="s1">a </span><span class="s3">+ </span><span class="s6">5.</span><span class="s3">) * </span><span class="s1">b</span><span class="s3">**</span><span class="s6">2. </span><span class="s3">+ (</span><span class="s1">a </span><span class="s3">+ </span><span class="s6">5.</span><span class="s3">)</span>
                      <span class="s3">* (</span><span class="s1">a </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">) * </span><span class="s1">b </span><span class="s3">+ </span><span class="s6">2. </span><span class="s3">* (</span><span class="s1">a </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">)**</span><span class="s6">2</span><span class="s3">)</span>
                      <span class="s3">+ </span><span class="s6">3 </span><span class="s3">* (</span><span class="s1">a </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">) * </span><span class="s1">n</span>
                      <span class="s3">* ((</span><span class="s1">a </span><span class="s3">+ </span><span class="s6">5.</span><span class="s3">) * </span><span class="s1">b</span><span class="s3">**</span><span class="s6">2. </span><span class="s3">+ (</span><span class="s1">a </span><span class="s3">+ </span><span class="s6">5.</span><span class="s3">) * (</span><span class="s1">a </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">) * </span><span class="s1">b</span>
                      <span class="s3">+ </span><span class="s6">2. </span><span class="s3">* (</span><span class="s1">a </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">)**</span><span class="s6">2.</span><span class="s3">))</span>
            <span class="s1">denominator </span><span class="s3">= ((</span><span class="s1">a </span><span class="s3">- </span><span class="s6">4.</span><span class="s3">) * (</span><span class="s1">a </span><span class="s3">- </span><span class="s6">3.</span><span class="s3">) * </span><span class="s1">b </span><span class="s3">* </span><span class="s1">n</span>
                           <span class="s3">* (</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">b </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">) * (</span><span class="s1">a </span><span class="s3">+ </span><span class="s1">n </span><span class="s3">- </span><span class="s6">1.</span><span class="s3">))</span>
            <span class="s0"># Wolfram Alpha uses Pearson kurtosis, so we substract 3 to get</span>
            <span class="s0"># scipy's Fisher kurtosis</span>
            <span class="s2">return </span><span class="s1">term </span><span class="s3">* </span><span class="s1">term_2 </span><span class="s3">/ </span><span class="s1">denominator </span><span class="s3">- </span><span class="s6">3.</span>
        <span class="s2">if </span><span class="s5">'k' </span><span class="s2">in </span><span class="s1">moments</span><span class="s3">:</span>
            <span class="s1">g2 </span><span class="s3">= </span><span class="s1">_lazywhere</span><span class="s3">(</span><span class="s1">a </span><span class="s3">&gt; </span><span class="s6">4</span><span class="s3">, (</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">), </span><span class="s1">f</span><span class="s3">=</span><span class="s1">kurtosis</span><span class="s3">, </span><span class="s1">fillvalue</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var</span><span class="s3">, </span><span class="s1">g1</span><span class="s3">, </span><span class="s1">g2</span>


<span class="s1">betanbinom </span><span class="s3">= </span><span class="s1">betanbinom_gen</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s5">'betanbinom'</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">geom_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A geometric discrete random variable. 
 
    %(before_notes)s 
 
    Notes 
    ----- 
    The probability mass function for `geom` is: 
 
    .. math:: 
 
        f(k) = (1-p)^{k-1} p 
 
    for :math:`k \ge 1`, :math:`0 &lt; p \leq 1` 
 
    `geom` takes :math:`p` as shape parameter, 
    where :math:`p` is the probability of a single success 
    and :math:`1-p` is the probability of a single failure. 
 
    %(after_notes)s 
 
    See Also 
    -------- 
    planck 
 
    %(example)s 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;p&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">True</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">geometric</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_argcheck</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">p </span><span class="s3">&lt;= </span><span class="s6">1</span><span class="s3">) &amp; (</span><span class="s1">p </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s6">1</span><span class="s3">-</span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">) * </span><span class="s1">p</span>

    <span class="s2">def </span><span class="s1">_logpmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">special</span><span class="s3">.</span><span class="s1">xlog1py</span><span class="s3">(</span><span class="s1">k </span><span class="s3">- </span><span class="s6">1</span><span class="s3">, -</span><span class="s1">p</span><span class="s3">) + </span><span class="s1">log</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s3">-</span><span class="s1">expm1</span><span class="s3">(</span><span class="s1">log1p</span><span class="s3">(-</span><span class="s1">p</span><span class="s3">)*</span><span class="s1">k</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_sf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_logsf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">p</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_logsf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">k</span><span class="s3">*</span><span class="s1">log1p</span><span class="s3">(-</span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_ppf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s1">vals </span><span class="s3">= </span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">log1p</span><span class="s3">(-</span><span class="s1">q</span><span class="s3">) / </span><span class="s1">log1p</span><span class="s3">(-</span><span class="s1">p</span><span class="s3">))</span>
        <span class="s1">temp </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">-</span><span class="s6">1</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">((</span><span class="s1">temp </span><span class="s3">&gt;= </span><span class="s1">q</span><span class="s3">) &amp; (</span><span class="s1">vals </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">), </span><span class="s1">vals</span><span class="s3">-</span><span class="s6">1</span><span class="s3">, </span><span class="s1">vals</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s1">mu </span><span class="s3">= </span><span class="s6">1.0</span><span class="s3">/</span><span class="s1">p</span>
        <span class="s1">qr </span><span class="s3">= </span><span class="s6">1.0</span><span class="s3">-</span><span class="s1">p</span>
        <span class="s1">var </span><span class="s3">= </span><span class="s1">qr </span><span class="s3">/ </span><span class="s1">p </span><span class="s3">/ </span><span class="s1">p</span>
        <span class="s1">g1 </span><span class="s3">= (</span><span class="s6">2.0</span><span class="s3">-</span><span class="s1">p</span><span class="s3">) / </span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">qr</span><span class="s3">)</span>
        <span class="s1">g2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">polyval</span><span class="s3">([</span><span class="s6">1</span><span class="s3">, -</span><span class="s6">6</span><span class="s3">, </span><span class="s6">6</span><span class="s3">], </span><span class="s1">p</span><span class="s3">)/(</span><span class="s6">1.0</span><span class="s3">-</span><span class="s1">p</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var</span><span class="s3">, </span><span class="s1">g1</span><span class="s3">, </span><span class="s1">g2</span>

    <span class="s2">def </span><span class="s1">_entropy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">-</span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) - </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log1p</span><span class="s3">(-</span><span class="s1">p</span><span class="s3">) * (</span><span class="s6">1.0</span><span class="s3">-</span><span class="s1">p</span><span class="s3">) / </span><span class="s1">p</span>


<span class="s1">geom </span><span class="s3">= </span><span class="s1">geom_gen</span><span class="s3">(</span><span class="s1">a</span><span class="s3">=</span><span class="s6">1</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s5">'geom'</span><span class="s3">, </span><span class="s1">longname</span><span class="s3">=</span><span class="s5">&quot;A geometric&quot;</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">hypergeom_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A hypergeometric discrete random variable. 
 
    The hypergeometric distribution models drawing objects from a bin. 
    `M` is the total number of objects, `n` is total number of Type I objects. 
    The random variate represents the number of Type I objects in `N` drawn 
    without replacement from the total population. 
 
    %(before_notes)s 
 
    Notes 
    ----- 
    The symbols used to denote the shape parameters (`M`, `n`, and `N`) are not 
    universally accepted.  See the Examples for a clarification of the 
    definitions used here. 
 
    The probability mass function is defined as, 
 
    .. math:: p(k, M, n, N) = \frac{\binom{n}{k} \binom{M - n}{N - k}} 
                                   {\binom{M}{N}} 
 
    for :math:`k \in [\max(0, N - M + n), \min(n, N)]`, where the binomial 
    coefficients are defined as, 
 
    .. math:: \binom{n}{k} \equiv \frac{n!}{k! (n - k)!}. 
 
    %(after_notes)s 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import hypergeom 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    Suppose we have a collection of 20 animals, of which 7 are dogs.  Then if 
    we want to know the probability of finding a given number of dogs if we 
    choose at random 12 of the 20 animals, we can initialize a frozen 
    distribution and plot the probability mass function: 
 
    &gt;&gt;&gt; [M, n, N] = [20, 7, 12] 
    &gt;&gt;&gt; rv = hypergeom(M, n, N) 
    &gt;&gt;&gt; x = np.arange(0, n+1) 
    &gt;&gt;&gt; pmf_dogs = rv.pmf(x) 
 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; ax = fig.add_subplot(111) 
    &gt;&gt;&gt; ax.plot(x, pmf_dogs, 'bo') 
    &gt;&gt;&gt; ax.vlines(x, 0, pmf_dogs, lw=2) 
    &gt;&gt;&gt; ax.set_xlabel('# of dogs in our group of chosen animals') 
    &gt;&gt;&gt; ax.set_ylabel('hypergeom PMF') 
    &gt;&gt;&gt; plt.show() 
 
    Instead of using a frozen distribution we can also use `hypergeom` 
    methods directly.  To for example obtain the cumulative distribution 
    function, use: 
 
    &gt;&gt;&gt; prb = hypergeom.cdf(x, M, n, N) 
 
    And to generate random numbers: 
 
    &gt;&gt;&gt; R = hypergeom.rvs(M, n, N, size=10) 
 
    See Also 
    -------- 
    nhypergeom, binom, nbinom 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;M&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)),</span>
                <span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;n&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)),</span>
                <span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;N&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">hypergeometric</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">M</span><span class="s3">-</span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_support</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(</span><span class="s1">N</span><span class="s3">-(</span><span class="s1">M</span><span class="s3">-</span><span class="s1">n</span><span class="s3">), </span><span class="s6">0</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">minimum</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_argcheck</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
        <span class="s1">cond </span><span class="s3">= (</span><span class="s1">M </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">) &amp; (</span><span class="s1">n </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">) &amp; (</span><span class="s1">N </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">cond </span><span class="s3">&amp;= (</span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s1">M</span><span class="s3">) &amp; (</span><span class="s1">N </span><span class="s3">&lt;= </span><span class="s1">M</span><span class="s3">)</span>
        <span class="s1">cond </span><span class="s3">&amp;= </span><span class="s1">_isintegral</span><span class="s3">(</span><span class="s1">M</span><span class="s3">) &amp; </span><span class="s1">_isintegral</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) &amp; </span><span class="s1">_isintegral</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">cond</span>

    <span class="s2">def </span><span class="s1">_logpmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
        <span class="s1">tot</span><span class="s3">, </span><span class="s1">good </span><span class="s3">= </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span>
        <span class="s1">bad </span><span class="s3">= </span><span class="s1">tot </span><span class="s3">- </span><span class="s1">good</span>
        <span class="s1">result </span><span class="s3">= (</span><span class="s1">betaln</span><span class="s3">(</span><span class="s1">good</span><span class="s3">+</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">) + </span><span class="s1">betaln</span><span class="s3">(</span><span class="s1">bad</span><span class="s3">+</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">) + </span><span class="s1">betaln</span><span class="s3">(</span><span class="s1">tot</span><span class="s3">-</span><span class="s1">N</span><span class="s3">+</span><span class="s6">1</span><span class="s3">, </span><span class="s1">N</span><span class="s3">+</span><span class="s6">1</span><span class="s3">) -</span>
                  <span class="s1">betaln</span><span class="s3">(</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1</span><span class="s3">, </span><span class="s1">good</span><span class="s3">-</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1</span><span class="s3">) - </span><span class="s1">betaln</span><span class="s3">(</span><span class="s1">N</span><span class="s3">-</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1</span><span class="s3">, </span><span class="s1">bad</span><span class="s3">-</span><span class="s1">N</span><span class="s3">+</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1</span><span class="s3">) -</span>
                  <span class="s1">betaln</span><span class="s3">(</span><span class="s1">tot</span><span class="s3">+</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">scu</span><span class="s3">.</span><span class="s1">_hypergeom_pmf</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">scu</span><span class="s3">.</span><span class="s1">_hypergeom_cdf</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
        <span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N </span><span class="s3">= </span><span class="s6">1. </span><span class="s3">* </span><span class="s1">M</span><span class="s3">, </span><span class="s6">1. </span><span class="s3">* </span><span class="s1">n</span><span class="s3">, </span><span class="s6">1. </span><span class="s3">* </span><span class="s1">N</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">M </span><span class="s3">- </span><span class="s1">n</span>

        <span class="s0"># Boost kurtosis_excess doesn't return the same as the value</span>
        <span class="s0"># computed here.</span>
        <span class="s1">g2 </span><span class="s3">= </span><span class="s1">M </span><span class="s3">* (</span><span class="s1">M </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">) - </span><span class="s6">6. </span><span class="s3">* </span><span class="s1">N </span><span class="s3">* (</span><span class="s1">M </span><span class="s3">- </span><span class="s1">N</span><span class="s3">) - </span><span class="s6">6. </span><span class="s3">* </span><span class="s1">n </span><span class="s3">* </span><span class="s1">m</span>
        <span class="s1">g2 </span><span class="s3">*= (</span><span class="s1">M </span><span class="s3">- </span><span class="s6">1</span><span class="s3">) * </span><span class="s1">M </span><span class="s3">* </span><span class="s1">M</span>
        <span class="s1">g2 </span><span class="s3">+= </span><span class="s6">6. </span><span class="s3">* </span><span class="s1">n </span><span class="s3">* </span><span class="s1">N </span><span class="s3">* (</span><span class="s1">M </span><span class="s3">- </span><span class="s1">N</span><span class="s3">) * </span><span class="s1">m </span><span class="s3">* (</span><span class="s6">5. </span><span class="s3">* </span><span class="s1">M </span><span class="s3">- </span><span class="s6">6</span><span class="s3">)</span>
        <span class="s1">g2 </span><span class="s3">/= </span><span class="s1">n </span><span class="s3">* </span><span class="s1">N </span><span class="s3">* (</span><span class="s1">M </span><span class="s3">- </span><span class="s1">N</span><span class="s3">) * </span><span class="s1">m </span><span class="s3">* (</span><span class="s1">M </span><span class="s3">- </span><span class="s6">2.</span><span class="s3">) * (</span><span class="s1">M </span><span class="s3">- </span><span class="s6">3.</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s3">(</span>
            <span class="s1">scu</span><span class="s3">.</span><span class="s1">_hypergeom_mean</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">),</span>
            <span class="s1">scu</span><span class="s3">.</span><span class="s1">_hypergeom_variance</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">),</span>
            <span class="s1">scu</span><span class="s3">.</span><span class="s1">_hypergeom_skewness</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">),</span>
            <span class="s1">g2</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_entropy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">r_</span><span class="s3">[</span><span class="s1">N </span><span class="s3">- (</span><span class="s1">M </span><span class="s3">- </span><span class="s1">n</span><span class="s3">):</span><span class="s1">min</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">) + </span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">vals </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pmf</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">entr</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_sf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">scu</span><span class="s3">.</span><span class="s1">_hypergeom_sf</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">M</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_logsf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
        <span class="s1">res </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">quant</span><span class="s3">, </span><span class="s1">tot</span><span class="s3">, </span><span class="s1">good</span><span class="s3">, </span><span class="s1">draw </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_arrays</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">)):</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">quant </span><span class="s3">+ </span><span class="s6">0.5</span><span class="s3">) * (</span><span class="s1">tot </span><span class="s3">+ </span><span class="s6">0.5</span><span class="s3">) &lt; (</span><span class="s1">good </span><span class="s3">- </span><span class="s6">0.5</span><span class="s3">) * (</span><span class="s1">draw </span><span class="s3">- </span><span class="s6">0.5</span><span class="s3">):</span>
                <span class="s0"># Less terms to sum if we calculate log(1-cdf)</span>
                <span class="s1">res</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">log1p</span><span class="s3">(-</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">logcdf</span><span class="s3">(</span><span class="s1">quant</span><span class="s3">, </span><span class="s1">tot</span><span class="s3">, </span><span class="s1">good</span><span class="s3">, </span><span class="s1">draw</span><span class="s3">))))</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s0"># Integration over probability mass function using logsumexp</span>
                <span class="s1">k2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">quant </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">, </span><span class="s1">draw </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">)</span>
                <span class="s1">res</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">logsumexp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_logpmf</span><span class="s3">(</span><span class="s1">k2</span><span class="s3">, </span><span class="s1">tot</span><span class="s3">, </span><span class="s1">good</span><span class="s3">, </span><span class="s1">draw</span><span class="s3">)))</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">res</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_logcdf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
        <span class="s1">res </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">quant</span><span class="s3">, </span><span class="s1">tot</span><span class="s3">, </span><span class="s1">good</span><span class="s3">, </span><span class="s1">draw </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_arrays</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">)):</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">quant </span><span class="s3">+ </span><span class="s6">0.5</span><span class="s3">) * (</span><span class="s1">tot </span><span class="s3">+ </span><span class="s6">0.5</span><span class="s3">) &gt; (</span><span class="s1">good </span><span class="s3">- </span><span class="s6">0.5</span><span class="s3">) * (</span><span class="s1">draw </span><span class="s3">- </span><span class="s6">0.5</span><span class="s3">):</span>
                <span class="s0"># Less terms to sum if we calculate log(1-sf)</span>
                <span class="s1">res</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">log1p</span><span class="s3">(-</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">logsf</span><span class="s3">(</span><span class="s1">quant</span><span class="s3">, </span><span class="s1">tot</span><span class="s3">, </span><span class="s1">good</span><span class="s3">, </span><span class="s1">draw</span><span class="s3">))))</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s0"># Integration over probability mass function using logsumexp</span>
                <span class="s1">k2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">quant </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">)</span>
                <span class="s1">res</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">logsumexp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_logpmf</span><span class="s3">(</span><span class="s1">k2</span><span class="s3">, </span><span class="s1">tot</span><span class="s3">, </span><span class="s1">good</span><span class="s3">, </span><span class="s1">draw</span><span class="s3">)))</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">res</span><span class="s3">)</span>


<span class="s1">hypergeom </span><span class="s3">= </span><span class="s1">hypergeom_gen</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s5">'hypergeom'</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">nhypergeom_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A negative hypergeometric discrete random variable. 
 
    Consider a box containing :math:`M` balls:, :math:`n` red and 
    :math:`M-n` blue. We randomly sample balls from the box, one 
    at a time and *without* replacement, until we have picked :math:`r` 
    blue balls. `nhypergeom` is the distribution of the number of 
    red balls :math:`k` we have picked. 
 
    %(before_notes)s 
 
    Notes 
    ----- 
    The symbols used to denote the shape parameters (`M`, `n`, and `r`) are not 
    universally accepted. See the Examples for a clarification of the 
    definitions used here. 
 
    The probability mass function is defined as, 
 
    .. math:: f(k; M, n, r) = \frac{{{k+r-1}\choose{k}}{{M-r-k}\choose{n-k}}} 
                                   {{M \choose n}} 
 
    for :math:`k \in [0, n]`, :math:`n \in [0, M]`, :math:`r \in [0, M-n]`, 
    and the binomial coefficient is: 
 
    .. math:: \binom{n}{k} \equiv \frac{n!}{k! (n - k)!}. 
 
    It is equivalent to observing :math:`k` successes in :math:`k+r-1` 
    samples with :math:`k+r`'th sample being a failure. The former 
    can be modelled as a hypergeometric distribution. The probability 
    of the latter is simply the number of failures remaining 
    :math:`M-n-(r-1)` divided by the size of the remaining population 
    :math:`M-(k+r-1)`. This relationship can be shown as: 
 
    .. math:: NHG(k;M,n,r) = HG(k;M,n,k+r-1)\frac{(M-n-(r-1))}{(M-(k+r-1))} 
 
    where :math:`NHG` is probability mass function (PMF) of the 
    negative hypergeometric distribution and :math:`HG` is the 
    PMF of the hypergeometric distribution. 
 
    %(after_notes)s 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import nhypergeom 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    Suppose we have a collection of 20 animals, of which 7 are dogs. 
    Then if we want to know the probability of finding a given number 
    of dogs (successes) in a sample with exactly 12 animals that 
    aren't dogs (failures), we can initialize a frozen distribution 
    and plot the probability mass function: 
 
    &gt;&gt;&gt; M, n, r = [20, 7, 12] 
    &gt;&gt;&gt; rv = nhypergeom(M, n, r) 
    &gt;&gt;&gt; x = np.arange(0, n+2) 
    &gt;&gt;&gt; pmf_dogs = rv.pmf(x) 
 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; ax = fig.add_subplot(111) 
    &gt;&gt;&gt; ax.plot(x, pmf_dogs, 'bo') 
    &gt;&gt;&gt; ax.vlines(x, 0, pmf_dogs, lw=2) 
    &gt;&gt;&gt; ax.set_xlabel('# of dogs in our group with given 12 failures') 
    &gt;&gt;&gt; ax.set_ylabel('nhypergeom PMF') 
    &gt;&gt;&gt; plt.show() 
 
    Instead of using a frozen distribution we can also use `nhypergeom` 
    methods directly.  To for example obtain the probability mass 
    function, use: 
 
    &gt;&gt;&gt; prb = nhypergeom.pmf(x, M, n, r) 
 
    And to generate random numbers: 
 
    &gt;&gt;&gt; R = nhypergeom.rvs(M, n, r, size=10) 
 
    To verify the relationship between `hypergeom` and `nhypergeom`, use: 
 
    &gt;&gt;&gt; from scipy.stats import hypergeom, nhypergeom 
    &gt;&gt;&gt; M, n, r = 45, 13, 8 
    &gt;&gt;&gt; k = 6 
    &gt;&gt;&gt; nhypergeom.pmf(k, M, n, r) 
    0.06180776620271643 
    &gt;&gt;&gt; hypergeom.pmf(k, M, n, k+r-1) * (M - n - (r-1)) / (M - (k+r-1)) 
    0.06180776620271644 
 
    See Also 
    -------- 
    hypergeom, binom, nbinom 
 
    References 
    ---------- 
    .. [1] Negative Hypergeometric Distribution on Wikipedia 
           https://en.wikipedia.org/wiki/Negative_hypergeometric_distribution 
 
    .. [2] Negative Hypergeometric Distribution from 
           http://www.math.wm.edu/~leemis/chart/UDR/PDFs/Negativehypergeometric.pdf 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;M&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)),</span>
                <span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;n&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)),</span>
                <span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;r&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_get_support</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">r</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s6">0</span><span class="s3">, </span><span class="s1">n</span>

    <span class="s2">def </span><span class="s1">_argcheck</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">r</span><span class="s3">):</span>
        <span class="s1">cond </span><span class="s3">= (</span><span class="s1">n </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">) &amp; (</span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s1">M</span><span class="s3">) &amp; (</span><span class="s1">r </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">) &amp; (</span><span class="s1">r </span><span class="s3">&lt;= </span><span class="s1">M</span><span class="s3">-</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">cond </span><span class="s3">&amp;= </span><span class="s1">_isintegral</span><span class="s3">(</span><span class="s1">M</span><span class="s3">) &amp; </span><span class="s1">_isintegral</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) &amp; </span><span class="s1">_isintegral</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">cond</span>

    <span class="s2">def </span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>

        <span class="s3">@</span><span class="s1">_vectorize_rvs_over_shapes</span>
        <span class="s2">def </span><span class="s1">_rvs1</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">):</span>
            <span class="s0"># invert cdf by calculating all values in support, scalar M, n, r</span>
            <span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">support</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">r</span><span class="s3">)</span>
            <span class="s1">ks </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)</span>
            <span class="s1">cdf </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">cdf</span><span class="s3">(</span><span class="s1">ks</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">r</span><span class="s3">)</span>
            <span class="s1">ppf </span><span class="s3">= </span><span class="s1">interp1d</span><span class="s3">(</span><span class="s1">cdf</span><span class="s3">, </span><span class="s1">ks</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">=</span><span class="s5">'next'</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=</span><span class="s5">'extrapolate'</span><span class="s3">)</span>
            <span class="s1">rvs </span><span class="s3">= </span><span class="s1">ppf</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=</span><span class="s1">size</span><span class="s3">)).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">rvs</span><span class="s3">.</span><span class="s1">item</span><span class="s3">()</span>
            <span class="s2">return </span><span class="s1">rvs</span>

        <span class="s2">return </span><span class="s1">_rvs1</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">size</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">random_state</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_logpmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">r</span><span class="s3">):</span>
        <span class="s1">cond </span><span class="s3">= ((</span><span class="s1">r </span><span class="s3">== </span><span class="s6">0</span><span class="s3">) &amp; (</span><span class="s1">k </span><span class="s3">== </span><span class="s6">0</span><span class="s3">))</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">_lazywhere</span><span class="s3">(~</span><span class="s1">cond</span><span class="s3">, (</span><span class="s1">k</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">r</span><span class="s3">),</span>
                            <span class="s2">lambda </span><span class="s1">k</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">r</span><span class="s3">:</span>
                                <span class="s3">(-</span><span class="s1">betaln</span><span class="s3">(</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1</span><span class="s3">, </span><span class="s1">r</span><span class="s3">) + </span><span class="s1">betaln</span><span class="s3">(</span><span class="s1">k</span><span class="s3">+</span><span class="s1">r</span><span class="s3">, </span><span class="s6">1</span><span class="s3">) -</span>
                                 <span class="s1">betaln</span><span class="s3">(</span><span class="s1">n</span><span class="s3">-</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1</span><span class="s3">, </span><span class="s1">M</span><span class="s3">-</span><span class="s1">r</span><span class="s3">-</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">) + </span><span class="s1">betaln</span><span class="s3">(</span><span class="s1">M</span><span class="s3">-</span><span class="s1">r</span><span class="s3">-</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">) +</span>
                                 <span class="s1">betaln</span><span class="s3">(</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">, </span><span class="s1">M</span><span class="s3">-</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">) - </span><span class="s1">betaln</span><span class="s3">(</span><span class="s1">M</span><span class="s3">+</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)),</span>
                            <span class="s1">fillvalue</span><span class="s3">=</span><span class="s6">0.0</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">r</span><span class="s3">):</span>
        <span class="s0"># same as the following but numerically more precise</span>
        <span class="s0"># return comb(k+r-1, k) * comb(M-r-k, n-k) / comb(M, n)</span>
        <span class="s2">return </span><span class="s1">exp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_logpmf</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">r</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">r</span><span class="s3">):</span>
        <span class="s0"># Promote the datatype to at least float</span>
        <span class="s0"># mu = rn / (M-n+1)</span>
        <span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">r </span><span class="s3">= </span><span class="s6">1.</span><span class="s3">*</span><span class="s1">M</span><span class="s3">, </span><span class="s6">1.</span><span class="s3">*</span><span class="s1">n</span><span class="s3">, </span><span class="s6">1.</span><span class="s3">*</span><span class="s1">r</span>
        <span class="s1">mu </span><span class="s3">= </span><span class="s1">r</span><span class="s3">*</span><span class="s1">n </span><span class="s3">/ (</span><span class="s1">M</span><span class="s3">-</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)</span>

        <span class="s1">var </span><span class="s3">= </span><span class="s1">r</span><span class="s3">*(</span><span class="s1">M</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)*</span><span class="s1">n </span><span class="s3">/ ((</span><span class="s1">M</span><span class="s3">-</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)*(</span><span class="s1">M</span><span class="s3">-</span><span class="s1">n</span><span class="s3">+</span><span class="s6">2</span><span class="s3">)) * (</span><span class="s6">1 </span><span class="s3">- </span><span class="s1">r </span><span class="s3">/ (</span><span class="s1">M</span><span class="s3">-</span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">))</span>

        <span class="s0"># The skew and kurtosis are mathematically</span>
        <span class="s0"># intractable so return `None`. See [2]_.</span>
        <span class="s1">g1</span><span class="s3">, </span><span class="s1">g2 </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var</span><span class="s3">, </span><span class="s1">g1</span><span class="s3">, </span><span class="s1">g2</span>


<span class="s1">nhypergeom </span><span class="s3">= </span><span class="s1">nhypergeom_gen</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s5">'nhypergeom'</span><span class="s3">)</span>


<span class="s0"># FIXME: Fails _cdfvec</span>
<span class="s2">class </span><span class="s1">logser_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A Logarithmic (Log-Series, Series) discrete random variable. 
 
    %(before_notes)s 
 
    Notes 
    ----- 
    The probability mass function for `logser` is: 
 
    .. math:: 
 
        f(k) = - \frac{p^k}{k \log(1-p)} 
 
    for :math:`k \ge 1`, :math:`0 &lt; p &lt; 1` 
 
    `logser` takes :math:`p` as shape parameter, 
    where :math:`p` is the probability of a single success 
    and :math:`1-p` is the probability of a single failure. 
 
    %(after_notes)s 
 
    %(example)s 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;p&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">True</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0"># looks wrong for p&gt;0.5, too few k=1</span>
        <span class="s0"># trying to use generic is worse, no k=1 at all</span>
        <span class="s2">return </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">logseries</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_argcheck</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">p </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">) &amp; (</span><span class="s1">p </span><span class="s3">&lt; </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s0"># logser.pmf(k) = - p**k / (k*log(1-p))</span>
        <span class="s2">return </span><span class="s3">-</span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">) * </span><span class="s6">1.0 </span><span class="s3">/ </span><span class="s1">k </span><span class="s3">/ </span><span class="s1">special</span><span class="s3">.</span><span class="s1">log1p</span><span class="s3">(-</span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s1">r </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">log1p</span><span class="s3">(-</span><span class="s1">p</span><span class="s3">)</span>
        <span class="s1">mu </span><span class="s3">= </span><span class="s1">p </span><span class="s3">/ (</span><span class="s1">p </span><span class="s3">- </span><span class="s6">1.0</span><span class="s3">) / </span><span class="s1">r</span>
        <span class="s1">mu2p </span><span class="s3">= -</span><span class="s1">p </span><span class="s3">/ </span><span class="s1">r </span><span class="s3">/ (</span><span class="s1">p </span><span class="s3">- </span><span class="s6">1.0</span><span class="s3">)**</span><span class="s6">2</span>
        <span class="s1">var </span><span class="s3">= </span><span class="s1">mu2p </span><span class="s3">- </span><span class="s1">mu</span><span class="s3">*</span><span class="s1">mu</span>
        <span class="s1">mu3p </span><span class="s3">= -</span><span class="s1">p </span><span class="s3">/ </span><span class="s1">r </span><span class="s3">* (</span><span class="s6">1.0</span><span class="s3">+</span><span class="s1">p</span><span class="s3">) / (</span><span class="s6">1.0 </span><span class="s3">- </span><span class="s1">p</span><span class="s3">)**</span><span class="s6">3</span>
        <span class="s1">mu3 </span><span class="s3">= </span><span class="s1">mu3p </span><span class="s3">- </span><span class="s6">3</span><span class="s3">*</span><span class="s1">mu</span><span class="s3">*</span><span class="s1">mu2p </span><span class="s3">+ </span><span class="s6">2</span><span class="s3">*</span><span class="s1">mu</span><span class="s3">**</span><span class="s6">3</span>
        <span class="s1">g1 </span><span class="s3">= </span><span class="s1">mu3 </span><span class="s3">/ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s1">var</span><span class="s3">, </span><span class="s6">1.5</span><span class="s3">)</span>

        <span class="s1">mu4p </span><span class="s3">= -</span><span class="s1">p </span><span class="s3">/ </span><span class="s1">r </span><span class="s3">* (</span>
            <span class="s6">1.0 </span><span class="s3">/ (</span><span class="s1">p</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)**</span><span class="s6">2 </span><span class="s3">- </span><span class="s6">6</span><span class="s3">*</span><span class="s1">p </span><span class="s3">/ (</span><span class="s1">p </span><span class="s3">- </span><span class="s6">1</span><span class="s3">)**</span><span class="s6">3 </span><span class="s3">+ </span><span class="s6">6</span><span class="s3">*</span><span class="s1">p</span><span class="s3">*</span><span class="s1">p </span><span class="s3">/ (</span><span class="s1">p</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)**</span><span class="s6">4</span><span class="s3">)</span>
        <span class="s1">mu4 </span><span class="s3">= </span><span class="s1">mu4p </span><span class="s3">- </span><span class="s6">4</span><span class="s3">*</span><span class="s1">mu3p</span><span class="s3">*</span><span class="s1">mu </span><span class="s3">+ </span><span class="s6">6</span><span class="s3">*</span><span class="s1">mu2p</span><span class="s3">*</span><span class="s1">mu</span><span class="s3">*</span><span class="s1">mu </span><span class="s3">- </span><span class="s6">3</span><span class="s3">*</span><span class="s1">mu</span><span class="s3">**</span><span class="s6">4</span>
        <span class="s1">g2 </span><span class="s3">= </span><span class="s1">mu4 </span><span class="s3">/ </span><span class="s1">var</span><span class="s3">**</span><span class="s6">2 </span><span class="s3">- </span><span class="s6">3.0</span>
        <span class="s2">return </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var</span><span class="s3">, </span><span class="s1">g1</span><span class="s3">, </span><span class="s1">g2</span>


<span class="s1">logser </span><span class="s3">= </span><span class="s1">logser_gen</span><span class="s3">(</span><span class="s1">a</span><span class="s3">=</span><span class="s6">1</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s5">'logser'</span><span class="s3">, </span><span class="s1">longname</span><span class="s3">=</span><span class="s5">'A logarithmic'</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">poisson_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A Poisson discrete random variable. 
 
    %(before_notes)s 
 
    Notes 
    ----- 
    The probability mass function for `poisson` is: 
 
    .. math:: 
 
        f(k) = \exp(-\mu) \frac{\mu^k}{k!} 
 
    for :math:`k \ge 0`. 
 
    `poisson` takes :math:`\mu \geq 0` as shape parameter. 
    When :math:`\mu = 0`, the ``pmf`` method 
    returns ``1.0`` at quantile :math:`k = 0`. 
 
    %(after_notes)s 
 
    %(example)s 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;mu&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))]</span>

    <span class="s0"># Override rv_discrete._argcheck to allow mu=0.</span>
    <span class="s2">def </span><span class="s1">_argcheck</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">mu </span><span class="s3">&gt;= </span><span class="s6">0</span>

    <span class="s2">def </span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">poisson</span><span class="s3">(</span><span class="s1">mu</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_logpmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">):</span>
        <span class="s1">Pk </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">xlogy</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">) - </span><span class="s1">gamln</span><span class="s3">(</span><span class="s1">k </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">) - </span><span class="s1">mu</span>
        <span class="s2">return </span><span class="s1">Pk</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">):</span>
        <span class="s0"># poisson.pmf(k) = exp(-mu) * mu**k / k!</span>
        <span class="s2">return </span><span class="s1">exp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_logpmf</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">special</span><span class="s3">.</span><span class="s1">pdtr</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_sf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">special</span><span class="s3">.</span><span class="s1">pdtrc</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_ppf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">):</span>
        <span class="s1">vals </span><span class="s3">= </span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">special</span><span class="s3">.</span><span class="s1">pdtrik</span><span class="s3">(</span><span class="s1">q</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">))</span>
        <span class="s1">vals1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(</span><span class="s1">vals </span><span class="s3">- </span><span class="s6">1</span><span class="s3">, </span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">temp </span><span class="s3">= </span><span class="s1">special</span><span class="s3">.</span><span class="s1">pdtr</span><span class="s3">(</span><span class="s1">vals1</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">temp </span><span class="s3">&gt;= </span><span class="s1">q</span><span class="s3">, </span><span class="s1">vals1</span><span class="s3">, </span><span class="s1">vals</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">):</span>
        <span class="s1">var </span><span class="s3">= </span><span class="s1">mu</span>
        <span class="s1">tmp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">mu</span><span class="s3">)</span>
        <span class="s1">mu_nonzero </span><span class="s3">= </span><span class="s1">tmp </span><span class="s3">&gt; </span><span class="s6">0</span>
        <span class="s1">g1 </span><span class="s3">= </span><span class="s1">_lazywhere</span><span class="s3">(</span><span class="s1">mu_nonzero</span><span class="s3">, (</span><span class="s1">tmp</span><span class="s3">,), </span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">sqrt</span><span class="s3">(</span><span class="s6">1.0</span><span class="s3">/</span><span class="s1">x</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">)</span>
        <span class="s1">g2 </span><span class="s3">= </span><span class="s1">_lazywhere</span><span class="s3">(</span><span class="s1">mu_nonzero</span><span class="s3">, (</span><span class="s1">tmp</span><span class="s3">,), </span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s6">1.0</span><span class="s3">/</span><span class="s1">x</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var</span><span class="s3">, </span><span class="s1">g1</span><span class="s3">, </span><span class="s1">g2</span>


<span class="s1">poisson </span><span class="s3">= </span><span class="s1">poisson_gen</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s5">&quot;poisson&quot;</span><span class="s3">, </span><span class="s1">longname</span><span class="s3">=</span><span class="s5">'A Poisson'</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">planck_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A Planck discrete exponential random variable. 
 
    %(before_notes)s 
 
    Notes 
    ----- 
    The probability mass function for `planck` is: 
 
    .. math:: 
 
        f(k) = (1-\exp(-\lambda)) \exp(-\lambda k) 
 
    for :math:`k \ge 0` and :math:`\lambda &gt; 0`. 
 
    `planck` takes :math:`\lambda` as shape parameter. The Planck distribution 
    can be written as a geometric distribution (`geom`) with 
    :math:`p = 1 - \exp(-\lambda)` shifted by ``loc = -1``. 
 
    %(after_notes)s 
 
    See Also 
    -------- 
    geom 
 
    %(example)s 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;lambda&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_argcheck</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">lambda_ </span><span class="s3">&gt; </span><span class="s6">0</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">-</span><span class="s1">expm1</span><span class="s3">(-</span><span class="s1">lambda_</span><span class="s3">)*</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">lambda_</span><span class="s3">*</span><span class="s1">k</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s3">-</span><span class="s1">expm1</span><span class="s3">(-</span><span class="s1">lambda_</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_sf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">exp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_logsf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_logsf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s3">-</span><span class="s1">lambda_</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_ppf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">):</span>
        <span class="s1">vals </span><span class="s3">= </span><span class="s1">ceil</span><span class="s3">(-</span><span class="s6">1.0</span><span class="s3">/</span><span class="s1">lambda_ </span><span class="s3">* </span><span class="s1">log1p</span><span class="s3">(-</span><span class="s1">q</span><span class="s3">)-</span><span class="s6">1</span><span class="s3">)</span>
        <span class="s1">vals1 </span><span class="s3">= (</span><span class="s1">vals</span><span class="s3">-</span><span class="s6">1</span><span class="s3">).</span><span class="s1">clip</span><span class="s3">(*(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_get_support</span><span class="s3">(</span><span class="s1">lambda_</span><span class="s3">)))</span>
        <span class="s1">temp </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">vals1</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">temp </span><span class="s3">&gt;= </span><span class="s1">q</span><span class="s3">, </span><span class="s1">vals1</span><span class="s3">, </span><span class="s1">vals</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0"># use relation to geometric distribution for sampling</span>
        <span class="s1">p </span><span class="s3">= -</span><span class="s1">expm1</span><span class="s3">(-</span><span class="s1">lambda_</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">geometric</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">size</span><span class="s3">) - </span><span class="s6">1.0</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">):</span>
        <span class="s1">mu </span><span class="s3">= </span><span class="s6">1</span><span class="s3">/</span><span class="s1">expm1</span><span class="s3">(</span><span class="s1">lambda_</span><span class="s3">)</span>
        <span class="s1">var </span><span class="s3">= </span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">lambda_</span><span class="s3">)/(</span><span class="s1">expm1</span><span class="s3">(-</span><span class="s1">lambda_</span><span class="s3">))**</span><span class="s6">2</span>
        <span class="s1">g1 </span><span class="s3">= </span><span class="s6">2</span><span class="s3">*</span><span class="s1">cosh</span><span class="s3">(</span><span class="s1">lambda_</span><span class="s3">/</span><span class="s6">2.0</span><span class="s3">)</span>
        <span class="s1">g2 </span><span class="s3">= </span><span class="s6">4</span><span class="s3">+</span><span class="s6">2</span><span class="s3">*</span><span class="s1">cosh</span><span class="s3">(</span><span class="s1">lambda_</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var</span><span class="s3">, </span><span class="s1">g1</span><span class="s3">, </span><span class="s1">g2</span>

    <span class="s2">def </span><span class="s1">_entropy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">):</span>
        <span class="s1">C </span><span class="s3">= -</span><span class="s1">expm1</span><span class="s3">(-</span><span class="s1">lambda_</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">lambda_</span><span class="s3">*</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">lambda_</span><span class="s3">)/</span><span class="s1">C </span><span class="s3">- </span><span class="s1">log</span><span class="s3">(</span><span class="s1">C</span><span class="s3">)</span>


<span class="s1">planck </span><span class="s3">= </span><span class="s1">planck_gen</span><span class="s3">(</span><span class="s1">a</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s5">'planck'</span><span class="s3">, </span><span class="s1">longname</span><span class="s3">=</span><span class="s5">'A discrete exponential '</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">boltzmann_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A Boltzmann (Truncated Discrete Exponential) random variable. 
 
    %(before_notes)s 
 
    Notes 
    ----- 
    The probability mass function for `boltzmann` is: 
 
    .. math:: 
 
        f(k) = (1-\exp(-\lambda)) \exp(-\lambda k) / (1-\exp(-\lambda N)) 
 
    for :math:`k = 0,..., N-1`. 
 
    `boltzmann` takes :math:`\lambda &gt; 0` and :math:`N &gt; 0` as shape parameters. 
 
    %(after_notes)s 
 
    %(example)s 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;lambda_&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)),</span>
                <span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;N&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_argcheck</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">lambda_ </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">) &amp; (</span><span class="s1">N </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">) &amp; </span><span class="s1">_isintegral</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_support</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">a</span><span class="s3">, </span><span class="s1">N </span><span class="s3">- </span><span class="s6">1</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
        <span class="s0"># boltzmann.pmf(k) =</span>
        <span class="s0">#               (1-exp(-lambda_)*exp(-lambda_*k)/(1-exp(-lambda_*N))</span>
        <span class="s1">fact </span><span class="s3">= (</span><span class="s6">1</span><span class="s3">-</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">lambda_</span><span class="s3">))/(</span><span class="s6">1</span><span class="s3">-</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">lambda_</span><span class="s3">*</span><span class="s1">N</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">fact</span><span class="s3">*</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">lambda_</span><span class="s3">*</span><span class="s1">k</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s6">1</span><span class="s3">-</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">lambda_</span><span class="s3">*(</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)))/(</span><span class="s6">1</span><span class="s3">-</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">lambda_</span><span class="s3">*</span><span class="s1">N</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_ppf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
        <span class="s1">qnew </span><span class="s3">= </span><span class="s1">q</span><span class="s3">*(</span><span class="s6">1</span><span class="s3">-</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">lambda_</span><span class="s3">*</span><span class="s1">N</span><span class="s3">))</span>
        <span class="s1">vals </span><span class="s3">= </span><span class="s1">ceil</span><span class="s3">(-</span><span class="s6">1.0</span><span class="s3">/</span><span class="s1">lambda_ </span><span class="s3">* </span><span class="s1">log</span><span class="s3">(</span><span class="s6">1</span><span class="s3">-</span><span class="s1">qnew</span><span class="s3">)-</span><span class="s6">1</span><span class="s3">)</span>
        <span class="s1">vals1 </span><span class="s3">= (</span><span class="s1">vals</span><span class="s3">-</span><span class="s6">1</span><span class="s3">).</span><span class="s1">clip</span><span class="s3">(</span><span class="s6">0.0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">)</span>
        <span class="s1">temp </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">vals1</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">, </span><span class="s1">N</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">temp </span><span class="s3">&gt;= </span><span class="s1">q</span><span class="s3">, </span><span class="s1">vals1</span><span class="s3">, </span><span class="s1">vals</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">lambda_</span><span class="s3">, </span><span class="s1">N</span><span class="s3">):</span>
        <span class="s1">z </span><span class="s3">= </span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">lambda_</span><span class="s3">)</span>
        <span class="s1">zN </span><span class="s3">= </span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">lambda_</span><span class="s3">*</span><span class="s1">N</span><span class="s3">)</span>
        <span class="s1">mu </span><span class="s3">= </span><span class="s1">z</span><span class="s3">/(</span><span class="s6">1.0</span><span class="s3">-</span><span class="s1">z</span><span class="s3">)-</span><span class="s1">N</span><span class="s3">*</span><span class="s1">zN</span><span class="s3">/(</span><span class="s6">1</span><span class="s3">-</span><span class="s1">zN</span><span class="s3">)</span>
        <span class="s1">var </span><span class="s3">= </span><span class="s1">z</span><span class="s3">/(</span><span class="s6">1.0</span><span class="s3">-</span><span class="s1">z</span><span class="s3">)**</span><span class="s6">2 </span><span class="s3">- </span><span class="s1">N</span><span class="s3">*</span><span class="s1">N</span><span class="s3">*</span><span class="s1">zN</span><span class="s3">/(</span><span class="s6">1</span><span class="s3">-</span><span class="s1">zN</span><span class="s3">)**</span><span class="s6">2</span>
        <span class="s1">trm </span><span class="s3">= (</span><span class="s6">1</span><span class="s3">-</span><span class="s1">zN</span><span class="s3">)/(</span><span class="s6">1</span><span class="s3">-</span><span class="s1">z</span><span class="s3">)</span>
        <span class="s1">trm2 </span><span class="s3">= (</span><span class="s1">z</span><span class="s3">*</span><span class="s1">trm</span><span class="s3">**</span><span class="s6">2 </span><span class="s3">- </span><span class="s1">N</span><span class="s3">*</span><span class="s1">N</span><span class="s3">*</span><span class="s1">zN</span><span class="s3">)</span>
        <span class="s1">g1 </span><span class="s3">= </span><span class="s1">z</span><span class="s3">*(</span><span class="s6">1</span><span class="s3">+</span><span class="s1">z</span><span class="s3">)*</span><span class="s1">trm</span><span class="s3">**</span><span class="s6">3 </span><span class="s3">- </span><span class="s1">N</span><span class="s3">**</span><span class="s6">3</span><span class="s3">*</span><span class="s1">zN</span><span class="s3">*(</span><span class="s6">1</span><span class="s3">+</span><span class="s1">zN</span><span class="s3">)</span>
        <span class="s1">g1 </span><span class="s3">= </span><span class="s1">g1 </span><span class="s3">/ </span><span class="s1">trm2</span><span class="s3">**(</span><span class="s6">1.5</span><span class="s3">)</span>
        <span class="s1">g2 </span><span class="s3">= </span><span class="s1">z</span><span class="s3">*(</span><span class="s6">1</span><span class="s3">+</span><span class="s6">4</span><span class="s3">*</span><span class="s1">z</span><span class="s3">+</span><span class="s1">z</span><span class="s3">*</span><span class="s1">z</span><span class="s3">)*</span><span class="s1">trm</span><span class="s3">**</span><span class="s6">4 </span><span class="s3">- </span><span class="s1">N</span><span class="s3">**</span><span class="s6">4 </span><span class="s3">* </span><span class="s1">zN</span><span class="s3">*(</span><span class="s6">1</span><span class="s3">+</span><span class="s6">4</span><span class="s3">*</span><span class="s1">zN</span><span class="s3">+</span><span class="s1">zN</span><span class="s3">*</span><span class="s1">zN</span><span class="s3">)</span>
        <span class="s1">g2 </span><span class="s3">= </span><span class="s1">g2 </span><span class="s3">/ </span><span class="s1">trm2 </span><span class="s3">/ </span><span class="s1">trm2</span>
        <span class="s2">return </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var</span><span class="s3">, </span><span class="s1">g1</span><span class="s3">, </span><span class="s1">g2</span>


<span class="s1">boltzmann </span><span class="s3">= </span><span class="s1">boltzmann_gen</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s5">'boltzmann'</span><span class="s3">, </span><span class="s1">a</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
                          <span class="s1">longname</span><span class="s3">=</span><span class="s5">'A truncated discrete exponential '</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">randint_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A uniform discrete random variable. 
 
    %(before_notes)s 
 
    Notes 
    ----- 
    The probability mass function for `randint` is: 
 
    .. math:: 
 
        f(k) = \frac{1}{\texttt{high} - \texttt{low}} 
 
    for :math:`k \in \{\texttt{low}, \dots, \texttt{high} - 1\}`. 
 
    `randint` takes :math:`\texttt{low}` and :math:`\texttt{high}` as shape 
    parameters. 
 
    %(after_notes)s 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import randint 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, ax = plt.subplots(1, 1) 
 
    Calculate the first four moments: 
 
    &gt;&gt;&gt; low, high = 7, 31 
    &gt;&gt;&gt; mean, var, skew, kurt = randint.stats(low, high, moments='mvsk') 
 
    Display the probability mass function (``pmf``): 
 
    &gt;&gt;&gt; x = np.arange(low - 5, high + 5) 
    &gt;&gt;&gt; ax.plot(x, randint.pmf(x, low, high), 'bo', ms=8, label='randint pmf') 
    &gt;&gt;&gt; ax.vlines(x, 0, randint.pmf(x, low, high), colors='b', lw=5, alpha=0.5) 
 
    Alternatively, the distribution object can be called (as a function) to 
    fix the shape and location. This returns a &quot;frozen&quot; RV object holding the 
    given parameters fixed. 
 
    Freeze the distribution and display the frozen ``pmf``: 
 
    &gt;&gt;&gt; rv = randint(low, high) 
    &gt;&gt;&gt; ax.vlines(x, 0, rv.pmf(x), colors='k', linestyles='-', 
    ...           lw=1, label='frozen pmf') 
    &gt;&gt;&gt; ax.legend(loc='lower center') 
    &gt;&gt;&gt; plt.show() 
 
    Check the relationship between the cumulative distribution function 
    (``cdf``) and its inverse, the percent point function (``ppf``): 
 
    &gt;&gt;&gt; q = np.arange(low, high) 
    &gt;&gt;&gt; p = randint.cdf(q, low, high) 
    &gt;&gt;&gt; np.allclose(q, randint.ppf(p, low, high)) 
    True 
 
    Generate random numbers: 
 
    &gt;&gt;&gt; r = randint.rvs(low, high, size=1000) 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;low&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, (-</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)),</span>
                <span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;high&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, (-</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_argcheck</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">high </span><span class="s3">&gt; </span><span class="s1">low</span><span class="s3">) &amp; </span><span class="s1">_isintegral</span><span class="s3">(</span><span class="s1">low</span><span class="s3">) &amp; </span><span class="s1">_isintegral</span><span class="s3">(</span><span class="s1">high</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_get_support</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">-</span><span class="s6">1</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">):</span>
        <span class="s0"># randint.pmf(k) = 1./(high - low)</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones_like</span><span class="s3">(</span><span class="s1">k</span><span class="s3">) / (</span><span class="s1">high </span><span class="s3">- </span><span class="s1">low</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">((</span><span class="s1">k </span><span class="s3">&gt;= </span><span class="s1">low</span><span class="s3">) &amp; (</span><span class="s1">k </span><span class="s3">&lt; </span><span class="s1">high</span><span class="s3">), </span><span class="s1">p</span><span class="s3">, </span><span class="s6">0.</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">k </span><span class="s3">- </span><span class="s1">low </span><span class="s3">+ </span><span class="s6">1.</span><span class="s3">) / (</span><span class="s1">high </span><span class="s3">- </span><span class="s1">low</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_ppf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">):</span>
        <span class="s1">vals </span><span class="s3">= </span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">q </span><span class="s3">* (</span><span class="s1">high </span><span class="s3">- </span><span class="s1">low</span><span class="s3">) + </span><span class="s1">low</span><span class="s3">) - </span><span class="s6">1</span>
        <span class="s1">vals1 </span><span class="s3">= (</span><span class="s1">vals </span><span class="s3">- </span><span class="s6">1</span><span class="s3">).</span><span class="s1">clip</span><span class="s3">(</span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">)</span>
        <span class="s1">temp </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">vals1</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">temp </span><span class="s3">&gt;= </span><span class="s1">q</span><span class="s3">, </span><span class="s1">vals1</span><span class="s3">, </span><span class="s1">vals</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">):</span>
        <span class="s1">m2</span><span class="s3">, </span><span class="s1">m1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">high</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">low</span><span class="s3">)</span>
        <span class="s1">mu </span><span class="s3">= (</span><span class="s1">m2 </span><span class="s3">+ </span><span class="s1">m1 </span><span class="s3">- </span><span class="s6">1.0</span><span class="s3">) / </span><span class="s6">2</span>
        <span class="s1">d </span><span class="s3">= </span><span class="s1">m2 </span><span class="s3">- </span><span class="s1">m1</span>
        <span class="s1">var </span><span class="s3">= (</span><span class="s1">d</span><span class="s3">*</span><span class="s1">d </span><span class="s3">- </span><span class="s6">1</span><span class="s3">) / </span><span class="s6">12.0</span>
        <span class="s1">g1 </span><span class="s3">= </span><span class="s6">0.0</span>
        <span class="s1">g2 </span><span class="s3">= -</span><span class="s6">6.0</span><span class="s3">/</span><span class="s6">5.0 </span><span class="s3">* (</span><span class="s1">d</span><span class="s3">*</span><span class="s1">d </span><span class="s3">+ </span><span class="s6">1.0</span><span class="s3">) / (</span><span class="s1">d</span><span class="s3">*</span><span class="s1">d </span><span class="s3">- </span><span class="s6">1.0</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var</span><span class="s3">, </span><span class="s1">g1</span><span class="s3">, </span><span class="s1">g2</span>

    <span class="s2">def </span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s4">&quot;&quot;&quot;An array of *size* random integers &gt;= ``low`` and &lt; ``high``.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">low</span><span class="s3">).</span><span class="s1">size </span><span class="s3">== </span><span class="s6">1 </span><span class="s2">and </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">high</span><span class="s3">).</span><span class="s1">size </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s0"># no need to vectorize in that case</span>
            <span class="s2">return </span><span class="s1">rng_integers</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">size</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">size </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s0"># NumPy's RandomState.randint() doesn't broadcast its arguments.</span>
            <span class="s0"># Use `broadcast_to()` to extend the shapes of low and high</span>
            <span class="s0"># up to size.  Then we can use the numpy.vectorize'd</span>
            <span class="s0"># randint without needing to pass it a `size` argument.</span>
            <span class="s1">low </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">low</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>
            <span class="s1">high </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">high</span><span class="s3">, </span><span class="s1">size</span><span class="s3">)</span>
        <span class="s1">randint </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">vectorize</span><span class="s3">(</span><span class="s1">partial</span><span class="s3">(</span><span class="s1">rng_integers</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">),</span>
                               <span class="s1">otypes</span><span class="s3">=[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">)])</span>
        <span class="s2">return </span><span class="s1">randint</span><span class="s3">(</span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_entropy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">low</span><span class="s3">, </span><span class="s1">high</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">log</span><span class="s3">(</span><span class="s1">high </span><span class="s3">- </span><span class="s1">low</span><span class="s3">)</span>


<span class="s1">randint </span><span class="s3">= </span><span class="s1">randint_gen</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s5">'randint'</span><span class="s3">, </span><span class="s1">longname</span><span class="s3">=</span><span class="s5">'A discrete uniform '</span>
                      <span class="s5">'(random integer)'</span><span class="s3">)</span>


<span class="s0"># FIXME: problems sampling.</span>
<span class="s2">class </span><span class="s1">zipf_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A Zipf (Zeta) discrete random variable. 
 
    %(before_notes)s 
 
    See Also 
    -------- 
    zipfian 
 
    Notes 
    ----- 
    The probability mass function for `zipf` is: 
 
    .. math:: 
 
        f(k, a) = \frac{1}{\zeta(a) k^a} 
 
    for :math:`k \ge 1`, :math:`a &gt; 1`. 
 
    `zipf` takes :math:`a &gt; 1` as shape parameter. :math:`\zeta` is the 
    Riemann zeta function (`scipy.special.zeta`) 
 
    The Zipf distribution is also known as the zeta distribution, which is 
    a special case of the Zipfian distribution (`zipfian`). 
 
    %(after_notes)s 
 
    References 
    ---------- 
    .. [1] &quot;Zeta Distribution&quot;, Wikipedia, 
           https://en.wikipedia.org/wiki/Zeta_distribution 
 
    %(example)s 
 
    Confirm that `zipf` is the large `n` limit of `zipfian`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import zipf, zipfian 
    &gt;&gt;&gt; k = np.arange(11) 
    &gt;&gt;&gt; np.allclose(zipf.pmf(k, a), zipfian.pmf(k, a, n=10000000)) 
    True 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;a&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">1</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">zipf</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">size</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_argcheck</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">a </span><span class="s3">&gt; </span><span class="s6">1</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">a</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">k</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s0"># zipf.pmf(k, a) = 1/(zeta(a) * k**a)</span>
        <span class="s1">Pk </span><span class="s3">= </span><span class="s6">1.0 </span><span class="s3">/ </span><span class="s1">special</span><span class="s3">.</span><span class="s1">zeta</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">1</span><span class="s3">) * </span><span class="s1">k</span><span class="s3">**-</span><span class="s1">a</span>
        <span class="s2">return </span><span class="s1">Pk</span>

    <span class="s2">def </span><span class="s1">_munp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">_lazywhere</span><span class="s3">(</span>
            <span class="s1">a </span><span class="s3">&gt; </span><span class="s1">n </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">, (</span><span class="s1">a</span><span class="s3">, </span><span class="s1">n</span><span class="s3">),</span>
            <span class="s2">lambda </span><span class="s1">a</span><span class="s3">, </span><span class="s1">n</span><span class="s3">: </span><span class="s1">special</span><span class="s3">.</span><span class="s1">zeta</span><span class="s3">(</span><span class="s1">a </span><span class="s3">- </span><span class="s1">n</span><span class="s3">, </span><span class="s6">1</span><span class="s3">) / </span><span class="s1">special</span><span class="s3">.</span><span class="s1">zeta</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">1</span><span class="s3">),</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">)</span>


<span class="s1">zipf </span><span class="s3">= </span><span class="s1">zipf_gen</span><span class="s3">(</span><span class="s1">a</span><span class="s3">=</span><span class="s6">1</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s5">'zipf'</span><span class="s3">, </span><span class="s1">longname</span><span class="s3">=</span><span class="s5">'A Zipf'</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_gen_harmonic_gt1</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot;Generalized harmonic number, a &gt; 1&quot;&quot;&quot;</span>
    <span class="s0"># See https://en.wikipedia.org/wiki/Harmonic_number; search for &quot;hurwitz&quot;</span>
    <span class="s2">return </span><span class="s1">zeta</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s6">1</span><span class="s3">) - </span><span class="s1">zeta</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">n</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_gen_harmonic_leq1</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot;Generalized harmonic number, a &lt;= 1&quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">size</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">n</span>
    <span class="s1">n_max </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)  </span><span class="s0"># loop starts at maximum of all n</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">)</span>
    <span class="s0"># add terms of harmonic series; starting from smallest to avoid roundoff</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n_max</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, -</span><span class="s6">1</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">):</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">i </span><span class="s3">&lt;= </span><span class="s1">n  </span><span class="s0"># don't add terms after nth</span>
        <span class="s1">out</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">] += </span><span class="s6">1</span><span class="s3">/</span><span class="s1">i</span><span class="s3">**</span><span class="s1">a</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">_gen_harmonic</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot;Generalized harmonic number&quot;&quot;&quot;</span>
    <span class="s1">n</span><span class="s3">, </span><span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_arrays</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_lazywhere</span><span class="s3">(</span><span class="s1">a </span><span class="s3">&gt; </span><span class="s6">1</span><span class="s3">, (</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">),</span>
                      <span class="s1">f</span><span class="s3">=</span><span class="s1">_gen_harmonic_gt1</span><span class="s3">, </span><span class="s1">f2</span><span class="s3">=</span><span class="s1">_gen_harmonic_leq1</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">zipfian_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A Zipfian discrete random variable. 
 
    %(before_notes)s 
 
    See Also 
    -------- 
    zipf 
 
    Notes 
    ----- 
    The probability mass function for `zipfian` is: 
 
    .. math:: 
 
        f(k, a, n) = \frac{1}{H_{n,a} k^a} 
 
    for :math:`k \in \{1, 2, \dots, n-1, n\}`, :math:`a \ge 0`, 
    :math:`n \in \{1, 2, 3, \dots\}`. 
 
    `zipfian` takes :math:`a` and :math:`n` as shape parameters. 
    :math:`H_{n,a}` is the :math:`n`:sup:`th` generalized harmonic 
    number of order :math:`a`. 
 
    The Zipfian distribution reduces to the Zipf (zeta) distribution as 
    :math:`n \rightarrow \infty`. 
 
    %(after_notes)s 
 
    References 
    ---------- 
    .. [1] &quot;Zipf's Law&quot;, Wikipedia, https://en.wikipedia.org/wiki/Zipf's_law 
    .. [2] Larry Leemis, &quot;Zipf Distribution&quot;, Univariate Distribution 
           Relationships. http://www.math.wm.edu/~leemis/chart/UDR/PDFs/Zipf.pdf 
 
    %(example)s 
 
    Confirm that `zipfian` reduces to `zipf` for large `n`, `a &gt; 1`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import zipf, zipfian 
    &gt;&gt;&gt; k = np.arange(11) 
    &gt;&gt;&gt; np.allclose(zipfian.pmf(k, a=3.5, n=10000000), zipf.pmf(k, a=3.5)) 
    True 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;a&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)),</span>
                <span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;n&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_argcheck</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s0"># we need np.asarray here because moment (maybe others) don't convert</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">a </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">) &amp; (</span><span class="s1">n </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">) &amp; (</span><span class="s1">n </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">int</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_get_support</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s6">1</span><span class="s3">, </span><span class="s1">n</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">k</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s6">1.0 </span><span class="s3">/ </span><span class="s1">_gen_harmonic</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">) * </span><span class="s1">k</span><span class="s3">**-</span><span class="s1">a</span>

    <span class="s2">def </span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">_gen_harmonic</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">a</span><span class="s3">) / </span><span class="s1">_gen_harmonic</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_sf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">k </span><span class="s3">+ </span><span class="s6">1  </span><span class="s0"># # to match SciPy convention</span>
        <span class="s0"># see http://www.math.wm.edu/~leemis/chart/UDR/PDFs/Zipf.pdf</span>
        <span class="s2">return </span><span class="s3">((</span><span class="s1">k</span><span class="s3">**</span><span class="s1">a</span><span class="s3">*(</span><span class="s1">_gen_harmonic</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">) - </span><span class="s1">_gen_harmonic</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)) + </span><span class="s6">1</span><span class="s3">)</span>
                <span class="s3">/ (</span><span class="s1">k</span><span class="s3">**</span><span class="s1">a</span><span class="s3">*</span><span class="s1">_gen_harmonic</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)))</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
        <span class="s0"># see # see http://www.math.wm.edu/~leemis/chart/UDR/PDFs/Zipf.pdf</span>
        <span class="s1">Hna </span><span class="s3">= </span><span class="s1">_gen_harmonic</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">Hna1 </span><span class="s3">= </span><span class="s1">_gen_harmonic</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)</span>
        <span class="s1">Hna2 </span><span class="s3">= </span><span class="s1">_gen_harmonic</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">-</span><span class="s6">2</span><span class="s3">)</span>
        <span class="s1">Hna3 </span><span class="s3">= </span><span class="s1">_gen_harmonic</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">-</span><span class="s6">3</span><span class="s3">)</span>
        <span class="s1">Hna4 </span><span class="s3">= </span><span class="s1">_gen_harmonic</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">-</span><span class="s6">4</span><span class="s3">)</span>
        <span class="s1">mu1 </span><span class="s3">= </span><span class="s1">Hna1</span><span class="s3">/</span><span class="s1">Hna</span>
        <span class="s1">mu2n </span><span class="s3">= (</span><span class="s1">Hna2</span><span class="s3">*</span><span class="s1">Hna </span><span class="s3">- </span><span class="s1">Hna1</span><span class="s3">**</span><span class="s6">2</span><span class="s3">)</span>
        <span class="s1">mu2d </span><span class="s3">= </span><span class="s1">Hna</span><span class="s3">**</span><span class="s6">2</span>
        <span class="s1">mu2 </span><span class="s3">= </span><span class="s1">mu2n </span><span class="s3">/ </span><span class="s1">mu2d</span>
        <span class="s1">g1 </span><span class="s3">= (</span><span class="s1">Hna3</span><span class="s3">/</span><span class="s1">Hna </span><span class="s3">- </span><span class="s6">3</span><span class="s3">*</span><span class="s1">Hna1</span><span class="s3">*</span><span class="s1">Hna2</span><span class="s3">/</span><span class="s1">Hna</span><span class="s3">**</span><span class="s6">2 </span><span class="s3">+ </span><span class="s6">2</span><span class="s3">*</span><span class="s1">Hna1</span><span class="s3">**</span><span class="s6">3</span><span class="s3">/</span><span class="s1">Hna</span><span class="s3">**</span><span class="s6">3</span><span class="s3">)/</span><span class="s1">mu2</span><span class="s3">**(</span><span class="s6">3</span><span class="s3">/</span><span class="s6">2</span><span class="s3">)</span>
        <span class="s1">g2 </span><span class="s3">= (</span><span class="s1">Hna</span><span class="s3">**</span><span class="s6">3</span><span class="s3">*</span><span class="s1">Hna4 </span><span class="s3">- </span><span class="s6">4</span><span class="s3">*</span><span class="s1">Hna</span><span class="s3">**</span><span class="s6">2</span><span class="s3">*</span><span class="s1">Hna1</span><span class="s3">*</span><span class="s1">Hna3 </span><span class="s3">+ </span><span class="s6">6</span><span class="s3">*</span><span class="s1">Hna</span><span class="s3">*</span><span class="s1">Hna1</span><span class="s3">**</span><span class="s6">2</span><span class="s3">*</span><span class="s1">Hna2</span>
              <span class="s3">- </span><span class="s6">3</span><span class="s3">*</span><span class="s1">Hna1</span><span class="s3">**</span><span class="s6">4</span><span class="s3">) / </span><span class="s1">mu2n</span><span class="s3">**</span><span class="s6">2</span>
        <span class="s1">g2 </span><span class="s3">-= </span><span class="s6">3</span>
        <span class="s2">return </span><span class="s1">mu1</span><span class="s3">, </span><span class="s1">mu2</span><span class="s3">, </span><span class="s1">g1</span><span class="s3">, </span><span class="s1">g2</span>


<span class="s1">zipfian </span><span class="s3">= </span><span class="s1">zipfian_gen</span><span class="s3">(</span><span class="s1">a</span><span class="s3">=</span><span class="s6">1</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s5">'zipfian'</span><span class="s3">, </span><span class="s1">longname</span><span class="s3">=</span><span class="s5">'A Zipfian'</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">dlaplace_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A  Laplacian discrete random variable. 
 
    %(before_notes)s 
 
    Notes 
    ----- 
    The probability mass function for `dlaplace` is: 
 
    .. math:: 
 
        f(k) = \tanh(a/2) \exp(-a |k|) 
 
    for integers :math:`k` and :math:`a &gt; 0`. 
 
    `dlaplace` takes :math:`a` as shape parameter. 
 
    %(after_notes)s 
 
    %(example)s 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;a&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">a</span><span class="s3">):</span>
        <span class="s0"># dlaplace.pmf(k) = tanh(a/2) * exp(-a*abs(k))</span>
        <span class="s2">return </span><span class="s1">tanh</span><span class="s3">(</span><span class="s1">a</span><span class="s3">/</span><span class="s6">2.0</span><span class="s3">) * </span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">a </span><span class="s3">* </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">k</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">a</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">f</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">a</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s6">1.0 </span><span class="s3">- </span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">a </span><span class="s3">* </span><span class="s1">k</span><span class="s3">) / (</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) + </span><span class="s6">1</span><span class="s3">)</span>

        <span class="s2">def </span><span class="s1">f2</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">a</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">exp</span><span class="s3">(</span><span class="s1">a </span><span class="s3">* (</span><span class="s1">k </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">)) / (</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) + </span><span class="s6">1</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">_lazywhere</span><span class="s3">(</span><span class="s1">k </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">, (</span><span class="s1">k</span><span class="s3">, </span><span class="s1">a</span><span class="s3">), </span><span class="s1">f</span><span class="s3">=</span><span class="s1">f</span><span class="s3">, </span><span class="s1">f2</span><span class="s3">=</span><span class="s1">f2</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_ppf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">a</span><span class="s3">):</span>
        <span class="s1">const </span><span class="s3">= </span><span class="s6">1 </span><span class="s3">+ </span><span class="s1">exp</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">vals </span><span class="s3">= </span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">q </span><span class="s3">&lt; </span><span class="s6">1.0 </span><span class="s3">/ (</span><span class="s6">1 </span><span class="s3">+ </span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">a</span><span class="s3">)),</span>
                             <span class="s1">log</span><span class="s3">(</span><span class="s1">q</span><span class="s3">*</span><span class="s1">const</span><span class="s3">) / </span><span class="s1">a </span><span class="s3">- </span><span class="s6">1</span><span class="s3">,</span>
                             <span class="s3">-</span><span class="s1">log</span><span class="s3">((</span><span class="s6">1</span><span class="s3">-</span><span class="s1">q</span><span class="s3">) * </span><span class="s1">const</span><span class="s3">) / </span><span class="s1">a</span><span class="s3">))</span>
        <span class="s1">vals1 </span><span class="s3">= </span><span class="s1">vals </span><span class="s3">- </span><span class="s6">1</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">vals1</span><span class="s3">, </span><span class="s1">a</span><span class="s3">) &gt;= </span><span class="s1">q</span><span class="s3">, </span><span class="s1">vals1</span><span class="s3">, </span><span class="s1">vals</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">a</span><span class="s3">):</span>
        <span class="s1">ea </span><span class="s3">= </span><span class="s1">exp</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s1">mu2 </span><span class="s3">= </span><span class="s6">2.</span><span class="s3">*</span><span class="s1">ea</span><span class="s3">/(</span><span class="s1">ea</span><span class="s3">-</span><span class="s6">1.</span><span class="s3">)**</span><span class="s6">2</span>
        <span class="s1">mu4 </span><span class="s3">= </span><span class="s6">2.</span><span class="s3">*</span><span class="s1">ea</span><span class="s3">*(</span><span class="s1">ea</span><span class="s3">**</span><span class="s6">2</span><span class="s3">+</span><span class="s6">10.</span><span class="s3">*</span><span class="s1">ea</span><span class="s3">+</span><span class="s6">1.</span><span class="s3">) / (</span><span class="s1">ea</span><span class="s3">-</span><span class="s6">1.</span><span class="s3">)**</span><span class="s6">4</span>
        <span class="s2">return </span><span class="s6">0.</span><span class="s3">, </span><span class="s1">mu2</span><span class="s3">, </span><span class="s6">0.</span><span class="s3">, </span><span class="s1">mu4</span><span class="s3">/</span><span class="s1">mu2</span><span class="s3">**</span><span class="s6">2 </span><span class="s3">- </span><span class="s6">3.</span>

    <span class="s2">def </span><span class="s1">_entropy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">a</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">a </span><span class="s3">/ </span><span class="s1">sinh</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) - </span><span class="s1">log</span><span class="s3">(</span><span class="s1">tanh</span><span class="s3">(</span><span class="s1">a</span><span class="s3">/</span><span class="s6">2.0</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0"># The discrete Laplace is equivalent to the two-sided geometric</span>
        <span class="s0"># distribution with PMF:</span>
        <span class="s0">#   f(k) = (1 - alpha)/(1 + alpha) * alpha^abs(k)</span>
        <span class="s0">#   Reference:</span>
        <span class="s0">#     https://www.sciencedirect.com/science/</span>
        <span class="s0">#     article/abs/pii/S0378375804003519</span>
        <span class="s0"># Furthermore, the two-sided geometric distribution is</span>
        <span class="s0"># equivalent to the difference between two iid geometric</span>
        <span class="s0"># distributions.</span>
        <span class="s0">#   Reference (page 179):</span>
        <span class="s0">#     https://pdfs.semanticscholar.org/61b3/</span>
        <span class="s0">#     b99f466815808fd0d03f5d2791eea8b541a1.pdf</span>
        <span class="s0"># Thus, we can leverage the following:</span>
        <span class="s0">#   1) alpha = e^-a</span>
        <span class="s0">#   2) probability_of_success = 1 - alpha (Bernoulli trial)</span>
        <span class="s1">probOfSuccess </span><span class="s3">= -</span><span class="s1">np</span><span class="s3">.</span><span class="s1">expm1</span><span class="s3">(-</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">))</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">geometric</span><span class="s3">(</span><span class="s1">probOfSuccess</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">size</span><span class="s3">)</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">geometric</span><span class="s3">(</span><span class="s1">probOfSuccess</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">size</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">x </span><span class="s3">- </span><span class="s1">y</span>


<span class="s1">dlaplace </span><span class="s3">= </span><span class="s1">dlaplace_gen</span><span class="s3">(</span><span class="s1">a</span><span class="s3">=-</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">,</span>
                        <span class="s1">name</span><span class="s3">=</span><span class="s5">'dlaplace'</span><span class="s3">, </span><span class="s1">longname</span><span class="s3">=</span><span class="s5">'A discrete Laplacian'</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">skellam_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A  Skellam discrete random variable. 
 
    %(before_notes)s 
 
    Notes 
    ----- 
    Probability distribution of the difference of two correlated or 
    uncorrelated Poisson random variables. 
 
    Let :math:`k_1` and :math:`k_2` be two Poisson-distributed r.v. with 
    expected values :math:`\lambda_1` and :math:`\lambda_2`. Then, 
    :math:`k_1 - k_2` follows a Skellam distribution with parameters 
    :math:`\mu_1 = \lambda_1 - \rho \sqrt{\lambda_1 \lambda_2}` and 
    :math:`\mu_2 = \lambda_2 - \rho \sqrt{\lambda_1 \lambda_2}`, where 
    :math:`\rho` is the correlation coefficient between :math:`k_1` and 
    :math:`k_2`. If the two Poisson-distributed r.v. are independent then 
    :math:`\rho = 0`. 
 
    Parameters :math:`\mu_1` and :math:`\mu_2` must be strictly positive. 
 
    For details see: https://en.wikipedia.org/wiki/Skellam_distribution 
 
    `skellam` takes :math:`\mu_1` and :math:`\mu_2` as shape parameters. 
 
    %(after_notes)s 
 
    %(example)s 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;mu1&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)),</span>
                <span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;mu2&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">mu1</span><span class="s3">, </span><span class="s1">mu2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">size</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">poisson</span><span class="s3">(</span><span class="s1">mu1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">) -</span>
                <span class="s1">random_state</span><span class="s3">.</span><span class="s1">poisson</span><span class="s3">(</span><span class="s1">mu2</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">mu1</span><span class="s3">, </span><span class="s1">mu2</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">over</span><span class="s3">=</span><span class="s5">'ignore'</span><span class="s3">):  </span><span class="s0"># see gh-17432</span>
            <span class="s1">px </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">x </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">,</span>
                          <span class="s1">scu</span><span class="s3">.</span><span class="s1">_ncx2_pdf</span><span class="s3">(</span><span class="s6">2</span><span class="s3">*</span><span class="s1">mu2</span><span class="s3">, </span><span class="s6">2</span><span class="s3">*(</span><span class="s6">1</span><span class="s3">-</span><span class="s1">x</span><span class="s3">), </span><span class="s6">2</span><span class="s3">*</span><span class="s1">mu1</span><span class="s3">)*</span><span class="s6">2</span><span class="s3">,</span>
                          <span class="s1">scu</span><span class="s3">.</span><span class="s1">_ncx2_pdf</span><span class="s3">(</span><span class="s6">2</span><span class="s3">*</span><span class="s1">mu1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">*(</span><span class="s6">1</span><span class="s3">+</span><span class="s1">x</span><span class="s3">), </span><span class="s6">2</span><span class="s3">*</span><span class="s1">mu2</span><span class="s3">)*</span><span class="s6">2</span><span class="s3">)</span>
            <span class="s0"># ncx2.pdf() returns nan's for extremely low probabilities</span>
        <span class="s2">return </span><span class="s1">px</span>

    <span class="s2">def </span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">mu1</span><span class="s3">, </span><span class="s1">mu2</span><span class="s3">):</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">over</span><span class="s3">=</span><span class="s5">'ignore'</span><span class="s3">):  </span><span class="s0"># see gh-17432</span>
            <span class="s1">px </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">x </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">,</span>
                          <span class="s1">scu</span><span class="s3">.</span><span class="s1">_ncx2_cdf</span><span class="s3">(</span><span class="s6">2</span><span class="s3">*</span><span class="s1">mu2</span><span class="s3">, -</span><span class="s6">2</span><span class="s3">*</span><span class="s1">x</span><span class="s3">, </span><span class="s6">2</span><span class="s3">*</span><span class="s1">mu1</span><span class="s3">),</span>
                          <span class="s6">1 </span><span class="s3">- </span><span class="s1">scu</span><span class="s3">.</span><span class="s1">_ncx2_cdf</span><span class="s3">(</span><span class="s6">2</span><span class="s3">*</span><span class="s1">mu1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">*(</span><span class="s1">x</span><span class="s3">+</span><span class="s6">1</span><span class="s3">), </span><span class="s6">2</span><span class="s3">*</span><span class="s1">mu2</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">px</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">mu1</span><span class="s3">, </span><span class="s1">mu2</span><span class="s3">):</span>
        <span class="s1">mean </span><span class="s3">= </span><span class="s1">mu1 </span><span class="s3">- </span><span class="s1">mu2</span>
        <span class="s1">var </span><span class="s3">= </span><span class="s1">mu1 </span><span class="s3">+ </span><span class="s1">mu2</span>
        <span class="s1">g1 </span><span class="s3">= </span><span class="s1">mean </span><span class="s3">/ </span><span class="s1">sqrt</span><span class="s3">((</span><span class="s1">var</span><span class="s3">)**</span><span class="s6">3</span><span class="s3">)</span>
        <span class="s1">g2 </span><span class="s3">= </span><span class="s6">1 </span><span class="s3">/ </span><span class="s1">var</span>
        <span class="s2">return </span><span class="s1">mean</span><span class="s3">, </span><span class="s1">var</span><span class="s3">, </span><span class="s1">g1</span><span class="s3">, </span><span class="s1">g2</span>


<span class="s1">skellam </span><span class="s3">= </span><span class="s1">skellam_gen</span><span class="s3">(</span><span class="s1">a</span><span class="s3">=-</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s5">&quot;skellam&quot;</span><span class="s3">, </span><span class="s1">longname</span><span class="s3">=</span><span class="s5">'A Skellam'</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">yulesimon_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A Yule-Simon discrete random variable. 
 
    %(before_notes)s 
 
    Notes 
    ----- 
 
    The probability mass function for the `yulesimon` is: 
 
    .. math:: 
 
        f(k) =  \alpha B(k, \alpha+1) 
 
    for :math:`k=1,2,3,...`, where :math:`\alpha&gt;0`. 
    Here :math:`B` refers to the `scipy.special.beta` function. 
 
    The sampling of random variates is based on pg 553, Section 6.3 of [1]_. 
    Our notation maps to the referenced logic via :math:`\alpha=a-1`. 
 
    For details see the wikipedia entry [2]_. 
 
    References 
    ---------- 
    .. [1] Devroye, Luc. &quot;Non-uniform Random Variate Generation&quot;, 
         (1986) Springer, New York. 
 
    .. [2] https://en.wikipedia.org/wiki/Yule-Simon_distribution 
 
    %(after_notes)s 
 
    %(example)s 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;alpha&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">E1 </span><span class="s3">= </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">standard_exponential</span><span class="s3">(</span><span class="s1">size</span><span class="s3">)</span>
        <span class="s1">E2 </span><span class="s3">= </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">standard_exponential</span><span class="s3">(</span><span class="s1">size</span><span class="s3">)</span>
        <span class="s1">ans </span><span class="s3">= </span><span class="s1">ceil</span><span class="s3">(-</span><span class="s1">E1 </span><span class="s3">/ </span><span class="s1">log1p</span><span class="s3">(-</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">E2 </span><span class="s3">/ </span><span class="s1">alpha</span><span class="s3">)))</span>
        <span class="s2">return </span><span class="s1">ans</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">alpha </span><span class="s3">* </span><span class="s1">special</span><span class="s3">.</span><span class="s1">beta</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">alpha </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_argcheck</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">alpha </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_logpmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">log</span><span class="s3">(</span><span class="s1">alpha</span><span class="s3">) + </span><span class="s1">special</span><span class="s3">.</span><span class="s1">betaln</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">alpha </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_cdf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s6">1 </span><span class="s3">- </span><span class="s1">x </span><span class="s3">* </span><span class="s1">special</span><span class="s3">.</span><span class="s1">beta</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">alpha </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_sf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">x </span><span class="s3">* </span><span class="s1">special</span><span class="s3">.</span><span class="s1">beta</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">alpha </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_logsf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">log</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) + </span><span class="s1">special</span><span class="s3">.</span><span class="s1">betaln</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">alpha </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">):</span>
        <span class="s1">mu </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">alpha </span><span class="s3">&lt;= </span><span class="s6">1</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, </span><span class="s1">alpha </span><span class="s3">/ (</span><span class="s1">alpha </span><span class="s3">- </span><span class="s6">1</span><span class="s3">))</span>
        <span class="s1">mu2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">alpha </span><span class="s3">&gt; </span><span class="s6">2</span><span class="s3">,</span>
                       <span class="s1">alpha</span><span class="s3">**</span><span class="s6">2 </span><span class="s3">/ ((</span><span class="s1">alpha </span><span class="s3">- </span><span class="s6">2.0</span><span class="s3">) * (</span><span class="s1">alpha </span><span class="s3">- </span><span class="s6">1</span><span class="s3">)**</span><span class="s6">2</span><span class="s3">),</span>
                       <span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">)</span>
        <span class="s1">mu2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">alpha </span><span class="s3">&lt;= </span><span class="s6">1</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">mu2</span><span class="s3">)</span>
        <span class="s1">g1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">alpha </span><span class="s3">&gt; </span><span class="s6">3</span><span class="s3">,</span>
                      <span class="s1">sqrt</span><span class="s3">(</span><span class="s1">alpha </span><span class="s3">- </span><span class="s6">2</span><span class="s3">) * (</span><span class="s1">alpha </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">)**</span><span class="s6">2 </span><span class="s3">/ (</span><span class="s1">alpha </span><span class="s3">* (</span><span class="s1">alpha </span><span class="s3">- </span><span class="s6">3</span><span class="s3">)),</span>
                      <span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">)</span>
        <span class="s1">g1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">alpha </span><span class="s3">&lt;= </span><span class="s6">2</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">g1</span><span class="s3">)</span>
        <span class="s1">g2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">alpha </span><span class="s3">&gt; </span><span class="s6">4</span><span class="s3">,</span>
                      <span class="s1">alpha </span><span class="s3">+ </span><span class="s6">3 </span><span class="s3">+ ((</span><span class="s6">11 </span><span class="s3">* </span><span class="s1">alpha</span><span class="s3">**</span><span class="s6">3 </span><span class="s3">- </span><span class="s6">49 </span><span class="s3">* </span><span class="s1">alpha </span><span class="s3">- </span><span class="s6">22</span><span class="s3">) /</span>
                                   <span class="s3">(</span><span class="s1">alpha </span><span class="s3">* (</span><span class="s1">alpha </span><span class="s3">- </span><span class="s6">4</span><span class="s3">) * (</span><span class="s1">alpha </span><span class="s3">- </span><span class="s6">3</span><span class="s3">))),</span>
                      <span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">)</span>
        <span class="s1">g2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">alpha </span><span class="s3">&lt;= </span><span class="s6">2</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">g2</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">mu2</span><span class="s3">, </span><span class="s1">g1</span><span class="s3">, </span><span class="s1">g2</span>


<span class="s1">yulesimon </span><span class="s3">= </span><span class="s1">yulesimon_gen</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s5">'yulesimon'</span><span class="s3">, </span><span class="s1">a</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">_nchypergeom_gen</span><span class="s3">(</span><span class="s1">rv_discrete</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A noncentral hypergeometric discrete random variable. 
 
    For subclassing by nchypergeom_fisher_gen and nchypergeom_wallenius_gen. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">rvs_name </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s1">dist </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_shape_info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;M&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)),</span>
                <span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;n&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)),</span>
                <span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;N&quot;</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)),</span>
                <span class="s1">_ShapeInfo</span><span class="s3">(</span><span class="s5">&quot;odds&quot;</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, (</span><span class="s6">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">), (</span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">))]</span>

    <span class="s2">def </span><span class="s1">_get_support</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">odds</span><span class="s3">):</span>
        <span class="s1">N</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N  </span><span class="s0"># follow Wikipedia notation</span>
        <span class="s1">m2 </span><span class="s3">= </span><span class="s1">N </span><span class="s3">- </span><span class="s1">m1</span>
        <span class="s1">x_min </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">n </span><span class="s3">- </span><span class="s1">m2</span><span class="s3">)</span>
        <span class="s1">x_max </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">minimum</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">x_min</span><span class="s3">, </span><span class="s1">x_max</span>

    <span class="s2">def </span><span class="s1">_argcheck</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">odds</span><span class="s3">):</span>
        <span class="s1">M</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">M</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">n</span><span class="s3">),</span>
        <span class="s1">N</span><span class="s3">, </span><span class="s1">odds </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">N</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">odds</span><span class="s3">)</span>
        <span class="s1">cond1 </span><span class="s3">= (</span><span class="s1">M</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">) == </span><span class="s1">M</span><span class="s3">) &amp; (</span><span class="s1">M </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">cond2 </span><span class="s3">= (</span><span class="s1">n</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">) == </span><span class="s1">n</span><span class="s3">) &amp; (</span><span class="s1">n </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">cond3 </span><span class="s3">= (</span><span class="s1">N</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">int</span><span class="s3">) == </span><span class="s1">N</span><span class="s3">) &amp; (</span><span class="s1">N </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">cond4 </span><span class="s3">= </span><span class="s1">odds </span><span class="s3">&gt; </span><span class="s6">0</span>
        <span class="s1">cond5 </span><span class="s3">= </span><span class="s1">N </span><span class="s3">&lt;= </span><span class="s1">M</span>
        <span class="s1">cond6 </span><span class="s3">= </span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s1">M</span>
        <span class="s2">return </span><span class="s1">cond1 </span><span class="s3">&amp; </span><span class="s1">cond2 </span><span class="s3">&amp; </span><span class="s1">cond3 </span><span class="s3">&amp; </span><span class="s1">cond4 </span><span class="s3">&amp; </span><span class="s1">cond5 </span><span class="s3">&amp; </span><span class="s1">cond6</span>

    <span class="s2">def </span><span class="s1">_rvs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">odds</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>

        <span class="s3">@</span><span class="s1">_vectorize_rvs_over_shapes</span>
        <span class="s2">def </span><span class="s1">_rvs1</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">odds</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">):</span>
            <span class="s1">length </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">size</span><span class="s3">)</span>
            <span class="s1">urn </span><span class="s3">= </span><span class="s1">_PyStochasticLib3</span><span class="s3">()</span>
            <span class="s1">rv_gen </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">urn</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">rvs_name</span><span class="s3">)</span>
            <span class="s1">rvs </span><span class="s3">= </span><span class="s1">rv_gen</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">odds</span><span class="s3">, </span><span class="s1">length</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">)</span>
            <span class="s1">rvs </span><span class="s3">= </span><span class="s1">rvs</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">size</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">rvs</span>

        <span class="s2">return </span><span class="s1">_rvs1</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">odds</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">size</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">random_state</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_pmf</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">odds</span><span class="s3">):</span>

        <span class="s1">x</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">odds </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_arrays</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">odds</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:  </span><span class="s0"># np.vectorize doesn't work with zero size input</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

        <span class="s3">@</span><span class="s1">np</span><span class="s3">.</span><span class="s1">vectorize</span>
        <span class="s2">def </span><span class="s1">_pmf1</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">odds</span><span class="s3">):</span>
            <span class="s1">urn </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">odds</span><span class="s3">, </span><span class="s6">1e-12</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">urn</span><span class="s3">.</span><span class="s1">probability</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">_pmf1</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">odds</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_stats</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">odds</span><span class="s3">, </span><span class="s1">moments</span><span class="s3">):</span>

        <span class="s3">@</span><span class="s1">np</span><span class="s3">.</span><span class="s1">vectorize</span>
        <span class="s2">def </span><span class="s1">_moments1</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">odds</span><span class="s3">):</span>
            <span class="s1">urn </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">dist</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">odds</span><span class="s3">, </span><span class="s6">1e-12</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">urn</span><span class="s3">.</span><span class="s1">moments</span><span class="s3">()</span>

        <span class="s1">m</span><span class="s3">, </span><span class="s1">v </span><span class="s3">= (</span><span class="s1">_moments1</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">odds</span><span class="s3">) </span><span class="s2">if </span><span class="s3">(</span><span class="s5">&quot;m&quot; </span><span class="s2">in </span><span class="s1">moments </span><span class="s2">or </span><span class="s5">&quot;v&quot; </span><span class="s2">in </span><span class="s1">moments</span><span class="s3">)</span>
                <span class="s2">else </span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">))</span>
        <span class="s1">s</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">m</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">k</span>


<span class="s2">class </span><span class="s1">nchypergeom_fisher_gen</span><span class="s3">(</span><span class="s1">_nchypergeom_gen</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A Fisher's noncentral hypergeometric discrete random variable. 
 
    Fisher's noncentral hypergeometric distribution models drawing objects of 
    two types from a bin. `M` is the total number of objects, `n` is the 
    number of Type I objects, and `odds` is the odds ratio: the odds of 
    selecting a Type I object rather than a Type II object when there is only 
    one object of each type. 
    The random variate represents the number of Type I objects drawn if we 
    take a handful of objects from the bin at once and find out afterwards 
    that we took `N` objects. 
 
    %(before_notes)s 
 
    See Also 
    -------- 
    nchypergeom_wallenius, hypergeom, nhypergeom 
 
    Notes 
    ----- 
    Let mathematical symbols :math:`N`, :math:`n`, and :math:`M` correspond 
    with parameters `N`, `n`, and `M` (respectively) as defined above. 
 
    The probability mass function is defined as 
 
    .. math:: 
 
        p(x; M, n, N, \omega) = 
        \frac{\binom{n}{x}\binom{M - n}{N-x}\omega^x}{P_0}, 
 
    for 
    :math:`x \in [x_l, x_u]`, 
    :math:`M \in {\mathbb N}`, 
    :math:`n \in [0, M]`, 
    :math:`N \in [0, M]`, 
    :math:`\omega &gt; 0`, 
    where 
    :math:`x_l = \max(0, N - (M - n))`, 
    :math:`x_u = \min(N, n)`, 
 
    .. math:: 
 
        P_0 = \sum_{y=x_l}^{x_u} \binom{n}{y}\binom{M - n}{N-y}\omega^y, 
 
    and the binomial coefficients are defined as 
 
    .. math:: \binom{n}{k} \equiv \frac{n!}{k! (n - k)!}. 
 
    `nchypergeom_fisher` uses the BiasedUrn package by Agner Fog with 
    permission for it to be distributed under SciPy's license. 
 
    The symbols used to denote the shape parameters (`N`, `n`, and `M`) are not 
    universally accepted; they are chosen for consistency with `hypergeom`. 
 
    Note that Fisher's noncentral hypergeometric distribution is distinct 
    from Wallenius' noncentral hypergeometric distribution, which models 
    drawing a pre-determined `N` objects from a bin one by one. 
    When the odds ratio is unity, however, both distributions reduce to the 
    ordinary hypergeometric distribution. 
 
    %(after_notes)s 
 
    References 
    ---------- 
    .. [1] Agner Fog, &quot;Biased Urn Theory&quot;. 
           https://cran.r-project.org/web/packages/BiasedUrn/vignettes/UrnTheory.pdf 
 
    .. [2] &quot;Fisher's noncentral hypergeometric distribution&quot;, Wikipedia, 
           https://en.wikipedia.org/wiki/Fisher's_noncentral_hypergeometric_distribution 
 
    %(example)s 
 
    &quot;&quot;&quot;</span>

    <span class="s1">rvs_name </span><span class="s3">= </span><span class="s5">&quot;rvs_fisher&quot;</span>
    <span class="s1">dist </span><span class="s3">= </span><span class="s1">_PyFishersNCHypergeometric</span>


<span class="s1">nchypergeom_fisher </span><span class="s3">= </span><span class="s1">nchypergeom_fisher_gen</span><span class="s3">(</span>
    <span class="s1">name</span><span class="s3">=</span><span class="s5">'nchypergeom_fisher'</span><span class="s3">,</span>
    <span class="s1">longname</span><span class="s3">=</span><span class="s5">&quot;A Fisher's noncentral hypergeometric&quot;</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">nchypergeom_wallenius_gen</span><span class="s3">(</span><span class="s1">_nchypergeom_gen</span><span class="s3">):</span>
    <span class="s4">r&quot;&quot;&quot;A Wallenius' noncentral hypergeometric discrete random variable. 
 
    Wallenius' noncentral hypergeometric distribution models drawing objects of 
    two types from a bin. `M` is the total number of objects, `n` is the 
    number of Type I objects, and `odds` is the odds ratio: the odds of 
    selecting a Type I object rather than a Type II object when there is only 
    one object of each type. 
    The random variate represents the number of Type I objects drawn if we 
    draw a pre-determined `N` objects from a bin one by one. 
 
    %(before_notes)s 
 
    See Also 
    -------- 
    nchypergeom_fisher, hypergeom, nhypergeom 
 
    Notes 
    ----- 
    Let mathematical symbols :math:`N`, :math:`n`, and :math:`M` correspond 
    with parameters `N`, `n`, and `M` (respectively) as defined above. 
 
    The probability mass function is defined as 
 
    .. math:: 
 
        p(x; N, n, M) = \binom{n}{x} \binom{M - n}{N-x} 
        \int_0^1 \left(1-t^{\omega/D}\right)^x\left(1-t^{1/D}\right)^{N-x} dt 
 
    for 
    :math:`x \in [x_l, x_u]`, 
    :math:`M \in {\mathbb N}`, 
    :math:`n \in [0, M]`, 
    :math:`N \in [0, M]`, 
    :math:`\omega &gt; 0`, 
    where 
    :math:`x_l = \max(0, N - (M - n))`, 
    :math:`x_u = \min(N, n)`, 
 
    .. math:: 
 
        D = \omega(n - x) + ((M - n)-(N-x)), 
 
    and the binomial coefficients are defined as 
 
    .. math:: \binom{n}{k} \equiv \frac{n!}{k! (n - k)!}. 
 
    `nchypergeom_wallenius` uses the BiasedUrn package by Agner Fog with 
    permission for it to be distributed under SciPy's license. 
 
    The symbols used to denote the shape parameters (`N`, `n`, and `M`) are not 
    universally accepted; they are chosen for consistency with `hypergeom`. 
 
    Note that Wallenius' noncentral hypergeometric distribution is distinct 
    from Fisher's noncentral hypergeometric distribution, which models 
    take a handful of objects from the bin at once, finding out afterwards 
    that `N` objects were taken. 
    When the odds ratio is unity, however, both distributions reduce to the 
    ordinary hypergeometric distribution. 
 
    %(after_notes)s 
 
    References 
    ---------- 
    .. [1] Agner Fog, &quot;Biased Urn Theory&quot;. 
           https://cran.r-project.org/web/packages/BiasedUrn/vignettes/UrnTheory.pdf 
 
    .. [2] &quot;Wallenius' noncentral hypergeometric distribution&quot;, Wikipedia, 
           https://en.wikipedia.org/wiki/Wallenius'_noncentral_hypergeometric_distribution 
 
    %(example)s 
 
    &quot;&quot;&quot;</span>

    <span class="s1">rvs_name </span><span class="s3">= </span><span class="s5">&quot;rvs_wallenius&quot;</span>
    <span class="s1">dist </span><span class="s3">= </span><span class="s1">_PyWalleniusNCHypergeometric</span>


<span class="s1">nchypergeom_wallenius </span><span class="s3">= </span><span class="s1">nchypergeom_wallenius_gen</span><span class="s3">(</span>
    <span class="s1">name</span><span class="s3">=</span><span class="s5">'nchypergeom_wallenius'</span><span class="s3">,</span>
    <span class="s1">longname</span><span class="s3">=</span><span class="s5">&quot;A Wallenius' noncentral hypergeometric&quot;</span><span class="s3">)</span>


<span class="s0"># Collect names of classes and objects in this module.</span>
<span class="s1">pairs </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">globals</span><span class="s3">().</span><span class="s1">copy</span><span class="s3">().</span><span class="s1">items</span><span class="s3">())</span>
<span class="s1">_distn_names</span><span class="s3">, </span><span class="s1">_distn_gen_names </span><span class="s3">= </span><span class="s1">get_distribution_names</span><span class="s3">(</span><span class="s1">pairs</span><span class="s3">, </span><span class="s1">rv_discrete</span><span class="s3">)</span>

<span class="s1">__all__ </span><span class="s3">= </span><span class="s1">_distn_names </span><span class="s3">+ </span><span class="s1">_distn_gen_names</span>
</pre>
</body>
</html>