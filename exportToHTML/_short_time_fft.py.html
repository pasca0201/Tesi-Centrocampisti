<html>
<head>
<title>_short_time_fft.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_short_time_fft.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Implementation of an FFT-based Short-time Fourier Transform. &quot;&quot;&quot;</span>

<span class="s2"># Implementation Notes for this file (as of 2023-07)</span>
<span class="s2"># --------------------------------------------------</span>
<span class="s2"># * MyPy version 1.1.1 does not seem to support decorated property methods</span>
<span class="s2">#   properly. Hence, applying ``@property`` to methods decorated with `@cache``</span>
<span class="s2">#   (as tried with the ``lower_border_end`` method) causes a mypy error when</span>
<span class="s2">#   accessing it as an index (e.g., ``SFT.lower_border_end[0]``).</span>
<span class="s2"># * Since the method `stft` and `istft` have identical names as the legacy</span>
<span class="s2">#   functions in the signal module, referencing them as HTML link in the</span>
<span class="s2">#   docstrings has to be done by an explicit `~ShortTimeFFT.stft` instead of an</span>
<span class="s2">#   ambiguous `stft` (The ``~`` hides the class / module name).</span>
<span class="s2"># * The HTML documentation currently renders each method/property on a separate</span>
<span class="s2">#   page without reference to the parent class. Thus, a link to `ShortTimeFFT`</span>
<span class="s2">#   was added to the &quot;See Also&quot; section of each method/property. These links</span>
<span class="s2">#   can be removed, when SciPy updates ``pydata-sphinx-theme`` to &gt;= 0.13.3</span>
<span class="s2">#   (currently 0.9). Consult Issue 18512 and PR 16660 for further details.</span>
<span class="s2">#</span>

<span class="s2"># Provides typing union operator ``|`` in Python 3.9:</span>
<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>
<span class="s2"># Linter does not allow to import ``Generator`` from ``typing`` module:</span>
<span class="s3">from </span><span class="s1">collections</span><span class="s4">.</span><span class="s1">abc </span><span class="s3">import </span><span class="s1">Generator</span>
<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">cache</span><span class="s4">, </span><span class="s1">lru_cache</span><span class="s4">, </span><span class="s1">partial</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span><span class="s4">, </span><span class="s1">get_args</span><span class="s4">, </span><span class="s1">Literal</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>

<span class="s3">import </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">fft </span><span class="s3">as </span><span class="s1">fft_lib</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">signal </span><span class="s3">import </span><span class="s1">detrend</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">signal</span><span class="s4">.</span><span class="s1">windows </span><span class="s3">import </span><span class="s1">get_window</span>

<span class="s1">__all__ </span><span class="s4">= [</span><span class="s5">'ShortTimeFFT'</span><span class="s4">]</span>


<span class="s2">#: Allowed values for parameter `padding` of method `ShortTimeFFT.stft()`:</span>
<span class="s1">PAD_TYPE </span><span class="s4">= </span><span class="s1">Literal</span><span class="s4">[</span><span class="s5">'zeros'</span><span class="s4">, </span><span class="s5">'edge'</span><span class="s4">, </span><span class="s5">'even'</span><span class="s4">, </span><span class="s5">'odd'</span><span class="s4">]</span>

<span class="s2">#: Allowed values for property `ShortTimeFFT.fft_mode`:</span>
<span class="s1">FFT_MODE_TYPE </span><span class="s4">= </span><span class="s1">Literal</span><span class="s4">[</span><span class="s5">'twosided'</span><span class="s4">, </span><span class="s5">'centered'</span><span class="s4">, </span><span class="s5">'onesided'</span><span class="s4">, </span><span class="s5">'onesided2X'</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">_calc_dual_canonical_window</span><span class="s4">(</span><span class="s1">win</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">, </span><span class="s1">hop</span><span class="s4">: </span><span class="s1">int</span><span class="s4">) </span><span class="s1">-&gt; np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">:</span>
    <span class="s0">&quot;&quot;&quot;Calculate canonical dual window for 1d window `win` and a time step 
    of `hop` samples. 
 
    A ``ValueError`` is raised, if the inversion fails. 
 
    This is a separate function not a method, since it is also used in the 
    class method ``ShortTimeFFT.from_dual()``. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">hop </span><span class="s4">&gt; </span><span class="s1">len</span><span class="s4">(</span><span class="s1">win</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">hop</span><span class="s4">=</span><span class="s3">} </span><span class="s5">is larger than window length of </span><span class="s3">{</span><span class="s1">len</span><span class="s4">(</span><span class="s1">win</span><span class="s4">)</span><span class="s3">}</span><span class="s5">&quot; </span><span class="s4">+</span>
                         <span class="s5">&quot; =&gt; STFT not invertible!&quot;</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">issubclass</span><span class="s4">(</span><span class="s1">win</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">.</span><span class="s1">type</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">integer</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Parameter 'win' cannot be of integer type, but &quot; </span><span class="s4">+</span>
                         <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">win</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">=</span><span class="s3">} </span><span class="s5">=&gt; STFT not invertible!&quot;</span><span class="s4">)</span>
        <span class="s2"># The calculation of `relative_resolution` does not work for ints.</span>
        <span class="s2"># Furthermore, `win / DD` casts the integers away, thus an implicit</span>
        <span class="s2"># cast is avoided, which can always cause confusion when using 32-Bit</span>
        <span class="s2"># floats.</span>

    <span class="s1">w2 </span><span class="s4">= </span><span class="s1">win</span><span class="s4">.</span><span class="s1">real</span><span class="s4">**</span><span class="s6">2 </span><span class="s4">+ </span><span class="s1">win</span><span class="s4">.</span><span class="s1">imag</span><span class="s4">**</span><span class="s6">2  </span><span class="s2"># win*win.conj() does not ensure w2 is real</span>
    <span class="s1">DD </span><span class="s4">= </span><span class="s1">w2</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">()</span>
    <span class="s3">for </span><span class="s1">k_ </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">hop</span><span class="s4">, </span><span class="s1">len</span><span class="s4">(</span><span class="s1">win</span><span class="s4">), </span><span class="s1">hop</span><span class="s4">):</span>
        <span class="s1">DD</span><span class="s4">[</span><span class="s1">k_</span><span class="s4">:] += </span><span class="s1">w2</span><span class="s4">[:-</span><span class="s1">k_</span><span class="s4">]</span>
        <span class="s1">DD</span><span class="s4">[:-</span><span class="s1">k_</span><span class="s4">] += </span><span class="s1">w2</span><span class="s4">[</span><span class="s1">k_</span><span class="s4">:]</span>

    <span class="s2"># check DD &gt; 0:</span>
    <span class="s1">relative_resolution </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">finfo</span><span class="s4">(</span><span class="s1">win</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">).</span><span class="s1">resolution </span><span class="s4">* </span><span class="s1">max</span><span class="s4">(</span><span class="s1">DD</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">all</span><span class="s4">(</span><span class="s1">DD </span><span class="s4">&gt;= </span><span class="s1">relative_resolution</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Short-time Fourier Transform not invertible!&quot;</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">win </span><span class="s4">/ </span><span class="s1">DD</span>


<span class="s2"># noinspection PyShadowingNames</span>
<span class="s3">class </span><span class="s1">ShortTimeFFT</span><span class="s4">:</span>
    <span class="s0">r&quot;&quot;&quot;Provide a parametrized discrete Short-time Fourier transform (stft) 
    and its inverse (istft). 
 
    .. currentmodule:: scipy.signal.ShortTimeFFT 
 
    The `~ShortTimeFFT.stft` calculates sequential FFTs by sliding a 
    window (`win`) over an input signal by `hop` increments. It can be used to 
    quantify the change of the spectrum over time. 
 
    The `~ShortTimeFFT.stft` is represented by a complex-valued matrix S[q,p] 
    where the p-th column represents an FFT with the window centered at the 
    time t[p] = p * `delta_t` = p * `hop` * `T` where `T` is  the sampling 
    interval of the input signal. The q-th row represents the values at the 
    frequency f[q] = q * `delta_f` with `delta_f` = 1 / (`mfft` * `T`) being 
    the bin width of the FFT. 
 
    The inverse STFT `~ShortTimeFFT.istft` is calculated by reversing the steps 
    of the STFT: Take the IFFT of the p-th slice of S[q,p] and multiply the 
    result with the so-called dual window (see `dual_win`). Shift the result by 
    p * `delta_t` and add the result to previous shifted results to reconstruct 
    the signal. If only the dual window is known and the STFT is invertible, 
    `from_dual` can be used to instantiate this class. 
 
    Due to the convention of time t = 0 being at the first sample of the input 
    signal, the STFT values typically have negative time slots. Hence, 
    negative indexes like `p_min` or `k_min` do not indicate counting 
    backwards from an array's end like in standard Python indexing but being 
    left of t = 0. 
 
    More detailed information can be found in the :ref:`tutorial_stft` section 
    of the :ref:`user_guide`. 
 
    Note that all parameters of the initializer, except `scale_to` (which uses 
    `scaling`) have identical named attributes. 
 
    Parameters 
    ---------- 
    win : np.ndarray 
        The window must be a real- or complex-valued 1d array. 
    hop : int 
        The increment in samples, by which the window is shifted in each step. 
    fs : float 
        Sampling frequency of input signal and window. Its relation to the 
        sampling interval `T` is ``T = 1 / fs``. 
    fft_mode : 'twosided', 'centered', 'onesided', 'onesided2X' 
        Mode of FFT to be used (default 'onesided'). 
        See property `fft_mode` for details. 
    mfft: int | None 
        Length of the FFT used, if a zero padded FFT is desired. 
        If ``None`` (default), the length of the window `win` is used. 
    dual_win : np.ndarray | None 
        The dual window of `win`. If set to ``None``, it is calculated if 
        needed. 
    scale_to : 'magnitude', 'psd' | None 
        If not ``None`` (default) the window function is scaled, so each STFT 
        column represents  either a 'magnitude' or a power spectral density 
        ('psd') spectrum. This parameter sets the property `scaling` to the 
        same value. See method `scale_to` for details. 
    phase_shift : int | None 
        If set, add a linear phase `phase_shift` / `mfft` * `f` to each 
        frequency `f`. The default value 0 ensures that there is no phase shift 
        on the zeroth slice (in which t=0 is centered). See property 
        `phase_shift` for more details. 
 
    Examples 
    -------- 
    The following example shows the magnitude of the STFT of a sine with 
    varying frequency :math:`f_i(t)` (marked by a red dashed line in the plot): 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.signal import ShortTimeFFT 
    &gt;&gt;&gt; from scipy.signal.windows import gaussian 
    ... 
    &gt;&gt;&gt; T_x, N = 1 / 20, 1000  # 20 Hz sampling rate for 50 s signal 
    &gt;&gt;&gt; t_x = np.arange(N) * T_x  # time indexes for signal 
    &gt;&gt;&gt; f_i = 1 * np.arctan((t_x - t_x[N // 2]) / 2) + 5  # varying frequency 
    &gt;&gt;&gt; x = np.sin(2*np.pi*np.cumsum(f_i)*T_x) # the signal 
 
    The utilized Gaussian window is 50 samples or 2.5 s long. The parameter 
    ``mfft=200`` in `ShortTimeFFT` causes the spectrum to be oversampled 
    by a factor of 4: 
 
    &gt;&gt;&gt; g_std = 8  # standard deviation for Gaussian window in samples 
    &gt;&gt;&gt; w = gaussian(50, std=g_std, sym=True)  # symmetric Gaussian window 
    &gt;&gt;&gt; SFT = ShortTimeFFT(w, hop=10, fs=1/T_x, mfft=200, scale_to='magnitude') 
    &gt;&gt;&gt; Sx = SFT.stft(x)  # perform the STFT 
 
    In the plot, the time extent of the signal `x` is marked by vertical dashed 
    lines. Note that the SFT produces values outside the time range of `x`. The 
    shaded areas on the left and the right indicate border effects caused 
    by  the window slices in that area not fully being inside time range of 
    `x`: 
 
    &gt;&gt;&gt; fig1, ax1 = plt.subplots(figsize=(6., 4.))  # enlarge plot a bit 
    &gt;&gt;&gt; t_lo, t_hi = SFT.extent(N)[:2]  # time range of plot 
    &gt;&gt;&gt; ax1.set_title(rf&quot;STFT ({SFT.m_num*SFT.T:g}$\,s$ Gaussian window, &quot; + 
    ...               rf&quot;$\sigma_t={g_std*SFT.T}\,$s)&quot;) 
    &gt;&gt;&gt; ax1.set(xlabel=f&quot;Time $t$ in seconds ({SFT.p_num(N)} slices, &quot; + 
    ...                rf&quot;$\Delta t = {SFT.delta_t:g}\,$s)&quot;, 
    ...         ylabel=f&quot;Freq. $f$ in Hz ({SFT.f_pts} bins, &quot; + 
    ...                rf&quot;$\Delta f = {SFT.delta_f:g}\,$Hz)&quot;, 
    ...         xlim=(t_lo, t_hi)) 
    ... 
    &gt;&gt;&gt; im1 = ax1.imshow(abs(Sx), origin='lower', aspect='auto', 
    ...                  extent=SFT.extent(N), cmap='viridis') 
    &gt;&gt;&gt; ax1.plot(t_x, f_i, 'r--', alpha=.5, label='$f_i(t)$') 
    &gt;&gt;&gt; fig1.colorbar(im1, label=&quot;Magnitude $|S_x(t, f)|$&quot;) 
    ... 
    &gt;&gt;&gt; # Shade areas where window slices stick out to the side: 
    &gt;&gt;&gt; for t0_, t1_ in [(t_lo, SFT.lower_border_end[0] * SFT.T), 
    ...                  (SFT.upper_border_begin(N)[0] * SFT.T, t_hi)]: 
    ...     ax1.axvspan(t0_, t1_, color='w', linewidth=0, alpha=.2) 
    &gt;&gt;&gt; for t_ in [0, N * SFT.T]:  # mark signal borders with vertical line: 
    ...     ax1.axvline(t_, color='y', linestyle='--', alpha=0.5) 
    &gt;&gt;&gt; ax1.legend() 
    &gt;&gt;&gt; fig1.tight_layout() 
    &gt;&gt;&gt; plt.show() 
 
    Reconstructing the signal with the `~ShortTimeFFT.istft` is 
    straightforward, but note that the length of `x1` should be specified, 
    since the SFT length increases in `hop` steps: 
 
    &gt;&gt;&gt; SFT.invertible  # check if invertible 
    True 
    &gt;&gt;&gt; x1 = SFT.istft(Sx, k1=N) 
    &gt;&gt;&gt; np.allclose(x, x1) 
    True 
 
    It is possible to calculate the SFT of signal parts: 
 
    &gt;&gt;&gt; p_q = SFT.nearest_k_p(N // 2) 
    &gt;&gt;&gt; Sx0 = SFT.stft(x[:p_q]) 
    &gt;&gt;&gt; Sx1 = SFT.stft(x[p_q:]) 
 
    When assembling sequential STFT parts together, the overlap needs to be 
    considered: 
 
    &gt;&gt;&gt; p0_ub = SFT.upper_border_begin(p_q)[1] - SFT.p_min 
    &gt;&gt;&gt; p1_le = SFT.lower_border_end[1] - SFT.p_min 
    &gt;&gt;&gt; Sx01 = np.hstack((Sx0[:, :p0_ub], 
    ...                   Sx0[:, p0_ub:] + Sx1[:, :p1_le], 
    ...                   Sx1[:, p1_le:])) 
    &gt;&gt;&gt; np.allclose(Sx01, Sx)  # Compare with SFT of complete signal 
    True 
 
    It is also possible to calculate the `itsft` for signal parts: 
 
    &gt;&gt;&gt; y_p = SFT.istft(Sx, N//3, N//2) 
    &gt;&gt;&gt; np.allclose(y_p, x[N//3:N//2]) 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># immutable attributes (only have getters but no setters):</span>
    <span class="s1">_win</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray  </span><span class="s2"># window</span>
    <span class="s1">_dual_win</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None  </span><span class="s2"># canonical dual window</span>
    <span class="s1">_hop</span><span class="s4">: </span><span class="s1">int  </span><span class="s2"># Step of STFT in number of samples</span>

    <span class="s2"># mutable attributes:</span>
    <span class="s1">_fs</span><span class="s4">: </span><span class="s1">float  </span><span class="s2"># sampling frequency of input signal and window</span>
    <span class="s1">_fft_mode</span><span class="s4">: </span><span class="s1">FFT_MODE_TYPE </span><span class="s4">= </span><span class="s5">'onesided'  </span><span class="s2"># Mode of FFT to use</span>
    <span class="s1">_mfft</span><span class="s4">: </span><span class="s1">int  </span><span class="s2"># length of FFT used - defaults to len(win)</span>
    <span class="s1">_scaling</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s5">'magnitude'</span><span class="s4">, </span><span class="s5">'psd'</span><span class="s4">] | </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None  </span><span class="s2"># Scaling of _win</span>
    <span class="s1">_phase_shift</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None  </span><span class="s2"># amount to shift phase of FFT in samples</span>

    <span class="s2"># attributes for caching calculated values:</span>
    <span class="s1">_fac_mag</span><span class="s4">: </span><span class="s1">float </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s1">_fac_psd</span><span class="s4">: </span><span class="s1">float </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s1">_lower_border_end</span><span class="s4">: </span><span class="s1">tuple</span><span class="s4">[</span><span class="s1">int</span><span class="s4">, </span><span class="s1">int</span><span class="s4">] | </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">win</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">, </span><span class="s1">hop</span><span class="s4">: </span><span class="s1">int</span><span class="s4">, </span><span class="s1">fs</span><span class="s4">: </span><span class="s1">float</span><span class="s4">, *,</span>
                 <span class="s1">fft_mode</span><span class="s4">: </span><span class="s1">FFT_MODE_TYPE </span><span class="s4">= </span><span class="s5">'onesided'</span><span class="s4">,</span>
                 <span class="s1">mfft</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
                 <span class="s1">dual_win</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
                 <span class="s1">scale_to</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s5">'magnitude'</span><span class="s4">, </span><span class="s5">'psd'</span><span class="s4">] | </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
                 <span class="s1">phase_shift</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s6">0</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s4">(</span><span class="s1">win</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">== </span><span class="s6">1 </span><span class="s3">and </span><span class="s1">win</span><span class="s4">.</span><span class="s1">size </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;Parameter win must be 1d, but </span><span class="s3">{</span><span class="s1">win</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">=</span><span class="s3">}</span><span class="s5">!&quot;</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">all</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">isfinite</span><span class="s4">(</span><span class="s1">win</span><span class="s4">)):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Parameter win must have finite entries!&quot;</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s4">(</span><span class="s1">hop </span><span class="s4">&gt;= </span><span class="s6">1 </span><span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">hop</span><span class="s4">, </span><span class="s1">int</span><span class="s4">)):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;Parameter </span><span class="s3">{</span><span class="s1">hop</span><span class="s4">=</span><span class="s3">} </span><span class="s5">is not an integer &gt;= 1!&quot;</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_win</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_hop</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fs </span><span class="s4">= </span><span class="s1">win</span><span class="s4">, </span><span class="s1">hop</span><span class="s4">, </span><span class="s1">fs</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">mfft </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">win</span><span class="s4">) </span><span class="s3">if </span><span class="s1">mfft </span><span class="s3">is None else </span><span class="s1">mfft</span>

        <span class="s3">if </span><span class="s1">dual_win </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">dual_win</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">!= </span><span class="s1">win</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">dual_win</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">=</span><span class="s3">} </span><span class="s5">must equal </span><span class="s3">{</span><span class="s1">win</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">=</span><span class="s3">}</span><span class="s5">!&quot;</span><span class="s4">)</span>
            <span class="s3">if not </span><span class="s1">all</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">isfinite</span><span class="s4">(</span><span class="s1">dual_win</span><span class="s4">)):</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Parameter dual_win must be a finite array!&quot;</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_dual_win </span><span class="s4">= </span><span class="s1">dual_win  </span><span class="s2"># needs to be set before scaling</span>

        <span class="s3">if </span><span class="s1">scale_to </span><span class="s3">is not None</span><span class="s4">:  </span><span class="s2"># needs to be set before fft_mode</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">scale_to</span><span class="s4">(</span><span class="s1">scale_to</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">phase_shift </span><span class="s4">= </span><span class="s1">fft_mode</span><span class="s4">, </span><span class="s1">phase_shift</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">from_dual</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">dual_win</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">, </span><span class="s1">hop</span><span class="s4">: </span><span class="s1">int</span><span class="s4">, </span><span class="s1">fs</span><span class="s4">: </span><span class="s1">float</span><span class="s4">, *,</span>
                  <span class="s1">fft_mode</span><span class="s4">: </span><span class="s1">FFT_MODE_TYPE </span><span class="s4">= </span><span class="s5">'onesided'</span><span class="s4">,</span>
                  <span class="s1">mfft</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
                  <span class="s1">scale_to</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s5">'magnitude'</span><span class="s4">, </span><span class="s5">'psd'</span><span class="s4">] | </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
                  <span class="s1">phase_shift</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s6">0</span><span class="s4">):</span>
        <span class="s0">r&quot;&quot;&quot;Instantiate a `ShortTimeFFT` by only providing a dual window. 
 
        If an STFT is invertible, it is possible to calculate the window `win` 
        from a given dual window `dual_win`. All other parameters have the 
        same meaning as in the initializer of `ShortTimeFFT`. 
 
        As explained in the :ref:`tutorial_stft` section of the 
        :ref:`user_guide`, an invertible STFT can be interpreted as series 
        expansion of time-shifted and frequency modulated dual windows. E.g., 
        the series coefficient S[q,p] belongs to the term, which shifted 
        `dual_win` by p * `delta_t` and multiplied it by 
        exp( 2 * j * pi * t * q * `delta_f`). 
 
 
        Examples 
        -------- 
        The following example discusses decomposing a signal into time- and 
        frequency-shifted Gaussians. A Gaussian with standard deviation of 
        one made up of 51 samples will be used: 
 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; import matplotlib.pyplot as plt 
        &gt;&gt;&gt; from scipy.signal import ShortTimeFFT 
        &gt;&gt;&gt; from scipy.signal.windows import gaussian 
        ... 
        &gt;&gt;&gt; T, N = 0.1, 51 
        &gt;&gt;&gt; d_win = gaussian(N, std=1/T, sym=True)  # symmetric Gaussian window 
        &gt;&gt;&gt; t = T * (np.arange(N) - N//2) 
        ... 
        &gt;&gt;&gt; fg1, ax1 = plt.subplots() 
        &gt;&gt;&gt; ax1.set_title(r&quot;Dual Window: Gaussian with $\sigma_t=1$&quot;) 
        &gt;&gt;&gt; ax1.set(xlabel=f&quot;Time $t$ in seconds ({N} samples, $T={T}$ s)&quot;, 
        ...        xlim=(t[0], t[-1]), ylim=(0, 1.1*max(d_win))) 
        &gt;&gt;&gt; ax1.plot(t, d_win, 'C0-') 
 
        The following plot with the overlap of 41, 11 and 2 samples show how 
        the `hop` interval affects the shape of the window `win`: 
 
        &gt;&gt;&gt; fig2, axx = plt.subplots(3, 1, sharex='all') 
        ... 
        &gt;&gt;&gt; axx[0].set_title(r&quot;Windows for hop$\in\{10, 40, 49\}$&quot;) 
        &gt;&gt;&gt; for c_, h_ in enumerate([10, 40, 49]): 
        ...     SFT = ShortTimeFFT.from_dual(d_win, h_, 1/T) 
        ...     axx[c_].plot(t + h_ * T, SFT.win, 'k--', alpha=.3, label=None) 
        ...     axx[c_].plot(t - h_ * T, SFT.win, 'k:', alpha=.3, label=None) 
        ...     axx[c_].plot(t, SFT.win, f'C{c_+1}', 
        ...                     label=r&quot;$\Delta t=%0.1f\,$s&quot; % SFT.delta_t) 
        ...     axx[c_].set_ylim(0, 1.1*max(SFT.win)) 
        ...     axx[c_].legend(loc='center') 
        &gt;&gt;&gt; axx[-1].set(xlabel=f&quot;Time $t$ in seconds ({N} samples, $T={T}$ s)&quot;, 
        ...             xlim=(t[0], t[-1])) 
        &gt;&gt;&gt; plt.show() 
 
        Beside the window `win` centered at t = 0 the previous (t = -`delta_t`) 
        and following window (t = `delta_t`) are depicted. It can be seen that 
        for small `hop` intervals, the window is compact and smooth, having a 
        good time-frequency concentration in the STFT. For the large `hop` 
        interval of 4.9 s, the window has small values around t = 0, which are 
        not covered by the overlap of the adjacent windows, which could lead to 
        numeric inaccuracies. Furthermore, the peaky shape at the beginning and 
        the end of the window points to a higher bandwidth, resulting in a 
        poorer time-frequency resolution of the STFT. 
        Hence, the choice of the `hop` interval will be a compromise between 
        a time-frequency resolution and memory requirements demanded by small 
        `hop` sizes. 
 
        See Also 
        -------- 
        from_window: Create instance by wrapping `get_window`. 
        ShortTimeFFT: Create instance using standard initializer. 
        &quot;&quot;&quot;</span>
        <span class="s1">win </span><span class="s4">= </span><span class="s1">_calc_dual_canonical_window</span><span class="s4">(</span><span class="s1">dual_win</span><span class="s4">, </span><span class="s1">hop</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">cls</span><span class="s4">(</span><span class="s1">win</span><span class="s4">=</span><span class="s1">win</span><span class="s4">, </span><span class="s1">hop</span><span class="s4">=</span><span class="s1">hop</span><span class="s4">, </span><span class="s1">fs</span><span class="s4">=</span><span class="s1">fs</span><span class="s4">, </span><span class="s1">fft_mode</span><span class="s4">=</span><span class="s1">fft_mode</span><span class="s4">, </span><span class="s1">mfft</span><span class="s4">=</span><span class="s1">mfft</span><span class="s4">,</span>
                   <span class="s1">dual_win</span><span class="s4">=</span><span class="s1">dual_win</span><span class="s4">, </span><span class="s1">scale_to</span><span class="s4">=</span><span class="s1">scale_to</span><span class="s4">,</span>
                   <span class="s1">phase_shift</span><span class="s4">=</span><span class="s1">phase_shift</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">from_window</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">win_param</span><span class="s4">: </span><span class="s1">str </span><span class="s4">| </span><span class="s1">tuple </span><span class="s4">| </span><span class="s1">float</span><span class="s4">,</span>
                    <span class="s1">fs</span><span class="s4">: </span><span class="s1">float</span><span class="s4">, </span><span class="s1">nperseg</span><span class="s4">: </span><span class="s1">int</span><span class="s4">, </span><span class="s1">noverlap</span><span class="s4">: </span><span class="s1">int</span><span class="s4">, *,</span>
                    <span class="s1">symmetric_win</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
                    <span class="s1">fft_mode</span><span class="s4">: </span><span class="s1">FFT_MODE_TYPE </span><span class="s4">= </span><span class="s5">'onesided'</span><span class="s4">,</span>
                    <span class="s1">mfft</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
                    <span class="s1">scale_to</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s5">'magnitude'</span><span class="s4">, </span><span class="s5">'psd'</span><span class="s4">] | </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
                    <span class="s1">phase_shift</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s6">0</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Instantiate `ShortTimeFFT` by using `get_window`. 
 
        The method `get_window` is used to create a window of length 
        `nperseg`. The parameter names `noverlap`, and `nperseg` are used here, 
        since they more inline with other classical STFT libraries. 
 
        Parameters 
        ---------- 
        win_param: Union[str, tuple, float], 
            Parameters passed to `get_window`. For windows with no parameters, 
            it may be a string (e.g., ``'hann'``), for parametrized windows a 
            tuple, (e.g., ``('gaussian', 2.)``) or a single float specifying 
            the shape parameter of a kaiser window (i.e. ``4.``  and 
            ``('kaiser', 4.)`` are equal. See `get_window` for more details. 
        fs : float 
            Sampling frequency of input signal. Its relation to the 
            sampling interval `T` is ``T = 1 / fs``. 
        nperseg: int 
            Window length in samples, which corresponds to the `m_num`. 
        noverlap: int 
            Window overlap in samples. It relates to the `hop` increment by 
            ``hop = npsereg - noverlap``. 
        symmetric_win: bool 
            If ``True`` then a symmetric window is generated, else a periodic 
            window is generated (default). Though symmetric windows seem for 
            most applications to be more sensible, the default of a periodic 
            windows was chosen to correspond to the default of `get_window`. 
        fft_mode : 'twosided', 'centered', 'onesided', 'onesided2X' 
            Mode of FFT to be used (default 'onesided'). 
            See property `fft_mode` for details. 
        mfft: int | None 
            Length of the FFT used, if a zero padded FFT is desired. 
            If ``None`` (default), the length of the window `win` is used. 
        scale_to : 'magnitude', 'psd' | None 
            If not ``None`` (default) the window function is scaled, so each 
            STFT column represents  either a 'magnitude' or a power spectral 
            density ('psd') spectrum. This parameter sets the property 
            `scaling` to the same value. See method `scale_to` for details. 
        phase_shift : int | None 
            If set, add a linear phase `phase_shift` / `mfft` * `f` to each 
            frequency `f`. The default value 0 ensures that there is no phase 
            shift on the zeroth slice (in which t=0 is centered). See property 
            `phase_shift` for more details. 
 
        Examples 
        -------- 
        The following instances ``SFT0`` and ``SFT1`` are equivalent: 
 
        &gt;&gt;&gt; from scipy.signal import ShortTimeFFT, get_window 
        &gt;&gt;&gt; nperseg = 9  # window length 
        &gt;&gt;&gt; w = get_window(('gaussian', 2.), nperseg) 
        &gt;&gt;&gt; fs = 128  # sampling frequency 
        &gt;&gt;&gt; hop = 3  # increment of STFT time slice 
        &gt;&gt;&gt; SFT0 = ShortTimeFFT(w, hop, fs=fs) 
        &gt;&gt;&gt; SFT1 = ShortTimeFFT.from_window(('gaussian', 2.), fs, nperseg, 
        ...                                 noverlap=nperseg-hop) 
 
        See Also 
        -------- 
        scipy.signal.get_window: Return a window of a given length and type. 
        from_dual: Create instance using dual window. 
        ShortTimeFFT: Create instance using standard initializer. 
        &quot;&quot;&quot;</span>
        <span class="s1">win </span><span class="s4">= </span><span class="s1">get_window</span><span class="s4">(</span><span class="s1">win_param</span><span class="s4">, </span><span class="s1">nperseg</span><span class="s4">, </span><span class="s1">fftbins</span><span class="s4">=</span><span class="s3">not </span><span class="s1">symmetric_win</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">cls</span><span class="s4">(</span><span class="s1">win</span><span class="s4">, </span><span class="s1">hop</span><span class="s4">=</span><span class="s1">nperseg</span><span class="s4">-</span><span class="s1">noverlap</span><span class="s4">, </span><span class="s1">fs</span><span class="s4">=</span><span class="s1">fs</span><span class="s4">, </span><span class="s1">fft_mode</span><span class="s4">=</span><span class="s1">fft_mode</span><span class="s4">,</span>
                   <span class="s1">mfft</span><span class="s4">=</span><span class="s1">mfft</span><span class="s4">, </span><span class="s1">scale_to</span><span class="s4">=</span><span class="s1">scale_to</span><span class="s4">, </span><span class="s1">phase_shift</span><span class="s4">=</span><span class="s1">phase_shift</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">win</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Window function as real- or complex-valued 1d array. 
 
        This attribute is read only, since `dual_win` depends on it. 
 
        See Also 
        -------- 
        dual_win: Canonical dual window. 
        m_num: Number of samples in window `win`. 
        m_num_mid: Center index of window `win`. 
        mfft: Length of input for the FFT used - may be larger than `m_num`. 
        hop: ime increment in signal samples for sliding window. 
        win: Window function as real- or complex-valued 1d array. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_win</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">hop</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Time increment in signal samples for sliding window. 
 
        This attribute is read only, since `dual_win` depends on it. 
 
        See Also 
        -------- 
        delta_t: Time increment of STFT (``hop*T``) 
        m_num: Number of samples in window `win`. 
        m_num_mid: Center index of window `win`. 
        mfft: Length of input for the FFT used - may be larger than `m_num`. 
        T: Sampling interval of input signal and of the window. 
        win: Window function as real- or complex-valued 1d array. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_hop</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">T</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; float</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Sampling interval of input signal and of the window. 
 
        A ``ValueError`` is raised if it is set to a non-positive value. 
 
        See Also 
        -------- 
        delta_t: Time increment of STFT (``hop*T``) 
        hop: Time increment in signal samples for sliding window. 
        fs: Sampling frequency (being ``1/T``) 
        t: Times of STFT for an input signal with `n` samples. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s6">1 </span><span class="s4">/ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fs</span>

    <span class="s4">@</span><span class="s1">T</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">T</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">v</span><span class="s4">: </span><span class="s1">float</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Sampling interval of input signal and of the window. 
 
        A ``ValueError`` is raised if it is set to a non-positive value. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s4">(</span><span class="s1">v </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;Sampling interval T=</span><span class="s3">{</span><span class="s1">v</span><span class="s3">} </span><span class="s5">must be positive!&quot;</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_fs </span><span class="s4">= </span><span class="s6">1 </span><span class="s4">/ </span><span class="s1">v</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">fs</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; float</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Sampling frequency of input signal and of the window. 
 
        The sampling frequency is the inverse of the sampling interval `T`. 
        A ``ValueError`` is raised if it is set to a non-positive value. 
 
        See Also 
        -------- 
        delta_t: Time increment of STFT (``hop*T``) 
        hop: Time increment in signal samples for sliding window. 
        T: Sampling interval of input signal and of the window (``1/fs``). 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fs</span>

    <span class="s4">@</span><span class="s1">fs</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">fs</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">v</span><span class="s4">: </span><span class="s1">float</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Sampling frequency of input signal and of the window. 
 
        The sampling frequency is the inverse of the sampling interval `T`. 
        A ``ValueError`` is raised if it is set to a non-positive value. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s4">(</span><span class="s1">v </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;Sampling frequency fs=</span><span class="s3">{</span><span class="s1">v</span><span class="s3">} </span><span class="s5">must be positive!&quot;</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_fs </span><span class="s4">= </span><span class="s1">v</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">fft_mode</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; FFT_MODE_TYPE</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Mode of utilized FFT ('twosided', 'centered', 'onesided' or 
        'onesided2X'). 
 
        It can have the following values: 
 
        'twosided': 
            Two-sided FFT, where values for the negative frequencies are in 
            upper half of the array. Corresponds to :func:`~scipy.fft.fft()`. 
        'centered': 
            Two-sided FFT with the values being ordered along monotonically 
            increasing frequencies. Corresponds to applying 
            :func:`~scipy.fft.fftshift()` to :func:`~scipy.fft.fft()`. 
        'onesided': 
            Calculates only values for non-negative frequency values. 
            Corresponds to :func:`~scipy.fft.rfft()`. 
        'onesided2X': 
            Like `onesided`, but the non-zero frequencies are doubled if 
            `scaling` is set to 'magnitude' or multiplied by ``sqrt(2)`` if 
            set to 'psd'. If `scaling` is ``None``, setting `fft_mode` to 
            `onesided2X` is not allowed. 
            If the FFT length `mfft` is even, the last FFT value is not paired, 
            and thus it is not scaled. 
 
        Note that `onesided` and `onesided2X` do not work for complex-valued signals or 
        complex-valued windows. Furthermore, the frequency values can be obtained by 
        reading the `f` property, and the number of samples by accessing the `f_pts` 
        property. 
 
        See Also 
        -------- 
        delta_f: Width of the frequency bins of the STFT. 
        f: Frequencies values of the STFT. 
        f_pts: Width of the frequency bins of the STFT. 
        onesided_fft: True if a one-sided FFT is used. 
        scaling: Normalization applied to the window function 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fft_mode</span>

    <span class="s4">@</span><span class="s1">fft_mode</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">fft_mode</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">t</span><span class="s4">: </span><span class="s1">FFT_MODE_TYPE</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Set mode of FFT. 
 
        Allowed values are 'twosided', 'centered', 'onesided', 'onesided2X'. 
        See the property `fft_mode` for more details. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">t </span><span class="s3">not in </span><span class="s4">(</span><span class="s1">fft_mode_types </span><span class="s4">:= </span><span class="s1">get_args</span><span class="s4">(</span><span class="s1">FFT_MODE_TYPE</span><span class="s4">)):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;fft_mode='</span><span class="s3">{</span><span class="s1">t</span><span class="s3">}</span><span class="s5">' not in </span><span class="s3">{</span><span class="s1">fft_mode_types</span><span class="s3">}</span><span class="s5">!&quot;</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">t </span><span class="s3">in </span><span class="s4">{</span><span class="s5">'onesided'</span><span class="s4">, </span><span class="s5">'onesided2X'</span><span class="s4">} </span><span class="s3">and </span><span class="s1">np</span><span class="s4">.</span><span class="s1">iscomplexobj</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">win</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;One-sided spectra, i.e., fft_mode='</span><span class="s3">{</span><span class="s1">t</span><span class="s3">}</span><span class="s5">', &quot; </span><span class="s4">+</span>
                             <span class="s5">&quot;are not allowed for complex-valued windows!&quot;</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">t </span><span class="s4">== </span><span class="s5">'onesided2X' </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">scaling </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;For scaling is None, fft_mode='</span><span class="s3">{</span><span class="s1">t</span><span class="s3">}</span><span class="s5">' is invalid!&quot;</span>
                             <span class="s5">&quot;Do scale_to('psd') or scale_to('magnitude')!&quot;</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_fft_mode </span><span class="s4">= </span><span class="s1">t</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">mfft</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Length of input for the FFT used - may be larger than window 
        length `m_num`. 
 
        If not set, `mfft` defaults to the window length `m_num`. 
 
        See Also 
        -------- 
        f_pts: Number of points along the frequency axis. 
        f: Frequencies values of the STFT. 
        m_num: Number of samples in window `win`. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_mfft</span>

    <span class="s4">@</span><span class="s1">mfft</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">mfft</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">n_</span><span class="s4">: </span><span class="s1">int</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Setter for the length of FFT utilized. 
 
        See the property `mfft` for further details. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s4">(</span><span class="s1">n_ </span><span class="s4">&gt;= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;Attribute mfft=</span><span class="s3">{</span><span class="s1">n_</span><span class="s3">} </span><span class="s5">needs to be at least the &quot; </span><span class="s4">+</span>
                             <span class="s5">f&quot;window length m_num=</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num</span><span class="s3">}</span><span class="s5">!&quot;</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_mfft </span><span class="s4">= </span><span class="s1">n_</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">scaling</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Literal</span><span class="s4">[</span><span class="s5">'magnitude'</span><span class="s4">, </span><span class="s5">'psd'</span><span class="s4">] | </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Normalization applied to the window function 
        ('magnitude', 'psd' or ``None``). 
 
        If not ``None``, the FFTs can be either interpreted as a magnitude or 
        a power spectral density spectrum. 
 
        The window function can be scaled by calling the `scale_to` method, 
        or it is set by the initializer parameter ``scale_to``. 
 
        See Also 
        -------- 
        fac_magnitude: Scaling factor for to a magnitude spectrum. 
        fac_psd: Scaling factor for to  a power spectral density spectrum. 
        fft_mode: Mode of utilized FFT 
        scale_to: Scale window to obtain 'magnitude' or 'psd' scaling. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_scaling</span>

    <span class="s3">def </span><span class="s1">scale_to</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">scaling</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s5">'magnitude'</span><span class="s4">, </span><span class="s5">'psd'</span><span class="s4">]):</span>
        <span class="s0">&quot;&quot;&quot;Scale window to obtain 'magnitude' or 'psd' scaling for the STFT. 
 
        The window of a 'magnitude' spectrum has an integral of one, i.e., unit 
        area for non-negative windows. This ensures that absolute the values of 
        spectrum does not change if the length of the window changes (given 
        the input signal is stationary). 
 
        To represent the power spectral density ('psd') for varying length 
        windows the area of the absolute square of the window needs to be 
        unity. 
 
        The `scaling` property shows the current scaling. The properties 
        `fac_magnitude` and `fac_psd` show the scaling factors required to 
        scale the STFT values to a magnitude or a psd spectrum. 
 
        This method is called, if the initializer parameter `scale_to` is set. 
 
        See Also 
        -------- 
        fac_magnitude: Scaling factor for to  a magnitude spectrum. 
        fac_psd: Scaling factor for to  a power spectral density spectrum. 
        fft_mode: Mode of utilized FFT 
        scaling: Normalization applied to the window function. 
        ShortTimeFFT: Class this method belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">scaling </span><span class="s3">not in </span><span class="s4">(</span><span class="s1">scaling_values </span><span class="s4">:= {</span><span class="s5">'magnitude'</span><span class="s4">, </span><span class="s5">'psd'</span><span class="s4">}):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">scaling</span><span class="s4">=</span><span class="s3">} </span><span class="s5">not in </span><span class="s3">{</span><span class="s1">scaling_values</span><span class="s3">}</span><span class="s5">!&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_scaling </span><span class="s4">== </span><span class="s1">scaling</span><span class="s4">:  </span><span class="s2"># do nothing</span>
            <span class="s3">return</span>

        <span class="s1">s_fac </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fac_psd </span><span class="s3">if </span><span class="s1">scaling </span><span class="s4">== </span><span class="s5">'psd' </span><span class="s3">else </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fac_magnitude</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_win </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_win </span><span class="s4">* </span><span class="s1">s_fac</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dual_win </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_dual_win </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dual_win </span><span class="s4">/ </span><span class="s1">s_fac</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_fac_mag</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fac_psd </span><span class="s4">= </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None  </span><span class="s2"># reset scaling factors</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_scaling </span><span class="s4">= </span><span class="s1">scaling</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">phase_shift</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int </span><span class="s4">| </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;If set, add linear phase `phase_shift` / `mfft` * `f` to each FFT 
        slice of frequency `f`. 
 
        Shifting (more precisely `rolling`) an `mfft`-point FFT input by 
        `phase_shift` samples results in a multiplication of the output by 
        ``np.exp(2j*np.pi*q*phase_shift/mfft)`` at the frequency q * `delta_f`. 
 
        The default value 0 ensures that there is no phase shift on the 
        zeroth slice (in which t=0 is centered). 
        No phase shift (``phase_shift is None``) is equivalent to 
        ``phase_shift = -mfft//2``. In this case slices are not shifted 
        before calculating the FFT. 
 
        The absolute value of `phase_shift` is limited to be less than `mfft`. 
 
        See Also 
        -------- 
        delta_f: Width of the frequency bins of the STFT. 
        f: Frequencies values of the STFT. 
        mfft: Length of input for the FFT used 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_phase_shift</span>

    <span class="s4">@</span><span class="s1">phase_shift</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">phase_shift</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">v</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;The absolute value of the phase shift needs to be less than mfft 
        samples. 
 
        See the `phase_shift` getter method for more details. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">v </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_phase_shift </span><span class="s4">= </span><span class="s1">v</span>
            <span class="s3">return</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">v</span><span class="s4">, </span><span class="s1">int</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;phase_shift=</span><span class="s3">{</span><span class="s1">v</span><span class="s3">} </span><span class="s5">has the unit samples. Hence &quot; </span><span class="s4">+</span>
                             <span class="s5">&quot;it needs to be an int or it may be None!&quot;</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s4">(-</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft </span><span class="s4">&lt; </span><span class="s1">v </span><span class="s4">&lt; </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;-mfft &lt; phase_shift &lt; mfft does not hold &quot; </span><span class="s4">+</span>
                             <span class="s5">f&quot;for mfft=</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft</span><span class="s3">}</span><span class="s5">, phase_shift=</span><span class="s3">{</span><span class="s1">v</span><span class="s3">}</span><span class="s5">!&quot;</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_phase_shift </span><span class="s4">= </span><span class="s1">v</span>

    <span class="s3">def </span><span class="s1">_x_slices</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">x</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">, </span><span class="s1">k_off</span><span class="s4">: </span><span class="s1">int</span><span class="s4">, </span><span class="s1">p0</span><span class="s4">: </span><span class="s1">int</span><span class="s4">, </span><span class="s1">p1</span><span class="s4">: </span><span class="s1">int</span><span class="s4">,</span>
                  <span class="s1">padding</span><span class="s4">: </span><span class="s1">PAD_TYPE</span><span class="s4">) </span><span class="s1">-&gt; Generator</span><span class="s4">[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">]:</span>
        <span class="s0">&quot;&quot;&quot;Generate signal slices along last axis of `x`. 
 
        This method is only used by `stft_detrend`. The parameters are 
        described in `~ShortTimeFFT.stft`. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">padding </span><span class="s3">not in </span><span class="s4">(</span><span class="s1">padding_types </span><span class="s4">:= </span><span class="s1">get_args</span><span class="s4">(</span><span class="s1">PAD_TYPE</span><span class="s4">)):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;Parameter </span><span class="s3">{</span><span class="s1">padding</span><span class="s4">=</span><span class="s3">} </span><span class="s5">not in </span><span class="s3">{</span><span class="s1">padding_types</span><span class="s3">}</span><span class="s5">!&quot;</span><span class="s4">)</span>
        <span class="s1">pad_kws</span><span class="s4">: </span><span class="s1">dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">dict</span><span class="s4">] = {  </span><span class="s2"># possible keywords to pass to np.pad:</span>
            <span class="s5">'zeros'</span><span class="s4">: </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">mode</span><span class="s4">=</span><span class="s5">'constant'</span><span class="s4">, </span><span class="s1">constant_values</span><span class="s4">=(</span><span class="s6">0</span><span class="s4">, </span><span class="s6">0</span><span class="s4">)),</span>
            <span class="s5">'edge'</span><span class="s4">: </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">mode</span><span class="s4">=</span><span class="s5">'edge'</span><span class="s4">),</span>
            <span class="s5">'even'</span><span class="s4">: </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">mode</span><span class="s4">=</span><span class="s5">'reflect'</span><span class="s4">, </span><span class="s1">reflect_type</span><span class="s4">=</span><span class="s5">'even'</span><span class="s4">),</span>
            <span class="s5">'odd'</span><span class="s4">: </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">mode</span><span class="s4">=</span><span class="s5">'reflect'</span><span class="s4">, </span><span class="s1">reflect_type</span><span class="s4">=</span><span class="s5">'odd'</span><span class="s4">),</span>
           <span class="s4">}  </span><span class="s2"># typing of pad_kws is needed to make mypy happy</span>

        <span class="s1">n</span><span class="s4">, </span><span class="s1">n1 </span><span class="s4">= </span><span class="s1">x</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">], (</span><span class="s1">p1 </span><span class="s4">- </span><span class="s1">p0</span><span class="s4">) * </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop</span>
        <span class="s1">k0 </span><span class="s4">= </span><span class="s1">p0 </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num_mid </span><span class="s4">+ </span><span class="s1">k_off  </span><span class="s2"># start sample</span>
        <span class="s1">k1 </span><span class="s4">= </span><span class="s1">k0 </span><span class="s4">+ </span><span class="s1">n1 </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num  </span><span class="s2"># end sample</span>

        <span class="s1">i0</span><span class="s4">, </span><span class="s1">i1 </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s1">k0</span><span class="s4">, </span><span class="s6">0</span><span class="s4">), </span><span class="s1">min</span><span class="s4">(</span><span class="s1">k1</span><span class="s4">, </span><span class="s1">n</span><span class="s4">)  </span><span class="s2"># indexes to shorten x</span>
        <span class="s2"># dimensions for padding x:</span>
        <span class="s1">pad_width </span><span class="s4">= [(</span><span class="s6">0</span><span class="s4">, </span><span class="s6">0</span><span class="s4">)] * (</span><span class="s1">x</span><span class="s4">.</span><span class="s1">ndim</span><span class="s4">-</span><span class="s6">1</span><span class="s4">) + [(-</span><span class="s1">min</span><span class="s4">(</span><span class="s1">k0</span><span class="s4">, </span><span class="s6">0</span><span class="s4">), </span><span class="s1">max</span><span class="s4">(</span><span class="s1">k1 </span><span class="s4">- </span><span class="s1">n</span><span class="s4">, </span><span class="s6">0</span><span class="s4">))]</span>

        <span class="s1">x1 </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">pad</span><span class="s4">(</span><span class="s1">x</span><span class="s4">[..., </span><span class="s1">i0</span><span class="s4">:</span><span class="s1">i1</span><span class="s4">], </span><span class="s1">pad_width</span><span class="s4">, **</span><span class="s1">pad_kws</span><span class="s4">[</span><span class="s1">padding</span><span class="s4">])</span>
        <span class="s3">for </span><span class="s1">k_ </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">n1</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop</span><span class="s4">):</span>
            <span class="s3">yield </span><span class="s1">x1</span><span class="s4">[..., </span><span class="s1">k_</span><span class="s4">:</span><span class="s1">k_ </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">stft</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">x</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">, </span><span class="s1">p0</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
             <span class="s1">p1</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">, *, </span><span class="s1">k_offset</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= </span><span class="s6">0</span><span class="s4">,</span>
             <span class="s1">padding</span><span class="s4">: </span><span class="s1">PAD_TYPE </span><span class="s4">= </span><span class="s5">'zeros'</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= -</span><span class="s6">1</span><span class="s4">) </span><span class="s1">\</span>
            <span class="s1">-&gt; np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Perform the short-time Fourier transform. 
 
        A two-dimensional matrix with ``p1-p0`` columns is calculated. 
        The `f_pts` rows represent value at the frequencies `f`. The q-th 
        column of the windowed FFT with the window `win` is centered at t[q]. 
        The columns represent the values at the frequencies `f`. 
 
        Parameters 
        ---------- 
        x 
            The input signal as real or complex valued array. For complex values, the 
            property `fft_mode` must be set to 'twosided' or 'centered'. 
        p0 
            The first element of the range of slices to calculate. If ``None`` 
            then it is set to :attr:`p_min`, which is the smallest possible 
            slice. 
        p1 
            The end of the array. If ``None`` then `p_max(n)` is used. 
        k_offset 
            Index of first sample (t = 0) in `x`. 
        padding 
            Kind of values which are added, when the sliding window sticks out 
            on either the lower or upper end of the input `x`. Zeros are added 
            if the default 'zeros' is set. For 'edge' either the first or the 
            last value of `x` is used. 'even' pads by reflecting the 
            signal on the first or last sample and 'odd' additionally 
            multiplies it with -1. 
        axis 
            The axis of `x` over which to compute the STFT. 
            If not given, the last axis is used. 
 
        Returns 
        ------- 
        S 
            A complex array is returned with the dimension always being larger 
            by one than of `x`. The last axis always represent the time slices 
            of the STFT. `axis` defines the frequency axis (default second to 
            last). E.g., for a one-dimensional `x`, a complex 2d array is 
            returned, with axis 0 representing frequency and axis 1 the time 
            slices. 
 
        See Also 
        -------- 
        delta_f: Width of the frequency bins of the STFT. 
        delta_t: Time increment of STFT 
        f: Frequencies values of the STFT. 
        invertible: Check if STFT is invertible. 
        :meth:`~ShortTimeFFT.istft`: Inverse short-time Fourier transform. 
        p_range: Determine and validate slice index range. 
        stft_detrend: STFT with detrended segments. 
        t: Times of STFT for an input signal with `n` samples. 
        :class:`scipy.signal.ShortTimeFFT`: Class this method belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stft_detrend</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">p0</span><span class="s4">, </span><span class="s1">p1</span><span class="s4">, </span><span class="s1">k_offset</span><span class="s4">=</span><span class="s1">k_offset</span><span class="s4">,</span>
                                 <span class="s1">padding</span><span class="s4">=</span><span class="s1">padding</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s1">axis</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">stft_detrend</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">x</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">,</span>
                     <span class="s1">detr</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">], </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">] | </span><span class="s1">Literal</span><span class="s4">[</span><span class="s5">'linear'</span><span class="s4">, </span><span class="s5">'constant'</span><span class="s4">] | </span><span class="s3">None</span><span class="s4">,  </span><span class="s2"># noqa: E501</span>
                     <span class="s1">p0</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">, </span><span class="s1">p1</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">, *,</span>
                     <span class="s1">k_offset</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= </span><span class="s6">0</span><span class="s4">, </span><span class="s1">padding</span><span class="s4">: </span><span class="s1">PAD_TYPE </span><span class="s4">= </span><span class="s5">'zeros'</span><span class="s4">,</span>
                     <span class="s1">axis</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= -</span><span class="s6">1</span><span class="s4">) </span><span class="s1">\</span>
            <span class="s1">-&gt; np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Short-time Fourier transform with a trend being subtracted from each 
        segment beforehand. 
 
        If `detr` is set to 'constant', the mean is subtracted, if set to 
        &quot;linear&quot;, the linear trend is removed. This is achieved by calling 
        :func:`scipy.signal.detrend`. If `detr` is a function, `detr` is 
        applied to each segment. 
        All other parameters have the same meaning as in `~ShortTimeFFT.stft`. 
 
        Note that due to the detrending, the original signal cannot be 
        reconstructed by the `~ShortTimeFFT.istft`. 
 
        See Also 
        -------- 
        invertible: Check if STFT is invertible. 
        :meth:`~ShortTimeFFT.istft`: Inverse short-time Fourier transform. 
        :meth:`~ShortTimeFFT.stft`: Short-time Fourier transform 
                                   (without detrending). 
        :class:`scipy.signal.ShortTimeFFT`: Class this method belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">onesided_fft </span><span class="s3">and </span><span class="s1">np</span><span class="s4">.</span><span class="s1">iscomplexobj</span><span class="s4">(</span><span class="s1">x</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;Complex-valued `x` not allowed for </span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode</span><span class="s4">=</span><span class="s3">}</span><span class="s5">'! &quot;</span>
                             <span class="s5">&quot;Set property `fft_mode` to 'twosided' or 'centered'.&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">detr</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
            <span class="s1">detr </span><span class="s4">= </span><span class="s1">partial</span><span class="s4">(</span><span class="s1">detrend</span><span class="s4">, </span><span class="s1">type</span><span class="s4">=</span><span class="s1">detr</span><span class="s4">)</span>
        <span class="s3">elif not </span><span class="s4">(</span><span class="s1">detr </span><span class="s3">is None or </span><span class="s1">callable</span><span class="s4">(</span><span class="s1">detr</span><span class="s4">)):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;Parameter </span><span class="s3">{</span><span class="s1">detr</span><span class="s4">=</span><span class="s3">} </span><span class="s5">is not a str, function or &quot; </span><span class="s4">+</span>
                             <span class="s5">&quot;None!&quot;</span><span class="s4">)</span>
        <span class="s1">n </span><span class="s4">= </span><span class="s1">x</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s1">axis</span><span class="s4">]</span>
        <span class="s3">if not </span><span class="s4">(</span><span class="s1">n </span><span class="s4">&gt;= (</span><span class="s1">m2p </span><span class="s4">:= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num</span><span class="s4">-</span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num_mid</span><span class="s4">)):</span>
            <span class="s1">e_str </span><span class="s4">= </span><span class="s5">f'</span><span class="s3">{</span><span class="s1">len</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)=</span><span class="s3">}</span><span class="s5">' </span><span class="s3">if </span><span class="s1">x</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">== </span><span class="s6">1 </span><span class="s3">else </span><span class="s5">f'of </span><span class="s3">{</span><span class="s1">axis</span><span class="s4">=</span><span class="s3">} </span><span class="s5">of </span><span class="s3">{</span><span class="s1">x</span><span class="s4">.</span><span class="s1">shape</span><span class="s3">}</span><span class="s5">'</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">e_str</span><span class="s3">} </span><span class="s5">must be &gt;= ceil(m_num/2) = </span><span class="s3">{</span><span class="s1">m2p</span><span class="s3">}</span><span class="s5">!&quot;</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">x</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">&gt; </span><span class="s6">1</span><span class="s4">:  </span><span class="s2"># motivated by the NumPy broadcasting mechanisms:</span>
            <span class="s1">x </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">moveaxis</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s2"># determine slice index range:</span>
        <span class="s1">p0</span><span class="s4">, </span><span class="s1">p1 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">p_range</span><span class="s4">(</span><span class="s1">n</span><span class="s4">, </span><span class="s1">p0</span><span class="s4">, </span><span class="s1">p1</span><span class="s4">)</span>
        <span class="s1">S_shape_1d </span><span class="s4">= (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">f_pts</span><span class="s4">, </span><span class="s1">p1 </span><span class="s4">- </span><span class="s1">p0</span><span class="s4">)</span>
        <span class="s1">S_shape </span><span class="s4">= </span><span class="s1">x</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[:-</span><span class="s6">1</span><span class="s4">] + </span><span class="s1">S_shape_1d </span><span class="s3">if </span><span class="s1">x</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">&gt; </span><span class="s6">1 </span><span class="s3">else </span><span class="s1">S_shape_1d</span>
        <span class="s1">S </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">S_shape</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">complex</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">p_</span><span class="s4">, </span><span class="s1">x_ </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_x_slices</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">k_offset</span><span class="s4">, </span><span class="s1">p0</span><span class="s4">, </span><span class="s1">p1</span><span class="s4">, </span><span class="s1">padding</span><span class="s4">)):</span>
            <span class="s3">if </span><span class="s1">detr </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">x_ </span><span class="s4">= </span><span class="s1">detr</span><span class="s4">(</span><span class="s1">x_</span><span class="s4">)</span>
            <span class="s1">S</span><span class="s4">[..., :, </span><span class="s1">p_</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fft_func</span><span class="s4">(</span><span class="s1">x_ </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">win</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">())</span>
        <span class="s3">if </span><span class="s1">x</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">&gt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">moveaxis</span><span class="s4">(</span><span class="s1">S</span><span class="s4">, -</span><span class="s6">2</span><span class="s4">, </span><span class="s1">axis </span><span class="s3">if </span><span class="s1">axis </span><span class="s4">&gt;= </span><span class="s6">0 </span><span class="s3">else </span><span class="s1">axis</span><span class="s4">-</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">S</span>

    <span class="s3">def </span><span class="s1">spectrogram</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">x</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">, </span><span class="s1">y</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
                    <span class="s1">detr</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">], </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">] | </span><span class="s1">Literal</span><span class="s4">[</span><span class="s5">'linear'</span><span class="s4">, </span><span class="s5">'constant'</span><span class="s4">] | </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,  </span><span class="s2"># noqa: E501</span>
                    <span class="s4">*,</span>
                    <span class="s1">p0</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">, </span><span class="s1">p1</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
                    <span class="s1">k_offset</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= </span><span class="s6">0</span><span class="s4">, </span><span class="s1">padding</span><span class="s4">: </span><span class="s1">PAD_TYPE </span><span class="s4">= </span><span class="s5">'zeros'</span><span class="s4">,</span>
                    <span class="s1">axis</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= -</span><span class="s6">1</span><span class="s4">) </span><span class="s1">\</span>
            <span class="s1">-&gt; np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">:</span>
        <span class="s0">r&quot;&quot;&quot;Calculate spectrogram or cross-spectrogram. 
 
        The spectrogram is the absolute square of the STFT, i.e, it is 
        ``abs(S[q,p])**2`` for given ``S[q,p]``  and thus is always 
        non-negative. 
        For two STFTs ``Sx[q,p], Sy[q,p]``, the cross-spectrogram is defined 
        as ``Sx[q,p] * np.conj(Sx[q,p])`` and is complex-valued. 
        This is a convenience function for calling `~ShortTimeFFT.stft` / 
        `stft_detrend`, hence all parameters are discussed there. If `y` is not 
        ``None`` it needs to have the same shape as `x`. 
 
        Examples 
        -------- 
        The following example shows the spectrogram of a square wave with 
        varying frequency :math:`f_i(t)` (marked by a green dashed line in the 
        plot) sampled with 20 Hz: 
 
        &gt;&gt;&gt; import matplotlib.pyplot as plt 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; from scipy.signal import square, ShortTimeFFT 
        &gt;&gt;&gt; from scipy.signal.windows import gaussian 
        ... 
        &gt;&gt;&gt; T_x, N = 1 / 20, 1000  # 20 Hz sampling rate for 50 s signal 
        &gt;&gt;&gt; t_x = np.arange(N) * T_x  # time indexes for signal 
        &gt;&gt;&gt; f_i = 5e-3*(t_x - t_x[N // 3])**2 + 1  # varying frequency 
        &gt;&gt;&gt; x = square(2*np.pi*np.cumsum(f_i)*T_x)  # the signal 
 
        The utitlized Gaussian window is 50 samples or 2.5 s long. The 
        parameter ``mfft=800`` (oversampling factor 16) and the `hop` interval 
        of 2 in `ShortTimeFFT` was chosen to produce a sufficient number of 
        points: 
 
        &gt;&gt;&gt; g_std = 12  # standard deviation for Gaussian window in samples 
        &gt;&gt;&gt; win = gaussian(50, std=g_std, sym=True)  # symmetric Gaussian wind. 
        &gt;&gt;&gt; SFT = ShortTimeFFT(win, hop=2, fs=1/T_x, mfft=800, scale_to='psd') 
        &gt;&gt;&gt; Sx2 = SFT.spectrogram(x)  # calculate absolute square of STFT 
 
        The plot's colormap is logarithmically scaled as the power spectral 
        density is in dB. The time extent of the signal `x` is marked by 
        vertical dashed lines and the shaded areas mark the presence of border 
        effects: 
 
        &gt;&gt;&gt; fig1, ax1 = plt.subplots(figsize=(6., 4.))  # enlarge plot a bit 
        &gt;&gt;&gt; t_lo, t_hi = SFT.extent(N)[:2]  # time range of plot 
        &gt;&gt;&gt; ax1.set_title(rf&quot;Spectrogram ({SFT.m_num*SFT.T:g}$\,s$ Gaussian &quot; + 
        ...               rf&quot;window, $\sigma_t={g_std*SFT.T:g}\,$s)&quot;) 
        &gt;&gt;&gt; ax1.set(xlabel=f&quot;Time $t$ in seconds ({SFT.p_num(N)} slices, &quot; + 
        ...                rf&quot;$\Delta t = {SFT.delta_t:g}\,$s)&quot;, 
        ...         ylabel=f&quot;Freq. $f$ in Hz ({SFT.f_pts} bins, &quot; + 
        ...                rf&quot;$\Delta f = {SFT.delta_f:g}\,$Hz)&quot;, 
        ...         xlim=(t_lo, t_hi)) 
        &gt;&gt;&gt; Sx_dB = 10 * np.log10(np.fmax(Sx2, 1e-4))  # limit range to -40 dB 
        &gt;&gt;&gt; im1 = ax1.imshow(Sx_dB, origin='lower', aspect='auto', 
        ...                  extent=SFT.extent(N), cmap='magma') 
        &gt;&gt;&gt; ax1.plot(t_x, f_i, 'g--', alpha=.5, label='$f_i(t)$') 
        &gt;&gt;&gt; fig1.colorbar(im1, label='Power Spectral Density ' + 
        ...                          r&quot;$20\,\log_{10}|S_x(t, f)|$ in dB&quot;) 
        ... 
        &gt;&gt;&gt; # Shade areas where window slices stick out to the side: 
        &gt;&gt;&gt; for t0_, t1_ in [(t_lo, SFT.lower_border_end[0] * SFT.T), 
        ...                  (SFT.upper_border_begin(N)[0] * SFT.T, t_hi)]: 
        ...     ax1.axvspan(t0_, t1_, color='w', linewidth=0, alpha=.3) 
        &gt;&gt;&gt; for t_ in [0, N * SFT.T]:  # mark signal borders with vertical line 
        ...     ax1.axvline(t_, color='c', linestyle='--', alpha=0.5) 
        &gt;&gt;&gt; ax1.legend() 
        &gt;&gt;&gt; fig1.tight_layout() 
        &gt;&gt;&gt; plt.show() 
 
        The logarithmic scaling reveals the odd harmonics of the square wave, 
        which are reflected at the Nyquist frequency of 10 Hz. This aliasing 
        is also the main source of the noise artifacts in the plot. 
 
 
        See Also 
        -------- 
        :meth:`~ShortTimeFFT.stft`: Perform the short-time Fourier transform. 
        stft_detrend: STFT with a trend subtracted from each segment. 
        :class:`scipy.signal.ShortTimeFFT`: Class this method belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s1">Sx </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stft_detrend</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">detr</span><span class="s4">, </span><span class="s1">p0</span><span class="s4">, </span><span class="s1">p1</span><span class="s4">, </span><span class="s1">k_offset</span><span class="s4">=</span><span class="s1">k_offset</span><span class="s4">,</span>
                               <span class="s1">padding</span><span class="s4">=</span><span class="s1">padding</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s1">axis</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">y </span><span class="s3">is None or </span><span class="s1">y </span><span class="s3">is </span><span class="s1">x</span><span class="s4">:  </span><span class="s2"># do spectrogram:</span>
            <span class="s3">return </span><span class="s1">Sx</span><span class="s4">.</span><span class="s1">real</span><span class="s4">**</span><span class="s6">2 </span><span class="s4">+ </span><span class="s1">Sx</span><span class="s4">.</span><span class="s1">imag</span><span class="s4">**</span><span class="s6">2</span>
        <span class="s2"># Cross-spectrogram:</span>
        <span class="s1">Sy </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stft_detrend</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">detr</span><span class="s4">, </span><span class="s1">p0</span><span class="s4">, </span><span class="s1">p1</span><span class="s4">, </span><span class="s1">k_offset</span><span class="s4">=</span><span class="s1">k_offset</span><span class="s4">,</span>
                               <span class="s1">padding</span><span class="s4">=</span><span class="s1">padding</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s1">axis</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">Sx </span><span class="s4">* </span><span class="s1">Sy</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">dual_win</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Canonical dual window. 
 
        A STFT can be interpreted as the input signal being expressed as a 
        weighted sum of modulated and time-shifted dual windows. Note that for 
        a given window there exist many dual windows. The canonical window is 
        the one with the minimal energy (i.e., :math:`L_2` norm). 
 
        `dual_win` has same length as `win`, namely `m_num` samples. 
 
        If the dual window cannot be calculated a ``ValueError`` is raised. 
        This attribute is read only and calculated lazily. 
 
        See Also 
        -------- 
        dual_win: Canonical dual window. 
        m_num: Number of samples in window `win`. 
        win: Window function as real- or complex-valued 1d array. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dual_win </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_dual_win </span><span class="s4">= </span><span class="s1">_calc_dual_canonical_window</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">win</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dual_win</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">invertible</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Check if STFT is invertible. 
 
        This is achieved by trying to calculate the canonical dual window. 
 
        See Also 
        -------- 
        :meth:`~ShortTimeFFT.istft`: Inverse short-time Fourier transform. 
        m_num: Number of samples in window `win` and `dual_win`. 
        dual_win: Canonical dual window. 
        win: Window for STFT. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">dual_win</span><span class="s4">) &gt; </span><span class="s6">0  </span><span class="s2"># call self.dual_win()</span>
        <span class="s3">except </span><span class="s1">ValueError</span><span class="s4">:</span>
            <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">istft</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">S</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">, </span><span class="s1">k0</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= </span><span class="s6">0</span><span class="s4">, </span><span class="s1">k1</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">, *,</span>
              <span class="s1">f_axis</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= -</span><span class="s6">2</span><span class="s4">, </span><span class="s1">t_axis</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= -</span><span class="s6">1</span><span class="s4">) </span><span class="s1">\</span>
            <span class="s1">-&gt; np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Inverse short-time Fourier transform. 
 
        It returns an array of dimension ``S.ndim - 1``  which is real 
        if `onesided_fft` is set, else complex. If the STFT is not 
        `invertible`, or the parameters are out of bounds  a ``ValueError`` is 
        raised. 
 
        Parameters 
        ---------- 
        S 
            A complex valued array where `f_axis` denotes the frequency 
            values and the `t-axis` dimension the temporal values of the 
            STFT values. 
        k0, k1 
            The start and the end index of the reconstructed signal. The 
            default (``k0 = 0``, ``k1 = None``) assumes that the maximum length 
            signal should be reconstructed. 
        f_axis, t_axis 
            The axes in `S` denoting the frequency and the time dimension. 
 
        Notes 
        ----- 
        It is required that `S` has `f_pts` entries along the `f_axis`. For 
        the `t_axis` it is assumed that the first entry corresponds to 
        `p_min` * `delta_t` (being &lt;= 0). The length of `t_axis` needs to be 
        compatible with `k1`. I.e., ``S.shape[t_axis] &gt;= self.p_max(k1)`` must 
        hold, if `k1` is not ``None``. Else `k1` is set to `k_max` with:: 
 
            q_max = S.shape[t_range] + self.p_min 
            k_max = (q_max - 1) * self.hop + self.m_num - self.m_num_mid 
 
        The :ref:`tutorial_stft` section of the :ref:`user_guide` discussed the 
        slicing behavior by means of an example. 
 
        See Also 
        -------- 
        invertible: Check if STFT is invertible. 
        :meth:`~ShortTimeFFT.stft`: Perform Short-time Fourier transform. 
        :class:`scipy.signal.ShortTimeFFT`: Class this method belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">f_axis </span><span class="s4">== </span><span class="s1">t_axis</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">f_axis</span><span class="s4">=</span><span class="s3">} </span><span class="s5">may not be equal to </span><span class="s3">{</span><span class="s1">t_axis</span><span class="s4">=</span><span class="s3">}</span><span class="s5">!&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">S</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s1">f_axis</span><span class="s4">] != </span><span class="s1">self</span><span class="s4">.</span><span class="s1">f_pts</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">S</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s1">f_axis</span><span class="s4">]=</span><span class="s3">} </span><span class="s5">must be equal to &quot; </span><span class="s4">+</span>
                             <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">f_pts</span><span class="s4">=</span><span class="s3">} </span><span class="s5">(</span><span class="s3">{</span><span class="s1">S</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">=</span><span class="s3">}</span><span class="s5">)!&quot;</span><span class="s4">)</span>
        <span class="s1">n_min </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num</span><span class="s4">-</span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num_mid  </span><span class="s2"># minimum signal length</span>
        <span class="s3">if not </span><span class="s4">(</span><span class="s1">S</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s1">t_axis</span><span class="s4">] &gt;= (</span><span class="s1">q_num </span><span class="s4">:= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">p_num</span><span class="s4">(</span><span class="s1">n_min</span><span class="s4">))):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">S</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s1">t_axis</span><span class="s4">]=</span><span class="s3">} </span><span class="s5">needs to have at least &quot; </span><span class="s4">+</span>
                             <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">q_num</span><span class="s3">} </span><span class="s5">slices (</span><span class="s3">{</span><span class="s1">S</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">=</span><span class="s3">}</span><span class="s5">)!&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">t_axis </span><span class="s4">!= </span><span class="s1">S</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">- </span><span class="s6">1 </span><span class="s3">or </span><span class="s1">f_axis </span><span class="s4">!= </span><span class="s1">S</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">- </span><span class="s6">2</span><span class="s4">:</span>
            <span class="s1">t_axis </span><span class="s4">= </span><span class="s1">S</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">+ </span><span class="s1">t_axis </span><span class="s3">if </span><span class="s1">t_axis </span><span class="s4">&lt; </span><span class="s6">0 </span><span class="s3">else </span><span class="s1">t_axis</span>
            <span class="s1">f_axis </span><span class="s4">= </span><span class="s1">S</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">+ </span><span class="s1">f_axis </span><span class="s3">if </span><span class="s1">f_axis </span><span class="s4">&lt; </span><span class="s6">0 </span><span class="s3">else </span><span class="s1">f_axis</span>
            <span class="s1">S </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">moveaxis</span><span class="s4">(</span><span class="s1">S</span><span class="s4">, (</span><span class="s1">f_axis</span><span class="s4">, </span><span class="s1">t_axis</span><span class="s4">), (-</span><span class="s6">2</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">))</span>

        <span class="s1">q_max </span><span class="s4">= </span><span class="s1">S</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">] + </span><span class="s1">self</span><span class="s4">.</span><span class="s1">p_min</span>
        <span class="s1">k_max </span><span class="s4">= (</span><span class="s1">q_max </span><span class="s4">- </span><span class="s6">1</span><span class="s4">) * </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num_mid</span>

        <span class="s1">k1 </span><span class="s4">= </span><span class="s1">k_max </span><span class="s3">if </span><span class="s1">k1 </span><span class="s3">is None else </span><span class="s1">k1</span>
        <span class="s3">if not </span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">k_min </span><span class="s4">&lt;= </span><span class="s1">k0 </span><span class="s4">&lt; </span><span class="s1">k1 </span><span class="s4">&lt;= </span><span class="s1">k_max</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;(</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">k_min</span><span class="s4">=</span><span class="s3">}</span><span class="s5">) &lt;= (</span><span class="s3">{</span><span class="s1">k0</span><span class="s4">=</span><span class="s3">}</span><span class="s5">) &lt; (</span><span class="s3">{</span><span class="s1">k1</span><span class="s4">=</span><span class="s3">}</span><span class="s5">) &lt;= &quot; </span><span class="s4">+</span>
                             <span class="s5">f&quot;(</span><span class="s3">{</span><span class="s1">k_max</span><span class="s4">=</span><span class="s3">}</span><span class="s5">) is false!&quot;</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s4">(</span><span class="s1">num_pts </span><span class="s4">:= </span><span class="s1">k1 </span><span class="s4">- </span><span class="s1">k0</span><span class="s4">) &gt;= </span><span class="s1">n_min</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;(</span><span class="s3">{</span><span class="s1">k1</span><span class="s4">=</span><span class="s3">}</span><span class="s5">) - (</span><span class="s3">{</span><span class="s1">k0</span><span class="s4">=</span><span class="s3">}</span><span class="s5">) = </span><span class="s3">{</span><span class="s1">num_pts</span><span class="s3">} </span><span class="s5">has to be at &quot; </span><span class="s4">+</span>
                             <span class="s5">f&quot;least the half the window length </span><span class="s3">{</span><span class="s1">n_min</span><span class="s3">}</span><span class="s5">!&quot;</span><span class="s4">)</span>

        <span class="s1">q0 </span><span class="s4">= (</span><span class="s1">k0 </span><span class="s4">// </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">p_min </span><span class="s3">if </span><span class="s1">k0 </span><span class="s4">&gt;= </span><span class="s6">0 </span><span class="s3">else  </span><span class="s2"># p_min always &lt;= 0</span>
              <span class="s1">k0 </span><span class="s4">// </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop</span><span class="s4">)</span>
        <span class="s1">q1 </span><span class="s4">= </span><span class="s1">min</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">p_max</span><span class="s4">(</span><span class="s1">k1</span><span class="s4">), </span><span class="s1">q_max</span><span class="s4">)</span>
        <span class="s1">k_q0</span><span class="s4">, </span><span class="s1">k_q1 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nearest_k_p</span><span class="s4">(</span><span class="s1">k0</span><span class="s4">), </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nearest_k_p</span><span class="s4">(</span><span class="s1">k1</span><span class="s4">, </span><span class="s1">left</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
        <span class="s1">n_pts </span><span class="s4">= </span><span class="s1">k_q1 </span><span class="s4">- </span><span class="s1">k_q0 </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num_mid</span>
        <span class="s1">x </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">S</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[:-</span><span class="s6">2</span><span class="s4">] + (</span><span class="s1">n_pts</span><span class="s4">,),</span>
                     <span class="s1">dtype</span><span class="s4">=</span><span class="s1">float </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">onesided_fft </span><span class="s3">else </span><span class="s1">complex</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">q_ </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">q0</span><span class="s4">, </span><span class="s1">q1</span><span class="s4">):</span>
            <span class="s1">xs </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_ifft_func</span><span class="s4">(</span><span class="s1">S</span><span class="s4">[..., :, </span><span class="s1">q_ </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">p_min</span><span class="s4">]) * </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dual_win</span>
            <span class="s1">i0 </span><span class="s4">= </span><span class="s1">q_ </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num_mid</span>
            <span class="s1">i1 </span><span class="s4">= </span><span class="s1">min</span><span class="s4">(</span><span class="s1">i0 </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num</span><span class="s4">, </span><span class="s1">n_pts</span><span class="s4">+</span><span class="s1">k0</span><span class="s4">)</span>
            <span class="s1">j0</span><span class="s4">, </span><span class="s1">j1 </span><span class="s4">= </span><span class="s6">0</span><span class="s4">, </span><span class="s1">i1 </span><span class="s4">- </span><span class="s1">i0</span>
            <span class="s3">if </span><span class="s1">i0 </span><span class="s4">&lt; </span><span class="s1">k0</span><span class="s4">:  </span><span class="s2"># xs sticks out to the left on x:</span>
                <span class="s1">j0 </span><span class="s4">+= </span><span class="s1">k0 </span><span class="s4">- </span><span class="s1">i0</span>
                <span class="s1">i0 </span><span class="s4">= </span><span class="s1">k0</span>
            <span class="s1">x</span><span class="s4">[..., </span><span class="s1">i0</span><span class="s4">-</span><span class="s1">k0</span><span class="s4">:</span><span class="s1">i1</span><span class="s4">-</span><span class="s1">k0</span><span class="s4">] += </span><span class="s1">xs</span><span class="s4">[..., </span><span class="s1">j0</span><span class="s4">:</span><span class="s1">j1</span><span class="s4">]</span>
        <span class="s1">x </span><span class="s4">= </span><span class="s1">x</span><span class="s4">[..., :</span><span class="s1">k1</span><span class="s4">-</span><span class="s1">k0</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">x</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">&gt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s1">x </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">moveaxis</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">, </span><span class="s1">f_axis </span><span class="s3">if </span><span class="s1">f_axis </span><span class="s4">&lt; </span><span class="s1">x</span><span class="s4">.</span><span class="s1">ndim </span><span class="s3">else </span><span class="s1">t_axis</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">x</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">fac_magnitude</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; float</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Factor to multiply the STFT values by to scale each frequency slice 
        to a magnitude spectrum. 
 
        It is 1 if attribute ``scaling == 'magnitude'``. 
        The window can be scaled to a magnitude spectrum by using the method 
        `scale_to`. 
 
        See Also 
        -------- 
        fac_psd: Scaling factor for to a power spectral density spectrum. 
        scale_to: Scale window to obtain 'magnitude' or 'psd' scaling. 
        scaling: Normalization applied to the window function. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">scaling </span><span class="s4">== </span><span class="s5">'magnitude'</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s6">1</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fac_mag </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_fac_mag </span><span class="s4">= </span><span class="s6">1 </span><span class="s4">/ </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">win</span><span class="s4">))</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fac_mag</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">fac_psd</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; float</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Factor to multiply the STFT values by to scale each frequency slice 
        to a power spectral density (PSD). 
 
        It is 1 if attribute ``scaling == 'psd'``. 
        The window can be scaled to a psd spectrum by using the method 
        `scale_to`. 
 
        See Also 
        -------- 
        fac_magnitude: Scaling factor for to a magnitude spectrum. 
        scale_to: Scale window to obtain 'magnitude' or 'psd' scaling. 
        scaling: Normalization applied to the window function. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">scaling </span><span class="s4">== </span><span class="s5">'psd'</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s6">1</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fac_psd </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_fac_psd </span><span class="s4">= </span><span class="s6">1 </span><span class="s4">/ </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span>
                <span class="s1">sum</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">win</span><span class="s4">.</span><span class="s1">real</span><span class="s4">**</span><span class="s6">2</span><span class="s4">+</span><span class="s1">self</span><span class="s4">.</span><span class="s1">win</span><span class="s4">.</span><span class="s1">imag</span><span class="s4">**</span><span class="s6">2</span><span class="s4">) / </span><span class="s1">self</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fac_psd</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">m_num</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Number of samples in window `win`. 
 
        Note that the FFT can be oversampled by zero-padding. This is achieved 
        by setting the `mfft` property. 
 
        See Also 
        -------- 
        m_num_mid: Center index of window `win`. 
        mfft: Length of input for the FFT used - may be larger than `m_num`. 
        hop: Time increment in signal samples for sliding window. 
        win: Window function as real- or complex-valued 1d array. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">win</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">m_num_mid</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Center index of window `win`. 
 
        For odd `m_num`, ``(m_num - 1) / 2`` is returned and 
        for even `m_num` (per definition) ``m_num / 2`` is returned. 
 
        See Also 
        -------- 
        m_num: Number of samples in window `win`. 
        mfft: Length of input for the FFT used - may be larger than `m_num`. 
        hop: ime increment in signal samples for sliding window. 
        win: Window function as real- or complex-valued 1d array. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num </span><span class="s4">// </span><span class="s6">2</span>

    <span class="s4">@</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">_pre_padding</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; tuple</span><span class="s4">[</span><span class="s1">int</span><span class="s4">, </span><span class="s1">int</span><span class="s4">]:</span>
        <span class="s0">&quot;&quot;&quot;Smallest signal index and slice index due to padding. 
 
         Since, per convention, for time t=0, n,q is zero, the returned values 
         are negative or zero. 
         &quot;&quot;&quot;</span>
        <span class="s1">w2 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">win</span><span class="s4">.</span><span class="s1">real</span><span class="s4">**</span><span class="s6">2 </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">win</span><span class="s4">.</span><span class="s1">imag</span><span class="s4">**</span><span class="s6">2</span>
        <span class="s2"># move window to the left until the overlap with t &gt;= 0 vanishes:</span>
        <span class="s1">n0 </span><span class="s4">= -</span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num_mid</span>
        <span class="s3">for </span><span class="s1">q_</span><span class="s4">, </span><span class="s1">n_ </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">range</span><span class="s4">(</span><span class="s1">n0</span><span class="s4">, </span><span class="s1">n0</span><span class="s4">-</span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num</span><span class="s4">-</span><span class="s6">1</span><span class="s4">, -</span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop</span><span class="s4">)):</span>
            <span class="s1">n_next </span><span class="s4">= </span><span class="s1">n_ </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop</span>
            <span class="s3">if </span><span class="s1">n_next </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num </span><span class="s4">&lt;= </span><span class="s6">0 </span><span class="s3">or </span><span class="s1">all</span><span class="s4">(</span><span class="s1">w2</span><span class="s4">[</span><span class="s1">n_next</span><span class="s4">:] == </span><span class="s6">0</span><span class="s4">):</span>
                <span class="s3">return </span><span class="s1">n_</span><span class="s4">, -</span><span class="s1">q_</span>
        <span class="s3">raise </span><span class="s1">RuntimeError</span><span class="s4">(</span><span class="s5">&quot;This is code line should not have been reached!&quot;</span><span class="s4">)</span>
        <span class="s2"># If this case is reached, it probably means the first slice should be</span>
        <span class="s2"># returned, i.e.: return n0, 0</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">k_min</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;The smallest possible signal index of the STFT. 
 
        `k_min` is the index of the left-most non-zero value of the lowest 
        slice `p_min`. Since the zeroth slice is centered over the zeroth 
        sample of the input signal, `k_min` is never positive. 
        A detailed example is provided in the :ref:`tutorial_stft_sliding_win` 
        section of the :ref:`user_guide`. 
 
        See Also 
        -------- 
        k_max: First sample index after signal end not touched by a time slice. 
        lower_border_end: Where pre-padding effects end. 
        p_min: The smallest possible slice index. 
        p_max: Index of first non-overlapping upper time slice. 
        p_num: Number of time slices, i.e., `p_max` - `p_min`. 
        p_range: Determine and validate slice index range. 
        upper_border_begin: Where post-padding effects start. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pre_padding</span><span class="s4">()[</span><span class="s6">0</span><span class="s4">]</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">p_min</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;The smallest possible slice index. 
 
        `p_min` is the index of the left-most slice, where the window still 
        sticks into the signal, i.e., has non-zero part for t &gt;= 0. 
        `k_min` is the smallest index where the window function of the slice 
        `p_min` is non-zero. 
 
        Since, per convention the zeroth slice is centered at t=0, 
        `p_min` &lt;= 0 always holds. 
        A detailed example is provided in the :ref:`tutorial_stft_sliding_win` 
        section of the :ref:`user_guide`. 
 
        See Also 
        -------- 
        k_min: The smallest possible signal index. 
        k_max: First sample index after signal end not touched by a time slice. 
        p_max: Index of first non-overlapping upper time slice. 
        p_num: Number of time slices, i.e., `p_max` - `p_min`. 
        p_range: Determine and validate slice index range. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_pre_padding</span><span class="s4">()[</span><span class="s6">1</span><span class="s4">]</span>

    <span class="s4">@</span><span class="s1">lru_cache</span><span class="s4">(</span><span class="s1">maxsize</span><span class="s4">=</span><span class="s6">256</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">_post_padding</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">n</span><span class="s4">: </span><span class="s1">int</span><span class="s4">) </span><span class="s1">-&gt; tuple</span><span class="s4">[</span><span class="s1">int</span><span class="s4">, </span><span class="s1">int</span><span class="s4">]:</span>
        <span class="s0">&quot;&quot;&quot;Largest signal index and slice index due to padding.&quot;&quot;&quot;</span>
        <span class="s1">w2 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">win</span><span class="s4">.</span><span class="s1">real</span><span class="s4">**</span><span class="s6">2 </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">win</span><span class="s4">.</span><span class="s1">imag</span><span class="s4">**</span><span class="s6">2</span>
        <span class="s2"># move window to the right until the overlap for t &lt; t[n] vanishes:</span>
        <span class="s1">q1 </span><span class="s4">= </span><span class="s1">n </span><span class="s4">// </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop   </span><span class="s2"># last slice index with t[p1] &lt;= t[n]</span>
        <span class="s1">k1 </span><span class="s4">= </span><span class="s1">q1 </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num_mid</span>
        <span class="s3">for </span><span class="s1">q_</span><span class="s4">, </span><span class="s1">k_ </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">range</span><span class="s4">(</span><span class="s1">k1</span><span class="s4">, </span><span class="s1">n</span><span class="s4">+</span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop</span><span class="s4">), </span><span class="s1">start</span><span class="s4">=</span><span class="s1">q1</span><span class="s4">):</span>
            <span class="s1">n_next </span><span class="s4">= </span><span class="s1">k_ </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop</span>
            <span class="s3">if </span><span class="s1">n_next </span><span class="s4">&gt;= </span><span class="s1">n </span><span class="s3">or </span><span class="s1">all</span><span class="s4">(</span><span class="s1">w2</span><span class="s4">[:</span><span class="s1">n</span><span class="s4">-</span><span class="s1">n_next</span><span class="s4">] == </span><span class="s6">0</span><span class="s4">):</span>
                <span class="s3">return </span><span class="s1">k_ </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num</span><span class="s4">, </span><span class="s1">q_ </span><span class="s4">+ </span><span class="s6">1</span>
        <span class="s3">raise </span><span class="s1">RuntimeError</span><span class="s4">(</span><span class="s5">&quot;This is code line should not have been reached!&quot;</span><span class="s4">)</span>
        <span class="s2"># If this case is reached, it probably means the last slice should be</span>
        <span class="s2"># returned, i.e.: return k1 + self.m_num - self.m_num_mid, q1 + 1</span>

    <span class="s3">def </span><span class="s1">k_max</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">n</span><span class="s4">: </span><span class="s1">int</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;First sample index after signal end not touched by a time slice. 
 
        `k_max` - 1 is the largest sample index of the slice `p_max` for a 
        given input signal of `n` samples. 
        A detailed example is provided in the :ref:`tutorial_stft_sliding_win` 
        section of the :ref:`user_guide`. 
 
        See Also 
        -------- 
        k_min: The smallest possible signal index. 
        p_min: The smallest possible slice index. 
        p_max: Index of first non-overlapping upper time slice. 
        p_num: Number of time slices, i.e., `p_max` - `p_min`. 
        p_range: Determine and validate slice index range. 
        ShortTimeFFT: Class this method belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_post_padding</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)[</span><span class="s6">0</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">p_max</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">n</span><span class="s4">: </span><span class="s1">int</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Index of first non-overlapping upper time slice for `n` sample 
        input. 
 
        Note that center point t[p_max] = (p_max(n)-1) * `delta_t` is typically 
        larger than last time index t[n-1] == (`n`-1) * `T`. The upper border 
        of samples indexes covered by the window slices is given by `k_max`. 
        Furthermore, `p_max` does not denote the number of slices `p_num` since 
        `p_min` is typically less than zero. 
        A detailed example is provided in the :ref:`tutorial_stft_sliding_win` 
        section of the :ref:`user_guide`. 
 
        See Also 
        -------- 
        k_min: The smallest possible signal index. 
        k_max: First sample index after signal end not touched by a time slice. 
        p_min: The smallest possible slice index. 
        p_num: Number of time slices, i.e., `p_max` - `p_min`. 
        p_range: Determine and validate slice index range. 
        ShortTimeFFT: Class this method belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_post_padding</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)[</span><span class="s6">1</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">p_num</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">n</span><span class="s4">: </span><span class="s1">int</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Number of time slices for an input signal with `n` samples. 
 
        It is given by `p_num` = `p_max` - `p_min` with `p_min` typically 
        being negative. 
        A detailed example is provided in the :ref:`tutorial_stft_sliding_win` 
        section of the :ref:`user_guide`. 
 
        See Also 
        -------- 
        k_min: The smallest possible signal index. 
        k_max: First sample index after signal end not touched by a time slice. 
        lower_border_end: Where pre-padding effects end. 
        p_min: The smallest possible slice index. 
        p_max: Index of first non-overlapping upper time slice. 
        p_range: Determine and validate slice index range. 
        upper_border_begin: Where post-padding effects start. 
        ShortTimeFFT: Class this method belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">p_max</span><span class="s4">(</span><span class="s1">n</span><span class="s4">) - </span><span class="s1">self</span><span class="s4">.</span><span class="s1">p_min</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">lower_border_end</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; tuple</span><span class="s4">[</span><span class="s1">int</span><span class="s4">, </span><span class="s1">int</span><span class="s4">]:</span>
        <span class="s0">&quot;&quot;&quot;First signal index and first slice index unaffected by pre-padding. 
 
        Describes the point where the window does not stick out to the left 
        of the signal domain. 
        A detailed example is provided in the :ref:`tutorial_stft_sliding_win` 
        section of the :ref:`user_guide`. 
 
        See Also 
        -------- 
        k_min: The smallest possible signal index. 
        k_max: First sample index after signal end not touched by a time slice. 
        lower_border_end: Where pre-padding effects end. 
        p_min: The smallest possible slice index. 
        p_max: Index of first non-overlapping upper time slice. 
        p_num: Number of time slices, i.e., `p_max` - `p_min`. 
        p_range: Determine and validate slice index range. 
        upper_border_begin: Where post-padding effects start. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s2"># not using @cache decorator due to MyPy limitations</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_lower_border_end </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_lower_border_end</span>

        <span class="s2"># first non-zero element in self.win:</span>
        <span class="s1">m0 </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">flatnonzero</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">win</span><span class="s4">.</span><span class="s1">real</span><span class="s4">**</span><span class="s6">2 </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">win</span><span class="s4">.</span><span class="s1">imag</span><span class="s4">**</span><span class="s6">2</span><span class="s4">)[</span><span class="s6">0</span><span class="s4">]</span>

        <span class="s2"># move window to the right until does not stick out to the left:</span>
        <span class="s1">k0 </span><span class="s4">= -</span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num_mid </span><span class="s4">+ </span><span class="s1">m0</span>
        <span class="s3">for </span><span class="s1">q_</span><span class="s4">, </span><span class="s1">k_ </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">range</span><span class="s4">(</span><span class="s1">k0</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop</span><span class="s4">)):</span>
            <span class="s3">if </span><span class="s1">k_ </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop </span><span class="s4">&gt;= </span><span class="s6">0</span><span class="s4">:  </span><span class="s2"># next entry does not stick out anymore</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_lower_border_end </span><span class="s4">= (</span><span class="s1">k_ </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num</span><span class="s4">, </span><span class="s1">q_ </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">)</span>
                <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_lower_border_end</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_lower_border_end </span><span class="s4">= (</span><span class="s6">0</span><span class="s4">, </span><span class="s1">max</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">p_min</span><span class="s4">, </span><span class="s6">0</span><span class="s4">))  </span><span class="s2"># ends at first slice</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_lower_border_end</span>

    <span class="s4">@</span><span class="s1">lru_cache</span><span class="s4">(</span><span class="s1">maxsize</span><span class="s4">=</span><span class="s6">256</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">upper_border_begin</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">n</span><span class="s4">: </span><span class="s1">int</span><span class="s4">) </span><span class="s1">-&gt; tuple</span><span class="s4">[</span><span class="s1">int</span><span class="s4">, </span><span class="s1">int</span><span class="s4">]:</span>
        <span class="s0">&quot;&quot;&quot;First signal index and first slice index affected by post-padding. 
 
        Describes the point where the window does begin stick out to the right 
        of the signal domain. 
        A detailed example is given :ref:`tutorial_stft_sliding_win` section 
        of the :ref:`user_guide`. 
 
        See Also 
        -------- 
        k_min: The smallest possible signal index. 
        k_max: First sample index after signal end not touched by a time slice. 
        lower_border_end: Where pre-padding effects end. 
        p_min: The smallest possible slice index. 
        p_max: Index of first non-overlapping upper time slice. 
        p_num: Number of time slices, i.e., `p_max` - `p_min`. 
        p_range: Determine and validate slice index range. 
        ShortTimeFFT: Class this method belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s1">w2 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">win</span><span class="s4">.</span><span class="s1">real</span><span class="s4">**</span><span class="s6">2 </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">win</span><span class="s4">.</span><span class="s1">imag</span><span class="s4">**</span><span class="s6">2</span>
        <span class="s1">q2 </span><span class="s4">= </span><span class="s1">n </span><span class="s4">// </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop </span><span class="s4">+ </span><span class="s6">1  </span><span class="s2"># first t[q] &gt;= t[n]</span>
        <span class="s1">q1 </span><span class="s4">= </span><span class="s1">max</span><span class="s4">((</span><span class="s1">n</span><span class="s4">-</span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num</span><span class="s4">) // </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop </span><span class="s4">- </span><span class="s6">1</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s2"># move window left until does not stick out to the right:</span>
        <span class="s3">for </span><span class="s1">q_ </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">q2</span><span class="s4">, </span><span class="s1">q1</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">):</span>
            <span class="s1">k_ </span><span class="s4">= </span><span class="s1">q_ </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop </span><span class="s4">+ (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num_mid</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">k_ </span><span class="s4">&lt; </span><span class="s1">n </span><span class="s3">or </span><span class="s1">all</span><span class="s4">(</span><span class="s1">w2</span><span class="s4">[</span><span class="s1">n</span><span class="s4">-</span><span class="s1">k_</span><span class="s4">:] == </span><span class="s6">0</span><span class="s4">):</span>
                <span class="s3">return </span><span class="s4">(</span><span class="s1">q_ </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">) * </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num_mid</span><span class="s4">, </span><span class="s1">q_ </span><span class="s4">+ </span><span class="s6">1</span>
        <span class="s3">return </span><span class="s6">0</span><span class="s4">, </span><span class="s6">0  </span><span class="s2"># border starts at first slice</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">delta_t</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; float</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Time increment of STFT. 
 
        The time increment `delta_t` = `T` * `hop` represents the sample 
        increment `hop` converted to time based on the sampling interval `T`. 
 
        See Also 
        -------- 
        delta_f: Width of the frequency bins of the STFT. 
        hop: Hop size in signal samples for sliding window. 
        t: Times of STFT for an input signal with `n` samples. 
        T: Sampling interval of input signal and window `win`. 
        ShortTimeFFT: Class this property belongs to 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">T </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop</span>

    <span class="s3">def </span><span class="s1">p_range</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">n</span><span class="s4">: </span><span class="s1">int</span><span class="s4">, </span><span class="s1">p0</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
                <span class="s1">p1</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; tuple</span><span class="s4">[</span><span class="s1">int</span><span class="s4">, </span><span class="s1">int</span><span class="s4">]:</span>
        <span class="s0">&quot;&quot;&quot;Determine and validate slice index range. 
 
        Parameters 
        ---------- 
        n : int 
            Number of samples of input signal, assuming t[0] = 0. 
        p0 : int | None 
            First slice index. If 0 then the first slice is centered at t = 0. 
            If ``None`` then `p_min` is used. Note that p0 may be &lt; 0 if 
            slices are left of t = 0. 
        p1 : int | None 
            End of interval (last value is p1-1). 
            If ``None`` then `p_max(n)` is used. 
 
 
        Returns 
        ------- 
        p0_ : int 
            The fist slice index 
        p1_ : int 
            End of interval (last value is p1-1). 
 
        Notes 
        ----- 
        A ``ValueError`` is raised if ``p_min &lt;= p0 &lt; p1 &lt;= p_max(n)`` does not 
        hold. 
 
        See Also 
        -------- 
        k_min: The smallest possible signal index. 
        k_max: First sample index after signal end not touched by a time slice. 
        lower_border_end: Where pre-padding effects end. 
        p_min: The smallest possible slice index. 
        p_max: Index of first non-overlapping upper time slice. 
        p_num: Number of time slices, i.e., `p_max` - `p_min`. 
        upper_border_begin: Where post-padding effects start. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s1">p_max </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">p_max</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)  </span><span class="s2"># shorthand</span>
        <span class="s1">p0_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">p_min </span><span class="s3">if </span><span class="s1">p0 </span><span class="s3">is None else </span><span class="s1">p0</span>
        <span class="s1">p1_ </span><span class="s4">= </span><span class="s1">p_max </span><span class="s3">if </span><span class="s1">p1 </span><span class="s3">is None else </span><span class="s1">p1</span>
        <span class="s3">if not </span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">p_min </span><span class="s4">&lt;= </span><span class="s1">p0_ </span><span class="s4">&lt; </span><span class="s1">p1_ </span><span class="s4">&lt;= </span><span class="s1">p_max</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;Invalid Parameter </span><span class="s3">{</span><span class="s1">p0</span><span class="s4">=</span><span class="s3">}</span><span class="s5">, </span><span class="s3">{</span><span class="s1">p1</span><span class="s4">=</span><span class="s3">}</span><span class="s5">, i.e., &quot; </span><span class="s4">+</span>
                             <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">p_min</span><span class="s4">=</span><span class="s3">} </span><span class="s5">&lt;= p0 &lt; p1 &lt;= </span><span class="s3">{</span><span class="s1">p_max</span><span class="s4">=</span><span class="s3">} </span><span class="s5">&quot; </span><span class="s4">+</span>
                             <span class="s5">f&quot;does not hold for signal length </span><span class="s3">{</span><span class="s1">n</span><span class="s4">=</span><span class="s3">}</span><span class="s5">!&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">p0_</span><span class="s4">, </span><span class="s1">p1_</span>

    <span class="s4">@</span><span class="s1">lru_cache</span><span class="s4">(</span><span class="s1">maxsize</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">t</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">n</span><span class="s4">: </span><span class="s1">int</span><span class="s4">, </span><span class="s1">p0</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">, </span><span class="s1">p1</span><span class="s4">: </span><span class="s1">int </span><span class="s4">| </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
          <span class="s1">k_offset</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= </span><span class="s6">0</span><span class="s4">) </span><span class="s1">-&gt; np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Times of STFT for an input signal with `n` samples. 
 
        Returns a 1d array with times of the `~ShortTimeFFT.stft` values with 
        the same  parametrization. Note that the slices are 
        ``delta_t = hop * T`` time units apart. 
 
         Parameters 
        ---------- 
        n 
            Number of sample of the input signal. 
        p0 
            The first element of the range of slices to calculate. If ``None`` 
            then it is set to :attr:`p_min`, which is the smallest possible 
            slice. 
        p1 
            The end of the array. If ``None`` then `p_max(n)` is used. 
        k_offset 
            Index of first sample (t = 0) in `x`. 
 
 
        See Also 
        -------- 
        delta_t: Time increment of STFT (``hop*T``) 
        hop: Time increment in signal samples for sliding window. 
        nearest_k_p: Nearest sample index k_p for which t[k_p] == t[p] holds. 
        T: Sampling interval of input signal and of the window (``1/fs``). 
        fs: Sampling frequency (being ``1/T``) 
        ShortTimeFFT: Class this method belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s1">p0</span><span class="s4">, </span><span class="s1">p1 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">p_range</span><span class="s4">(</span><span class="s1">n</span><span class="s4">, </span><span class="s1">p0</span><span class="s4">, </span><span class="s1">p1</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s1">p0</span><span class="s4">, </span><span class="s1">p1</span><span class="s4">) * </span><span class="s1">self</span><span class="s4">.</span><span class="s1">delta_t </span><span class="s4">+ </span><span class="s1">k_offset </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">T</span>

    <span class="s3">def </span><span class="s1">nearest_k_p</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">k</span><span class="s4">: </span><span class="s1">int</span><span class="s4">, </span><span class="s1">left</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Return nearest sample index k_p for which t[k_p] == t[p] holds. 
 
        The nearest next smaller time sample p (where t[p] is the center 
        position of the window of the p-th slice) is p_k = k // `hop`. 
        If `hop` is a divisor of `k` than `k` is returned. 
        If `left` is set than p_k * `hop` is returned else (p_k+1) * `hop`. 
 
        This method can be used to slice an input signal into chunks for 
        calculating the STFT and iSTFT incrementally. 
 
        See Also 
        -------- 
        delta_t: Time increment of STFT (``hop*T``) 
        hop: Time increment in signal samples for sliding window. 
        T: Sampling interval of input signal and of the window (``1/fs``). 
        fs: Sampling frequency (being ``1/T``) 
        t: Times of STFT for an input signal with `n` samples. 
        ShortTimeFFT: Class this method belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s1">p_q</span><span class="s4">, </span><span class="s1">remainder </span><span class="s4">= </span><span class="s1">divmod</span><span class="s4">(</span><span class="s1">k</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">remainder </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">k</span>
        <span class="s3">return </span><span class="s1">p_q </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop </span><span class="s3">if </span><span class="s1">left </span><span class="s3">else </span><span class="s4">(</span><span class="s1">p_q </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">) * </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hop</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">delta_f</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; float</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Width of the frequency bins of the STFT. 
 
        Return the frequency interval `delta_f` = 1 / (`mfft` * `T`). 
 
        See Also 
        -------- 
        delta_t: Time increment of STFT. 
        f_pts: Number of points along the frequency axis. 
        f: Frequencies values of the STFT. 
        mfft: Length of the input for FFT used. 
        T: Sampling interval. 
        t: Times of STFT for an input signal with `n` samples. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s6">1 </span><span class="s4">/ (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">f_pts</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Number of points along the frequency axis. 
 
        See Also 
        -------- 
        delta_f: Width of the frequency bins of the STFT. 
        f: Frequencies values of the STFT. 
        mfft: Length of the input for FFT used. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft </span><span class="s4">// </span><span class="s6">2 </span><span class="s4">+ </span><span class="s6">1 </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">onesided_fft </span><span class="s3">else </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">onesided_fft</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Return True if a one-sided FFT is used. 
 
        Returns ``True`` if `fft_mode` is either 'onesided' or 'onesided2X'. 
 
        See Also 
        -------- 
        fft_mode: Utilized FFT ('twosided', 'centered', 'onesided' or 
                 'onesided2X') 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode </span><span class="s3">in </span><span class="s4">{</span><span class="s5">'onesided'</span><span class="s4">, </span><span class="s5">'onesided2X'</span><span class="s4">}</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">f</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Frequencies values of the STFT. 
 
        A 1d array of length `f_pts` with `delta_f` spaced entries is returned. 
 
        See Also 
        -------- 
        delta_f: Width of the frequency bins of the STFT. 
        f_pts: Number of points along the frequency axis. 
        mfft: Length of the input for FFT used. 
        ShortTimeFFT: Class this property belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode </span><span class="s3">in </span><span class="s4">{</span><span class="s5">'onesided'</span><span class="s4">, </span><span class="s5">'onesided2X'</span><span class="s4">}:</span>
            <span class="s3">return </span><span class="s1">fft_lib</span><span class="s4">.</span><span class="s1">rfftfreq</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode </span><span class="s4">== </span><span class="s5">'twosided'</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">fft_lib</span><span class="s4">.</span><span class="s1">fftfreq</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode </span><span class="s4">== </span><span class="s5">'centered'</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">fft_lib</span><span class="s4">.</span><span class="s1">fftshift</span><span class="s4">(</span><span class="s1">fft_lib</span><span class="s4">.</span><span class="s1">fftfreq</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">T</span><span class="s4">))</span>
        <span class="s2"># This should never happen but makes the Linters happy:</span>
        <span class="s1">fft_modes </span><span class="s4">= </span><span class="s1">get_args</span><span class="s4">(</span><span class="s1">FFT_MODE_TYPE</span><span class="s4">)</span>
        <span class="s3">raise </span><span class="s1">RuntimeError</span><span class="s4">(</span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode</span><span class="s4">=</span><span class="s3">} </span><span class="s5">not in </span><span class="s3">{</span><span class="s1">fft_modes</span><span class="s3">}</span><span class="s5">!&quot;</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_fft_func</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">x</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">) </span><span class="s1">-&gt; np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;FFT based on the `fft_mode`, `mfft`, `scaling` and `phase_shift` 
        attributes. 
 
        For multidimensional arrays the transformation is carried out on the 
        last axis. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">phase_shift </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">x</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">] &lt; </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft</span><span class="s4">:  </span><span class="s2"># zero pad if needed</span>
                <span class="s1">z_shape </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">x</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">)</span>
                <span class="s1">z_shape</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft </span><span class="s4">- </span><span class="s1">x</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]</span>
                <span class="s1">x </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">x</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">z_shape</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">x</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)))</span>
            <span class="s1">p_s </span><span class="s4">= (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">phase_shift </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num_mid</span><span class="s4">) % </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num</span>
            <span class="s1">x </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">roll</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, -</span><span class="s1">p_s</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode </span><span class="s4">== </span><span class="s5">'twosided'</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">fft_lib</span><span class="s4">.</span><span class="s1">fft</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode </span><span class="s4">== </span><span class="s5">'centered'</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">fft_lib</span><span class="s4">.</span><span class="s1">fftshift</span><span class="s4">(</span><span class="s1">fft_lib</span><span class="s4">.</span><span class="s1">fft</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">), </span><span class="s1">axes</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode </span><span class="s4">== </span><span class="s5">'onesided'</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">fft_lib</span><span class="s4">.</span><span class="s1">rfft</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode </span><span class="s4">== </span><span class="s5">'onesided2X'</span><span class="s4">:</span>
            <span class="s1">X </span><span class="s4">= </span><span class="s1">fft_lib</span><span class="s4">.</span><span class="s1">rfft</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">)</span>
            <span class="s2"># Either squared magnitude (psd) or magnitude is doubled:</span>
            <span class="s1">fac </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s6">2</span><span class="s4">) </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">scaling </span><span class="s4">== </span><span class="s5">'psd' </span><span class="s3">else </span><span class="s6">2</span>
            <span class="s2"># For even input length, the last entry is unpaired:</span>
            <span class="s1">X</span><span class="s4">[..., </span><span class="s6">1</span><span class="s4">: -</span><span class="s6">1 </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft </span><span class="s4">% </span><span class="s6">2 </span><span class="s4">== </span><span class="s6">0 </span><span class="s3">else None</span><span class="s4">] *= </span><span class="s1">fac</span>
            <span class="s3">return </span><span class="s1">X</span>
        <span class="s2"># This should never happen but makes the Linter happy:</span>
        <span class="s1">fft_modes </span><span class="s4">= </span><span class="s1">get_args</span><span class="s4">(</span><span class="s1">FFT_MODE_TYPE</span><span class="s4">)</span>
        <span class="s3">raise </span><span class="s1">RuntimeError</span><span class="s4">(</span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode</span><span class="s4">=</span><span class="s3">} </span><span class="s5">not in </span><span class="s3">{</span><span class="s1">fft_modes</span><span class="s3">}</span><span class="s5">!&quot;</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_ifft_func</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">) </span><span class="s1">-&gt; np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">:</span>
        <span class="s0">&quot;&quot;&quot;Inverse to `_fft_func`. 
 
        Returned is an array of length `m_num`. If the FFT is `onesided` 
        then a float array is returned else a complex array is returned. 
        For multidimensional arrays the transformation is carried out on the 
        last axis. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode </span><span class="s4">== </span><span class="s5">'twosided'</span><span class="s4">:</span>
            <span class="s1">x </span><span class="s4">= </span><span class="s1">fft_lib</span><span class="s4">.</span><span class="s1">ifft</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode </span><span class="s4">== </span><span class="s5">'centered'</span><span class="s4">:</span>
            <span class="s1">x </span><span class="s4">= </span><span class="s1">fft_lib</span><span class="s4">.</span><span class="s1">ifft</span><span class="s4">(</span><span class="s1">fft_lib</span><span class="s4">.</span><span class="s1">ifftshift</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axes</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">), </span><span class="s1">n</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode </span><span class="s4">== </span><span class="s5">'onesided'</span><span class="s4">:</span>
            <span class="s1">x </span><span class="s4">= </span><span class="s1">fft_lib</span><span class="s4">.</span><span class="s1">irfft</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode </span><span class="s4">== </span><span class="s5">'onesided2X'</span><span class="s4">:</span>
            <span class="s1">Xc </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">()  </span><span class="s2"># we do not want to modify function parameters</span>
            <span class="s1">fac </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s6">2</span><span class="s4">) </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">scaling </span><span class="s4">== </span><span class="s5">'psd' </span><span class="s3">else </span><span class="s6">2</span>
            <span class="s2"># For even length X the last value is not paired with a negative</span>
            <span class="s2"># value on the two-sided FFT:</span>
            <span class="s1">q1 </span><span class="s4">= -</span><span class="s6">1 </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft </span><span class="s4">% </span><span class="s6">2 </span><span class="s4">== </span><span class="s6">0 </span><span class="s3">else None</span>
            <span class="s1">Xc</span><span class="s4">[..., </span><span class="s6">1</span><span class="s4">:</span><span class="s1">q1</span><span class="s4">] /= </span><span class="s1">fac</span>
            <span class="s1">x </span><span class="s4">= </span><span class="s1">fft_lib</span><span class="s4">.</span><span class="s1">irfft</span><span class="s4">(</span><span class="s1">Xc</span><span class="s4">, </span><span class="s1">n</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:  </span><span class="s2"># This should never happen but makes the Linter happy:</span>
            <span class="s1">error_str </span><span class="s4">= </span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode</span><span class="s4">=</span><span class="s3">} </span><span class="s5">not in </span><span class="s3">{</span><span class="s1">get_args</span><span class="s4">(</span><span class="s1">FFT_MODE_TYPE</span><span class="s4">)</span><span class="s3">}</span><span class="s5">!&quot;</span>
            <span class="s3">raise </span><span class="s1">RuntimeError</span><span class="s4">(</span><span class="s1">error_str</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">phase_shift </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">x</span><span class="s4">[:</span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num</span><span class="s4">]</span>
        <span class="s1">p_s </span><span class="s4">= (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">phase_shift </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num_mid</span><span class="s4">) % </span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num</span>
        <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">roll</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">p_s</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">)[:</span><span class="s1">self</span><span class="s4">.</span><span class="s1">m_num</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">extent</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">n</span><span class="s4">: </span><span class="s1">int</span><span class="s4">, </span><span class="s1">axes_seq</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s5">'tf'</span><span class="s4">, </span><span class="s5">'ft'</span><span class="s4">] = </span><span class="s5">'tf'</span><span class="s4">,</span>
               <span class="s1">center_bins</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">) </span><span class="s1">-&gt; tuple</span><span class="s4">[</span><span class="s1">float</span><span class="s4">, </span><span class="s1">float</span><span class="s4">, </span><span class="s1">float</span><span class="s4">, </span><span class="s1">float</span><span class="s4">]:</span>
        <span class="s0">&quot;&quot;&quot;Return minimum and maximum values time-frequency values. 
 
        A tuple with four floats  ``(t0, t1, f0, f1)`` for 'tf' and 
        ``(f0, f1, t0, t1)`` for 'ft' is returned describing the corners 
        of the time-frequency domain of the `~ShortTimeFFT.stft`. 
        That tuple can be passed to `matplotlib.pyplot.imshow` as a parameter 
        with the same name. 
 
        Parameters 
        ---------- 
        n : int 
            Number of samples in input signal. 
        axes_seq : {'tf', 'ft'} 
            Return time extent first and then frequency extent or vice-versa. 
        center_bins: bool 
            If set (default ``False``), the values of the time slots and 
            frequency bins are moved from the side the middle. This is useful, 
            when plotting the `~ShortTimeFFT.stft` values as step functions, 
            i.e., with no interpolation. 
 
        See Also 
        -------- 
        :func:`matplotlib.pyplot.imshow`: Display data as an image. 
        :class:`scipy.signal.ShortTimeFFT`: Class this method belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">axes_seq </span><span class="s3">not in </span><span class="s4">(</span><span class="s5">'tf'</span><span class="s4">, </span><span class="s5">'ft'</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;Parameter </span><span class="s3">{</span><span class="s1">axes_seq</span><span class="s4">=</span><span class="s3">} </span><span class="s5">not in ['tf', 'ft']!&quot;</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">onesided_fft</span><span class="s4">:</span>
            <span class="s1">q0</span><span class="s4">, </span><span class="s1">q1 </span><span class="s4">= </span><span class="s6">0</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">f_pts</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode </span><span class="s4">== </span><span class="s5">'centered'</span><span class="s4">:</span>
            <span class="s1">q0 </span><span class="s4">= -</span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft </span><span class="s4">// </span><span class="s6">2</span>
            <span class="s1">q1 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft </span><span class="s4">// </span><span class="s6">2 </span><span class="s4">- </span><span class="s6">1 </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft </span><span class="s4">% </span><span class="s6">2 </span><span class="s4">== </span><span class="s6">0 </span><span class="s3">else </span><span class="s1">self</span><span class="s4">.</span><span class="s1">mfft </span><span class="s4">// </span><span class="s6">2</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;Attribute fft_mode=</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">fft_mode</span><span class="s3">} </span><span class="s5">must be &quot; </span><span class="s4">+</span>
                             <span class="s5">&quot;in ['centered', 'onesided', 'onesided2X']&quot;</span><span class="s4">)</span>

        <span class="s1">p0</span><span class="s4">, </span><span class="s1">p1 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">p_min</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">p_max</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)  </span><span class="s2"># shorthand</span>
        <span class="s3">if </span><span class="s1">center_bins</span><span class="s4">:</span>
            <span class="s1">t0</span><span class="s4">, </span><span class="s1">t1 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">delta_t </span><span class="s4">* (</span><span class="s1">p0 </span><span class="s4">- </span><span class="s6">0.5</span><span class="s4">), </span><span class="s1">self</span><span class="s4">.</span><span class="s1">delta_t </span><span class="s4">* (</span><span class="s1">p1 </span><span class="s4">- </span><span class="s6">0.5</span><span class="s4">)</span>
            <span class="s1">f0</span><span class="s4">, </span><span class="s1">f1 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">delta_f </span><span class="s4">* (</span><span class="s1">q0 </span><span class="s4">- </span><span class="s6">0.5</span><span class="s4">), </span><span class="s1">self</span><span class="s4">.</span><span class="s1">delta_f </span><span class="s4">* (</span><span class="s1">q1 </span><span class="s4">- </span><span class="s6">0.5</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">t0</span><span class="s4">, </span><span class="s1">t1 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">delta_t </span><span class="s4">* </span><span class="s1">p0</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">delta_t </span><span class="s4">* </span><span class="s1">p1</span>
            <span class="s1">f0</span><span class="s4">, </span><span class="s1">f1 </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">delta_f </span><span class="s4">* </span><span class="s1">q0</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">delta_f </span><span class="s4">* </span><span class="s1">q1</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">t0</span><span class="s4">, </span><span class="s1">t1</span><span class="s4">, </span><span class="s1">f0</span><span class="s4">, </span><span class="s1">f1</span><span class="s4">) </span><span class="s3">if </span><span class="s1">axes_seq </span><span class="s4">== </span><span class="s5">'tf' </span><span class="s3">else </span><span class="s4">(</span><span class="s1">f0</span><span class="s4">, </span><span class="s1">f1</span><span class="s4">, </span><span class="s1">t0</span><span class="s4">, </span><span class="s1">t1</span><span class="s4">)</span>
</pre>
</body>
</html>