<html>
<head>
<title>libsvm_sparse_helper.c</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #7a7e85;}
.s4 { color: #2aacb8;}
.s5 { color: #0da19e;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
libsvm_sparse_helper.c</font>
</center></td></tr></table>
<pre><span class="s0">#include </span><span class="s1">&lt;stdlib.h&gt;</span>
<span class="s0">#define </span><span class="s1">PY_SSIZE_T_CLEAN</span>
<span class="s0">#include </span><span class="s1">&lt;Python.h&gt;</span>
<span class="s0">#include </span><span class="s2">&quot;svm.h&quot;</span>
<span class="s0">#include </span><span class="s2">&quot;_svm_cython_blas_helpers.h&quot;</span>


<span class="s0">#ifndef </span><span class="s1">MAX</span>
    <span class="s0">#define </span><span class="s1">MAX(x, y) (((x) &gt; (y)) ? (x) : (y))</span>
<span class="s0">#endif</span>


<span class="s3">/* 
 * Convert scipy.sparse.csr to libsvm's sparse data structure 
 */</span>
<span class="s0">struct </span><span class="s1">svm_csr_node **csr_to_libsvm (</span><span class="s0">double </span><span class="s1">*values, </span><span class="s0">int</span><span class="s1">* indices, </span><span class="s0">int</span><span class="s1">* indptr, </span><span class="s0">int </span><span class="s1">n_samples)</span>
<span class="s1">{</span>
    <span class="s0">struct </span><span class="s1">svm_csr_node **sparse, *temp;</span>
    <span class="s0">int </span><span class="s1">i, j=</span><span class="s4">0</span><span class="s1">, k=</span><span class="s4">0</span><span class="s1">, n;</span>
    <span class="s1">sparse = malloc (n_samples * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">struct </span><span class="s1">svm_csr_node *));</span>

    <span class="s0">if </span><span class="s1">(sparse == NULL)</span>
        <span class="s0">return </span><span class="s1">NULL;</span>

    <span class="s0">for </span><span class="s1">(i=</span><span class="s4">0</span><span class="s1">; i&lt;n_samples; ++i) {</span>
        <span class="s1">n = indptr[i+</span><span class="s4">1</span><span class="s1">] - indptr[i]; </span><span class="s3">/* count elements in row i */</span>
        <span class="s1">temp = malloc ((n+</span><span class="s4">1</span><span class="s1">) * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">struct </span><span class="s1">svm_csr_node));</span>

        <span class="s0">if </span><span class="s1">(temp == NULL) {</span>
            <span class="s0">for </span><span class="s1">(j=</span><span class="s4">0</span><span class="s1">; j&lt;i; j++)</span>
                <span class="s1">free(sparse[j]);</span>
            <span class="s1">free(sparse);</span>
            <span class="s0">return </span><span class="s1">NULL;</span>
        <span class="s1">}</span>

        <span class="s0">for </span><span class="s1">(j=</span><span class="s4">0</span><span class="s1">; j&lt;n; ++j) {</span>
            <span class="s1">temp[j].value = values[k];</span>
            <span class="s1">temp[j].index = indices[k] + </span><span class="s4">1</span><span class="s1">; </span><span class="s3">/* libsvm uses 1-based indexing */</span>
            <span class="s1">++k;</span>
        <span class="s1">}</span>
        <span class="s3">/* set sentinel */</span>
        <span class="s1">temp[n].index = -</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">sparse[i] = temp;</span>
    <span class="s1">}</span>

    <span class="s0">return </span><span class="s1">sparse;</span>
<span class="s1">}</span>



<span class="s0">struct </span><span class="s1">svm_parameter * set_parameter(</span><span class="s0">int </span><span class="s1">svm_type, </span><span class="s0">int </span><span class="s1">kernel_type, </span><span class="s0">int </span><span class="s1">degree,</span>
		<span class="s0">double </span><span class="s1">gamma, </span><span class="s0">double </span><span class="s1">coef0, </span><span class="s0">double </span><span class="s1">nu, </span><span class="s0">double </span><span class="s1">cache_size, </span><span class="s0">double </span><span class="s1">C,</span>
		<span class="s0">double </span><span class="s1">eps, </span><span class="s0">double </span><span class="s1">p, </span><span class="s0">int </span><span class="s1">shrinking, </span><span class="s0">int </span><span class="s1">probability, </span><span class="s0">int </span><span class="s1">nr_weight,</span>
		<span class="s0">char </span><span class="s1">*weight_label, </span><span class="s0">char </span><span class="s1">*weight, </span><span class="s0">int </span><span class="s1">max_iter, </span><span class="s0">int </span><span class="s1">random_seed)</span>
<span class="s1">{</span>
    <span class="s0">struct </span><span class="s1">svm_parameter *param;</span>
    <span class="s1">param = malloc(</span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">struct </span><span class="s1">svm_parameter));</span>
    <span class="s0">if </span><span class="s1">(param == NULL) </span><span class="s0">return </span><span class="s1">NULL;</span>
    <span class="s1">param</span><span class="s5">-&gt;</span><span class="s1">svm_type = svm_type;</span>
    <span class="s1">param</span><span class="s5">-&gt;</span><span class="s1">kernel_type = kernel_type;</span>
    <span class="s1">param</span><span class="s5">-&gt;</span><span class="s1">degree = degree;</span>
    <span class="s1">param</span><span class="s5">-&gt;</span><span class="s1">coef0 = coef0;</span>
    <span class="s1">param</span><span class="s5">-&gt;</span><span class="s1">nu = nu;</span>
    <span class="s1">param</span><span class="s5">-&gt;</span><span class="s1">cache_size = cache_size;</span>
    <span class="s1">param</span><span class="s5">-&gt;</span><span class="s1">C = C;</span>
    <span class="s1">param</span><span class="s5">-&gt;</span><span class="s1">eps = eps;</span>
    <span class="s1">param</span><span class="s5">-&gt;</span><span class="s1">p = p;</span>
    <span class="s1">param</span><span class="s5">-&gt;</span><span class="s1">shrinking = shrinking;</span>
    <span class="s1">param</span><span class="s5">-&gt;</span><span class="s1">probability = probability;</span>
    <span class="s1">param</span><span class="s5">-&gt;</span><span class="s1">nr_weight = nr_weight;</span>
    <span class="s1">param</span><span class="s5">-&gt;</span><span class="s1">weight_label = (</span><span class="s0">int </span><span class="s1">*) weight_label;</span>
    <span class="s1">param</span><span class="s5">-&gt;</span><span class="s1">weight = (</span><span class="s0">double </span><span class="s1">*) weight;</span>
    <span class="s1">param</span><span class="s5">-&gt;</span><span class="s1">gamma = gamma;</span>
    <span class="s1">param</span><span class="s5">-&gt;</span><span class="s1">max_iter = max_iter;</span>
    <span class="s1">param</span><span class="s5">-&gt;</span><span class="s1">random_seed = random_seed;</span>
    <span class="s0">return </span><span class="s1">param;</span>
<span class="s1">}</span>


<span class="s3">/* 
 * Create and return a svm_csr_problem struct from a scipy.sparse.csr matrix. It is 
 * up to the user to free resulting structure. 
 * 
 * TODO: precomputed kernel. 
 */</span>
<span class="s0">struct </span><span class="s1">svm_csr_problem * csr_set_problem (</span><span class="s0">char </span><span class="s1">*values, Py_ssize_t *n_indices,</span>
		<span class="s0">char </span><span class="s1">*indices, Py_ssize_t *n_indptr, </span><span class="s0">char </span><span class="s1">*indptr, </span><span class="s0">char </span><span class="s1">*Y,</span>
                <span class="s0">char </span><span class="s1">*sample_weight, </span><span class="s0">int </span><span class="s1">kernel_type) {</span>

    <span class="s0">struct </span><span class="s1">svm_csr_problem *problem;</span>
    <span class="s1">problem = malloc (</span><span class="s0">sizeof </span><span class="s1">(</span><span class="s0">struct </span><span class="s1">svm_csr_problem));</span>
    <span class="s0">if </span><span class="s1">(problem == NULL) </span><span class="s0">return </span><span class="s1">NULL;</span>
    <span class="s1">problem</span><span class="s5">-&gt;</span><span class="s1">l = (</span><span class="s0">int</span><span class="s1">) n_indptr[</span><span class="s4">0</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">problem</span><span class="s5">-&gt;</span><span class="s1">y = (</span><span class="s0">double </span><span class="s1">*) Y;</span>
    <span class="s1">problem</span><span class="s5">-&gt;</span><span class="s1">x = csr_to_libsvm((</span><span class="s0">double </span><span class="s1">*) values, (</span><span class="s0">int </span><span class="s1">*) indices,</span>
                               <span class="s1">(</span><span class="s0">int </span><span class="s1">*) indptr, problem</span><span class="s5">-&gt;</span><span class="s1">l);</span>
    <span class="s3">/* should be removed once we implement weighted samples */</span>
    <span class="s1">problem</span><span class="s5">-&gt;</span><span class="s1">W = (</span><span class="s0">double </span><span class="s1">*) sample_weight;</span>

    <span class="s0">if </span><span class="s1">(problem</span><span class="s5">-&gt;</span><span class="s1">x == NULL) {</span>
        <span class="s1">free(problem);</span>
        <span class="s0">return </span><span class="s1">NULL;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">problem;</span>
<span class="s1">}</span>


<span class="s0">struct </span><span class="s1">svm_csr_model *csr_set_model(</span><span class="s0">struct </span><span class="s1">svm_parameter *param, </span><span class="s0">int </span><span class="s1">nr_class,</span>
                            <span class="s0">char </span><span class="s1">*SV_data, Py_ssize_t *SV_indices_dims,</span>
                            <span class="s0">char </span><span class="s1">*SV_indices, Py_ssize_t *SV_indptr_dims,</span>
                            <span class="s0">char </span><span class="s1">*SV_intptr,</span>
                            <span class="s0">char </span><span class="s1">*sv_coef, </span><span class="s0">char </span><span class="s1">*rho, </span><span class="s0">char </span><span class="s1">*nSV,</span>
                            <span class="s0">char </span><span class="s1">*probA, </span><span class="s0">char </span><span class="s1">*probB)</span>
<span class="s1">{</span>
    <span class="s0">struct </span><span class="s1">svm_csr_model *model;</span>
    <span class="s0">double </span><span class="s1">*dsv_coef = (</span><span class="s0">double </span><span class="s1">*) sv_coef;</span>
    <span class="s0">int </span><span class="s1">i, m;</span>

    <span class="s1">m = nr_class * (nr_class-1)/</span><span class="s4">2</span><span class="s1">;</span>

    <span class="s0">if </span><span class="s1">((model = malloc(</span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">struct </span><span class="s1">svm_csr_model))) == NULL)</span>
        <span class="s0">goto </span><span class="s1">model_error;</span>
    <span class="s0">if </span><span class="s1">((model</span><span class="s5">-&gt;</span><span class="s1">nSV = malloc(nr_class * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">int</span><span class="s1">))) == NULL)</span>
        <span class="s0">goto </span><span class="s1">nsv_error;</span>
    <span class="s0">if </span><span class="s1">((model</span><span class="s5">-&gt;</span><span class="s1">label = malloc(nr_class * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">int</span><span class="s1">))) == NULL)</span>
        <span class="s0">goto </span><span class="s1">label_error;</span>
    <span class="s0">if </span><span class="s1">((model</span><span class="s5">-&gt;</span><span class="s1">sv_coef = malloc((nr_class-1)*</span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">double </span><span class="s1">*))) == NULL)</span>
        <span class="s0">goto </span><span class="s1">sv_coef_error;</span>
    <span class="s0">if </span><span class="s1">((model</span><span class="s5">-&gt;</span><span class="s1">rho = malloc( m * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">double</span><span class="s1">))) == NULL)</span>
        <span class="s0">goto </span><span class="s1">rho_error;</span>

    <span class="s3">// This is only allocated in dynamic memory while training.</span>
    <span class="s1">model</span><span class="s5">-&gt;</span><span class="s1">n_iter = NULL;</span>

    <span class="s3">/* in the case of precomputed kernels we do not use 
       dense_to_precomputed because we don't want the leading 0. As 
       indices start at 1 (not at 0) this will work */</span>
    <span class="s1">model</span><span class="s5">-&gt;</span><span class="s1">l = (</span><span class="s0">int</span><span class="s1">) SV_indptr_dims[</span><span class="s4">0</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">model</span><span class="s5">-&gt;</span><span class="s1">SV = csr_to_libsvm((</span><span class="s0">double </span><span class="s1">*) SV_data, (</span><span class="s0">int </span><span class="s1">*) SV_indices,</span>
                              <span class="s1">(</span><span class="s0">int </span><span class="s1">*) SV_intptr, model</span><span class="s5">-&gt;</span><span class="s1">l);</span>
    <span class="s1">model</span><span class="s5">-&gt;</span><span class="s1">nr_class = nr_class;</span>
    <span class="s1">model</span><span class="s5">-&gt;</span><span class="s1">param = *param;</span>

    <span class="s3">/* 
     * regression and one-class does not use nSV, label. 
     */</span>
    <span class="s0">if </span><span class="s1">(param</span><span class="s5">-&gt;</span><span class="s1">svm_type &lt; </span><span class="s4">2</span><span class="s1">) {</span>
        <span class="s1">memcpy(model</span><span class="s5">-&gt;</span><span class="s1">nSV,   nSV,   model</span><span class="s5">-&gt;</span><span class="s1">nr_class * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">int</span><span class="s1">));</span>
        <span class="s0">for</span><span class="s1">(i=</span><span class="s4">0</span><span class="s1">; i &lt; model</span><span class="s5">-&gt;</span><span class="s1">nr_class; i++)</span>
            <span class="s1">model</span><span class="s5">-&gt;</span><span class="s1">label[i] = i;</span>
    <span class="s1">}</span>

    <span class="s0">for </span><span class="s1">(i=</span><span class="s4">0</span><span class="s1">; i &lt; model</span><span class="s5">-&gt;</span><span class="s1">nr_class-1; i++) {</span>
        <span class="s3">/* 
         * We cannot squash all this mallocs in a single call since 
         * svm_destroy_model will free each element of the array. 
         */</span>
        <span class="s0">if </span><span class="s1">((model</span><span class="s5">-&gt;</span><span class="s1">sv_coef[i] = malloc((model</span><span class="s5">-&gt;</span><span class="s1">l) * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">double</span><span class="s1">))) == NULL) {</span>
            <span class="s0">int </span><span class="s1">j;</span>
            <span class="s0">for </span><span class="s1">(j=</span><span class="s4">0</span><span class="s1">; j&lt;i; j++)</span>
                <span class="s1">free(model</span><span class="s5">-&gt;</span><span class="s1">sv_coef[j]);</span>
            <span class="s0">goto </span><span class="s1">sv_coef_i_error;</span>
        <span class="s1">}</span>
        <span class="s1">memcpy(model</span><span class="s5">-&gt;</span><span class="s1">sv_coef[i], dsv_coef, (model</span><span class="s5">-&gt;</span><span class="s1">l) * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">double</span><span class="s1">));</span>
        <span class="s1">dsv_coef += model</span><span class="s5">-&gt;</span><span class="s1">l;</span>
    <span class="s1">}</span>

    <span class="s0">for </span><span class="s1">(i=</span><span class="s4">0</span><span class="s1">; i&lt;m; ++i) {</span>
        <span class="s1">(model</span><span class="s5">-&gt;</span><span class="s1">rho)[i] = -((</span><span class="s0">double </span><span class="s1">*) rho)[i];</span>
    <span class="s1">}</span>

    <span class="s3">/* 
     * just to avoid segfaults, these features are not wrapped but 
     * svm_destroy_model will try to free them. 
     */</span>

    <span class="s0">if </span><span class="s1">(param</span><span class="s5">-&gt;</span><span class="s1">probability) {</span>
        <span class="s0">if </span><span class="s1">((model</span><span class="s5">-&gt;</span><span class="s1">probA = malloc(m * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">double</span><span class="s1">))) == NULL)</span>
            <span class="s0">goto </span><span class="s1">probA_error;</span>
        <span class="s1">memcpy(model</span><span class="s5">-&gt;</span><span class="s1">probA, probA, m * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">double</span><span class="s1">));</span>
        <span class="s0">if </span><span class="s1">((model</span><span class="s5">-&gt;</span><span class="s1">probB = malloc(m * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">double</span><span class="s1">))) == NULL)</span>
            <span class="s0">goto </span><span class="s1">probB_error;</span>
        <span class="s1">memcpy(model</span><span class="s5">-&gt;</span><span class="s1">probB, probB, m * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">double</span><span class="s1">));</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s1">model</span><span class="s5">-&gt;</span><span class="s1">probA = NULL;</span>
        <span class="s1">model</span><span class="s5">-&gt;</span><span class="s1">probB = NULL;</span>
    <span class="s1">}</span>

    <span class="s3">/* We'll free SV ourselves */</span>
    <span class="s1">model</span><span class="s5">-&gt;</span><span class="s1">free_sv = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s0">return </span><span class="s1">model;</span>

<span class="s1">probB_error:</span>
    <span class="s1">free(model</span><span class="s5">-&gt;</span><span class="s1">probA);</span>
<span class="s1">probA_error:</span>
    <span class="s0">for </span><span class="s1">(i=</span><span class="s4">0</span><span class="s1">; i &lt; model</span><span class="s5">-&gt;</span><span class="s1">nr_class-1; i++)</span>
        <span class="s1">free(model</span><span class="s5">-&gt;</span><span class="s1">sv_coef[i]);</span>
<span class="s1">sv_coef_i_error:</span>
    <span class="s1">free(model</span><span class="s5">-&gt;</span><span class="s1">rho);</span>
<span class="s1">rho_error:</span>
    <span class="s1">free(model</span><span class="s5">-&gt;</span><span class="s1">sv_coef);</span>
<span class="s1">sv_coef_error:</span>
    <span class="s1">free(model</span><span class="s5">-&gt;</span><span class="s1">label);</span>
<span class="s1">label_error:</span>
    <span class="s1">free(model</span><span class="s5">-&gt;</span><span class="s1">nSV);</span>
<span class="s1">nsv_error:</span>
    <span class="s1">free(model);</span>
<span class="s1">model_error:</span>
    <span class="s0">return </span><span class="s1">NULL;</span>
<span class="s1">}</span>


<span class="s3">/* 
 * Copy support vectors into a scipy.sparse.csr matrix 
 */</span>
<span class="s0">int </span><span class="s1">csr_copy_SV (</span><span class="s0">char </span><span class="s1">*data, Py_ssize_t *n_indices,</span>
		<span class="s0">char </span><span class="s1">*indices, Py_ssize_t *n_indptr, </span><span class="s0">char </span><span class="s1">*indptr,</span>
		<span class="s0">struct </span><span class="s1">svm_csr_model *model, </span><span class="s0">int </span><span class="s1">n_features)</span>
<span class="s1">{</span>
	<span class="s0">int </span><span class="s1">i, j, k=</span><span class="s4">0</span><span class="s1">, index;</span>
	<span class="s0">double </span><span class="s1">*dvalues = (</span><span class="s0">double </span><span class="s1">*) data;</span>
	<span class="s0">int </span><span class="s1">*iindices = (</span><span class="s0">int </span><span class="s1">*) indices;</span>
	<span class="s0">int </span><span class="s1">*iindptr  = (</span><span class="s0">int </span><span class="s1">*) indptr;</span>
	<span class="s1">iindptr[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0</span><span class="s1">;</span>
	<span class="s0">for </span><span class="s1">(i=</span><span class="s4">0</span><span class="s1">; i&lt;model</span><span class="s5">-&gt;</span><span class="s1">l; ++i) { </span><span class="s3">/* iterate over support vectors */</span>
		<span class="s1">index = model</span><span class="s5">-&gt;</span><span class="s1">SV[i][</span><span class="s4">0</span><span class="s1">].index;</span>
        <span class="s0">for</span><span class="s1">(j=</span><span class="s4">0</span><span class="s1">; index &gt;=</span><span class="s4">0 </span><span class="s1">; ++j) {</span>
        	<span class="s1">iindices[k] = index - </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">dvalues[k] = model</span><span class="s5">-&gt;</span><span class="s1">SV[i][j].value;</span>
            <span class="s1">index = model</span><span class="s5">-&gt;</span><span class="s1">SV[i][j+</span><span class="s4">1</span><span class="s1">].index;</span>
            <span class="s1">++k;</span>
        <span class="s1">}</span>
        <span class="s1">iindptr[i+</span><span class="s4">1</span><span class="s1">] = k;</span>
	<span class="s1">}</span>

	<span class="s0">return </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">/* get number of nonzero coefficients in support vectors */</span>
<span class="s1">Py_ssize_t get_nonzero_SV (</span><span class="s0">struct </span><span class="s1">svm_csr_model *model) {</span>
	<span class="s0">int </span><span class="s1">i, j;</span>
	<span class="s1">Py_ssize_t count=</span><span class="s4">0</span><span class="s1">;</span>
	<span class="s0">for </span><span class="s1">(i=</span><span class="s4">0</span><span class="s1">; i&lt;model</span><span class="s5">-&gt;</span><span class="s1">l; ++i) {</span>
		<span class="s1">j = </span><span class="s4">0</span><span class="s1">;</span>
		<span class="s0">while </span><span class="s1">(model</span><span class="s5">-&gt;</span><span class="s1">SV[i][j].index != -</span><span class="s4">1</span><span class="s1">) {</span>
			<span class="s1">++j;</span>
			<span class="s1">++count;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s0">return </span><span class="s1">count;</span>
<span class="s1">}</span>


<span class="s3">/* 
 * Predict using a model, where data is expected to be encoded into a csr matrix. 
 */</span>
<span class="s0">int </span><span class="s1">csr_copy_predict (Py_ssize_t *data_size, </span><span class="s0">char </span><span class="s1">*data, Py_ssize_t *index_size,</span>
		<span class="s0">char </span><span class="s1">*index, Py_ssize_t *intptr_size, </span><span class="s0">char </span><span class="s1">*intptr, </span><span class="s0">struct </span><span class="s1">svm_csr_model *model,</span>
		<span class="s0">char </span><span class="s1">*dec_values, BlasFunctions *blas_functions) {</span>
    <span class="s0">double </span><span class="s1">*t = (</span><span class="s0">double </span><span class="s1">*) dec_values;</span>
    <span class="s0">struct </span><span class="s1">svm_csr_node **predict_nodes;</span>
    <span class="s1">Py_ssize_t i;</span>

    <span class="s1">predict_nodes = csr_to_libsvm((</span><span class="s0">double </span><span class="s1">*) data, (</span><span class="s0">int </span><span class="s1">*) index,</span>
                                  <span class="s1">(</span><span class="s0">int </span><span class="s1">*) intptr, intptr_size[</span><span class="s4">0</span><span class="s1">]-</span><span class="s4">1</span><span class="s1">);</span>

    <span class="s0">if </span><span class="s1">(predict_nodes == NULL)</span>
        <span class="s0">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s0">for</span><span class="s1">(i=</span><span class="s4">0</span><span class="s1">; i &lt; intptr_size[</span><span class="s4">0</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">; ++i) {</span>
        <span class="s1">*t = svm_csr_predict(model, predict_nodes[i], blas_functions);</span>
        <span class="s1">free(predict_nodes[i]);</span>
        <span class="s1">++t;</span>
    <span class="s1">}</span>
    <span class="s1">free(predict_nodes);</span>
    <span class="s0">return </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">int </span><span class="s1">csr_copy_predict_values (Py_ssize_t *data_size, </span><span class="s0">char </span><span class="s1">*data, Py_ssize_t *index_size,</span>
                <span class="s0">char </span><span class="s1">*index, Py_ssize_t *intptr_size, </span><span class="s0">char </span><span class="s1">*intptr, </span><span class="s0">struct </span><span class="s1">svm_csr_model *model,</span>
                <span class="s0">char </span><span class="s1">*dec_values, </span><span class="s0">int </span><span class="s1">nr_class, BlasFunctions *blas_functions) {</span>
    <span class="s0">struct </span><span class="s1">svm_csr_node **predict_nodes;</span>
    <span class="s1">Py_ssize_t i;</span>

    <span class="s1">predict_nodes = csr_to_libsvm((</span><span class="s0">double </span><span class="s1">*) data, (</span><span class="s0">int </span><span class="s1">*) index,</span>
                                  <span class="s1">(</span><span class="s0">int </span><span class="s1">*) intptr, intptr_size[</span><span class="s4">0</span><span class="s1">]-</span><span class="s4">1</span><span class="s1">);</span>

    <span class="s0">if </span><span class="s1">(predict_nodes == NULL)</span>
        <span class="s0">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s0">for</span><span class="s1">(i=</span><span class="s4">0</span><span class="s1">; i &lt; intptr_size[</span><span class="s4">0</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">; ++i) {</span>
        <span class="s1">svm_csr_predict_values(model, predict_nodes[i],</span>
                               <span class="s1">((</span><span class="s0">double </span><span class="s1">*) dec_values) + i*nr_class,</span>
			       <span class="s1">blas_functions);</span>
        <span class="s1">free(predict_nodes[i]);</span>
    <span class="s1">}</span>
    <span class="s1">free(predict_nodes);</span>

    <span class="s0">return </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">int </span><span class="s1">csr_copy_predict_proba (Py_ssize_t *data_size, </span><span class="s0">char </span><span class="s1">*data, Py_ssize_t *index_size,</span>
		<span class="s0">char </span><span class="s1">*index, Py_ssize_t *intptr_size, </span><span class="s0">char </span><span class="s1">*intptr, </span><span class="s0">struct </span><span class="s1">svm_csr_model *model,</span>
		<span class="s0">char </span><span class="s1">*dec_values, BlasFunctions *blas_functions) {</span>

    <span class="s0">struct </span><span class="s1">svm_csr_node **predict_nodes;</span>
    <span class="s1">Py_ssize_t i;</span>
    <span class="s0">int </span><span class="s1">m = model</span><span class="s5">-&gt;</span><span class="s1">nr_class;</span>

    <span class="s1">predict_nodes = csr_to_libsvm((</span><span class="s0">double </span><span class="s1">*) data, (</span><span class="s0">int </span><span class="s1">*) index,</span>
                                  <span class="s1">(</span><span class="s0">int </span><span class="s1">*) intptr, intptr_size[</span><span class="s4">0</span><span class="s1">]-</span><span class="s4">1</span><span class="s1">);</span>

    <span class="s0">if </span><span class="s1">(predict_nodes == NULL)</span>
        <span class="s0">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s0">for</span><span class="s1">(i=</span><span class="s4">0</span><span class="s1">; i &lt; intptr_size[</span><span class="s4">0</span><span class="s1">] - </span><span class="s4">1</span><span class="s1">; ++i) {</span>
        <span class="s1">svm_csr_predict_probability(</span>
		<span class="s1">model, predict_nodes[i], ((</span><span class="s0">double </span><span class="s1">*) dec_values) + i*m, blas_functions);</span>
        <span class="s1">free(predict_nodes[i]);</span>
    <span class="s1">}</span>
    <span class="s1">free(predict_nodes);</span>
    <span class="s0">return </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>


<span class="s1">Py_ssize_t get_nr(</span><span class="s0">struct </span><span class="s1">svm_csr_model *model)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">(Py_ssize_t) model</span><span class="s5">-&gt;</span><span class="s1">nr_class;</span>
<span class="s1">}</span>

<span class="s0">void </span><span class="s1">copy_intercept(</span><span class="s0">char </span><span class="s1">*data, </span><span class="s0">struct </span><span class="s1">svm_csr_model *model, Py_ssize_t *dims)</span>
<span class="s1">{</span>
    <span class="s3">/* intercept = -rho */</span>
    <span class="s1">Py_ssize_t i, n = dims[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s0">double </span><span class="s1">t, *ddata = (</span><span class="s0">double </span><span class="s1">*) data;</span>
    <span class="s0">for </span><span class="s1">(i=</span><span class="s4">0</span><span class="s1">; i&lt;n; ++i) {</span>
        <span class="s1">t = model</span><span class="s5">-&gt;</span><span class="s1">rho[i];</span>
        <span class="s3">/* we do this to avoid ugly -0.0 */</span>
        <span class="s1">*ddata = (t != </span><span class="s4">0</span><span class="s1">) ? -t : </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">++ddata;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">void </span><span class="s1">copy_support (</span><span class="s0">char </span><span class="s1">*data, </span><span class="s0">struct </span><span class="s1">svm_csr_model *model)</span>
<span class="s1">{</span>
    <span class="s1">memcpy (data, model</span><span class="s5">-&gt;</span><span class="s1">sv_ind, (model</span><span class="s5">-&gt;</span><span class="s1">l) * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">int</span><span class="s1">));</span>
<span class="s1">}</span>

<span class="s3">/* 
 * Some helpers to convert from libsvm sparse data structures 
 * model-&gt;sv_coef is a double **, whereas data is just a double *, 
 * so we have to do some stupid copying. 
 */</span>
<span class="s0">void </span><span class="s1">copy_sv_coef(</span><span class="s0">char </span><span class="s1">*data, </span><span class="s0">struct </span><span class="s1">svm_csr_model *model)</span>
<span class="s1">{</span>
    <span class="s0">int </span><span class="s1">i, len = model</span><span class="s5">-&gt;</span><span class="s1">nr_class-1;</span>
    <span class="s0">double </span><span class="s1">*temp = (</span><span class="s0">double </span><span class="s1">*) data;</span>
    <span class="s0">for</span><span class="s1">(i=</span><span class="s4">0</span><span class="s1">; i&lt;len; ++i) {</span>
        <span class="s1">memcpy(temp, model</span><span class="s5">-&gt;</span><span class="s1">sv_coef[i], </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">double</span><span class="s1">) * model</span><span class="s5">-&gt;</span><span class="s1">l);</span>
        <span class="s1">temp += model</span><span class="s5">-&gt;</span><span class="s1">l;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/* 
 * Get the number of iterations run in optimization 
 */</span>
<span class="s0">void </span><span class="s1">copy_n_iter(</span><span class="s0">char </span><span class="s1">*data, </span><span class="s0">struct </span><span class="s1">svm_csr_model *model)</span>
<span class="s1">{</span>
    <span class="s0">const int </span><span class="s1">n_models = MAX(</span><span class="s4">1</span><span class="s1">, model</span><span class="s5">-&gt;</span><span class="s1">nr_class * (model</span><span class="s5">-&gt;</span><span class="s1">nr_class-1) / </span><span class="s4">2</span><span class="s1">);</span>
    <span class="s1">memcpy(data, model</span><span class="s5">-&gt;</span><span class="s1">n_iter, n_models * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">int</span><span class="s1">));</span>
<span class="s1">}</span>

<span class="s3">/* 
 * Get the number of support vectors in a model. 
 */</span>
<span class="s1">Py_ssize_t get_l(</span><span class="s0">struct </span><span class="s1">svm_csr_model *model)</span>
<span class="s1">{</span>
    <span class="s0">return </span><span class="s1">(Py_ssize_t) model</span><span class="s5">-&gt;</span><span class="s1">l;</span>
<span class="s1">}</span>

<span class="s0">void </span><span class="s1">copy_nSV(</span><span class="s0">char </span><span class="s1">*data, </span><span class="s0">struct </span><span class="s1">svm_csr_model *model)</span>
<span class="s1">{</span>
    <span class="s0">if </span><span class="s1">(model</span><span class="s5">-&gt;</span><span class="s1">label == NULL) </span><span class="s0">return</span><span class="s1">;</span>
    <span class="s1">memcpy(data, model</span><span class="s5">-&gt;</span><span class="s1">nSV, model</span><span class="s5">-&gt;</span><span class="s1">nr_class * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">int</span><span class="s1">));</span>
<span class="s1">}</span>

<span class="s3">/* 
 * same as above with model-&gt;label 
 * TODO: merge in the cython layer 
 */</span>
<span class="s0">void </span><span class="s1">copy_label(</span><span class="s0">char </span><span class="s1">*data, </span><span class="s0">struct </span><span class="s1">svm_csr_model *model)</span>
<span class="s1">{</span>
    <span class="s0">if </span><span class="s1">(model</span><span class="s5">-&gt;</span><span class="s1">label == NULL) </span><span class="s0">return</span><span class="s1">;</span>
    <span class="s1">memcpy(data, model</span><span class="s5">-&gt;</span><span class="s1">label, model</span><span class="s5">-&gt;</span><span class="s1">nr_class * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">int</span><span class="s1">));</span>
<span class="s1">}</span>

<span class="s0">void </span><span class="s1">copy_probA(</span><span class="s0">char </span><span class="s1">*data, </span><span class="s0">struct </span><span class="s1">svm_csr_model *model, Py_ssize_t * dims)</span>
<span class="s1">{</span>
    <span class="s1">memcpy(data, model</span><span class="s5">-&gt;</span><span class="s1">probA, dims[</span><span class="s4">0</span><span class="s1">] * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">double</span><span class="s1">));</span>
<span class="s1">}</span>

<span class="s0">void </span><span class="s1">copy_probB(</span><span class="s0">char </span><span class="s1">*data, </span><span class="s0">struct </span><span class="s1">svm_csr_model *model, Py_ssize_t * dims)</span>
<span class="s1">{</span>
    <span class="s1">memcpy(data, model</span><span class="s5">-&gt;</span><span class="s1">probB, dims[</span><span class="s4">0</span><span class="s1">] * </span><span class="s0">sizeof</span><span class="s1">(</span><span class="s0">double</span><span class="s1">));</span>
<span class="s1">}</span>


<span class="s3">/* 
 * Some free routines. Some of them are nontrivial since a lot of 
 * sharing happens across objects (they *must* be called in the 
 * correct order) 
 */</span>
<span class="s0">int </span><span class="s1">free_problem(</span><span class="s0">struct </span><span class="s1">svm_csr_problem *problem)</span>
<span class="s1">{</span>
    <span class="s0">int </span><span class="s1">i;</span>
    <span class="s0">if </span><span class="s1">(problem == NULL) </span><span class="s0">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s0">for </span><span class="s1">(i=</span><span class="s4">0</span><span class="s1">; i&lt;problem</span><span class="s5">-&gt;</span><span class="s1">l; ++i)</span>
        <span class="s1">free (problem</span><span class="s5">-&gt;</span><span class="s1">x[i]);</span>
    <span class="s1">free (problem</span><span class="s5">-&gt;</span><span class="s1">x);</span>
    <span class="s1">free (problem);</span>
    <span class="s0">return </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">int </span><span class="s1">free_model(</span><span class="s0">struct </span><span class="s1">svm_csr_model *model)</span>
<span class="s1">{</span>
    <span class="s3">/* like svm_free_and_destroy_model, but does not free sv_coef[i] */</span>
    <span class="s3">/* We don't free n_iter, since we did not create them in set_model. */</span>
    <span class="s0">if </span><span class="s1">(model == NULL) </span><span class="s0">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">free(model</span><span class="s5">-&gt;</span><span class="s1">SV);</span>
    <span class="s1">free(model</span><span class="s5">-&gt;</span><span class="s1">sv_coef);</span>
    <span class="s1">free(model</span><span class="s5">-&gt;</span><span class="s1">rho);</span>
    <span class="s1">free(model</span><span class="s5">-&gt;</span><span class="s1">label);</span>
    <span class="s1">free(model</span><span class="s5">-&gt;</span><span class="s1">probA);</span>
    <span class="s1">free(model</span><span class="s5">-&gt;</span><span class="s1">probB);</span>
    <span class="s1">free(model</span><span class="s5">-&gt;</span><span class="s1">nSV);</span>
    <span class="s1">free(model);</span>

    <span class="s0">return </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">int </span><span class="s1">free_param(</span><span class="s0">struct </span><span class="s1">svm_parameter *param)</span>
<span class="s1">{</span>
    <span class="s0">if </span><span class="s1">(param == NULL) </span><span class="s0">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">free(param);</span>
    <span class="s0">return </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>


<span class="s0">int </span><span class="s1">free_model_SV(</span><span class="s0">struct </span><span class="s1">svm_csr_model *model)</span>
<span class="s1">{</span>
    <span class="s0">int </span><span class="s1">i;</span>
    <span class="s0">for </span><span class="s1">(i=model</span><span class="s5">-&gt;</span><span class="s1">l-1; i&gt;=</span><span class="s4">0</span><span class="s1">; --i) free(model</span><span class="s5">-&gt;</span><span class="s1">SV[i]);</span>
    <span class="s3">/* svn_destroy_model frees model-&gt;SV */</span>
    <span class="s0">for </span><span class="s1">(i=</span><span class="s4">0</span><span class="s1">; i &lt; model</span><span class="s5">-&gt;</span><span class="s1">nr_class-1 ; ++i) free(model</span><span class="s5">-&gt;</span><span class="s1">sv_coef[i]);</span>
    <span class="s3">/* svn_destroy_model frees model-&gt;sv_coef */</span>
    <span class="s0">return </span><span class="s4">0</span><span class="s1">;</span>
<span class="s1">}</span>


<span class="s3">/* borrowed from original libsvm code */</span>
<span class="s0">static void </span><span class="s1">print_null(</span><span class="s0">const char </span><span class="s1">*s) {}</span>

<span class="s0">static void </span><span class="s1">print_string_stdout(</span><span class="s0">const char </span><span class="s1">*s)</span>
<span class="s1">{</span>
	<span class="s1">fputs(s,stdout);</span>
	<span class="s1">fflush(stdout);</span>
<span class="s1">}</span>

<span class="s3">/* provide convenience wrapper */</span>
<span class="s0">void </span><span class="s1">set_verbosity(</span><span class="s0">int </span><span class="s1">verbosity_flag){</span>
	<span class="s0">if </span><span class="s1">(verbosity_flag)</span>
		<span class="s1">svm_set_print_string_function(&amp;print_string_stdout);</span>
	<span class="s0">else</span>
		<span class="s1">svm_set_print_string_function(&amp;print_null);</span>
<span class="s1">}</span>
</pre>
</body>
</html>