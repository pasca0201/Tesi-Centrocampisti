<html>
<head>
<title>scoping.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
scoping.py</font>
</center></td></tr></table>
<pre><span class="s0"># orm/scoping.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Callable</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Dict</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Generic</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Iterable</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Iterator</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">overload</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Sequence</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Tuple</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Type</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TypeVar</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Union</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">session </span><span class="s2">import </span><span class="s1">_S</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">session </span><span class="s2">import </span><span class="s1">Session</span>
<span class="s2">from </span><span class="s3">.. </span><span class="s2">import </span><span class="s1">exc </span><span class="s2">as </span><span class="s1">sa_exc</span>
<span class="s2">from </span><span class="s3">.. </span><span class="s2">import </span><span class="s1">util</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">util </span><span class="s2">import </span><span class="s1">create_proxy_methods</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">util </span><span class="s2">import </span><span class="s1">ScopedRegistry</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">util </span><span class="s2">import </span><span class="s1">ThreadLocalRegistry</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">util </span><span class="s2">import </span><span class="s1">warn</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">util </span><span class="s2">import </span><span class="s1">warn_deprecated</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">util</span><span class="s3">.</span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Protocol</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_EntityType</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_IdentityKeyType</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">OrmExecuteOptionsParameter</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">identity </span><span class="s2">import </span><span class="s1">IdentityMap</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">interfaces </span><span class="s2">import </span><span class="s1">ORMOption</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">mapper </span><span class="s2">import </span><span class="s1">Mapper</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">query </span><span class="s2">import </span><span class="s1">Query</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">query </span><span class="s2">import </span><span class="s1">RowReturningQuery</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">session </span><span class="s2">import </span><span class="s1">_BindArguments</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">session </span><span class="s2">import </span><span class="s1">_EntityBindKey</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">session </span><span class="s2">import </span><span class="s1">_PKIdentityArgument</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">session </span><span class="s2">import </span><span class="s1">_SessionBind</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">session </span><span class="s2">import </span><span class="s1">sessionmaker</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">session </span><span class="s2">import </span><span class="s1">SessionTransaction</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">engine </span><span class="s2">import </span><span class="s1">Connection</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">engine </span><span class="s2">import </span><span class="s1">CursorResult</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">engine </span><span class="s2">import </span><span class="s1">Engine</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">engine </span><span class="s2">import </span><span class="s1">Result</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">engine </span><span class="s2">import </span><span class="s1">Row</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">engine </span><span class="s2">import </span><span class="s1">RowMapping</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">engine</span><span class="s3">.</span><span class="s1">interfaces </span><span class="s2">import </span><span class="s1">_CoreAnyExecuteParams</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">engine</span><span class="s3">.</span><span class="s1">interfaces </span><span class="s2">import </span><span class="s1">_CoreSingleExecuteParams</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">engine</span><span class="s3">.</span><span class="s1">interfaces </span><span class="s2">import </span><span class="s1">CoreExecuteOptionsParameter</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">engine</span><span class="s3">.</span><span class="s1">result </span><span class="s2">import </span><span class="s1">ScalarResult</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_ColumnsClauseArgument</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T0</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T1</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T2</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T3</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T4</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T5</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T6</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T7</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_TypedColumnClauseArgument </span><span class="s2">as </span><span class="s1">_TCCA</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">base </span><span class="s2">import </span><span class="s1">Executable</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">dml </span><span class="s2">import </span><span class="s1">UpdateBase</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">elements </span><span class="s2">import </span><span class="s1">ClauseElement</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">roles </span><span class="s2">import </span><span class="s1">TypedColumnsClauseRole</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">ForUpdateParameter</span>
    <span class="s2">from </span><span class="s3">..</span><span class="s1">sql</span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">TypedReturnsRows</span>

<span class="s1">_T </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">&quot;_T&quot;</span><span class="s3">, </span><span class="s1">bound</span><span class="s3">=</span><span class="s1">Any</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">QueryPropertyDescriptor</span><span class="s3">(</span><span class="s1">Protocol</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Describes the type applied to a class-level 
    :meth:`_orm.scoped_session.query_property` attribute. 
 
    .. versionadded:: 2.0.5 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__get__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">instance</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">owner</span><span class="s3">: </span><span class="s1">Type</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]) </span><span class="s1">-&gt; Query</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]: ...</span>


<span class="s1">_O </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">&quot;_O&quot;</span><span class="s3">, </span><span class="s1">bound</span><span class="s3">=</span><span class="s1">object</span><span class="s3">)</span>

<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">&quot;scoped_session&quot;</span><span class="s3">]</span>


<span class="s3">@</span><span class="s1">create_proxy_methods</span><span class="s3">(</span>
    <span class="s1">Session</span><span class="s3">,</span>
    <span class="s4">&quot;:class:`_orm.Session`&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;:class:`_orm.scoping.scoped_session`&quot;</span><span class="s3">,</span>
    <span class="s1">classmethods</span><span class="s3">=[</span><span class="s4">&quot;close_all&quot;</span><span class="s3">, </span><span class="s4">&quot;object_session&quot;</span><span class="s3">, </span><span class="s4">&quot;identity_key&quot;</span><span class="s3">],</span>
    <span class="s1">methods</span><span class="s3">=[</span>
        <span class="s4">&quot;__contains__&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;__iter__&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;add&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;add_all&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;begin&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;begin_nested&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;close&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;reset&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;commit&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;connection&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;delete&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;execute&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;expire&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;expire_all&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;expunge&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;expunge_all&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;flush&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;get&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;get_one&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;get_bind&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;is_modified&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;bulk_save_objects&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;bulk_insert_mappings&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;bulk_update_mappings&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;merge&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;query&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;refresh&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;rollback&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;scalar&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;scalars&quot;</span><span class="s3">,</span>
    <span class="s3">],</span>
    <span class="s1">attributes</span><span class="s3">=[</span>
        <span class="s4">&quot;bind&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;dirty&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;deleted&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;new&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;identity_map&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;is_active&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;autoflush&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;no_autoflush&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;info&quot;</span><span class="s3">,</span>
    <span class="s3">],</span>
<span class="s3">)</span>
<span class="s2">class </span><span class="s1">scoped_session</span><span class="s3">(</span><span class="s1">Generic</span><span class="s3">[</span><span class="s1">_S</span><span class="s3">]):</span>
    <span class="s5">&quot;&quot;&quot;Provides scoped management of :class:`.Session` objects. 
 
    See :ref:`unitofwork_contextual` for a tutorial. 
 
    .. note:: 
 
       When using :ref:`asyncio_toplevel`, the async-compatible 
       :class:`_asyncio.async_scoped_session` class should be 
       used in place of :class:`.scoped_session`. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_support_async</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s1">session_factory</span><span class="s3">: </span><span class="s1">sessionmaker</span><span class="s3">[</span><span class="s1">_S</span><span class="s3">]</span>
    <span class="s4">&quot;&quot;&quot;The `session_factory` provided to `__init__` is stored in this 
    attribute and may be accessed at a later time.  This can be useful when 
    a new non-scoped :class:`.Session` is needed.&quot;&quot;&quot;</span>

    <span class="s1">registry</span><span class="s3">: </span><span class="s1">ScopedRegistry</span><span class="s3">[</span><span class="s1">_S</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">session_factory</span><span class="s3">: </span><span class="s1">sessionmaker</span><span class="s3">[</span><span class="s1">_S</span><span class="s3">],</span>
        <span class="s1">scopefunc</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Callable</span><span class="s3">[[], </span><span class="s1">Any</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot;Construct a new :class:`.scoped_session`. 
 
        :param session_factory: a factory to create new :class:`.Session` 
         instances. This is usually, but not necessarily, an instance 
         of :class:`.sessionmaker`. 
        :param scopefunc: optional function which defines 
         the current scope.   If not passed, the :class:`.scoped_session` 
         object assumes &quot;thread-local&quot; scope, and will use 
         a Python ``threading.local()`` in order to maintain the current 
         :class:`.Session`.  If passed, the function should return 
         a hashable token; this token will be used as the key in a 
         dictionary in order to store and retrieve the current 
         :class:`.Session`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">session_factory </span><span class="s3">= </span><span class="s1">session_factory</span>

        <span class="s2">if </span><span class="s1">scopefunc</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">registry </span><span class="s3">= </span><span class="s1">ScopedRegistry</span><span class="s3">(</span><span class="s1">session_factory</span><span class="s3">, </span><span class="s1">scopefunc</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">registry </span><span class="s3">= </span><span class="s1">ThreadLocalRegistry</span><span class="s3">(</span><span class="s1">session_factory</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">_proxied</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; _S</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">registry</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, **</span><span class="s1">kw</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; _S</span><span class="s3">:</span>
        <span class="s5">r&quot;&quot;&quot;Return the current :class:`.Session`, creating it 
        using the :attr:`.scoped_session.session_factory` if not present. 
 
        :param \**kw: Keyword arguments will be passed to the 
         :attr:`.scoped_session.session_factory` callable, if an existing 
         :class:`.Session` is not present.  If the :class:`.Session` is present 
         and keyword arguments have been passed, 
         :exc:`~sqlalchemy.exc.InvalidRequestError` is raised. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">kw</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">registry</span><span class="s3">.</span><span class="s1">has</span><span class="s3">():</span>
                <span class="s2">raise </span><span class="s1">sa_exc</span><span class="s3">.</span><span class="s1">InvalidRequestError</span><span class="s3">(</span>
                    <span class="s4">&quot;Scoped session is already present; &quot;</span>
                    <span class="s4">&quot;no new arguments may be specified.&quot;</span>
                <span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">sess </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">session_factory</span><span class="s3">(**</span><span class="s1">kw</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">registry</span><span class="s3">.</span><span class="s1">set</span><span class="s3">(</span><span class="s1">sess</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">sess </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">registry</span><span class="s3">()</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_support_async </span><span class="s2">and </span><span class="s1">sess</span><span class="s3">.</span><span class="s1">_is_asyncio</span><span class="s3">:</span>
            <span class="s1">warn_deprecated</span><span class="s3">(</span>
                <span class="s4">&quot;Using `scoped_session` with asyncio is deprecated and &quot;</span>
                <span class="s4">&quot;will raise an error in a future version. &quot;</span>
                <span class="s4">&quot;Please use `async_scoped_session` instead.&quot;</span><span class="s3">,</span>
                <span class="s4">&quot;1.4.23&quot;</span><span class="s3">,</span>
            <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">sess</span>

    <span class="s2">def </span><span class="s1">configure</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;reconfigure the :class:`.sessionmaker` used by this 
        :class:`.scoped_session`. 
 
        See :meth:`.sessionmaker.configure`. 
 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">registry</span><span class="s3">.</span><span class="s1">has</span><span class="s3">():</span>
            <span class="s1">warn</span><span class="s3">(</span>
                <span class="s4">&quot;At least one scoped session is already present. &quot;</span>
                <span class="s4">&quot; configure() can not affect sessions that have &quot;</span>
                <span class="s4">&quot;already been created.&quot;</span>
            <span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">session_factory</span><span class="s3">.</span><span class="s1">configure</span><span class="s3">(**</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">remove</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;Dispose of the current :class:`.Session`, if present. 
 
        This will first call :meth:`.Session.close` method 
        on the current :class:`.Session`, which releases any existing 
        transactional/connection resources still being held; transactions 
        specifically are rolled back.  The :class:`.Session` is then 
        discarded.   Upon next usage within the same scope, 
        the :class:`.scoped_session` will produce a new 
        :class:`.Session` object. 
 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">registry</span><span class="s3">.</span><span class="s1">has</span><span class="s3">():</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">registry</span><span class="s3">().</span><span class="s1">close</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">registry</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">query_property</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">query_cls</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Type</span><span class="s3">[</span><span class="s1">Query</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]]] = </span><span class="s2">None</span>
    <span class="s3">) </span><span class="s1">-&gt; QueryPropertyDescriptor</span><span class="s3">:</span>
        <span class="s5">&quot;&quot;&quot;return a class property which produces a legacy 
        :class:`_query.Query` object against the class and the current 
        :class:`.Session` when called. 
 
        .. legacy:: The :meth:`_orm.scoped_session.query_property` accessor 
           is specific to the legacy :class:`.Query` object and is not 
           considered to be part of :term:`2.0-style` ORM use. 
 
        e.g.:: 
 
            from sqlalchemy.orm import QueryPropertyDescriptor 
            from sqlalchemy.orm import scoped_session 
            from sqlalchemy.orm import sessionmaker 
 
            Session = scoped_session(sessionmaker()) 
 
            class MyClass: 
                query: QueryPropertyDescriptor = Session.query_property() 
 
            # after mappers are defined 
            result = MyClass.query.filter(MyClass.name=='foo').all() 
 
        Produces instances of the session's configured query class by 
        default.  To override and use a custom implementation, provide 
        a ``query_cls`` callable.  The callable will be invoked with 
        the class's mapper as a positional argument and a session 
        keyword argument. 
 
        There is no limit to the number of query properties placed on 
        a class. 
 
        &quot;&quot;&quot;</span>

        <span class="s2">class </span><span class="s1">query</span><span class="s3">:</span>
            <span class="s2">def </span><span class="s1">__get__</span><span class="s3">(</span><span class="s1">s</span><span class="s3">, </span><span class="s1">instance</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">owner</span><span class="s3">: </span><span class="s1">Type</span><span class="s3">[</span><span class="s1">_O</span><span class="s3">]) </span><span class="s1">-&gt; Query</span><span class="s3">[</span><span class="s1">_O</span><span class="s3">]:</span>
                <span class="s2">if </span><span class="s1">query_cls</span><span class="s3">:</span>
                    <span class="s0"># custom query class</span>
                    <span class="s2">return </span><span class="s1">query_cls</span><span class="s3">(</span><span class="s1">owner</span><span class="s3">, </span><span class="s1">session</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">registry</span><span class="s3">())  </span><span class="s0"># type: ignore  # noqa: E501</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s0"># session's configured query class</span>
                    <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">registry</span><span class="s3">().</span><span class="s1">query</span><span class="s3">(</span><span class="s1">owner</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">query</span><span class="s3">()</span>

    <span class="s0"># START PROXY METHODS scoped_session</span>

    <span class="s0"># code within this block is **programmatically,</span>
    <span class="s0"># statically generated** by tools/generate_proxy_methods.py</span>

    <span class="s2">def </span><span class="s1">__contains__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">instance</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Return True if the instance is associated with this session. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        The instance may be pending or persistent within the Session for a 
        result of True. 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">__contains__</span><span class="s3">(</span><span class="s1">instance</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__iter__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Iterator</span><span class="s3">[</span><span class="s1">object</span><span class="s3">]:</span>
        <span class="s4">r&quot;&quot;&quot;Iterate over all pending or persistent instances within this 
        Session. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">__iter__</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">add</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">instance</span><span class="s3">: </span><span class="s1">object</span><span class="s3">, </span><span class="s1">_warn</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Place an object into this :class:`_orm.Session`. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        Objects that are in the :term:`transient` state when passed to the 
        :meth:`_orm.Session.add` method will move to the 
        :term:`pending` state, until the next flush, at which point they 
        will move to the :term:`persistent` state. 
 
        Objects that are in the :term:`detached` state when passed to the 
        :meth:`_orm.Session.add` method will move to the :term:`persistent` 
        state directly. 
 
        If the transaction used by the :class:`_orm.Session` is rolled back, 
        objects which were transient when they were passed to 
        :meth:`_orm.Session.add` will be moved back to the 
        :term:`transient` state, and will no longer be present within this 
        :class:`_orm.Session`. 
 
        .. seealso:: 
 
            :meth:`_orm.Session.add_all` 
 
            :ref:`session_adding` - at :ref:`session_basics` 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">instance</span><span class="s3">, </span><span class="s1">_warn</span><span class="s3">=</span><span class="s1">_warn</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">add_all</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">instances</span><span class="s3">: </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">object</span><span class="s3">]) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Add the given collection of instances to this :class:`_orm.Session`. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        See the documentation for :meth:`_orm.Session.add` for a general 
        behavioral description. 
 
        .. seealso:: 
 
            :meth:`_orm.Session.add` 
 
            :ref:`session_adding` - at :ref:`session_basics` 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">add_all</span><span class="s3">(</span><span class="s1">instances</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">begin</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">nested</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">) </span><span class="s1">-&gt; SessionTransaction</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Begin a transaction, or nested transaction, 
        on this :class:`.Session`, if one is not already begun. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        The :class:`_orm.Session` object features **autobegin** behavior, 
        so that normally it is not necessary to call the 
        :meth:`_orm.Session.begin` 
        method explicitly. However, it may be used in order to control 
        the scope of when the transactional state is begun. 
 
        When used to begin the outermost transaction, an error is raised 
        if this :class:`.Session` is already inside of a transaction. 
 
        :param nested: if True, begins a SAVEPOINT transaction and is 
         equivalent to calling :meth:`~.Session.begin_nested`. For 
         documentation on SAVEPOINT transactions, please see 
         :ref:`session_begin_nested`. 
 
        :return: the :class:`.SessionTransaction` object.  Note that 
         :class:`.SessionTransaction` 
         acts as a Python context manager, allowing :meth:`.Session.begin` 
         to be used in a &quot;with&quot; block.  See :ref:`session_explicit_begin` for 
         an example. 
 
        .. seealso:: 
 
            :ref:`session_autobegin` 
 
            :ref:`unitofwork_transaction` 
 
            :meth:`.Session.begin_nested` 
 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">begin</span><span class="s3">(</span><span class="s1">nested</span><span class="s3">=</span><span class="s1">nested</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">begin_nested</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; SessionTransaction</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Begin a &quot;nested&quot; transaction on this Session, e.g. SAVEPOINT. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        The target database(s) and associated drivers must support SQL 
        SAVEPOINT for this method to function correctly. 
 
        For documentation on SAVEPOINT 
        transactions, please see :ref:`session_begin_nested`. 
 
        :return: the :class:`.SessionTransaction` object.  Note that 
         :class:`.SessionTransaction` acts as a context manager, allowing 
         :meth:`.Session.begin_nested` to be used in a &quot;with&quot; block. 
         See :ref:`session_begin_nested` for a usage example. 
 
        .. seealso:: 
 
            :ref:`session_begin_nested` 
 
            :ref:`pysqlite_serializable` - special workarounds required 
            with the SQLite driver in order for SAVEPOINT to work 
            correctly. For asyncio use cases, see the section 
            :ref:`aiosqlite_serializable`. 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">begin_nested</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">close</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Close out the transactional resources and ORM objects used by this 
        :class:`_orm.Session`. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        This expunges all ORM objects associated with this 
        :class:`_orm.Session`, ends any transaction in progress and 
        :term:`releases` any :class:`_engine.Connection` objects which this 
        :class:`_orm.Session` itself has checked out from associated 
        :class:`_engine.Engine` objects. The operation then leaves the 
        :class:`_orm.Session` in a state which it may be used again. 
 
        .. tip:: 
 
            In the default running mode the :meth:`_orm.Session.close` 
            method **does not prevent the Session from being used again**. 
            The :class:`_orm.Session` itself does not actually have a 
            distinct &quot;closed&quot; state; it merely means 
            the :class:`_orm.Session` will release all database connections 
            and ORM objects. 
 
            Setting the parameter :paramref:`_orm.Session.close_resets_only` 
            to ``False`` will instead make the ``close`` final, meaning that 
            any further action on the session will be forbidden. 
 
        .. versionchanged:: 1.4  The :meth:`.Session.close` method does not 
           immediately create a new :class:`.SessionTransaction` object; 
           instead, the new :class:`.SessionTransaction` is created only if 
           the :class:`.Session` is used again for a database operation. 
 
        .. seealso:: 
 
            :ref:`session_closing` - detail on the semantics of 
            :meth:`_orm.Session.close` and :meth:`_orm.Session.reset`. 
 
            :meth:`_orm.Session.reset` - a similar method that behaves like 
            ``close()`` with  the parameter 
            :paramref:`_orm.Session.close_resets_only` set to ``True``. 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">reset</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Close out the transactional resources and ORM objects used by this 
        :class:`_orm.Session`, resetting the session to its initial state. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        This method provides for same &quot;reset-only&quot; behavior that the 
        :meth:`_orm.Session.close` method has provided historically, where the 
        state of the :class:`_orm.Session` is reset as though the object were 
        brand new, and ready to be used again. 
        This method may then be useful for :class:`_orm.Session` objects 
        which set :paramref:`_orm.Session.close_resets_only` to ``False``, 
        so that &quot;reset only&quot; behavior is still available. 
 
        .. versionadded:: 2.0.22 
 
        .. seealso:: 
 
            :ref:`session_closing` - detail on the semantics of 
            :meth:`_orm.Session.close` and :meth:`_orm.Session.reset`. 
 
            :meth:`_orm.Session.close` - a similar method will additionally 
            prevent re-use of the Session when the parameter 
            :paramref:`_orm.Session.close_resets_only` is set to ``False``. 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">reset</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">commit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Flush pending changes and commit the current transaction. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        When the COMMIT operation is complete, all objects are fully 
        :term:`expired`, erasing their internal contents, which will be 
        automatically re-loaded when the objects are next accessed. In the 
        interim, these objects are in an expired state and will not function if 
        they are :term:`detached` from the :class:`.Session`. Additionally, 
        this re-load operation is not supported when using asyncio-oriented 
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used 
        to disable this behavior. 
 
        When there is no transaction in place for the :class:`.Session`, 
        indicating that no operations were invoked on this :class:`.Session` 
        since the previous call to :meth:`.Session.commit`, the method will 
        begin and commit an internal-only &quot;logical&quot; transaction, that does not 
        normally affect the database unless pending flush changes were 
        detected, but will still invoke event handlers and object expiration 
        rules. 
 
        The outermost database transaction is committed unconditionally, 
        automatically releasing any SAVEPOINTs in effect. 
 
        .. seealso:: 
 
            :ref:`session_committing` 
 
            :ref:`unitofwork_transaction` 
 
            :ref:`asyncio_orm_avoid_lazyloads` 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">commit</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">connection</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">bind_arguments</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_BindArguments</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">execution_options</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">CoreExecuteOptionsParameter</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Connection</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Return a :class:`_engine.Connection` object corresponding to this 
        :class:`.Session` object's transactional state. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        Either the :class:`_engine.Connection` corresponding to the current 
        transaction is returned, or if no transaction is in progress, a new 
        one is begun and the :class:`_engine.Connection` 
        returned (note that no 
        transactional state is established with the DBAPI until the first 
        SQL statement is emitted). 
 
        Ambiguity in multi-bind or unbound :class:`.Session` objects can be 
        resolved through any of the optional keyword arguments.   This 
        ultimately makes usage of the :meth:`.get_bind` method for resolution. 
 
        :param bind_arguments: dictionary of bind arguments.  May include 
         &quot;mapper&quot;, &quot;bind&quot;, &quot;clause&quot;, other custom arguments that are passed 
         to :meth:`.Session.get_bind`. 
 
        :param execution_options: a dictionary of execution options that will 
         be passed to :meth:`_engine.Connection.execution_options`, **when the 
         connection is first procured only**.   If the connection is already 
         present within the :class:`.Session`, a warning is emitted and 
         the arguments are ignored. 
 
         .. seealso:: 
 
            :ref:`session_transaction_isolation` 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">connection</span><span class="s3">(</span>
            <span class="s1">bind_arguments</span><span class="s3">=</span><span class="s1">bind_arguments</span><span class="s3">, </span><span class="s1">execution_options</span><span class="s3">=</span><span class="s1">execution_options</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">delete</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">instance</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Mark an instance as deleted. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        The object is assumed to be either :term:`persistent` or 
        :term:`detached` when passed; after the method is called, the 
        object will remain in the :term:`persistent` state until the next 
        flush proceeds.  During this time, the object will also be a member 
        of the :attr:`_orm.Session.deleted` collection. 
 
        When the next flush proceeds, the object will move to the 
        :term:`deleted` state, indicating a ``DELETE`` statement was emitted 
        for its row within the current transaction.   When the transaction 
        is successfully committed, 
        the deleted object is moved to the :term:`detached` state and is 
        no longer present within this :class:`_orm.Session`. 
 
        .. seealso:: 
 
            :ref:`session_deleting` - at :ref:`session_basics` 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">delete</span><span class="s3">(</span><span class="s1">instance</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">execute</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">statement</span><span class="s3">: </span><span class="s1">TypedReturnsRows</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">],</span>
        <span class="s1">params</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">execution_options</span><span class="s3">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s3">= </span><span class="s1">util</span><span class="s3">.</span><span class="s1">EMPTY_DICT</span><span class="s3">,</span>
        <span class="s1">bind_arguments</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_BindArguments</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">_parent_execute_state</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">_add_event</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Result</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">execute</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">statement</span><span class="s3">: </span><span class="s1">UpdateBase</span><span class="s3">,</span>
        <span class="s1">params</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">execution_options</span><span class="s3">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s3">= </span><span class="s1">util</span><span class="s3">.</span><span class="s1">EMPTY_DICT</span><span class="s3">,</span>
        <span class="s1">bind_arguments</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_BindArguments</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">_parent_execute_state</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">_add_event</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; CursorResult</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">execute</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">statement</span><span class="s3">: </span><span class="s1">Executable</span><span class="s3">,</span>
        <span class="s1">params</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">execution_options</span><span class="s3">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s3">= </span><span class="s1">util</span><span class="s3">.</span><span class="s1">EMPTY_DICT</span><span class="s3">,</span>
        <span class="s1">bind_arguments</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_BindArguments</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">_parent_execute_state</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">_add_event</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Result</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]: ...</span>

    <span class="s2">def </span><span class="s1">execute</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">statement</span><span class="s3">: </span><span class="s1">Executable</span><span class="s3">,</span>
        <span class="s1">params</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">execution_options</span><span class="s3">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s3">= </span><span class="s1">util</span><span class="s3">.</span><span class="s1">EMPTY_DICT</span><span class="s3">,</span>
        <span class="s1">bind_arguments</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_BindArguments</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">_parent_execute_state</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">_add_event</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Result</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]:</span>
        <span class="s4">r&quot;&quot;&quot;Execute a SQL expression construct. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        Returns a :class:`_engine.Result` object representing 
        results of the statement execution. 
 
        E.g.:: 
 
            from sqlalchemy import select 
            result = session.execute( 
                select(User).where(User.id == 5) 
            ) 
 
        The API contract of :meth:`_orm.Session.execute` is similar to that 
        of :meth:`_engine.Connection.execute`, the :term:`2.0 style` version 
        of :class:`_engine.Connection`. 
 
        .. versionchanged:: 1.4 the :meth:`_orm.Session.execute` method is 
           now the primary point of ORM statement execution when using 
           :term:`2.0 style` ORM usage. 
 
        :param statement: 
            An executable statement (i.e. an :class:`.Executable` expression 
            such as :func:`_expression.select`). 
 
        :param params: 
            Optional dictionary, or list of dictionaries, containing 
            bound parameter values.   If a single dictionary, single-row 
            execution occurs; if a list of dictionaries, an 
            &quot;executemany&quot; will be invoked.  The keys in each dictionary 
            must correspond to parameter names present in the statement. 
 
        :param execution_options: optional dictionary of execution options, 
         which will be associated with the statement execution.  This 
         dictionary can provide a subset of the options that are accepted 
         by :meth:`_engine.Connection.execution_options`, and may also 
         provide additional options understood only in an ORM context. 
 
         .. seealso:: 
 
            :ref:`orm_queryguide_execution_options` - ORM-specific execution 
            options 
 
        :param bind_arguments: dictionary of additional arguments to determine 
         the bind.  May include &quot;mapper&quot;, &quot;bind&quot;, or other custom arguments. 
         Contents of this dictionary are passed to the 
         :meth:`.Session.get_bind` method. 
 
        :return: a :class:`_engine.Result` object. 
 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">execute</span><span class="s3">(</span>
            <span class="s1">statement</span><span class="s3">,</span>
            <span class="s1">params</span><span class="s3">=</span><span class="s1">params</span><span class="s3">,</span>
            <span class="s1">execution_options</span><span class="s3">=</span><span class="s1">execution_options</span><span class="s3">,</span>
            <span class="s1">bind_arguments</span><span class="s3">=</span><span class="s1">bind_arguments</span><span class="s3">,</span>
            <span class="s1">_parent_execute_state</span><span class="s3">=</span><span class="s1">_parent_execute_state</span><span class="s3">,</span>
            <span class="s1">_add_event</span><span class="s3">=</span><span class="s1">_add_event</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">expire</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">instance</span><span class="s3">: </span><span class="s1">object</span><span class="s3">, </span><span class="s1">attribute_names</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]] = </span><span class="s2">None</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Expire the attributes on an instance. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        Marks the attributes of an instance as out of date. When an expired 
        attribute is next accessed, a query will be issued to the 
        :class:`.Session` object's current transactional context in order to 
        load all expired attributes for the given instance.   Note that 
        a highly isolated transaction will return the same values as were 
        previously read in that same transaction, regardless of changes 
        in database state outside of that transaction. 
 
        To expire all objects in the :class:`.Session` simultaneously, 
        use :meth:`Session.expire_all`. 
 
        The :class:`.Session` object's default behavior is to 
        expire all state whenever the :meth:`Session.rollback` 
        or :meth:`Session.commit` methods are called, so that new 
        state can be loaded for the new transaction.   For this reason, 
        calling :meth:`Session.expire` only makes sense for the specific 
        case that a non-ORM SQL statement was emitted in the current 
        transaction. 
 
        :param instance: The instance to be refreshed. 
        :param attribute_names: optional list of string attribute names 
          indicating a subset of attributes to be expired. 
 
        .. seealso:: 
 
            :ref:`session_expire` - introductory material 
 
            :meth:`.Session.expire` 
 
            :meth:`.Session.refresh` 
 
            :meth:`_orm.Query.populate_existing` 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">expire</span><span class="s3">(</span><span class="s1">instance</span><span class="s3">, </span><span class="s1">attribute_names</span><span class="s3">=</span><span class="s1">attribute_names</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">expire_all</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Expires all persistent instances within this Session. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        When any attributes on a persistent instance is next accessed, 
        a query will be issued using the 
        :class:`.Session` object's current transactional context in order to 
        load all expired attributes for the given instance.   Note that 
        a highly isolated transaction will return the same values as were 
        previously read in that same transaction, regardless of changes 
        in database state outside of that transaction. 
 
        To expire individual objects and individual attributes 
        on those objects, use :meth:`Session.expire`. 
 
        The :class:`.Session` object's default behavior is to 
        expire all state whenever the :meth:`Session.rollback` 
        or :meth:`Session.commit` methods are called, so that new 
        state can be loaded for the new transaction.   For this reason, 
        calling :meth:`Session.expire_all` is not usually needed, 
        assuming the transaction is isolated. 
 
        .. seealso:: 
 
            :ref:`session_expire` - introductory material 
 
            :meth:`.Session.expire` 
 
            :meth:`.Session.refresh` 
 
            :meth:`_orm.Query.populate_existing` 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">expire_all</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">expunge</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">instance</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Remove the `instance` from this ``Session``. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        This will free all internal references to the instance.  Cascading 
        will be applied according to the *expunge* cascade rule. 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">expunge</span><span class="s3">(</span><span class="s1">instance</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">expunge_all</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Remove all object instances from this ``Session``. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        This is equivalent to calling ``expunge(obj)`` on all objects in this 
        ``Session``. 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">expunge_all</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">flush</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">objects</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Flush all the object changes to the database. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        Writes out all pending object creations, deletions and modifications 
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are 
        automatically ordered by the Session's unit of work dependency 
        solver. 
 
        Database operations will be issued in the current transactional 
        context and do not affect the state of the transaction, unless an 
        error occurs, in which case the entire transaction is rolled back. 
        You may flush() as often as you like within a transaction to move 
        changes from Python to the database's transaction buffer. 
 
        :param objects: Optional; restricts the flush operation to operate 
          only on elements that are in the given collection. 
 
          This feature is for an extremely narrow set of use cases where 
          particular objects may need to be operated upon before the 
          full flush() occurs.  It is not intended for general use. 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">flush</span><span class="s3">(</span><span class="s1">objects</span><span class="s3">=</span><span class="s1">objects</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">entity</span><span class="s3">: </span><span class="s1">_EntityBindKey</span><span class="s3">[</span><span class="s1">_O</span><span class="s3">],</span>
        <span class="s1">ident</span><span class="s3">: </span><span class="s1">_PKIdentityArgument</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">options</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">ORMOption</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">populate_existing</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">with_for_update</span><span class="s3">: </span><span class="s1">ForUpdateParameter </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">identity_token</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">execution_options</span><span class="s3">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s3">= </span><span class="s1">util</span><span class="s3">.</span><span class="s1">EMPTY_DICT</span><span class="s3">,</span>
        <span class="s1">bind_arguments</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_BindArguments</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">_O</span><span class="s3">]:</span>
        <span class="s4">r&quot;&quot;&quot;Return an instance based on the given primary key identifier, 
        or ``None`` if not found. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        E.g.:: 
 
            my_user = session.get(User, 5) 
 
            some_object = session.get(VersionedFoo, (5, 10)) 
 
            some_object = session.get( 
                VersionedFoo, 
                {&quot;id&quot;: 5, &quot;version_id&quot;: 10} 
            ) 
 
        .. versionadded:: 1.4 Added :meth:`_orm.Session.get`, which is moved 
           from the now legacy :meth:`_orm.Query.get` method. 
 
        :meth:`_orm.Session.get` is special in that it provides direct 
        access to the identity map of the :class:`.Session`. 
        If the given primary key identifier is present 
        in the local identity map, the object is returned 
        directly from this collection and no SQL is emitted, 
        unless the object has been marked fully expired. 
        If not present, 
        a SELECT is performed in order to locate the object. 
 
        :meth:`_orm.Session.get` also will perform a check if 
        the object is present in the identity map and 
        marked as expired - a SELECT 
        is emitted to refresh the object as well as to 
        ensure that the row is still present. 
        If not, :class:`~sqlalchemy.orm.exc.ObjectDeletedError` is raised. 
 
        :param entity: a mapped class or :class:`.Mapper` indicating the 
         type of entity to be loaded. 
 
        :param ident: A scalar, tuple, or dictionary representing the 
         primary key.  For a composite (e.g. multiple column) primary key, 
         a tuple or dictionary should be passed. 
 
         For a single-column primary key, the scalar calling form is typically 
         the most expedient.  If the primary key of a row is the value &quot;5&quot;, 
         the call looks like:: 
 
            my_object = session.get(SomeClass, 5) 
 
         The tuple form contains primary key values typically in 
         the order in which they correspond to the mapped 
         :class:`_schema.Table` 
         object's primary key columns, or if the 
         :paramref:`_orm.Mapper.primary_key` configuration parameter were 
         used, in 
         the order used for that parameter. For example, if the primary key 
         of a row is represented by the integer 
         digits &quot;5, 10&quot; the call would look like:: 
 
             my_object = session.get(SomeClass, (5, 10)) 
 
         The dictionary form should include as keys the mapped attribute names 
         corresponding to each element of the primary key.  If the mapped class 
         has the attributes ``id``, ``version_id`` as the attributes which 
         store the object's primary key value, the call would look like:: 
 
            my_object = session.get(SomeClass, {&quot;id&quot;: 5, &quot;version_id&quot;: 10}) 
 
        :param options: optional sequence of loader options which will be 
         applied to the query, if one is emitted. 
 
        :param populate_existing: causes the method to unconditionally emit 
         a SQL query and refresh the object with the newly loaded data, 
         regardless of whether or not the object is already present. 
 
        :param with_for_update: optional boolean ``True`` indicating FOR UPDATE 
          should be used, or may be a dictionary containing flags to 
          indicate a more specific set of FOR UPDATE flags for the SELECT; 
          flags should match the parameters of 
          :meth:`_query.Query.with_for_update`. 
          Supersedes the :paramref:`.Session.refresh.lockmode` parameter. 
 
        :param execution_options: optional dictionary of execution options, 
         which will be associated with the query execution if one is emitted. 
         This dictionary can provide a subset of the options that are 
         accepted by :meth:`_engine.Connection.execution_options`, and may 
         also provide additional options understood only in an ORM context. 
 
         .. versionadded:: 1.4.29 
 
         .. seealso:: 
 
            :ref:`orm_queryguide_execution_options` - ORM-specific execution 
            options 
 
        :param bind_arguments: dictionary of additional arguments to determine 
         the bind.  May include &quot;mapper&quot;, &quot;bind&quot;, or other custom arguments. 
         Contents of this dictionary are passed to the 
         :meth:`.Session.get_bind` method. 
 
         .. versionadded: 2.0.0rc1 
 
        :return: The object instance, or ``None``. 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span>
            <span class="s1">entity</span><span class="s3">,</span>
            <span class="s1">ident</span><span class="s3">,</span>
            <span class="s1">options</span><span class="s3">=</span><span class="s1">options</span><span class="s3">,</span>
            <span class="s1">populate_existing</span><span class="s3">=</span><span class="s1">populate_existing</span><span class="s3">,</span>
            <span class="s1">with_for_update</span><span class="s3">=</span><span class="s1">with_for_update</span><span class="s3">,</span>
            <span class="s1">identity_token</span><span class="s3">=</span><span class="s1">identity_token</span><span class="s3">,</span>
            <span class="s1">execution_options</span><span class="s3">=</span><span class="s1">execution_options</span><span class="s3">,</span>
            <span class="s1">bind_arguments</span><span class="s3">=</span><span class="s1">bind_arguments</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_one</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">entity</span><span class="s3">: </span><span class="s1">_EntityBindKey</span><span class="s3">[</span><span class="s1">_O</span><span class="s3">],</span>
        <span class="s1">ident</span><span class="s3">: </span><span class="s1">_PKIdentityArgument</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">options</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">ORMOption</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">populate_existing</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">with_for_update</span><span class="s3">: </span><span class="s1">ForUpdateParameter </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">identity_token</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">execution_options</span><span class="s3">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s3">= </span><span class="s1">util</span><span class="s3">.</span><span class="s1">EMPTY_DICT</span><span class="s3">,</span>
        <span class="s1">bind_arguments</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_BindArguments</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; _O</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Return exactly one instance based on the given primary key 
        identifier, or raise an exception if not found. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        Raises ``sqlalchemy.orm.exc.NoResultFound`` if the query 
        selects no rows. 
 
        For a detailed documentation of the arguments see the 
        method :meth:`.Session.get`. 
 
        .. versionadded:: 2.0.22 
 
        :return: The object instance. 
 
        .. seealso:: 
 
            :meth:`.Session.get` - equivalent method that instead 
              returns ``None`` if no row was found with the provided primary 
              key 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">get_one</span><span class="s3">(</span>
            <span class="s1">entity</span><span class="s3">,</span>
            <span class="s1">ident</span><span class="s3">,</span>
            <span class="s1">options</span><span class="s3">=</span><span class="s1">options</span><span class="s3">,</span>
            <span class="s1">populate_existing</span><span class="s3">=</span><span class="s1">populate_existing</span><span class="s3">,</span>
            <span class="s1">with_for_update</span><span class="s3">=</span><span class="s1">with_for_update</span><span class="s3">,</span>
            <span class="s1">identity_token</span><span class="s3">=</span><span class="s1">identity_token</span><span class="s3">,</span>
            <span class="s1">execution_options</span><span class="s3">=</span><span class="s1">execution_options</span><span class="s3">,</span>
            <span class="s1">bind_arguments</span><span class="s3">=</span><span class="s1">bind_arguments</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_bind</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">mapper</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_EntityBindKey</span><span class="s3">[</span><span class="s1">_O</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">clause</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">ClauseElement</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">bind</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_SessionBind</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">_sa_skip_events</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">_sa_skip_for_implicit_returning</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kw</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Union</span><span class="s3">[</span><span class="s1">Engine</span><span class="s3">, </span><span class="s1">Connection</span><span class="s3">]:</span>
        <span class="s4">r&quot;&quot;&quot;Return a &quot;bind&quot; to which this :class:`.Session` is bound. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        The &quot;bind&quot; is usually an instance of :class:`_engine.Engine`, 
        except in the case where the :class:`.Session` has been 
        explicitly bound directly to a :class:`_engine.Connection`. 
 
        For a multiply-bound or unbound :class:`.Session`, the 
        ``mapper`` or ``clause`` arguments are used to determine the 
        appropriate bind to return. 
 
        Note that the &quot;mapper&quot; argument is usually present 
        when :meth:`.Session.get_bind` is called via an ORM 
        operation such as a :meth:`.Session.query`, each 
        individual INSERT/UPDATE/DELETE operation within a 
        :meth:`.Session.flush`, call, etc. 
 
        The order of resolution is: 
 
        1. if mapper given and :paramref:`.Session.binds` is present, 
           locate a bind based first on the mapper in use, then 
           on the mapped class in use, then on any base classes that are 
           present in the ``__mro__`` of the mapped class, from more specific 
           superclasses to more general. 
        2. if clause given and ``Session.binds`` is present, 
           locate a bind based on :class:`_schema.Table` objects 
           found in the given clause present in ``Session.binds``. 
        3. if ``Session.binds`` is present, return that. 
        4. if clause given, attempt to return a bind 
           linked to the :class:`_schema.MetaData` ultimately 
           associated with the clause. 
        5. if mapper given, attempt to return a bind 
           linked to the :class:`_schema.MetaData` ultimately 
           associated with the :class:`_schema.Table` or other 
           selectable to which the mapper is mapped. 
        6. No bind can be found, :exc:`~sqlalchemy.exc.UnboundExecutionError` 
           is raised. 
 
        Note that the :meth:`.Session.get_bind` method can be overridden on 
        a user-defined subclass of :class:`.Session` to provide any kind 
        of bind resolution scheme.  See the example at 
        :ref:`session_custom_partitioning`. 
 
        :param mapper: 
          Optional mapped class or corresponding :class:`_orm.Mapper` instance. 
          The bind can be derived from a :class:`_orm.Mapper` first by 
          consulting the &quot;binds&quot; map associated with this :class:`.Session`, 
          and secondly by consulting the :class:`_schema.MetaData` associated 
          with the :class:`_schema.Table` to which the :class:`_orm.Mapper` is 
          mapped for a bind. 
 
        :param clause: 
            A :class:`_expression.ClauseElement` (i.e. 
            :func:`_expression.select`, 
            :func:`_expression.text`, 
            etc.).  If the ``mapper`` argument is not present or could not 
            produce a bind, the given expression construct will be searched 
            for a bound element, typically a :class:`_schema.Table` 
            associated with 
            bound :class:`_schema.MetaData`. 
 
        .. seealso:: 
 
             :ref:`session_partitioning` 
 
             :paramref:`.Session.binds` 
 
             :meth:`.Session.bind_mapper` 
 
             :meth:`.Session.bind_table` 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">get_bind</span><span class="s3">(</span>
            <span class="s1">mapper</span><span class="s3">=</span><span class="s1">mapper</span><span class="s3">,</span>
            <span class="s1">clause</span><span class="s3">=</span><span class="s1">clause</span><span class="s3">,</span>
            <span class="s1">bind</span><span class="s3">=</span><span class="s1">bind</span><span class="s3">,</span>
            <span class="s1">_sa_skip_events</span><span class="s3">=</span><span class="s1">_sa_skip_events</span><span class="s3">,</span>
            <span class="s1">_sa_skip_for_implicit_returning</span><span class="s3">=</span><span class="s1">_sa_skip_for_implicit_returning</span><span class="s3">,</span>
            <span class="s3">**</span><span class="s1">kw</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">is_modified</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">instance</span><span class="s3">: </span><span class="s1">object</span><span class="s3">, </span><span class="s1">include_collections</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span>
    <span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Return ``True`` if the given instance has locally 
        modified attributes. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        This method retrieves the history for each instrumented 
        attribute on the instance and performs a comparison of the current 
        value to its previously flushed or committed value, if any. 
 
        It is in effect a more expensive and accurate 
        version of checking for the given instance in the 
        :attr:`.Session.dirty` collection; a full test for 
        each attribute's net &quot;dirty&quot; status is performed. 
 
        E.g.:: 
 
            return session.is_modified(someobject) 
 
        A few caveats to this method apply: 
 
        * Instances present in the :attr:`.Session.dirty` collection may 
          report ``False`` when tested with this method.  This is because 
          the object may have received change events via attribute mutation, 
          thus placing it in :attr:`.Session.dirty`, but ultimately the state 
          is the same as that loaded from the database, resulting in no net 
          change here. 
        * Scalar attributes may not have recorded the previously set 
          value when a new value was applied, if the attribute was not loaded, 
          or was expired, at the time the new value was received - in these 
          cases, the attribute is assumed to have a change, even if there is 
          ultimately no net change against its database value. SQLAlchemy in 
          most cases does not need the &quot;old&quot; value when a set event occurs, so 
          it skips the expense of a SQL call if the old value isn't present, 
          based on the assumption that an UPDATE of the scalar value is 
          usually needed, and in those few cases where it isn't, is less 
          expensive on average than issuing a defensive SELECT. 
 
          The &quot;old&quot; value is fetched unconditionally upon set only if the 
          attribute container has the ``active_history`` flag set to ``True``. 
          This flag is set typically for primary key attributes and scalar 
          object references that are not a simple many-to-one.  To set this 
          flag for any arbitrary mapped column, use the ``active_history`` 
          argument with :func:`.column_property`. 
 
        :param instance: mapped instance to be tested for pending changes. 
        :param include_collections: Indicates if multivalued collections 
         should be included in the operation.  Setting this to ``False`` is a 
         way to detect only local-column based properties (i.e. scalar columns 
         or many-to-one foreign keys) that would result in an UPDATE for this 
         instance upon flush. 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">is_modified</span><span class="s3">(</span>
            <span class="s1">instance</span><span class="s3">, </span><span class="s1">include_collections</span><span class="s3">=</span><span class="s1">include_collections</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">bulk_save_objects</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">objects</span><span class="s3">: </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">object</span><span class="s3">],</span>
        <span class="s1">return_defaults</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">update_changed_only</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">preserve_order</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Perform a bulk save of the given list of objects. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        .. legacy:: 
 
            This method is a legacy feature as of the 2.0 series of 
            SQLAlchemy.   For modern bulk INSERT and UPDATE, see 
            the sections :ref:`orm_queryguide_bulk_insert` and 
            :ref:`orm_queryguide_bulk_update`. 
 
            For general INSERT and UPDATE of existing ORM mapped objects, 
            prefer standard :term:`unit of work` data management patterns, 
            introduced in the :ref:`unified_tutorial` at 
            :ref:`tutorial_orm_data_manipulation`.  SQLAlchemy 2.0 
            now uses :ref:`engine_insertmanyvalues` with modern dialects 
            which solves previous issues of bulk INSERT slowness. 
 
        :param objects: a sequence of mapped object instances.  The mapped 
         objects are persisted as is, and are **not** associated with the 
         :class:`.Session` afterwards. 
 
         For each object, whether the object is sent as an INSERT or an 
         UPDATE is dependent on the same rules used by the :class:`.Session` 
         in traditional operation; if the object has the 
         :attr:`.InstanceState.key` 
         attribute set, then the object is assumed to be &quot;detached&quot; and 
         will result in an UPDATE.  Otherwise, an INSERT is used. 
 
         In the case of an UPDATE, statements are grouped based on which 
         attributes have changed, and are thus to be the subject of each 
         SET clause.  If ``update_changed_only`` is False, then all 
         attributes present within each object are applied to the UPDATE 
         statement, which may help in allowing the statements to be grouped 
         together into a larger executemany(), and will also reduce the 
         overhead of checking history on attributes. 
 
        :param return_defaults: when True, rows that are missing values which 
         generate defaults, namely integer primary key defaults and sequences, 
         will be inserted **one at a time**, so that the primary key value 
         is available.  In particular this will allow joined-inheritance 
         and other multi-table mappings to insert correctly without the need 
         to provide primary key values ahead of time; however, 
         :paramref:`.Session.bulk_save_objects.return_defaults` **greatly 
         reduces the performance gains** of the method overall.  It is strongly 
         advised to please use the standard :meth:`_orm.Session.add_all` 
         approach. 
 
        :param update_changed_only: when True, UPDATE statements are rendered 
         based on those attributes in each state that have logged changes. 
         When False, all attributes present are rendered into the SET clause 
         with the exception of primary key attributes. 
 
        :param preserve_order: when True, the order of inserts and updates 
         matches exactly the order in which the objects are given.   When 
         False, common types of objects are grouped into inserts 
         and updates, to allow for more batching opportunities. 
 
        .. seealso:: 
 
            :doc:`queryguide/dml` 
 
            :meth:`.Session.bulk_insert_mappings` 
 
            :meth:`.Session.bulk_update_mappings` 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">bulk_save_objects</span><span class="s3">(</span>
            <span class="s1">objects</span><span class="s3">,</span>
            <span class="s1">return_defaults</span><span class="s3">=</span><span class="s1">return_defaults</span><span class="s3">,</span>
            <span class="s1">update_changed_only</span><span class="s3">=</span><span class="s1">update_changed_only</span><span class="s3">,</span>
            <span class="s1">preserve_order</span><span class="s3">=</span><span class="s1">preserve_order</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">bulk_insert_mappings</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">mapper</span><span class="s3">: </span><span class="s1">Mapper</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">],</span>
        <span class="s1">mappings</span><span class="s3">: </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]],</span>
        <span class="s1">return_defaults</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">render_nulls</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Perform a bulk insert of the given list of mapping dictionaries. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        .. legacy:: 
 
            This method is a legacy feature as of the 2.0 series of 
            SQLAlchemy.   For modern bulk INSERT and UPDATE, see 
            the sections :ref:`orm_queryguide_bulk_insert` and 
            :ref:`orm_queryguide_bulk_update`.  The 2.0 API shares 
            implementation details with this method and adds new features 
            as well. 
 
        :param mapper: a mapped class, or the actual :class:`_orm.Mapper` 
         object, 
         representing the single kind of object represented within the mapping 
         list. 
 
        :param mappings: a sequence of dictionaries, each one containing the 
         state of the mapped row to be inserted, in terms of the attribute 
         names on the mapped class.   If the mapping refers to multiple tables, 
         such as a joined-inheritance mapping, each dictionary must contain all 
         keys to be populated into all tables. 
 
        :param return_defaults: when True, the INSERT process will be altered 
         to ensure that newly generated primary key values will be fetched. 
         The rationale for this parameter is typically to enable 
         :ref:`Joined Table Inheritance &lt;joined_inheritance&gt;` mappings to 
         be bulk inserted. 
 
         .. note:: for backends that don't support RETURNING, the 
            :paramref:`_orm.Session.bulk_insert_mappings.return_defaults` 
            parameter can significantly decrease performance as INSERT 
            statements can no longer be batched.   See 
            :ref:`engine_insertmanyvalues` 
            for background on which backends are affected. 
 
        :param render_nulls: When True, a value of ``None`` will result 
         in a NULL value being included in the INSERT statement, rather 
         than the column being omitted from the INSERT.   This allows all 
         the rows being INSERTed to have the identical set of columns which 
         allows the full set of rows to be batched to the DBAPI.  Normally, 
         each column-set that contains a different combination of NULL values 
         than the previous row must omit a different series of columns from 
         the rendered INSERT statement, which means it must be emitted as a 
         separate statement.   By passing this flag, the full set of rows 
         are guaranteed to be batchable into one batch; the cost however is 
         that server-side defaults which are invoked by an omitted column will 
         be skipped, so care must be taken to ensure that these are not 
         necessary. 
 
         .. warning:: 
 
            When this flag is set, **server side default SQL values will 
            not be invoked** for those columns that are inserted as NULL; 
            the NULL value will be sent explicitly.   Care must be taken 
            to ensure that no server-side default functions need to be 
            invoked for the operation as a whole. 
 
        .. seealso:: 
 
            :doc:`queryguide/dml` 
 
            :meth:`.Session.bulk_save_objects` 
 
            :meth:`.Session.bulk_update_mappings` 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">bulk_insert_mappings</span><span class="s3">(</span>
            <span class="s1">mapper</span><span class="s3">,</span>
            <span class="s1">mappings</span><span class="s3">,</span>
            <span class="s1">return_defaults</span><span class="s3">=</span><span class="s1">return_defaults</span><span class="s3">,</span>
            <span class="s1">render_nulls</span><span class="s3">=</span><span class="s1">render_nulls</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">bulk_update_mappings</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">mapper</span><span class="s3">: </span><span class="s1">Mapper</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">], </span><span class="s1">mappings</span><span class="s3">: </span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">Dict</span><span class="s3">[</span><span class="s1">str</span><span class="s3">, </span><span class="s1">Any</span><span class="s3">]]</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Perform a bulk update of the given list of mapping dictionaries. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        .. legacy:: 
 
            This method is a legacy feature as of the 2.0 series of 
            SQLAlchemy.   For modern bulk INSERT and UPDATE, see 
            the sections :ref:`orm_queryguide_bulk_insert` and 
            :ref:`orm_queryguide_bulk_update`.  The 2.0 API shares 
            implementation details with this method and adds new features 
            as well. 
 
        :param mapper: a mapped class, or the actual :class:`_orm.Mapper` 
         object, 
         representing the single kind of object represented within the mapping 
         list. 
 
        :param mappings: a sequence of dictionaries, each one containing the 
         state of the mapped row to be updated, in terms of the attribute names 
         on the mapped class.   If the mapping refers to multiple tables, such 
         as a joined-inheritance mapping, each dictionary may contain keys 
         corresponding to all tables.   All those keys which are present and 
         are not part of the primary key are applied to the SET clause of the 
         UPDATE statement; the primary key values, which are required, are 
         applied to the WHERE clause. 
 
 
        .. seealso:: 
 
            :doc:`queryguide/dml` 
 
            :meth:`.Session.bulk_insert_mappings` 
 
            :meth:`.Session.bulk_save_objects` 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">bulk_update_mappings</span><span class="s3">(</span><span class="s1">mapper</span><span class="s3">, </span><span class="s1">mappings</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">merge</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">instance</span><span class="s3">: </span><span class="s1">_O</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">load</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">options</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">ORMOption</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; _O</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Copy the state of a given instance into a corresponding instance 
        within this :class:`.Session`. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        :meth:`.Session.merge` examines the primary key attributes of the 
        source instance, and attempts to reconcile it with an instance of the 
        same primary key in the session.   If not found locally, it attempts 
        to load the object from the database based on primary key, and if 
        none can be located, creates a new instance.  The state of each 
        attribute on the source instance is then copied to the target 
        instance.  The resulting target instance is then returned by the 
        method; the original source instance is left unmodified, and 
        un-associated with the :class:`.Session` if not already. 
 
        This operation cascades to associated instances if the association is 
        mapped with ``cascade=&quot;merge&quot;``. 
 
        See :ref:`unitofwork_merging` for a detailed discussion of merging. 
 
        :param instance: Instance to be merged. 
        :param load: Boolean, when False, :meth:`.merge` switches into 
         a &quot;high performance&quot; mode which causes it to forego emitting history 
         events as well as all database access.  This flag is used for 
         cases such as transferring graphs of objects into a :class:`.Session` 
         from a second level cache, or to transfer just-loaded objects 
         into the :class:`.Session` owned by a worker thread or process 
         without re-querying the database. 
 
         The ``load=False`` use case adds the caveat that the given 
         object has to be in a &quot;clean&quot; state, that is, has no pending changes 
         to be flushed - even if the incoming object is detached from any 
         :class:`.Session`.   This is so that when 
         the merge operation populates local attributes and 
         cascades to related objects and 
         collections, the values can be &quot;stamped&quot; onto the 
         target object as is, without generating any history or attribute 
         events, and without the need to reconcile the incoming data with 
         any existing related objects or collections that might not 
         be loaded.  The resulting objects from ``load=False`` are always 
         produced as &quot;clean&quot;, so it is only appropriate that the given objects 
         should be &quot;clean&quot; as well, else this suggests a mis-use of the 
         method. 
        :param options: optional sequence of loader options which will be 
         applied to the :meth:`_orm.Session.get` method when the merge 
         operation loads the existing version of the object from the database. 
 
         .. versionadded:: 1.4.24 
 
 
        .. seealso:: 
 
            :func:`.make_transient_to_detached` - provides for an alternative 
            means of &quot;merging&quot; a single object into the :class:`.Session` 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">merge</span><span class="s3">(</span><span class="s1">instance</span><span class="s3">, </span><span class="s1">load</span><span class="s3">=</span><span class="s1">load</span><span class="s3">, </span><span class="s1">options</span><span class="s3">=</span><span class="s1">options</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">query</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">_entity</span><span class="s3">: </span><span class="s1">_EntityType</span><span class="s3">[</span><span class="s1">_O</span><span class="s3">]) </span><span class="s1">-&gt; Query</span><span class="s3">[</span><span class="s1">_O</span><span class="s3">]: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">query</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">_colexpr</span><span class="s3">: </span><span class="s1">TypedColumnsClauseRole</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]</span>
    <span class="s3">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]]: ...</span>

    <span class="s0"># START OVERLOADED FUNCTIONS self.query RowReturningQuery 2-8</span>

    <span class="s0"># code within this block is **programmatically,</span>
    <span class="s0"># statically generated** by tools/generate_tuple_map_overloads.py</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">query</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">__ent0</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">], </span><span class="s1">__ent1</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T1</span><span class="s3">]</span>
    <span class="s3">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">, </span><span class="s1">_T1</span><span class="s3">]]: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">query</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">__ent0</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">], </span><span class="s1">__ent1</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T1</span><span class="s3">], </span><span class="s1">__ent2</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T2</span><span class="s3">]</span>
    <span class="s3">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">, </span><span class="s1">_T1</span><span class="s3">, </span><span class="s1">_T2</span><span class="s3">]]: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">query</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">__ent0</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">],</span>
        <span class="s1">__ent1</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T1</span><span class="s3">],</span>
        <span class="s1">__ent2</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T2</span><span class="s3">],</span>
        <span class="s1">__ent3</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T3</span><span class="s3">],</span>
    <span class="s3">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">, </span><span class="s1">_T1</span><span class="s3">, </span><span class="s1">_T2</span><span class="s3">, </span><span class="s1">_T3</span><span class="s3">]]: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">query</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">__ent0</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">],</span>
        <span class="s1">__ent1</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T1</span><span class="s3">],</span>
        <span class="s1">__ent2</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T2</span><span class="s3">],</span>
        <span class="s1">__ent3</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T3</span><span class="s3">],</span>
        <span class="s1">__ent4</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T4</span><span class="s3">],</span>
    <span class="s3">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">, </span><span class="s1">_T1</span><span class="s3">, </span><span class="s1">_T2</span><span class="s3">, </span><span class="s1">_T3</span><span class="s3">, </span><span class="s1">_T4</span><span class="s3">]]: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">query</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">__ent0</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">],</span>
        <span class="s1">__ent1</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T1</span><span class="s3">],</span>
        <span class="s1">__ent2</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T2</span><span class="s3">],</span>
        <span class="s1">__ent3</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T3</span><span class="s3">],</span>
        <span class="s1">__ent4</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T4</span><span class="s3">],</span>
        <span class="s1">__ent5</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T5</span><span class="s3">],</span>
    <span class="s3">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">, </span><span class="s1">_T1</span><span class="s3">, </span><span class="s1">_T2</span><span class="s3">, </span><span class="s1">_T3</span><span class="s3">, </span><span class="s1">_T4</span><span class="s3">, </span><span class="s1">_T5</span><span class="s3">]]: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">query</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">__ent0</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">],</span>
        <span class="s1">__ent1</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T1</span><span class="s3">],</span>
        <span class="s1">__ent2</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T2</span><span class="s3">],</span>
        <span class="s1">__ent3</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T3</span><span class="s3">],</span>
        <span class="s1">__ent4</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T4</span><span class="s3">],</span>
        <span class="s1">__ent5</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T5</span><span class="s3">],</span>
        <span class="s1">__ent6</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T6</span><span class="s3">],</span>
    <span class="s3">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">, </span><span class="s1">_T1</span><span class="s3">, </span><span class="s1">_T2</span><span class="s3">, </span><span class="s1">_T3</span><span class="s3">, </span><span class="s1">_T4</span><span class="s3">, </span><span class="s1">_T5</span><span class="s3">, </span><span class="s1">_T6</span><span class="s3">]]: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">query</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">__ent0</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">],</span>
        <span class="s1">__ent1</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T1</span><span class="s3">],</span>
        <span class="s1">__ent2</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T2</span><span class="s3">],</span>
        <span class="s1">__ent3</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T3</span><span class="s3">],</span>
        <span class="s1">__ent4</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T4</span><span class="s3">],</span>
        <span class="s1">__ent5</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T5</span><span class="s3">],</span>
        <span class="s1">__ent6</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T6</span><span class="s3">],</span>
        <span class="s1">__ent7</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T7</span><span class="s3">],</span>
    <span class="s3">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">, </span><span class="s1">_T1</span><span class="s3">, </span><span class="s1">_T2</span><span class="s3">, </span><span class="s1">_T3</span><span class="s3">, </span><span class="s1">_T4</span><span class="s3">, </span><span class="s1">_T5</span><span class="s3">, </span><span class="s1">_T6</span><span class="s3">, </span><span class="s1">_T7</span><span class="s3">]]: ...</span>

    <span class="s0"># END OVERLOADED FUNCTIONS self.query</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">query</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, *</span><span class="s1">entities</span><span class="s3">: </span><span class="s1">_ColumnsClauseArgument</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">], **</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">Any</span>
    <span class="s3">) </span><span class="s1">-&gt; Query</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]: ...</span>

    <span class="s2">def </span><span class="s1">query</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, *</span><span class="s1">entities</span><span class="s3">: </span><span class="s1">_ColumnsClauseArgument</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">], **</span><span class="s1">kwargs</span><span class="s3">: </span><span class="s1">Any</span>
    <span class="s3">) </span><span class="s1">-&gt; Query</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]:</span>
        <span class="s4">r&quot;&quot;&quot;Return a new :class:`_query.Query` object corresponding to this 
        :class:`_orm.Session`. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        Note that the :class:`_query.Query` object is legacy as of 
        SQLAlchemy 2.0; the :func:`_sql.select` construct is now used 
        to construct ORM queries. 
 
        .. seealso:: 
 
            :ref:`unified_tutorial` 
 
            :ref:`queryguide_toplevel` 
 
            :ref:`query_api_toplevel` - legacy API doc 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">query</span><span class="s3">(*</span><span class="s1">entities</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">refresh</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">instance</span><span class="s3">: </span><span class="s1">object</span><span class="s3">,</span>
        <span class="s1">attribute_names</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Iterable</span><span class="s3">[</span><span class="s1">str</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">with_for_update</span><span class="s3">: </span><span class="s1">ForUpdateParameter </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Expire and refresh attributes on the given instance. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        The selected attributes will first be expired as they would when using 
        :meth:`_orm.Session.expire`; then a SELECT statement will be issued to 
        the database to refresh column-oriented attributes with the current 
        value available in the current transaction. 
 
        :func:`_orm.relationship` oriented attributes will also be immediately 
        loaded if they were already eagerly loaded on the object, using the 
        same eager loading strategy that they were loaded with originally. 
 
        .. versionadded:: 1.4 - the :meth:`_orm.Session.refresh` method 
           can also refresh eagerly loaded attributes. 
 
        :func:`_orm.relationship` oriented attributes that would normally 
        load using the ``select`` (or &quot;lazy&quot;) loader strategy will also 
        load **if they are named explicitly in the attribute_names 
        collection**, emitting a SELECT statement for the attribute using the 
        ``immediate`` loader strategy.  If lazy-loaded relationships are not 
        named in :paramref:`_orm.Session.refresh.attribute_names`, then 
        they remain as &quot;lazy loaded&quot; attributes and are not implicitly 
        refreshed. 
 
        .. versionchanged:: 2.0.4  The :meth:`_orm.Session.refresh` method 
           will now refresh lazy-loaded :func:`_orm.relationship` oriented 
           attributes for those which are named explicitly in the 
           :paramref:`_orm.Session.refresh.attribute_names` collection. 
 
        .. tip:: 
 
            While the :meth:`_orm.Session.refresh` method is capable of 
            refreshing both column and relationship oriented attributes, its 
            primary focus is on refreshing of local column-oriented attributes 
            on a single instance. For more open ended &quot;refresh&quot; functionality, 
            including the ability to refresh the attributes on many objects at 
            once while having explicit control over relationship loader 
            strategies, use the 
            :ref:`populate existing &lt;orm_queryguide_populate_existing&gt;` feature 
            instead. 
 
        Note that a highly isolated transaction will return the same values as 
        were previously read in that same transaction, regardless of changes 
        in database state outside of that transaction.   Refreshing 
        attributes usually only makes sense at the start of a transaction 
        where database rows have not yet been accessed. 
 
        :param attribute_names: optional.  An iterable collection of 
          string attribute names indicating a subset of attributes to 
          be refreshed. 
 
        :param with_for_update: optional boolean ``True`` indicating FOR UPDATE 
          should be used, or may be a dictionary containing flags to 
          indicate a more specific set of FOR UPDATE flags for the SELECT; 
          flags should match the parameters of 
          :meth:`_query.Query.with_for_update`. 
          Supersedes the :paramref:`.Session.refresh.lockmode` parameter. 
 
        .. seealso:: 
 
            :ref:`session_expire` - introductory material 
 
            :meth:`.Session.expire` 
 
            :meth:`.Session.expire_all` 
 
            :ref:`orm_queryguide_populate_existing` - allows any ORM query 
            to refresh objects as they would be loaded normally. 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">refresh</span><span class="s3">(</span>
            <span class="s1">instance</span><span class="s3">,</span>
            <span class="s1">attribute_names</span><span class="s3">=</span><span class="s1">attribute_names</span><span class="s3">,</span>
            <span class="s1">with_for_update</span><span class="s3">=</span><span class="s1">with_for_update</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">rollback</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Rollback the current transaction in progress. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        If no transaction is in progress, this method is a pass-through. 
 
        The method always rolls back 
        the topmost database transaction, discarding any nested 
        transactions that may be in progress. 
 
        .. seealso:: 
 
            :ref:`session_rollback` 
 
            :ref:`unitofwork_transaction` 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">rollback</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">scalar</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">statement</span><span class="s3">: </span><span class="s1">TypedReturnsRows</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]],</span>
        <span class="s1">params</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_CoreSingleExecuteParams</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">execution_options</span><span class="s3">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s3">= </span><span class="s1">util</span><span class="s3">.</span><span class="s1">EMPTY_DICT</span><span class="s3">,</span>
        <span class="s1">bind_arguments</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_BindArguments</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kw</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">scalar</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">statement</span><span class="s3">: </span><span class="s1">Executable</span><span class="s3">,</span>
        <span class="s1">params</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_CoreSingleExecuteParams</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">execution_options</span><span class="s3">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s3">= </span><span class="s1">util</span><span class="s3">.</span><span class="s1">EMPTY_DICT</span><span class="s3">,</span>
        <span class="s1">bind_arguments</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_BindArguments</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kw</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">: ...</span>

    <span class="s2">def </span><span class="s1">scalar</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">statement</span><span class="s3">: </span><span class="s1">Executable</span><span class="s3">,</span>
        <span class="s1">params</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_CoreSingleExecuteParams</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">execution_options</span><span class="s3">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s3">= </span><span class="s1">util</span><span class="s3">.</span><span class="s1">EMPTY_DICT</span><span class="s3">,</span>
        <span class="s1">bind_arguments</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_BindArguments</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kw</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Execute a statement and return a scalar result. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        Usage and parameters are the same as that of 
        :meth:`_orm.Session.execute`; the return result is a scalar Python 
        value. 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">scalar</span><span class="s3">(</span>
            <span class="s1">statement</span><span class="s3">,</span>
            <span class="s1">params</span><span class="s3">=</span><span class="s1">params</span><span class="s3">,</span>
            <span class="s1">execution_options</span><span class="s3">=</span><span class="s1">execution_options</span><span class="s3">,</span>
            <span class="s1">bind_arguments</span><span class="s3">=</span><span class="s1">bind_arguments</span><span class="s3">,</span>
            <span class="s3">**</span><span class="s1">kw</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">scalars</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">statement</span><span class="s3">: </span><span class="s1">TypedReturnsRows</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]],</span>
        <span class="s1">params</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">execution_options</span><span class="s3">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s3">= </span><span class="s1">util</span><span class="s3">.</span><span class="s1">EMPTY_DICT</span><span class="s3">,</span>
        <span class="s1">bind_arguments</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_BindArguments</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kw</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; ScalarResult</span><span class="s3">[</span><span class="s1">_T</span><span class="s3">]: ...</span>

    <span class="s3">@</span><span class="s1">overload</span>
    <span class="s2">def </span><span class="s1">scalars</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">statement</span><span class="s3">: </span><span class="s1">Executable</span><span class="s3">,</span>
        <span class="s1">params</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">execution_options</span><span class="s3">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s3">= </span><span class="s1">util</span><span class="s3">.</span><span class="s1">EMPTY_DICT</span><span class="s3">,</span>
        <span class="s1">bind_arguments</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_BindArguments</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kw</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; ScalarResult</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]: ...</span>

    <span class="s2">def </span><span class="s1">scalars</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">statement</span><span class="s3">: </span><span class="s1">Executable</span><span class="s3">,</span>
        <span class="s1">params</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_CoreAnyExecuteParams</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">execution_options</span><span class="s3">: </span><span class="s1">OrmExecuteOptionsParameter </span><span class="s3">= </span><span class="s1">util</span><span class="s3">.</span><span class="s1">EMPTY_DICT</span><span class="s3">,</span>
        <span class="s1">bind_arguments</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_BindArguments</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kw</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; ScalarResult</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]:</span>
        <span class="s4">r&quot;&quot;&quot;Execute a statement and return the results as scalars. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        Usage and parameters are the same as that of 
        :meth:`_orm.Session.execute`; the return result is a 
        :class:`_result.ScalarResult` filtering object which 
        will return single elements rather than :class:`_row.Row` objects. 
 
        :return:  a :class:`_result.ScalarResult` object 
 
        .. versionadded:: 1.4.24 Added :meth:`_orm.Session.scalars` 
 
        .. versionadded:: 1.4.26 Added :meth:`_orm.scoped_session.scalars` 
 
        .. seealso:: 
 
            :ref:`orm_queryguide_select_orm_entities` - contrasts the behavior 
            of :meth:`_orm.Session.execute` to :meth:`_orm.Session.scalars` 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">scalars</span><span class="s3">(</span>
            <span class="s1">statement</span><span class="s3">,</span>
            <span class="s1">params</span><span class="s3">=</span><span class="s1">params</span><span class="s3">,</span>
            <span class="s1">execution_options</span><span class="s3">=</span><span class="s1">execution_options</span><span class="s3">,</span>
            <span class="s1">bind_arguments</span><span class="s3">=</span><span class="s1">bind_arguments</span><span class="s3">,</span>
            <span class="s3">**</span><span class="s1">kw</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">bind</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">Engine</span><span class="s3">, </span><span class="s1">Connection</span><span class="s3">]]:</span>
        <span class="s4">r&quot;&quot;&quot;Proxy for the :attr:`_orm.Session.bind` attribute 
        on behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">bind</span>

    <span class="s3">@</span><span class="s1">bind</span><span class="s3">.</span><span class="s1">setter</span>
    <span class="s2">def </span><span class="s1">bind</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">Engine</span><span class="s3">, </span><span class="s1">Connection</span><span class="s3">]]) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">bind </span><span class="s3">= </span><span class="s1">attr</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">dirty</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;The set of all persistent instances considered dirty. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class 
            on behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        E.g.:: 
 
            some_mapped_object in session.dirty 
 
        Instances are considered dirty when they were modified but not 
        deleted. 
 
        Note that this 'dirty' calculation is 'optimistic'; most 
        attribute-setting or collection modification operations will 
        mark an instance as 'dirty' and place it in this set, even if 
        there is no net change to the attribute's value.  At flush 
        time, the value of each attribute is compared to its 
        previously saved value, and if there's no net change, no SQL 
        operation will occur (this is a more expensive operation so 
        it's only done at flush time). 
 
        To check if an instance has actionable net changes to its 
        attributes, use the :meth:`.Session.is_modified` method. 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">dirty</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">deleted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;The set of all instances marked as 'deleted' within this ``Session`` 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class 
            on behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">deleted</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">new</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;The set of all instances marked as 'new' within this ``Session``. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class 
            on behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">new</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">identity_map</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; IdentityMap</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Proxy for the :attr:`_orm.Session.identity_map` attribute 
        on behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">identity_map</span>

    <span class="s3">@</span><span class="s1">identity_map</span><span class="s3">.</span><span class="s1">setter</span>
    <span class="s2">def </span><span class="s1">identity_map</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">: </span><span class="s1">IdentityMap</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">identity_map </span><span class="s3">= </span><span class="s1">attr</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">is_active</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;True if this :class:`.Session` not in &quot;partial rollback&quot; state. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class 
            on behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        .. versionchanged:: 1.4 The :class:`_orm.Session` no longer begins 
           a new transaction immediately, so this attribute will be False 
           when the :class:`_orm.Session` is first instantiated. 
 
        &quot;partial rollback&quot; state typically indicates that the flush process 
        of the :class:`_orm.Session` has failed, and that the 
        :meth:`_orm.Session.rollback` method must be emitted in order to 
        fully roll back the transaction. 
 
        If this :class:`_orm.Session` is not in a transaction at all, the 
        :class:`_orm.Session` will autobegin when it is first used, so in this 
        case :attr:`_orm.Session.is_active` will return True. 
 
        Otherwise, if this :class:`_orm.Session` is within a transaction, 
        and that transaction has not been rolled back internally, the 
        :attr:`_orm.Session.is_active` will also return True. 
 
        .. seealso:: 
 
            :ref:`faq_session_rollback` 
 
            :meth:`_orm.Session.in_transaction` 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">is_active</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">autoflush</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Proxy for the :attr:`_orm.Session.autoflush` attribute 
        on behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">autoflush</span>

    <span class="s3">@</span><span class="s1">autoflush</span><span class="s3">.</span><span class="s1">setter</span>
    <span class="s2">def </span><span class="s1">autoflush</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">autoflush </span><span class="s3">= </span><span class="s1">attr</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">no_autoflush</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Return a context manager that disables autoflush. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class 
            on behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        e.g.:: 
 
            with session.no_autoflush: 
 
                some_object = SomeClass() 
                session.add(some_object) 
                # won't autoflush 
                some_object.related_thing = session.query(SomeRelated).first() 
 
        Operations that proceed within the ``with:`` block 
        will not be subject to flushes occurring upon query 
        access.  This is useful when initializing a series 
        of objects which involve existing database queries, 
        where the uncompleted object should not yet be flushed. 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">no_autoflush</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">info</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">-&gt; Any</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;A user-modifiable dictionary. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class 
            on behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        The initial value of this dictionary can be populated using the 
        ``info`` argument to the :class:`.Session` constructor or 
        :class:`.sessionmaker` constructor or factory methods.  The dictionary 
        here is always local to this :class:`.Session` and can be modified 
        independently of all other :class:`.Session` objects. 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_proxied</span><span class="s3">.</span><span class="s1">info</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">close_all</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">) </span><span class="s1">-&gt; </span><span class="s2">None</span><span class="s3">:</span>
        <span class="s4">r&quot;&quot;&quot;Close *all* sessions in memory. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        .. deprecated:: 1.3 The :meth:`.Session.close_all` method is deprecated and will be removed in a future release.  Please refer to :func:`.session.close_all_sessions`. 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">Session</span><span class="s3">.</span><span class="s1">close_all</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">object_session</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">instance</span><span class="s3">: </span><span class="s1">object</span><span class="s3">) </span><span class="s1">-&gt; Optional</span><span class="s3">[</span><span class="s1">Session</span><span class="s3">]:</span>
        <span class="s4">r&quot;&quot;&quot;Return the :class:`.Session` to which an object belongs. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        This is an alias of :func:`.object_session`. 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">Session</span><span class="s3">.</span><span class="s1">object_session</span><span class="s3">(</span><span class="s1">instance</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">identity_key</span><span class="s3">(</span>
        <span class="s1">cls</span><span class="s3">,</span>
        <span class="s1">class_</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Type</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">ident</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">, ...]] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s3">*,</span>
        <span class="s1">instance</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">row</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">Row</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">], </span><span class="s1">RowMapping</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
        <span class="s1">identity_token</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">-&gt; _IdentityKeyType</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]:</span>
        <span class="s4">r&quot;&quot;&quot;Return an identity key. 
 
        .. container:: class_bases 
 
            Proxied for the :class:`_orm.Session` class on 
            behalf of the :class:`_orm.scoping.scoped_session` class. 
 
        This is an alias of :func:`.util.identity_key`. 
 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s2">return </span><span class="s1">Session</span><span class="s3">.</span><span class="s1">identity_key</span><span class="s3">(</span>
            <span class="s1">class_</span><span class="s3">=</span><span class="s1">class_</span><span class="s3">,</span>
            <span class="s1">ident</span><span class="s3">=</span><span class="s1">ident</span><span class="s3">,</span>
            <span class="s1">instance</span><span class="s3">=</span><span class="s1">instance</span><span class="s3">,</span>
            <span class="s1">row</span><span class="s3">=</span><span class="s1">row</span><span class="s3">,</span>
            <span class="s1">identity_token</span><span class="s3">=</span><span class="s1">identity_token</span><span class="s3">,</span>
        <span class="s3">)</span>

    <span class="s0"># END PROXY METHODS scoped_session</span>


<span class="s1">ScopedSession </span><span class="s3">= </span><span class="s1">scoped_session</span>
<span class="s4">&quot;&quot;&quot;Old name for backwards compatibility.&quot;&quot;&quot;</span>
</pre>
</body>
</html>