<html>
<head>
<title>varStore.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #2aacb8;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
varStore.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">misc</span><span class="s2">.</span><span class="s1">roundTools </span><span class="s0">import </span><span class="s1">noRound</span><span class="s2">, </span><span class="s1">otRound</span>
<span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">misc</span><span class="s2">.</span><span class="s1">intTools </span><span class="s0">import </span><span class="s1">bit_count</span>
<span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">ttLib</span><span class="s2">.</span><span class="s1">tables </span><span class="s0">import </span><span class="s1">otTables </span><span class="s0">as </span><span class="s1">ot</span>
<span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">varLib</span><span class="s2">.</span><span class="s1">models </span><span class="s0">import </span><span class="s1">supportScalar</span>
<span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">varLib</span><span class="s2">.</span><span class="s1">builder </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">buildVarRegionList</span><span class="s2">,</span>
    <span class="s1">buildVarStore</span><span class="s2">,</span>
    <span class="s1">buildVarRegion</span><span class="s2">,</span>
    <span class="s1">buildVarData</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict</span>
<span class="s0">from </span><span class="s1">heapq </span><span class="s0">import </span><span class="s1">heappush</span><span class="s2">, </span><span class="s1">heappop</span>


<span class="s1">NO_VARIATION_INDEX </span><span class="s2">= </span><span class="s1">ot</span><span class="s2">.</span><span class="s1">NO_VARIATION_INDEX</span>
<span class="s1">ot</span><span class="s2">.</span><span class="s1">VarStore</span><span class="s2">.</span><span class="s1">NO_VARIATION_INDEX </span><span class="s2">= </span><span class="s1">NO_VARIATION_INDEX</span>


<span class="s0">def </span><span class="s1">_getLocationKey</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">loc</span><span class="s2">.</span><span class="s1">items</span><span class="s2">(), </span><span class="s1">key</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">kv</span><span class="s2">: </span><span class="s1">kv</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]))</span>


<span class="s0">class </span><span class="s1">OnlineVarStoreBuilder</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axisTags</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_axisTags </span><span class="s2">= </span><span class="s1">axisTags</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_regionMap </span><span class="s2">= {}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_regionList </span><span class="s2">= </span><span class="s1">buildVarRegionList</span><span class="s2">([], </span><span class="s1">axisTags</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_store </span><span class="s2">= </span><span class="s1">buildVarStore</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_regionList</span><span class="s2">, [])</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_data </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_model </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_supports </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_varDataIndices </span><span class="s2">= {}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_varDataCaches </span><span class="s2">= {}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_cache </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">setModel</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">model</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">setSupports</span><span class="s2">(</span><span class="s1">model</span><span class="s2">.</span><span class="s1">supports</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_model </span><span class="s2">= </span><span class="s1">model</span>

    <span class="s0">def </span><span class="s1">setSupports</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">supports</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_model </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_supports </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">supports</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_supports</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]:</span>
            <span class="s0">del </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_supports</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]  </span><span class="s4"># Drop base master support</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_cache </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_data </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">finish</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">optimize</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_regionList</span><span class="s2">.</span><span class="s1">RegionCount </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_regionList</span><span class="s2">.</span><span class="s1">Region</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_store</span><span class="s2">.</span><span class="s1">VarDataCount </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_store</span><span class="s2">.</span><span class="s1">VarData</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">data </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_store</span><span class="s2">.</span><span class="s1">VarData</span><span class="s2">:</span>
            <span class="s1">data</span><span class="s2">.</span><span class="s1">ItemCount </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">.</span><span class="s1">Item</span><span class="s2">)</span>
            <span class="s1">data</span><span class="s2">.</span><span class="s1">calculateNumShorts</span><span class="s2">(</span><span class="s1">optimize</span><span class="s2">=</span><span class="s1">optimize</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_store</span>

    <span class="s0">def </span><span class="s1">_add_VarData</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">num_items</span><span class="s2">=</span><span class="s3">1</span><span class="s2">):</span>
        <span class="s1">regionMap </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_regionMap</span>
        <span class="s1">regionList </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_regionList</span>

        <span class="s1">regions </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_supports</span>
        <span class="s1">regionIndices </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">region </span><span class="s0">in </span><span class="s1">regions</span><span class="s2">:</span>
            <span class="s1">key </span><span class="s2">= </span><span class="s1">_getLocationKey</span><span class="s2">(</span><span class="s1">region</span><span class="s2">)</span>
            <span class="s1">idx </span><span class="s2">= </span><span class="s1">regionMap</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">idx </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s1">varRegion </span><span class="s2">= </span><span class="s1">buildVarRegion</span><span class="s2">(</span><span class="s1">region</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_axisTags</span><span class="s2">)</span>
                <span class="s1">idx </span><span class="s2">= </span><span class="s1">regionMap</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s1">len</span><span class="s2">(</span><span class="s1">regionList</span><span class="s2">.</span><span class="s1">Region</span><span class="s2">)</span>
                <span class="s1">regionList</span><span class="s2">.</span><span class="s1">Region</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">varRegion</span><span class="s2">)</span>
            <span class="s1">regionIndices</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">)</span>

        <span class="s4"># Check if we have one already...</span>
        <span class="s1">key </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">regionIndices</span><span class="s2">)</span>
        <span class="s1">varDataIdx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_varDataIndices</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">varDataIdx </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_outer </span><span class="s2">= </span><span class="s1">varDataIdx</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_store</span><span class="s2">.</span><span class="s1">VarData</span><span class="s2">[</span><span class="s1">varDataIdx</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_cache </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_varDataCaches</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">Item</span><span class="s2">) + </span><span class="s1">num_items </span><span class="s2">&gt; </span><span class="s3">0xFFFF</span><span class="s2">:</span>
                <span class="s4"># This is full.  Need new one.</span>
                <span class="s1">varDataIdx </span><span class="s2">= </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">varDataIdx </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_data </span><span class="s2">= </span><span class="s1">buildVarData</span><span class="s2">(</span><span class="s1">regionIndices</span><span class="s2">, [], </span><span class="s1">optimize</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_outer </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_store</span><span class="s2">.</span><span class="s1">VarData</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_store</span><span class="s2">.</span><span class="s1">VarData</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_varDataIndices</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_outer</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_varDataCaches</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_varDataCaches</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = {}</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_cache </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_varDataCaches</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">storeMasters</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">master_values</span><span class="s2">, *, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">round</span><span class="s2">):</span>
        <span class="s1">deltas </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_model</span><span class="s2">.</span><span class="s1">getDeltas</span><span class="s2">(</span><span class="s1">master_values</span><span class="s2">, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">round</span><span class="s2">)</span>
        <span class="s1">base </span><span class="s2">= </span><span class="s1">deltas</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">0</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">base</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">storeDeltas</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">noRound</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">storeMastersMany</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">master_values_list</span><span class="s2">, *, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">round</span><span class="s2">):</span>
        <span class="s1">deltas_list </span><span class="s2">= [</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_model</span><span class="s2">.</span><span class="s1">getDeltas</span><span class="s2">(</span><span class="s1">master_values</span><span class="s2">, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">round</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">master_values </span><span class="s0">in </span><span class="s1">master_values_list</span>
        <span class="s2">]</span>
        <span class="s1">base_list </span><span class="s2">= [</span><span class="s1">deltas</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">0</span><span class="s2">) </span><span class="s0">for </span><span class="s1">deltas </span><span class="s0">in </span><span class="s1">deltas_list</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">base_list</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">storeDeltasMany</span><span class="s2">(</span><span class="s1">deltas_list</span><span class="s2">, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">noRound</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">storeDeltas</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">, *, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">round</span><span class="s2">):</span>
        <span class="s1">deltas </span><span class="s2">= [</span><span class="s1">round</span><span class="s2">(</span><span class="s1">d</span><span class="s2">) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">deltas</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_supports</span><span class="s2">) + </span><span class="s3">1</span><span class="s2">:</span>
            <span class="s1">deltas </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">[</span><span class="s3">1</span><span class="s2">:])</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_supports</span><span class="s2">)</span>
            <span class="s1">deltas </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">)</span>

        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_add_VarData</span><span class="s2">()</span>

        <span class="s1">varIdx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_cache</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">varIdx </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">varIdx</span>

        <span class="s1">inner </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">Item</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">inner </span><span class="s2">== </span><span class="s3">0xFFFF</span><span class="s2">:</span>
            <span class="s4"># Full array. Start new one.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_add_VarData</span><span class="s2">()</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">storeDeltas</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">noRound</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">addItem</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">noRound</span><span class="s2">)</span>

        <span class="s1">varIdx </span><span class="s2">= (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_outer </span><span class="s2">&lt;&lt; </span><span class="s3">16</span><span class="s2">) + </span><span class="s1">inner</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_cache</span><span class="s2">[</span><span class="s1">deltas</span><span class="s2">] = </span><span class="s1">varIdx</span>
        <span class="s0">return </span><span class="s1">varIdx</span>

    <span class="s0">def </span><span class="s1">storeDeltasMany</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">deltas_list</span><span class="s2">, *, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">round</span><span class="s2">):</span>
        <span class="s1">deltas_list </span><span class="s2">= [[</span><span class="s1">round</span><span class="s2">(</span><span class="s1">d</span><span class="s2">) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">deltas</span><span class="s2">] </span><span class="s0">for </span><span class="s1">deltas </span><span class="s0">in </span><span class="s1">deltas_list</span><span class="s2">]</span>
        <span class="s1">deltas_list </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">) </span><span class="s0">for </span><span class="s1">deltas </span><span class="s0">in </span><span class="s1">deltas_list</span><span class="s2">)</span>

        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_add_VarData</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">deltas_list</span><span class="s2">))</span>

        <span class="s1">varIdx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_cache</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">deltas_list</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">varIdx </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">varIdx</span>

        <span class="s1">inner </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">Item</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">inner </span><span class="s2">+ </span><span class="s1">len</span><span class="s2">(</span><span class="s1">deltas_list</span><span class="s2">) &gt; </span><span class="s3">0xFFFF</span><span class="s2">:</span>
            <span class="s4"># Full array. Start new one.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_add_VarData</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">deltas_list</span><span class="s2">))</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">storeDeltasMany</span><span class="s2">(</span><span class="s1">deltas_list</span><span class="s2">, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">noRound</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">deltas </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">deltas_list</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_data</span><span class="s2">.</span><span class="s1">addItem</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">noRound</span><span class="s2">)</span>

            <span class="s1">varIdx </span><span class="s2">= (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_outer </span><span class="s2">&lt;&lt; </span><span class="s3">16</span><span class="s2">) + </span><span class="s1">inner </span><span class="s2">+ </span><span class="s1">i</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_cache</span><span class="s2">[</span><span class="s1">deltas</span><span class="s2">] = </span><span class="s1">varIdx</span>

        <span class="s1">varIdx </span><span class="s2">= (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_outer </span><span class="s2">&lt;&lt; </span><span class="s3">16</span><span class="s2">) + </span><span class="s1">inner</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_cache</span><span class="s2">[</span><span class="s1">deltas_list</span><span class="s2">] = </span><span class="s1">varIdx</span>

        <span class="s0">return </span><span class="s1">varIdx</span>


<span class="s0">def </span><span class="s1">VarData_addItem</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">, *, </span><span class="s1">round</span><span class="s2">=</span><span class="s1">round</span><span class="s2">):</span>
    <span class="s1">deltas </span><span class="s2">= [</span><span class="s1">round</span><span class="s2">(</span><span class="s1">d</span><span class="s2">) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">deltas</span><span class="s2">]</span>

    <span class="s1">countUs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">VarRegionCount</span>
    <span class="s1">countThem </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">countUs </span><span class="s2">+ </span><span class="s3">1 </span><span class="s2">== </span><span class="s1">countThem</span><span class="s2">:</span>
        <span class="s1">deltas </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">[</span><span class="s3">1</span><span class="s2">:])</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">countUs </span><span class="s2">== </span><span class="s1">countThem</span><span class="s2">, (</span><span class="s1">countUs</span><span class="s2">, </span><span class="s1">countThem</span><span class="s2">)</span>
        <span class="s1">deltas </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">)</span>
    <span class="s1">self</span><span class="s2">.</span><span class="s1">Item</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">)</span>
    <span class="s1">self</span><span class="s2">.</span><span class="s1">ItemCount </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">Item</span><span class="s2">)</span>


<span class="s1">ot</span><span class="s2">.</span><span class="s1">VarData</span><span class="s2">.</span><span class="s1">addItem </span><span class="s2">= </span><span class="s1">VarData_addItem</span>


<span class="s0">def </span><span class="s1">VarRegion_get_support</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fvar_axes</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">{</span>
        <span class="s1">fvar_axes</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">axisTag</span><span class="s2">: (</span><span class="s1">reg</span><span class="s2">.</span><span class="s1">StartCoord</span><span class="s2">, </span><span class="s1">reg</span><span class="s2">.</span><span class="s1">PeakCoord</span><span class="s2">, </span><span class="s1">reg</span><span class="s2">.</span><span class="s1">EndCoord</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">reg </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">VarRegionAxis</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">reg</span><span class="s2">.</span><span class="s1">PeakCoord </span><span class="s2">!= </span><span class="s3">0</span>
    <span class="s2">}</span>


<span class="s1">ot</span><span class="s2">.</span><span class="s1">VarRegion</span><span class="s2">.</span><span class="s1">get_support </span><span class="s2">= </span><span class="s1">VarRegion_get_support</span>


<span class="s0">def </span><span class="s1">VarStore___bool__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">bool</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">VarData</span><span class="s2">)</span>


<span class="s1">ot</span><span class="s2">.</span><span class="s1">VarStore</span><span class="s2">.</span><span class="s1">__bool__ </span><span class="s2">= </span><span class="s1">VarStore___bool__</span>


<span class="s0">class </span><span class="s1">VarStoreInstancer</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">varstore</span><span class="s2">, </span><span class="s1">fvar_axes</span><span class="s2">, </span><span class="s1">location</span><span class="s2">={}):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">fvar_axes </span><span class="s2">= </span><span class="s1">fvar_axes</span>
        <span class="s0">assert </span><span class="s1">varstore </span><span class="s0">is None or </span><span class="s1">varstore</span><span class="s2">.</span><span class="s1">Format </span><span class="s2">== </span><span class="s3">1</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_varData </span><span class="s2">= </span><span class="s1">varstore</span><span class="s2">.</span><span class="s1">VarData </span><span class="s0">if </span><span class="s1">varstore </span><span class="s0">else </span><span class="s2">[]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_regions </span><span class="s2">= </span><span class="s1">varstore</span><span class="s2">.</span><span class="s1">VarRegionList</span><span class="s2">.</span><span class="s1">Region </span><span class="s0">if </span><span class="s1">varstore </span><span class="s0">else </span><span class="s2">[]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">setLocation</span><span class="s2">(</span><span class="s1">location</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">setLocation</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">location</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">location </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">location</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_clearCaches</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">_clearCaches</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_scalars </span><span class="s2">= {}</span>

    <span class="s0">def </span><span class="s1">_getScalar</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">regionIdx</span><span class="s2">):</span>
        <span class="s1">scalar </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_scalars</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">regionIdx</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">scalar </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">support </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_regions</span><span class="s2">[</span><span class="s1">regionIdx</span><span class="s2">].</span><span class="s1">get_support</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">fvar_axes</span><span class="s2">)</span>
            <span class="s1">scalar </span><span class="s2">= </span><span class="s1">supportScalar</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">location</span><span class="s2">, </span><span class="s1">support</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_scalars</span><span class="s2">[</span><span class="s1">regionIdx</span><span class="s2">] = </span><span class="s1">scalar</span>
        <span class="s0">return </span><span class="s1">scalar</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s0">def </span><span class="s1">interpolateFromDeltasAndScalars</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">scalars</span><span class="s2">):</span>
        <span class="s1">delta </span><span class="s2">= </span><span class="s3">0.0</span>
        <span class="s0">for </span><span class="s1">d</span><span class="s2">, </span><span class="s1">s </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">scalars</span><span class="s2">):</span>
            <span class="s0">if not </span><span class="s1">s</span><span class="s2">:</span>
                <span class="s0">continue</span>
            <span class="s1">delta </span><span class="s2">+= </span><span class="s1">d </span><span class="s2">* </span><span class="s1">s</span>
        <span class="s0">return </span><span class="s1">delta</span>

    <span class="s0">def </span><span class="s1">__getitem__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">varidx</span><span class="s2">):</span>
        <span class="s1">major</span><span class="s2">, </span><span class="s1">minor </span><span class="s2">= </span><span class="s1">varidx </span><span class="s2">&gt;&gt; </span><span class="s3">16</span><span class="s2">, </span><span class="s1">varidx </span><span class="s2">&amp; </span><span class="s3">0xFFFF</span>
        <span class="s0">if </span><span class="s1">varidx </span><span class="s2">== </span><span class="s1">NO_VARIATION_INDEX</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s3">0.0</span>
        <span class="s1">varData </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_varData</span>
        <span class="s1">scalars </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_getScalar</span><span class="s2">(</span><span class="s1">ri</span><span class="s2">) </span><span class="s0">for </span><span class="s1">ri </span><span class="s0">in </span><span class="s1">varData</span><span class="s2">[</span><span class="s1">major</span><span class="s2">].</span><span class="s1">VarRegionIndex</span><span class="s2">]</span>
        <span class="s1">deltas </span><span class="s2">= </span><span class="s1">varData</span><span class="s2">[</span><span class="s1">major</span><span class="s2">].</span><span class="s1">Item</span><span class="s2">[</span><span class="s1">minor</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">interpolateFromDeltasAndScalars</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">scalars</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">interpolateFromDeltas</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">varDataIndex</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">):</span>
        <span class="s1">varData </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_varData</span>
        <span class="s1">scalars </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_getScalar</span><span class="s2">(</span><span class="s1">ri</span><span class="s2">) </span><span class="s0">for </span><span class="s1">ri </span><span class="s0">in </span><span class="s1">varData</span><span class="s2">[</span><span class="s1">varDataIndex</span><span class="s2">].</span><span class="s1">VarRegionIndex</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">interpolateFromDeltasAndScalars</span><span class="s2">(</span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">scalars</span><span class="s2">)</span>


<span class="s4">#</span>
<span class="s4"># Optimizations</span>
<span class="s4">#</span>
<span class="s4"># retainFirstMap - If true, major 0 mappings are retained. Deltas for unused indices are zeroed</span>
<span class="s4"># advIdxes - Set of major 0 indices for advance deltas to be listed first. Other major 0 indices follow.</span>


<span class="s0">def </span><span class="s1">VarStore_subset_varidxes</span><span class="s2">(</span>
    <span class="s1">self</span><span class="s2">,</span>
    <span class="s1">varIdxes</span><span class="s2">,</span>
    <span class="s1">optimize</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
    <span class="s1">retainFirstMap</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
    <span class="s1">advIdxes</span><span class="s2">=</span><span class="s1">set</span><span class="s2">(),</span>
    <span class="s2">*,</span>
    <span class="s1">VarData</span><span class="s2">=</span><span class="s5">&quot;VarData&quot;</span><span class="s2">,</span>
<span class="s2">):</span>
    <span class="s4"># Sort out used varIdxes by major/minor.</span>
    <span class="s1">used </span><span class="s2">= </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">set</span><span class="s2">)</span>
    <span class="s0">for </span><span class="s1">varIdx </span><span class="s0">in </span><span class="s1">varIdxes</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">varIdx </span><span class="s2">== </span><span class="s1">NO_VARIATION_INDEX</span><span class="s2">:</span>
            <span class="s0">continue</span>
        <span class="s1">major </span><span class="s2">= </span><span class="s1">varIdx </span><span class="s2">&gt;&gt; </span><span class="s3">16</span>
        <span class="s1">minor </span><span class="s2">= </span><span class="s1">varIdx </span><span class="s2">&amp; </span><span class="s3">0xFFFF</span>
        <span class="s1">used</span><span class="s2">[</span><span class="s1">major</span><span class="s2">].</span><span class="s1">add</span><span class="s2">(</span><span class="s1">minor</span><span class="s2">)</span>
    <span class="s0">del </span><span class="s1">varIdxes</span>

    <span class="s4">#</span>
    <span class="s4"># Subset VarData</span>
    <span class="s4">#</span>

    <span class="s1">varData </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">VarData</span><span class="s2">)</span>
    <span class="s1">newVarData </span><span class="s2">= []</span>
    <span class="s1">varDataMap </span><span class="s2">= {</span><span class="s1">NO_VARIATION_INDEX</span><span class="s2">: </span><span class="s1">NO_VARIATION_INDEX</span><span class="s2">}</span>
    <span class="s0">for </span><span class="s1">major</span><span class="s2">, </span><span class="s1">data </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">varData</span><span class="s2">):</span>
        <span class="s1">usedMinors </span><span class="s2">= </span><span class="s1">used</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">major</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">usedMinors </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">continue</span>
        <span class="s1">newMajor </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">newVarData</span><span class="s2">)</span>
        <span class="s1">newVarData</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>

        <span class="s1">items </span><span class="s2">= </span><span class="s1">data</span><span class="s2">.</span><span class="s1">Item</span>
        <span class="s1">newItems </span><span class="s2">= []</span>
        <span class="s0">if </span><span class="s1">major </span><span class="s2">== </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">retainFirstMap</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">minor </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">items</span><span class="s2">)):</span>
                <span class="s1">newItems</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span>
                    <span class="s1">items</span><span class="s2">[</span><span class="s1">minor</span><span class="s2">] </span><span class="s0">if </span><span class="s1">minor </span><span class="s0">in </span><span class="s1">usedMinors </span><span class="s0">else </span><span class="s2">[</span><span class="s3">0</span><span class="s2">] * </span><span class="s1">len</span><span class="s2">(</span><span class="s1">items</span><span class="s2">[</span><span class="s1">minor</span><span class="s2">])</span>
                <span class="s2">)</span>
                <span class="s1">varDataMap</span><span class="s2">[</span><span class="s1">minor</span><span class="s2">] = </span><span class="s1">minor</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">major </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
                <span class="s1">minors </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">advIdxes</span><span class="s2">) + </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">usedMinors </span><span class="s2">- </span><span class="s1">advIdxes</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">minors </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">usedMinors</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">minor </span><span class="s0">in </span><span class="s1">minors</span><span class="s2">:</span>
                <span class="s1">newMinor </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">newItems</span><span class="s2">)</span>
                <span class="s1">newItems</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">items</span><span class="s2">[</span><span class="s1">minor</span><span class="s2">])</span>
                <span class="s1">varDataMap</span><span class="s2">[(</span><span class="s1">major </span><span class="s2">&lt;&lt; </span><span class="s3">16</span><span class="s2">) + </span><span class="s1">minor</span><span class="s2">] = (</span><span class="s1">newMajor </span><span class="s2">&lt;&lt; </span><span class="s3">16</span><span class="s2">) + </span><span class="s1">newMinor</span>

        <span class="s1">data</span><span class="s2">.</span><span class="s1">Item </span><span class="s2">= </span><span class="s1">newItems</span>
        <span class="s1">data</span><span class="s2">.</span><span class="s1">ItemCount </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">.</span><span class="s1">Item</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">VarData </span><span class="s2">== </span><span class="s5">&quot;VarData&quot;</span><span class="s2">:</span>
            <span class="s1">data</span><span class="s2">.</span><span class="s1">calculateNumShorts</span><span class="s2">(</span><span class="s1">optimize</span><span class="s2">=</span><span class="s1">optimize</span><span class="s2">)</span>

    <span class="s1">setattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">VarData</span><span class="s2">, </span><span class="s1">newVarData</span><span class="s2">)</span>
    <span class="s1">setattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">VarData </span><span class="s2">+ </span><span class="s5">&quot;Count&quot;</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">newVarData</span><span class="s2">))</span>

    <span class="s1">self</span><span class="s2">.</span><span class="s1">prune_regions</span><span class="s2">()</span>

    <span class="s0">return </span><span class="s1">varDataMap</span>


<span class="s1">ot</span><span class="s2">.</span><span class="s1">VarStore</span><span class="s2">.</span><span class="s1">subset_varidxes </span><span class="s2">= </span><span class="s1">VarStore_subset_varidxes</span>


<span class="s0">def </span><span class="s1">VarStore_prune_regions</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *, </span><span class="s1">VarData</span><span class="s2">=</span><span class="s5">&quot;VarData&quot;</span><span class="s2">, </span><span class="s1">VarRegionList</span><span class="s2">=</span><span class="s5">&quot;VarRegionList&quot;</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Remove unused VarRegions.&quot;&quot;&quot;</span>
    <span class="s4">#</span>
    <span class="s4"># Subset VarRegionList</span>
    <span class="s4">#</span>

    <span class="s4"># Collect.</span>
    <span class="s1">usedRegions </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
    <span class="s0">for </span><span class="s1">data </span><span class="s0">in </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">VarData</span><span class="s2">):</span>
        <span class="s1">usedRegions</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">data</span><span class="s2">.</span><span class="s1">VarRegionIndex</span><span class="s2">)</span>
    <span class="s4"># Subset.</span>
    <span class="s1">regionList </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">VarRegionList</span><span class="s2">)</span>
    <span class="s1">regions </span><span class="s2">= </span><span class="s1">regionList</span><span class="s2">.</span><span class="s1">Region</span>
    <span class="s1">newRegions </span><span class="s2">= []</span>
    <span class="s1">regionMap </span><span class="s2">= {}</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">usedRegions</span><span class="s2">):</span>
        <span class="s1">regionMap</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">len</span><span class="s2">(</span><span class="s1">newRegions</span><span class="s2">)</span>
        <span class="s1">newRegions</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">regions</span><span class="s2">[</span><span class="s1">i</span><span class="s2">])</span>
    <span class="s1">regionList</span><span class="s2">.</span><span class="s1">Region </span><span class="s2">= </span><span class="s1">newRegions</span>
    <span class="s1">regionList</span><span class="s2">.</span><span class="s1">RegionCount </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">regionList</span><span class="s2">.</span><span class="s1">Region</span><span class="s2">)</span>
    <span class="s4"># Map.</span>
    <span class="s0">for </span><span class="s1">data </span><span class="s0">in </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">VarData</span><span class="s2">):</span>
        <span class="s1">data</span><span class="s2">.</span><span class="s1">VarRegionIndex </span><span class="s2">= [</span><span class="s1">regionMap</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">data</span><span class="s2">.</span><span class="s1">VarRegionIndex</span><span class="s2">]</span>


<span class="s1">ot</span><span class="s2">.</span><span class="s1">VarStore</span><span class="s2">.</span><span class="s1">prune_regions </span><span class="s2">= </span><span class="s1">VarStore_prune_regions</span>


<span class="s0">def </span><span class="s1">_visit</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Recurse down from self, if type of an object is ot.Device, 
    call func() on it.  Works on otData-style classes.&quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) == </span><span class="s1">ot</span><span class="s2">.</span><span class="s1">Device</span><span class="s2">:</span>
        <span class="s1">func</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">list</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">that </span><span class="s0">in </span><span class="s1">self</span><span class="s2">:</span>
            <span class="s1">_visit</span><span class="s2">(</span><span class="s1">that</span><span class="s2">, </span><span class="s1">func</span><span class="s2">)</span>

    <span class="s0">elif </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s5">&quot;getConverters&quot;</span><span class="s2">) </span><span class="s0">and not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s5">&quot;postRead&quot;</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">conv </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getConverters</span><span class="s2">():</span>
            <span class="s1">that </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">conv</span><span class="s2">.</span><span class="s1">name</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">that </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">_visit</span><span class="s2">(</span><span class="s1">that</span><span class="s2">, </span><span class="s1">func</span><span class="s2">)</span>

    <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ot</span><span class="s2">.</span><span class="s1">ValueRecord</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">that </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__dict__</span><span class="s2">.</span><span class="s1">values</span><span class="s2">():</span>
            <span class="s1">_visit</span><span class="s2">(</span><span class="s1">that</span><span class="s2">, </span><span class="s1">func</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_Device_recordVarIdx</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Add VarIdx in this Device table (if any) to the set s.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">DeltaFormat </span><span class="s2">== </span><span class="s3">0x8000</span><span class="s2">:</span>
        <span class="s1">s</span><span class="s2">.</span><span class="s1">add</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">StartSize </span><span class="s2">&lt;&lt; </span><span class="s3">16</span><span class="s2">) + </span><span class="s1">self</span><span class="s2">.</span><span class="s1">EndSize</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">Object_collect_device_varidxes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">varidxes</span><span class="s2">):</span>
    <span class="s1">adder </span><span class="s2">= </span><span class="s1">partial</span><span class="s2">(</span><span class="s1">_Device_recordVarIdx</span><span class="s2">, </span><span class="s1">s</span><span class="s2">=</span><span class="s1">varidxes</span><span class="s2">)</span>
    <span class="s1">_visit</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">adder</span><span class="s2">)</span>


<span class="s1">ot</span><span class="s2">.</span><span class="s1">GDEF</span><span class="s2">.</span><span class="s1">collect_device_varidxes </span><span class="s2">= </span><span class="s1">Object_collect_device_varidxes</span>
<span class="s1">ot</span><span class="s2">.</span><span class="s1">GPOS</span><span class="s2">.</span><span class="s1">collect_device_varidxes </span><span class="s2">= </span><span class="s1">Object_collect_device_varidxes</span>


<span class="s0">def </span><span class="s1">_Device_mapVarIdx</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">mapping</span><span class="s2">, </span><span class="s1">done</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Map VarIdx in this Device table (if any) through mapping.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">id</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s0">in </span><span class="s1">done</span><span class="s2">:</span>
        <span class="s0">return</span>
    <span class="s1">done</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">id</span><span class="s2">(</span><span class="s1">self</span><span class="s2">))</span>
    <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">DeltaFormat </span><span class="s2">== </span><span class="s3">0x8000</span><span class="s2">:</span>
        <span class="s1">varIdx </span><span class="s2">= </span><span class="s1">mapping</span><span class="s2">[(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">StartSize </span><span class="s2">&lt;&lt; </span><span class="s3">16</span><span class="s2">) + </span><span class="s1">self</span><span class="s2">.</span><span class="s1">EndSize</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">StartSize </span><span class="s2">= </span><span class="s1">varIdx </span><span class="s2">&gt;&gt; </span><span class="s3">16</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">EndSize </span><span class="s2">= </span><span class="s1">varIdx </span><span class="s2">&amp; </span><span class="s3">0xFFFF</span>


<span class="s0">def </span><span class="s1">Object_remap_device_varidxes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">varidxes_map</span><span class="s2">):</span>
    <span class="s1">mapper </span><span class="s2">= </span><span class="s1">partial</span><span class="s2">(</span><span class="s1">_Device_mapVarIdx</span><span class="s2">, </span><span class="s1">mapping</span><span class="s2">=</span><span class="s1">varidxes_map</span><span class="s2">, </span><span class="s1">done</span><span class="s2">=</span><span class="s1">set</span><span class="s2">())</span>
    <span class="s1">_visit</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">mapper</span><span class="s2">)</span>


<span class="s1">ot</span><span class="s2">.</span><span class="s1">GDEF</span><span class="s2">.</span><span class="s1">remap_device_varidxes </span><span class="s2">= </span><span class="s1">Object_remap_device_varidxes</span>
<span class="s1">ot</span><span class="s2">.</span><span class="s1">GPOS</span><span class="s2">.</span><span class="s1">remap_device_varidxes </span><span class="s2">= </span><span class="s1">Object_remap_device_varidxes</span>


<span class="s0">class </span><span class="s1">_Encoding</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">chars</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">chars </span><span class="s2">= </span><span class="s1">chars</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">width </span><span class="s2">= </span><span class="s1">bit_count</span><span class="s2">(</span><span class="s1">chars</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">columns </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_columns</span><span class="s2">(</span><span class="s1">chars</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">overhead </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_characteristic_overhead</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">columns</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">items </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">append</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">row</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">extend</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">lst</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">lst</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_room</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Maximum number of bytes that can be added to characteristic 
        while still being beneficial to merge it into another one.&quot;&quot;&quot;</span>
        <span class="s1">count </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">max</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">overhead </span><span class="s2">- </span><span class="s3">1</span><span class="s2">) // </span><span class="s1">count </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">width</span><span class="s2">)</span>

    <span class="s1">room </span><span class="s2">= </span><span class="s1">property</span><span class="s2">(</span><span class="s1">get_room</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_gain</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Maximum possible byte gain from merging this into another 
        characteristic.&quot;&quot;&quot;</span>
        <span class="s1">count </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">max</span><span class="s2">(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">overhead </span><span class="s2">- </span><span class="s1">count</span><span class="s2">)</span>

    <span class="s1">gain </span><span class="s2">= </span><span class="s1">property</span><span class="s2">(</span><span class="s1">get_gain</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">gain_sort_key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">gain</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">chars</span>

    <span class="s0">def </span><span class="s1">width_sort_key</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">width</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">chars</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s0">def </span><span class="s1">_characteristic_overhead</span><span class="s2">(</span><span class="s1">columns</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Returns overhead in bytes of encoding this characteristic 
        as a VarData.&quot;&quot;&quot;</span>
        <span class="s1">c </span><span class="s2">= </span><span class="s3">4 </span><span class="s2">+ </span><span class="s3">6  </span><span class="s4"># 4 bytes for LOffset, 6 bytes for VarData header</span>
        <span class="s1">c </span><span class="s2">+= </span><span class="s1">bit_count</span><span class="s2">(</span><span class="s1">columns</span><span class="s2">) * </span><span class="s3">2</span>
        <span class="s0">return </span><span class="s1">c</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s0">def </span><span class="s1">_columns</span><span class="s2">(</span><span class="s1">chars</span><span class="s2">):</span>
        <span class="s1">cols </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s1">i </span><span class="s2">= </span><span class="s3">1</span>
        <span class="s0">while </span><span class="s1">chars</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">chars </span><span class="s2">&amp; </span><span class="s3">0b1111</span><span class="s2">:</span>
                <span class="s1">cols </span><span class="s2">|= </span><span class="s1">i</span>
            <span class="s1">chars </span><span class="s2">&gt;&gt;= </span><span class="s3">4</span>
            <span class="s1">i </span><span class="s2">&lt;&lt;= </span><span class="s3">1</span>
        <span class="s0">return </span><span class="s1">cols</span>

    <span class="s0">def </span><span class="s1">gain_from_merging</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other_encoding</span><span class="s2">):</span>
        <span class="s1">combined_chars </span><span class="s2">= </span><span class="s1">other_encoding</span><span class="s2">.</span><span class="s1">chars </span><span class="s2">| </span><span class="s1">self</span><span class="s2">.</span><span class="s1">chars</span>
        <span class="s1">combined_width </span><span class="s2">= </span><span class="s1">bit_count</span><span class="s2">(</span><span class="s1">combined_chars</span><span class="s2">)</span>
        <span class="s1">combined_columns </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">columns </span><span class="s2">| </span><span class="s1">other_encoding</span><span class="s2">.</span><span class="s1">columns</span>
        <span class="s1">combined_overhead </span><span class="s2">= </span><span class="s1">_Encoding</span><span class="s2">.</span><span class="s1">_characteristic_overhead</span><span class="s2">(</span><span class="s1">combined_columns</span><span class="s2">)</span>
        <span class="s1">combined_gain </span><span class="s2">= (</span>
            <span class="s2">+</span><span class="s1">self</span><span class="s2">.</span><span class="s1">overhead</span>
            <span class="s2">+ </span><span class="s1">other_encoding</span><span class="s2">.</span><span class="s1">overhead</span>
            <span class="s2">- </span><span class="s1">combined_overhead</span>
            <span class="s2">- (</span><span class="s1">combined_width </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">width</span><span class="s2">) * </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">items</span><span class="s2">)</span>
            <span class="s2">- (</span><span class="s1">combined_width </span><span class="s2">- </span><span class="s1">other_encoding</span><span class="s2">.</span><span class="s1">width</span><span class="s2">) * </span><span class="s1">len</span><span class="s2">(</span><span class="s1">other_encoding</span><span class="s2">.</span><span class="s1">items</span><span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">combined_gain</span>


<span class="s0">class </span><span class="s1">_EncodingDict</span><span class="s2">(</span><span class="s1">dict</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__missing__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">chars</span><span class="s2">):</span>
        <span class="s1">r </span><span class="s2">= </span><span class="s1">self</span><span class="s2">[</span><span class="s1">chars</span><span class="s2">] = </span><span class="s1">_Encoding</span><span class="s2">(</span><span class="s1">chars</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">r</span>

    <span class="s0">def </span><span class="s1">add_row</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">):</span>
        <span class="s1">chars </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_row_characteristics</span><span class="s2">(</span><span class="s1">row</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">[</span><span class="s1">chars</span><span class="s2">].</span><span class="s1">append</span><span class="s2">(</span><span class="s1">row</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">staticmethod</span>
    <span class="s0">def </span><span class="s1">_row_characteristics</span><span class="s2">(</span><span class="s1">row</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Returns encoding characteristics for a row.&quot;&quot;&quot;</span>
        <span class="s1">longWords </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s1">chars </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s1">i </span><span class="s2">= </span><span class="s3">1</span>
        <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">row</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">v</span><span class="s2">:</span>
                <span class="s1">chars </span><span class="s2">+= </span><span class="s1">i</span>
            <span class="s0">if not </span><span class="s2">(-</span><span class="s3">128 </span><span class="s2">&lt;= </span><span class="s1">v </span><span class="s2">&lt;= </span><span class="s3">127</span><span class="s2">):</span>
                <span class="s1">chars </span><span class="s2">+= </span><span class="s1">i </span><span class="s2">* </span><span class="s3">0b0010</span>
            <span class="s0">if not </span><span class="s2">(-</span><span class="s3">32768 </span><span class="s2">&lt;= </span><span class="s1">v </span><span class="s2">&lt;= </span><span class="s3">32767</span><span class="s2">):</span>
                <span class="s1">longWords </span><span class="s2">= </span><span class="s0">True</span>
                <span class="s0">break</span>
            <span class="s1">i </span><span class="s2">&lt;&lt;= </span><span class="s3">4</span>

        <span class="s0">if </span><span class="s1">longWords</span><span class="s2">:</span>
            <span class="s4"># Redo; only allow 2byte/4byte encoding</span>
            <span class="s1">chars </span><span class="s2">= </span><span class="s3">0</span>
            <span class="s1">i </span><span class="s2">= </span><span class="s3">1</span>
            <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">row</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">v</span><span class="s2">:</span>
                    <span class="s1">chars </span><span class="s2">+= </span><span class="s1">i </span><span class="s2">* </span><span class="s3">0b0011</span>
                <span class="s0">if not </span><span class="s2">(-</span><span class="s3">32768 </span><span class="s2">&lt;= </span><span class="s1">v </span><span class="s2">&lt;= </span><span class="s3">32767</span><span class="s2">):</span>
                    <span class="s1">chars </span><span class="s2">+= </span><span class="s1">i </span><span class="s2">* </span><span class="s3">0b1100</span>
                <span class="s1">i </span><span class="s2">&lt;&lt;= </span><span class="s3">4</span>

        <span class="s0">return </span><span class="s1">chars</span>


<span class="s0">def </span><span class="s1">VarStore_optimize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">use_NO_VARIATION_INDEX</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">quantization</span><span class="s2">=</span><span class="s3">1</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Optimize storage. Returns mapping from old VarIdxes to new ones.&quot;&quot;&quot;</span>

    <span class="s4"># Overview:</span>
    <span class="s4">#</span>
    <span class="s4"># For each VarData row, we first extend it with zeroes to have</span>
    <span class="s4"># one column per region in VarRegionList. We then group the</span>
    <span class="s4"># rows into _Encoding objects, by their &quot;characteristic&quot; bitmap.</span>
    <span class="s4"># The characteristic bitmap is a binary number representing how</span>
    <span class="s4"># many bytes each column of the data takes up to encode. Each</span>
    <span class="s4"># column is encoded in four bits. For example, if a column has</span>
    <span class="s4"># only values in the range -128..127, it would only have a single</span>
    <span class="s4"># bit set in the characteristic bitmap for that column. If it has</span>
    <span class="s4"># values in the range -32768..32767, it would have two bits set.</span>
    <span class="s4"># The number of ones in the characteristic bitmap is the &quot;width&quot;</span>
    <span class="s4"># of the encoding.</span>
    <span class="s4">#</span>
    <span class="s4"># Each encoding as such has a number of &quot;active&quot; (ie. non-zero)</span>
    <span class="s4"># columns. The overhead of encoding the characteristic bitmap</span>
    <span class="s4"># is 10 bytes, plus 2 bytes per active column.</span>
    <span class="s4">#</span>
    <span class="s4"># When an encoding is merged into another one, if the characteristic</span>
    <span class="s4"># of the old encoding is a subset of the new one, then the overhead</span>
    <span class="s4"># of the old encoding is completely eliminated. However, each row</span>
    <span class="s4"># now would require more bytes to encode, to the tune of one byte</span>
    <span class="s4"># per characteristic bit that is active in the new encoding but not</span>
    <span class="s4"># in the old one. The number of bits that can be added to an encoding</span>
    <span class="s4"># while still beneficial to merge it into another encoding is called</span>
    <span class="s4"># the &quot;room&quot; for that encoding.</span>
    <span class="s4">#</span>
    <span class="s4"># The &quot;gain&quot; of an encodings is the maximum number of bytes we can</span>
    <span class="s4"># save by merging it into another encoding. The &quot;gain&quot; of merging</span>
    <span class="s4"># two encodings is how many bytes we save by doing so.</span>
    <span class="s4">#</span>
    <span class="s4"># High-level algorithm:</span>
    <span class="s4">#</span>
    <span class="s4"># - Each encoding has a minimal way to encode it. However, because</span>
    <span class="s4">#   of the overhead of encoding the characteristic bitmap, it may</span>
    <span class="s4">#   be beneficial to merge two encodings together, if there is</span>
    <span class="s4">#   gain in doing so. As such, we need to search for the best</span>
    <span class="s4">#   such successive merges.</span>
    <span class="s4">#</span>
    <span class="s4"># Algorithm:</span>
    <span class="s4">#</span>
    <span class="s4"># - Put all encodings into a &quot;todo&quot; list.</span>
    <span class="s4">#</span>
    <span class="s4"># - Sort todo list by decreasing gain (for stability).</span>
    <span class="s4">#</span>
    <span class="s4"># - Make a priority-queue of the gain from combining each two</span>
    <span class="s4">#   encodings in the todo list. The priority queue is sorted by</span>
    <span class="s4">#   decreasing gain. Only positive gains are included.</span>
    <span class="s4">#</span>
    <span class="s4"># - While priority queue is not empty:</span>
    <span class="s4">#   - Pop the first item from the priority queue,</span>
    <span class="s4">#   - Merge the two encodings it represents,</span>
    <span class="s4">#   - Remove the two encodings from the todo list,</span>
    <span class="s4">#   - Insert positive gains from combining the new encoding with</span>
    <span class="s4">#     all existing todo list items into the priority queue,</span>
    <span class="s4">#   - If a todo list item with the same characteristic bitmap as</span>
    <span class="s4">#     the new encoding exists, remove it from the todo list and</span>
    <span class="s4">#     merge it into the new encoding.</span>
    <span class="s4">#   - Insert the new encoding into the todo list,</span>
    <span class="s4">#</span>
    <span class="s4"># - Encode all remaining items in the todo list.</span>
    <span class="s4">#</span>
    <span class="s4"># The output is then sorted for stability, in the following way:</span>
    <span class="s4"># - The VarRegionList of the input is kept intact.</span>
    <span class="s4"># - All encodings are sorted before the main algorithm, by</span>
    <span class="s4">#   gain_key_sort(), which is a tuple of the following items:</span>
    <span class="s4">#   * The gain of the encoding.</span>
    <span class="s4">#   * The characteristic bitmap of the encoding, with higher-numbered</span>
    <span class="s4">#     columns compared first.</span>
    <span class="s4"># - The VarData is sorted by width_sort_key(), which is a tuple</span>
    <span class="s4">#   of the following items:</span>
    <span class="s4">#   * The &quot;width&quot; of the encoding.</span>
    <span class="s4">#   * The characteristic bitmap of the encoding, with higher-numbered</span>
    <span class="s4">#     columns compared first.</span>
    <span class="s4"># - Within each VarData, the items are sorted as vectors of numbers.</span>
    <span class="s4">#</span>
    <span class="s4"># Finally, each VarData is optimized to remove the empty columns and</span>
    <span class="s4"># reorder columns as needed.</span>

    <span class="s4"># TODO</span>
    <span class="s4"># Check that no two VarRegions are the same; if they are, fold them.</span>

    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">VarRegionList</span><span class="s2">.</span><span class="s1">Region</span><span class="s2">)  </span><span class="s4"># Number of columns</span>
    <span class="s1">zeroes </span><span class="s2">= [</span><span class="s3">0</span><span class="s2">] * </span><span class="s1">n</span>

    <span class="s1">front_mapping </span><span class="s2">= {}  </span><span class="s4"># Map from old VarIdxes to full row tuples</span>

    <span class="s1">encodings </span><span class="s2">= </span><span class="s1">_EncodingDict</span><span class="s2">()</span>

    <span class="s4"># Collect all items into a set of full rows (with lots of zeroes.)</span>
    <span class="s0">for </span><span class="s1">major</span><span class="s2">, </span><span class="s1">data </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">VarData</span><span class="s2">):</span>
        <span class="s1">regionIndices </span><span class="s2">= </span><span class="s1">data</span><span class="s2">.</span><span class="s1">VarRegionIndex</span>

        <span class="s0">for </span><span class="s1">minor</span><span class="s2">, </span><span class="s1">item </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">data</span><span class="s2">.</span><span class="s1">Item</span><span class="s2">):</span>
            <span class="s1">row </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">zeroes</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">quantization </span><span class="s2">== </span><span class="s3">1</span><span class="s2">:</span>
                <span class="s0">for </span><span class="s1">regionIdx</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">regionIndices</span><span class="s2">, </span><span class="s1">item</span><span class="s2">):</span>
                    <span class="s1">row</span><span class="s2">[</span><span class="s1">regionIdx</span><span class="s2">] += </span><span class="s1">v</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">for </span><span class="s1">regionIdx</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">regionIndices</span><span class="s2">, </span><span class="s1">item</span><span class="s2">):</span>
                    <span class="s1">row</span><span class="s2">[</span><span class="s1">regionIdx</span><span class="s2">] += (</span>
                        <span class="s1">round</span><span class="s2">(</span><span class="s1">v </span><span class="s2">/ </span><span class="s1">quantization</span><span class="s2">) * </span><span class="s1">quantization</span>
                    <span class="s2">)  </span><span class="s4"># TODO https://github.com/fonttools/fonttools/pull/3126#discussion_r1205439785</span>

            <span class="s1">row </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">row</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">use_NO_VARIATION_INDEX </span><span class="s0">and not </span><span class="s1">any</span><span class="s2">(</span><span class="s1">row</span><span class="s2">):</span>
                <span class="s1">front_mapping</span><span class="s2">[(</span><span class="s1">major </span><span class="s2">&lt;&lt; </span><span class="s3">16</span><span class="s2">) + </span><span class="s1">minor</span><span class="s2">] = </span><span class="s0">None</span>
                <span class="s0">continue</span>

            <span class="s1">encodings</span><span class="s2">.</span><span class="s1">add_row</span><span class="s2">(</span><span class="s1">row</span><span class="s2">)</span>
            <span class="s1">front_mapping</span><span class="s2">[(</span><span class="s1">major </span><span class="s2">&lt;&lt; </span><span class="s3">16</span><span class="s2">) + </span><span class="s1">minor</span><span class="s2">] = </span><span class="s1">row</span>

    <span class="s4"># Prepare for the main algorithm.</span>
    <span class="s1">todo </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">encodings</span><span class="s2">.</span><span class="s1">values</span><span class="s2">(), </span><span class="s1">key</span><span class="s2">=</span><span class="s1">_Encoding</span><span class="s2">.</span><span class="s1">gain_sort_key</span><span class="s2">)</span>
    <span class="s0">del </span><span class="s1">encodings</span>

    <span class="s4"># Repeatedly pick two best encodings to combine, and combine them.</span>

    <span class="s1">heap </span><span class="s2">= []</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">encoding </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">todo</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">i </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">todo</span><span class="s2">)):</span>
            <span class="s1">other_encoding </span><span class="s2">= </span><span class="s1">todo</span><span class="s2">[</span><span class="s1">j</span><span class="s2">]</span>
            <span class="s1">combining_gain </span><span class="s2">= </span><span class="s1">encoding</span><span class="s2">.</span><span class="s1">gain_from_merging</span><span class="s2">(</span><span class="s1">other_encoding</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">combining_gain </span><span class="s2">&gt; </span><span class="s3">0</span><span class="s2">:</span>
                <span class="s1">heappush</span><span class="s2">(</span><span class="s1">heap</span><span class="s2">, (-</span><span class="s1">combining_gain</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">))</span>

    <span class="s0">while </span><span class="s1">heap</span><span class="s2">:</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j </span><span class="s2">= </span><span class="s1">heappop</span><span class="s2">(</span><span class="s1">heap</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">todo</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] </span><span class="s0">is None or </span><span class="s1">todo</span><span class="s2">[</span><span class="s1">j</span><span class="s2">] </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">continue</span>

        <span class="s1">encoding</span><span class="s2">, </span><span class="s1">other_encoding </span><span class="s2">= </span><span class="s1">todo</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">todo</span><span class="s2">[</span><span class="s1">j</span><span class="s2">]</span>
        <span class="s1">todo</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">todo</span><span class="s2">[</span><span class="s1">j</span><span class="s2">] = </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span>

        <span class="s4"># Combine the two encodings</span>
        <span class="s1">combined_chars </span><span class="s2">= </span><span class="s1">other_encoding</span><span class="s2">.</span><span class="s1">chars </span><span class="s2">| </span><span class="s1">encoding</span><span class="s2">.</span><span class="s1">chars</span>
        <span class="s1">combined_encoding </span><span class="s2">= </span><span class="s1">_Encoding</span><span class="s2">(</span><span class="s1">combined_chars</span><span class="s2">)</span>
        <span class="s1">combined_encoding</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">encoding</span><span class="s2">.</span><span class="s1">items</span><span class="s2">)</span>
        <span class="s1">combined_encoding</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">other_encoding</span><span class="s2">.</span><span class="s1">items</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">enc </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">todo</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">enc </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s0">continue</span>

            <span class="s4"># In the unlikely event that the same encoding exists already,</span>
            <span class="s4"># combine it.</span>
            <span class="s0">if </span><span class="s1">enc</span><span class="s2">.</span><span class="s1">chars </span><span class="s2">== </span><span class="s1">combined_chars</span><span class="s2">:</span>
                <span class="s1">combined_encoding</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">enc</span><span class="s2">.</span><span class="s1">items</span><span class="s2">)</span>
                <span class="s1">todo</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s0">None</span>
                <span class="s0">continue</span>

            <span class="s1">combining_gain </span><span class="s2">= </span><span class="s1">combined_encoding</span><span class="s2">.</span><span class="s1">gain_from_merging</span><span class="s2">(</span><span class="s1">enc</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">combining_gain </span><span class="s2">&gt; </span><span class="s3">0</span><span class="s2">:</span>
                <span class="s1">heappush</span><span class="s2">(</span><span class="s1">heap</span><span class="s2">, (-</span><span class="s1">combining_gain</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">todo</span><span class="s2">)))</span>

        <span class="s1">todo</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">combined_encoding</span><span class="s2">)</span>

    <span class="s1">encodings </span><span class="s2">= [</span><span class="s1">encoding </span><span class="s0">for </span><span class="s1">encoding </span><span class="s0">in </span><span class="s1">todo </span><span class="s0">if </span><span class="s1">encoding </span><span class="s0">is not None</span><span class="s2">]</span>

    <span class="s4"># Assemble final store.</span>
    <span class="s1">back_mapping </span><span class="s2">= {}  </span><span class="s4"># Mapping from full rows to new VarIdxes</span>
    <span class="s1">encodings</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">key</span><span class="s2">=</span><span class="s1">_Encoding</span><span class="s2">.</span><span class="s1">width_sort_key</span><span class="s2">)</span>
    <span class="s1">self</span><span class="s2">.</span><span class="s1">VarData </span><span class="s2">= []</span>
    <span class="s0">for </span><span class="s1">encoding </span><span class="s0">in </span><span class="s1">encodings</span><span class="s2">:</span>
        <span class="s1">items </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">encoding</span><span class="s2">.</span><span class="s1">items</span><span class="s2">)</span>

        <span class="s0">while </span><span class="s1">items</span><span class="s2">:</span>
            <span class="s1">major </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">VarData</span><span class="s2">)</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">ot</span><span class="s2">.</span><span class="s1">VarData</span><span class="s2">()</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">VarData</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
            <span class="s1">data</span><span class="s2">.</span><span class="s1">VarRegionIndex </span><span class="s2">= </span><span class="s1">range</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
            <span class="s1">data</span><span class="s2">.</span><span class="s1">VarRegionCount </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">.</span><span class="s1">VarRegionIndex</span><span class="s2">)</span>

            <span class="s4"># Each major can only encode up to 0xFFFF entries.</span>
            <span class="s1">data</span><span class="s2">.</span><span class="s1">Item</span><span class="s2">, </span><span class="s1">items </span><span class="s2">= </span><span class="s1">items</span><span class="s2">[:</span><span class="s3">0xFFFF</span><span class="s2">], </span><span class="s1">items</span><span class="s2">[</span><span class="s3">0xFFFF</span><span class="s2">:]</span>

            <span class="s0">for </span><span class="s1">minor</span><span class="s2">, </span><span class="s1">item </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">data</span><span class="s2">.</span><span class="s1">Item</span><span class="s2">):</span>
                <span class="s1">back_mapping</span><span class="s2">[</span><span class="s1">item</span><span class="s2">] = (</span><span class="s1">major </span><span class="s2">&lt;&lt; </span><span class="s3">16</span><span class="s2">) + </span><span class="s1">minor</span>

    <span class="s4"># Compile final mapping.</span>
    <span class="s1">varidx_map </span><span class="s2">= {</span><span class="s1">NO_VARIATION_INDEX</span><span class="s2">: </span><span class="s1">NO_VARIATION_INDEX</span><span class="s2">}</span>
    <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">front_mapping</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
        <span class="s1">varidx_map</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">back_mapping</span><span class="s2">[</span><span class="s1">v</span><span class="s2">] </span><span class="s0">if </span><span class="s1">v </span><span class="s0">is not None else </span><span class="s1">NO_VARIATION_INDEX</span>

    <span class="s4"># Recalculate things and go home.</span>
    <span class="s1">self</span><span class="s2">.</span><span class="s1">VarRegionList</span><span class="s2">.</span><span class="s1">RegionCount </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">VarRegionList</span><span class="s2">.</span><span class="s1">Region</span><span class="s2">)</span>
    <span class="s1">self</span><span class="s2">.</span><span class="s1">VarDataCount </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">VarData</span><span class="s2">)</span>
    <span class="s0">for </span><span class="s1">data </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">VarData</span><span class="s2">:</span>
        <span class="s1">data</span><span class="s2">.</span><span class="s1">ItemCount </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">.</span><span class="s1">Item</span><span class="s2">)</span>
        <span class="s1">data</span><span class="s2">.</span><span class="s1">optimize</span><span class="s2">()</span>

    <span class="s4"># Remove unused regions.</span>
    <span class="s1">self</span><span class="s2">.</span><span class="s1">prune_regions</span><span class="s2">()</span>

    <span class="s0">return </span><span class="s1">varidx_map</span>


<span class="s1">ot</span><span class="s2">.</span><span class="s1">VarStore</span><span class="s2">.</span><span class="s1">optimize </span><span class="s2">= </span><span class="s1">VarStore_optimize</span>


<span class="s0">def </span><span class="s1">main</span><span class="s2">(</span><span class="s1">args</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Optimize a font's GDEF variation store&quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">argparse </span><span class="s0">import </span><span class="s1">ArgumentParser</span>
    <span class="s0">from </span><span class="s1">fontTools </span><span class="s0">import </span><span class="s1">configLogger</span>
    <span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">ttLib </span><span class="s0">import </span><span class="s1">TTFont</span>
    <span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">ttLib</span><span class="s2">.</span><span class="s1">tables</span><span class="s2">.</span><span class="s1">otBase </span><span class="s0">import </span><span class="s1">OTTableWriter</span>

    <span class="s1">parser </span><span class="s2">= </span><span class="s1">ArgumentParser</span><span class="s2">(</span><span class="s1">prog</span><span class="s2">=</span><span class="s5">&quot;varLib.varStore&quot;</span><span class="s2">, </span><span class="s1">description</span><span class="s2">=</span><span class="s1">main</span><span class="s2">.</span><span class="s1">__doc__</span><span class="s2">)</span>
    <span class="s1">parser</span><span class="s2">.</span><span class="s1">add_argument</span><span class="s2">(</span><span class="s5">&quot;--quantization&quot;</span><span class="s2">, </span><span class="s1">type</span><span class="s2">=</span><span class="s1">int</span><span class="s2">, </span><span class="s1">default</span><span class="s2">=</span><span class="s3">1</span><span class="s2">)</span>
    <span class="s1">parser</span><span class="s2">.</span><span class="s1">add_argument</span><span class="s2">(</span><span class="s5">&quot;fontfile&quot;</span><span class="s2">)</span>
    <span class="s1">parser</span><span class="s2">.</span><span class="s1">add_argument</span><span class="s2">(</span><span class="s5">&quot;outfile&quot;</span><span class="s2">, </span><span class="s1">nargs</span><span class="s2">=</span><span class="s5">&quot;?&quot;</span><span class="s2">)</span>
    <span class="s1">options </span><span class="s2">= </span><span class="s1">parser</span><span class="s2">.</span><span class="s1">parse_args</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>

    <span class="s4"># TODO: allow user to configure logging via command-line options</span>
    <span class="s1">configLogger</span><span class="s2">(</span><span class="s1">level</span><span class="s2">=</span><span class="s5">&quot;INFO&quot;</span><span class="s2">)</span>

    <span class="s1">quantization </span><span class="s2">= </span><span class="s1">options</span><span class="s2">.</span><span class="s1">quantization</span>
    <span class="s1">fontfile </span><span class="s2">= </span><span class="s1">options</span><span class="s2">.</span><span class="s1">fontfile</span>
    <span class="s1">outfile </span><span class="s2">= </span><span class="s1">options</span><span class="s2">.</span><span class="s1">outfile</span>

    <span class="s1">font </span><span class="s2">= </span><span class="s1">TTFont</span><span class="s2">(</span><span class="s1">fontfile</span><span class="s2">)</span>
    <span class="s1">gdef </span><span class="s2">= </span><span class="s1">font</span><span class="s2">[</span><span class="s5">&quot;GDEF&quot;</span><span class="s2">]</span>
    <span class="s1">store </span><span class="s2">= </span><span class="s1">gdef</span><span class="s2">.</span><span class="s1">table</span><span class="s2">.</span><span class="s1">VarStore</span>

    <span class="s1">writer </span><span class="s2">= </span><span class="s1">OTTableWriter</span><span class="s2">()</span>
    <span class="s1">store</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s1">writer</span><span class="s2">, </span><span class="s1">font</span><span class="s2">)</span>
    <span class="s1">size </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">writer</span><span class="s2">.</span><span class="s1">getAllData</span><span class="s2">())</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s5">&quot;Before: %7d bytes&quot; </span><span class="s2">% </span><span class="s1">size</span><span class="s2">)</span>

    <span class="s1">varidx_map </span><span class="s2">= </span><span class="s1">store</span><span class="s2">.</span><span class="s1">optimize</span><span class="s2">(</span><span class="s1">quantization</span><span class="s2">=</span><span class="s1">quantization</span><span class="s2">)</span>

    <span class="s1">writer </span><span class="s2">= </span><span class="s1">OTTableWriter</span><span class="s2">()</span>
    <span class="s1">store</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s1">writer</span><span class="s2">, </span><span class="s1">font</span><span class="s2">)</span>
    <span class="s1">size </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">writer</span><span class="s2">.</span><span class="s1">getAllData</span><span class="s2">())</span>
    <span class="s1">print</span><span class="s2">(</span><span class="s5">&quot;After:  %7d bytes&quot; </span><span class="s2">% </span><span class="s1">size</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">outfile </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">gdef</span><span class="s2">.</span><span class="s1">table</span><span class="s2">.</span><span class="s1">remap_device_varidxes</span><span class="s2">(</span><span class="s1">varidx_map</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s5">&quot;GPOS&quot; </span><span class="s0">in </span><span class="s1">font</span><span class="s2">:</span>
            <span class="s1">font</span><span class="s2">[</span><span class="s5">&quot;GPOS&quot;</span><span class="s2">].</span><span class="s1">table</span><span class="s2">.</span><span class="s1">remap_device_varidxes</span><span class="s2">(</span><span class="s1">varidx_map</span><span class="s2">)</span>

        <span class="s1">font</span><span class="s2">.</span><span class="s1">save</span><span class="s2">(</span><span class="s1">outfile</span><span class="s2">)</span>


<span class="s0">if </span><span class="s1">__name__ </span><span class="s2">== </span><span class="s5">&quot;__main__&quot;</span><span class="s2">:</span>
    <span class="s0">import </span><span class="s1">sys</span>

    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">argv</span><span class="s2">) &gt; </span><span class="s3">1</span><span class="s2">:</span>
        <span class="s1">sys</span><span class="s2">.</span><span class="s1">exit</span><span class="s2">(</span><span class="s1">main</span><span class="s2">())</span>
    <span class="s0">import </span><span class="s1">doctest</span>

    <span class="s1">sys</span><span class="s2">.</span><span class="s1">exit</span><span class="s2">(</span><span class="s1">doctest</span><span class="s2">.</span><span class="s1">testmod</span><span class="s2">().</span><span class="s1">failed</span><span class="s2">)</span>
</pre>
</body>
</html>