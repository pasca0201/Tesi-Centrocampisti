<html>
<head>
<title>_differentiate.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_differentiate.py</font>
</center></td></tr></table>
<pre><span class="s0"># mypy: disable-error-code=&quot;attr-defined&quot;</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">_lib</span><span class="s3">.</span><span class="s1">_elementwise_iterative_method </span><span class="s2">as </span><span class="s1">eim</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">_lib</span><span class="s3">.</span><span class="s1">_util </span><span class="s2">import </span><span class="s1">_RichResult</span>

<span class="s1">_EERRORINCREASE </span><span class="s3">= -</span><span class="s4">1  </span><span class="s0"># used in _differentiate</span>

<span class="s2">def </span><span class="s1">_differentiate_iv</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s1">initial_step</span><span class="s3">,</span>
                      <span class="s1">step_factor</span><span class="s3">, </span><span class="s1">step_direction</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">):</span>
    <span class="s0"># Input validation for `_differentiate`</span>

    <span class="s2">if not </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">func</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">'`func` must be callable.'</span><span class="s3">)</span>

    <span class="s0"># x has more complex IV that is taken care of during initialization</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">dtype </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inexact</span><span class="s3">) </span><span class="s2">else </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span>

    <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iterable</span><span class="s3">(</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s1">args </span><span class="s3">= (</span><span class="s1">args</span><span class="s3">,)</span>

    <span class="s2">if </span><span class="s1">atol </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">atol </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">tiny</span>

    <span class="s2">if </span><span class="s1">rtol </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">rtol </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">eps</span><span class="s3">)</span>

    <span class="s1">message </span><span class="s3">= </span><span class="s5">'Tolerances and step parameters must be non-negative scalars.'</span>
    <span class="s1">tols </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">([</span><span class="s1">atol</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">, </span><span class="s1">initial_step</span><span class="s3">, </span><span class="s1">step_factor</span><span class="s3">])</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">tols</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">number</span><span class="s3">)</span>
            <span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">tols </span><span class="s3">&lt; </span><span class="s4">0</span><span class="s3">)</span>
            <span class="s2">or </span><span class="s1">tols</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= (</span><span class="s4">4</span><span class="s3">,)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">message</span><span class="s3">)</span>
    <span class="s1">initial_step</span><span class="s3">, </span><span class="s1">step_factor </span><span class="s3">= </span><span class="s1">tols</span><span class="s3">[</span><span class="s4">2</span><span class="s3">:].</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">maxiter_int </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">maxiter</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">maxiter </span><span class="s3">!= </span><span class="s1">maxiter_int </span><span class="s2">or </span><span class="s1">maxiter </span><span class="s3">&lt;= </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">'`maxiter` must be a positive integer.'</span><span class="s3">)</span>

    <span class="s1">order_int </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">order</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">order_int </span><span class="s3">!= </span><span class="s1">order </span><span class="s2">or </span><span class="s1">order </span><span class="s3">&lt;= </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">'`order` must be a positive integer.'</span><span class="s3">)</span>

    <span class="s1">step_direction </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sign</span><span class="s3">(</span><span class="s1">step_direction</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">step_direction </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_arrays</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">step_direction</span><span class="s3">)</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">step_direction </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[()], </span><span class="s1">step_direction</span><span class="s3">[()]</span>

    <span class="s1">message </span><span class="s3">= </span><span class="s5">'`preserve_shape` must be True or False.'</span>
    <span class="s2">if </span><span class="s1">preserve_shape </span><span class="s2">not in </span><span class="s3">{</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">}:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">message</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">callback </span><span class="s2">is not None and not </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">callback</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s5">'`callback` must be callable.'</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">, </span><span class="s1">maxiter_int</span><span class="s3">, </span><span class="s1">order_int</span><span class="s3">, </span><span class="s1">initial_step</span><span class="s3">,</span>
            <span class="s1">step_factor</span><span class="s3">, </span><span class="s1">step_direction</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_differentiate</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, *, </span><span class="s1">args</span><span class="s3">=(), </span><span class="s1">atol</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">=</span><span class="s4">10</span><span class="s3">,</span>
                   <span class="s1">order</span><span class="s3">=</span><span class="s4">8</span><span class="s3">, </span><span class="s1">initial_step</span><span class="s3">=</span><span class="s4">0.5</span><span class="s3">, </span><span class="s1">step_factor</span><span class="s3">=</span><span class="s4">2.0</span><span class="s3">,</span>
                   <span class="s1">step_direction</span><span class="s3">=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Evaluate the derivative of an elementwise scalar function numerically. 
 
    Parameters 
    ---------- 
    func : callable 
        The function whose derivative is desired. The signature must be:: 
 
            func(x: ndarray, *fargs) -&gt; ndarray 
 
         where each element of ``x`` is a finite real number and ``fargs`` is a tuple, 
         which may contain an arbitrary number of arrays that are broadcastable 
         with `x`. ``func`` must be an elementwise function: each element 
         ``func(x)[i]`` must equal ``func(x[i])`` for all indices ``i``. 
    x : array_like 
        Abscissae at which to evaluate the derivative. 
    args : tuple, optional 
        Additional positional arguments to be passed to `func`. Must be arrays 
        broadcastable with `x`. If the callable to be differentiated requires 
        arguments that are not broadcastable with `x`, wrap that callable with 
        `func`. See Examples. 
    atol, rtol : float, optional 
        Absolute and relative tolerances for the stopping condition: iteration 
        will stop when ``res.error &lt; atol + rtol * abs(res.df)``. The default 
        `atol` is the smallest normal number of the appropriate dtype, and 
        the default `rtol` is the square root of the precision of the 
        appropriate dtype. 
    order : int, default: 8 
        The (positive integer) order of the finite difference formula to be 
        used. Odd integers will be rounded up to the next even integer. 
    initial_step : float, default: 0.5 
        The (absolute) initial step size for the finite difference derivative 
        approximation. 
    step_factor : float, default: 2.0 
        The factor by which the step size is *reduced* in each iteration; i.e. 
        the step size in iteration 1 is ``initial_step/step_factor``. If 
        ``step_factor &lt; 1``, subsequent steps will be greater than the initial 
        step; this may be useful if steps smaller than some threshold are 
        undesirable (e.g. due to subtractive cancellation error). 
    maxiter : int, default: 10 
        The maximum number of iterations of the algorithm to perform. See 
        notes. 
    step_direction : array_like 
        An array representing the direction of the finite difference steps (for 
        use when `x` lies near to the boundary of the domain of the function.) 
        Must be broadcastable with `x` and all `args`. 
        Where 0 (default), central differences are used; where negative (e.g. 
        -1), steps are non-positive; and where positive (e.g. 1), all steps are 
        non-negative. 
    preserve_shape : bool, default: False 
        In the following, &quot;arguments of `func`&quot; refers to the array ``x`` and 
        any arrays within ``fargs``. Let ``shape`` be the broadcasted shape 
        of `x` and all elements of `args` (which is conceptually 
        distinct from ``fargs`` passed into `f`). 
 
        - When ``preserve_shape=False`` (default), `f` must accept arguments 
          of *any* broadcastable shapes. 
 
        - When ``preserve_shape=True``, `f` must accept arguments of shape 
          ``shape`` *or* ``shape + (n,)``, where ``(n,)`` is the number of 
          abscissae at which the function is being evaluated. 
 
        In either case, for each scalar element ``xi`` within `x`, the array 
        returned by `f` must include the scalar ``f(xi)`` at the same index. 
        Consequently, the shape of the output is always the shape of the input 
        ``x``. 
 
        See Examples. 
    callback : callable, optional 
        An optional user-supplied function to be called before the first 
        iteration and after each iteration. 
        Called as ``callback(res)``, where ``res`` is a ``_RichResult`` 
        similar to that returned by `_differentiate` (but containing the 
        current iterate's values of all variables). If `callback` raises a 
        ``StopIteration``, the algorithm will terminate immediately and 
        `_differentiate` will return a result. 
 
    Returns 
    ------- 
    res : _RichResult 
        An instance of `scipy._lib._util._RichResult` with the following 
        attributes. (The descriptions are written as though the values will be 
        scalars; however, if `func` returns an array, the outputs will be 
        arrays of the same shape.) 
 
        success : bool 
            ``True`` when the algorithm terminated successfully (status ``0``). 
        status : int 
            An integer representing the exit status of the algorithm. 
            ``0`` : The algorithm converged to the specified tolerances. 
            ``-1`` : The error estimate increased, so iteration was terminated. 
            ``-2`` : The maximum number of iterations was reached. 
            ``-3`` : A non-finite value was encountered. 
            ``-4`` : Iteration was terminated by `callback`. 
            ``1`` : The algorithm is proceeding normally (in `callback` only). 
        df : float 
            The derivative of `func` at `x`, if the algorithm terminated 
            successfully. 
        error : float 
            An estimate of the error: the magnitude of the difference between 
            the current estimate of the derivative and the estimate in the 
            previous iteration. 
        nit : int 
            The number of iterations performed. 
        nfev : int 
            The number of points at which `func` was evaluated. 
        x : float 
            The value at which the derivative of `func` was evaluated 
            (after broadcasting with `args` and `step_direction`). 
 
    Notes 
    ----- 
    The implementation was inspired by jacobi [1]_, numdifftools [2]_, and 
    DERIVEST [3]_, but the implementation follows the theory of Taylor series 
    more straightforwardly (and arguably naively so). 
    In the first iteration, the derivative is estimated using a finite 
    difference formula of order `order` with maximum step size `initial_step`. 
    Each subsequent iteration, the maximum step size is reduced by 
    `step_factor`, and the derivative is estimated again until a termination 
    condition is reached. The error estimate is the magnitude of the difference 
    between the current derivative approximation and that of the previous 
    iteration. 
 
    The stencils of the finite difference formulae are designed such that 
    abscissae are &quot;nested&quot;: after `func` is evaluated at ``order + 1`` 
    points in the first iteration, `func` is evaluated at only two new points 
    in each subsequent iteration; ``order - 1`` previously evaluated function 
    values required by the finite difference formula are reused, and two 
    function values (evaluations at the points furthest from `x`) are unused. 
 
    Step sizes are absolute. When the step size is small relative to the 
    magnitude of `x`, precision is lost; for example, if `x` is ``1e20``, the 
    default initial step size of ``0.5`` cannot be resolved. Accordingly, 
    consider using larger initial step sizes for large magnitudes of `x`. 
 
    The default tolerances are challenging to satisfy at points where the 
    true derivative is exactly zero. If the derivative may be exactly zero, 
    consider specifying an absolute tolerance (e.g. ``atol=1e-16``) to 
    improve convergence. 
 
    References 
    ---------- 
    [1]_ Hans Dembinski (@HDembinski). jacobi. 
         https://github.com/HDembinski/jacobi 
    [2]_ Per A. Brodtkorb and John D'Errico. numdifftools. 
         https://numdifftools.readthedocs.io/en/latest/ 
    [3]_ John D'Errico. DERIVEST: Adaptive Robust Numerical Differentiation. 
         https://www.mathworks.com/matlabcentral/fileexchange/13490-adaptive-robust-numerical-differentiation 
    [4]_ Numerical Differentition. Wikipedia. 
         https://en.wikipedia.org/wiki/Numerical_differentiation 
 
    Examples 
    -------- 
    Evaluate the derivative of ``np.exp`` at several points ``x``. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.optimize._differentiate import _differentiate 
    &gt;&gt;&gt; f = np.exp 
    &gt;&gt;&gt; df = np.exp  # true derivative 
    &gt;&gt;&gt; x = np.linspace(1, 2, 5) 
    &gt;&gt;&gt; res = _differentiate(f, x) 
    &gt;&gt;&gt; res.df  # approximation of the derivative 
    array([2.71828183, 3.49034296, 4.48168907, 5.75460268, 7.3890561 ]) 
    &gt;&gt;&gt; res.error  # estimate of the error 
    array( 
        [7.12940817e-12, 9.16688947e-12, 1.17594823e-11, 1.50972568e-11, 1.93942640e-11] 
    ) 
    &gt;&gt;&gt; abs(res.df - df(x))  # true error 
    array( 
        [3.06421555e-14, 3.01980663e-14, 5.06261699e-14, 6.30606678e-14, 8.34887715e-14] 
    ) 
 
    Show the convergence of the approximation as the step size is reduced. 
    Each iteration, the step size is reduced by `step_factor`, so for 
    sufficiently small initial step, each iteration reduces the error by a 
    factor of ``1/step_factor**order`` until finite precision arithmetic 
    inhibits further improvement. 
 
    &gt;&gt;&gt; iter = list(range(1, 12))  # maximum iterations 
    &gt;&gt;&gt; hfac = 2  # step size reduction per iteration 
    &gt;&gt;&gt; hdir = [-1, 0, 1]  # compare left-, central-, and right- steps 
    &gt;&gt;&gt; order = 4  # order of differentiation formula 
    &gt;&gt;&gt; x = 1 
    &gt;&gt;&gt; ref = df(x) 
    &gt;&gt;&gt; errors = []  # true error 
    &gt;&gt;&gt; for i in iter: 
    ...     res = _differentiate(f, x, maxiter=i, step_factor=hfac, 
    ...                          step_direction=hdir, order=order, 
    ...                          atol=0, rtol=0)  # prevent early termination 
    ...     errors.append(abs(res.df - ref)) 
    &gt;&gt;&gt; errors = np.array(errors) 
    &gt;&gt;&gt; plt.semilogy(iter, errors[:, 0], label='left differences') 
    &gt;&gt;&gt; plt.semilogy(iter, errors[:, 1], label='central differences') 
    &gt;&gt;&gt; plt.semilogy(iter, errors[:, 2], label='right differences') 
    &gt;&gt;&gt; plt.xlabel('iteration') 
    &gt;&gt;&gt; plt.ylabel('error') 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.show() 
    &gt;&gt;&gt; (errors[1, 1] / errors[0, 1], 1 / hfac**order) 
    (0.06215223140159822, 0.0625) 
 
    The implementation is vectorized over `x`, `step_direction`, and `args`. 
    The function is evaluated once before the first iteration to perform input 
    validation and standardization, and once per iteration thereafter. 
 
    &gt;&gt;&gt; def f(x, p): 
    ...     print('here') 
    ...     f.nit += 1 
    ...     return x**p 
    &gt;&gt;&gt; f.nit = 0 
    &gt;&gt;&gt; def df(x, p): 
    ...     return p*x**(p-1) 
    &gt;&gt;&gt; x = np.arange(1, 5) 
    &gt;&gt;&gt; p = np.arange(1, 6).reshape((-1, 1)) 
    &gt;&gt;&gt; hdir = np.arange(-1, 2).reshape((-1, 1, 1)) 
    &gt;&gt;&gt; res = _differentiate(f, x, args=(p,), step_direction=hdir, maxiter=1) 
    &gt;&gt;&gt; np.allclose(res.df, df(x, p)) 
    True 
    &gt;&gt;&gt; res.df.shape 
    (3, 5, 4) 
    &gt;&gt;&gt; f.nit 
    2 
 
    By default, `preserve_shape` is False, and therefore the callable 
    `f` may be called with arrays of any broadcastable shapes. 
    For example: 
 
    &gt;&gt;&gt; shapes = [] 
    &gt;&gt;&gt; def f(x, c): 
    ...    shape = np.broadcast_shapes(x.shape, c.shape) 
    ...    shapes.append(shape) 
    ...    return np.sin(c*x) 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; c = [1, 5, 10, 20] 
    &gt;&gt;&gt; res = _differentiate(f, 0, args=(c,)) 
    &gt;&gt;&gt; shapes 
    [(4,), (4, 8), (4, 2), (3, 2), (2, 2), (1, 2)] 
 
    To understand where these shapes are coming from - and to better 
    understand how `_differentiate` computes accurate results - note that 
    higher values of ``c`` correspond with higher frequency sinusoids. 
    The higher frequency sinusoids make the function's derivative change 
    faster, so more function evaluations are required to achieve the target 
    accuracy: 
 
    &gt;&gt;&gt; res.nfev 
    array([11, 13, 15, 17]) 
 
    The initial ``shape``, ``(4,)``, corresponds with evaluating the 
    function at a single abscissa and all four frequencies; this is used 
    for input validation and to determine the size and dtype of the arrays 
    that store results. The next shape corresponds with evaluating the 
    function at an initial grid of abscissae and all four frequencies. 
    Successive calls to the function evaluate the function at two more 
    abscissae, increasing the effective order of the approximation by two. 
    However, in later function evaluations, the function is evaluated at 
    fewer frequencies because the corresponding derivative has already 
    converged to the required tolerance. This saves function evaluations to 
    improve performance, but it requires the function to accept arguments of 
    any shape. 
 
    &quot;Vector-valued&quot; functions are unlikely to satisfy this requirement. 
    For example, consider 
 
    &gt;&gt;&gt; def f(x): 
    ...    return [x, np.sin(3*x), x+np.sin(10*x), np.sin(20*x)*(x-1)**2] 
 
    This integrand is not compatible with `_differentiate` as written; for instance, 
    the shape of the output will not be the same as the shape of ``x``. Such a 
    function *could* be converted to a compatible form with the introduction of 
    additional parameters, but this would be inconvenient. In such cases, 
    a simpler solution would be to use `preserve_shape`. 
 
    &gt;&gt;&gt; shapes = [] 
    &gt;&gt;&gt; def f(x): 
    ...     shapes.append(x.shape) 
    ...     x0, x1, x2, x3 = x 
    ...     return [x0, np.sin(3*x1), x2+np.sin(10*x2), np.sin(20*x3)*(x3-1)**2] 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; x = np.zeros(4) 
    &gt;&gt;&gt; res = _differentiate(f, x, preserve_shape=True) 
    &gt;&gt;&gt; shapes 
    [(4,), (4, 8), (4, 2), (4, 2), (4, 2), (4, 2)] 
 
    Here, the shape of ``x`` is ``(4,)``. With ``preserve_shape=True``, the 
    function may be called with argument ``x`` of shape ``(4,)`` or ``(4, n)``, 
    and this is what we observe. 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># TODO (followup):</span>
    <span class="s0">#  - investigate behavior at saddle points</span>
    <span class="s0">#  - array initial_step / step_factor?</span>
    <span class="s0">#  - multivariate functions?</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">_differentiate_iv</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s1">initial_step</span><span class="s3">,</span>
                            <span class="s1">step_factor</span><span class="s3">, </span><span class="s1">step_direction</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">)</span>
    <span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">, </span><span class="s1">order</span><span class="s3">,</span>
     <span class="s1">h0</span><span class="s3">, </span><span class="s1">fac</span><span class="s3">, </span><span class="s1">hdir</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">) = </span><span class="s1">res</span>

    <span class="s0"># Initialization</span>
    <span class="s0"># Since f(x) (no step) is not needed for central differences, it may be</span>
    <span class="s0"># possible to eliminate this function evaluation. However, it's useful for</span>
    <span class="s0"># input validation and standardization, and everything else is designed to</span>
    <span class="s0"># reduce function calls, so let's keep it simple.</span>
    <span class="s1">temp </span><span class="s3">= </span><span class="s1">eim</span><span class="s3">.</span><span class="s1">_initialize</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, (</span><span class="s1">x</span><span class="s3">,), </span><span class="s1">args</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">=</span><span class="s1">preserve_shape</span><span class="s3">)</span>
    <span class="s1">func</span><span class="s3">, </span><span class="s1">xs</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">xp </span><span class="s3">= </span><span class="s1">temp</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">f </span><span class="s3">= </span><span class="s1">xs</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">fs</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
    <span class="s1">df </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full_like</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">)</span>
    <span class="s0"># Ideally we'd broadcast the shape of `hdir` in `_elementwise_algo_init`, but</span>
    <span class="s0"># it's simpler to do it here than to generalize `_elementwise_algo_init` further.</span>
    <span class="s0"># `hdir` and `x` are already broadcasted in `_differentiate_iv`, so we know</span>
    <span class="s0"># that `hdir` can be broadcasted to the final shape.</span>
    <span class="s1">hdir </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">hdir</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">).</span><span class="s1">flatten</span><span class="s3">()</span>

    <span class="s1">status </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full_like</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">eim</span><span class="s3">.</span><span class="s1">_EINPROGRESS</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">int</span><span class="s3">)  </span><span class="s0"># in progress</span>
    <span class="s1">nit</span><span class="s3">, </span><span class="s1">nfev </span><span class="s3">= </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1  </span><span class="s0"># one function evaluations performed above</span>
    <span class="s0"># Boolean indices of left, central, right, and (all) one-sided steps</span>
    <span class="s1">il </span><span class="s3">= </span><span class="s1">hdir </span><span class="s3">&lt; </span><span class="s4">0</span>
    <span class="s1">ic </span><span class="s3">= </span><span class="s1">hdir </span><span class="s3">== </span><span class="s4">0</span>
    <span class="s1">ir </span><span class="s3">= </span><span class="s1">hdir </span><span class="s3">&gt; </span><span class="s4">0</span>
    <span class="s1">io </span><span class="s3">= </span><span class="s1">il </span><span class="s3">| </span><span class="s1">ir</span>

    <span class="s0"># Most of these attributes are reasonably obvious, but:</span>
    <span class="s0"># - `fs` holds all the function values of all active `x`. The zeroth</span>
    <span class="s0">#   axis corresponds with active points `x`, the first axis corresponds</span>
    <span class="s0">#   with the different steps (in the order described in</span>
    <span class="s0">#   `_differentiate_weights`).</span>
    <span class="s0"># - `terms` (which could probably use a better name) is half the `order`,</span>
    <span class="s0">#   which is always even.</span>
    <span class="s1">work </span><span class="s3">= </span><span class="s1">_RichResult</span><span class="s3">(</span><span class="s1">x</span><span class="s3">=</span><span class="s1">x</span><span class="s3">, </span><span class="s1">df</span><span class="s3">=</span><span class="s1">df</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s1">f</span><span class="s3">[:, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">newaxis</span><span class="s3">], </span><span class="s1">error</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">h</span><span class="s3">=</span><span class="s1">h0</span><span class="s3">,</span>
                       <span class="s1">df_last</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">error_last</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">h0</span><span class="s3">=</span><span class="s1">h0</span><span class="s3">, </span><span class="s1">fac</span><span class="s3">=</span><span class="s1">fac</span><span class="s3">,</span>
                       <span class="s1">atol</span><span class="s3">=</span><span class="s1">atol</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s1">rtol</span><span class="s3">, </span><span class="s1">nit</span><span class="s3">=</span><span class="s1">nit</span><span class="s3">, </span><span class="s1">nfev</span><span class="s3">=</span><span class="s1">nfev</span><span class="s3">,</span>
                       <span class="s1">status</span><span class="s3">=</span><span class="s1">status</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">terms</span><span class="s3">=(</span><span class="s1">order</span><span class="s3">+</span><span class="s4">1</span><span class="s3">)//</span><span class="s4">2</span><span class="s3">,</span>
                       <span class="s1">hdir</span><span class="s3">=</span><span class="s1">hdir</span><span class="s3">, </span><span class="s1">il</span><span class="s3">=</span><span class="s1">il</span><span class="s3">, </span><span class="s1">ic</span><span class="s3">=</span><span class="s1">ic</span><span class="s3">, </span><span class="s1">ir</span><span class="s3">=</span><span class="s1">ir</span><span class="s3">, </span><span class="s1">io</span><span class="s3">=</span><span class="s1">io</span><span class="s3">)</span>
    <span class="s0"># This is the correspondence between terms in the `work` object and the</span>
    <span class="s0"># final result. In this case, the mapping is trivial. Note that `success`</span>
    <span class="s0"># is prepended automatically.</span>
    <span class="s1">res_work_pairs </span><span class="s3">= [(</span><span class="s5">'status'</span><span class="s3">, </span><span class="s5">'status'</span><span class="s3">), (</span><span class="s5">'df'</span><span class="s3">, </span><span class="s5">'df'</span><span class="s3">), (</span><span class="s5">'error'</span><span class="s3">, </span><span class="s5">'error'</span><span class="s3">),</span>
                      <span class="s3">(</span><span class="s5">'nit'</span><span class="s3">, </span><span class="s5">'nit'</span><span class="s3">), (</span><span class="s5">'nfev'</span><span class="s3">, </span><span class="s5">'nfev'</span><span class="s3">), (</span><span class="s5">'x'</span><span class="s3">, </span><span class="s5">'x'</span><span class="s3">)]</span>

    <span class="s2">def </span><span class="s1">pre_func_eval</span><span class="s3">(</span><span class="s1">work</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Determine the abscissae at which the function needs to be evaluated. 
 
        See `_differentiate_weights` for a description of the stencil (pattern 
        of the abscissae). 
 
        In the first iteration, there is only one stored function value in 
        `work.fs`, `f(x)`, so we need to evaluate at `order` new points. In 
        subsequent iterations, we evaluate at two new points. Note that 
        `work.x` is always flattened into a 1D array after broadcasting with 
        all `args`, so we add a new axis at the end and evaluate all point 
        in one call to the function. 
 
        For improvement: 
        - Consider measuring the step size actually taken, since `(x + h) - x` 
          is not identically equal to `h` with floating point arithmetic. 
        - Adjust the step size automatically if `x` is too big to resolve the 
          step. 
        - We could probably save some work if there are no central difference 
          steps or no one-sided steps. 
        &quot;&quot;&quot;</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">work</span><span class="s3">.</span><span class="s1">terms  </span><span class="s0"># half the order</span>
        <span class="s1">h </span><span class="s3">= </span><span class="s1">work</span><span class="s3">.</span><span class="s1">h  </span><span class="s0"># step size</span>
        <span class="s1">c </span><span class="s3">= </span><span class="s1">work</span><span class="s3">.</span><span class="s1">fac  </span><span class="s0"># step reduction factor</span>
        <span class="s1">d </span><span class="s3">= </span><span class="s1">c</span><span class="s3">**</span><span class="s4">0.5  </span><span class="s0"># square root of step reduction factor (one-sided stencil)</span>
        <span class="s0"># Note - no need to be careful about dtypes until we allocate `x_eval`</span>

        <span class="s2">if </span><span class="s1">work</span><span class="s3">.</span><span class="s1">nit </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s1">hc </span><span class="s3">= </span><span class="s1">h </span><span class="s3">/ </span><span class="s1">c</span><span class="s3">**</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
            <span class="s1">hc </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((-</span><span class="s1">hc</span><span class="s3">[::-</span><span class="s4">1</span><span class="s3">], </span><span class="s1">hc</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">hc </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">([-</span><span class="s1">h</span><span class="s3">, </span><span class="s1">h</span><span class="s3">]) / </span><span class="s1">c</span><span class="s3">**(</span><span class="s1">n</span><span class="s3">-</span><span class="s4">1</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">work</span><span class="s3">.</span><span class="s1">nit </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s1">hr </span><span class="s3">= </span><span class="s1">h </span><span class="s3">/ </span><span class="s1">d</span><span class="s3">**</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">2</span><span class="s3">*</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">hr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">([</span><span class="s1">h</span><span class="s3">, </span><span class="s1">h</span><span class="s3">/</span><span class="s1">d</span><span class="s3">]) / </span><span class="s1">c</span><span class="s3">**(</span><span class="s1">n</span><span class="s3">-</span><span class="s4">1</span><span class="s3">)</span>

        <span class="s1">n_new </span><span class="s3">= </span><span class="s4">2</span><span class="s3">*</span><span class="s1">n </span><span class="s2">if </span><span class="s1">work</span><span class="s3">.</span><span class="s1">nit </span><span class="s3">== </span><span class="s4">0 </span><span class="s2">else </span><span class="s4">2  </span><span class="s0"># number of new abscissae</span>
        <span class="s1">x_eval </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">len</span><span class="s3">(</span><span class="s1">work</span><span class="s3">.</span><span class="s1">hdir</span><span class="s3">), </span><span class="s1">n_new</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">work</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">il</span><span class="s3">, </span><span class="s1">ic</span><span class="s3">, </span><span class="s1">ir </span><span class="s3">= </span><span class="s1">work</span><span class="s3">.</span><span class="s1">il</span><span class="s3">, </span><span class="s1">work</span><span class="s3">.</span><span class="s1">ic</span><span class="s3">, </span><span class="s1">work</span><span class="s3">.</span><span class="s1">ir</span>
        <span class="s1">x_eval</span><span class="s3">[</span><span class="s1">ir</span><span class="s3">] = </span><span class="s1">work</span><span class="s3">.</span><span class="s1">x</span><span class="s3">[</span><span class="s1">ir</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">newaxis</span><span class="s3">] + </span><span class="s1">hr</span>
        <span class="s1">x_eval</span><span class="s3">[</span><span class="s1">ic</span><span class="s3">] = </span><span class="s1">work</span><span class="s3">.</span><span class="s1">x</span><span class="s3">[</span><span class="s1">ic</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">newaxis</span><span class="s3">] + </span><span class="s1">hc</span>
        <span class="s1">x_eval</span><span class="s3">[</span><span class="s1">il</span><span class="s3">] = </span><span class="s1">work</span><span class="s3">.</span><span class="s1">x</span><span class="s3">[</span><span class="s1">il</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">newaxis</span><span class="s3">] - </span><span class="s1">hr</span>
        <span class="s2">return </span><span class="s1">x_eval</span>

    <span class="s2">def </span><span class="s1">post_func_eval</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">f</span><span class="s3">, </span><span class="s1">work</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot; Estimate the derivative and error from the function evaluations 
 
        As in `pre_func_eval`: in the first iteration, there is only one stored 
        function value in `work.fs`, `f(x)`, so we need to add the `order` new 
        points. In subsequent iterations, we add two new points. The tricky 
        part is getting the order to match that of the weights, which is 
        described in `_differentiate_weights`. 
 
        For improvement: 
        - Change the order of the weights (and steps in `pre_func_eval`) to 
          simplify `work_fc` concatenation and eliminate `fc` concatenation. 
        - It would be simple to do one-step Richardson extrapolation with `df` 
          and `df_last` to increase the order of the estimate and/or improve 
          the error estimate. 
        - Process the function evaluations in a more numerically favorable 
          way. For instance, combining the pairs of central difference evals 
          into a second-order approximation and using Richardson extrapolation 
          to produce a higher order approximation seemed to retain accuracy up 
          to very high order. 
        - Alternatively, we could use `polyfit` like Jacobi. An advantage of 
          fitting polynomial to more points than necessary is improved noise 
          tolerance. 
        &quot;&quot;&quot;</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">work</span><span class="s3">.</span><span class="s1">terms</span>
        <span class="s1">n_new </span><span class="s3">= </span><span class="s1">n </span><span class="s2">if </span><span class="s1">work</span><span class="s3">.</span><span class="s1">nit </span><span class="s3">== </span><span class="s4">0 </span><span class="s2">else </span><span class="s4">1</span>
        <span class="s1">il</span><span class="s3">, </span><span class="s1">ic</span><span class="s3">, </span><span class="s1">io </span><span class="s3">= </span><span class="s1">work</span><span class="s3">.</span><span class="s1">il</span><span class="s3">, </span><span class="s1">work</span><span class="s3">.</span><span class="s1">ic</span><span class="s3">, </span><span class="s1">work</span><span class="s3">.</span><span class="s1">io</span>

        <span class="s0"># Central difference</span>
        <span class="s0"># `work_fc` is *all* the points at which the function has been evaluated</span>
        <span class="s0"># `fc` is the points we're using *this iteration* to produce the estimate</span>
        <span class="s1">work_fc </span><span class="s3">= (</span><span class="s1">f</span><span class="s3">[</span><span class="s1">ic</span><span class="s3">, :</span><span class="s1">n_new</span><span class="s3">], </span><span class="s1">work</span><span class="s3">.</span><span class="s1">fs</span><span class="s3">[</span><span class="s1">ic</span><span class="s3">, :], </span><span class="s1">f</span><span class="s3">[</span><span class="s1">ic</span><span class="s3">, -</span><span class="s1">n_new</span><span class="s3">:])</span>
        <span class="s1">work_fc </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">(</span><span class="s1">work_fc</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">work</span><span class="s3">.</span><span class="s1">nit </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s1">fc </span><span class="s3">= </span><span class="s1">work_fc</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">fc </span><span class="s3">= (</span><span class="s1">work_fc</span><span class="s3">[:, :</span><span class="s1">n</span><span class="s3">], </span><span class="s1">work_fc</span><span class="s3">[:, </span><span class="s1">n</span><span class="s3">:</span><span class="s1">n</span><span class="s3">+</span><span class="s4">1</span><span class="s3">], </span><span class="s1">work_fc</span><span class="s3">[:, -</span><span class="s1">n</span><span class="s3">:])</span>
            <span class="s1">fc </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">(</span><span class="s1">fc</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s4">1</span><span class="s3">)</span>

        <span class="s0"># One-sided difference</span>
        <span class="s1">work_fo </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">work</span><span class="s3">.</span><span class="s1">fs</span><span class="s3">[</span><span class="s1">io</span><span class="s3">, :], </span><span class="s1">f</span><span class="s3">[</span><span class="s1">io</span><span class="s3">, :]), </span><span class="s1">axis</span><span class="s3">=-</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">work</span><span class="s3">.</span><span class="s1">nit </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s1">fo </span><span class="s3">= </span><span class="s1">work_fo</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">fo </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">work_fo</span><span class="s3">[:, </span><span class="s4">0</span><span class="s3">:</span><span class="s4">1</span><span class="s3">], </span><span class="s1">work_fo</span><span class="s3">[:, -</span><span class="s4">2</span><span class="s3">*</span><span class="s1">n</span><span class="s3">:]), </span><span class="s1">axis</span><span class="s3">=-</span><span class="s4">1</span><span class="s3">)</span>

        <span class="s1">work</span><span class="s3">.</span><span class="s1">fs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">len</span><span class="s3">(</span><span class="s1">ic</span><span class="s3">), </span><span class="s1">work</span><span class="s3">.</span><span class="s1">fs</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">] + </span><span class="s4">2</span><span class="s3">*</span><span class="s1">n_new</span><span class="s3">))</span>
        <span class="s1">work</span><span class="s3">.</span><span class="s1">fs</span><span class="s3">[</span><span class="s1">ic</span><span class="s3">] = </span><span class="s1">work_fc</span>
        <span class="s1">work</span><span class="s3">.</span><span class="s1">fs</span><span class="s3">[</span><span class="s1">io</span><span class="s3">] = </span><span class="s1">work_fo</span>

        <span class="s1">wc</span><span class="s3">, </span><span class="s1">wo </span><span class="s3">= </span><span class="s1">_differentiate_weights</span><span class="s3">(</span><span class="s1">work</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">work</span><span class="s3">.</span><span class="s1">df_last </span><span class="s3">= </span><span class="s1">work</span><span class="s3">.</span><span class="s1">df</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">work</span><span class="s3">.</span><span class="s1">df</span><span class="s3">[</span><span class="s1">ic</span><span class="s3">] = </span><span class="s1">fc </span><span class="s3">@ </span><span class="s1">wc </span><span class="s3">/ </span><span class="s1">work</span><span class="s3">.</span><span class="s1">h</span>
        <span class="s1">work</span><span class="s3">.</span><span class="s1">df</span><span class="s3">[</span><span class="s1">io</span><span class="s3">] = </span><span class="s1">fo </span><span class="s3">@ </span><span class="s1">wo </span><span class="s3">/ </span><span class="s1">work</span><span class="s3">.</span><span class="s1">h</span>
        <span class="s1">work</span><span class="s3">.</span><span class="s1">df</span><span class="s3">[</span><span class="s1">il</span><span class="s3">] *= -</span><span class="s4">1</span>

        <span class="s1">work</span><span class="s3">.</span><span class="s1">h </span><span class="s3">/= </span><span class="s1">work</span><span class="s3">.</span><span class="s1">fac</span>
        <span class="s1">work</span><span class="s3">.</span><span class="s1">error_last </span><span class="s3">= </span><span class="s1">work</span><span class="s3">.</span><span class="s1">error</span>
        <span class="s0"># Simple error estimate - the difference in derivative estimates between</span>
        <span class="s0"># this iteration and the last. This is typically conservative because if</span>
        <span class="s0"># convergence has begin, the true error is much closer to the difference</span>
        <span class="s0"># between the current estimate and the *next* error estimate. However,</span>
        <span class="s0"># we could use Richarson extrapolation to produce an error estimate that</span>
        <span class="s0"># is one order higher, and take the difference between that and</span>
        <span class="s0"># `work.df` (which would just be constant factor that depends on `fac`.)</span>
        <span class="s1">work</span><span class="s3">.</span><span class="s1">error </span><span class="s3">= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">work</span><span class="s3">.</span><span class="s1">df </span><span class="s3">- </span><span class="s1">work</span><span class="s3">.</span><span class="s1">df_last</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">check_termination</span><span class="s3">(</span><span class="s1">work</span><span class="s3">):</span>
        <span class="s6">&quot;&quot;&quot;Terminate due to convergence, non-finite values, or error increase&quot;&quot;&quot;</span>
        <span class="s1">stop </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">work</span><span class="s3">.</span><span class="s1">df</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">bool</span><span class="s3">)</span>

        <span class="s1">i </span><span class="s3">= </span><span class="s1">work</span><span class="s3">.</span><span class="s1">error </span><span class="s3">&lt; </span><span class="s1">work</span><span class="s3">.</span><span class="s1">atol </span><span class="s3">+ </span><span class="s1">work</span><span class="s3">.</span><span class="s1">rtol</span><span class="s3">*</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">work</span><span class="s3">.</span><span class="s1">df</span><span class="s3">)</span>
        <span class="s1">work</span><span class="s3">.</span><span class="s1">status</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">eim</span><span class="s3">.</span><span class="s1">_ECONVERGED</span>
        <span class="s1">stop</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s2">True</span>

        <span class="s2">if </span><span class="s1">work</span><span class="s3">.</span><span class="s1">nit </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s1">i </span><span class="s3">= ~((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">work</span><span class="s3">.</span><span class="s1">x</span><span class="s3">) &amp; </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">work</span><span class="s3">.</span><span class="s1">df</span><span class="s3">)) | </span><span class="s1">stop</span><span class="s3">)</span>
            <span class="s1">work</span><span class="s3">.</span><span class="s1">df</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">work</span><span class="s3">.</span><span class="s1">status</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">eim</span><span class="s3">.</span><span class="s1">_EVALUEERR</span>
            <span class="s1">stop</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s2">True</span>

        <span class="s0"># With infinite precision, there is a step size below which</span>
        <span class="s0"># all smaller step sizes will reduce the error. But in floating point</span>
        <span class="s0"># arithmetic, catastrophic cancellation will begin to cause the error</span>
        <span class="s0"># to increase again. This heuristic tries to avoid step sizes that are</span>
        <span class="s0"># too small. There may be more theoretically sound approaches for</span>
        <span class="s0"># detecting a step size that minimizes the total error, but this</span>
        <span class="s0"># heuristic seems simple and effective.</span>
        <span class="s1">i </span><span class="s3">= (</span><span class="s1">work</span><span class="s3">.</span><span class="s1">error </span><span class="s3">&gt; </span><span class="s1">work</span><span class="s3">.</span><span class="s1">error_last</span><span class="s3">*</span><span class="s4">10</span><span class="s3">) &amp; ~</span><span class="s1">stop</span>
        <span class="s1">work</span><span class="s3">.</span><span class="s1">status</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">_EERRORINCREASE</span>
        <span class="s1">stop</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s2">True</span>

        <span class="s2">return </span><span class="s1">stop</span>

    <span class="s2">def </span><span class="s1">post_termination_check</span><span class="s3">(</span><span class="s1">work</span><span class="s3">):</span>
        <span class="s2">return</span>

    <span class="s2">def </span><span class="s1">customize_result</span><span class="s3">(</span><span class="s1">res</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">shape</span>

    <span class="s2">return </span><span class="s1">eim</span><span class="s3">.</span><span class="s1">_loop</span><span class="s3">(</span><span class="s1">work</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">, </span><span class="s1">func</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">,</span>
                     <span class="s1">pre_func_eval</span><span class="s3">, </span><span class="s1">post_func_eval</span><span class="s3">, </span><span class="s1">check_termination</span><span class="s3">,</span>
                     <span class="s1">post_termination_check</span><span class="s3">, </span><span class="s1">customize_result</span><span class="s3">, </span><span class="s1">res_work_pairs</span><span class="s3">,</span>
                     <span class="s1">xp</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_differentiate_weights</span><span class="s3">(</span><span class="s1">work</span><span class="s3">, </span><span class="s1">n</span><span class="s3">):</span>
    <span class="s0"># This produces the weights of the finite difference formula for a given</span>
    <span class="s0"># stencil. In experiments, use of a second-order central difference formula</span>
    <span class="s0"># with Richardson extrapolation was more accurate numerically, but it was</span>
    <span class="s0"># more complicated, and it would have become even more complicated when</span>
    <span class="s0"># adding support for one-sided differences. However, now that all the</span>
    <span class="s0"># function evaluation values are stored, they can be processed in whatever</span>
    <span class="s0"># way is desired to produce the derivative estimate. We leave alternative</span>
    <span class="s0"># approaches to future work. To be more self-contained, here is the theory</span>
    <span class="s0"># for deriving the weights below.</span>
    <span class="s0">#</span>
    <span class="s0"># Recall that the Taylor expansion of a univariate, scalar-values function</span>
    <span class="s0"># about a point `x` may be expressed as:</span>
    <span class="s0">#      f(x + h)  =     f(x) + f'(x)*h + f''(x)/2!*h**2  + O(h**3)</span>
    <span class="s0"># Suppose we evaluate f(x), f(x+h), and f(x-h).  We have:</span>
    <span class="s0">#      f(x)      =     f(x)</span>
    <span class="s0">#      f(x + h)  =     f(x) + f'(x)*h + f''(x)/2!*h**2  + O(h**3)</span>
    <span class="s0">#      f(x - h)  =     f(x) - f'(x)*h + f''(x)/2!*h**2  + O(h**3)</span>
    <span class="s0"># We can solve for weights `wi` such that:</span>
    <span class="s0">#   w1*f(x)      = w1*(f(x))</span>
    <span class="s0"># + w2*f(x + h)  = w2*(f(x) + f'(x)*h + f''(x)/2!*h**2) + O(h**3)</span>
    <span class="s0"># + w3*f(x - h)  = w3*(f(x) - f'(x)*h + f''(x)/2!*h**2) + O(h**3)</span>
    <span class="s0">#                =     0    + f'(x)*h + 0               + O(h**3)</span>
    <span class="s0"># Then</span>
    <span class="s0">#     f'(x) ~ (w1*f(x) + w2*f(x+h) + w3*f(x-h))/h</span>
    <span class="s0"># is a finite difference derivative approximation with error O(h**2),</span>
    <span class="s0"># and so it is said to be a &quot;second-order&quot; approximation. Under certain</span>
    <span class="s0"># conditions (e.g. well-behaved function, `h` sufficiently small), the</span>
    <span class="s0"># error in the approximation will decrease with h**2; that is, if `h` is</span>
    <span class="s0"># reduced by a factor of 2, the error is reduced by a factor of 4.</span>
    <span class="s0">#</span>
    <span class="s0"># By default, we use eighth-order formulae. Our central-difference formula</span>
    <span class="s0"># uses abscissae:</span>
    <span class="s0">#   x-h/c**3, x-h/c**2, x-h/c, x-h, x, x+h, x+h/c, x+h/c**2, x+h/c**3</span>
    <span class="s0"># where `c` is the step factor. (Typically, the step factor is greater than</span>
    <span class="s0"># one, so the outermost points - as written above - are actually closest to</span>
    <span class="s0"># `x`.) This &quot;stencil&quot; is chosen so that each iteration, the step can be</span>
    <span class="s0"># reduced by the factor `c`, and most of the function evaluations can be</span>
    <span class="s0"># reused with the new step size. For example, in the next iteration, we</span>
    <span class="s0"># will have:</span>
    <span class="s0">#   x-h/c**4, x-h/c**3, x-h/c**2, x-h/c, x, x+h/c, x+h/c**2, x+h/c**3, x+h/c**4</span>
    <span class="s0"># We do not reuse `x-h` and `x+h` for the new derivative estimate.</span>
    <span class="s0"># While this would increase the order of the formula and thus the</span>
    <span class="s0"># theoretical convergence rate, it is also less stable numerically.</span>
    <span class="s0"># (As noted above, there are other ways of processing the values that are</span>
    <span class="s0"># more stable. Thus, even now we store `f(x-h)` and `f(x+h)` in `work.fs`</span>
    <span class="s0"># to simplify future development of this sort of improvement.)</span>
    <span class="s0">#</span>
    <span class="s0"># The (right) one-sided formula is produced similarly using abscissae</span>
    <span class="s0">#   x, x+h, x+h/d, x+h/d**2, ..., x+h/d**6, x+h/d**7, x+h/d**7</span>
    <span class="s0"># where `d` is the square root of `c`. (The left one-sided formula simply</span>
    <span class="s0"># uses -h.) When the step size is reduced by factor `c = d**2`, we have</span>
    <span class="s0"># abscissae:</span>
    <span class="s0">#   x, x+h/d**2, x+h/d**3..., x+h/d**8, x+h/d**9, x+h/d**9</span>
    <span class="s0"># `d` is chosen as the square root of `c` so that the rate of the step-size</span>
    <span class="s0"># reduction is the same per iteration as in the central difference case.</span>
    <span class="s0"># Note that because the central difference formulas are inherently of even</span>
    <span class="s0"># order, for simplicity, we use only even-order formulas for one-sided</span>
    <span class="s0"># differences, too.</span>

    <span class="s0"># It's possible for the user to specify `fac` in, say, double precision but</span>
    <span class="s0"># `x` and `args` in single precision. `fac` gets converted to single</span>
    <span class="s0"># precision, but we should always use double precision for the intermediate</span>
    <span class="s0"># calculations here to avoid additional error in the weights.</span>
    <span class="s1">fac </span><span class="s3">= </span><span class="s1">work</span><span class="s3">.</span><span class="s1">fac</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s0"># Note that if the user switches back to floating point precision with</span>
    <span class="s0"># `x` and `args`, then `fac` will not necessarily equal the (lower</span>
    <span class="s0"># precision) cached `_differentiate_weights.fac`, and the weights will</span>
    <span class="s0"># need to be recalculated. This could be fixed, but it's late, and of</span>
    <span class="s0"># low consequence.</span>
    <span class="s2">if </span><span class="s1">fac </span><span class="s3">!= </span><span class="s1">_differentiate_weights</span><span class="s3">.</span><span class="s1">fac</span><span class="s3">:</span>
        <span class="s1">_differentiate_weights</span><span class="s3">.</span><span class="s1">central </span><span class="s3">= []</span>
        <span class="s1">_differentiate_weights</span><span class="s3">.</span><span class="s1">right </span><span class="s3">= []</span>
        <span class="s1">_differentiate_weights</span><span class="s3">.</span><span class="s1">fac </span><span class="s3">= </span><span class="s1">fac</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">_differentiate_weights</span><span class="s3">.</span><span class="s1">central</span><span class="s3">) != </span><span class="s4">2</span><span class="s3">*</span><span class="s1">n </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s0"># Central difference weights. Consider refactoring this; it could</span>
        <span class="s0"># probably be more compact.</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(-</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">i</span><span class="s3">) - </span><span class="s4">1.  </span><span class="s0"># center point has power `p` -1, but sign `s` is 0</span>
        <span class="s1">s </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sign</span><span class="s3">(</span><span class="s1">i</span><span class="s3">)</span>

        <span class="s1">h </span><span class="s3">= </span><span class="s1">s </span><span class="s3">/ </span><span class="s1">fac </span><span class="s3">** </span><span class="s1">p</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">vander</span><span class="s3">(</span><span class="s1">h</span><span class="s3">, </span><span class="s1">increasing</span><span class="s3">=</span><span class="s2">True</span><span class="s3">).</span><span class="s1">T</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">2</span><span class="s3">*</span><span class="s1">n </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">b</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] = </span><span class="s4">1</span>
        <span class="s1">weights </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">solve</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

        <span class="s0"># Enforce identities to improve accuracy</span>
        <span class="s1">weights</span><span class="s3">[</span><span class="s1">n</span><span class="s3">] = </span><span class="s4">0</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
            <span class="s1">weights</span><span class="s3">[-</span><span class="s1">i</span><span class="s3">-</span><span class="s4">1</span><span class="s3">] = -</span><span class="s1">weights</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

        <span class="s0"># Cache the weights. We only need to calculate them once unless</span>
        <span class="s0"># the step factor changes.</span>
        <span class="s1">_differentiate_weights</span><span class="s3">.</span><span class="s1">central </span><span class="s3">= </span><span class="s1">weights</span>

        <span class="s0"># One-sided difference weights. The left one-sided weights (with</span>
        <span class="s0"># negative steps) are simply the negative of the right one-sided</span>
        <span class="s0"># weights, so no need to compute them separately.</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">2</span><span class="s3">*</span><span class="s1">n </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">i </span><span class="s3">- </span><span class="s4">1.</span>
        <span class="s1">s </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sign</span><span class="s3">(</span><span class="s1">i</span><span class="s3">)</span>

        <span class="s1">h </span><span class="s3">= </span><span class="s1">s </span><span class="s3">/ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">fac</span><span class="s3">) ** </span><span class="s1">p</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">vander</span><span class="s3">(</span><span class="s1">h</span><span class="s3">, </span><span class="s1">increasing</span><span class="s3">=</span><span class="s2">True</span><span class="s3">).</span><span class="s1">T</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">2 </span><span class="s3">* </span><span class="s1">n </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">b</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] = </span><span class="s4">1</span>
        <span class="s1">weights </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">solve</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

        <span class="s1">_differentiate_weights</span><span class="s3">.</span><span class="s1">right </span><span class="s3">= </span><span class="s1">weights</span>

    <span class="s2">return </span><span class="s3">(</span><span class="s1">_differentiate_weights</span><span class="s3">.</span><span class="s1">central</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">work</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">),</span>
            <span class="s1">_differentiate_weights</span><span class="s3">.</span><span class="s1">right</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">work</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">))</span>
<span class="s1">_differentiate_weights</span><span class="s3">.</span><span class="s1">central </span><span class="s3">= []</span>
<span class="s1">_differentiate_weights</span><span class="s3">.</span><span class="s1">right </span><span class="s3">= []</span>
<span class="s1">_differentiate_weights</span><span class="s3">.</span><span class="s1">fac </span><span class="s3">= </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">_jacobian</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, *, </span><span class="s1">atol</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">=</span><span class="s4">10</span><span class="s3">,</span>
              <span class="s1">order</span><span class="s3">=</span><span class="s4">8</span><span class="s3">, </span><span class="s1">initial_step</span><span class="s3">=</span><span class="s4">0.5</span><span class="s3">, </span><span class="s1">step_factor</span><span class="s3">=</span><span class="s4">2.0</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot;Evaluate the Jacobian of a function numerically. 
 
    Parameters 
    ---------- 
    func : callable 
        The function whose Jacobian is desired. The signature must be:: 
 
            func(x: ndarray) -&gt; ndarray 
 
         where each element of ``x`` is a finite real. If the function to be 
         differentiated accepts additional, arguments wrap it (e.g. using 
         `functools.partial` or ``lambda``) and pass the wrapped callable 
         into `_jacobian`. See Notes regarding vectorization and the dimensionality 
         of the input and output. 
    x : array_like 
        Points at which to evaluate the Jacobian. Must have at least one dimension. 
        See Notes regarding the dimensionality and vectorization. 
    atol, rtol : float, optional 
        Absolute and relative tolerances for the stopping condition: iteration 
        will stop for each element of the Jacobian when 
        ``res.error &lt; atol + rtol * abs(res.df)``. The default `atol` is the 
        smallest normal number of the appropriate dtype, and the default `rtol` 
        is the square root of the precision of the appropriate dtype. 
    order : int, default: 8 
        The (positive integer) order of the finite difference formula to be 
        used. Odd integers will be rounded up to the next even integer. 
    initial_step : float, default: 0.5 
        The (absolute) initial step size for the finite difference derivative 
        approximation. 
    step_factor : float, default: 2.0 
        The factor by which the step size is *reduced* in each iteration; i.e. 
        the step size in iteration 1 is ``initial_step/step_factor``. If 
        ``step_factor &lt; 1``, subsequent steps will be greater than the initial 
        step; this may be useful if steps smaller than some threshold are 
        undesirable (e.g. due to subtractive cancellation error). 
    maxiter : int, default: 10 
        The maximum number of iterations of the algorithm to perform. 
 
    Returns 
    ------- 
    res : _RichResult 
        An instance of `scipy._lib._util._RichResult` with the following 
        attributes. 
 
        success : bool array 
            ``True`` when the algorithm terminated successfully (status ``0``). 
        status : int array 
            An integer representing the exit status of the algorithm. 
            ``0`` : The algorithm converged to the specified tolerances. 
            ``-1`` : The error estimate increased, so iteration was terminated. 
            ``-2`` : The maximum number of iterations was reached. 
            ``-3`` : A non-finite value was encountered. 
            ``-4`` : Iteration was terminated by `callback`. 
            ``1`` : The algorithm is proceeding normally (in `callback` only). 
        df : float array 
            The Jacobian of `func` at `x`, if the algorithm terminated 
            successfully. 
        error : float array 
            An estimate of the error: the magnitude of the difference between 
            the current estimate of the derivative and the estimate in the 
            previous iteration. 
        nit : int array 
            The number of iterations performed. 
        nfev : int array 
            The number of points at which `func` was evaluated. 
        x : float array 
            The value at which the derivative of `func` was evaluated. 
 
    See Also 
    -------- 
    _differentiate 
 
    Notes 
    ----- 
    Suppose we wish to evaluate the Jacobian of a function 
    :math:`f: \mathbf{R^m} \rightarrow \mathbf{R^n}`, and assign to variables 
    ``m`` and ``n`` the positive integer values of :math:`m` and :math:`n`, 
    respectively. If we wish to evaluate the Jacobian at a single point, 
    then: 
 
    - argument `x` must be an array of shape ``(m,)`` 
    - argument `func` must be vectorized to accept an array of shape ``(m, p)``. 
      The first axis represents the :math:`m` inputs of :math:`f`; the second 
      is for evaluating the function at multiple points in a single call. 
    - argument `func` must return an array of shape ``(n, p)``. The first 
      axis represents the :math:`n` outputs of :math:`f`; the second 
      is for the result of evaluating the function at multiple points. 
    - attribute ``df`` of the result object will be an array of shape ``(n, m)``, 
      the Jacobian. 
 
    This function is also vectorized in the sense that the Jacobian can be 
    evaluated at ``k`` points in a single call. In this case, `x` would be an 
    array of shape ``(m, k)``, `func` would accept an array of shape 
    ``(m, k, p)`` and return an array of shape ``(n, k, p)``, and the ``df`` 
    attribute of the result would have shape ``(n, m, k)``. 
 
    References 
    ---------- 
    .. [1] Jacobian matrix and determinant, *Wikipedia*, 
           https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant 
 
    Examples 
    -------- 
    The Rosenbrock function maps from :math:`\mathbf{R}^m \righarrow \mathbf{R}`; 
    the SciPy implementation `scipy.optimize.rosen` is vectorized to accept an 
    array of shape ``(m, p)`` and return an array of shape ``m``. Suppose we wish 
    to evaluate the Jacobian (AKA the gradient because the function returns a scalar) 
    at ``[0.5, 0.5, 0.5]``. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.optimize._differentiate import _jacobian as jacobian 
    &gt;&gt;&gt; from scipy.optimize import rosen, rosen_der 
    &gt;&gt;&gt; m = 3 
    &gt;&gt;&gt; x = np.full(m, 0.5) 
    &gt;&gt;&gt; res = jacobian(rosen, x) 
    &gt;&gt;&gt; ref = rosen_der(x)  # reference value of the gradient 
    &gt;&gt;&gt; res.df, ref 
    (array([-51.,  -1.,  50.]), array([-51.,  -1.,  50.])) 
 
    As an example of a function with multiple outputs, consider Example 4 
    from [1]_. 
 
    &gt;&gt;&gt; def f(x): 
    ...     x1, x2, x3 = x    ... 
    ...     return [x1, 5*x3, 4*x2**2 - 2*x3, x3*np.sin(x1)] 
 
    The true Jacobian is given by: 
 
    &gt;&gt;&gt; def df(x): 
    ...         x1, x2, x3 = x 
    ...         one = np.ones_like(x1) 
    ...         return [[one, 0*one, 0*one], 
    ...                 [0*one, 0*one, 5*one], 
    ...                 [0*one, 8*x2, -2*one], 
    ...                 [x3*np.cos(x1), 0*one, np.sin(x1)]] 
 
    Evaluate the Jacobian at an arbitrary point. 
 
    &gt;&gt;&gt; rng = np.random.default_rng(389252938452) 
    &gt;&gt;&gt; x = rng.random(size=3) 
    &gt;&gt;&gt; res = jacobian(f, x) 
    &gt;&gt;&gt; ref = df(x) 
    &gt;&gt;&gt; res.df.shape == (4, 3) 
    True 
    &gt;&gt;&gt; np.allclose(res.df, ref) 
    True 
 
    Evaluate the Jacobian at 10 arbitrary points in a single call. 
 
    &gt;&gt;&gt; x = rng.random(size=(3, 10)) 
    &gt;&gt;&gt; res = jacobian(f, x) 
    &gt;&gt;&gt; ref = df(x) 
    &gt;&gt;&gt; res.df.shape == (4, 3, 10) 
    True 
    &gt;&gt;&gt; np.allclose(res.df, ref) 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">int_dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">)</span>
    <span class="s1">x0 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">) </span><span class="s2">if </span><span class="s1">int_dtype </span><span class="s2">else </span><span class="s1">x</span>

    <span class="s2">if </span><span class="s1">x0</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&lt; </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">message </span><span class="s3">= </span><span class="s5">&quot;Argument `x` must be at least 1-D.&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">message</span><span class="s3">)</span>

    <span class="s1">m </span><span class="s3">= </span><span class="s1">x0</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
    <span class="s1">i </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">wrapped</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s1">p </span><span class="s3">= () </span><span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s1">x0</span><span class="s3">.</span><span class="s1">ndim </span><span class="s2">else </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">],)  </span><span class="s0"># number of abscissae</span>
        <span class="s1">new_dims </span><span class="s3">= (</span><span class="s4">1</span><span class="s3">,) </span><span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s1">x0</span><span class="s3">.</span><span class="s1">ndim </span><span class="s2">else </span><span class="s3">(</span><span class="s4">1</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">)</span>
        <span class="s1">new_shape </span><span class="s3">= (</span><span class="s1">m</span><span class="s3">, </span><span class="s1">m</span><span class="s3">) + </span><span class="s1">x0</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">:] + </span><span class="s1">p</span>
        <span class="s1">xph </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">expand_dims</span><span class="s3">(</span><span class="s1">x0</span><span class="s3">, </span><span class="s1">new_dims</span><span class="s3">)</span>
        <span class="s1">xph </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">xph</span><span class="s3">, </span><span class="s1">new_shape</span><span class="s3">).</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">xph</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">i</span><span class="s3">] = </span><span class="s1">x</span>
        <span class="s2">return </span><span class="s1">func</span><span class="s3">(</span><span class="s1">xph</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">_differentiate</span><span class="s3">(</span><span class="s1">wrapped</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s1">atol</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s1">rtol</span><span class="s3">,</span>
                         <span class="s1">maxiter</span><span class="s3">=</span><span class="s1">maxiter</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">, </span><span class="s1">initial_step</span><span class="s3">=</span><span class="s1">initial_step</span><span class="s3">,</span>
                         <span class="s1">step_factor</span><span class="s3">=</span><span class="s1">step_factor</span><span class="s3">, </span><span class="s1">preserve_shape</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">del </span><span class="s1">res</span><span class="s3">.</span><span class="s1">x  </span><span class="s0"># the user knows `x`, and the way it gets broadcasted is meaningless here</span>
    <span class="s2">return </span><span class="s1">res</span>
</pre>
</body>
</html>