<html>
<head>
<title>_filters.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_filters.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (C) 2003-2005 Peter J. Verveer</span>
<span class="s0">#</span>
<span class="s0"># Redistribution and use in source and binary forms, with or without</span>
<span class="s0"># modification, are permitted provided that the following conditions</span>
<span class="s0"># are met:</span>
<span class="s0">#</span>
<span class="s0"># 1. Redistributions of source code must retain the above copyright</span>
<span class="s0">#    notice, this list of conditions and the following disclaimer.</span>
<span class="s0">#</span>
<span class="s0"># 2. Redistributions in binary form must reproduce the above</span>
<span class="s0">#    copyright notice, this list of conditions and the following</span>
<span class="s0">#    disclaimer in the documentation and/or other materials provided</span>
<span class="s0">#    with the distribution.</span>
<span class="s0">#</span>
<span class="s0"># 3. The name of the author may not be used to endorse or promote</span>
<span class="s0">#    products derived from this software without specific prior</span>
<span class="s0">#    written permission.</span>
<span class="s0">#</span>
<span class="s0"># THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS</span>
<span class="s0"># OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<span class="s0"># WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="s0"># ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY</span>
<span class="s0"># DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="s0"># DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE</span>
<span class="s0"># GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="s0"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,</span>
<span class="s0"># WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="s0"># NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="s0"># SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="s2">from </span><span class="s1">collections</span><span class="s3">.</span><span class="s1">abc </span><span class="s2">import </span><span class="s1">Iterable</span>
<span class="s2">import </span><span class="s1">numbers</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">operator</span>

<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">_lib</span><span class="s3">.</span><span class="s1">_util </span><span class="s2">import </span><span class="s1">normalize_axis_index</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_ni_support</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_nd_image</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_ni_docstrings</span>

<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">'correlate1d'</span><span class="s3">, </span><span class="s4">'convolve1d'</span><span class="s3">, </span><span class="s4">'gaussian_filter1d'</span><span class="s3">, </span><span class="s4">'gaussian_filter'</span><span class="s3">,</span>
           <span class="s4">'prewitt'</span><span class="s3">, </span><span class="s4">'sobel'</span><span class="s3">, </span><span class="s4">'generic_laplace'</span><span class="s3">, </span><span class="s4">'laplace'</span><span class="s3">,</span>
           <span class="s4">'gaussian_laplace'</span><span class="s3">, </span><span class="s4">'generic_gradient_magnitude'</span><span class="s3">,</span>
           <span class="s4">'gaussian_gradient_magnitude'</span><span class="s3">, </span><span class="s4">'correlate'</span><span class="s3">, </span><span class="s4">'convolve'</span><span class="s3">,</span>
           <span class="s4">'uniform_filter1d'</span><span class="s3">, </span><span class="s4">'uniform_filter'</span><span class="s3">, </span><span class="s4">'minimum_filter1d'</span><span class="s3">,</span>
           <span class="s4">'maximum_filter1d'</span><span class="s3">, </span><span class="s4">'minimum_filter'</span><span class="s3">, </span><span class="s4">'maximum_filter'</span><span class="s3">,</span>
           <span class="s4">'rank_filter'</span><span class="s3">, </span><span class="s4">'median_filter'</span><span class="s3">, </span><span class="s4">'percentile_filter'</span><span class="s3">,</span>
           <span class="s4">'generic_filter1d'</span><span class="s3">, </span><span class="s4">'generic_filter'</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">_invalid_origin</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">, </span><span class="s1">lenw</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s3">(</span><span class="s1">origin </span><span class="s3">&lt; -(</span><span class="s1">lenw </span><span class="s3">// </span><span class="s5">2</span><span class="s3">)) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">origin </span><span class="s3">&gt; (</span><span class="s1">lenw </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) // </span><span class="s5">2</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_complex_via_real_components</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">input</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Complex convolution via a linear combination of real convolutions.&quot;&quot;&quot;</span>
    <span class="s1">complex_input </span><span class="s3">= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'c'</span>
    <span class="s1">complex_weights </span><span class="s3">= </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'c'</span>
    <span class="s2">if </span><span class="s1">complex_input </span><span class="s2">and </span><span class="s1">complex_weights</span><span class="s3">:</span>
        <span class="s0"># real component of the output</span>
        <span class="s1">func</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">real</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">real</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s1">output</span><span class="s3">.</span><span class="s1">real</span><span class="s3">,</span>
             <span class="s1">cval</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">real</span><span class="s3">(</span><span class="s1">cval</span><span class="s3">), **</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s1">output</span><span class="s3">.</span><span class="s1">real </span><span class="s3">-= </span><span class="s1">func</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                            <span class="s1">cval</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">(</span><span class="s1">cval</span><span class="s3">), **</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s0"># imaginary component of the output</span>
        <span class="s1">func</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">real</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s1">output</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">,</span>
             <span class="s1">cval</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">real</span><span class="s3">(</span><span class="s1">cval</span><span class="s3">), **</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s1">output</span><span class="s3">.</span><span class="s1">imag </span><span class="s3">+= </span><span class="s1">func</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">real</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                            <span class="s1">cval</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">(</span><span class="s1">cval</span><span class="s3">), **</span><span class="s1">kwargs</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">complex_input</span><span class="s3">:</span>
        <span class="s1">func</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">real</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s1">output</span><span class="s3">.</span><span class="s1">real</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">real</span><span class="s3">(</span><span class="s1">cval</span><span class="s3">),</span>
             <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s1">func</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s1">output</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">(</span><span class="s1">cval</span><span class="s3">),</span>
             <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">cval</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Cannot provide a complex-valued cval when the &quot;</span>
                             <span class="s4">&quot;input is real.&quot;</span><span class="s3">)</span>
        <span class="s1">func</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">real</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s1">output</span><span class="s3">.</span><span class="s1">real</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s1">cval</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s1">func</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s1">output</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s1">cval</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">correlate1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">,</span>
                <span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Calculate a 1-D correlation along the given axis. 
 
    The lines of the array along the given axis are correlated with the 
    given weights. 
 
    Parameters 
    ---------- 
    %(input)s 
    weights : array 
        1-D sequence of numbers. 
    %(axis)s 
    %(output)s 
    %(mode_reflect)s 
    %(cval)s 
    %(origin)s 
 
    Returns 
    ------- 
    result : ndarray 
        Correlation result. Has the same shape as `input`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.ndimage import correlate1d 
    &gt;&gt;&gt; correlate1d([2, 8, 0, 4, 1, 9, 9, 0], weights=[1, 3]) 
    array([ 8, 26,  8, 12,  7, 28, 36,  9]) 
    &quot;&quot;&quot;</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">weights </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">)</span>
    <span class="s1">complex_input </span><span class="s3">= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'c'</span>
    <span class="s1">complex_weights </span><span class="s3">= </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'c'</span>
    <span class="s2">if </span><span class="s1">complex_input </span><span class="s2">or </span><span class="s1">complex_weights</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">complex_weights</span><span class="s3">:</span>
            <span class="s1">weights </span><span class="s3">= </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">()</span>
            <span class="s1">weights </span><span class="s3">= </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">complex128</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">kwargs </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s1">origin</span><span class="s3">)</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">, </span><span class="s1">complex_output</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_complex_via_real_components</span><span class="s3">(</span><span class="s1">correlate1d</span><span class="s3">, </span><span class="s1">input</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">,</span>
                                            <span class="s1">output</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">weights </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">1 </span><span class="s2">or </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] &lt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'no filter weights given'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">contiguous</span><span class="s3">:</span>
        <span class="s1">weights </span><span class="s3">= </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">axis </span><span class="s3">= </span><span class="s1">normalize_axis_index</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">_invalid_origin</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Invalid origin; origin must satisfy '</span>
                         <span class="s4">'-(len(weights) // 2) &lt;= origin &lt;= '</span>
                         <span class="s4">'(len(weights)-1) // 2'</span><span class="s3">)</span>
    <span class="s1">mode </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_extend_mode_to_code</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">)</span>
    <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">correlate1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">,</span>
                          <span class="s1">origin</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">convolve1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">,</span>
               <span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Calculate a 1-D convolution along the given axis. 
 
    The lines of the array along the given axis are convolved with the 
    given weights. 
 
    Parameters 
    ---------- 
    %(input)s 
    weights : ndarray 
        1-D sequence of numbers. 
    %(axis)s 
    %(output)s 
    %(mode_reflect)s 
    %(cval)s 
    %(origin)s 
 
    Returns 
    ------- 
    convolve1d : ndarray 
        Convolved array with same shape as input 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.ndimage import convolve1d 
    &gt;&gt;&gt; convolve1d([2, 8, 0, 4, 1, 9, 9, 0], weights=[1, 3]) 
    array([14, 24,  4, 13, 12, 36, 27,  0]) 
    &quot;&quot;&quot;</span>
    <span class="s1">weights </span><span class="s3">= </span><span class="s1">weights</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s1">origin </span><span class="s3">= -</span><span class="s1">origin</span>
    <span class="s2">if not </span><span class="s1">len</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">) &amp; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">origin </span><span class="s3">-= </span><span class="s5">1</span>
    <span class="s1">weights </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'c'</span><span class="s3">:</span>
        <span class="s0"># pre-conjugate here to counteract the conjugation in correlate1d</span>
        <span class="s1">weights </span><span class="s3">= </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">correlate1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_gaussian_kernel1d</span><span class="s3">(</span><span class="s1">sigma</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s1">radius</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Computes a 1-D Gaussian convolution kernel. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">order </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'order must be non-negative'</span><span class="s3">)</span>
    <span class="s1">exponent_range </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">order </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">sigma2 </span><span class="s3">= </span><span class="s1">sigma </span><span class="s3">* </span><span class="s1">sigma</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(-</span><span class="s1">radius</span><span class="s3">, </span><span class="s1">radius</span><span class="s3">+</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">phi_x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(-</span><span class="s5">0.5 </span><span class="s3">/ </span><span class="s1">sigma2 </span><span class="s3">* </span><span class="s1">x </span><span class="s3">** </span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">phi_x </span><span class="s3">= </span><span class="s1">phi_x </span><span class="s3">/ </span><span class="s1">phi_x</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">()</span>

    <span class="s2">if </span><span class="s1">order </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">phi_x</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s0"># f(x) = q(x) * phi(x) = q(x) * exp(p(x))</span>
        <span class="s0"># f'(x) = (q'(x) + q(x) * p'(x)) * phi(x)</span>
        <span class="s0"># p'(x) = -1 / sigma ** 2</span>
        <span class="s0"># Implement q'(x) + q(x) * p'(x) as a matrix operator and apply to the</span>
        <span class="s0"># coefficients of q(x)</span>
        <span class="s1">q </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">order </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">q</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s5">1</span>
        <span class="s1">D </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">diag</span><span class="s3">(</span><span class="s1">exponent_range</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:], </span><span class="s5">1</span><span class="s3">)  </span><span class="s0"># D @ q(x) = q'(x)</span>
        <span class="s1">P </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">diag</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">order</span><span class="s3">)/-</span><span class="s1">sigma2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)  </span><span class="s0"># P @ q(x) = q(x) * p'(x)</span>
        <span class="s1">Q_deriv </span><span class="s3">= </span><span class="s1">D </span><span class="s3">+ </span><span class="s1">P</span>
        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">order</span><span class="s3">):</span>
            <span class="s1">q </span><span class="s3">= </span><span class="s1">Q_deriv</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">q</span><span class="s3">)</span>
        <span class="s1">q </span><span class="s3">= (</span><span class="s1">x</span><span class="s3">[:, </span><span class="s2">None</span><span class="s3">] ** </span><span class="s1">exponent_range</span><span class="s3">).</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">q</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">q </span><span class="s3">* </span><span class="s1">phi_x</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">gaussian_filter1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                      <span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">truncate</span><span class="s3">=</span><span class="s5">4.0</span><span class="s3">, *, </span><span class="s1">radius</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;1-D Gaussian filter. 
 
    Parameters 
    ---------- 
    %(input)s 
    sigma : scalar 
        standard deviation for Gaussian kernel 
    %(axis)s 
    order : int, optional 
        An order of 0 corresponds to convolution with a Gaussian 
        kernel. A positive order corresponds to convolution with 
        that derivative of a Gaussian. 
    %(output)s 
    %(mode_reflect)s 
    %(cval)s 
    truncate : float, optional 
        Truncate the filter at this many standard deviations. 
        Default is 4.0. 
    radius : None or int, optional 
        Radius of the Gaussian kernel. If specified, the size of 
        the kernel will be ``2*radius + 1``, and `truncate` is ignored. 
        Default is None. 
 
    Returns 
    ------- 
    gaussian_filter1d : ndarray 
 
    Notes 
    ----- 
    The Gaussian kernel will have size ``2*radius + 1`` along each axis. If 
    `radius` is None, a default ``radius = round(truncate * sigma)`` will be 
    used. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.ndimage import gaussian_filter1d 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; gaussian_filter1d([1.0, 2.0, 3.0, 4.0, 5.0], 1) 
    array([ 1.42704095,  2.06782203,  3.        ,  3.93217797,  4.57295905]) 
    &gt;&gt;&gt; gaussian_filter1d([1.0, 2.0, 3.0, 4.0, 5.0], 4) 
    array([ 2.91948343,  2.95023502,  3.        ,  3.04976498,  3.08051657]) 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; x = rng.standard_normal(101).cumsum() 
    &gt;&gt;&gt; y3 = gaussian_filter1d(x, 3) 
    &gt;&gt;&gt; y6 = gaussian_filter1d(x, 6) 
    &gt;&gt;&gt; plt.plot(x, 'k', label='original data') 
    &gt;&gt;&gt; plt.plot(y3, '--', label='filtered, sigma=3') 
    &gt;&gt;&gt; plt.plot(y6, ':', label='filtered, sigma=6') 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.grid() 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">sd </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">sigma</span><span class="s3">)</span>
    <span class="s0"># make the radius of the filter equal to truncate standard deviations</span>
    <span class="s1">lw </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">truncate </span><span class="s3">* </span><span class="s1">sd </span><span class="s3">+ </span><span class="s5">0.5</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">radius </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">lw </span><span class="s3">= </span><span class="s1">radius</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">lw</span><span class="s3">, </span><span class="s1">numbers</span><span class="s3">.</span><span class="s1">Integral</span><span class="s3">) </span><span class="s2">or </span><span class="s1">lw </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Radius must be a nonnegative integer.'</span><span class="s3">)</span>
    <span class="s0"># Since we are calling correlate, not convolve, revert the kernel</span>
    <span class="s1">weights </span><span class="s3">= </span><span class="s1">_gaussian_kernel1d</span><span class="s3">(</span><span class="s1">sigma</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s1">lw</span><span class="s3">)[::-</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">correlate1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">gaussian_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                    <span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">truncate</span><span class="s3">=</span><span class="s5">4.0</span><span class="s3">, *, </span><span class="s1">radius</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                    <span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Multidimensional Gaussian filter. 
 
    Parameters 
    ---------- 
    %(input)s 
    sigma : scalar or sequence of scalars 
        Standard deviation for Gaussian kernel. The standard 
        deviations of the Gaussian filter are given for each axis as a 
        sequence, or as a single number, in which case it is equal for 
        all axes. 
    order : int or sequence of ints, optional 
        The order of the filter along each axis is given as a sequence 
        of integers, or as a single number. An order of 0 corresponds 
        to convolution with a Gaussian kernel. A positive order 
        corresponds to convolution with that derivative of a Gaussian. 
    %(output)s 
    %(mode_multiple)s 
    %(cval)s 
    truncate : float, optional 
        Truncate the filter at this many standard deviations. 
        Default is 4.0. 
    radius : None or int or sequence of ints, optional 
        Radius of the Gaussian kernel. The radius are given for each axis 
        as a sequence, or as a single number, in which case it is equal 
        for all axes. If specified, the size of the kernel along each axis 
        will be ``2*radius + 1``, and `truncate` is ignored. 
        Default is None. 
    axes : tuple of int or None, optional 
        If None, `input` is filtered along all axes. Otherwise, 
        `input` is filtered along the specified axes. When `axes` is 
        specified, any tuples used for `sigma`, `order`, `mode` and/or `radius` 
        must match the length of `axes`. The ith entry in any of these tuples 
        corresponds to the ith entry in `axes`. 
 
    Returns 
    ------- 
    gaussian_filter : ndarray 
        Returned array of same shape as `input`. 
 
    Notes 
    ----- 
    The multidimensional filter is implemented as a sequence of 
    1-D convolution filters. The intermediate arrays are 
    stored in the same data type as the output. Therefore, for output 
    types with a limited precision, the results may be imprecise 
    because intermediate results may be stored with insufficient 
    precision. 
 
    The Gaussian kernel will have size ``2*radius + 1`` along each axis. If 
    `radius` is None, the default ``radius = round(truncate * sigma)`` will be 
    used. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.ndimage import gaussian_filter 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.arange(50, step=2).reshape((5,5)) 
    &gt;&gt;&gt; a 
    array([[ 0,  2,  4,  6,  8], 
           [10, 12, 14, 16, 18], 
           [20, 22, 24, 26, 28], 
           [30, 32, 34, 36, 38], 
           [40, 42, 44, 46, 48]]) 
    &gt;&gt;&gt; gaussian_filter(a, sigma=1) 
    array([[ 4,  6,  8,  9, 11], 
           [10, 12, 14, 15, 17], 
           [20, 22, 24, 25, 27], 
           [29, 31, 33, 34, 36], 
           [35, 37, 39, 40, 42]]) 
 
    &gt;&gt;&gt; from scipy import datasets 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; plt.gray()  # show the filtered result in grayscale 
    &gt;&gt;&gt; ax1 = fig.add_subplot(121)  # left side 
    &gt;&gt;&gt; ax2 = fig.add_subplot(122)  # right side 
    &gt;&gt;&gt; ascent = datasets.ascent() 
    &gt;&gt;&gt; result = gaussian_filter(ascent, sigma=5) 
    &gt;&gt;&gt; ax1.imshow(ascent) 
    &gt;&gt;&gt; ax2.imshow(result) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>

    <span class="s1">axes </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_check_axes</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">num_axes </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">)</span>
    <span class="s1">orders </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">order</span><span class="s3">, </span><span class="s1">num_axes</span><span class="s3">)</span>
    <span class="s1">sigmas </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">sigma</span><span class="s3">, </span><span class="s1">num_axes</span><span class="s3">)</span>
    <span class="s1">modes </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">num_axes</span><span class="s3">)</span>
    <span class="s1">radiuses </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">radius</span><span class="s3">, </span><span class="s1">num_axes</span><span class="s3">)</span>
    <span class="s1">axes </span><span class="s3">= [(</span><span class="s1">axes</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s1">sigmas</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s1">orders</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s1">modes</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s1">radiuses</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">])</span>
            <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">num_axes</span><span class="s3">) </span><span class="s2">if </span><span class="s1">sigmas</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">] &gt; </span><span class="s5">1e-15</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">radius </span><span class="s2">in </span><span class="s1">axes</span><span class="s3">:</span>
            <span class="s1">gaussian_filter1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s1">output</span><span class="s3">,</span>
                              <span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">, </span><span class="s1">truncate</span><span class="s3">, </span><span class="s1">radius</span><span class="s3">=</span><span class="s1">radius</span><span class="s3">)</span>
            <span class="s1">input </span><span class="s3">= </span><span class="s1">output</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">output</span><span class="s3">[...] = </span><span class="s1">input</span><span class="s3">[...]</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">prewitt</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Calculate a Prewitt filter. 
 
    Parameters 
    ---------- 
    %(input)s 
    %(axis)s 
    %(output)s 
    %(mode_multiple)s 
    %(cval)s 
 
    Returns 
    ------- 
    prewitt : ndarray 
        Filtered array. Has the same shape as `input`. 
 
    See Also 
    -------- 
    sobel: Sobel filter 
 
    Notes 
    ----- 
    This function computes the one-dimensional Prewitt filter. 
    Horizontal edges are emphasised with the horizontal transform (axis=0), 
    vertical edges with the vertical transform (axis=1), and so on for higher 
    dimensions. These can be combined to give the magnitude. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage, datasets 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; ascent = datasets.ascent() 
    &gt;&gt;&gt; prewitt_h = ndimage.prewitt(ascent, axis=0) 
    &gt;&gt;&gt; prewitt_v = ndimage.prewitt(ascent, axis=1) 
    &gt;&gt;&gt; magnitude = np.sqrt(prewitt_h ** 2 + prewitt_v ** 2) 
    &gt;&gt;&gt; magnitude *= 255 / np.max(magnitude) # Normalization 
    &gt;&gt;&gt; fig, axes = plt.subplots(2, 2, figsize = (8, 8)) 
    &gt;&gt;&gt; plt.gray() 
    &gt;&gt;&gt; axes[0, 0].imshow(ascent) 
    &gt;&gt;&gt; axes[0, 1].imshow(prewitt_h) 
    &gt;&gt;&gt; axes[1, 0].imshow(prewitt_v) 
    &gt;&gt;&gt; axes[1, 1].imshow(magnitude) 
    &gt;&gt;&gt; titles = [&quot;original&quot;, &quot;horizontal&quot;, &quot;vertical&quot;, &quot;magnitude&quot;] 
    &gt;&gt;&gt; for i, ax in enumerate(axes.ravel()): 
    ...     ax.set_title(titles[i]) 
    ...     ax.axis(&quot;off&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">axis </span><span class="s3">= </span><span class="s1">normalize_axis_index</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">modes </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">correlate1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, [-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">], </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">modes</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">], </span><span class="s1">cval</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">axes </span><span class="s3">= [</span><span class="s1">ii </span><span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">) </span><span class="s2">if </span><span class="s1">ii </span><span class="s3">!= </span><span class="s1">axis</span><span class="s3">]</span>
    <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">axes</span><span class="s3">:</span>
        <span class="s1">correlate1d</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">], </span><span class="s1">ii</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">modes</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s1">cval</span><span class="s3">, </span><span class="s5">0</span><span class="s3">,)</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">sobel</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Calculate a Sobel filter. 
 
    Parameters 
    ---------- 
    %(input)s 
    %(axis)s 
    %(output)s 
    %(mode_multiple)s 
    %(cval)s 
 
    Returns 
    ------- 
    sobel : ndarray 
        Filtered array. Has the same shape as `input`. 
 
    Notes 
    ----- 
    This function computes the axis-specific Sobel gradient. 
    The horizontal edges can be emphasised with the horizontal transform (axis=0), 
    the vertical edges with the vertical transform (axis=1) and so on for higher 
    dimensions. These can be combined to give the magnitude. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage, datasets 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; ascent = datasets.ascent().astype('int32') 
    &gt;&gt;&gt; sobel_h = ndimage.sobel(ascent, 0)  # horizontal gradient 
    &gt;&gt;&gt; sobel_v = ndimage.sobel(ascent, 1)  # vertical gradient 
    &gt;&gt;&gt; magnitude = np.sqrt(sobel_h**2 + sobel_v**2) 
    &gt;&gt;&gt; magnitude *= 255.0 / np.max(magnitude)  # normalization 
    &gt;&gt;&gt; fig, axs = plt.subplots(2, 2, figsize=(8, 8)) 
    &gt;&gt;&gt; plt.gray()  # show the filtered result in grayscale 
    &gt;&gt;&gt; axs[0, 0].imshow(ascent) 
    &gt;&gt;&gt; axs[0, 1].imshow(sobel_h) 
    &gt;&gt;&gt; axs[1, 0].imshow(sobel_v) 
    &gt;&gt;&gt; axs[1, 1].imshow(magnitude) 
    &gt;&gt;&gt; titles = [&quot;original&quot;, &quot;horizontal&quot;, &quot;vertical&quot;, &quot;magnitude&quot;] 
    &gt;&gt;&gt; for i, ax in enumerate(axs.ravel()): 
    ...     ax.set_title(titles[i]) 
    ...     ax.axis(&quot;off&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">axis </span><span class="s3">= </span><span class="s1">normalize_axis_index</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">modes </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">correlate1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, [-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">], </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">modes</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">], </span><span class="s1">cval</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">axes </span><span class="s3">= [</span><span class="s1">ii </span><span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">) </span><span class="s2">if </span><span class="s1">ii </span><span class="s3">!= </span><span class="s1">axis</span><span class="s3">]</span>
    <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">axes</span><span class="s3">:</span>
        <span class="s1">correlate1d</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">], </span><span class="s1">ii</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">modes</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s1">cval</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">generic_laplace</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">derivative2</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">,</span>
                    <span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">,</span>
                    <span class="s1">extra_arguments</span><span class="s3">=(),</span>
                    <span class="s1">extra_keywords</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    N-D Laplace filter using a provided second derivative function. 
 
    Parameters 
    ---------- 
    %(input)s 
    derivative2 : callable 
        Callable with the following signature:: 
 
            derivative2(input, axis, output, mode, cval, 
                        *extra_arguments, **extra_keywords) 
 
        See `extra_arguments`, `extra_keywords` below. 
    %(output)s 
    %(mode_multiple)s 
    %(cval)s 
    %(extra_keywords)s 
    %(extra_arguments)s 
 
    Returns 
    ------- 
    generic_laplace : ndarray 
        Filtered array. Has the same shape as `input`. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">extra_keywords </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">extra_keywords </span><span class="s3">= {}</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">axes </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">modes </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">))</span>
        <span class="s1">derivative2</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">output</span><span class="s3">, </span><span class="s1">modes</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">cval</span><span class="s3">,</span>
                    <span class="s3">*</span><span class="s1">extra_arguments</span><span class="s3">, **</span><span class="s1">extra_keywords</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">)):</span>
            <span class="s1">tmp </span><span class="s3">= </span><span class="s1">derivative2</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s1">output</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">modes</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s1">cval</span><span class="s3">,</span>
                              <span class="s3">*</span><span class="s1">extra_arguments</span><span class="s3">, **</span><span class="s1">extra_keywords</span><span class="s3">)</span>
            <span class="s1">output </span><span class="s3">+= </span><span class="s1">tmp</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">output</span><span class="s3">[...] = </span><span class="s1">input</span><span class="s3">[...]</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">laplace</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;N-D Laplace filter based on approximate second derivatives. 
 
    Parameters 
    ---------- 
    %(input)s 
    %(output)s 
    %(mode_multiple)s 
    %(cval)s 
 
    Returns 
    ------- 
    laplace : ndarray 
        Filtered array. Has the same shape as `input`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage, datasets 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; plt.gray()  # show the filtered result in grayscale 
    &gt;&gt;&gt; ax1 = fig.add_subplot(121)  # left side 
    &gt;&gt;&gt; ax2 = fig.add_subplot(122)  # right side 
    &gt;&gt;&gt; ascent = datasets.ascent() 
    &gt;&gt;&gt; result = ndimage.laplace(ascent) 
    &gt;&gt;&gt; ax1.imshow(ascent) 
    &gt;&gt;&gt; ax2.imshow(result) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">derivative2</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">correlate1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, [</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">], </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">generic_laplace</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">derivative2</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">gaussian_laplace</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">,</span>
                     <span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Multidimensional Laplace filter using Gaussian second derivatives. 
 
    Parameters 
    ---------- 
    %(input)s 
    sigma : scalar or sequence of scalars 
        The standard deviations of the Gaussian filter are given for 
        each axis as a sequence, or as a single number, in which case 
        it is equal for all axes. 
    %(output)s 
    %(mode_multiple)s 
    %(cval)s 
    Extra keyword arguments will be passed to gaussian_filter(). 
 
    Returns 
    ------- 
    gaussian_laplace : ndarray 
        Filtered array. Has the same shape as `input`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage, datasets 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; ascent = datasets.ascent() 
 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; plt.gray()  # show the filtered result in grayscale 
    &gt;&gt;&gt; ax1 = fig.add_subplot(121)  # left side 
    &gt;&gt;&gt; ax2 = fig.add_subplot(122)  # right side 
 
    &gt;&gt;&gt; result = ndimage.gaussian_laplace(ascent, sigma=1) 
    &gt;&gt;&gt; ax1.imshow(result) 
 
    &gt;&gt;&gt; result = ndimage.gaussian_laplace(ascent, sigma=3) 
    &gt;&gt;&gt; ax2.imshow(result) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">derivative2</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s1">order </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span>
        <span class="s1">order</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s5">2</span>
        <span class="s2">return </span><span class="s1">gaussian_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">,</span>
                               <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">generic_laplace</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">derivative2</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">,</span>
                           <span class="s1">extra_arguments</span><span class="s3">=(</span><span class="s1">sigma</span><span class="s3">,),</span>
                           <span class="s1">extra_keywords</span><span class="s3">=</span><span class="s1">kwargs</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">generic_gradient_magnitude</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">derivative</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                               <span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">,</span>
                               <span class="s1">extra_arguments</span><span class="s3">=(), </span><span class="s1">extra_keywords</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Gradient magnitude using a provided gradient function. 
 
    Parameters 
    ---------- 
    %(input)s 
    derivative : callable 
        Callable with the following signature:: 
 
            derivative(input, axis, output, mode, cval, 
                       *extra_arguments, **extra_keywords) 
 
        See `extra_arguments`, `extra_keywords` below. 
        `derivative` can assume that `input` and `output` are ndarrays. 
        Note that the output from `derivative` is modified inplace; 
        be careful to copy important inputs before returning them. 
    %(output)s 
    %(mode_multiple)s 
    %(cval)s 
    %(extra_keywords)s 
    %(extra_arguments)s 
 
    Returns 
    ------- 
    generic_gradient_matnitude : ndarray 
        Filtered array. Has the same shape as `input`. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">extra_keywords </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">extra_keywords </span><span class="s3">= {}</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">axes </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">modes </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">))</span>
        <span class="s1">derivative</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">output</span><span class="s3">, </span><span class="s1">modes</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">cval</span><span class="s3">,</span>
                   <span class="s3">*</span><span class="s1">extra_arguments</span><span class="s3">, **</span><span class="s1">extra_keywords</span><span class="s3">)</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">output</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">)):</span>
            <span class="s1">tmp </span><span class="s3">= </span><span class="s1">derivative</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s1">output</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">modes</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s1">cval</span><span class="s3">,</span>
                             <span class="s3">*</span><span class="s1">extra_arguments</span><span class="s3">, **</span><span class="s1">extra_keywords</span><span class="s3">)</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">tmp</span><span class="s3">, </span><span class="s1">tmp</span><span class="s3">)</span>
            <span class="s1">output </span><span class="s3">+= </span><span class="s1">tmp</span>
        <span class="s0"># This allows the sqrt to work with a different default casting</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">casting</span><span class="s3">=</span><span class="s4">'unsafe'</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">output</span><span class="s3">[...] = </span><span class="s1">input</span><span class="s3">[...]</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">gaussian_gradient_magnitude</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                                <span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Multidimensional gradient magnitude using Gaussian derivatives. 
 
    Parameters 
    ---------- 
    %(input)s 
    sigma : scalar or sequence of scalars 
        The standard deviations of the Gaussian filter are given for 
        each axis as a sequence, or as a single number, in which case 
        it is equal for all axes. 
    %(output)s 
    %(mode_multiple)s 
    %(cval)s 
    Extra keyword arguments will be passed to gaussian_filter(). 
 
    Returns 
    ------- 
    gaussian_gradient_magnitude : ndarray 
        Filtered array. Has the same shape as `input`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage, datasets 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; plt.gray()  # show the filtered result in grayscale 
    &gt;&gt;&gt; ax1 = fig.add_subplot(121)  # left side 
    &gt;&gt;&gt; ax2 = fig.add_subplot(122)  # right side 
    &gt;&gt;&gt; ascent = datasets.ascent() 
    &gt;&gt;&gt; result = ndimage.gaussian_gradient_magnitude(ascent, sigma=5) 
    &gt;&gt;&gt; ax1.imshow(ascent) 
    &gt;&gt;&gt; ax2.imshow(result) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">derivative</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s1">order </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span>
        <span class="s1">order</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">gaussian_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">sigma</span><span class="s3">, </span><span class="s1">order</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                               <span class="s1">cval</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">generic_gradient_magnitude</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">derivative</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                                      <span class="s1">cval</span><span class="s3">, </span><span class="s1">extra_arguments</span><span class="s3">=(</span><span class="s1">sigma</span><span class="s3">,),</span>
                                      <span class="s1">extra_keywords</span><span class="s3">=</span><span class="s1">kwargs</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_correlate_or_convolve</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">,</span>
                           <span class="s1">convolution</span><span class="s3">):</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">weights </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">)</span>
    <span class="s1">complex_input </span><span class="s3">= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'c'</span>
    <span class="s1">complex_weights </span><span class="s3">= </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'c'</span>
    <span class="s2">if </span><span class="s1">complex_input </span><span class="s2">or </span><span class="s1">complex_weights</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">complex_weights </span><span class="s2">and not </span><span class="s1">convolution</span><span class="s3">:</span>
            <span class="s0"># As for np.correlate, conjugate weights rather than input.</span>
            <span class="s1">weights </span><span class="s3">= </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">()</span>
        <span class="s1">kwargs </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span>
            <span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s1">origin</span><span class="s3">, </span><span class="s1">convolution</span><span class="s3">=</span><span class="s1">convolution</span>
        <span class="s3">)</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">, </span><span class="s1">complex_output</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">_complex_via_real_components</span><span class="s3">(</span><span class="s1">_correlate_or_convolve</span><span class="s3">, </span><span class="s1">input</span><span class="s3">,</span>
                                            <span class="s1">weights</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s1">origins </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">weights </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s1">wshape </span><span class="s3">= [</span><span class="s1">ii </span><span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">shape </span><span class="s2">if </span><span class="s1">ii </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">wshape</span><span class="s3">) != </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'filter weights array has incorrect shape.'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">convolution</span><span class="s3">:</span>
        <span class="s1">weights </span><span class="s3">= </span><span class="s1">weights</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)] * </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)]</span>
        <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">origins</span><span class="s3">)):</span>
            <span class="s1">origins</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">] = -</span><span class="s1">origins</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">]</span>
            <span class="s2">if not </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">] &amp; </span><span class="s5">1</span><span class="s3">:</span>
                <span class="s1">origins</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">] -= </span><span class="s5">1</span>
    <span class="s2">for </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">lenw </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">origins</span><span class="s3">, </span><span class="s1">wshape</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">_invalid_origin</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">, </span><span class="s1">lenw</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Invalid origin; origin must satisfy '</span>
                             <span class="s4">'-(weights.shape[k] // 2) &lt;= origin[k] &lt;= '</span>
                             <span class="s4">'(weights.shape[k]-1) // 2'</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">contiguous</span><span class="s3">:</span>
        <span class="s1">weights </span><span class="s3">= </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">temp_needed </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">may_share_memory</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">output</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">temp_needed</span><span class="s3">:</span>
        <span class="s0"># input and output arrays cannot share memory</span>
        <span class="s1">temp </span><span class="s3">= </span><span class="s1">output</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">str</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">Iterable</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">&quot;A sequence of modes is not supported&quot;</span><span class="s3">)</span>
    <span class="s1">mode </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_extend_mode_to_code</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">)</span>
    <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">correlate</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">, </span><span class="s1">origins</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">temp_needed</span><span class="s3">:</span>
        <span class="s1">temp</span><span class="s3">[...] = </span><span class="s1">output</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">temp</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">correlate</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'reflect'</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">,</span>
              <span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Multidimensional correlation. 
 
    The array is correlated with the given kernel. 
 
    Parameters 
    ---------- 
    %(input)s 
    weights : ndarray 
        array of weights, same number of dimensions as input 
    %(output)s 
    %(mode_reflect)s 
    %(cval)s 
    %(origin_multiple)s 
 
    Returns 
    ------- 
    result : ndarray 
        The result of correlation of `input` with `weights`. 
 
    See Also 
    -------- 
    convolve : Convolve an image with a kernel. 
 
    Examples 
    -------- 
    Correlation is the process of moving a filter mask often referred to 
    as kernel over the image and computing the sum of products at each location. 
 
    &gt;&gt;&gt; from scipy.ndimage import correlate 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; input_img = np.arange(25).reshape(5,5) 
    &gt;&gt;&gt; print(input_img) 
    [[ 0  1  2  3  4] 
    [ 5  6  7  8  9] 
    [10 11 12 13 14] 
    [15 16 17 18 19] 
    [20 21 22 23 24]] 
 
    Define a kernel (weights) for correlation. In this example, it is for sum of 
    center and up, down, left and right next elements. 
 
    &gt;&gt;&gt; weights = [[0, 1, 0], 
    ...            [1, 1, 1], 
    ...            [0, 1, 0]] 
 
    We can calculate a correlation result: 
    For example, element ``[2,2]`` is ``7 + 11 + 12 + 13 + 17 = 60``. 
 
    &gt;&gt;&gt; correlate(input_img, weights) 
    array([[  6,  10,  15,  20,  24], 
        [ 26,  30,  35,  40,  44], 
        [ 51,  55,  60,  65,  69], 
        [ 76,  80,  85,  90,  94], 
        [ 96, 100, 105, 110, 114]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_correlate_or_convolve</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">,</span>
                                  <span class="s1">origin</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">convolve</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'reflect'</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">,</span>
             <span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Multidimensional convolution. 
 
    The array is convolved with the given kernel. 
 
    Parameters 
    ---------- 
    %(input)s 
    weights : array_like 
        Array of weights, same number of dimensions as input 
    %(output)s 
    %(mode_reflect)s 
    cval : scalar, optional 
        Value to fill past edges of input if `mode` is 'constant'. Default 
        is 0.0 
    origin : int, optional 
        Controls the origin of the input signal, which is where the 
        filter is centered to produce the first element of the output. 
        Positive values shift the filter to the right, and negative values 
        shift the filter to the left. Default is 0. 
 
    Returns 
    ------- 
    result : ndarray 
        The result of convolution of `input` with `weights`. 
 
    See Also 
    -------- 
    correlate : Correlate an image with a kernel. 
 
    Notes 
    ----- 
    Each value in result is :math:`C_i = \\sum_j{I_{i+k-j} W_j}`, where 
    W is the `weights` kernel, 
    j is the N-D spatial index over :math:`W`, 
    I is the `input` and k is the coordinate of the center of 
    W, specified by `origin` in the input parameters. 
 
    Examples 
    -------- 
    Perhaps the simplest case to understand is ``mode='constant', cval=0.0``, 
    because in this case borders (i.e., where the `weights` kernel, centered 
    on any one value, extends beyond an edge of `input`) are treated as zeros. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([[1, 2, 0, 0], 
    ...               [5, 3, 0, 4], 
    ...               [0, 0, 0, 7], 
    ...               [9, 3, 0, 0]]) 
    &gt;&gt;&gt; k = np.array([[1,1,1],[1,1,0],[1,0,0]]) 
    &gt;&gt;&gt; from scipy import ndimage 
    &gt;&gt;&gt; ndimage.convolve(a, k, mode='constant', cval=0.0) 
    array([[11, 10,  7,  4], 
           [10,  3, 11, 11], 
           [15, 12, 14,  7], 
           [12,  3,  7,  0]]) 
 
    Setting ``cval=1.0`` is equivalent to padding the outer edge of `input` 
    with 1.0's (and then extracting only the original region of the result). 
 
    &gt;&gt;&gt; ndimage.convolve(a, k, mode='constant', cval=1.0) 
    array([[13, 11,  8,  7], 
           [11,  3, 11, 14], 
           [16, 12, 14, 10], 
           [15,  6, 10,  5]]) 
 
    With ``mode='reflect'`` (the default), outer values are reflected at the 
    edge of `input` to fill in missing values. 
 
    &gt;&gt;&gt; b = np.array([[2, 0, 0], 
    ...               [1, 0, 0], 
    ...               [0, 0, 0]]) 
    &gt;&gt;&gt; k = np.array([[0,1,0], [0,1,0], [0,1,0]]) 
    &gt;&gt;&gt; ndimage.convolve(b, k, mode='reflect') 
    array([[5, 0, 0], 
           [3, 0, 0], 
           [1, 0, 0]]) 
 
    This includes diagonally at the corners. 
 
    &gt;&gt;&gt; k = np.array([[1,0,0],[0,1,0],[0,0,1]]) 
    &gt;&gt;&gt; ndimage.convolve(b, k) 
    array([[4, 2, 0], 
           [3, 2, 0], 
           [1, 1, 0]]) 
 
    With ``mode='nearest'``, the single nearest value in to an edge in 
    `input` is repeated as many times as needed to match the overlapping 
    `weights`. 
 
    &gt;&gt;&gt; c = np.array([[2, 0, 1], 
    ...               [1, 0, 0], 
    ...               [0, 0, 0]]) 
    &gt;&gt;&gt; k = np.array([[0, 1, 0], 
    ...               [0, 1, 0], 
    ...               [0, 1, 0], 
    ...               [0, 1, 0], 
    ...               [0, 1, 0]]) 
    &gt;&gt;&gt; ndimage.convolve(c, k, mode='nearest') 
    array([[7, 0, 3], 
           [5, 0, 2], 
           [3, 0, 1]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_correlate_or_convolve</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">,</span>
                                  <span class="s1">origin</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">uniform_filter1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                     <span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Calculate a 1-D uniform filter along the given axis. 
 
    The lines of the array along the given axis are filtered with a 
    uniform filter of given size. 
 
    Parameters 
    ---------- 
    %(input)s 
    size : int 
        length of uniform filter 
    %(axis)s 
    %(output)s 
    %(mode_reflect)s 
    %(cval)s 
    %(origin)s 
 
    Returns 
    ------- 
    result : ndarray 
        Filtered array. Has same shape as `input`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.ndimage import uniform_filter1d 
    &gt;&gt;&gt; uniform_filter1d([2, 8, 0, 4, 1, 9, 9, 0], size=3) 
    array([4, 3, 4, 1, 4, 6, 6, 3]) 
    &quot;&quot;&quot;</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">axis </span><span class="s3">= </span><span class="s1">normalize_axis_index</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">size </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'incorrect filter size'</span><span class="s3">)</span>
    <span class="s1">complex_output </span><span class="s3">= </span><span class="s1">input</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'c'</span>
    <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">,</span>
                                     <span class="s1">complex_output</span><span class="s3">=</span><span class="s1">complex_output</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">size </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s1">origin </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">size </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s1">origin </span><span class="s3">&gt;= </span><span class="s1">size</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'invalid origin'</span><span class="s3">)</span>
    <span class="s1">mode </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_extend_mode_to_code</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">complex_output</span><span class="s3">:</span>
        <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">uniform_filter1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">,</span>
                                   <span class="s1">origin</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">uniform_filter1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">real</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">output</span><span class="s3">.</span><span class="s1">real</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                                   <span class="s1">np</span><span class="s3">.</span><span class="s1">real</span><span class="s3">(</span><span class="s1">cval</span><span class="s3">), </span><span class="s1">origin</span><span class="s3">)</span>
        <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">uniform_filter1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">output</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                                   <span class="s1">np</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">(</span><span class="s1">cval</span><span class="s3">), </span><span class="s1">origin</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">uniform_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s5">3</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">,</span>
                   <span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, *, </span><span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Multidimensional uniform filter. 
 
    Parameters 
    ---------- 
    %(input)s 
    size : int or sequence of ints, optional 
        The sizes of the uniform filter are given for each axis as a 
        sequence, or as a single number, in which case the size is 
        equal for all axes. 
    %(output)s 
    %(mode_multiple)s 
    %(cval)s 
    %(origin_multiple)s 
    axes : tuple of int or None, optional 
        If None, `input` is filtered along all axes. Otherwise, 
        `input` is filtered along the specified axes. When `axes` is 
        specified, any tuples used for `size`, `origin`, and/or `mode` 
        must match the length of `axes`. The ith entry in any of these tuples 
        corresponds to the ith entry in `axes`. 
 
    Returns 
    ------- 
    uniform_filter : ndarray 
        Filtered array. Has the same shape as `input`. 
 
    Notes 
    ----- 
    The multidimensional filter is implemented as a sequence of 
    1-D uniform filters. The intermediate arrays are stored 
    in the same data type as the output. Therefore, for output types 
    with a limited precision, the results may be imprecise because 
    intermediate results may be stored with insufficient precision. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage, datasets 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; plt.gray()  # show the filtered result in grayscale 
    &gt;&gt;&gt; ax1 = fig.add_subplot(121)  # left side 
    &gt;&gt;&gt; ax2 = fig.add_subplot(122)  # right side 
    &gt;&gt;&gt; ascent = datasets.ascent() 
    &gt;&gt;&gt; result = ndimage.uniform_filter(ascent, size=20) 
    &gt;&gt;&gt; ax1.imshow(ascent) 
    &gt;&gt;&gt; ax2.imshow(result) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">,</span>
                                     <span class="s1">complex_output</span><span class="s3">=</span><span class="s1">input</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'c'</span><span class="s3">)</span>
    <span class="s1">axes </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_check_axes</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">num_axes </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">)</span>
    <span class="s1">sizes </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">size</span><span class="s3">, </span><span class="s1">num_axes</span><span class="s3">)</span>
    <span class="s1">origins </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">, </span><span class="s1">num_axes</span><span class="s3">)</span>
    <span class="s1">modes </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">num_axes</span><span class="s3">)</span>
    <span class="s1">axes </span><span class="s3">= [(</span><span class="s1">axes</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s1">sizes</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s1">origins</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s1">modes</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">])</span>
            <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">num_axes</span><span class="s3">) </span><span class="s2">if </span><span class="s1">sizes</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">] &gt; </span><span class="s5">1</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">axes</span><span class="s3">:</span>
            <span class="s1">uniform_filter1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">int</span><span class="s3">(</span><span class="s1">size</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                             <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>
            <span class="s1">input </span><span class="s3">= </span><span class="s1">output</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">output</span><span class="s3">[...] = </span><span class="s1">input</span><span class="s3">[...]</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">minimum_filter1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                     <span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Calculate a 1-D minimum filter along the given axis. 
 
    The lines of the array along the given axis are filtered with a 
    minimum filter of given size. 
 
    Parameters 
    ---------- 
    %(input)s 
    size : int 
        length along which to calculate 1D minimum 
    %(axis)s 
    %(output)s 
    %(mode_reflect)s 
    %(cval)s 
    %(origin)s 
 
    Returns 
    ------- 
    result : ndarray. 
        Filtered image. Has the same shape as `input`. 
 
    Notes 
    ----- 
    This function implements the MINLIST algorithm [1]_, as described by 
    Richard Harter [2]_, and has a guaranteed O(n) performance, `n` being 
    the `input` length, regardless of filter size. 
 
    References 
    ---------- 
    .. [1] http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.2777 
    .. [2] http://www.richardhartersworld.com/cri/2001/slidingmin.html 
 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.ndimage import minimum_filter1d 
    &gt;&gt;&gt; minimum_filter1d([2, 8, 0, 4, 1, 9, 9, 0], size=3) 
    array([2, 0, 0, 0, 1, 1, 0, 0]) 
    &quot;&quot;&quot;</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">input</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">'Complex type not supported'</span><span class="s3">)</span>
    <span class="s1">axis </span><span class="s3">= </span><span class="s1">normalize_axis_index</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">size </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'incorrect filter size'</span><span class="s3">)</span>
    <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">size </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s1">origin </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">size </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s1">origin </span><span class="s3">&gt;= </span><span class="s1">size</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'invalid origin'</span><span class="s3">)</span>
    <span class="s1">mode </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_extend_mode_to_code</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">)</span>
    <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">min_or_max_filter1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">,</span>
                                  <span class="s1">origin</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">maximum_filter1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                     <span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Calculate a 1-D maximum filter along the given axis. 
 
    The lines of the array along the given axis are filtered with a 
    maximum filter of given size. 
 
    Parameters 
    ---------- 
    %(input)s 
    size : int 
        Length along which to calculate the 1-D maximum. 
    %(axis)s 
    %(output)s 
    %(mode_reflect)s 
    %(cval)s 
    %(origin)s 
 
    Returns 
    ------- 
    maximum1d : ndarray, None 
        Maximum-filtered array with same shape as input. 
        None if `output` is not None 
 
    Notes 
    ----- 
    This function implements the MAXLIST algorithm [1]_, as described by 
    Richard Harter [2]_, and has a guaranteed O(n) performance, `n` being 
    the `input` length, regardless of filter size. 
 
    References 
    ---------- 
    .. [1] http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.2777 
    .. [2] http://www.richardhartersworld.com/cri/2001/slidingmin.html 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.ndimage import maximum_filter1d 
    &gt;&gt;&gt; maximum_filter1d([2, 8, 0, 4, 1, 9, 9, 0], size=3) 
    array([8, 8, 8, 4, 9, 9, 9, 9]) 
    &quot;&quot;&quot;</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">input</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">'Complex type not supported'</span><span class="s3">)</span>
    <span class="s1">axis </span><span class="s3">= </span><span class="s1">normalize_axis_index</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">size </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'incorrect filter size'</span><span class="s3">)</span>
    <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">size </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s1">origin </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">size </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s1">origin </span><span class="s3">&gt;= </span><span class="s1">size</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'invalid origin'</span><span class="s3">)</span>
    <span class="s1">mode </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_extend_mode_to_code</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">)</span>
    <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">min_or_max_filter1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">,</span>
                                  <span class="s1">origin</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s2">def </span><span class="s1">_min_or_max_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                       <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">minimum</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">size </span><span class="s2">is not None</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">footprint </span><span class="s2">is not None</span><span class="s3">):</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">&quot;ignoring size because footprint is set&quot;</span><span class="s3">,</span>
                      <span class="s1">UserWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">3</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">structure </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">footprint </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">&quot;no footprint provided&quot;</span><span class="s3">)</span>
            <span class="s1">separable </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">footprint </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>
            <span class="s2">if not </span><span class="s1">footprint</span><span class="s3">.</span><span class="s1">any</span><span class="s3">():</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;All-zero footprint is not supported.&quot;</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">footprint</span><span class="s3">.</span><span class="s1">all</span><span class="s3">():</span>
                <span class="s1">size </span><span class="s3">= </span><span class="s1">footprint</span><span class="s3">.</span><span class="s1">shape</span>
                <span class="s1">footprint </span><span class="s3">= </span><span class="s2">None</span>
                <span class="s1">separable </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">separable </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">structure </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">structure</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s1">separable </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">footprint </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">footprint </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">structure</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">footprint </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">input</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">&quot;Complex type not supported&quot;</span><span class="s3">)</span>
    <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">temp_needed </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">may_share_memory</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">output</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">temp_needed</span><span class="s3">:</span>
        <span class="s0"># input and output arrays cannot share memory</span>
        <span class="s1">temp </span><span class="s3">= </span><span class="s1">output</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">axes </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_check_axes</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">num_axes </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">separable</span><span class="s3">:</span>
        <span class="s1">origins </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">, </span><span class="s1">num_axes</span><span class="s3">)</span>
        <span class="s1">sizes </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">size</span><span class="s3">, </span><span class="s1">num_axes</span><span class="s3">)</span>
        <span class="s1">modes </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">num_axes</span><span class="s3">)</span>
        <span class="s1">axes </span><span class="s3">= [(</span><span class="s1">axes</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s1">sizes</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s1">origins</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">], </span><span class="s1">modes</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">])</span>
                <span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">)) </span><span class="s2">if </span><span class="s1">sizes</span><span class="s3">[</span><span class="s1">ii</span><span class="s3">] &gt; </span><span class="s5">1</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">minimum</span><span class="s3">:</span>
            <span class="s1">filter_ </span><span class="s3">= </span><span class="s1">minimum_filter1d</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">filter_ </span><span class="s3">= </span><span class="s1">maximum_filter1d</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">axes</span><span class="s3">:</span>
                <span class="s1">filter_</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">int</span><span class="s3">(</span><span class="s1">size</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">)</span>
                <span class="s1">input </span><span class="s3">= </span><span class="s1">output</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">output</span><span class="s3">[...] = </span><span class="s1">input</span><span class="s3">[...]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">origins </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">, </span><span class="s1">num_axes</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">num_axes </span><span class="s3">&lt; </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">footprint</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s1">num_axes</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">&quot;footprint array has incorrect shape&quot;</span><span class="s3">)</span>
            <span class="s1">footprint </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">expand_dims</span><span class="s3">(</span>
                <span class="s1">footprint</span><span class="s3">,</span>
                <span class="s1">tuple</span><span class="s3">(</span><span class="s1">ax </span><span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">) </span><span class="s2">if </span><span class="s1">ax </span><span class="s2">not in </span><span class="s1">axes</span><span class="s3">)</span>
            <span class="s3">)</span>
            <span class="s0"># set origin = 0 for any axes not being filtered</span>
            <span class="s1">origins_temp </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">,] * </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span>
            <span class="s2">for </span><span class="s1">o</span><span class="s3">, </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">origins</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">):</span>
                <span class="s1">origins_temp</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">] = </span><span class="s1">o</span>
            <span class="s1">origins </span><span class="s3">= </span><span class="s1">origins_temp</span>

        <span class="s1">fshape </span><span class="s3">= [</span><span class="s1">ii </span><span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">footprint</span><span class="s3">.</span><span class="s1">shape </span><span class="s2">if </span><span class="s1">ii </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">fshape</span><span class="s3">) != </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'footprint array has incorrect shape.'</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">lenf </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">origins</span><span class="s3">, </span><span class="s1">fshape</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">lenf </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s1">origin </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">lenf </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s1">origin </span><span class="s3">&gt;= </span><span class="s1">lenf</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;invalid origin&quot;</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">footprint</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">contiguous</span><span class="s3">:</span>
            <span class="s1">footprint </span><span class="s3">= </span><span class="s1">footprint</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">structure </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">structure</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">) != </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">&quot;structure array has incorrect shape&quot;</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">num_axes </span><span class="s3">!= </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
                <span class="s1">structure </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">expand_dims</span><span class="s3">(</span>
                    <span class="s1">structure</span><span class="s3">,</span>
                    <span class="s1">tuple</span><span class="s3">(</span><span class="s1">ax </span><span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">structure</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">) </span><span class="s2">if </span><span class="s1">ax </span><span class="s2">not in </span><span class="s1">axes</span><span class="s3">)</span>
                <span class="s3">)</span>
            <span class="s2">if not </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">contiguous</span><span class="s3">:</span>
                <span class="s1">structure </span><span class="s3">= </span><span class="s1">structure</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">str</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">Iterable</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span>
                <span class="s4">&quot;A sequence of modes is not supported for non-separable &quot;</span>
                <span class="s4">&quot;footprints&quot;</span><span class="s3">)</span>
        <span class="s1">mode </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_extend_mode_to_code</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">)</span>
        <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">min_or_max_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">output</span><span class="s3">,</span>
                                    <span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">, </span><span class="s1">origins</span><span class="s3">, </span><span class="s1">minimum</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">temp_needed</span><span class="s3">:</span>
        <span class="s1">temp</span><span class="s3">[...] = </span><span class="s1">output</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">temp</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">minimum_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                   <span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, *, </span><span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Calculate a multidimensional minimum filter. 
 
    Parameters 
    ---------- 
    %(input)s 
    %(size_foot)s 
    %(output)s 
    %(mode_multiple)s 
    %(cval)s 
    %(origin_multiple)s 
    axes : tuple of int or None, optional 
        If None, `input` is filtered along all axes. Otherwise, 
        `input` is filtered along the specified axes. When `axes` is 
        specified, any tuples used for `size`, `origin`, and/or `mode` 
        must match the length of `axes`. The ith entry in any of these tuples 
        corresponds to the ith entry in `axes`. 
 
    Returns 
    ------- 
    minimum_filter : ndarray 
        Filtered array. Has the same shape as `input`. 
 
    Notes 
    ----- 
    A sequence of modes (one per axis) is only supported when the footprint is 
    separable. Otherwise, a single mode string must be provided. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage, datasets 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; plt.gray()  # show the filtered result in grayscale 
    &gt;&gt;&gt; ax1 = fig.add_subplot(121)  # left side 
    &gt;&gt;&gt; ax2 = fig.add_subplot(122)  # right side 
    &gt;&gt;&gt; ascent = datasets.ascent() 
    &gt;&gt;&gt; result = ndimage.minimum_filter(ascent, size=20) 
    &gt;&gt;&gt; ax1.imshow(ascent) 
    &gt;&gt;&gt; ax2.imshow(result) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_min_or_max_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                              <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">maximum_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                   <span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, *, </span><span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Calculate a multidimensional maximum filter. 
 
    Parameters 
    ---------- 
    %(input)s 
    %(size_foot)s 
    %(output)s 
    %(mode_multiple)s 
    %(cval)s 
    %(origin_multiple)s 
    axes : tuple of int or None, optional 
        If None, `input` is filtered along all axes. Otherwise, 
        `input` is filtered along the specified axes. When `axes` is 
        specified, any tuples used for `size`, `origin`, and/or `mode` 
        must match the length of `axes`. The ith entry in any of these tuples 
        corresponds to the ith entry in `axes`. 
 
    Returns 
    ------- 
    maximum_filter : ndarray 
        Filtered array. Has the same shape as `input`. 
 
    Notes 
    ----- 
    A sequence of modes (one per axis) is only supported when the footprint is 
    separable. Otherwise, a single mode string must be provided. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage, datasets 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; plt.gray()  # show the filtered result in grayscale 
    &gt;&gt;&gt; ax1 = fig.add_subplot(121)  # left side 
    &gt;&gt;&gt; ax2 = fig.add_subplot(122)  # right side 
    &gt;&gt;&gt; ascent = datasets.ascent() 
    &gt;&gt;&gt; result = ndimage.maximum_filter(ascent, size=20) 
    &gt;&gt;&gt; ax1.imshow(ascent) 
    &gt;&gt;&gt; ax2.imshow(result) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_min_or_max_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                              <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">_rank_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">rank</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                 <span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">operation</span><span class="s3">=</span><span class="s4">'rank'</span><span class="s3">,</span>
                 <span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">size </span><span class="s2">is not None</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">footprint </span><span class="s2">is not None</span><span class="s3">):</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">&quot;ignoring size because footprint is set&quot;</span><span class="s3">,</span>
                      <span class="s1">UserWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">3</span><span class="s3">)</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">input</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">'Complex type not supported'</span><span class="s3">)</span>
    <span class="s1">axes </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_check_axes</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s1">num_axes </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">)</span>
    <span class="s1">origins </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">, </span><span class="s1">num_axes</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">footprint </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">&quot;no footprint or filter size provided&quot;</span><span class="s3">)</span>
        <span class="s1">sizes </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">size</span><span class="s3">, </span><span class="s1">num_axes</span><span class="s3">)</span>
        <span class="s1">footprint </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">sizes</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">footprint </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">num_axes </span><span class="s3">&lt; </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
        <span class="s0"># set origin = 0 for any axes not being filtered</span>
        <span class="s1">origins_temp </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">,] * </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span>
        <span class="s2">for </span><span class="s1">o</span><span class="s3">, </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">origins</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">):</span>
            <span class="s1">origins_temp</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">] = </span><span class="s1">o</span>
        <span class="s1">origins </span><span class="s3">= </span><span class="s1">origins_temp</span>

        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">str</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">Iterable</span><span class="s3">):</span>
            <span class="s0"># set mode = 'constant' for any axes not being filtered</span>
            <span class="s1">modes </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">num_axes</span><span class="s3">)</span>
            <span class="s1">modes_temp </span><span class="s3">= [</span><span class="s4">'constant'</span><span class="s3">] * </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span>
            <span class="s2">for </span><span class="s1">m</span><span class="s3">, </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">modes</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">):</span>
                <span class="s1">modes_temp</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">] = </span><span class="s1">m</span>
            <span class="s1">mode </span><span class="s3">= </span><span class="s1">modes_temp</span>

        <span class="s0"># insert singleton dimension along any non-filtered axes</span>
        <span class="s2">if </span><span class="s1">footprint</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s1">num_axes</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">&quot;footprint array has incorrect shape&quot;</span><span class="s3">)</span>
        <span class="s1">footprint </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">expand_dims</span><span class="s3">(</span>
            <span class="s1">footprint</span><span class="s3">,</span>
            <span class="s1">tuple</span><span class="s3">(</span><span class="s1">ax </span><span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">) </span><span class="s2">if </span><span class="s1">ax </span><span class="s2">not in </span><span class="s1">axes</span><span class="s3">)</span>
        <span class="s3">)</span>
    <span class="s1">fshape </span><span class="s3">= [</span><span class="s1">ii </span><span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">footprint</span><span class="s3">.</span><span class="s1">shape </span><span class="s2">if </span><span class="s1">ii </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">fshape</span><span class="s3">) != </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'footprint array has incorrect shape.'</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">lenf </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">origins</span><span class="s3">, </span><span class="s1">fshape</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">lenf </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s1">origin </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">lenf </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s1">origin </span><span class="s3">&gt;= </span><span class="s1">lenf</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'invalid origin'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">footprint</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">contiguous</span><span class="s3">:</span>
        <span class="s1">footprint </span><span class="s3">= </span><span class="s1">footprint</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">filter_size </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">footprint</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s1">operation </span><span class="s3">== </span><span class="s4">'median'</span><span class="s3">:</span>
        <span class="s1">rank </span><span class="s3">= </span><span class="s1">filter_size </span><span class="s3">// </span><span class="s5">2</span>
    <span class="s2">elif </span><span class="s1">operation </span><span class="s3">== </span><span class="s4">'percentile'</span><span class="s3">:</span>
        <span class="s1">percentile </span><span class="s3">= </span><span class="s1">rank</span>
        <span class="s2">if </span><span class="s1">percentile </span><span class="s3">&lt; </span><span class="s5">0.0</span><span class="s3">:</span>
            <span class="s1">percentile </span><span class="s3">+= </span><span class="s5">100.0</span>
        <span class="s2">if </span><span class="s1">percentile </span><span class="s3">&lt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">percentile </span><span class="s3">&gt; </span><span class="s5">100</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'invalid percentile'</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">percentile </span><span class="s3">== </span><span class="s5">100.0</span><span class="s3">:</span>
            <span class="s1">rank </span><span class="s3">= </span><span class="s1">filter_size </span><span class="s3">- </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">rank </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">float</span><span class="s3">(</span><span class="s1">filter_size</span><span class="s3">) * </span><span class="s1">percentile </span><span class="s3">/ </span><span class="s5">100.0</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">rank </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">rank </span><span class="s3">+= </span><span class="s1">filter_size</span>
    <span class="s2">if </span><span class="s1">rank </span><span class="s3">&lt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">rank </span><span class="s3">&gt;= </span><span class="s1">filter_size</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'rank not within filter footprint size'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">rank </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">minimum_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">,</span>
                              <span class="s1">origins</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">rank </span><span class="s3">== </span><span class="s1">filter_size </span><span class="s3">- </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">maximum_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">,</span>
                              <span class="s1">origins</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
        <span class="s1">temp_needed </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">may_share_memory</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">output</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">temp_needed</span><span class="s3">:</span>
            <span class="s0"># input and output arrays cannot share memory</span>
            <span class="s1">temp </span><span class="s3">= </span><span class="s1">output</span>
            <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">str</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">Iterable</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span>
                <span class="s4">&quot;A sequence of modes is not supported by non-separable rank &quot;</span>
                <span class="s4">&quot;filters&quot;</span><span class="s3">)</span>
        <span class="s1">mode </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_extend_mode_to_code</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">)</span>
        <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">rank_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">rank</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">,</span>
                              <span class="s1">origins</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">temp_needed</span><span class="s3">:</span>
            <span class="s1">temp</span><span class="s3">[...] = </span><span class="s1">output</span>
            <span class="s1">output </span><span class="s3">= </span><span class="s1">temp</span>
        <span class="s2">return </span><span class="s1">output</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">rank_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">rank</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, *, </span><span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Calculate a multidimensional rank filter. 
 
    Parameters 
    ---------- 
    %(input)s 
    rank : int 
        The rank parameter may be less than zero, i.e., rank = -1 
        indicates the largest element. 
    %(size_foot)s 
    %(output)s 
    %(mode_reflect)s 
    %(cval)s 
    %(origin_multiple)s 
    axes : tuple of int or None, optional 
        If None, `input` is filtered along all axes. Otherwise, 
        `input` is filtered along the specified axes. 
 
    Returns 
    ------- 
    rank_filter : ndarray 
        Filtered array. Has the same shape as `input`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage, datasets 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; plt.gray()  # show the filtered result in grayscale 
    &gt;&gt;&gt; ax1 = fig.add_subplot(121)  # left side 
    &gt;&gt;&gt; ax2 = fig.add_subplot(122)  # right side 
    &gt;&gt;&gt; ascent = datasets.ascent() 
    &gt;&gt;&gt; result = ndimage.rank_filter(ascent, rank=42, size=20) 
    &gt;&gt;&gt; ax1.imshow(ascent) 
    &gt;&gt;&gt; ax2.imshow(result) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">rank </span><span class="s3">= </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">rank</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_rank_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">rank</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">,</span>
                        <span class="s1">origin</span><span class="s3">, </span><span class="s4">'rank'</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">axes</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">median_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                  <span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, *, </span><span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Calculate a multidimensional median filter. 
 
    Parameters 
    ---------- 
    %(input)s 
    %(size_foot)s 
    %(output)s 
    %(mode_reflect)s 
    %(cval)s 
    %(origin_multiple)s 
    axes : tuple of int or None, optional 
        If None, `input` is filtered along all axes. Otherwise, 
        `input` is filtered along the specified axes. 
 
    Returns 
    ------- 
    median_filter : ndarray 
        Filtered array. Has the same shape as `input`. 
 
    See Also 
    -------- 
    scipy.signal.medfilt2d 
 
    Notes 
    ----- 
    For 2-dimensional images with ``uint8``, ``float32`` or ``float64`` dtypes 
    the specialised function `scipy.signal.medfilt2d` may be faster. It is 
    however limited to constant mode with ``cval=0``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage, datasets 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; plt.gray()  # show the filtered result in grayscale 
    &gt;&gt;&gt; ax1 = fig.add_subplot(121)  # left side 
    &gt;&gt;&gt; ax2 = fig.add_subplot(122)  # right side 
    &gt;&gt;&gt; ascent = datasets.ascent() 
    &gt;&gt;&gt; result = ndimage.median_filter(ascent, size=20) 
    &gt;&gt;&gt; ax1.imshow(ascent) 
    &gt;&gt;&gt; ax2.imshow(result) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_rank_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">,</span>
                        <span class="s1">origin</span><span class="s3">, </span><span class="s4">'median'</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">axes</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">percentile_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">percentile</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                      <span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, *,</span>
                      <span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Calculate a multidimensional percentile filter. 
 
    Parameters 
    ---------- 
    %(input)s 
    percentile : scalar 
        The percentile parameter may be less than zero, i.e., 
        percentile = -20 equals percentile = 80 
    %(size_foot)s 
    %(output)s 
    %(mode_reflect)s 
    %(cval)s 
    %(origin_multiple)s 
    axes : tuple of int or None, optional 
        If None, `input` is filtered along all axes. Otherwise, 
        `input` is filtered along the specified axes. 
 
    Returns 
    ------- 
    percentile_filter : ndarray 
        Filtered array. Has the same shape as `input`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import ndimage, datasets 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; plt.gray()  # show the filtered result in grayscale 
    &gt;&gt;&gt; ax1 = fig.add_subplot(121)  # left side 
    &gt;&gt;&gt; ax2 = fig.add_subplot(122)  # right side 
    &gt;&gt;&gt; ascent = datasets.ascent() 
    &gt;&gt;&gt; result = ndimage.percentile_filter(ascent, percentile=20, size=20) 
    &gt;&gt;&gt; ax1.imshow(ascent) 
    &gt;&gt;&gt; ax2.imshow(result) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_rank_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">percentile</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                        <span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s4">'percentile'</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">axes</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">generic_filter1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">function</span><span class="s3">, </span><span class="s1">filter_size</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">,</span>
                     <span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
                     <span class="s1">extra_arguments</span><span class="s3">=(), </span><span class="s1">extra_keywords</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Calculate a 1-D filter along the given axis. 
 
    `generic_filter1d` iterates over the lines of the array, calling the 
    given function at each line. The arguments of the line are the 
    input line, and the output line. The input and output lines are 1-D 
    double arrays. The input line is extended appropriately according 
    to the filter size and origin. The output line must be modified 
    in-place with the result. 
 
    Parameters 
    ---------- 
    %(input)s 
    function : {callable, scipy.LowLevelCallable} 
        Function to apply along given axis. 
    filter_size : scalar 
        Length of the filter. 
    %(axis)s 
    %(output)s 
    %(mode_reflect)s 
    %(cval)s 
    %(origin)s 
    %(extra_arguments)s 
    %(extra_keywords)s 
 
    Returns 
    ------- 
    generic_filter1d : ndarray 
        Filtered array. Has the same shape as `input`. 
 
    Notes 
    ----- 
    This function also accepts low-level callback functions with one of 
    the following signatures and wrapped in `scipy.LowLevelCallable`: 
 
    .. code:: c 
 
       int function(double *input_line, npy_intp input_length, 
                    double *output_line, npy_intp output_length, 
                    void *user_data) 
       int function(double *input_line, intptr_t input_length, 
                    double *output_line, intptr_t output_length, 
                    void *user_data) 
 
    The calling function iterates over the lines of the input and output 
    arrays, calling the callback function at each line. The current line 
    is extended according to the border conditions set by the calling 
    function, and the result is copied into the array that is passed 
    through ``input_line``. The length of the input line (after extension) 
    is passed through ``input_length``. The callback function should apply 
    the filter and store the result in the array passed through 
    ``output_line``. The length of the output line is passed through 
    ``output_length``. ``user_data`` is the data pointer provided 
    to `scipy.LowLevelCallable` as-is. 
 
    The callback function must return an integer error status that is zero 
    if something went wrong and one otherwise. If an error occurs, you should 
    normally set the python error status with an informative message 
    before returning, otherwise a default error message is set by the 
    calling function. 
 
    In addition, some other low-level function pointer specifications 
    are accepted, but these are for backward compatibility only and should 
    not be used in new code. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">extra_keywords </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">extra_keywords </span><span class="s3">= {}</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">input</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">'Complex type not supported'</span><span class="s3">)</span>
    <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">filter_size </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'invalid filter size'</span><span class="s3">)</span>
    <span class="s1">axis </span><span class="s3">= </span><span class="s1">normalize_axis_index</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">filter_size </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s1">origin </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">filter_size </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s1">origin </span><span class="s3">&gt;=</span>
                                           <span class="s1">filter_size</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'invalid origin'</span><span class="s3">)</span>
    <span class="s1">mode </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_extend_mode_to_code</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">)</span>
    <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">generic_filter1d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">function</span><span class="s3">, </span><span class="s1">filter_size</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">output</span><span class="s3">,</span>
                               <span class="s1">mode</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">extra_arguments</span><span class="s3">,</span>
                               <span class="s1">extra_keywords</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">output</span>


<span class="s3">@</span><span class="s1">_ni_docstrings</span><span class="s3">.</span><span class="s1">docfiller</span>
<span class="s2">def </span><span class="s1">generic_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">function</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                   <span class="s1">output</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;reflect&quot;</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">origin</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
                   <span class="s1">extra_arguments</span><span class="s3">=(), </span><span class="s1">extra_keywords</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Calculate a multidimensional filter using the given function. 
 
    At each element the provided function is called. The input values 
    within the filter footprint at that element are passed to the function 
    as a 1-D array of double values. 
 
    Parameters 
    ---------- 
    %(input)s 
    function : {callable, scipy.LowLevelCallable} 
        Function to apply at each element. 
    %(size_foot)s 
    %(output)s 
    %(mode_reflect)s 
    %(cval)s 
    %(origin_multiple)s 
    %(extra_arguments)s 
    %(extra_keywords)s 
 
    Returns 
    ------- 
    generic_filter : ndarray 
        Filtered array. Has the same shape as `input`. 
 
    Notes 
    ----- 
    This function also accepts low-level callback functions with one of 
    the following signatures and wrapped in `scipy.LowLevelCallable`: 
 
    .. code:: c 
 
       int callback(double *buffer, npy_intp filter_size, 
                    double *return_value, void *user_data) 
       int callback(double *buffer, intptr_t filter_size, 
                    double *return_value, void *user_data) 
 
    The calling function iterates over the elements of the input and 
    output arrays, calling the callback function at each element. The 
    elements within the footprint of the filter at the current element are 
    passed through the ``buffer`` parameter, and the number of elements 
    within the footprint through ``filter_size``. The calculated value is 
    returned in ``return_value``. ``user_data`` is the data pointer provided 
    to `scipy.LowLevelCallable` as-is. 
 
    The callback function must return an integer error status that is zero 
    if something went wrong and one otherwise. If an error occurs, you should 
    normally set the python error status with an informative message 
    before returning, otherwise a default error message is set by the 
    calling function. 
 
    In addition, some other low-level function pointer specifications 
    are accepted, but these are for backward compatibility only and should 
    not be used in new code. 
 
    Examples 
    -------- 
    Import the necessary modules and load the example image used for 
    filtering. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import datasets 
    &gt;&gt;&gt; from scipy.ndimage import zoom, generic_filter 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; ascent = zoom(datasets.ascent(), 0.5) 
 
    Compute a maximum filter with kernel size 5 by passing a simple NumPy 
    aggregation function as argument to `function`. 
 
    &gt;&gt;&gt; maximum_filter_result = generic_filter(ascent, np.amax, [5, 5]) 
 
    While a maximmum filter could also directly be obtained using 
    `maximum_filter`, `generic_filter` allows generic Python function or 
    `scipy.LowLevelCallable` to be used as a filter. Here, we compute the 
    range between maximum and minimum value as an example for a kernel size 
    of 5. 
 
    &gt;&gt;&gt; def custom_filter(image): 
    ...     return np.amax(image) - np.amin(image) 
    &gt;&gt;&gt; custom_filter_result = generic_filter(ascent, custom_filter, [5, 5]) 
 
    Plot the original and filtered images. 
 
    &gt;&gt;&gt; fig, axes = plt.subplots(3, 1, figsize=(3, 9)) 
    &gt;&gt;&gt; plt.gray()  # show the filtered result in grayscale 
    &gt;&gt;&gt; top, middle, bottom = axes 
    &gt;&gt;&gt; for ax in axes: 
    ...     ax.set_axis_off()  # remove coordinate system 
    &gt;&gt;&gt; top.imshow(ascent) 
    &gt;&gt;&gt; top.set_title(&quot;Original image&quot;) 
    &gt;&gt;&gt; middle.imshow(maximum_filter_result) 
    &gt;&gt;&gt; middle.set_title(&quot;Maximum filter, Kernel: 5x5&quot;) 
    &gt;&gt;&gt; bottom.imshow(custom_filter_result) 
    &gt;&gt;&gt; bottom.set_title(&quot;Custom filter, Kernel: 5x5&quot;) 
    &gt;&gt;&gt; fig.tight_layout() 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">size </span><span class="s2">is not None</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">footprint </span><span class="s2">is not None</span><span class="s3">):</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">&quot;ignoring size because footprint is set&quot;</span><span class="s3">,</span>
                      <span class="s1">UserWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">extra_keywords </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">extra_keywords </span><span class="s3">= {}</span>
    <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">input</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">'Complex type not supported'</span><span class="s3">)</span>
    <span class="s1">origins </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">origin</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">footprint </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">&quot;no footprint or filter size provided&quot;</span><span class="s3">)</span>
        <span class="s1">sizes </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_normalize_sequence</span><span class="s3">(</span><span class="s1">size</span><span class="s3">, </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>
        <span class="s1">footprint </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">sizes</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">footprint </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s1">fshape </span><span class="s3">= [</span><span class="s1">ii </span><span class="s2">for </span><span class="s1">ii </span><span class="s2">in </span><span class="s1">footprint</span><span class="s3">.</span><span class="s1">shape </span><span class="s2">if </span><span class="s1">ii </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">fshape</span><span class="s3">) != </span><span class="s1">input</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span><span class="s4">'filter footprint array has incorrect shape.'</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">origin</span><span class="s3">, </span><span class="s1">lenf </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">origins</span><span class="s3">, </span><span class="s1">fshape</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">lenf </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s1">origin </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">) </span><span class="s2">or </span><span class="s3">(</span><span class="s1">lenf </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s1">origin </span><span class="s3">&gt;= </span><span class="s1">lenf</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'invalid origin'</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">footprint</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">contiguous</span><span class="s3">:</span>
        <span class="s1">footprint </span><span class="s3">= </span><span class="s1">footprint</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">output </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_get_output</span><span class="s3">(</span><span class="s1">output</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
    <span class="s1">mode </span><span class="s3">= </span><span class="s1">_ni_support</span><span class="s3">.</span><span class="s1">_extend_mode_to_code</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">)</span>
    <span class="s1">_nd_image</span><span class="s3">.</span><span class="s1">generic_filter</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">function</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">,</span>
                             <span class="s1">cval</span><span class="s3">, </span><span class="s1">origins</span><span class="s3">, </span><span class="s1">extra_arguments</span><span class="s3">, </span><span class="s1">extra_keywords</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">output</span>
</pre>
</body>
</html>