<html>
<head>
<title>hybrid.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
hybrid.py</font>
</center></td></tr></table>
<pre><span class="s0"># ext/hybrid.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">r&quot;&quot;&quot;Define attributes on ORM-mapped classes that have &quot;hybrid&quot; behavior. 
 
&quot;hybrid&quot; means the attribute has distinct behaviors defined at the 
class level and at the instance level. 
 
The :mod:`~sqlalchemy.ext.hybrid` extension provides a special form of 
method decorator and has minimal dependencies on the rest of SQLAlchemy. 
Its basic theory of operation can work with any descriptor-based expression 
system. 
 
Consider a mapping ``Interval``, representing integer ``start`` and ``end`` 
values. We can define higher level functions on mapped classes that produce SQL 
expressions at the class level, and Python expression evaluation at the 
instance level.  Below, each function decorated with :class:`.hybrid_method` or 
:class:`.hybrid_property` may receive ``self`` as an instance of the class, or 
may receive the class directly, depending on context:: 
 
    from __future__ import annotations 
 
    from sqlalchemy.ext.hybrid import hybrid_method 
    from sqlalchemy.ext.hybrid import hybrid_property 
    from sqlalchemy.orm import DeclarativeBase 
    from sqlalchemy.orm import Mapped 
    from sqlalchemy.orm import mapped_column 
 
 
    class Base(DeclarativeBase): 
        pass 
 
    class Interval(Base): 
        __tablename__ = 'interval' 
 
        id: Mapped[int] = mapped_column(primary_key=True) 
        start: Mapped[int] 
        end: Mapped[int] 
 
        def __init__(self, start: int, end: int): 
            self.start = start 
            self.end = end 
 
        @hybrid_property 
        def length(self) -&gt; int: 
            return self.end - self.start 
 
        @hybrid_method 
        def contains(self, point: int) -&gt; bool: 
            return (self.start &lt;= point) &amp; (point &lt;= self.end) 
 
        @hybrid_method 
        def intersects(self, other: Interval) -&gt; bool: 
            return self.contains(other.start) | self.contains(other.end) 
 
 
Above, the ``length`` property returns the difference between the 
``end`` and ``start`` attributes.  With an instance of ``Interval``, 
this subtraction occurs in Python, using normal Python descriptor 
mechanics:: 
 
    &gt;&gt;&gt; i1 = Interval(5, 10) 
    &gt;&gt;&gt; i1.length 
    5 
 
When dealing with the ``Interval`` class itself, the :class:`.hybrid_property` 
descriptor evaluates the function body given the ``Interval`` class as 
the argument, which when evaluated with SQLAlchemy expression mechanics 
returns a new SQL expression: 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; from sqlalchemy import select 
    &gt;&gt;&gt; print(select(Interval.length)) 
    {printsql}SELECT interval.&quot;end&quot; - interval.start AS length 
    FROM interval{stop} 
 
 
    &gt;&gt;&gt; print(select(Interval).filter(Interval.length &gt; 10)) 
    {printsql}SELECT interval.id, interval.start, interval.&quot;end&quot; 
    FROM interval 
    WHERE interval.&quot;end&quot; - interval.start &gt; :param_1 
 
Filtering methods such as :meth:`.Select.filter_by` are supported 
with hybrid attributes as well: 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; print(select(Interval).filter_by(length=5)) 
    {printsql}SELECT interval.id, interval.start, interval.&quot;end&quot; 
    FROM interval 
    WHERE interval.&quot;end&quot; - interval.start = :param_1 
 
The ``Interval`` class example also illustrates two methods, 
``contains()`` and ``intersects()``, decorated with 
:class:`.hybrid_method`. This decorator applies the same idea to 
methods that :class:`.hybrid_property` applies to attributes.   The 
methods return boolean values, and take advantage of the Python ``|`` 
and ``&amp;`` bitwise operators to produce equivalent instance-level and 
SQL expression-level boolean behavior: 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; i1.contains(6) 
    True 
    &gt;&gt;&gt; i1.contains(15) 
    False 
    &gt;&gt;&gt; i1.intersects(Interval(7, 18)) 
    True 
    &gt;&gt;&gt; i1.intersects(Interval(25, 29)) 
    False 
 
    &gt;&gt;&gt; print(select(Interval).filter(Interval.contains(15))) 
    {printsql}SELECT interval.id, interval.start, interval.&quot;end&quot; 
    FROM interval 
    WHERE interval.start &lt;= :start_1 AND interval.&quot;end&quot; &gt; :end_1{stop} 
 
    &gt;&gt;&gt; ia = aliased(Interval) 
    &gt;&gt;&gt; print(select(Interval, ia).filter(Interval.intersects(ia))) 
    {printsql}SELECT interval.id, interval.start, 
    interval.&quot;end&quot;, interval_1.id AS interval_1_id, 
    interval_1.start AS interval_1_start, interval_1.&quot;end&quot; AS interval_1_end 
    FROM interval, interval AS interval_1 
    WHERE interval.start &lt;= interval_1.start 
        AND interval.&quot;end&quot; &gt; interval_1.start 
        OR interval.start &lt;= interval_1.&quot;end&quot; 
        AND interval.&quot;end&quot; &gt; interval_1.&quot;end&quot;{stop} 
 
.. _hybrid_distinct_expression: 
 
Defining Expression Behavior Distinct from Attribute Behavior 
-------------------------------------------------------------- 
 
In the previous section, our usage of the ``&amp;`` and ``|`` bitwise operators 
within the ``Interval.contains`` and ``Interval.intersects`` methods was 
fortunate, considering our functions operated on two boolean values to return a 
new one. In many cases, the construction of an in-Python function and a 
SQLAlchemy SQL expression have enough differences that two separate Python 
expressions should be defined. The :mod:`~sqlalchemy.ext.hybrid` decorator 
defines a **modifier** :meth:`.hybrid_property.expression` for this purpose. As an 
example we'll define the radius of the interval, which requires the usage of 
the absolute value function:: 
 
    from sqlalchemy import ColumnElement 
    from sqlalchemy import Float 
    from sqlalchemy import func 
    from sqlalchemy import type_coerce 
 
    class Interval(Base): 
        # ... 
 
        @hybrid_property 
        def radius(self) -&gt; float: 
            return abs(self.length) / 2 
 
        @radius.inplace.expression 
        @classmethod 
        def _radius_expression(cls) -&gt; ColumnElement[float]: 
            return type_coerce(func.abs(cls.length) / 2, Float) 
 
In the above example, the :class:`.hybrid_property` first assigned to the 
name ``Interval.radius`` is amended by a subsequent method called 
``Interval._radius_expression``, using the decorator 
``@radius.inplace.expression``, which chains together two modifiers 
:attr:`.hybrid_property.inplace` and :attr:`.hybrid_property.expression`. 
The use of :attr:`.hybrid_property.inplace` indicates that the 
:meth:`.hybrid_property.expression` modifier should mutate the 
existing hybrid object at ``Interval.radius`` in place, without creating a 
new object.   Notes on this modifier and its 
rationale are discussed in the next section :ref:`hybrid_pep484_naming`. 
The use of ``@classmethod`` is optional, and is strictly to give typing 
tools a hint that ``cls`` in this case is expected to be the ``Interval`` 
class, and not an instance of ``Interval``. 
 
.. note:: :attr:`.hybrid_property.inplace` as well as the use of ``@classmethod`` 
   for proper typing support are available as of SQLAlchemy 2.0.4, and will 
   not work in earlier versions. 
 
With ``Interval.radius`` now including an expression element, the SQL 
function ``ABS()`` is returned when accessing ``Interval.radius`` 
at the class level: 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; from sqlalchemy import select 
    &gt;&gt;&gt; print(select(Interval).filter(Interval.radius &gt; 5)) 
    {printsql}SELECT interval.id, interval.start, interval.&quot;end&quot; 
    FROM interval 
    WHERE abs(interval.&quot;end&quot; - interval.start) / :abs_1 &gt; :param_1 
 
 
.. _hybrid_pep484_naming: 
 
Using ``inplace`` to create pep-484 compliant hybrid properties 
--------------------------------------------------------------- 
 
In the previous section, a :class:`.hybrid_property` decorator is illustrated 
which includes two separate method-level functions being decorated, both 
to produce a single object attribute referenced as ``Interval.radius``. 
There are actually several different modifiers we can use for 
:class:`.hybrid_property` including :meth:`.hybrid_property.expression`, 
:meth:`.hybrid_property.setter` and :meth:`.hybrid_property.update_expression`. 
 
SQLAlchemy's :class:`.hybrid_property` decorator intends that adding on these 
methods may be done in the identical manner as Python's built-in 
``@property`` decorator, where idiomatic use is to continue to redefine the 
attribute repeatedly, using the **same attribute name** each time, as in the 
example below that illustrates the use of :meth:`.hybrid_property.setter` and 
:meth:`.hybrid_property.expression` for the ``Interval.radius`` descriptor:: 
 
    # correct use, however is not accepted by pep-484 tooling 
 
    class Interval(Base): 
        # ... 
 
        @hybrid_property 
        def radius(self): 
            return abs(self.length) / 2 
 
        @radius.setter 
        def radius(self, value): 
            self.length = value * 2 
 
        @radius.expression 
        def radius(cls): 
            return type_coerce(func.abs(cls.length) / 2, Float) 
 
Above, there are three ``Interval.radius`` methods, but as each are decorated, 
first by the :class:`.hybrid_property` decorator and then by the 
``@radius`` name itself, the end effect is that ``Interval.radius`` is 
a single attribute with three different functions contained within it. 
This style of use is taken from `Python's documented use of @property 
&lt;https://docs.python.org/3/library/functions.html#property&gt;`_. 
It is important to note that the way both ``@property`` as well as 
:class:`.hybrid_property` work, a **copy of the descriptor is made each time**. 
That is, each call to ``@radius.expression``, ``@radius.setter`` etc. 
make a new object entirely.  This allows the attribute to be re-defined in 
subclasses without issue (see :ref:`hybrid_reuse_subclass` later in this 
section for how this is used). 
 
However, the above approach is not compatible with typing tools such as 
mypy and pyright.  Python's own ``@property`` decorator does not have this 
limitation only because 
`these tools hardcode the behavior of @property 
&lt;https://github.com/python/typing/discussions/1102&gt;`_, meaning this syntax 
is not available to SQLAlchemy under :pep:`484` compliance. 
 
In order to produce a reasonable syntax while remaining typing compliant, 
the :attr:`.hybrid_property.inplace` decorator allows the same 
decorator to be re-used with different method names, while still producing 
a single decorator under one name:: 
 
    # correct use which is also accepted by pep-484 tooling 
 
    class Interval(Base): 
        # ... 
 
        @hybrid_property 
        def radius(self) -&gt; float: 
            return abs(self.length) / 2 
 
        @radius.inplace.setter 
        def _radius_setter(self, value: float) -&gt; None: 
            # for example only 
            self.length = value * 2 
 
        @radius.inplace.expression 
        @classmethod 
        def _radius_expression(cls) -&gt; ColumnElement[float]: 
            return type_coerce(func.abs(cls.length) / 2, Float) 
 
Using :attr:`.hybrid_property.inplace` further qualifies the use of the 
decorator that a new copy should not be made, thereby maintaining the 
``Interval.radius`` name while allowing additional methods 
``Interval._radius_setter`` and ``Interval._radius_expression`` to be 
differently named. 
 
 
.. versionadded:: 2.0.4 Added :attr:`.hybrid_property.inplace` to allow 
   less verbose construction of composite :class:`.hybrid_property` objects 
   while not having to use repeated method names.   Additionally allowed the 
   use of ``@classmethod`` within :attr:`.hybrid_property.expression`, 
   :attr:`.hybrid_property.update_expression`, and 
   :attr:`.hybrid_property.comparator` to allow typing tools to identify 
   ``cls`` as a class and not an instance in the method signature. 
 
 
Defining Setters 
---------------- 
 
The :meth:`.hybrid_property.setter` modifier allows the construction of a 
custom setter method, that can modify values on the object:: 
 
    class Interval(Base): 
        # ... 
 
        @hybrid_property 
        def length(self) -&gt; int: 
            return self.end - self.start 
 
        @length.inplace.setter 
        def _length_setter(self, value: int) -&gt; None: 
            self.end = self.start + value 
 
The ``length(self, value)`` method is now called upon set:: 
 
    &gt;&gt;&gt; i1 = Interval(5, 10) 
    &gt;&gt;&gt; i1.length 
    5 
    &gt;&gt;&gt; i1.length = 12 
    &gt;&gt;&gt; i1.end 
    17 
 
.. _hybrid_bulk_update: 
 
Allowing Bulk ORM Update 
------------------------ 
 
A hybrid can define a custom &quot;UPDATE&quot; handler for when using 
ORM-enabled updates, allowing the hybrid to be used in the 
SET clause of the update. 
 
Normally, when using a hybrid with :func:`_sql.update`, the SQL 
expression is used as the column that's the target of the SET.  If our 
``Interval`` class had a hybrid ``start_point`` that linked to 
``Interval.start``, this could be substituted directly:: 
 
    from sqlalchemy import update 
    stmt = update(Interval).values({Interval.start_point: 10}) 
 
However, when using a composite hybrid like ``Interval.length``, this 
hybrid represents more than one column.   We can set up a handler that will 
accommodate a value passed in the VALUES expression which can affect 
this, using the :meth:`.hybrid_property.update_expression` decorator. 
A handler that works similarly to our setter would be:: 
 
    from typing import List, Tuple, Any 
 
    class Interval(Base): 
        # ... 
 
        @hybrid_property 
        def length(self) -&gt; int: 
            return self.end - self.start 
 
        @length.inplace.setter 
        def _length_setter(self, value: int) -&gt; None: 
            self.end = self.start + value 
 
        @length.inplace.update_expression 
        def _length_update_expression(cls, value: Any) -&gt; List[Tuple[Any, Any]]: 
            return [ 
                (cls.end, cls.start + value) 
            ] 
 
Above, if we use ``Interval.length`` in an UPDATE expression, we get 
a hybrid SET expression: 
 
.. sourcecode:: pycon+sql 
 
 
    &gt;&gt;&gt; from sqlalchemy import update 
    &gt;&gt;&gt; print(update(Interval).values({Interval.length: 25})) 
    {printsql}UPDATE interval SET &quot;end&quot;=(interval.start + :start_1) 
 
This SET expression is accommodated by the ORM automatically. 
 
.. seealso:: 
 
    :ref:`orm_expression_update_delete` - includes background on ORM-enabled 
    UPDATE statements 
 
 
Working with Relationships 
-------------------------- 
 
There's no essential difference when creating hybrids that work with 
related objects as opposed to column-based data. The need for distinct 
expressions tends to be greater.  The two variants we'll illustrate 
are the &quot;join-dependent&quot; hybrid, and the &quot;correlated subquery&quot; hybrid. 
 
Join-Dependent Relationship Hybrid 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
 
Consider the following declarative 
mapping which relates a ``User`` to a ``SavingsAccount``:: 
 
    from __future__ import annotations 
 
    from decimal import Decimal 
    from typing import cast 
    from typing import List 
    from typing import Optional 
 
    from sqlalchemy import ForeignKey 
    from sqlalchemy import Numeric 
    from sqlalchemy import String 
    from sqlalchemy import SQLColumnExpression 
    from sqlalchemy.ext.hybrid import hybrid_property 
    from sqlalchemy.orm import DeclarativeBase 
    from sqlalchemy.orm import Mapped 
    from sqlalchemy.orm import mapped_column 
    from sqlalchemy.orm import relationship 
 
 
    class Base(DeclarativeBase): 
        pass 
 
 
    class SavingsAccount(Base): 
        __tablename__ = 'account' 
        id: Mapped[int] = mapped_column(primary_key=True) 
        user_id: Mapped[int] = mapped_column(ForeignKey('user.id')) 
        balance: Mapped[Decimal] = mapped_column(Numeric(15, 5)) 
 
        owner: Mapped[User] = relationship(back_populates=&quot;accounts&quot;) 
 
    class User(Base): 
        __tablename__ = 'user' 
        id: Mapped[int] = mapped_column(primary_key=True) 
        name: Mapped[str] = mapped_column(String(100)) 
 
        accounts: Mapped[List[SavingsAccount]] = relationship( 
            back_populates=&quot;owner&quot;, lazy=&quot;selectin&quot; 
        ) 
 
        @hybrid_property 
        def balance(self) -&gt; Optional[Decimal]: 
            if self.accounts: 
                return self.accounts[0].balance 
            else: 
                return None 
 
        @balance.inplace.setter 
        def _balance_setter(self, value: Optional[Decimal]) -&gt; None: 
            assert value is not None 
 
            if not self.accounts: 
                account = SavingsAccount(owner=self) 
            else: 
                account = self.accounts[0] 
            account.balance = value 
 
        @balance.inplace.expression 
        @classmethod 
        def _balance_expression(cls) -&gt; SQLColumnExpression[Optional[Decimal]]: 
            return cast(&quot;SQLColumnExpression[Optional[Decimal]]&quot;, SavingsAccount.balance) 
 
The above hybrid property ``balance`` works with the first 
``SavingsAccount`` entry in the list of accounts for this user.   The 
in-Python getter/setter methods can treat ``accounts`` as a Python 
list available on ``self``. 
 
.. tip:: The ``User.balance`` getter in the above example accesses the 
   ``self.acccounts`` collection, which will normally be loaded via the 
   :func:`.selectinload` loader strategy configured on the ``User.balance`` 
   :func:`_orm.relationship`. The default loader strategy when not otherwise 
   stated on :func:`_orm.relationship` is :func:`.lazyload`, which emits SQL on 
   demand. When using asyncio, on-demand loaders such as :func:`.lazyload` are 
   not supported, so care should be taken to ensure the ``self.accounts`` 
   collection is accessible to this hybrid accessor when using asyncio. 
 
At the expression level, it's expected that the ``User`` class will 
be used in an appropriate context such that an appropriate join to 
``SavingsAccount`` will be present: 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; from sqlalchemy import select 
    &gt;&gt;&gt; print(select(User, User.balance). 
    ...       join(User.accounts).filter(User.balance &gt; 5000)) 
    {printsql}SELECT &quot;user&quot;.id AS user_id, &quot;user&quot;.name AS user_name, 
    account.balance AS account_balance 
    FROM &quot;user&quot; JOIN account ON &quot;user&quot;.id = account.user_id 
    WHERE account.balance &gt; :balance_1 
 
Note however, that while the instance level accessors need to worry 
about whether ``self.accounts`` is even present, this issue expresses 
itself differently at the SQL expression level, where we basically 
would use an outer join: 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; from sqlalchemy import select 
    &gt;&gt;&gt; from sqlalchemy import or_ 
    &gt;&gt;&gt; print (select(User, User.balance).outerjoin(User.accounts). 
    ...         filter(or_(User.balance &lt; 5000, User.balance == None))) 
    {printsql}SELECT &quot;user&quot;.id AS user_id, &quot;user&quot;.name AS user_name, 
    account.balance AS account_balance 
    FROM &quot;user&quot; LEFT OUTER JOIN account ON &quot;user&quot;.id = account.user_id 
    WHERE account.balance &lt;  :balance_1 OR account.balance IS NULL 
 
Correlated Subquery Relationship Hybrid 
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
 
We can, of course, forego being dependent on the enclosing query's usage 
of joins in favor of the correlated subquery, which can portably be packed 
into a single column expression. A correlated subquery is more portable, but 
often performs more poorly at the SQL level. Using the same technique 
illustrated at :ref:`mapper_column_property_sql_expressions`, 
we can adjust our ``SavingsAccount`` example to aggregate the balances for 
*all* accounts, and use a correlated subquery for the column expression:: 
 
    from __future__ import annotations 
 
    from decimal import Decimal 
    from typing import List 
 
    from sqlalchemy import ForeignKey 
    from sqlalchemy import func 
    from sqlalchemy import Numeric 
    from sqlalchemy import select 
    from sqlalchemy import SQLColumnExpression 
    from sqlalchemy import String 
    from sqlalchemy.ext.hybrid import hybrid_property 
    from sqlalchemy.orm import DeclarativeBase 
    from sqlalchemy.orm import Mapped 
    from sqlalchemy.orm import mapped_column 
    from sqlalchemy.orm import relationship 
 
 
    class Base(DeclarativeBase): 
        pass 
 
 
    class SavingsAccount(Base): 
        __tablename__ = 'account' 
        id: Mapped[int] = mapped_column(primary_key=True) 
        user_id: Mapped[int] = mapped_column(ForeignKey('user.id')) 
        balance: Mapped[Decimal] = mapped_column(Numeric(15, 5)) 
 
        owner: Mapped[User] = relationship(back_populates=&quot;accounts&quot;) 
 
    class User(Base): 
        __tablename__ = 'user' 
        id: Mapped[int] = mapped_column(primary_key=True) 
        name: Mapped[str] = mapped_column(String(100)) 
 
        accounts: Mapped[List[SavingsAccount]] = relationship( 
            back_populates=&quot;owner&quot;, lazy=&quot;selectin&quot; 
        ) 
 
        @hybrid_property 
        def balance(self) -&gt; Decimal: 
            return sum((acc.balance for acc in self.accounts), start=Decimal(&quot;0&quot;)) 
 
        @balance.inplace.expression 
        @classmethod 
        def _balance_expression(cls) -&gt; SQLColumnExpression[Decimal]: 
            return ( 
                select(func.sum(SavingsAccount.balance)) 
                .where(SavingsAccount.user_id == cls.id) 
                .label(&quot;total_balance&quot;) 
            ) 
 
 
The above recipe will give us the ``balance`` column which renders 
a correlated SELECT: 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; from sqlalchemy import select 
    &gt;&gt;&gt; print(select(User).filter(User.balance &gt; 400)) 
    {printsql}SELECT &quot;user&quot;.id, &quot;user&quot;.name 
    FROM &quot;user&quot; 
    WHERE ( 
        SELECT sum(account.balance) AS sum_1 FROM account 
        WHERE account.user_id = &quot;user&quot;.id 
    ) &gt; :param_1 
 
 
.. _hybrid_custom_comparators: 
 
Building Custom Comparators 
--------------------------- 
 
The hybrid property also includes a helper that allows construction of 
custom comparators. A comparator object allows one to customize the 
behavior of each SQLAlchemy expression operator individually.  They 
are useful when creating custom types that have some highly 
idiosyncratic behavior on the SQL side. 
 
.. note::  The :meth:`.hybrid_property.comparator` decorator introduced 
   in this section **replaces** the use of the 
   :meth:`.hybrid_property.expression` decorator. 
   They cannot be used together. 
 
The example class below allows case-insensitive comparisons on the attribute 
named ``word_insensitive``:: 
 
    from __future__ import annotations 
 
    from typing import Any 
 
    from sqlalchemy import ColumnElement 
    from sqlalchemy import func 
    from sqlalchemy.ext.hybrid import Comparator 
    from sqlalchemy.ext.hybrid import hybrid_property 
    from sqlalchemy.orm import DeclarativeBase 
    from sqlalchemy.orm import Mapped 
    from sqlalchemy.orm import mapped_column 
 
    class Base(DeclarativeBase): 
        pass 
 
 
    class CaseInsensitiveComparator(Comparator[str]): 
        def __eq__(self, other: Any) -&gt; ColumnElement[bool]:  # type: ignore[override]  # noqa: E501 
            return func.lower(self.__clause_element__()) == func.lower(other) 
 
    class SearchWord(Base): 
        __tablename__ = 'searchword' 
 
        id: Mapped[int] = mapped_column(primary_key=True) 
        word: Mapped[str] 
 
        @hybrid_property 
        def word_insensitive(self) -&gt; str: 
            return self.word.lower() 
 
        @word_insensitive.inplace.comparator 
        @classmethod 
        def _word_insensitive_comparator(cls) -&gt; CaseInsensitiveComparator: 
            return CaseInsensitiveComparator(cls.word) 
 
Above, SQL expressions against ``word_insensitive`` will apply the ``LOWER()`` 
SQL function to both sides: 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; from sqlalchemy import select 
    &gt;&gt;&gt; print(select(SearchWord).filter_by(word_insensitive=&quot;Trucks&quot;)) 
    {printsql}SELECT searchword.id, searchword.word 
    FROM searchword 
    WHERE lower(searchword.word) = lower(:lower_1) 
 
 
The ``CaseInsensitiveComparator`` above implements part of the 
:class:`.ColumnOperators` interface.   A &quot;coercion&quot; operation like 
lowercasing can be applied to all comparison operations (i.e. ``eq``, 
``lt``, ``gt``, etc.) using :meth:`.Operators.operate`:: 
 
    class CaseInsensitiveComparator(Comparator): 
        def operate(self, op, other, **kwargs): 
            return op( 
                func.lower(self.__clause_element__()), 
                func.lower(other), 
                **kwargs, 
            ) 
 
.. _hybrid_reuse_subclass: 
 
Reusing Hybrid Properties across Subclasses 
------------------------------------------- 
 
A hybrid can be referred to from a superclass, to allow modifying 
methods like :meth:`.hybrid_property.getter`, :meth:`.hybrid_property.setter` 
to be used to redefine those methods on a subclass.  This is similar to 
how the standard Python ``@property`` object works:: 
 
    class FirstNameOnly(Base): 
        # ... 
 
        first_name: Mapped[str] 
 
        @hybrid_property 
        def name(self) -&gt; str: 
            return self.first_name 
 
        @name.inplace.setter 
        def _name_setter(self, value: str) -&gt; None: 
            self.first_name = value 
 
    class FirstNameLastName(FirstNameOnly): 
        # ... 
 
        last_name: Mapped[str] 
 
        # 'inplace' is not used here; calling getter creates a copy 
        # of FirstNameOnly.name that is local to FirstNameLastName 
        @FirstNameOnly.name.getter 
        def name(self) -&gt; str: 
            return self.first_name + ' ' + self.last_name 
 
        @name.inplace.setter 
        def _name_setter(self, value: str) -&gt; None: 
            self.first_name, self.last_name = value.split(' ', 1) 
 
Above, the ``FirstNameLastName`` class refers to the hybrid from 
``FirstNameOnly.name`` to repurpose its getter and setter for the subclass. 
 
When overriding :meth:`.hybrid_property.expression` and 
:meth:`.hybrid_property.comparator` alone as the first reference to the 
superclass, these names conflict with the same-named accessors on the class- 
level :class:`.QueryableAttribute` object returned at the class level.  To 
override these methods when referring directly to the parent class descriptor, 
add the special qualifier :attr:`.hybrid_property.overrides`, which will de- 
reference the instrumented attribute back to the hybrid object:: 
 
    class FirstNameLastName(FirstNameOnly): 
        # ... 
 
        last_name: Mapped[str] 
 
        @FirstNameOnly.name.overrides.expression 
        @classmethod 
        def name(cls): 
            return func.concat(cls.first_name, ' ', cls.last_name) 
 
 
Hybrid Value Objects 
-------------------- 
 
Note in our previous example, if we were to compare the ``word_insensitive`` 
attribute of a ``SearchWord`` instance to a plain Python string, the plain 
Python string would not be coerced to lower case - the 
``CaseInsensitiveComparator`` we built, being returned by 
``@word_insensitive.comparator``, only applies to the SQL side. 
 
A more comprehensive form of the custom comparator is to construct a *Hybrid 
Value Object*. This technique applies the target value or expression to a value 
object which is then returned by the accessor in all cases.   The value object 
allows control of all operations upon the value as well as how compared values 
are treated, both on the SQL expression side as well as the Python value side. 
Replacing the previous ``CaseInsensitiveComparator`` class with a new 
``CaseInsensitiveWord`` class:: 
 
    class CaseInsensitiveWord(Comparator): 
        &quot;Hybrid value representing a lower case representation of a word.&quot; 
 
        def __init__(self, word): 
            if isinstance(word, basestring): 
                self.word = word.lower() 
            elif isinstance(word, CaseInsensitiveWord): 
                self.word = word.word 
            else: 
                self.word = func.lower(word) 
 
        def operate(self, op, other, **kwargs): 
            if not isinstance(other, CaseInsensitiveWord): 
                other = CaseInsensitiveWord(other) 
            return op(self.word, other.word, **kwargs) 
 
        def __clause_element__(self): 
            return self.word 
 
        def __str__(self): 
            return self.word 
 
        key = 'word' 
        &quot;Label to apply to Query tuple results&quot; 
 
Above, the ``CaseInsensitiveWord`` object represents ``self.word``, which may 
be a SQL function, or may be a Python native.   By overriding ``operate()`` and 
``__clause_element__()`` to work in terms of ``self.word``, all comparison 
operations will work against the &quot;converted&quot; form of ``word``, whether it be 
SQL side or Python side. Our ``SearchWord`` class can now deliver the 
``CaseInsensitiveWord`` object unconditionally from a single hybrid call:: 
 
    class SearchWord(Base): 
        __tablename__ = 'searchword' 
        id: Mapped[int] = mapped_column(primary_key=True) 
        word: Mapped[str] 
 
        @hybrid_property 
        def word_insensitive(self) -&gt; CaseInsensitiveWord: 
            return CaseInsensitiveWord(self.word) 
 
The ``word_insensitive`` attribute now has case-insensitive comparison behavior 
universally, including SQL expression vs. Python expression (note the Python 
value is converted to lower case on the Python side here): 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; print(select(SearchWord).filter_by(word_insensitive=&quot;Trucks&quot;)) 
    {printsql}SELECT searchword.id AS searchword_id, searchword.word AS searchword_word 
    FROM searchword 
    WHERE lower(searchword.word) = :lower_1 
 
SQL expression versus SQL expression: 
 
.. sourcecode:: pycon+sql 
 
    &gt;&gt;&gt; from sqlalchemy.orm import aliased 
    &gt;&gt;&gt; sw1 = aliased(SearchWord) 
    &gt;&gt;&gt; sw2 = aliased(SearchWord) 
    &gt;&gt;&gt; print( 
    ...     select(sw1.word_insensitive, sw2.word_insensitive).filter( 
    ...         sw1.word_insensitive &gt; sw2.word_insensitive 
    ...     ) 
    ... ) 
    {printsql}SELECT lower(searchword_1.word) AS lower_1, 
    lower(searchword_2.word) AS lower_2 
    FROM searchword AS searchword_1, searchword AS searchword_2 
    WHERE lower(searchword_1.word) &gt; lower(searchword_2.word) 
 
Python only expression:: 
 
    &gt;&gt;&gt; ws1 = SearchWord(word=&quot;SomeWord&quot;) 
    &gt;&gt;&gt; ws1.word_insensitive == &quot;sOmEwOrD&quot; 
    True 
    &gt;&gt;&gt; ws1.word_insensitive == &quot;XOmEwOrX&quot; 
    False 
    &gt;&gt;&gt; print(ws1.word_insensitive) 
    someword 
 
The Hybrid Value pattern is very useful for any kind of value that may have 
multiple representations, such as timestamps, time deltas, units of 
measurement, currencies and encrypted passwords. 
 
.. seealso:: 
 
    `Hybrids and Value Agnostic Types 
    &lt;https://techspot.zzzeek.org/2011/10/21/hybrids-and-value-agnostic-types/&gt;`_ 
    - on the techspot.zzzeek.org blog 
 
    `Value Agnostic Types, Part II 
    &lt;https://techspot.zzzeek.org/2011/10/29/value-agnostic-types-part-ii/&gt;`_ - 
    on the techspot.zzzeek.org blog 
 
 
&quot;&quot;&quot;  </span><span class="s0"># noqa</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Generic</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">overload</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Sequence</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Tuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Type</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TypeVar</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>

<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">orm </span><span class="s3">import </span><span class="s1">attributes</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">orm </span><span class="s3">import </span><span class="s1">InspectionAttrExtensionType</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">orm </span><span class="s3">import </span><span class="s1">interfaces</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">orm </span><span class="s3">import </span><span class="s1">ORMDescriptor</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">orm</span><span class="s4">.</span><span class="s1">attributes </span><span class="s3">import </span><span class="s1">QueryableAttribute</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">roles</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">is_has_clause_element</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">ColumnElement</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">SQLCoreOperations</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Concatenate</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Literal</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">ParamSpec</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Protocol</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Self</span>

<span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">orm</span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">MapperProperty</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">orm</span><span class="s4">.</span><span class="s1">util </span><span class="s3">import </span><span class="s1">AliasedInsp</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">SQLColumnExpression</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_ColumnExpressionArgument</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_DMLColumnArgument</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_HasClauseElement</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_InfoType</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">operators </span><span class="s3">import </span><span class="s1">OperatorType</span>

<span class="s1">_P </span><span class="s4">= </span><span class="s1">ParamSpec</span><span class="s4">(</span><span class="s2">&quot;_P&quot;</span><span class="s4">)</span>
<span class="s1">_R </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s2">&quot;_R&quot;</span><span class="s4">)</span>
<span class="s1">_T </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s2">&quot;_T&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s1">Any</span><span class="s4">)</span>
<span class="s1">_TE </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s2">&quot;_TE&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s1">Any</span><span class="s4">)</span>
<span class="s1">_T_co </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s2">&quot;_T_co&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">covariant</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
<span class="s1">_T_con </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s2">&quot;_T_con&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">contravariant</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">HybridExtensionType</span><span class="s4">(</span><span class="s1">InspectionAttrExtensionType</span><span class="s4">):</span>
    <span class="s1">HYBRID_METHOD </span><span class="s4">= </span><span class="s2">&quot;HYBRID_METHOD&quot;</span>
    <span class="s2">&quot;&quot;&quot;Symbol indicating an :class:`InspectionAttr` that's 
    of type :class:`.hybrid_method`. 
 
    Is assigned to the :attr:`.InspectionAttr.extension_type` 
    attribute. 
 
    .. seealso:: 
 
        :attr:`_orm.Mapper.all_orm_attributes` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">HYBRID_PROPERTY </span><span class="s4">= </span><span class="s2">&quot;HYBRID_PROPERTY&quot;</span>
    <span class="s2">&quot;&quot;&quot;Symbol indicating an :class:`InspectionAttr` that's 
        of type :class:`.hybrid_method`. 
 
    Is assigned to the :attr:`.InspectionAttr.extension_type` 
    attribute. 
 
    .. seealso:: 
 
        :attr:`_orm.Mapper.all_orm_attributes` 
 
    &quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">_HybridGetterType</span><span class="s4">(</span><span class="s1">Protocol</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]):</span>
    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span><span class="s1">s</span><span class="s4">, </span><span class="s1">self</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; _T_co</span><span class="s4">: ...</span>


<span class="s3">class </span><span class="s1">_HybridSetterType</span><span class="s4">(</span><span class="s1">Protocol</span><span class="s4">[</span><span class="s1">_T_con</span><span class="s4">]):</span>
    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span><span class="s1">s</span><span class="s4">, </span><span class="s1">self</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">_T_con</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">: ...</span>


<span class="s3">class </span><span class="s1">_HybridUpdaterType</span><span class="s4">(</span><span class="s1">Protocol</span><span class="s4">[</span><span class="s1">_T_con</span><span class="s4">]):</span>
    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span>
        <span class="s1">s</span><span class="s4">,</span>
        <span class="s1">cls</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s1">value</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">_T_con</span><span class="s4">, </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">_T_con</span><span class="s4">]],</span>
    <span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_DMLColumnArgument</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]]: ...</span>


<span class="s3">class </span><span class="s1">_HybridDeleterType</span><span class="s4">(</span><span class="s1">Protocol</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]):</span>
    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span><span class="s1">s</span><span class="s4">, </span><span class="s1">self</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">: ...</span>


<span class="s3">class </span><span class="s1">_HybridExprCallableType</span><span class="s4">(</span><span class="s1">Protocol</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]):</span>
    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span>
        <span class="s1">s</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">_HasClauseElement</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">], </span><span class="s1">SQLColumnExpression</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]]: ...</span>


<span class="s3">class </span><span class="s1">_HybridComparatorCallableType</span><span class="s4">(</span><span class="s1">Protocol</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Comparator</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]: ...</span>


<span class="s3">class </span><span class="s1">_HybridClassLevelAccessor</span><span class="s4">(</span><span class="s1">QueryableAttribute</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s5">&quot;&quot;&quot;Describe the object returned by a hybrid_property() when 
    called as a class-level descriptor. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s3">def </span><span class="s1">getter</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">fget</span><span class="s4">: </span><span class="s1">_HybridGetterType</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
        <span class="s4">) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">setter</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">fset</span><span class="s4">: </span><span class="s1">_HybridSetterType</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
        <span class="s4">) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">deleter</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">fdel</span><span class="s4">: </span><span class="s1">_HybridDeleterType</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
        <span class="s4">) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">property</span>
        <span class="s3">def </span><span class="s1">overrides</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">update_expression</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">meth</span><span class="s4">: </span><span class="s1">_HybridUpdaterType</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
        <span class="s4">) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]: ...</span>


<span class="s3">class </span><span class="s1">hybrid_method</span><span class="s4">(</span><span class="s1">interfaces</span><span class="s4">.</span><span class="s1">InspectionAttrInfo</span><span class="s4">, </span><span class="s1">Generic</span><span class="s4">[</span><span class="s1">_P</span><span class="s4">, </span><span class="s1">_R</span><span class="s4">]):</span>
    <span class="s5">&quot;&quot;&quot;A decorator which allows definition of a Python object method with both 
    instance-level and class-level behavior. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">is_attribute </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">extension_type </span><span class="s4">= </span><span class="s1">HybridExtensionType</span><span class="s4">.</span><span class="s1">HYBRID_METHOD</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">func</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[</span><span class="s1">Concatenate</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">_P</span><span class="s4">], </span><span class="s1">_R</span><span class="s4">],</span>
        <span class="s1">expr</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span>
            <span class="s1">Callable</span><span class="s4">[</span><span class="s1">Concatenate</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">_P</span><span class="s4">], </span><span class="s1">SQLCoreOperations</span><span class="s4">[</span><span class="s1">_R</span><span class="s4">]]</span>
        <span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot;Create a new :class:`.hybrid_method`. 
 
        Usage is typically via decorator:: 
 
            from sqlalchemy.ext.hybrid import hybrid_method 
 
            class SomeClass: 
                @hybrid_method 
                def value(self, x, y): 
                    return self._value + x + y 
 
                @value.expression 
                @classmethod 
                def value(cls, x, y): 
                    return func.some_function(cls._value, x, y) 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">func </span><span class="s4">= </span><span class="s1">func</span>
        <span class="s3">if </span><span class="s1">expr </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">expression</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">expression</span><span class="s4">(</span><span class="s1">func</span><span class="s4">)  </span><span class="s0"># type: ignore</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">inplace</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s5">&quot;&quot;&quot;Return the inplace mutator for this :class:`.hybrid_method`. 
 
        The :class:`.hybrid_method` class already performs &quot;in place&quot; mutation 
        when the :meth:`.hybrid_method.expression` decorator is called, 
        so this attribute returns Self. 
 
        .. versionadded:: 2.0.4 
 
        .. seealso:: 
 
            :ref:`hybrid_pep484_naming` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">None</span><span class="s4">], </span><span class="s1">owner</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">object</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">[</span><span class="s1">_P</span><span class="s4">, </span><span class="s1">SQLCoreOperations</span><span class="s4">[</span><span class="s1">_R</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">object</span><span class="s4">, </span><span class="s1">owner</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">object</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">[</span><span class="s1">_P</span><span class="s4">, </span><span class="s1">_R</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">object</span><span class="s4">], </span><span class="s1">owner</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">object</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">Callable</span><span class="s4">[</span><span class="s1">_P</span><span class="s4">, </span><span class="s1">_R</span><span class="s4">], </span><span class="s1">Callable</span><span class="s4">[</span><span class="s1">_P</span><span class="s4">, </span><span class="s1">SQLCoreOperations</span><span class="s4">[</span><span class="s1">_R</span><span class="s4">]]]:</span>
        <span class="s3">if </span><span class="s1">instance </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span><span class="s4">.</span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">owner</span><span class="s4">, </span><span class="s1">owner</span><span class="s4">)  </span><span class="s0"># type: ignore</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">, </span><span class="s1">owner</span><span class="s4">)  </span><span class="s0"># type: ignore</span>

    <span class="s3">def </span><span class="s1">expression</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">expr</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[</span><span class="s1">Concatenate</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">_P</span><span class="s4">], </span><span class="s1">SQLCoreOperations</span><span class="s4">[</span><span class="s1">_R</span><span class="s4">]]</span>
    <span class="s4">) </span><span class="s1">-&gt; hybrid_method</span><span class="s4">[</span><span class="s1">_P</span><span class="s4">, </span><span class="s1">_R</span><span class="s4">]:</span>
        <span class="s5">&quot;&quot;&quot;Provide a modifying decorator that defines a 
        SQL-expression producing method.&quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">expr </span><span class="s4">= </span><span class="s1">expr</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span><span class="s4">.</span><span class="s1">__doc__</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span><span class="s4">.</span><span class="s1">__doc__ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">__doc__</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">def </span><span class="s1">_unwrap_classmethod</span><span class="s4">(</span><span class="s1">meth</span><span class="s4">: </span><span class="s1">_T</span><span class="s4">) </span><span class="s1">-&gt; _T</span><span class="s4">:</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">meth</span><span class="s4">, </span><span class="s1">classmethod</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">meth</span><span class="s4">.</span><span class="s1">__func__  </span><span class="s0"># type: ignore</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">meth</span>


<span class="s3">class </span><span class="s1">hybrid_property</span><span class="s4">(</span><span class="s1">interfaces</span><span class="s4">.</span><span class="s1">InspectionAttrInfo</span><span class="s4">, </span><span class="s1">ORMDescriptor</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s5">&quot;&quot;&quot;A decorator which allows definition of a Python descriptor with both 
    instance-level and class-level behavior. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">is_attribute </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">extension_type </span><span class="s4">= </span><span class="s1">HybridExtensionType</span><span class="s4">.</span><span class="s1">HYBRID_PROPERTY</span>

    <span class="s1">__name__</span><span class="s4">: </span><span class="s1">str</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">fget</span><span class="s4">: </span><span class="s1">_HybridGetterType</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
        <span class="s1">fset</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_HybridSetterType</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">fdel</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_HybridDeleterType</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">expr</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_HybridExprCallableType</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">custom_comparator</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">update_expr</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_HybridUpdaterType</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s5">&quot;&quot;&quot;Create a new :class:`.hybrid_property`. 
 
        Usage is typically via decorator:: 
 
            from sqlalchemy.ext.hybrid import hybrid_property 
 
            class SomeClass: 
                @hybrid_property 
                def value(self): 
                    return self._value 
 
                @value.setter 
                def value(self, value): 
                    self._value = value 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">fget </span><span class="s4">= </span><span class="s1">fget</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">fset </span><span class="s4">= </span><span class="s1">fset</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">fdel </span><span class="s4">= </span><span class="s1">fdel</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">expr </span><span class="s4">= </span><span class="s1">_unwrap_classmethod</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">custom_comparator </span><span class="s4">= </span><span class="s1">_unwrap_classmethod</span><span class="s4">(</span><span class="s1">custom_comparator</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">update_expr </span><span class="s4">= </span><span class="s1">_unwrap_classmethod</span><span class="s4">(</span><span class="s1">update_expr</span><span class="s4">)</span>
        <span class="s1">util</span><span class="s4">.</span><span class="s1">update_wrapper</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fget</span><span class="s4">)  </span><span class="s0"># type: ignore[arg-type]</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">owner</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">None</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">None</span><span class="s4">], </span><span class="s1">owner</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">object</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; _HybridClassLevelAccessor</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">object</span><span class="s4">, </span><span class="s1">owner</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">object</span><span class="s4">]) </span><span class="s1">-&gt; _T</span><span class="s4">: ...</span>

    <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">object</span><span class="s4">], </span><span class="s1">owner</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">object</span><span class="s4">]]</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">hybrid_property</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">], </span><span class="s1">_HybridClassLevelAccessor</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">], </span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">owner </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>
        <span class="s3">elif </span><span class="s1">instance </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_expr_comparator</span><span class="s4">(</span><span class="s1">owner</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fget</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__set__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">object</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fset </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span><span class="s2">&quot;can't set attribute&quot;</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">fset</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__delete__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">instance</span><span class="s4">: </span><span class="s1">object</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fdel </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span><span class="s2">&quot;can't delete attribute&quot;</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">fdel</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_copy</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s1">defaults </span><span class="s4">= {</span>
            <span class="s1">key</span><span class="s4">: </span><span class="s1">value</span>
            <span class="s3">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()</span>
            <span class="s3">if not </span><span class="s1">key</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s2">&quot;_&quot;</span><span class="s4">)</span>
        <span class="s4">}</span>
        <span class="s1">defaults</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(**</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)(**</span><span class="s1">defaults</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">overrides</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s5">&quot;&quot;&quot;Prefix for a method that is overriding an existing attribute. 
 
        The :attr:`.hybrid_property.overrides` accessor just returns 
        this hybrid object, which when called at the class level from 
        a parent class, will de-reference the &quot;instrumented attribute&quot; 
        normally returned at this level, and allow modifying decorators 
        like :meth:`.hybrid_property.expression` and 
        :meth:`.hybrid_property.comparator` 
        to be used without conflicting with the same-named attributes 
        normally present on the :class:`.QueryableAttribute`:: 
 
            class SuperClass: 
                # ... 
 
                @hybrid_property 
                def foobar(self): 
                    return self._foobar 
 
            class SubClass(SuperClass): 
                # ... 
 
                @SuperClass.foobar.overrides.expression 
                def foobar(cls): 
                    return func.subfoobar(self._foobar) 
 
        .. versionadded:: 1.2 
 
        .. seealso:: 
 
            :ref:`hybrid_reuse_subclass` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">class </span><span class="s1">_InPlace</span><span class="s4">(</span><span class="s1">Generic</span><span class="s4">[</span><span class="s1">_TE</span><span class="s4">]):</span>
        <span class="s5">&quot;&quot;&quot;A builder helper for .hybrid_property. 
 
        .. versionadded:: 2.0.4 
 
        &quot;&quot;&quot;</span>

        <span class="s1">__slots__ </span><span class="s4">= (</span><span class="s2">&quot;attr&quot;</span><span class="s4">,)</span>

        <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">: </span><span class="s1">hybrid_property</span><span class="s4">[</span><span class="s1">_TE</span><span class="s4">]):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">attr </span><span class="s4">= </span><span class="s1">attr</span>

        <span class="s3">def </span><span class="s1">_set</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_TE</span><span class="s4">]:</span>
            <span class="s3">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">kw</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
                <span class="s1">setattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">attr</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">_unwrap_classmethod</span><span class="s4">(</span><span class="s1">v</span><span class="s4">))</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">attr</span>

        <span class="s3">def </span><span class="s1">getter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fget</span><span class="s4">: </span><span class="s1">_HybridGetterType</span><span class="s4">[</span><span class="s1">_TE</span><span class="s4">]) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_TE</span><span class="s4">]:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_set</span><span class="s4">(</span><span class="s1">fget</span><span class="s4">=</span><span class="s1">fget</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">setter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fset</span><span class="s4">: </span><span class="s1">_HybridSetterType</span><span class="s4">[</span><span class="s1">_TE</span><span class="s4">]) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_TE</span><span class="s4">]:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_set</span><span class="s4">(</span><span class="s1">fset</span><span class="s4">=</span><span class="s1">fset</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">deleter</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">fdel</span><span class="s4">: </span><span class="s1">_HybridDeleterType</span><span class="s4">[</span><span class="s1">_TE</span><span class="s4">]</span>
        <span class="s4">) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_TE</span><span class="s4">]:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_set</span><span class="s4">(</span><span class="s1">fdel</span><span class="s4">=</span><span class="s1">fdel</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">expression</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">expr</span><span class="s4">: </span><span class="s1">_HybridExprCallableType</span><span class="s4">[</span><span class="s1">_TE</span><span class="s4">]</span>
        <span class="s4">) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_TE</span><span class="s4">]:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_set</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">=</span><span class="s1">expr</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">comparator</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">comparator</span><span class="s4">: </span><span class="s1">_HybridComparatorCallableType</span><span class="s4">[</span><span class="s1">_TE</span><span class="s4">]</span>
        <span class="s4">) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_TE</span><span class="s4">]:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_set</span><span class="s4">(</span><span class="s1">custom_comparator</span><span class="s4">=</span><span class="s1">comparator</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">update_expression</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">meth</span><span class="s4">: </span><span class="s1">_HybridUpdaterType</span><span class="s4">[</span><span class="s1">_TE</span><span class="s4">]</span>
        <span class="s4">) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_TE</span><span class="s4">]:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_set</span><span class="s4">(</span><span class="s1">update_expr</span><span class="s4">=</span><span class="s1">meth</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">inplace</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _InPlace</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s5">&quot;&quot;&quot;Return the inplace mutator for this :class:`.hybrid_property`. 
 
        This is to allow in-place mutation of the hybrid, allowing the first 
        hybrid method of a certain name to be re-used in order to add 
        more methods without having to name those methods the same, e.g.:: 
 
            class Interval(Base): 
                # ... 
 
                @hybrid_property 
                def radius(self) -&gt; float: 
                    return abs(self.length) / 2 
 
                @radius.inplace.setter 
                def _radius_setter(self, value: float) -&gt; None: 
                    self.length = value * 2 
 
                @radius.inplace.expression 
                def _radius_expression(cls) -&gt; ColumnElement[float]: 
                    return type_coerce(func.abs(cls.length) / 2, Float) 
 
        .. versionadded:: 2.0.4 
 
        .. seealso:: 
 
            :ref:`hybrid_pep484_naming` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">hybrid_property</span><span class="s4">.</span><span class="s1">_InPlace</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">getter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fget</span><span class="s4">: </span><span class="s1">_HybridGetterType</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s5">&quot;&quot;&quot;Provide a modifying decorator that defines a getter method. 
 
        .. versionadded:: 1.2 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_copy</span><span class="s4">(</span><span class="s1">fget</span><span class="s4">=</span><span class="s1">fget</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">setter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fset</span><span class="s4">: </span><span class="s1">_HybridSetterType</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s5">&quot;&quot;&quot;Provide a modifying decorator that defines a setter method.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_copy</span><span class="s4">(</span><span class="s1">fset</span><span class="s4">=</span><span class="s1">fset</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">deleter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fdel</span><span class="s4">: </span><span class="s1">_HybridDeleterType</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s5">&quot;&quot;&quot;Provide a modifying decorator that defines a deletion method.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_copy</span><span class="s4">(</span><span class="s1">fdel</span><span class="s4">=</span><span class="s1">fdel</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">expression</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">expr</span><span class="s4">: </span><span class="s1">_HybridExprCallableType</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s5">&quot;&quot;&quot;Provide a modifying decorator that defines a SQL-expression 
        producing method. 
 
        When a hybrid is invoked at the class level, the SQL expression given 
        here is wrapped inside of a specialized :class:`.QueryableAttribute`, 
        which is the same kind of object used by the ORM to represent other 
        mapped attributes.   The reason for this is so that other class-level 
        attributes such as docstrings and a reference to the hybrid itself may 
        be maintained within the structure that's returned, without any 
        modifications to the original SQL expression passed in. 
 
        .. note:: 
 
           When referring to a hybrid property  from an owning class (e.g. 
           ``SomeClass.some_hybrid``), an instance of 
           :class:`.QueryableAttribute` is returned, representing the 
           expression or comparator object as well as this  hybrid object. 
           However, that object itself has accessors called ``expression`` and 
           ``comparator``; so when attempting to override these decorators on a 
           subclass, it may be necessary to qualify it using the 
           :attr:`.hybrid_property.overrides` modifier first.  See that 
           modifier for details. 
 
        .. seealso:: 
 
            :ref:`hybrid_distinct_expression` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_copy</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">=</span><span class="s1">expr</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">comparator</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">comparator</span><span class="s4">: </span><span class="s1">_HybridComparatorCallableType</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s5">&quot;&quot;&quot;Provide a modifying decorator that defines a custom 
        comparator producing method. 
 
        The return value of the decorated method should be an instance of 
        :class:`~.hybrid.Comparator`. 
 
        .. note::  The :meth:`.hybrid_property.comparator` decorator 
           **replaces** the use of the :meth:`.hybrid_property.expression` 
           decorator.  They cannot be used together. 
 
        When a hybrid is invoked at the class level, the 
        :class:`~.hybrid.Comparator` object given here is wrapped inside of a 
        specialized :class:`.QueryableAttribute`, which is the same kind of 
        object used by the ORM to represent other mapped attributes.   The 
        reason for this is so that other class-level attributes such as 
        docstrings and a reference to the hybrid itself may be maintained 
        within the structure that's returned, without any modifications to the 
        original comparator object passed in. 
 
        .. note:: 
 
           When referring to a hybrid property  from an owning class (e.g. 
           ``SomeClass.some_hybrid``), an instance of 
           :class:`.QueryableAttribute` is returned, representing the 
           expression or comparator object as this  hybrid object.  However, 
           that object itself has accessors called ``expression`` and 
           ``comparator``; so when attempting to override these decorators on a 
           subclass, it may be necessary to qualify it using the 
           :attr:`.hybrid_property.overrides` modifier first.  See that 
           modifier for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_copy</span><span class="s4">(</span><span class="s1">custom_comparator</span><span class="s4">=</span><span class="s1">comparator</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">update_expression</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">meth</span><span class="s4">: </span><span class="s1">_HybridUpdaterType</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; hybrid_property</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s5">&quot;&quot;&quot;Provide a modifying decorator that defines an UPDATE tuple 
        producing method. 
 
        The method accepts a single value, which is the value to be 
        rendered into the SET clause of an UPDATE statement.  The method 
        should then process this value into individual column expressions 
        that fit into the ultimate SET clause, and return them as a 
        sequence of 2-tuples.  Each tuple 
        contains a column expression as the key and a value to be rendered. 
 
        E.g.:: 
 
            class Person(Base): 
                # ... 
 
                first_name = Column(String) 
                last_name = Column(String) 
 
                @hybrid_property 
                def fullname(self): 
                    return first_name + &quot; &quot; + last_name 
 
                @fullname.update_expression 
                def fullname(cls, value): 
                    fname, lname = value.split(&quot; &quot;, 1) 
                    return [ 
                        (cls.first_name, fname), 
                        (cls.last_name, lname) 
                    ] 
 
        .. versionadded:: 1.2 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_copy</span><span class="s4">(</span><span class="s1">update_expr</span><span class="s4">=</span><span class="s1">meth</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_expr_comparator</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">[[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">_HybridClassLevelAccessor</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">custom_comparator </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_comparator</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">custom_comparator</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">expr </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_expr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_expr</span><span class="s4">(</span><span class="s1">cast</span><span class="s4">(</span><span class="s1">_HybridExprCallableType</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">], </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fget</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">_get_expr</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">expr</span><span class="s4">: </span><span class="s1">_HybridExprCallableType</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">[[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">_HybridClassLevelAccessor</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
        <span class="s3">def </span><span class="s1">_expr</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ExprComparator</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
            <span class="s3">return </span><span class="s1">ExprComparator</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">expr</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">), </span><span class="s1">self</span><span class="s4">)</span>

        <span class="s1">util</span><span class="s4">.</span><span class="s1">update_wrapper</span><span class="s4">(</span><span class="s1">_expr</span><span class="s4">, </span><span class="s1">expr</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_comparator</span><span class="s4">(</span><span class="s1">_expr</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_get_comparator</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">comparator</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">[[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">_HybridClassLevelAccessor</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
        <span class="s1">proxy_attr </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">create_proxied_attribute</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">expr_comparator</span><span class="s4">(</span>
            <span class="s1">owner</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">object</span><span class="s4">],</span>
        <span class="s4">) </span><span class="s1">-&gt; _HybridClassLevelAccessor</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
            <span class="s0"># because this is the descriptor protocol, we don't really know</span>
            <span class="s0"># what our attribute name is.  so search for it through the</span>
            <span class="s0"># MRO.</span>
            <span class="s3">for </span><span class="s1">lookup </span><span class="s3">in </span><span class="s1">owner</span><span class="s4">.</span><span class="s1">__mro__</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__name__ </span><span class="s3">in </span><span class="s1">lookup</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">lookup</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">] </span><span class="s3">is </span><span class="s1">self</span><span class="s4">:</span>
                        <span class="s1">name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__name__</span>
                        <span class="s3">break</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">name </span><span class="s4">= </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">_UNKNOWN_ATTR_KEY  </span><span class="s0"># type: ignore[assignment]</span>

            <span class="s3">return </span><span class="s1">cast</span><span class="s4">(</span>
                <span class="s2">&quot;_HybridClassLevelAccessor[_T]&quot;</span><span class="s4">,</span>
                <span class="s1">proxy_attr</span><span class="s4">(</span>
                    <span class="s1">owner</span><span class="s4">,</span>
                    <span class="s1">name</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">,</span>
                    <span class="s1">comparator</span><span class="s4">(</span><span class="s1">owner</span><span class="s4">),</span>
                    <span class="s1">doc</span><span class="s4">=</span><span class="s1">comparator</span><span class="s4">.</span><span class="s1">__doc__ </span><span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__doc__</span><span class="s4">,</span>
                <span class="s4">),</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">expr_comparator</span>


<span class="s3">class </span><span class="s1">Comparator</span><span class="s4">(</span><span class="s1">interfaces</span><span class="s4">.</span><span class="s1">PropComparator</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s5">&quot;&quot;&quot;A helper class that allows easy construction of custom 
    :class:`~.orm.interfaces.PropComparator` 
    classes for usage with hybrids.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">expression</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">_HasClauseElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">], </span><span class="s1">SQLColumnExpression</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">expression </span><span class="s4">= </span><span class="s1">expression</span>

    <span class="s3">def </span><span class="s1">__clause_element__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; roles</span><span class="s4">.</span><span class="s1">ColumnsClauseRole</span><span class="s4">:</span>
        <span class="s1">expr </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">expression</span>
        <span class="s3">if </span><span class="s1">is_has_clause_element</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">):</span>
            <span class="s1">ret_expr </span><span class="s4">= </span><span class="s1">expr</span><span class="s4">.</span><span class="s1">__clause_element__</span><span class="s4">()</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
                <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">)</span>
            <span class="s1">ret_expr </span><span class="s4">= </span><span class="s1">expr</span>

        <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
            <span class="s0"># see test_hybrid-&gt;test_expression_isnt_clause_element</span>
            <span class="s0"># that exercises the usual place this is caught if not</span>
            <span class="s0"># true</span>
            <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">ret_expr</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">ret_expr</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">non_memoized_property</span>
    <span class="s3">def </span><span class="s1">property</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; interfaces</span><span class="s4">.</span><span class="s1">MapperProperty</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">adapt_to_entity</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">adapt_to_entity</span><span class="s4">: </span><span class="s1">AliasedInsp</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; Comparator</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s0"># interesting....</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">ExprComparator</span><span class="s4">(</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">expression</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">_HasClauseElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">], </span><span class="s1">SQLColumnExpression</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]],</span>
        <span class="s1">hybrid</span><span class="s4">: </span><span class="s1">hybrid_property</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">cls </span><span class="s4">= </span><span class="s1">cls</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">expression </span><span class="s4">= </span><span class="s1">expression</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">hybrid </span><span class="s4">= </span><span class="s1">hybrid</span>

    <span class="s3">def </span><span class="s1">__getattr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">expression</span><span class="s4">, </span><span class="s1">key</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">info</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _InfoType</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hybrid</span><span class="s4">.</span><span class="s1">info</span>

    <span class="s3">def </span><span class="s1">_bulk_update_tuples</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; Sequence</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_DMLColumnArgument</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">expression</span><span class="s4">, </span><span class="s1">attributes</span><span class="s4">.</span><span class="s1">QueryableAttribute</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">expression</span><span class="s4">.</span><span class="s1">_bulk_update_tuples</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hybrid</span><span class="s4">.</span><span class="s1">update_expr </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">hybrid</span><span class="s4">.</span><span class="s1">update_expr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">[(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">expression</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)]</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">non_memoized_property</span>
    <span class="s3">def </span><span class="s1">property</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; MapperProperty</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s0"># this accessor is not normally used, however is accessed by things</span>
        <span class="s0"># like ORM synonyms if the hybrid is used in this context; the</span>
        <span class="s0"># .property attribute is not necessarily accessible</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">expression</span><span class="s4">.</span><span class="s1">property  </span><span class="s0"># type: ignore</span>

    <span class="s3">def </span><span class="s1">operate</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">op</span><span class="s4">: </span><span class="s1">OperatorType</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">op</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">expression</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">reverse_operate</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">op</span><span class="s4">: </span><span class="s1">OperatorType</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">op</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">expression</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)  </span><span class="s0"># type: ignore</span>
</pre>
</body>
</html>