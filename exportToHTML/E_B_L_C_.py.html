<html>
<head>
<title>E_B_L_C_.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #7a7e85;}
.s5 { color: #2aacb8;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
E_B_L_C_.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">misc </span><span class="s0">import </span><span class="s1">sstruct</span>
<span class="s0">from </span><span class="s2">. </span><span class="s0">import </span><span class="s1">DefaultTable</span>
<span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">misc</span><span class="s2">.</span><span class="s1">textTools </span><span class="s0">import </span><span class="s1">bytesjoin</span><span class="s2">, </span><span class="s1">safeEval</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">BitmapGlyphMetrics </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">BigGlyphMetrics</span><span class="s2">,</span>
    <span class="s1">bigGlyphMetricsFormat</span><span class="s2">,</span>
    <span class="s1">SmallGlyphMetrics</span><span class="s2">,</span>
    <span class="s1">smallGlyphMetricsFormat</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">import </span><span class="s1">struct</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">deque</span>
<span class="s0">import </span><span class="s1">logging</span>


<span class="s1">log </span><span class="s2">= </span><span class="s1">logging</span><span class="s2">.</span><span class="s1">getLogger</span><span class="s2">(</span><span class="s1">__name__</span><span class="s2">)</span>

<span class="s1">eblcHeaderFormat </span><span class="s2">= </span><span class="s3">&quot;&quot;&quot; 
    &gt; # big endian 
    version:  16.16F 
    numSizes: I 
&quot;&quot;&quot;</span>
<span class="s4"># The table format string is split to handle sbitLineMetrics simply.</span>
<span class="s1">bitmapSizeTableFormatPart1 </span><span class="s2">= </span><span class="s3">&quot;&quot;&quot; 
    &gt; # big endian 
    indexSubTableArrayOffset: I 
    indexTablesSize:          I 
    numberOfIndexSubTables:   I 
    colorRef:                 I 
&quot;&quot;&quot;</span>
<span class="s4"># The compound type for hori and vert.</span>
<span class="s1">sbitLineMetricsFormat </span><span class="s2">= </span><span class="s3">&quot;&quot;&quot; 
    &gt; # big endian 
    ascender:              b 
    descender:             b 
    widthMax:              B 
    caretSlopeNumerator:   b 
    caretSlopeDenominator: b 
    caretOffset:           b 
    minOriginSB:           b 
    minAdvanceSB:          b 
    maxBeforeBL:           b 
    minAfterBL:            b 
    pad1:                  b 
    pad2:                  b 
&quot;&quot;&quot;</span>
<span class="s4"># hori and vert go between the two parts.</span>
<span class="s1">bitmapSizeTableFormatPart2 </span><span class="s2">= </span><span class="s3">&quot;&quot;&quot; 
    &gt; # big endian 
    startGlyphIndex: H 
    endGlyphIndex:   H 
    ppemX:           B 
    ppemY:           B 
    bitDepth:        B 
    flags:           b 
&quot;&quot;&quot;</span>

<span class="s1">indexSubTableArrayFormat </span><span class="s2">= </span><span class="s3">&quot;&gt;HHL&quot;</span>
<span class="s1">indexSubTableArraySize </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">calcsize</span><span class="s2">(</span><span class="s1">indexSubTableArrayFormat</span><span class="s2">)</span>

<span class="s1">indexSubHeaderFormat </span><span class="s2">= </span><span class="s3">&quot;&gt;HHL&quot;</span>
<span class="s1">indexSubHeaderSize </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">calcsize</span><span class="s2">(</span><span class="s1">indexSubHeaderFormat</span><span class="s2">)</span>

<span class="s1">codeOffsetPairFormat </span><span class="s2">= </span><span class="s3">&quot;&gt;HH&quot;</span>
<span class="s1">codeOffsetPairSize </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">calcsize</span><span class="s2">(</span><span class="s1">codeOffsetPairFormat</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">table_E_B_L_C_</span><span class="s2">(</span><span class="s1">DefaultTable</span><span class="s2">.</span><span class="s1">DefaultTable</span><span class="s2">):</span>
    <span class="s1">dependencies </span><span class="s2">= [</span><span class="s3">&quot;EBDT&quot;</span><span class="s2">]</span>

    <span class="s4"># This method can be overridden in subclasses to support new formats</span>
    <span class="s4"># without changing the other implementation. Also can be used as a</span>
    <span class="s4"># convenience method for coverting a font file to an alternative format.</span>
    <span class="s0">def </span><span class="s1">getIndexFormatClass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">indexFormat</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">eblc_sub_table_classes</span><span class="s2">[</span><span class="s1">indexFormat</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">decompile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s4"># Save the original data because offsets are from the start of the table.</span>
        <span class="s1">origData </span><span class="s2">= </span><span class="s1">data</span>
        <span class="s1">i </span><span class="s2">= </span><span class="s5">0</span>

        <span class="s1">dummy </span><span class="s2">= </span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s1">eblcHeaderFormat</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[:</span><span class="s5">8</span><span class="s2">], </span><span class="s1">self</span><span class="s2">)</span>
        <span class="s1">i </span><span class="s2">+= </span><span class="s5">8</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">strikes </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">curStrikeIndex </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">numSizes</span><span class="s2">):</span>
            <span class="s1">curStrike </span><span class="s2">= </span><span class="s1">Strike</span><span class="s2">()</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">strikes</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">curStrike</span><span class="s2">)</span>
            <span class="s1">curTable </span><span class="s2">= </span><span class="s1">curStrike</span><span class="s2">.</span><span class="s1">bitmapSizeTable</span>
            <span class="s1">dummy </span><span class="s2">= </span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">unpack2</span><span class="s2">(</span>
                <span class="s1">bitmapSizeTableFormatPart1</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">i </span><span class="s2">: </span><span class="s1">i </span><span class="s2">+ </span><span class="s5">16</span><span class="s2">], </span><span class="s1">curTable</span>
            <span class="s2">)</span>
            <span class="s1">i </span><span class="s2">+= </span><span class="s5">16</span>
            <span class="s0">for </span><span class="s1">metric </span><span class="s0">in </span><span class="s2">(</span><span class="s3">&quot;hori&quot;</span><span class="s2">, </span><span class="s3">&quot;vert&quot;</span><span class="s2">):</span>
                <span class="s1">metricObj </span><span class="s2">= </span><span class="s1">SbitLineMetrics</span><span class="s2">()</span>
                <span class="s1">vars</span><span class="s2">(</span><span class="s1">curTable</span><span class="s2">)[</span><span class="s1">metric</span><span class="s2">] = </span><span class="s1">metricObj</span>
                <span class="s1">dummy </span><span class="s2">= </span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">unpack2</span><span class="s2">(</span>
                    <span class="s1">sbitLineMetricsFormat</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">i </span><span class="s2">: </span><span class="s1">i </span><span class="s2">+ </span><span class="s5">12</span><span class="s2">], </span><span class="s1">metricObj</span>
                <span class="s2">)</span>
                <span class="s1">i </span><span class="s2">+= </span><span class="s5">12</span>
            <span class="s1">dummy </span><span class="s2">= </span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span>
                <span class="s1">bitmapSizeTableFormatPart2</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">i </span><span class="s2">: </span><span class="s1">i </span><span class="s2">+ </span><span class="s5">8</span><span class="s2">], </span><span class="s1">curTable</span>
            <span class="s2">)</span>
            <span class="s1">i </span><span class="s2">+= </span><span class="s5">8</span>

        <span class="s0">for </span><span class="s1">curStrike </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">strikes</span><span class="s2">:</span>
            <span class="s1">curTable </span><span class="s2">= </span><span class="s1">curStrike</span><span class="s2">.</span><span class="s1">bitmapSizeTable</span>
            <span class="s0">for </span><span class="s1">subtableIndex </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">curTable</span><span class="s2">.</span><span class="s1">numberOfIndexSubTables</span><span class="s2">):</span>
                <span class="s1">i </span><span class="s2">= (</span>
                    <span class="s1">curTable</span><span class="s2">.</span><span class="s1">indexSubTableArrayOffset</span>
                    <span class="s2">+ </span><span class="s1">subtableIndex </span><span class="s2">* </span><span class="s1">indexSubTableArraySize</span>
                <span class="s2">)</span>

                <span class="s1">tup </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span>
                    <span class="s1">indexSubTableArrayFormat</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">i </span><span class="s2">: </span><span class="s1">i </span><span class="s2">+ </span><span class="s1">indexSubTableArraySize</span><span class="s2">]</span>
                <span class="s2">)</span>
                <span class="s2">(</span><span class="s1">firstGlyphIndex</span><span class="s2">, </span><span class="s1">lastGlyphIndex</span><span class="s2">, </span><span class="s1">additionalOffsetToIndexSubtable</span><span class="s2">) = </span><span class="s1">tup</span>
                <span class="s1">i </span><span class="s2">= </span><span class="s1">curTable</span><span class="s2">.</span><span class="s1">indexSubTableArrayOffset </span><span class="s2">+ </span><span class="s1">additionalOffsetToIndexSubtable</span>

                <span class="s1">tup </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span>
                    <span class="s1">indexSubHeaderFormat</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">i </span><span class="s2">: </span><span class="s1">i </span><span class="s2">+ </span><span class="s1">indexSubHeaderSize</span><span class="s2">]</span>
                <span class="s2">)</span>
                <span class="s2">(</span><span class="s1">indexFormat</span><span class="s2">, </span><span class="s1">imageFormat</span><span class="s2">, </span><span class="s1">imageDataOffset</span><span class="s2">) = </span><span class="s1">tup</span>

                <span class="s1">indexFormatClass </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">getIndexFormatClass</span><span class="s2">(</span><span class="s1">indexFormat</span><span class="s2">)</span>
                <span class="s1">indexSubTable </span><span class="s2">= </span><span class="s1">indexFormatClass</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[</span><span class="s1">i </span><span class="s2">+ </span><span class="s1">indexSubHeaderSize </span><span class="s2">:], </span><span class="s1">ttFont</span><span class="s2">)</span>
                <span class="s1">indexSubTable</span><span class="s2">.</span><span class="s1">firstGlyphIndex </span><span class="s2">= </span><span class="s1">firstGlyphIndex</span>
                <span class="s1">indexSubTable</span><span class="s2">.</span><span class="s1">lastGlyphIndex </span><span class="s2">= </span><span class="s1">lastGlyphIndex</span>
                <span class="s1">indexSubTable</span><span class="s2">.</span><span class="s1">additionalOffsetToIndexSubtable </span><span class="s2">= (</span>
                    <span class="s1">additionalOffsetToIndexSubtable</span>
                <span class="s2">)</span>
                <span class="s1">indexSubTable</span><span class="s2">.</span><span class="s1">indexFormat </span><span class="s2">= </span><span class="s1">indexFormat</span>
                <span class="s1">indexSubTable</span><span class="s2">.</span><span class="s1">imageFormat </span><span class="s2">= </span><span class="s1">imageFormat</span>
                <span class="s1">indexSubTable</span><span class="s2">.</span><span class="s1">imageDataOffset </span><span class="s2">= </span><span class="s1">imageDataOffset</span>
                <span class="s1">indexSubTable</span><span class="s2">.</span><span class="s1">decompile</span><span class="s2">()  </span><span class="s4"># https://github.com/fonttools/fonttools/issues/317</span>
                <span class="s1">curStrike</span><span class="s2">.</span><span class="s1">indexSubTables</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">indexSubTable</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">dataList </span><span class="s2">= []</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">numSizes </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">strikes</span><span class="s2">)</span>
        <span class="s1">dataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s1">eblcHeaderFormat</span><span class="s2">, </span><span class="s1">self</span><span class="s2">))</span>

        <span class="s4"># Data size of the header + bitmapSizeTable needs to be calculated</span>
        <span class="s4"># in order to form offsets. This value will hold the size of the data</span>
        <span class="s4"># in dataList after all the data is consolidated in dataList.</span>
        <span class="s1">dataSize </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">dataList</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>

        <span class="s4"># The table will be structured in the following order:</span>
        <span class="s4"># (0) header</span>
        <span class="s4"># (1) Each bitmapSizeTable [1 ... self.numSizes]</span>
        <span class="s4"># (2) Alternate between indexSubTableArray and indexSubTable</span>
        <span class="s4">#     for each bitmapSizeTable present.</span>
        <span class="s4">#</span>
        <span class="s4"># The issue is maintaining the proper offsets when table information</span>
        <span class="s4"># gets moved around. All offsets and size information must be recalculated</span>
        <span class="s4"># when building the table to allow editing within ttLib and also allow easy</span>
        <span class="s4"># import/export to and from XML. All of this offset information is lost</span>
        <span class="s4"># when exporting to XML so everything must be calculated fresh so importing</span>
        <span class="s4"># from XML will work cleanly. Only byte offset and size information is</span>
        <span class="s4"># calculated fresh. Count information like numberOfIndexSubTables is</span>
        <span class="s4"># checked through assertions. If the information in this table was not</span>
        <span class="s4"># touched or was changed properly then these types of values should match.</span>
        <span class="s4">#</span>
        <span class="s4"># The table will be rebuilt the following way:</span>
        <span class="s4"># (0) Precompute the size of all the bitmapSizeTables. This is needed to</span>
        <span class="s4">#     compute the offsets properly.</span>
        <span class="s4"># (1) For each bitmapSizeTable compute the indexSubTable and</span>
        <span class="s4">#       indexSubTableArray pair. The indexSubTable must be computed first</span>
        <span class="s4">#     so that the offset information in indexSubTableArray can be</span>
        <span class="s4">#     calculated. Update the data size after each pairing.</span>
        <span class="s4"># (2) Build each bitmapSizeTable.</span>
        <span class="s4"># (3) Consolidate all the data into the main dataList in the correct order.</span>

        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">strikes</span><span class="s2">:</span>
            <span class="s1">dataSize </span><span class="s2">+= </span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">calcsize</span><span class="s2">(</span><span class="s1">bitmapSizeTableFormatPart1</span><span class="s2">)</span>
            <span class="s1">dataSize </span><span class="s2">+= </span><span class="s1">len</span><span class="s2">((</span><span class="s3">&quot;hori&quot;</span><span class="s2">, </span><span class="s3">&quot;vert&quot;</span><span class="s2">)) * </span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">calcsize</span><span class="s2">(</span><span class="s1">sbitLineMetricsFormat</span><span class="s2">)</span>
            <span class="s1">dataSize </span><span class="s2">+= </span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">calcsize</span><span class="s2">(</span><span class="s1">bitmapSizeTableFormatPart2</span><span class="s2">)</span>

        <span class="s1">indexSubTablePairDataList </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">curStrike </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">strikes</span><span class="s2">:</span>
            <span class="s1">curTable </span><span class="s2">= </span><span class="s1">curStrike</span><span class="s2">.</span><span class="s1">bitmapSizeTable</span>
            <span class="s1">curTable</span><span class="s2">.</span><span class="s1">numberOfIndexSubTables </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">curStrike</span><span class="s2">.</span><span class="s1">indexSubTables</span><span class="s2">)</span>
            <span class="s1">curTable</span><span class="s2">.</span><span class="s1">indexSubTableArrayOffset </span><span class="s2">= </span><span class="s1">dataSize</span>

            <span class="s4"># Precompute the size of the indexSubTableArray. This information</span>
            <span class="s4"># is important for correctly calculating the new value for</span>
            <span class="s4"># additionalOffsetToIndexSubtable.</span>
            <span class="s1">sizeOfSubTableArray </span><span class="s2">= (</span>
                <span class="s1">curTable</span><span class="s2">.</span><span class="s1">numberOfIndexSubTables </span><span class="s2">* </span><span class="s1">indexSubTableArraySize</span>
            <span class="s2">)</span>
            <span class="s1">lowerBound </span><span class="s2">= </span><span class="s1">dataSize</span>
            <span class="s1">dataSize </span><span class="s2">+= </span><span class="s1">sizeOfSubTableArray</span>
            <span class="s1">upperBound </span><span class="s2">= </span><span class="s1">dataSize</span>

            <span class="s1">indexSubTableDataList </span><span class="s2">= []</span>
            <span class="s0">for </span><span class="s1">indexSubTable </span><span class="s0">in </span><span class="s1">curStrike</span><span class="s2">.</span><span class="s1">indexSubTables</span><span class="s2">:</span>
                <span class="s1">indexSubTable</span><span class="s2">.</span><span class="s1">additionalOffsetToIndexSubtable </span><span class="s2">= (</span>
                    <span class="s1">dataSize </span><span class="s2">- </span><span class="s1">curTable</span><span class="s2">.</span><span class="s1">indexSubTableArrayOffset</span>
                <span class="s2">)</span>
                <span class="s1">glyphIds </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphID</span><span class="s2">, </span><span class="s1">indexSubTable</span><span class="s2">.</span><span class="s1">names</span><span class="s2">))</span>
                <span class="s1">indexSubTable</span><span class="s2">.</span><span class="s1">firstGlyphIndex </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">glyphIds</span><span class="s2">)</span>
                <span class="s1">indexSubTable</span><span class="s2">.</span><span class="s1">lastGlyphIndex </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">glyphIds</span><span class="s2">)</span>
                <span class="s1">data </span><span class="s2">= </span><span class="s1">indexSubTable</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s1">ttFont</span><span class="s2">)</span>
                <span class="s1">indexSubTableDataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
                <span class="s1">dataSize </span><span class="s2">+= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
            <span class="s1">curTable</span><span class="s2">.</span><span class="s1">startGlyphIndex </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span>
                <span class="s1">ist</span><span class="s2">.</span><span class="s1">firstGlyphIndex </span><span class="s0">for </span><span class="s1">ist </span><span class="s0">in </span><span class="s1">curStrike</span><span class="s2">.</span><span class="s1">indexSubTables</span>
            <span class="s2">)</span>
            <span class="s1">curTable</span><span class="s2">.</span><span class="s1">endGlyphIndex </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span>
                <span class="s1">ist</span><span class="s2">.</span><span class="s1">lastGlyphIndex </span><span class="s0">for </span><span class="s1">ist </span><span class="s0">in </span><span class="s1">curStrike</span><span class="s2">.</span><span class="s1">indexSubTables</span>
            <span class="s2">)</span>

            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">curStrike</span><span class="s2">.</span><span class="s1">indexSubTables</span><span class="s2">:</span>
                <span class="s1">data </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span>
                    <span class="s1">indexSubHeaderFormat</span><span class="s2">,</span>
                    <span class="s1">i</span><span class="s2">.</span><span class="s1">firstGlyphIndex</span><span class="s2">,</span>
                    <span class="s1">i</span><span class="s2">.</span><span class="s1">lastGlyphIndex</span><span class="s2">,</span>
                    <span class="s1">i</span><span class="s2">.</span><span class="s1">additionalOffsetToIndexSubtable</span><span class="s2">,</span>
                <span class="s2">)</span>
                <span class="s1">indexSubTablePairDataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
            <span class="s1">indexSubTablePairDataList</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">indexSubTableDataList</span><span class="s2">)</span>
            <span class="s1">curTable</span><span class="s2">.</span><span class="s1">indexTablesSize </span><span class="s2">= </span><span class="s1">dataSize </span><span class="s2">- </span><span class="s1">curTable</span><span class="s2">.</span><span class="s1">indexSubTableArrayOffset</span>

        <span class="s0">for </span><span class="s1">curStrike </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">strikes</span><span class="s2">:</span>
            <span class="s1">curTable </span><span class="s2">= </span><span class="s1">curStrike</span><span class="s2">.</span><span class="s1">bitmapSizeTable</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s1">bitmapSizeTableFormatPart1</span><span class="s2">, </span><span class="s1">curTable</span><span class="s2">)</span>
            <span class="s1">dataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">metric </span><span class="s0">in </span><span class="s2">(</span><span class="s3">&quot;hori&quot;</span><span class="s2">, </span><span class="s3">&quot;vert&quot;</span><span class="s2">):</span>
                <span class="s1">metricObj </span><span class="s2">= </span><span class="s1">vars</span><span class="s2">(</span><span class="s1">curTable</span><span class="s2">)[</span><span class="s1">metric</span><span class="s2">]</span>
                <span class="s1">data </span><span class="s2">= </span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s1">sbitLineMetricsFormat</span><span class="s2">, </span><span class="s1">metricObj</span><span class="s2">)</span>
                <span class="s1">dataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s1">bitmapSizeTableFormatPart2</span><span class="s2">, </span><span class="s1">curTable</span><span class="s2">)</span>
            <span class="s1">dataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s1">dataList</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">indexSubTablePairDataList</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">bytesjoin</span><span class="s2">(</span><span class="s1">dataList</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">toXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">simpletag</span><span class="s2">(</span><span class="s3">&quot;header&quot;</span><span class="s2">, [(</span><span class="s3">&quot;version&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">version</span><span class="s2">)])</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">curIndex</span><span class="s2">, </span><span class="s1">curStrike </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">strikes</span><span class="s2">):</span>
            <span class="s1">curStrike</span><span class="s2">.</span><span class="s1">toXML</span><span class="s2">(</span><span class="s1">curIndex</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s2">== </span><span class="s3">&quot;header&quot;</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">version </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s3">&quot;version&quot;</span><span class="s2">])</span>
        <span class="s0">elif </span><span class="s1">name </span><span class="s2">== </span><span class="s3">&quot;strike&quot;</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s3">&quot;strikes&quot;</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">strikes </span><span class="s2">= []</span>
            <span class="s1">strikeIndex </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s3">&quot;index&quot;</span><span class="s2">])</span>
            <span class="s1">curStrike </span><span class="s2">= </span><span class="s1">Strike</span><span class="s2">()</span>
            <span class="s1">curStrike</span><span class="s2">.</span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">, </span><span class="s1">self</span><span class="s2">)</span>

            <span class="s4"># Grow the strike array to the appropriate size. The XML format</span>
            <span class="s4"># allows for the strike index value to be out of order.</span>
            <span class="s0">if </span><span class="s1">strikeIndex </span><span class="s2">&gt;= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">strikes</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">strikes </span><span class="s2">+= [</span><span class="s0">None</span><span class="s2">] * (</span><span class="s1">strikeIndex </span><span class="s2">+ </span><span class="s5">1 </span><span class="s2">- </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">strikes</span><span class="s2">))</span>
            <span class="s0">assert </span><span class="s1">self</span><span class="s2">.</span><span class="s1">strikes</span><span class="s2">[</span><span class="s1">strikeIndex</span><span class="s2">] </span><span class="s0">is None</span><span class="s2">, </span><span class="s3">&quot;Duplicate strike EBLC indices.&quot;</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">strikes</span><span class="s2">[</span><span class="s1">strikeIndex</span><span class="s2">] = </span><span class="s1">curStrike</span>


<span class="s0">class </span><span class="s1">Strike</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">bitmapSizeTable </span><span class="s2">= </span><span class="s1">BitmapSizeTable</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">indexSubTables </span><span class="s2">= []</span>

    <span class="s0">def </span><span class="s1">toXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">strikeIndex</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">begintag</span><span class="s2">(</span><span class="s3">&quot;strike&quot;</span><span class="s2">, [(</span><span class="s3">&quot;index&quot;</span><span class="s2">, </span><span class="s1">strikeIndex</span><span class="s2">)])</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">bitmapSizeTable</span><span class="s2">.</span><span class="s1">toXML</span><span class="s2">(</span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">comment</span><span class="s2">(</span>
            <span class="s3">&quot;GlyphIds are written but not read. The firstGlyphIndex and</span><span class="s0">\n</span><span class="s3">lastGlyphIndex values will be recalculated by the compiler.&quot;</span>
        <span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">indexSubTable </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indexSubTables</span><span class="s2">:</span>
            <span class="s1">indexSubTable</span><span class="s2">.</span><span class="s1">toXML</span><span class="s2">(</span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">endtag</span><span class="s2">(</span><span class="s3">&quot;strike&quot;</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">, </span><span class="s1">locator</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">element</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s0">continue</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content </span><span class="s2">= </span><span class="s1">element</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s2">== </span><span class="s3">&quot;bitmapSizeTable&quot;</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">bitmapSizeTable</span><span class="s2">.</span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">name</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s1">_indexSubTableSubclassPrefix</span><span class="s2">):</span>
                <span class="s1">indexFormat </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">name</span><span class="s2">[</span><span class="s1">len</span><span class="s2">(</span><span class="s1">_indexSubTableSubclassPrefix</span><span class="s2">) :])</span>
                <span class="s1">indexFormatClass </span><span class="s2">= </span><span class="s1">locator</span><span class="s2">.</span><span class="s1">getIndexFormatClass</span><span class="s2">(</span><span class="s1">indexFormat</span><span class="s2">)</span>
                <span class="s1">indexSubTable </span><span class="s2">= </span><span class="s1">indexFormatClass</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>
                <span class="s1">indexSubTable</span><span class="s2">.</span><span class="s1">indexFormat </span><span class="s2">= </span><span class="s1">indexFormat</span>
                <span class="s1">indexSubTable</span><span class="s2">.</span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">indexSubTables</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">indexSubTable</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">BitmapSizeTable</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s4"># Returns all the simple metric names that bitmap size table</span>
    <span class="s4"># cares about in terms of XML creation.</span>
    <span class="s0">def </span><span class="s1">_getXMLMetricNames</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">dataNames </span><span class="s2">= </span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">getformat</span><span class="s2">(</span><span class="s1">bitmapSizeTableFormatPart1</span><span class="s2">)[</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s1">dataNames </span><span class="s2">= {**</span><span class="s1">dataNames</span><span class="s2">, **</span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">getformat</span><span class="s2">(</span><span class="s1">bitmapSizeTableFormatPart2</span><span class="s2">)[</span><span class="s5">1</span><span class="s2">]}</span>
        <span class="s4"># Skip the first 3 data names because they are byte offsets and counts.</span>
        <span class="s0">return </span><span class="s1">list</span><span class="s2">(</span><span class="s1">dataNames</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())[</span><span class="s5">3</span><span class="s2">:]</span>

    <span class="s0">def </span><span class="s1">toXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">begintag</span><span class="s2">(</span><span class="s3">&quot;bitmapSizeTable&quot;</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">metric </span><span class="s0">in </span><span class="s2">(</span><span class="s3">&quot;hori&quot;</span><span class="s2">, </span><span class="s3">&quot;vert&quot;</span><span class="s2">):</span>
            <span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">).</span><span class="s1">toXML</span><span class="s2">(</span><span class="s1">metric</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">metricName </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_getXMLMetricNames</span><span class="s2">():</span>
            <span class="s1">writer</span><span class="s2">.</span><span class="s1">simpletag</span><span class="s2">(</span><span class="s1">metricName</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">metricName</span><span class="s2">))</span>
            <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">endtag</span><span class="s2">(</span><span class="s3">&quot;bitmapSizeTable&quot;</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s4"># Create a lookup for all the simple names that make sense to</span>
        <span class="s4"># bitmap size table. Only read the information from these names.</span>
        <span class="s1">dataNames </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_getXMLMetricNames</span><span class="s2">())</span>
        <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">element</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s0">continue</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content </span><span class="s2">= </span><span class="s1">element</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s2">== </span><span class="s3">&quot;sbitLineMetrics&quot;</span><span class="s2">:</span>
                <span class="s1">direction </span><span class="s2">= </span><span class="s1">attrs</span><span class="s2">[</span><span class="s3">&quot;direction&quot;</span><span class="s2">]</span>
                <span class="s0">assert </span><span class="s1">direction </span><span class="s0">in </span><span class="s2">(</span>
                    <span class="s3">&quot;hori&quot;</span><span class="s2">,</span>
                    <span class="s3">&quot;vert&quot;</span><span class="s2">,</span>
                <span class="s2">), </span><span class="s3">&quot;SbitLineMetrics direction specified invalid.&quot;</span>
                <span class="s1">metricObj </span><span class="s2">= </span><span class="s1">SbitLineMetrics</span><span class="s2">()</span>
                <span class="s1">metricObj</span><span class="s2">.</span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>
                <span class="s1">vars</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)[</span><span class="s1">direction</span><span class="s2">] = </span><span class="s1">metricObj</span>
            <span class="s0">elif </span><span class="s1">name </span><span class="s0">in </span><span class="s1">dataNames</span><span class="s2">:</span>
                <span class="s1">vars</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s3">&quot;value&quot;</span><span class="s2">])</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">log</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;unknown name '%s' being ignored in BitmapSizeTable.&quot;</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">SbitLineMetrics</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">toXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">begintag</span><span class="s2">(</span><span class="s3">&quot;sbitLineMetrics&quot;</span><span class="s2">, [(</span><span class="s3">&quot;direction&quot;</span><span class="s2">, </span><span class="s1">name</span><span class="s2">)])</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s0">for </span><span class="s1">metricName </span><span class="s0">in </span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">getformat</span><span class="s2">(</span><span class="s1">sbitLineMetricsFormat</span><span class="s2">)[</span><span class="s5">1</span><span class="s2">]:</span>
            <span class="s1">writer</span><span class="s2">.</span><span class="s1">simpletag</span><span class="s2">(</span><span class="s1">metricName</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">metricName</span><span class="s2">))</span>
            <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">endtag</span><span class="s2">(</span><span class="s3">&quot;sbitLineMetrics&quot;</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">metricNames </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">getformat</span><span class="s2">(</span><span class="s1">sbitLineMetricsFormat</span><span class="s2">)[</span><span class="s5">1</span><span class="s2">])</span>
        <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">element</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s0">continue</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content </span><span class="s2">= </span><span class="s1">element</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">metricNames</span><span class="s2">:</span>
                <span class="s1">vars</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s3">&quot;value&quot;</span><span class="s2">])</span>


<span class="s4"># Important information about the naming scheme. Used for identifying subtables.</span>
<span class="s1">_indexSubTableSubclassPrefix </span><span class="s2">= </span><span class="s3">&quot;eblc_index_sub_table_&quot;</span>


<span class="s0">class </span><span class="s1">EblcIndexSubTable</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">data</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont </span><span class="s2">= </span><span class="s1">ttFont</span>
        <span class="s4"># TODO Currently non-lazy decompiling doesn't work for this class...</span>
        <span class="s4"># if not ttFont.lazy:</span>
        <span class="s4">#   self.decompile()</span>
        <span class="s4">#   del self.data, self.ttFont</span>

    <span class="s0">def </span><span class="s1">__getattr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">):</span>
        <span class="s4"># Allow lazy decompile.</span>
        <span class="s0">if </span><span class="s1">attr</span><span class="s2">[:</span><span class="s5">2</span><span class="s2">] == </span><span class="s3">&quot;__&quot;</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">attr </span><span class="s2">== </span><span class="s3">&quot;data&quot;</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">AttributeError</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">decompile</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">ensureDecompiled</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">recurse</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s3">&quot;data&quot;</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">decompile</span><span class="s2">()</span>

    <span class="s4"># This method just takes care of the indexSubHeader. Implementing subclasses</span>
    <span class="s4"># should call it to compile the indexSubHeader and then continue compiling</span>
    <span class="s4"># the remainder of their unique format.</span>
    <span class="s0">def </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span>
            <span class="s1">indexSubHeaderFormat</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">indexFormat</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">imageFormat</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">imageDataOffset</span><span class="s2">,</span>
        <span class="s2">)</span>

    <span class="s4"># Creates the XML for bitmap glyphs. Each index sub table basically makes</span>
    <span class="s4"># the same XML except for specific metric information that is written</span>
    <span class="s4"># out via a method call that a subclass implements optionally.</span>
    <span class="s0">def </span><span class="s1">toXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">begintag</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">,</span>
            <span class="s2">[</span>
                <span class="s2">(</span><span class="s3">&quot;imageFormat&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">imageFormat</span><span class="s2">),</span>
                <span class="s2">(</span><span class="s3">&quot;firstGlyphIndex&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">firstGlyphIndex</span><span class="s2">),</span>
                <span class="s2">(</span><span class="s3">&quot;lastGlyphIndex&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">lastGlyphIndex</span><span class="s2">),</span>
            <span class="s2">],</span>
        <span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">writeMetrics</span><span class="s2">(</span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>
        <span class="s4"># Write out the names as thats all thats needed to rebuild etc.</span>
        <span class="s4"># For font debugging of consecutive formats the ids are also written.</span>
        <span class="s4"># The ids are not read when moving from the XML format.</span>
        <span class="s1">glyphIds </span><span class="s2">= </span><span class="s1">map</span><span class="s2">(</span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphID</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">names</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">glyphName</span><span class="s2">, </span><span class="s1">glyphId </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">names</span><span class="s2">, </span><span class="s1">glyphIds</span><span class="s2">):</span>
            <span class="s1">writer</span><span class="s2">.</span><span class="s1">simpletag</span><span class="s2">(</span><span class="s3">&quot;glyphLoc&quot;</span><span class="s2">, </span><span class="s1">name</span><span class="s2">=</span><span class="s1">glyphName</span><span class="s2">, </span><span class="s1">id</span><span class="s2">=</span><span class="s1">glyphId</span><span class="s2">)</span>
            <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">endtag</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s4"># Read all the attributes. Even though the glyph indices are</span>
        <span class="s4"># recalculated, they are still read in case there needs to</span>
        <span class="s4"># be an immediate export of the data.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">imageFormat </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s3">&quot;imageFormat&quot;</span><span class="s2">])</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">firstGlyphIndex </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s3">&quot;firstGlyphIndex&quot;</span><span class="s2">])</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">lastGlyphIndex </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s3">&quot;lastGlyphIndex&quot;</span><span class="s2">])</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">readMetrics</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">names </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">element</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s0">continue</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content </span><span class="s2">= </span><span class="s1">element</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s2">== </span><span class="s3">&quot;glyphLoc&quot;</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">names</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s3">&quot;name&quot;</span><span class="s2">])</span>

    <span class="s4"># A helper method that writes the metrics for the index sub table. It also</span>
    <span class="s4"># is responsible for writing the image size for fixed size data since fixed</span>
    <span class="s4"># size is not recalculated on compile. Default behavior is to do nothing.</span>
    <span class="s0">def </span><span class="s1">writeMetrics</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s0">pass</span>

    <span class="s4"># A helper method that is the inverse of writeMetrics.</span>
    <span class="s0">def </span><span class="s1">readMetrics</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s0">pass</span>

    <span class="s4"># This method is for fixed glyph data sizes. There are formats where</span>
    <span class="s4"># the glyph data is fixed but are actually composite glyphs. To handle</span>
    <span class="s4"># this the font spec in indexSubTable makes the data the size of the</span>
    <span class="s4"># fixed size by padding the component arrays. This function abstracts</span>
    <span class="s4"># out this padding process. Input is data unpadded. Output is data</span>
    <span class="s4"># padded only in fixed formats. Default behavior is to return the data.</span>
    <span class="s0">def </span><span class="s1">padBitmapData</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">data</span>

    <span class="s4"># Remove any of the glyph locations and names that are flagged as skipped.</span>
    <span class="s4"># This only occurs in formats {1,3}.</span>
    <span class="s0">def </span><span class="s1">removeSkipGlyphs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4"># Determines if a name, location pair is a valid data location.</span>
        <span class="s4"># Skip glyphs are marked when the size is equal to zero.</span>
        <span class="s0">def </span><span class="s1">isValidLocation</span><span class="s2">(</span><span class="s1">args</span><span class="s2">):</span>
            <span class="s2">(</span><span class="s1">name</span><span class="s2">, (</span><span class="s1">startByte</span><span class="s2">, </span><span class="s1">endByte</span><span class="s2">)) = </span><span class="s1">args</span>
            <span class="s0">return </span><span class="s1">startByte </span><span class="s2">&lt; </span><span class="s1">endByte</span>

        <span class="s4"># Remove all skip glyphs.</span>
        <span class="s1">dataPairs </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">filter</span><span class="s2">(</span><span class="s1">isValidLocation</span><span class="s2">, </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">names</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">locations</span><span class="s2">)))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">names</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">locations </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">list</span><span class="s2">, </span><span class="s1">zip</span><span class="s2">(*</span><span class="s1">dataPairs</span><span class="s2">)))</span>


<span class="s4"># A closure for creating a custom mixin. This is done because formats 1 and 3</span>
<span class="s4"># are very similar. The only difference between them is the size per offset</span>
<span class="s4"># value. Code put in here should handle both cases generally.</span>
<span class="s0">def </span><span class="s1">_createOffsetArrayIndexSubTableMixin</span><span class="s2">(</span><span class="s1">formatStringForDataType</span><span class="s2">):</span>
    <span class="s4"># Prep the data size for the offset array data format.</span>
    <span class="s1">dataFormat </span><span class="s2">= </span><span class="s3">&quot;&gt;&quot; </span><span class="s2">+ </span><span class="s1">formatStringForDataType</span>
    <span class="s1">offsetDataSize </span><span class="s2">= </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">calcsize</span><span class="s2">(</span><span class="s1">dataFormat</span><span class="s2">)</span>

    <span class="s0">class </span><span class="s1">OffsetArrayIndexSubTableMixin</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">decompile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s1">numGlyphs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">lastGlyphIndex </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">firstGlyphIndex </span><span class="s2">+ </span><span class="s5">1</span>
            <span class="s1">indexingOffsets </span><span class="s2">= [</span>
                <span class="s1">glyphIndex </span><span class="s2">* </span><span class="s1">offsetDataSize </span><span class="s0">for </span><span class="s1">glyphIndex </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">numGlyphs </span><span class="s2">+ </span><span class="s5">2</span><span class="s2">)</span>
            <span class="s2">]</span>
            <span class="s1">indexingLocations </span><span class="s2">= </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">indexingOffsets</span><span class="s2">, </span><span class="s1">indexingOffsets</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:])</span>
            <span class="s1">offsetArray </span><span class="s2">= [</span>
                <span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s1">dataFormat</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">slice</span><span class="s2">(*</span><span class="s1">loc</span><span class="s2">)])[</span><span class="s5">0</span><span class="s2">]</span>
                <span class="s0">for </span><span class="s1">loc </span><span class="s0">in </span><span class="s1">indexingLocations</span>
            <span class="s2">]</span>

            <span class="s1">glyphIds </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">firstGlyphIndex</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">lastGlyphIndex </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">))</span>
            <span class="s1">modifiedOffsets </span><span class="s2">= [</span><span class="s1">offset </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">imageDataOffset </span><span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">offsetArray</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">locations </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">modifiedOffsets</span><span class="s2">, </span><span class="s1">modifiedOffsets</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]))</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">names </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphName</span><span class="s2">, </span><span class="s1">glyphIds</span><span class="s2">))</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">removeSkipGlyphs</span><span class="s2">()</span>
            <span class="s0">del </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont</span>

        <span class="s0">def </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
            <span class="s4"># First make sure that all the data lines up properly. Formats 1 and 3</span>
            <span class="s4"># must have all its data lined up consecutively. If not this will fail.</span>
            <span class="s0">for </span><span class="s1">curLoc</span><span class="s2">, </span><span class="s1">nxtLoc </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">locations</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">locations</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]):</span>
                <span class="s0">assert </span><span class="s2">(</span>
                    <span class="s1">curLoc</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] == </span><span class="s1">nxtLoc</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
                <span class="s2">), </span><span class="s3">&quot;Data must be consecutive in indexSubTable offset formats&quot;</span>

            <span class="s1">glyphIds </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphID</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">names</span><span class="s2">))</span>
            <span class="s4"># Make sure that all ids are sorted strictly increasing.</span>
            <span class="s0">assert </span><span class="s1">all</span><span class="s2">(</span><span class="s1">glyphIds</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] &lt; </span><span class="s1">glyphIds</span><span class="s2">[</span><span class="s1">i </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">glyphIds</span><span class="s2">) - </span><span class="s5">1</span><span class="s2">))</span>

            <span class="s4"># Run a simple algorithm to add skip glyphs to the data locations at</span>
            <span class="s4"># the places where an id is not present.</span>
            <span class="s1">idQueue </span><span class="s2">= </span><span class="s1">deque</span><span class="s2">(</span><span class="s1">glyphIds</span><span class="s2">)</span>
            <span class="s1">locQueue </span><span class="s2">= </span><span class="s1">deque</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">locations</span><span class="s2">)</span>
            <span class="s1">allGlyphIds </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">firstGlyphIndex</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">lastGlyphIndex </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">))</span>
            <span class="s1">allLocations </span><span class="s2">= []</span>
            <span class="s0">for </span><span class="s1">curId </span><span class="s0">in </span><span class="s1">allGlyphIds</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">curId </span><span class="s2">!= </span><span class="s1">idQueue</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]:</span>
                    <span class="s1">allLocations</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">locQueue</span><span class="s2">[</span><span class="s5">0</span><span class="s2">][</span><span class="s5">0</span><span class="s2">], </span><span class="s1">locQueue</span><span class="s2">[</span><span class="s5">0</span><span class="s2">][</span><span class="s5">0</span><span class="s2">]))</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">idQueue</span><span class="s2">.</span><span class="s1">popleft</span><span class="s2">()</span>
                    <span class="s1">allLocations</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">locQueue</span><span class="s2">.</span><span class="s1">popleft</span><span class="s2">())</span>

            <span class="s4"># Now that all the locations are collected, pack them appropriately into</span>
            <span class="s4"># offsets. This is the form where offset[i] is the location and</span>
            <span class="s4"># offset[i+1]-offset[i] is the size of the data location.</span>
            <span class="s1">offsets </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">allLocations</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]) + [</span><span class="s1">loc</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] </span><span class="s0">for </span><span class="s1">loc </span><span class="s0">in </span><span class="s1">allLocations</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]]</span>
            <span class="s4"># Image data offset must be less than or equal to the minimum of locations.</span>
            <span class="s4"># This offset may change the value for round tripping but is safer and</span>
            <span class="s4"># allows imageDataOffset to not be required to be in the XML version.</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">imageDataOffset </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">offsets</span><span class="s2">)</span>
            <span class="s1">offsetArray </span><span class="s2">= [</span><span class="s1">offset </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">imageDataOffset </span><span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">offsets</span><span class="s2">]</span>

            <span class="s1">dataList </span><span class="s2">= [</span><span class="s1">EblcIndexSubTable</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)]</span>
            <span class="s1">dataList </span><span class="s2">+= [</span>
                <span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s1">dataFormat</span><span class="s2">, </span><span class="s1">offsetValue</span><span class="s2">) </span><span class="s0">for </span><span class="s1">offsetValue </span><span class="s0">in </span><span class="s1">offsetArray</span>
            <span class="s2">]</span>
            <span class="s4"># Take care of any padding issues. Only occurs in format 3.</span>
            <span class="s0">if </span><span class="s1">offsetDataSize </span><span class="s2">* </span><span class="s1">len</span><span class="s2">(</span><span class="s1">offsetArray</span><span class="s2">) % </span><span class="s5">4 </span><span class="s2">!= </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s1">dataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s1">dataFormat</span><span class="s2">, </span><span class="s5">0</span><span class="s2">))</span>
            <span class="s0">return </span><span class="s1">bytesjoin</span><span class="s2">(</span><span class="s1">dataList</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">OffsetArrayIndexSubTableMixin</span>


<span class="s4"># A Mixin for functionality shared between the different kinds</span>
<span class="s4"># of fixed sized data handling. Both kinds have big metrics so</span>
<span class="s4"># that kind of special processing is also handled in this mixin.</span>
<span class="s0">class </span><span class="s1">FixedSizeIndexSubTableMixin</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">writeMetrics</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">simpletag</span><span class="s2">(</span><span class="s3">&quot;imageSize&quot;</span><span class="s2">, </span><span class="s1">value</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">imageSize</span><span class="s2">)</span>
        <span class="s1">writer</span><span class="s2">.</span><span class="s1">newline</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">metrics</span><span class="s2">.</span><span class="s1">toXML</span><span class="s2">(</span><span class="s1">writer</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">readMetrics</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content</span><span class="s2">:</span>
            <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">element</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
                <span class="s0">continue</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content </span><span class="s2">= </span><span class="s1">element</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s2">== </span><span class="s3">&quot;imageSize&quot;</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">imageSize </span><span class="s2">= </span><span class="s1">safeEval</span><span class="s2">(</span><span class="s1">attrs</span><span class="s2">[</span><span class="s3">&quot;value&quot;</span><span class="s2">])</span>
            <span class="s0">elif </span><span class="s1">name </span><span class="s2">== </span><span class="s1">BigGlyphMetrics</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">metrics </span><span class="s2">= </span><span class="s1">BigGlyphMetrics</span><span class="s2">()</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">metrics</span><span class="s2">.</span><span class="s1">fromXML</span><span class="s2">(</span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)</span>
            <span class="s0">elif </span><span class="s1">name </span><span class="s2">== </span><span class="s1">SmallGlyphMetrics</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">:</span>
                <span class="s1">log</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span>
                    <span class="s3">&quot;SmallGlyphMetrics being ignored in format %d.&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indexFormat</span>
                <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">padBitmapData</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">):</span>
        <span class="s4"># Make sure that the data isn't bigger than the fixed size.</span>
        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">) &lt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">imageSize</span><span class="s2">, (</span>
            <span class="s3">&quot;Data in indexSubTable format %d must be less than the fixed size.&quot;</span>
            <span class="s2">% </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indexFormat</span>
        <span class="s2">)</span>
        <span class="s4"># Pad the data so that it matches the fixed size.</span>
        <span class="s1">pad </span><span class="s2">= (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">imageSize </span><span class="s2">- </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)) * </span><span class="s6">b&quot;</span><span class="s0">\0</span><span class="s6">&quot;</span>
        <span class="s0">return </span><span class="s1">data </span><span class="s2">+ </span><span class="s1">pad</span>


<span class="s0">class </span><span class="s1">eblc_index_sub_table_1</span><span class="s2">(</span>
    <span class="s1">_createOffsetArrayIndexSubTableMixin</span><span class="s2">(</span><span class="s3">&quot;L&quot;</span><span class="s2">), </span><span class="s1">EblcIndexSubTable</span>
<span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">eblc_index_sub_table_2</span><span class="s2">(</span><span class="s1">FixedSizeIndexSubTableMixin</span><span class="s2">, </span><span class="s1">EblcIndexSubTable</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">decompile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">imageSize</span><span class="s2">,) = </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s3">&quot;&gt;L&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[:</span><span class="s5">4</span><span class="s2">])</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">metrics </span><span class="s2">= </span><span class="s1">BigGlyphMetrics</span><span class="s2">()</span>
        <span class="s1">sstruct</span><span class="s2">.</span><span class="s1">unpack2</span><span class="s2">(</span><span class="s1">bigGlyphMetricsFormat</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s5">4</span><span class="s2">:], </span><span class="s1">self</span><span class="s2">.</span><span class="s1">metrics</span><span class="s2">)</span>
        <span class="s1">glyphIds </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">firstGlyphIndex</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">lastGlyphIndex </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">))</span>
        <span class="s1">offsets </span><span class="s2">= [</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">imageSize </span><span class="s2">* </span><span class="s1">i </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">imageDataOffset </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">glyphIds</span><span class="s2">) + </span><span class="s5">1</span><span class="s2">)</span>
        <span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">locations </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">names </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphName</span><span class="s2">, </span><span class="s1">glyphIds</span><span class="s2">))</span>
        <span class="s0">del </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont</span>

    <span class="s0">def </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">glyphIds </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphID</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">names</span><span class="s2">))</span>
        <span class="s4"># Make sure all the ids are consecutive. This is required by Format 2.</span>
        <span class="s0">assert </span><span class="s1">glyphIds </span><span class="s2">== </span><span class="s1">list</span><span class="s2">(</span>
            <span class="s1">range</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">firstGlyphIndex</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">lastGlyphIndex </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">)</span>
        <span class="s2">), </span><span class="s3">&quot;Format 2 ids must be consecutive.&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">imageDataOffset </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(*</span><span class="s1">self</span><span class="s2">.</span><span class="s1">locations</span><span class="s2">))))</span>

        <span class="s1">dataList </span><span class="s2">= [</span><span class="s1">EblcIndexSubTable</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)]</span>
        <span class="s1">dataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s3">&quot;&gt;L&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">imageSize</span><span class="s2">))</span>
        <span class="s1">dataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s1">bigGlyphMetricsFormat</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">metrics</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">bytesjoin</span><span class="s2">(</span><span class="s1">dataList</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">eblc_index_sub_table_3</span><span class="s2">(</span>
    <span class="s1">_createOffsetArrayIndexSubTableMixin</span><span class="s2">(</span><span class="s3">&quot;H&quot;</span><span class="s2">), </span><span class="s1">EblcIndexSubTable</span>
<span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">eblc_index_sub_table_4</span><span class="s2">(</span><span class="s1">EblcIndexSubTable</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">decompile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s2">(</span><span class="s1">numGlyphs</span><span class="s2">,) = </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s3">&quot;&gt;L&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[:</span><span class="s5">4</span><span class="s2">])</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s5">4</span><span class="s2">:]</span>
        <span class="s1">indexingOffsets </span><span class="s2">= [</span>
            <span class="s1">glyphIndex </span><span class="s2">* </span><span class="s1">codeOffsetPairSize </span><span class="s0">for </span><span class="s1">glyphIndex </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">numGlyphs </span><span class="s2">+ </span><span class="s5">2</span><span class="s2">)</span>
        <span class="s2">]</span>
        <span class="s1">indexingLocations </span><span class="s2">= </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">indexingOffsets</span><span class="s2">, </span><span class="s1">indexingOffsets</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:])</span>
        <span class="s1">glyphArray </span><span class="s2">= [</span>
            <span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s1">codeOffsetPairFormat</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s1">slice</span><span class="s2">(*</span><span class="s1">loc</span><span class="s2">)])</span>
            <span class="s0">for </span><span class="s1">loc </span><span class="s0">in </span><span class="s1">indexingLocations</span>
        <span class="s2">]</span>
        <span class="s1">glyphIds</span><span class="s2">, </span><span class="s1">offsets </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">list</span><span class="s2">, </span><span class="s1">zip</span><span class="s2">(*</span><span class="s1">glyphArray</span><span class="s2">)))</span>
        <span class="s4"># There are one too many glyph ids. Get rid of the last one.</span>
        <span class="s1">glyphIds</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">()</span>

        <span class="s1">offsets </span><span class="s2">= [</span><span class="s1">offset </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">imageDataOffset </span><span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">offsets</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">locations </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">names </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphName</span><span class="s2">, </span><span class="s1">glyphIds</span><span class="s2">))</span>
        <span class="s0">del </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont</span>

    <span class="s0">def </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s4"># First make sure that all the data lines up properly. Format 4</span>
        <span class="s4"># must have all its data lined up consecutively. If not this will fail.</span>
        <span class="s0">for </span><span class="s1">curLoc</span><span class="s2">, </span><span class="s1">nxtLoc </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">locations</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">locations</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]):</span>
            <span class="s0">assert </span><span class="s2">(</span>
                <span class="s1">curLoc</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] == </span><span class="s1">nxtLoc</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
            <span class="s2">), </span><span class="s3">&quot;Data must be consecutive in indexSubTable format 4&quot;</span>

        <span class="s1">offsets </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">locations</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]) + [</span><span class="s1">loc</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] </span><span class="s0">for </span><span class="s1">loc </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">locations</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]]</span>
        <span class="s4"># Image data offset must be less than or equal to the minimum of locations.</span>
        <span class="s4"># Resetting this offset may change the value for round tripping but is safer</span>
        <span class="s4"># and allows imageDataOffset to not be required to be in the XML version.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">imageDataOffset </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">offsets</span><span class="s2">)</span>
        <span class="s1">offsets </span><span class="s2">= [</span><span class="s1">offset </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">imageDataOffset </span><span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">offsets</span><span class="s2">]</span>
        <span class="s1">glyphIds </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphID</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">names</span><span class="s2">))</span>
        <span class="s4"># Create an iterator over the ids plus a padding value.</span>
        <span class="s1">idsPlusPad </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">itertools</span><span class="s2">.</span><span class="s1">chain</span><span class="s2">(</span><span class="s1">glyphIds</span><span class="s2">, [</span><span class="s5">0</span><span class="s2">]))</span>

        <span class="s1">dataList </span><span class="s2">= [</span><span class="s1">EblcIndexSubTable</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)]</span>
        <span class="s1">dataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s3">&quot;&gt;L&quot;</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">glyphIds</span><span class="s2">)))</span>
        <span class="s1">tmp </span><span class="s2">= [</span>
            <span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s1">codeOffsetPairFormat</span><span class="s2">, *</span><span class="s1">cop</span><span class="s2">) </span><span class="s0">for </span><span class="s1">cop </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">idsPlusPad</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">)</span>
        <span class="s2">]</span>
        <span class="s1">dataList </span><span class="s2">+= </span><span class="s1">tmp</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">bytesjoin</span><span class="s2">(</span><span class="s1">dataList</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">data</span>


<span class="s0">class </span><span class="s1">eblc_index_sub_table_5</span><span class="s2">(</span><span class="s1">FixedSizeIndexSubTableMixin</span><span class="s2">, </span><span class="s1">EblcIndexSubTable</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">decompile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">origDataLen </span><span class="s2">= </span><span class="s5">0</span>
        <span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">imageSize</span><span class="s2">,) = </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s3">&quot;&gt;L&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[:</span><span class="s5">4</span><span class="s2">])</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s5">4</span><span class="s2">:]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">metrics</span><span class="s2">, </span><span class="s1">data </span><span class="s2">= </span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">unpack2</span><span class="s2">(</span>
            <span class="s1">bigGlyphMetricsFormat</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">BigGlyphMetrics</span><span class="s2">()</span>
        <span class="s2">)</span>
        <span class="s2">(</span><span class="s1">numGlyphs</span><span class="s2">,) = </span><span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s3">&quot;&gt;L&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[:</span><span class="s5">4</span><span class="s2">])</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">data</span><span class="s2">[</span><span class="s5">4</span><span class="s2">:]</span>
        <span class="s1">glyphIds </span><span class="s2">= [</span>
            <span class="s1">struct</span><span class="s2">.</span><span class="s1">unpack</span><span class="s2">(</span><span class="s3">&quot;&gt;H&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">[</span><span class="s5">2 </span><span class="s2">* </span><span class="s1">i </span><span class="s2">: </span><span class="s5">2 </span><span class="s2">* (</span><span class="s1">i </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">)])[</span><span class="s5">0</span><span class="s2">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">numGlyphs</span><span class="s2">)</span>
        <span class="s2">]</span>

        <span class="s1">offsets </span><span class="s2">= [</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">imageSize </span><span class="s2">* </span><span class="s1">i </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">imageDataOffset </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">glyphIds</span><span class="s2">) + </span><span class="s5">1</span><span class="s2">)</span>
        <span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">locations </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:]))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">names </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphName</span><span class="s2">, </span><span class="s1">glyphIds</span><span class="s2">))</span>
        <span class="s0">del </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ttFont</span>

    <span class="s0">def </span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">imageDataOffset </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">next</span><span class="s2">(</span><span class="s1">iter</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(*</span><span class="s1">self</span><span class="s2">.</span><span class="s1">locations</span><span class="s2">))))</span>
        <span class="s1">dataList </span><span class="s2">= [</span><span class="s1">EblcIndexSubTable</span><span class="s2">.</span><span class="s1">compile</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ttFont</span><span class="s2">)]</span>
        <span class="s1">dataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s3">&quot;&gt;L&quot;</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">imageSize</span><span class="s2">))</span>
        <span class="s1">dataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">sstruct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s1">bigGlyphMetricsFormat</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">metrics</span><span class="s2">))</span>
        <span class="s1">glyphIds </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">ttFont</span><span class="s2">.</span><span class="s1">getGlyphID</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">names</span><span class="s2">))</span>
        <span class="s1">dataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s3">&quot;&gt;L&quot;</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">glyphIds</span><span class="s2">)))</span>
        <span class="s1">dataList </span><span class="s2">+= [</span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s3">&quot;&gt;H&quot;</span><span class="s2">, </span><span class="s1">curId</span><span class="s2">) </span><span class="s0">for </span><span class="s1">curId </span><span class="s0">in </span><span class="s1">glyphIds</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">glyphIds</span><span class="s2">) % </span><span class="s5">2 </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">dataList</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">struct</span><span class="s2">.</span><span class="s1">pack</span><span class="s2">(</span><span class="s3">&quot;&gt;H&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">bytesjoin</span><span class="s2">(</span><span class="s1">dataList</span><span class="s2">)</span>


<span class="s4"># Dictionary of indexFormat to the class representing that format.</span>
<span class="s1">eblc_sub_table_classes </span><span class="s2">= {</span>
    <span class="s5">1</span><span class="s2">: </span><span class="s1">eblc_index_sub_table_1</span><span class="s2">,</span>
    <span class="s5">2</span><span class="s2">: </span><span class="s1">eblc_index_sub_table_2</span><span class="s2">,</span>
    <span class="s5">3</span><span class="s2">: </span><span class="s1">eblc_index_sub_table_3</span><span class="s2">,</span>
    <span class="s5">4</span><span class="s2">: </span><span class="s1">eblc_index_sub_table_4</span><span class="s2">,</span>
    <span class="s5">5</span><span class="s2">: </span><span class="s1">eblc_index_sub_table_5</span><span class="s2">,</span>
<span class="s2">}</span>
</pre>
</body>
</html>