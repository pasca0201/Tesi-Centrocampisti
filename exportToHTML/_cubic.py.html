<html>
<head>
<title>_cubic.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_cubic.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Interpolation algorithms using piecewise cubic polynomials.&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span>

<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">linalg </span><span class="s2">import </span><span class="s1">solve</span><span class="s3">, </span><span class="s1">solve_banded</span>

<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">PPoly</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_polyint </span><span class="s2">import </span><span class="s1">_isscalar</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Literal</span>

<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">&quot;CubicHermiteSpline&quot;</span><span class="s3">, </span><span class="s4">&quot;PchipInterpolator&quot;</span><span class="s3">, </span><span class="s4">&quot;pchip_interpolate&quot;</span><span class="s3">,</span>
           <span class="s4">&quot;Akima1DInterpolator&quot;</span><span class="s3">, </span><span class="s4">&quot;CubicSpline&quot;</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">prepare_input</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dydx</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Prepare input for cubic spline interpolators. 
 
    All data are converted to numpy arrays and checked for correctness. 
    Axes equal to `axis` of arrays `y` and `dydx` are moved to be the 0th 
    axis. The value of `axis` is converted to lie in 
    [0, number of dimensions of `y`). 
    &quot;&quot;&quot;</span>

    <span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">map</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">, (</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;`x` must contain real values.&quot;</span><span class="s3">)</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">):</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">complex</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">float</span>

    <span class="s2">if </span><span class="s1">dydx </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">dydx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">dydx</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">y</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= </span><span class="s1">dydx</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;The shapes of `y` and `dydx` must be identical.&quot;</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">dydx</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">):</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">complex</span>
        <span class="s1">dydx </span><span class="s3">= </span><span class="s1">dydx</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s1">y </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">axis </span><span class="s3">= </span><span class="s1">axis </span><span class="s3">% </span><span class="s1">y</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;`x` must be 1-dimensional.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] &lt; </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;`x` must contain at least 2 elements.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] != </span><span class="s1">y</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;The length of `y` along `axis`=</span><span class="s2">{</span><span class="s1">axis</span><span class="s2">} </span><span class="s4">doesn't &quot;</span>
                         <span class="s4">&quot;match the length of `x`&quot;</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;`x` must contain only finite values.&quot;</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;`y` must contain only finite values.&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">dydx </span><span class="s2">is not None and not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">dydx</span><span class="s3">)):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;`dydx` must contain only finite values.&quot;</span><span class="s3">)</span>

    <span class="s1">dx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">dx </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;`x` must be strictly increasing sequence.&quot;</span><span class="s3">)</span>

    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">dydx </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">dydx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">dydx</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dydx</span>


<span class="s2">class </span><span class="s1">CubicHermiteSpline</span><span class="s3">(</span><span class="s1">PPoly</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Piecewise-cubic interpolator matching values and first derivatives. 
 
    The result is represented as a `PPoly` instance. 
 
    Parameters 
    ---------- 
    x : array_like, shape (n,) 
        1-D array containing values of the independent variable. 
        Values must be real, finite and in strictly increasing order. 
    y : array_like 
        Array containing values of the dependent variable. It can have 
        arbitrary number of dimensions, but the length along ``axis`` 
        (see below) must match the length of ``x``. Values must be finite. 
    dydx : array_like 
        Array containing derivatives of the dependent variable. It can have 
        arbitrary number of dimensions, but the length along ``axis`` 
        (see below) must match the length of ``x``. Values must be finite. 
    axis : int, optional 
        Axis along which `y` is assumed to be varying. Meaning that for 
        ``x[i]`` the corresponding values are ``np.take(y, i, axis=axis)``. 
        Default is 0. 
    extrapolate : {bool, 'periodic', None}, optional 
        If bool, determines whether to extrapolate to out-of-bounds points 
        based on first and last intervals, or to return NaNs. If 'periodic', 
        periodic extrapolation is used. If None (default), it is set to True. 
 
    Attributes 
    ---------- 
    x : ndarray, shape (n,) 
        Breakpoints. The same ``x`` which was passed to the constructor. 
    c : ndarray, shape (4, n-1, ...) 
        Coefficients of the polynomials on each segment. The trailing 
        dimensions match the dimensions of `y`, excluding ``axis``. 
        For example, if `y` is 1-D, then ``c[k, i]`` is a coefficient for 
        ``(x-x[i])**(3-k)`` on the segment between ``x[i]`` and ``x[i+1]``. 
    axis : int 
        Interpolation axis. The same axis which was passed to the 
        constructor. 
 
    Methods 
    ------- 
    __call__ 
    derivative 
    antiderivative 
    integrate 
    roots 
 
    See Also 
    -------- 
    Akima1DInterpolator : Akima 1D interpolator. 
    PchipInterpolator : PCHIP 1-D monotonic cubic interpolator. 
    CubicSpline : Cubic spline data interpolator. 
    PPoly : Piecewise polynomial in terms of coefficients and breakpoints 
 
    Notes 
    ----- 
    If you want to create a higher-order spline matching higher-order 
    derivatives, use `BPoly.from_derivatives`. 
 
    References 
    ---------- 
    .. [1] `Cubic Hermite spline 
            &lt;https://en.wikipedia.org/wiki/Cubic_Hermite_spline&gt;`_ 
            on Wikipedia. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">dydx</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">extrapolate</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">extrapolate </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">extrapolate </span><span class="s3">= </span><span class="s2">True</span>

        <span class="s1">x</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dydx </span><span class="s3">= </span><span class="s1">prepare_input</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dydx</span><span class="s3">)</span>

        <span class="s1">dxr </span><span class="s3">= </span><span class="s1">dx</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">([</span><span class="s1">dx</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]] + [</span><span class="s5">1</span><span class="s3">] * (</span><span class="s1">y</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">))</span>
        <span class="s1">slope </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">) / </span><span class="s1">dxr</span>
        <span class="s1">t </span><span class="s3">= (</span><span class="s1">dydx</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">] + </span><span class="s1">dydx</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] - </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">slope</span><span class="s3">) / </span><span class="s1">dxr</span>

        <span class="s1">c </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s5">4</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">) + </span><span class="s1">y</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">t</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">c</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">t </span><span class="s3">/ </span><span class="s1">dxr</span>
        <span class="s1">c</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = (</span><span class="s1">slope </span><span class="s3">- </span><span class="s1">dydx</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]) / </span><span class="s1">dxr </span><span class="s3">- </span><span class="s1">t</span>
        <span class="s1">c</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">dydx</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s1">c</span><span class="s3">[</span><span class="s5">3</span><span class="s3">] = </span><span class="s1">y</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]</span>

        <span class="s1">super</span><span class="s3">().</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">extrapolate</span><span class="s3">=</span><span class="s1">extrapolate</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">axis </span><span class="s3">= </span><span class="s1">axis</span>


<span class="s2">class </span><span class="s1">PchipInterpolator</span><span class="s3">(</span><span class="s1">CubicHermiteSpline</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot;PCHIP 1-D monotonic cubic interpolation. 
 
    ``x`` and ``y`` are arrays of values used to approximate some function f, 
    with ``y = f(x)``. The interpolant uses monotonic cubic splines 
    to find the value of new points. (PCHIP stands for Piecewise Cubic 
    Hermite Interpolating Polynomial). 
 
    Parameters 
    ---------- 
    x : ndarray, shape (npoints, ) 
        A 1-D array of monotonically increasing real values. ``x`` cannot 
        include duplicate values (otherwise f is overspecified) 
    y : ndarray, shape (..., npoints, ...) 
        A N-D array of real values. ``y``'s length along the interpolation 
        axis must be equal to the length of ``x``. Use the ``axis`` 
        parameter to select the interpolation axis. 
 
        .. deprecated:: 1.13.0 
            Complex data is deprecated and will raise an error in SciPy 1.15.0. 
            If you are trying to use the real components of the passed array, 
            use ``np.real`` on ``y``. 
 
    axis : int, optional 
        Axis in the ``y`` array corresponding to the x-coordinate values. Defaults 
        to ``axis=0``. 
    extrapolate : bool, optional 
        Whether to extrapolate to out-of-bounds points based on first 
        and last intervals, or to return NaNs. 
 
    Methods 
    ------- 
    __call__ 
    derivative 
    antiderivative 
    roots 
 
    See Also 
    -------- 
    CubicHermiteSpline : Piecewise-cubic interpolator. 
    Akima1DInterpolator : Akima 1D interpolator. 
    CubicSpline : Cubic spline data interpolator. 
    PPoly : Piecewise polynomial in terms of coefficients and breakpoints. 
 
    Notes 
    ----- 
    The interpolator preserves monotonicity in the interpolation data and does 
    not overshoot if the data is not smooth. 
 
    The first derivatives are guaranteed to be continuous, but the second 
    derivatives may jump at :math:`x_k`. 
 
    Determines the derivatives at the points :math:`x_k`, :math:`f'_k`, 
    by using PCHIP algorithm [1]_. 
 
    Let :math:`h_k = x_{k+1} - x_k`, and  :math:`d_k = (y_{k+1} - y_k) / h_k` 
    are the slopes at internal points :math:`x_k`. 
    If the signs of :math:`d_k` and :math:`d_{k-1}` are different or either of 
    them equals zero, then :math:`f'_k = 0`. Otherwise, it is given by the 
    weighted harmonic mean 
 
    .. math:: 
 
        \frac{w_1 + w_2}{f'_k} = \frac{w_1}{d_{k-1}} + \frac{w_2}{d_k} 
 
    where :math:`w_1 = 2 h_k + h_{k-1}` and :math:`w_2 = h_k + 2 h_{k-1}`. 
 
    The end slopes are set using a one-sided scheme [2]_. 
 
 
    References 
    ---------- 
    .. [1] F. N. Fritsch and J. Butland, 
           A method for constructing local 
           monotone piecewise cubic interpolants, 
           SIAM J. Sci. Comput., 5(2), 300-304 (1984). 
           :doi:`10.1137/0905021`. 
    .. [2] see, e.g., C. Moler, Numerical Computing with Matlab, 2004. 
           :doi:`10.1137/1.9780898717952` 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">extrapolate</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">prepare_input</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">y</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;`PchipInterpolator` only works with real values for `y`. &quot;</span>
                   <span class="s4">&quot;Passing an array with a complex dtype for `y` is deprecated &quot;</span>
                   <span class="s4">&quot;and will raise an error in SciPy 1.15.0. If you are trying to &quot;</span>
                   <span class="s4">&quot;use the real components of the passed array, use `np.real` on &quot;</span>
                   <span class="s4">&quot;the array before passing to `PchipInterpolator`.&quot;</span><span class="s3">)</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
        <span class="s1">xp </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">((</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">],) + (</span><span class="s5">1</span><span class="s3">,)*(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">-</span><span class="s5">1</span><span class="s3">))</span>
        <span class="s1">dk </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_find_derivatives</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">dk</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">extrapolate</span><span class="s3">=</span><span class="s1">extrapolate</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">axis </span><span class="s3">= </span><span class="s1">axis</span>

    <span class="s3">@</span><span class="s1">staticmethod</span>
    <span class="s2">def </span><span class="s1">_edge_case</span><span class="s3">(</span><span class="s1">h0</span><span class="s3">, </span><span class="s1">h1</span><span class="s3">, </span><span class="s1">m0</span><span class="s3">, </span><span class="s1">m1</span><span class="s3">):</span>
        <span class="s6"># one-sided three-point estimate for the derivative</span>
        <span class="s1">d </span><span class="s3">= ((</span><span class="s5">2</span><span class="s3">*</span><span class="s1">h0 </span><span class="s3">+ </span><span class="s1">h1</span><span class="s3">)*</span><span class="s1">m0 </span><span class="s3">- </span><span class="s1">h0</span><span class="s3">*</span><span class="s1">m1</span><span class="s3">) / (</span><span class="s1">h0 </span><span class="s3">+ </span><span class="s1">h1</span><span class="s3">)</span>

        <span class="s6"># try to preserve shape</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sign</span><span class="s3">(</span><span class="s1">d</span><span class="s3">) != </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sign</span><span class="s3">(</span><span class="s1">m0</span><span class="s3">)</span>
        <span class="s1">mask2 </span><span class="s3">= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sign</span><span class="s3">(</span><span class="s1">m0</span><span class="s3">) != </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sign</span><span class="s3">(</span><span class="s1">m1</span><span class="s3">)) &amp; (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">d</span><span class="s3">) &gt; </span><span class="s5">3.</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">m0</span><span class="s3">))</span>
        <span class="s1">mmm </span><span class="s3">= (~</span><span class="s1">mask</span><span class="s3">) &amp; </span><span class="s1">mask2</span>

        <span class="s1">d</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">] = </span><span class="s5">0.</span>
        <span class="s1">d</span><span class="s3">[</span><span class="s1">mmm</span><span class="s3">] = </span><span class="s5">3.</span><span class="s3">*</span><span class="s1">m0</span><span class="s3">[</span><span class="s1">mmm</span><span class="s3">]</span>

        <span class="s2">return </span><span class="s1">d</span>

    <span class="s3">@</span><span class="s1">staticmethod</span>
    <span class="s2">def </span><span class="s1">_find_derivatives</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">):</span>
        <span class="s6"># Determine the derivatives at the points y_k, d_k, by using</span>
        <span class="s6">#  PCHIP algorithm is:</span>
        <span class="s6"># We choose the derivatives at the point x_k by</span>
        <span class="s6"># Let m_k be the slope of the kth segment (between k and k+1)</span>
        <span class="s6"># If m_k=0 or m_{k-1}=0 or sgn(m_k) != sgn(m_{k-1}) then d_k == 0</span>
        <span class="s6"># else use weighted harmonic mean:</span>
        <span class="s6">#   w_1 = 2h_k + h_{k-1}, w_2 = h_k + 2h_{k-1}</span>
        <span class="s6">#   1/d_k = 1/(w_1 + w_2)*(w_1 / m_k + w_2 / m_{k-1})</span>
        <span class="s6">#   where h_k is the spacing between x_k and x_{k+1}</span>
        <span class="s1">y_shape </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s2">if </span><span class="s1">y</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s6"># So that _edge_case doesn't end up assigning to scalars</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[:, </span><span class="s2">None</span><span class="s3">]</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s1">y</span><span class="s3">[:, </span><span class="s2">None</span><span class="s3">]</span>

        <span class="s1">hk </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] - </span><span class="s1">x</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s1">mk </span><span class="s3">= (</span><span class="s1">y</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] - </span><span class="s1">y</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]) / </span><span class="s1">hk</span>

        <span class="s2">if </span><span class="s1">y</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s5">2</span><span class="s3">:</span>
            <span class="s6"># edge case: only have two points, use linear interpolation</span>
            <span class="s1">dk </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
            <span class="s1">dk</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">mk</span>
            <span class="s1">dk</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">mk</span>
            <span class="s2">return </span><span class="s1">dk</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">y_shape</span><span class="s3">)</span>

        <span class="s1">smk </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sign</span><span class="s3">(</span><span class="s1">mk</span><span class="s3">)</span>
        <span class="s1">condition </span><span class="s3">= (</span><span class="s1">smk</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] != </span><span class="s1">smk</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]) | (</span><span class="s1">mk</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] == </span><span class="s5">0</span><span class="s3">) | (</span><span class="s1">mk</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">] == </span><span class="s5">0</span><span class="s3">)</span>

        <span class="s1">w1 </span><span class="s3">= </span><span class="s5">2</span><span class="s3">*</span><span class="s1">hk</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] + </span><span class="s1">hk</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s1">w2 </span><span class="s3">= </span><span class="s1">hk</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] + </span><span class="s5">2</span><span class="s3">*</span><span class="s1">hk</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]</span>

        <span class="s6"># values where division by zero occurs will be excluded</span>
        <span class="s6"># by 'condition' afterwards</span>
        <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">divide</span><span class="s3">=</span><span class="s4">'ignore'</span><span class="s3">, </span><span class="s1">invalid</span><span class="s3">=</span><span class="s4">'ignore'</span><span class="s3">):</span>
            <span class="s1">whmean </span><span class="s3">= (</span><span class="s1">w1</span><span class="s3">/</span><span class="s1">mk</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">] + </span><span class="s1">w2</span><span class="s3">/</span><span class="s1">mk</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]) / (</span><span class="s1">w1 </span><span class="s3">+ </span><span class="s1">w2</span><span class="s3">)</span>

        <span class="s1">dk </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">dk</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:-</span><span class="s5">1</span><span class="s3">][</span><span class="s1">condition</span><span class="s3">] = </span><span class="s5">0.0</span>
        <span class="s1">dk</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:-</span><span class="s5">1</span><span class="s3">][~</span><span class="s1">condition</span><span class="s3">] = </span><span class="s5">1.0 </span><span class="s3">/ </span><span class="s1">whmean</span><span class="s3">[~</span><span class="s1">condition</span><span class="s3">]</span>

        <span class="s6"># special case endpoints, as suggested in</span>
        <span class="s6"># Cleve Moler, Numerical Computing with MATLAB, Chap 3.6 (pchiptx.m)</span>
        <span class="s1">dk</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">PchipInterpolator</span><span class="s3">.</span><span class="s1">_edge_case</span><span class="s3">(</span><span class="s1">hk</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">hk</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">mk</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">mk</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
        <span class="s1">dk</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">PchipInterpolator</span><span class="s3">.</span><span class="s1">_edge_case</span><span class="s3">(</span><span class="s1">hk</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">hk</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">], </span><span class="s1">mk</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">mk</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">])</span>

        <span class="s2">return </span><span class="s1">dk</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">y_shape</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">pchip_interpolate</span><span class="s3">(</span><span class="s1">xi</span><span class="s3">, </span><span class="s1">yi</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">der</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convenience function for pchip interpolation. 
 
    xi and yi are arrays of values used to approximate some function f, 
    with ``yi = f(xi)``. The interpolant uses monotonic cubic splines 
    to find the value of new points x and the derivatives there. 
 
    See `scipy.interpolate.PchipInterpolator` for details. 
 
    Parameters 
    ---------- 
    xi : array_like 
        A sorted list of x-coordinates, of length N. 
    yi : array_like 
        A 1-D array of real values. `yi`'s length along the interpolation 
        axis must be equal to the length of `xi`. If N-D array, use axis 
        parameter to select correct axis. 
 
        .. deprecated:: 1.13.0 
            Complex data is deprecated and will raise an error in 
            SciPy 1.15.0. If you are trying to use the real components of 
            the passed array, use ``np.real`` on `yi`. 
 
    x : scalar or array_like 
        Of length M. 
    der : int or list, optional 
        Derivatives to extract. The 0th derivative can be included to 
        return the function value. 
    axis : int, optional 
        Axis in the yi array corresponding to the x-coordinate values. 
 
    Returns 
    ------- 
    y : scalar or array_like 
        The result, of length R or length M or M by R. 
 
    See Also 
    -------- 
    PchipInterpolator : PCHIP 1-D monotonic cubic interpolator. 
 
    Examples 
    -------- 
    We can interpolate 2D observed data using pchip interpolation: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.interpolate import pchip_interpolate 
    &gt;&gt;&gt; x_observed = np.linspace(0.0, 10.0, 11) 
    &gt;&gt;&gt; y_observed = np.sin(x_observed) 
    &gt;&gt;&gt; x = np.linspace(min(x_observed), max(x_observed), num=100) 
    &gt;&gt;&gt; y = pchip_interpolate(x_observed, y_observed, x) 
    &gt;&gt;&gt; plt.plot(x_observed, y_observed, &quot;o&quot;, label=&quot;observation&quot;) 
    &gt;&gt;&gt; plt.plot(x, y, label=&quot;pchip interpolation&quot;) 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">P </span><span class="s3">= </span><span class="s1">PchipInterpolator</span><span class="s3">(</span><span class="s1">xi</span><span class="s3">, </span><span class="s1">yi</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">der </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">P</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">_isscalar</span><span class="s3">(</span><span class="s1">der</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">P</span><span class="s3">.</span><span class="s1">derivative</span><span class="s3">(</span><span class="s1">der</span><span class="s3">)(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">P</span><span class="s3">.</span><span class="s1">derivative</span><span class="s3">(</span><span class="s1">nu</span><span class="s3">)(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">for </span><span class="s1">nu </span><span class="s2">in </span><span class="s1">der</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">Akima1DInterpolator</span><span class="s3">(</span><span class="s1">CubicHermiteSpline</span><span class="s3">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Akima interpolator 
 
    Fit piecewise cubic polynomials, given vectors x and y. The interpolation 
    method by Akima uses a continuously differentiable sub-spline built from 
    piecewise cubic polynomials. The resultant curve passes through the given 
    data points and will appear smooth and natural. 
 
    Parameters 
    ---------- 
    x : ndarray, shape (npoints, ) 
        1-D array of monotonically increasing real values. 
    y : ndarray, shape (..., npoints, ...) 
        N-D array of real values. The length of ``y`` along the interpolation axis 
        must be equal to the length of ``x``. Use the ``axis`` parameter to 
        select the interpolation axis. 
 
        .. deprecated:: 1.13.0 
            Complex data is deprecated and will raise an error in SciPy 1.15.0. 
            If you are trying to use the real components of the passed array, 
            use ``np.real`` on ``y``. 
 
    axis : int, optional 
        Axis in the ``y`` array corresponding to the x-coordinate values. Defaults 
        to ``axis=0``. 
    method : {'akima', 'makima'}, optional 
        If ``&quot;makima&quot;``, use the modified Akima interpolation [2]_. 
        Defaults to ``&quot;akima&quot;``, use the Akima interpolation [1]_. 
 
        .. versionadded:: 1.13.0 
 
    extrapolate : {bool, None}, optional 
        If bool, determines whether to extrapolate to out-of-bounds points  
        based on first and last intervals, or to return NaNs. If None,  
        ``extrapolate`` is set to False. 
         
    Methods 
    ------- 
    __call__ 
    derivative 
    antiderivative 
    roots 
 
    See Also 
    -------- 
    PchipInterpolator : PCHIP 1-D monotonic cubic interpolator. 
    CubicSpline : Cubic spline data interpolator. 
    PPoly : Piecewise polynomial in terms of coefficients and breakpoints 
 
    Notes 
    ----- 
    .. versionadded:: 0.14 
 
    Use only for precise data, as the fitted curve passes through the given 
    points exactly. This routine is useful for plotting a pleasingly smooth 
    curve through a few given points for purposes of plotting. 
 
    Let :math:`\delta_i = (y_{i+1} - y_i) / (x_{i+1} - x_i)` be the slopes of 
    the interval :math:`\left[x_i, x_{i+1}\right)`. Akima's derivative at 
    :math:`x_i` is defined as: 
 
    .. math:: 
 
        d_i = \frac{w_1}{w_1 + w_2}\delta_{i-1} + \frac{w_2}{w_1 + w_2}\delta_i 
 
    In the Akima interpolation [1]_ (``method=&quot;akima&quot;``), the weights are: 
 
    .. math:: 
 
        \begin{aligned} 
        w_1 &amp;= |\delta_{i+1} - \delta_i| \\ 
        w_2 &amp;= |\delta_{i-1} - \delta_{i-2}| 
        \end{aligned} 
 
    In the modified Akima interpolation [2]_ (``method=&quot;makima&quot;``), 
    to eliminate overshoot and avoid edge cases of both numerator and 
    denominator being equal to 0, the weights are modified as follows: 
 
    .. math:: 
 
        \begin{align*} 
        w_1 &amp;= |\delta_{i+1} - \delta_i| + |\delta_{i+1} + \delta_i| / 2 \\ 
        w_2 &amp;= |\delta_{i-1} - \delta_{i-2}| + |\delta_{i-1} + \delta_{i-2}| / 2 
        \end{align*} 
 
    Examples 
    -------- 
    Comparison of ``method=&quot;akima&quot;`` and ``method=&quot;makima&quot;``: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.interpolate import Akima1DInterpolator 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.linspace(1, 7, 7) 
    &gt;&gt;&gt; y = np.array([-1, -1, -1, 0, 1, 1, 1]) 
    &gt;&gt;&gt; xs = np.linspace(min(x), max(x), num=100) 
    &gt;&gt;&gt; y_akima = Akima1DInterpolator(x, y, method=&quot;akima&quot;)(xs) 
    &gt;&gt;&gt; y_makima = Akima1DInterpolator(x, y, method=&quot;makima&quot;)(xs) 
 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(x, y, &quot;o&quot;, label=&quot;data&quot;) 
    &gt;&gt;&gt; ax.plot(xs, y_akima, label=&quot;akima&quot;) 
    &gt;&gt;&gt; ax.plot(xs, y_makima, label=&quot;makima&quot;) 
    &gt;&gt;&gt; ax.legend() 
    &gt;&gt;&gt; fig.show() 
 
    The overshoot that occured in ``&quot;akima&quot;`` has been avoided in ``&quot;makima&quot;``. 
 
    References 
    ---------- 
    .. [1] A new method of interpolation and smooth curve fitting based 
           on local procedures. Hiroshi Akima, J. ACM, October 1970, 17(4), 
           589-602. :doi:`10.1145/321607.321609` 
    .. [2] Makima Piecewise Cubic Interpolation. Cleve Moler and Cosmin Ionita, 2019. 
           https://blogs.mathworks.com/cleve/2019/04/29/makima-piecewise-cubic-interpolation/ 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, *, </span><span class="s1">method</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">&quot;akima&quot;</span><span class="s3">, </span><span class="s4">&quot;makima&quot;</span><span class="s3">]=</span><span class="s4">&quot;akima&quot;</span><span class="s3">, </span>
                 <span class="s1">extrapolate</span><span class="s3">:</span><span class="s1">bool </span><span class="s3">| </span><span class="s2">None </span><span class="s3">= </span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">method </span><span class="s2">not in </span><span class="s3">{</span><span class="s4">&quot;akima&quot;</span><span class="s3">, </span><span class="s4">&quot;makima&quot;</span><span class="s3">}:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">f&quot;`method`=</span><span class="s2">{</span><span class="s1">method</span><span class="s2">} </span><span class="s4">is unsupported.&quot;</span><span class="s3">)</span>
        <span class="s6"># Original implementation in MATLAB by N. Shamsundar (BSD licensed), see</span>
        <span class="s6"># https://www.mathworks.com/matlabcentral/fileexchange/1814-akima-interpolation</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">prepare_input</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">y</span><span class="s3">):</span>
            <span class="s1">msg </span><span class="s3">= (</span><span class="s4">&quot;`Akima1DInterpolator` only works with real values for `y`. &quot;</span>
                   <span class="s4">&quot;Passing an array with a complex dtype for `y` is deprecated &quot;</span>
                   <span class="s4">&quot;and will raise an error in SciPy 1.15.0. If you are trying to &quot;</span>
                   <span class="s4">&quot;use the real components of the passed array, use `np.real` on &quot;</span>
                   <span class="s4">&quot;the array before passing to `Akima1DInterpolator`.&quot;</span><span class="s3">)</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>

        <span class="s6"># Akima extrapolation historically False; parent class defaults to True.</span>
        <span class="s1">extrapolate </span><span class="s3">= </span><span class="s2">False if </span><span class="s1">extrapolate </span><span class="s2">is None else </span><span class="s1">extrapolate</span>

        <span class="s6"># determine slopes between breakpoints</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">x</span><span class="s3">.</span><span class="s1">size </span><span class="s3">+ </span><span class="s5">3</span><span class="s3">, ) + </span><span class="s1">y</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:])</span>
        <span class="s1">dx </span><span class="s3">= </span><span class="s1">dx</span><span class="s3">[(</span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">), ) + (</span><span class="s2">None</span><span class="s3">, ) * (</span><span class="s1">y</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)]</span>
        <span class="s1">m</span><span class="s3">[</span><span class="s5">2</span><span class="s3">:-</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">) / </span><span class="s1">dx</span>

        <span class="s6"># add two additional points on the left ...</span>
        <span class="s1">m</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s5">2. </span><span class="s3">* </span><span class="s1">m</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] - </span><span class="s1">m</span><span class="s3">[</span><span class="s5">3</span><span class="s3">]</span>
        <span class="s1">m</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s5">2. </span><span class="s3">* </span><span class="s1">m</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">m</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]</span>
        <span class="s6"># ... and on the right</span>
        <span class="s1">m</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">] = </span><span class="s5">2. </span><span class="s3">* </span><span class="s1">m</span><span class="s3">[-</span><span class="s5">3</span><span class="s3">] - </span><span class="s1">m</span><span class="s3">[-</span><span class="s5">4</span><span class="s3">]</span>
        <span class="s1">m</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] = </span><span class="s5">2. </span><span class="s3">* </span><span class="s1">m</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">] - </span><span class="s1">m</span><span class="s3">[-</span><span class="s5">3</span><span class="s3">]</span>

        <span class="s6"># if m1 == m2 != m3 == m4, the slope at the breakpoint is not</span>
        <span class="s6"># defined. This is the fill value:</span>
        <span class="s1">t </span><span class="s3">= </span><span class="s5">.5 </span><span class="s3">* (</span><span class="s1">m</span><span class="s3">[</span><span class="s5">3</span><span class="s3">:] + </span><span class="s1">m</span><span class="s3">[:-</span><span class="s5">3</span><span class="s3">])</span>
        <span class="s6"># get the denominator of the slope t</span>
        <span class="s1">dm </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">m</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">))</span>
        <span class="s2">if </span><span class="s1">method </span><span class="s3">== </span><span class="s4">&quot;makima&quot;</span><span class="s3">:</span>
            <span class="s1">pm </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">m</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] + </span><span class="s1">m</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">])</span>
            <span class="s1">f1 </span><span class="s3">= </span><span class="s1">dm</span><span class="s3">[</span><span class="s5">2</span><span class="s3">:] + </span><span class="s5">0.5 </span><span class="s3">* </span><span class="s1">pm</span><span class="s3">[</span><span class="s5">2</span><span class="s3">:]</span>
            <span class="s1">f2 </span><span class="s3">= </span><span class="s1">dm</span><span class="s3">[:-</span><span class="s5">2</span><span class="s3">] + </span><span class="s5">0.5 </span><span class="s3">* </span><span class="s1">pm</span><span class="s3">[:-</span><span class="s5">2</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">f1 </span><span class="s3">= </span><span class="s1">dm</span><span class="s3">[</span><span class="s5">2</span><span class="s3">:]</span>
            <span class="s1">f2 </span><span class="s3">= </span><span class="s1">dm</span><span class="s3">[:-</span><span class="s5">2</span><span class="s3">]</span>
        <span class="s1">f12 </span><span class="s3">= </span><span class="s1">f1 </span><span class="s3">+ </span><span class="s1">f2</span>
        <span class="s6"># These are the mask of where the slope at breakpoint is defined:</span>
        <span class="s1">ind </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">(</span><span class="s1">f12 </span><span class="s3">&gt; </span><span class="s5">1e-9 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">f12</span><span class="s3">, </span><span class="s1">initial</span><span class="s3">=-</span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">))</span>
        <span class="s1">x_ind</span><span class="s3">, </span><span class="s1">y_ind </span><span class="s3">= </span><span class="s1">ind</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">ind</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]</span>
        <span class="s6"># Set the slope at breakpoint</span>
        <span class="s1">t</span><span class="s3">[</span><span class="s1">ind</span><span class="s3">] = (</span><span class="s1">f1</span><span class="s3">[</span><span class="s1">ind</span><span class="s3">] * </span><span class="s1">m</span><span class="s3">[(</span><span class="s1">x_ind </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">,) + </span><span class="s1">y_ind</span><span class="s3">] +</span>
                  <span class="s1">f2</span><span class="s3">[</span><span class="s1">ind</span><span class="s3">] * </span><span class="s1">m</span><span class="s3">[(</span><span class="s1">x_ind </span><span class="s3">+ </span><span class="s5">2</span><span class="s3">,) + </span><span class="s1">y_ind</span><span class="s3">]) / </span><span class="s1">f12</span><span class="s3">[</span><span class="s1">ind</span><span class="s3">]</span>

        <span class="s1">super</span><span class="s3">().</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">extrapolate</span><span class="s3">=</span><span class="s1">extrapolate</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">axis </span><span class="s3">= </span><span class="s1">axis</span>

    <span class="s2">def </span><span class="s1">extend</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">right</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">&quot;Extending a 1-D Akima interpolator is not &quot;</span>
                                  <span class="s4">&quot;yet implemented&quot;</span><span class="s3">)</span>

    <span class="s6"># These are inherited from PPoly, but they do not produce an Akima</span>
    <span class="s6"># interpolator. Hence stub them out.</span>
    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">from_spline</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">tck</span><span class="s3">, </span><span class="s1">extrapolate</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">&quot;This method does not make sense for &quot;</span>
                                  <span class="s4">&quot;an Akima interpolator.&quot;</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s2">def </span><span class="s1">from_bernstein_basis</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">bp</span><span class="s3">, </span><span class="s1">extrapolate</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">&quot;This method does not make sense for &quot;</span>
                                  <span class="s4">&quot;an Akima interpolator.&quot;</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">CubicSpline</span><span class="s3">(</span><span class="s1">CubicHermiteSpline</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Cubic spline data interpolator. 
 
    Interpolate data with a piecewise cubic polynomial which is twice 
    continuously differentiable [1]_. The result is represented as a `PPoly` 
    instance with breakpoints matching the given data. 
 
    Parameters 
    ---------- 
    x : array_like, shape (n,) 
        1-D array containing values of the independent variable. 
        Values must be real, finite and in strictly increasing order. 
    y : array_like 
        Array containing values of the dependent variable. It can have 
        arbitrary number of dimensions, but the length along ``axis`` 
        (see below) must match the length of ``x``. Values must be finite. 
    axis : int, optional 
        Axis along which `y` is assumed to be varying. Meaning that for 
        ``x[i]`` the corresponding values are ``np.take(y, i, axis=axis)``. 
        Default is 0. 
    bc_type : string or 2-tuple, optional 
        Boundary condition type. Two additional equations, given by the 
        boundary conditions, are required to determine all coefficients of 
        polynomials on each segment [2]_. 
 
        If `bc_type` is a string, then the specified condition will be applied 
        at both ends of a spline. Available conditions are: 
 
        * 'not-a-knot' (default): The first and second segment at a curve end 
          are the same polynomial. It is a good default when there is no 
          information on boundary conditions. 
        * 'periodic': The interpolated functions is assumed to be periodic 
          of period ``x[-1] - x[0]``. The first and last value of `y` must be 
          identical: ``y[0] == y[-1]``. This boundary condition will result in 
          ``y'[0] == y'[-1]`` and ``y''[0] == y''[-1]``. 
        * 'clamped': The first derivative at curves ends are zero. Assuming 
          a 1D `y`, ``bc_type=((1, 0.0), (1, 0.0))`` is the same condition. 
        * 'natural': The second derivative at curve ends are zero. Assuming 
          a 1D `y`, ``bc_type=((2, 0.0), (2, 0.0))`` is the same condition. 
 
        If `bc_type` is a 2-tuple, the first and the second value will be 
        applied at the curve start and end respectively. The tuple values can 
        be one of the previously mentioned strings (except 'periodic') or a 
        tuple `(order, deriv_values)` allowing to specify arbitrary 
        derivatives at curve ends: 
 
        * `order`: the derivative order, 1 or 2. 
        * `deriv_value`: array_like containing derivative values, shape must 
          be the same as `y`, excluding ``axis`` dimension. For example, if 
          `y` is 1-D, then `deriv_value` must be a scalar. If `y` is 3-D with 
          the shape (n0, n1, n2) and axis=2, then `deriv_value` must be 2-D 
          and have the shape (n0, n1). 
    extrapolate : {bool, 'periodic', None}, optional 
        If bool, determines whether to extrapolate to out-of-bounds points 
        based on first and last intervals, or to return NaNs. If 'periodic', 
        periodic extrapolation is used. If None (default), ``extrapolate`` is 
        set to 'periodic' for ``bc_type='periodic'`` and to True otherwise. 
 
    Attributes 
    ---------- 
    x : ndarray, shape (n,) 
        Breakpoints. The same ``x`` which was passed to the constructor. 
    c : ndarray, shape (4, n-1, ...) 
        Coefficients of the polynomials on each segment. The trailing 
        dimensions match the dimensions of `y`, excluding ``axis``. 
        For example, if `y` is 1-d, then ``c[k, i]`` is a coefficient for 
        ``(x-x[i])**(3-k)`` on the segment between ``x[i]`` and ``x[i+1]``. 
    axis : int 
        Interpolation axis. The same axis which was passed to the 
        constructor. 
 
    Methods 
    ------- 
    __call__ 
    derivative 
    antiderivative 
    integrate 
    roots 
 
    See Also 
    -------- 
    Akima1DInterpolator : Akima 1D interpolator. 
    PchipInterpolator : PCHIP 1-D monotonic cubic interpolator. 
    PPoly : Piecewise polynomial in terms of coefficients and breakpoints. 
 
    Notes 
    ----- 
    Parameters `bc_type` and ``extrapolate`` work independently, i.e. the 
    former controls only construction of a spline, and the latter only 
    evaluation. 
 
    When a boundary condition is 'not-a-knot' and n = 2, it is replaced by 
    a condition that the first derivative is equal to the linear interpolant 
    slope. When both boundary conditions are 'not-a-knot' and n = 3, the 
    solution is sought as a parabola passing through given points. 
 
    When 'not-a-knot' boundary conditions is applied to both ends, the 
    resulting spline will be the same as returned by `splrep` (with ``s=0``) 
    and `InterpolatedUnivariateSpline`, but these two methods use a 
    representation in B-spline basis. 
 
    .. versionadded:: 0.18.0 
 
    Examples 
    -------- 
    In this example the cubic spline is used to interpolate a sampled sinusoid. 
    You can see that the spline continuity property holds for the first and 
    second derivatives and violates only for the third derivative. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.interpolate import CubicSpline 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.arange(10) 
    &gt;&gt;&gt; y = np.sin(x) 
    &gt;&gt;&gt; cs = CubicSpline(x, y) 
    &gt;&gt;&gt; xs = np.arange(-0.5, 9.6, 0.1) 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(6.5, 4)) 
    &gt;&gt;&gt; ax.plot(x, y, 'o', label='data') 
    &gt;&gt;&gt; ax.plot(xs, np.sin(xs), label='true') 
    &gt;&gt;&gt; ax.plot(xs, cs(xs), label=&quot;S&quot;) 
    &gt;&gt;&gt; ax.plot(xs, cs(xs, 1), label=&quot;S'&quot;) 
    &gt;&gt;&gt; ax.plot(xs, cs(xs, 2), label=&quot;S''&quot;) 
    &gt;&gt;&gt; ax.plot(xs, cs(xs, 3), label=&quot;S'''&quot;) 
    &gt;&gt;&gt; ax.set_xlim(-0.5, 9.5) 
    &gt;&gt;&gt; ax.legend(loc='lower left', ncol=2) 
    &gt;&gt;&gt; plt.show() 
 
    In the second example, the unit circle is interpolated with a spline. A 
    periodic boundary condition is used. You can see that the first derivative 
    values, ds/dx=0, ds/dy=1 at the periodic point (1, 0) are correctly 
    computed. Note that a circle cannot be exactly represented by a cubic 
    spline. To increase precision, more breakpoints would be required. 
 
    &gt;&gt;&gt; theta = 2 * np.pi * np.linspace(0, 1, 5) 
    &gt;&gt;&gt; y = np.c_[np.cos(theta), np.sin(theta)] 
    &gt;&gt;&gt; cs = CubicSpline(theta, y, bc_type='periodic') 
    &gt;&gt;&gt; print(&quot;ds/dx={:.1f} ds/dy={:.1f}&quot;.format(cs(0, 1)[0], cs(0, 1)[1])) 
    ds/dx=0.0 ds/dy=1.0 
    &gt;&gt;&gt; xs = 2 * np.pi * np.linspace(0, 1, 100) 
    &gt;&gt;&gt; fig, ax = plt.subplots(figsize=(6.5, 4)) 
    &gt;&gt;&gt; ax.plot(y[:, 0], y[:, 1], 'o', label='data') 
    &gt;&gt;&gt; ax.plot(np.cos(xs), np.sin(xs), label='true') 
    &gt;&gt;&gt; ax.plot(cs(xs)[:, 0], cs(xs)[:, 1], label='spline') 
    &gt;&gt;&gt; ax.axes.set_aspect('equal') 
    &gt;&gt;&gt; ax.legend(loc='center') 
    &gt;&gt;&gt; plt.show() 
 
    The third example is the interpolation of a polynomial y = x**3 on the 
    interval 0 &lt;= x&lt;= 1. A cubic spline can represent this function exactly. 
    To achieve that we need to specify values and first derivatives at 
    endpoints of the interval. Note that y' = 3 * x**2 and thus y'(0) = 0 and 
    y'(1) = 3. 
 
    &gt;&gt;&gt; cs = CubicSpline([0, 1], [0, 1], bc_type=((1, 0), (1, 3))) 
    &gt;&gt;&gt; x = np.linspace(0, 1) 
    &gt;&gt;&gt; np.allclose(x**3, cs(x)) 
    True 
 
    References 
    ---------- 
    .. [1] `Cubic Spline Interpolation 
            &lt;https://en.wikiversity.org/wiki/Cubic_Spline_Interpolation&gt;`_ 
            on Wikiversity. 
    .. [2] Carl de Boor, &quot;A Practical Guide to Splines&quot;, Springer-Verlag, 1978. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">bc_type</span><span class="s3">=</span><span class="s4">'not-a-knot'</span><span class="s3">, </span><span class="s1">extrapolate</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">prepare_input</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

        <span class="s1">bc</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_bc</span><span class="s3">(</span><span class="s1">bc_type</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">y</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:], </span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">extrapolate </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">bc</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s4">'periodic'</span><span class="s3">:</span>
                <span class="s1">extrapolate </span><span class="s3">= </span><span class="s4">'periodic'</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">extrapolate </span><span class="s3">= </span><span class="s2">True</span>

        <span class="s2">if </span><span class="s1">y</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s6"># bail out early for zero-sized arrays</span>
            <span class="s1">s </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">dxr </span><span class="s3">= </span><span class="s1">dx</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">([</span><span class="s1">dx</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]] + [</span><span class="s5">1</span><span class="s3">] * (</span><span class="s1">y</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">))</span>
            <span class="s1">slope </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">) / </span><span class="s1">dxr</span>

            <span class="s6"># If bc is 'not-a-knot' this change is just a convention.</span>
            <span class="s6"># If bc is 'periodic' then we already checked that y[0] == y[-1],</span>
            <span class="s6"># and the spline is just a constant, we handle this case in the</span>
            <span class="s6"># same way by setting the first derivatives to slope, which is 0.</span>
            <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s5">2</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">bc</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'not-a-knot'</span><span class="s3">, </span><span class="s4">'periodic'</span><span class="s3">]:</span>
                    <span class="s1">bc</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = (</span><span class="s5">1</span><span class="s3">, </span><span class="s1">slope</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
                <span class="s2">if </span><span class="s1">bc</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'not-a-knot'</span><span class="s3">, </span><span class="s4">'periodic'</span><span class="s3">]:</span>
                    <span class="s1">bc</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = (</span><span class="s5">1</span><span class="s3">, </span><span class="s1">slope</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>

            <span class="s6"># This is a special case, when both conditions are 'not-a-knot'</span>
            <span class="s6"># and n == 3. In this case 'not-a-knot' can't be handled regularly</span>
            <span class="s6"># as the both conditions are identical. We handle this case by</span>
            <span class="s6"># constructing a parabola passing through given points.</span>
            <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s5">3 </span><span class="s2">and </span><span class="s1">bc</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s4">'not-a-knot' </span><span class="s2">and </span><span class="s1">bc</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] == </span><span class="s4">'not-a-knot'</span><span class="s3">:</span>
                <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">))  </span><span class="s6"># This is a standard matrix.</span>
                <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s5">3</span><span class="s3">,) + </span><span class="s1">y</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">y</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

                <span class="s1">A</span><span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">] = </span><span class="s5">1</span>
                <span class="s1">A</span><span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">] = </span><span class="s5">1</span>
                <span class="s1">A</span><span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">] = </span><span class="s1">dx</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>
                <span class="s1">A</span><span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">] = </span><span class="s5">2 </span><span class="s3">* (</span><span class="s1">dx</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] + </span><span class="s1">dx</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>
                <span class="s1">A</span><span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">] = </span><span class="s1">dx</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
                <span class="s1">A</span><span class="s3">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">] = </span><span class="s5">1</span>
                <span class="s1">A</span><span class="s3">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">] = </span><span class="s5">1</span>

                <span class="s1">b</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">slope</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
                <span class="s1">b</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] = </span><span class="s5">3 </span><span class="s3">* (</span><span class="s1">dxr</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">slope</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] + </span><span class="s1">dxr</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">slope</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
                <span class="s1">b</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] = </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">slope</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>

                <span class="s1">s </span><span class="s3">= </span><span class="s1">solve</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">overwrite_a</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">overwrite_b</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                          <span class="s1">check_finite</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">n </span><span class="s3">== </span><span class="s5">3 </span><span class="s2">and </span><span class="s1">bc</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s4">'periodic'</span><span class="s3">:</span>
                <span class="s6"># In case when number of points is 3 we compute the derivatives</span>
                <span class="s6"># manually</span>
                <span class="s1">t </span><span class="s3">= (</span><span class="s1">slope </span><span class="s3">/ </span><span class="s1">dxr</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">(</span><span class="s5">0</span><span class="s3">) / (</span><span class="s5">1. </span><span class="s3">/ </span><span class="s1">dxr</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
                <span class="s1">s </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">t</span><span class="s3">, (</span><span class="s1">n</span><span class="s3">,) + </span><span class="s1">y</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:])</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s6"># Find derivative values at each x[i] by solving a tridiagonal</span>
                <span class="s6"># system.</span>
                <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s5">3</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))  </span><span class="s6"># This is a banded matrix representation.</span>
                <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n</span><span class="s3">,) + </span><span class="s1">y</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">y</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

                <span class="s6"># Filling the system for i=1..n-2</span>
                <span class="s6">#                         (x[i-1] - x[i]) * s[i-1] +\</span>
                <span class="s6"># 2 * ((x[i] - x[i-1]) + (x[i+1] - x[i])) * s[i]   +\</span>
                <span class="s6">#                         (x[i] - x[i-1]) * s[i+1] =\</span>
                <span class="s6">#       3 * ((x[i+1] - x[i])*(y[i] - y[i-1])/(x[i] - x[i-1]) +\</span>
                <span class="s6">#           (x[i] - x[i-1])*(y[i+1] - y[i])/(x[i+1] - x[i]))</span>

                <span class="s1">A</span><span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">:-</span><span class="s5">1</span><span class="s3">] = </span><span class="s5">2 </span><span class="s3">* (</span><span class="s1">dx</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">] + </span><span class="s1">dx</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:])  </span><span class="s6"># The diagonal</span>
                <span class="s1">A</span><span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">:] = </span><span class="s1">dx</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]                   </span><span class="s6"># The upper diagonal</span>
                <span class="s1">A</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">, :-</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">dx</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]                  </span><span class="s6"># The lower diagonal</span>

                <span class="s1">b</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:-</span><span class="s5">1</span><span class="s3">] = </span><span class="s5">3 </span><span class="s3">* (</span><span class="s1">dxr</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] * </span><span class="s1">slope</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">] + </span><span class="s1">dxr</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">slope</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:])</span>

                <span class="s1">bc_start</span><span class="s3">, </span><span class="s1">bc_end </span><span class="s3">= </span><span class="s1">bc</span>

                <span class="s2">if </span><span class="s1">bc_start </span><span class="s3">== </span><span class="s4">'periodic'</span><span class="s3">:</span>
                    <span class="s6"># Due to the periodicity, and because y[-1] = y[0], the</span>
                    <span class="s6"># linear system has (n-1) unknowns/equations instead of n:</span>
                    <span class="s1">A </span><span class="s3">= </span><span class="s1">A</span><span class="s3">[:, </span><span class="s5">0</span><span class="s3">:-</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s1">A</span><span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">] = </span><span class="s5">2 </span><span class="s3">* (</span><span class="s1">dx</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] + </span><span class="s1">dx</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
                    <span class="s1">A</span><span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">] = </span><span class="s1">dx</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>

                    <span class="s1">b </span><span class="s3">= </span><span class="s1">b</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]</span>

                    <span class="s6"># Also, due to the periodicity, the system is not tri-diagonal.</span>
                    <span class="s6"># We need to compute a &quot;condensed&quot; matrix of shape (n-2, n-2).</span>
                    <span class="s6"># See https://web.archive.org/web/20151220180652/http://www.cfm.brown.edu/people/gk/chap6/node14.html</span>
                    <span class="s6"># for more explanations.</span>
                    <span class="s6"># The condensed matrix is obtained by removing the last column</span>
                    <span class="s6"># and last row of the (n-1, n-1) system matrix. The removed</span>
                    <span class="s6"># values are saved in scalar variables with the (n-1, n-1)</span>
                    <span class="s6"># system matrix indices forming their names:</span>
                    <span class="s1">a_m1_0 </span><span class="s3">= </span><span class="s1">dx</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">]  </span><span class="s6"># lower left corner value: A[-1, 0]</span>
                    <span class="s1">a_m1_m2 </span><span class="s3">= </span><span class="s1">dx</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s1">a_m1_m1 </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* (</span><span class="s1">dx</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] + </span><span class="s1">dx</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">])</span>
                    <span class="s1">a_m2_m1 </span><span class="s3">= </span><span class="s1">dx</span><span class="s3">[-</span><span class="s5">3</span><span class="s3">]</span>
                    <span class="s1">a_0_m1 </span><span class="s3">= </span><span class="s1">dx</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

                    <span class="s1">b</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s5">3 </span><span class="s3">* (</span><span class="s1">dxr</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] * </span><span class="s1">slope</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] + </span><span class="s1">dxr</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">slope</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
                    <span class="s1">b</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] = </span><span class="s5">3 </span><span class="s3">* (</span><span class="s1">dxr</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">slope</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">] + </span><span class="s1">dxr</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">] * </span><span class="s1">slope</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">])</span>

                    <span class="s1">Ac </span><span class="s3">= </span><span class="s1">A</span><span class="s3">[:, :-</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s1">b1 </span><span class="s3">= </span><span class="s1">b</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s1">b2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">b1</span><span class="s3">)</span>
                    <span class="s1">b2</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = -</span><span class="s1">a_0_m1</span>
                    <span class="s1">b2</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] = -</span><span class="s1">a_m2_m1</span>

                    <span class="s6"># s1 and s2 are the solutions of (n-2, n-2) system</span>
                    <span class="s1">s1 </span><span class="s3">= </span><span class="s1">solve_banded</span><span class="s3">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), </span><span class="s1">Ac</span><span class="s3">, </span><span class="s1">b1</span><span class="s3">, </span><span class="s1">overwrite_ab</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                                      <span class="s1">overwrite_b</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">check_finite</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

                    <span class="s1">s2 </span><span class="s3">= </span><span class="s1">solve_banded</span><span class="s3">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), </span><span class="s1">Ac</span><span class="s3">, </span><span class="s1">b2</span><span class="s3">, </span><span class="s1">overwrite_ab</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                                      <span class="s1">overwrite_b</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">check_finite</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

                    <span class="s6"># computing the s[n-2] solution:</span>
                    <span class="s1">s_m1 </span><span class="s3">= ((</span><span class="s1">b</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">a_m1_0 </span><span class="s3">* </span><span class="s1">s1</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] - </span><span class="s1">a_m1_m2 </span><span class="s3">* </span><span class="s1">s1</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]) /</span>
                            <span class="s3">(</span><span class="s1">a_m1_m1 </span><span class="s3">+ </span><span class="s1">a_m1_0 </span><span class="s3">* </span><span class="s1">s2</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] + </span><span class="s1">a_m1_m2 </span><span class="s3">* </span><span class="s1">s2</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]))</span>

                    <span class="s6"># s is the solution of the (n, n) system:</span>
                    <span class="s1">s </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n</span><span class="s3">,) + </span><span class="s1">y</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">y</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
                    <span class="s1">s</span><span class="s3">[:-</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">s1 </span><span class="s3">+ </span><span class="s1">s_m1 </span><span class="s3">* </span><span class="s1">s2</span>
                    <span class="s1">s</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">s_m1</span>
                    <span class="s1">s</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">s</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">if </span><span class="s1">bc_start </span><span class="s3">== </span><span class="s4">'not-a-knot'</span><span class="s3">:</span>
                        <span class="s1">A</span><span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">] = </span><span class="s1">dx</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>
                        <span class="s1">A</span><span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">] = </span><span class="s1">x</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] - </span><span class="s1">x</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
                        <span class="s1">d </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[</span><span class="s5">2</span><span class="s3">] - </span><span class="s1">x</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
                        <span class="s1">b</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = ((</span><span class="s1">dxr</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] + </span><span class="s5">2</span><span class="s3">*</span><span class="s1">d</span><span class="s3">) * </span><span class="s1">dxr</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">slope</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] +</span>
                                <span class="s1">dxr</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]**</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">slope</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]) / </span><span class="s1">d</span>
                    <span class="s2">elif </span><span class="s1">bc_start</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s5">1</span><span class="s3">:</span>
                        <span class="s1">A</span><span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">] = </span><span class="s5">1</span>
                        <span class="s1">A</span><span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">] = </span><span class="s5">0</span>
                        <span class="s1">b</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">bc_start</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s2">elif </span><span class="s1">bc_start</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s5">2</span><span class="s3">:</span>
                        <span class="s1">A</span><span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">] = </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">dx</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
                        <span class="s1">A</span><span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">] = </span><span class="s1">dx</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
                        <span class="s1">b</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = -</span><span class="s5">0.5 </span><span class="s3">* </span><span class="s1">bc_start</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">dx</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]**</span><span class="s5">2 </span><span class="s3">+ </span><span class="s5">3 </span><span class="s3">* (</span><span class="s1">y</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">y</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>

                    <span class="s2">if </span><span class="s1">bc_end </span><span class="s3">== </span><span class="s4">'not-a-knot'</span><span class="s3">:</span>
                        <span class="s1">A</span><span class="s3">[</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">dx</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">]</span>
                        <span class="s1">A</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">x</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">x</span><span class="s3">[-</span><span class="s5">3</span><span class="s3">]</span>
                        <span class="s1">d </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">x</span><span class="s3">[-</span><span class="s5">3</span><span class="s3">]</span>
                        <span class="s1">b</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] = ((</span><span class="s1">dxr</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]**</span><span class="s5">2</span><span class="s3">*</span><span class="s1">slope</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">] +</span>
                                 <span class="s3">(</span><span class="s5">2</span><span class="s3">*</span><span class="s1">d </span><span class="s3">+ </span><span class="s1">dxr</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">])*</span><span class="s1">dxr</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">]*</span><span class="s1">slope</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]) / </span><span class="s1">d</span><span class="s3">)</span>
                    <span class="s2">elif </span><span class="s1">bc_end</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s5">1</span><span class="s3">:</span>
                        <span class="s1">A</span><span class="s3">[</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">] = </span><span class="s5">1</span>
                        <span class="s1">A</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">] = </span><span class="s5">0</span>
                        <span class="s1">b</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">bc_end</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>
                    <span class="s2">elif </span><span class="s1">bc_end</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s5">2</span><span class="s3">:</span>
                        <span class="s1">A</span><span class="s3">[</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">] = </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">dx</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
                        <span class="s1">A</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">] = </span><span class="s1">dx</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
                        <span class="s1">b</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] = </span><span class="s5">0.5 </span><span class="s3">* </span><span class="s1">bc_end</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">dx</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]**</span><span class="s5">2 </span><span class="s3">+ </span><span class="s5">3 </span><span class="s3">* (</span><span class="s1">y</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">y</span><span class="s3">[-</span><span class="s5">2</span><span class="s3">])</span>

                    <span class="s1">s </span><span class="s3">= </span><span class="s1">solve_banded</span><span class="s3">((</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), </span><span class="s1">A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">overwrite_ab</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
                                     <span class="s1">overwrite_b</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">check_finite</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

        <span class="s1">super</span><span class="s3">().</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">extrapolate</span><span class="s3">=</span><span class="s1">extrapolate</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">axis </span><span class="s3">= </span><span class="s1">axis</span>

    <span class="s3">@</span><span class="s1">staticmethod</span>
    <span class="s2">def </span><span class="s1">_validate_bc</span><span class="s3">(</span><span class="s1">bc_type</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">expected_deriv_shape</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Validate and prepare boundary conditions. 
 
        Returns 
        ------- 
        validated_bc : 2-tuple 
            Boundary conditions for a curve start and end. 
        y : ndarray 
            y casted to complex dtype if one of the boundary conditions has 
            complex dtype. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">bc_type</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">bc_type </span><span class="s3">== </span><span class="s4">'periodic'</span><span class="s3">:</span>
                <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">allclose</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">y</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">rtol</span><span class="s3">=</span><span class="s5">1e-15</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s5">1e-15</span><span class="s3">):</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                        <span class="s4">f&quot;The first and last `y` point along axis </span><span class="s2">{</span><span class="s1">axis</span><span class="s2">} </span><span class="s4">must &quot;</span>
                        <span class="s4">&quot;be identical (within machine precision) when &quot;</span>
                        <span class="s4">&quot;bc_type='periodic'.&quot;</span><span class="s3">)</span>

            <span class="s1">bc_type </span><span class="s3">= (</span><span class="s1">bc_type</span><span class="s3">, </span><span class="s1">bc_type</span><span class="s3">)</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">bc_type</span><span class="s3">) != </span><span class="s5">2</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;`bc_type` must contain 2 elements to &quot;</span>
                                 <span class="s4">&quot;specify start and end conditions.&quot;</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s4">'periodic' </span><span class="s2">in </span><span class="s1">bc_type</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;'periodic' `bc_type` is defined for both &quot;</span>
                                 <span class="s4">&quot;curve ends and cannot be used with other &quot;</span>
                                 <span class="s4">&quot;boundary conditions.&quot;</span><span class="s3">)</span>

        <span class="s1">validated_bc </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">bc </span><span class="s2">in </span><span class="s1">bc_type</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">bc</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">bc </span><span class="s3">== </span><span class="s4">'clamped'</span><span class="s3">:</span>
                    <span class="s1">validated_bc</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s5">1</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">expected_deriv_shape</span><span class="s3">)))</span>
                <span class="s2">elif </span><span class="s1">bc </span><span class="s3">== </span><span class="s4">'natural'</span><span class="s3">:</span>
                    <span class="s1">validated_bc</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s5">2</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">expected_deriv_shape</span><span class="s3">)))</span>
                <span class="s2">elif </span><span class="s1">bc </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'not-a-knot'</span><span class="s3">, </span><span class="s4">'periodic'</span><span class="s3">]:</span>
                    <span class="s1">validated_bc</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">bc</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;bc_type=</span><span class="s2">{</span><span class="s1">bc</span><span class="s2">} </span><span class="s4">is not allowed.&quot;</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">deriv_order</span><span class="s3">, </span><span class="s1">deriv_value </span><span class="s3">= </span><span class="s1">bc</span>
                <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                        <span class="s4">&quot;A specified derivative value must be &quot;</span>
                        <span class="s4">&quot;given in the form (order, value).&quot;</span>
                    <span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

                <span class="s2">if </span><span class="s1">deriv_order </span><span class="s2">not in </span><span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">]:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;The specified derivative order must &quot;</span>
                                     <span class="s4">&quot;be 1 or 2.&quot;</span><span class="s3">)</span>

                <span class="s1">deriv_value </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">deriv_value</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">deriv_value</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= </span><span class="s1">expected_deriv_shape</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                        <span class="s4">f&quot;`deriv_value` shape </span><span class="s2">{</span><span class="s1">deriv_value</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">} </span><span class="s4">is not &quot;</span>
                        <span class="s4">f&quot;the expected one </span><span class="s2">{</span><span class="s1">expected_deriv_shape</span><span class="s2">}</span><span class="s4">.&quot;</span>
                    <span class="s3">)</span>

                <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">deriv_value</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">):</span>
                    <span class="s1">y </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">complex</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

                <span class="s1">validated_bc</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">deriv_order</span><span class="s3">, </span><span class="s1">deriv_value</span><span class="s3">))</span>

        <span class="s2">return </span><span class="s1">validated_bc</span><span class="s3">, </span><span class="s1">y</span>
</pre>
</body>
</html>