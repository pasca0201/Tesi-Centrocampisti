<html>
<head>
<title>_column_transformer.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_column_transformer.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
The :mod:`sklearn.compose._column_transformer` module implements utilities 
to work with heterogeneous data and to apply different transformers to 
different columns. 
&quot;&quot;&quot;</span>

<span class="s2"># Author: Andreas Mueller</span>
<span class="s2">#         Joris Van den Bossche</span>
<span class="s2"># License: BSD</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">Counter</span><span class="s4">, </span><span class="s1">UserList</span>
<span class="s3">from </span><span class="s1">itertools </span><span class="s3">import </span><span class="s1">chain</span>
<span class="s3">from </span><span class="s1">numbers </span><span class="s3">import </span><span class="s1">Integral</span><span class="s4">, </span><span class="s1">Real</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">sparse</span>

<span class="s3">from </span><span class="s4">..</span><span class="s1">base </span><span class="s3">import </span><span class="s1">TransformerMixin</span><span class="s4">, </span><span class="s1">_fit_context</span><span class="s4">, </span><span class="s1">clone</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">pipeline </span><span class="s3">import </span><span class="s1">_fit_transform_one</span><span class="s4">, </span><span class="s1">_name_estimators</span><span class="s4">, </span><span class="s1">_transform_one</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">preprocessing </span><span class="s3">import </span><span class="s1">FunctionTransformer</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils </span><span class="s3">import </span><span class="s1">Bunch</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_estimator_html_repr </span><span class="s3">import </span><span class="s1">_VisualBlock</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_indexing </span><span class="s3">import </span><span class="s1">_determine_key_type</span><span class="s4">, </span><span class="s1">_get_column_indices</span><span class="s4">, </span><span class="s1">_safe_indexing</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_metadata_requests </span><span class="s3">import </span><span class="s1">METHODS</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_param_validation </span><span class="s3">import </span><span class="s1">HasMethods</span><span class="s4">, </span><span class="s1">Hidden</span><span class="s4">, </span><span class="s1">Interval</span><span class="s4">, </span><span class="s1">StrOptions</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_set_output </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">_get_container_adapter</span><span class="s4">,</span>
    <span class="s1">_get_output_config</span><span class="s4">,</span>
    <span class="s1">_safe_set_output</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">metadata_routing </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">MetadataRouter</span><span class="s4">,</span>
    <span class="s1">MethodMapping</span><span class="s4">,</span>
    <span class="s1">_raise_for_params</span><span class="s4">,</span>
    <span class="s1">_routing_enabled</span><span class="s4">,</span>
    <span class="s1">process_routing</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">metaestimators </span><span class="s3">import </span><span class="s1">_BaseComposition</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">parallel </span><span class="s3">import </span><span class="s1">Parallel</span><span class="s4">, </span><span class="s1">delayed</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">validation </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">_check_feature_names_in</span><span class="s4">,</span>
    <span class="s1">_get_feature_names</span><span class="s4">,</span>
    <span class="s1">_is_pandas_df</span><span class="s4">,</span>
    <span class="s1">_num_samples</span><span class="s4">,</span>
    <span class="s1">check_array</span><span class="s4">,</span>
    <span class="s1">check_is_fitted</span><span class="s4">,</span>
<span class="s4">)</span>

<span class="s1">__all__ </span><span class="s4">= [</span><span class="s5">&quot;ColumnTransformer&quot;</span><span class="s4">, </span><span class="s5">&quot;make_column_transformer&quot;</span><span class="s4">, </span><span class="s5">&quot;make_column_selector&quot;</span><span class="s4">]</span>


<span class="s1">_ERR_MSG_1DCOLUMN </span><span class="s4">= (</span>
    <span class="s5">&quot;1D data passed to a transformer that expects 2D data. &quot;</span>
    <span class="s5">&quot;Try to specify the column selection as a list of one &quot;</span>
    <span class="s5">&quot;item instead of a scalar.&quot;</span>
<span class="s4">)</span>


<span class="s3">class </span><span class="s1">ColumnTransformer</span><span class="s4">(</span><span class="s1">TransformerMixin</span><span class="s4">, </span><span class="s1">_BaseComposition</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Applies transformers to columns of an array or pandas DataFrame. 
 
    This estimator allows different columns or column subsets of the input 
    to be transformed separately and the features generated by each transformer 
    will be concatenated to form a single feature space. 
    This is useful for heterogeneous or columnar data, to combine several 
    feature extraction mechanisms or transformations into a single transformer. 
 
    Read more in the :ref:`User Guide &lt;column_transformer&gt;`. 
 
    .. versionadded:: 0.20 
 
    Parameters 
    ---------- 
    transformers : list of tuples 
        List of (name, transformer, columns) tuples specifying the 
        transformer objects to be applied to subsets of the data. 
 
        name : str 
            Like in Pipeline and FeatureUnion, this allows the transformer and 
            its parameters to be set using ``set_params`` and searched in grid 
            search. 
        transformer : {'drop', 'passthrough'} or estimator 
            Estimator must support :term:`fit` and :term:`transform`. 
            Special-cased strings 'drop' and 'passthrough' are accepted as 
            well, to indicate to drop the columns or to pass them through 
            untransformed, respectively. 
        columns :  str, array-like of str, int, array-like of int, \ 
                array-like of bool, slice or callable 
            Indexes the data on its second axis. Integers are interpreted as 
            positional columns, while strings can reference DataFrame columns 
            by name.  A scalar string or int should be used where 
            ``transformer`` expects X to be a 1d array-like (vector), 
            otherwise a 2d array will be passed to the transformer. 
            A callable is passed the input data `X` and can return any of the 
            above. To select multiple columns by name or dtype, you can use 
            :obj:`make_column_selector`. 
 
    remainder : {'drop', 'passthrough'} or estimator, default='drop' 
        By default, only the specified columns in `transformers` are 
        transformed and combined in the output, and the non-specified 
        columns are dropped. (default of ``'drop'``). 
        By specifying ``remainder='passthrough'``, all remaining columns that 
        were not specified in `transformers`, but present in the data passed 
        to `fit` will be automatically passed through. This subset of columns 
        is concatenated with the output of the transformers. For dataframes, 
        extra columns not seen during `fit` will be excluded from the output 
        of `transform`. 
        By setting ``remainder`` to be an estimator, the remaining 
        non-specified columns will use the ``remainder`` estimator. The 
        estimator must support :term:`fit` and :term:`transform`. 
        Note that using this feature requires that the DataFrame columns 
        input at :term:`fit` and :term:`transform` have identical order. 
 
    sparse_threshold : float, default=0.3 
        If the output of the different transformers contains sparse matrices, 
        these will be stacked as a sparse matrix if the overall density is 
        lower than this value. Use ``sparse_threshold=0`` to always return 
        dense.  When the transformed output consists of all dense data, the 
        stacked result will be dense, and this keyword will be ignored. 
 
    n_jobs : int, default=None 
        Number of jobs to run in parallel. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    transformer_weights : dict, default=None 
        Multiplicative weights for features per transformer. The output of the 
        transformer is multiplied by these weights. Keys are transformer names, 
        values the weights. 
 
    verbose : bool, default=False 
        If True, the time elapsed while fitting each transformer will be 
        printed as it is completed. 
 
    verbose_feature_names_out : bool, default=True 
        If True, :meth:`ColumnTransformer.get_feature_names_out` will prefix 
        all feature names with the name of the transformer that generated that 
        feature. 
        If False, :meth:`ColumnTransformer.get_feature_names_out` will not 
        prefix any feature names and will error if feature names are not 
        unique. 
 
        .. versionadded:: 1.0 
 
    force_int_remainder_cols : bool, default=True 
        Force the columns of the last entry of `transformers_`, which 
        corresponds to the &quot;remainder&quot; transformer, to always be stored as 
        indices (int) rather than column names (str). See description of the 
        `transformers_` attribute for details. 
 
        .. note:: 
            If you do not access the list of columns for the remainder columns 
            in the `transformers_` fitted attribute, you do not need to set 
            this parameter. 
 
        .. versionadded:: 1.5 
 
        .. versionchanged:: 1.7 
           The default value for `force_int_remainder_cols` will change from 
           `True` to `False` in version 1.7. 
 
    Attributes 
    ---------- 
    transformers_ : list 
        The collection of fitted transformers as tuples of (name, 
        fitted_transformer, column). `fitted_transformer` can be an estimator, 
        or `'drop'`; `'passthrough'` is replaced with an equivalent 
        :class:`~sklearn.preprocessing.FunctionTransformer`. In case there were 
        no columns selected, this will be the unfitted transformer. If there 
        are remaining columns, the final element is a tuple of the form: 
        ('remainder', transformer, remaining_columns) corresponding to the 
        ``remainder`` parameter. If there are remaining columns, then 
        ``len(transformers_)==len(transformers)+1``, otherwise 
        ``len(transformers_)==len(transformers)``. 
 
        .. versionchanged:: 1.5 
            If there are remaining columns and `force_int_remainder_cols` is 
            True, the remaining columns are always represented by their 
            positional indices in the input `X` (as in older versions). If 
            `force_int_remainder_cols` is False, the format attempts to match 
            that of the other transformers: if all columns were provided as 
            column names (`str`), the remaining columns are stored as column 
            names; if all columns were provided as mask arrays (`bool`), so are 
            the remaining columns; in all other cases the remaining columns are 
            stored as indices (`int`). 
 
    named_transformers_ : :class:`~sklearn.utils.Bunch` 
        Read-only attribute to access any transformer by given name. 
        Keys are transformer names and values are the fitted transformer 
        objects. 
 
    sparse_output_ : bool 
        Boolean flag indicating whether the output of ``transform`` is a 
        sparse matrix or a dense numpy array, which depends on the output 
        of the individual transformers and the `sparse_threshold` keyword. 
 
    output_indices_ : dict 
        A dictionary from each transformer name to a slice, where the slice 
        corresponds to indices in the transformed output. This is useful to 
        inspect which transformer is responsible for which transformed 
        feature(s). 
 
        .. versionadded:: 1.0 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. Only defined if the 
        underlying transformers expose such an attribute when fit. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    make_column_transformer : Convenience function for 
        combining the outputs of multiple transformer objects applied to 
        column subsets of the original feature space. 
    make_column_selector : Convenience function for selecting 
        columns based on datatype or the columns name with a regex pattern. 
 
    Notes 
    ----- 
    The order of the columns in the transformed feature matrix follows the 
    order of how the columns are specified in the `transformers` list. 
    Columns of the original feature matrix that are not specified are 
    dropped from the resulting transformed feature matrix, unless specified 
    in the `passthrough` keyword. Those columns specified with `passthrough` 
    are added at the right to the output of the transformers. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.compose import ColumnTransformer 
    &gt;&gt;&gt; from sklearn.preprocessing import Normalizer 
    &gt;&gt;&gt; ct = ColumnTransformer( 
    ...     [(&quot;norm1&quot;, Normalizer(norm='l1'), [0, 1]), 
    ...      (&quot;norm2&quot;, Normalizer(norm='l1'), slice(2, 4))]) 
    &gt;&gt;&gt; X = np.array([[0., 1., 2., 2.], 
    ...               [1., 1., 0., 1.]]) 
    &gt;&gt;&gt; # Normalizer scales each row of X to unit norm. A separate scaling 
    &gt;&gt;&gt; # is applied for the two first and two last elements of each 
    &gt;&gt;&gt; # row independently. 
    &gt;&gt;&gt; ct.fit_transform(X) 
    array([[0. , 1. , 0.5, 0.5], 
           [0.5, 0.5, 0. , 1. ]]) 
 
    :class:`ColumnTransformer` can be configured with a transformer that requires 
    a 1d array by setting the column to a string: 
 
    &gt;&gt;&gt; from sklearn.feature_extraction.text import CountVectorizer 
    &gt;&gt;&gt; from sklearn.preprocessing import MinMaxScaler 
    &gt;&gt;&gt; import pandas as pd   # doctest: +SKIP 
    &gt;&gt;&gt; X = pd.DataFrame({ 
    ...     &quot;documents&quot;: [&quot;First item&quot;, &quot;second one here&quot;, &quot;Is this the last?&quot;], 
    ...     &quot;width&quot;: [3, 4, 5], 
    ... })  # doctest: +SKIP 
    &gt;&gt;&gt; # &quot;documents&quot; is a string which configures ColumnTransformer to 
    &gt;&gt;&gt; # pass the documents column as a 1d array to the CountVectorizer 
    &gt;&gt;&gt; ct = ColumnTransformer( 
    ...     [(&quot;text_preprocess&quot;, CountVectorizer(), &quot;documents&quot;), 
    ...      (&quot;num_preprocess&quot;, MinMaxScaler(), [&quot;width&quot;])]) 
    &gt;&gt;&gt; X_trans = ct.fit_transform(X)  # doctest: +SKIP 
 
    For a more detailed example of usage, see 
    :ref:`sphx_glr_auto_examples_compose_plot_column_transformer_mixed_types.py`. 
    &quot;&quot;&quot;</span>

    <span class="s1">_required_parameters </span><span class="s4">= [</span><span class="s5">&quot;transformers&quot;</span><span class="s4">]</span>

    <span class="s1">_parameter_constraints</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
        <span class="s5">&quot;transformers&quot;</span><span class="s4">: [</span><span class="s1">list</span><span class="s4">, </span><span class="s1">Hidden</span><span class="s4">(</span><span class="s1">tuple</span><span class="s4">)],</span>
        <span class="s5">&quot;remainder&quot;</span><span class="s4">: [</span>
            <span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;drop&quot;</span><span class="s4">, </span><span class="s5">&quot;passthrough&quot;</span><span class="s4">}),</span>
            <span class="s1">HasMethods</span><span class="s4">([</span><span class="s5">&quot;fit&quot;</span><span class="s4">, </span><span class="s5">&quot;transform&quot;</span><span class="s4">]),</span>
            <span class="s1">HasMethods</span><span class="s4">([</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">, </span><span class="s5">&quot;transform&quot;</span><span class="s4">]),</span>
        <span class="s4">],</span>
        <span class="s5">&quot;sparse_threshold&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;both&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;n_jobs&quot;</span><span class="s4">: [</span><span class="s1">Integral</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;transformer_weights&quot;</span><span class="s4">: [</span><span class="s1">dict</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;verbose&quot;</span><span class="s4">: [</span><span class="s5">&quot;verbose&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;verbose_feature_names_out&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;force_int_remainder_cols&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
    <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">transformers</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">remainder</span><span class="s4">=</span><span class="s5">&quot;drop&quot;</span><span class="s4">,</span>
        <span class="s1">sparse_threshold</span><span class="s4">=</span><span class="s6">0.3</span><span class="s4">,</span>
        <span class="s1">n_jobs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">transformer_weights</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">verbose_feature_names_out</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">force_int_remainder_cols</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">transformers </span><span class="s4">= </span><span class="s1">transformers</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">remainder </span><span class="s4">= </span><span class="s1">remainder</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">sparse_threshold </span><span class="s4">= </span><span class="s1">sparse_threshold</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs </span><span class="s4">= </span><span class="s1">n_jobs</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_weights </span><span class="s4">= </span><span class="s1">transformer_weights</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">verbose </span><span class="s4">= </span><span class="s1">verbose</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">verbose_feature_names_out </span><span class="s4">= </span><span class="s1">verbose_feature_names_out</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">force_int_remainder_cols </span><span class="s4">= </span><span class="s1">force_int_remainder_cols</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_transformers</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Internal list of transformer only containing the name and 
        transformers, dropping the columns. 
 
        DO NOT USE: This is for the implementation of get_params via 
        BaseComposition._get_params which expects lists of tuples of len 2. 
 
        To iterate through the transformers, use ``self._iter`` instead. 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">[(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">) </span><span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformers</span><span class="s4">]</span>
        <span class="s3">except </span><span class="s4">(</span><span class="s1">TypeError</span><span class="s4">, </span><span class="s1">ValueError</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformers</span>

    <span class="s4">@</span><span class="s1">_transformers</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">_transformers</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;DO NOT USE: This is for the implementation of set_params via 
        BaseComposition._get_params which gives lists of tuples of len 2. 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">transformers </span><span class="s4">= [</span>
                <span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">col</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s4">((</span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">), (</span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">col</span><span class="s4">)) </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformers</span><span class="s4">)</span>
            <span class="s4">]</span>
        <span class="s3">except </span><span class="s4">(</span><span class="s1">TypeError</span><span class="s4">, </span><span class="s1">ValueError</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">transformers </span><span class="s4">= </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">set_output</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *, </span><span class="s1">transform</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Set the output container when `&quot;transform&quot;` and `&quot;fit_transform&quot;` are called. 
 
        Calling `set_output` will set the output of all estimators in `transformers` 
        and `transformers_`. 
 
        Parameters 
        ---------- 
        transform : {&quot;default&quot;, &quot;pandas&quot;, &quot;polars&quot;}, default=None 
            Configure output of `transform` and `fit_transform`. 
 
            - `&quot;default&quot;`: Default output format of a transformer 
            - `&quot;pandas&quot;`: DataFrame output 
            - `&quot;polars&quot;`: Polars output 
            - `None`: Transform configuration is unchanged 
 
            .. versionadded:: 1.4 
                `&quot;polars&quot;` option was added. 
 
        Returns 
        ------- 
        self : estimator instance 
            Estimator instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">set_output</span><span class="s4">(</span><span class="s1">transform</span><span class="s4">=</span><span class="s1">transform</span><span class="s4">)</span>

        <span class="s1">transformers </span><span class="s4">= (</span>
            <span class="s1">trans</span>
            <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">chain</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">transformers</span><span class="s4">, </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;transformers_&quot;</span><span class="s4">, [])</span>
            <span class="s4">)</span>
            <span class="s3">if </span><span class="s1">trans </span><span class="s3">not in </span><span class="s4">{</span><span class="s5">&quot;passthrough&quot;</span><span class="s4">, </span><span class="s5">&quot;drop&quot;</span><span class="s4">}</span>
        <span class="s4">)</span>
        <span class="s3">for </span><span class="s1">trans </span><span class="s3">in </span><span class="s1">transformers</span><span class="s4">:</span>
            <span class="s1">_safe_set_output</span><span class="s4">(</span><span class="s1">trans</span><span class="s4">, </span><span class="s1">transform</span><span class="s4">=</span><span class="s1">transform</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">remainder </span><span class="s3">not in </span><span class="s4">{</span><span class="s5">&quot;passthrough&quot;</span><span class="s4">, </span><span class="s5">&quot;drop&quot;</span><span class="s4">}:</span>
            <span class="s1">_safe_set_output</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">remainder</span><span class="s4">, </span><span class="s1">transform</span><span class="s4">=</span><span class="s1">transform</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">get_params</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">deep</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Get parameters for this estimator. 
 
        Returns the parameters given in the constructor as well as the 
        estimators contained within the `transformers` of the 
        `ColumnTransformer`. 
 
        Parameters 
        ---------- 
        deep : bool, default=True 
            If True, will return the parameters for this estimator and 
            contained subobjects that are estimators. 
 
        Returns 
        ------- 
        params : dict 
            Parameter names mapped to their values. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_params</span><span class="s4">(</span><span class="s5">&quot;_transformers&quot;</span><span class="s4">, </span><span class="s1">deep</span><span class="s4">=</span><span class="s1">deep</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">set_params</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Set the parameters of this estimator. 
 
        Valid parameter keys can be listed with ``get_params()``. Note that you 
        can directly set the parameters of the estimators contained in 
        `transformers` of `ColumnTransformer`. 
 
        Parameters 
        ---------- 
        **kwargs : dict 
            Estimator parameters. 
 
        Returns 
        ------- 
        self : ColumnTransformer 
            This estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_set_params</span><span class="s4">(</span><span class="s5">&quot;_transformers&quot;</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_iter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">fitted</span><span class="s4">, </span><span class="s1">column_as_labels</span><span class="s4">, </span><span class="s1">skip_drop</span><span class="s4">, </span><span class="s1">skip_empty_columns</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Generate (name, trans, columns, weight) tuples. 
 
 
        Parameters 
        ---------- 
        fitted : bool 
            If True, use the fitted transformers (``self.transformers_``) to 
            iterate through transformers, else use the transformers passed by 
            the user (``self.transformers``). 
 
        column_as_labels : bool 
            If True, columns are returned as string labels. If False, columns 
            are returned as they were given by the user. This can only be True 
            if the ``ColumnTransformer`` is already fitted. 
 
        skip_drop : bool 
            If True, 'drop' transformers are filtered out. 
 
        skip_empty_columns : bool 
            If True, transformers with empty selected columns are filtered out. 
 
        Yields 
        ------ 
        A generator of tuples containing: 
            - name : the name of the transformer 
            - transformer : the transformer object 
            - columns : the columns for that transformer 
            - weight : the weight of the transformer 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">fitted</span><span class="s4">:</span>
            <span class="s1">transformers </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformers_</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># interleave the validated column specifiers</span>
            <span class="s1">transformers </span><span class="s4">= [</span>
                <span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">column</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">_</span><span class="s4">), </span><span class="s1">column </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformers</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_columns</span><span class="s4">)</span>
            <span class="s4">]</span>
            <span class="s2"># add transformer tuple for remainder</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_remainder</span><span class="s4">[</span><span class="s6">2</span><span class="s4">]:</span>
                <span class="s1">transformers </span><span class="s4">= </span><span class="s1">chain</span><span class="s4">(</span><span class="s1">transformers</span><span class="s4">, [</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_remainder</span><span class="s4">])</span>

        <span class="s2"># We want the warning about the future change of the remainder</span>
        <span class="s2"># columns dtype to be shown only when a user accesses them</span>
        <span class="s2"># directly, not when they are used by the ColumnTransformer itself.</span>
        <span class="s2"># We disable warnings here; they are enabled when setting</span>
        <span class="s2"># self.transformers_.</span>
        <span class="s1">transformers </span><span class="s4">= </span><span class="s1">_with_dtype_warning_enabled_set_to</span><span class="s4">(</span><span class="s3">False</span><span class="s4">, </span><span class="s1">transformers</span><span class="s4">)</span>

        <span class="s1">get_weight </span><span class="s4">= (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_weights </span><span class="s3">or </span><span class="s4">{}).</span><span class="s1">get</span>

        <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">columns </span><span class="s3">in </span><span class="s1">transformers</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">skip_drop </span><span class="s3">and </span><span class="s1">trans </span><span class="s4">== </span><span class="s5">&quot;drop&quot;</span><span class="s4">:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">skip_empty_columns </span><span class="s3">and </span><span class="s1">_is_empty_column_selection</span><span class="s4">(</span><span class="s1">columns</span><span class="s4">):</span>
                <span class="s3">continue</span>

            <span class="s3">if </span><span class="s1">column_as_labels</span><span class="s4">:</span>
                <span class="s2"># Convert all columns to using their string labels</span>
                <span class="s1">columns_is_scalar </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isscalar</span><span class="s4">(</span><span class="s1">columns</span><span class="s4">)</span>

                <span class="s1">indices </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transformer_to_input_indices</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]</span>
                <span class="s1">columns </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">feature_names_in_</span><span class="s4">[</span><span class="s1">indices</span><span class="s4">]</span>

                <span class="s3">if </span><span class="s1">columns_is_scalar</span><span class="s4">:</span>
                    <span class="s2"># selection is done with one dimension</span>
                    <span class="s1">columns </span><span class="s4">= </span><span class="s1">columns</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

            <span class="s3">yield </span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">columns</span><span class="s4">, </span><span class="s1">get_weight</span><span class="s4">(</span><span class="s1">name</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">_validate_transformers</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Validate names of transformers and the transformers themselves. 
 
        This checks whether given transformers have the required methods, i.e. 
        `fit` or `fit_transform` and `transform` implemented. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformers</span><span class="s4">:</span>
            <span class="s3">return</span>

        <span class="s1">names</span><span class="s4">, </span><span class="s1">transformers</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">zip</span><span class="s4">(*</span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformers</span><span class="s4">)</span>

        <span class="s2"># validate names</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_names</span><span class="s4">(</span><span class="s1">names</span><span class="s4">)</span>

        <span class="s2"># validate estimators</span>
        <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">transformers</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">t </span><span class="s3">in </span><span class="s4">(</span><span class="s5">&quot;drop&quot;</span><span class="s4">, </span><span class="s5">&quot;passthrough&quot;</span><span class="s4">):</span>
                <span class="s3">continue</span>
            <span class="s3">if not </span><span class="s4">(</span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">t</span><span class="s4">, </span><span class="s5">&quot;fit&quot;</span><span class="s4">) </span><span class="s3">or </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">t</span><span class="s4">, </span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">)) </span><span class="s3">or not </span><span class="s1">hasattr</span><span class="s4">(</span>
                <span class="s1">t</span><span class="s4">, </span><span class="s5">&quot;transform&quot;</span>
            <span class="s4">):</span>
                <span class="s2"># Used to validate the transformers in the `transformers` list</span>
                <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span>
                    <span class="s5">&quot;All estimators should implement fit and &quot;</span>
                    <span class="s5">&quot;transform, or can be 'drop' or 'passthrough' &quot;</span>
                    <span class="s5">&quot;specifiers. '%s' (type %s) doesn't.&quot; </span><span class="s4">% (</span><span class="s1">t</span><span class="s4">, </span><span class="s1">type</span><span class="s4">(</span><span class="s1">t</span><span class="s4">))</span>
                <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_validate_column_callables</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Converts callable column specifications. 
 
        This stores a dictionary of the form `{step_name: column_indices}` and 
        calls the `columns` on `X` if `columns` is a callable for a given 
        transformer. 
 
        The results are then stored in `self._transformer_to_input_indices`. 
        &quot;&quot;&quot;</span>
        <span class="s1">all_columns </span><span class="s4">= []</span>
        <span class="s1">transformer_to_input_indices </span><span class="s4">= {}</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">columns </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformers</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">callable</span><span class="s4">(</span><span class="s1">columns</span><span class="s4">):</span>
                <span class="s1">columns </span><span class="s4">= </span><span class="s1">columns</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
            <span class="s1">all_columns</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">columns</span><span class="s4">)</span>
            <span class="s1">transformer_to_input_indices</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">_get_column_indices</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">columns</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_columns </span><span class="s4">= </span><span class="s1">all_columns</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_transformer_to_input_indices </span><span class="s4">= </span><span class="s1">transformer_to_input_indices</span>

    <span class="s3">def </span><span class="s1">_validate_remainder</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Validates ``remainder`` and defines ``_remainder`` targeting 
        the remaining columns. 
        &quot;&quot;&quot;</span>
        <span class="s1">cols </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">chain</span><span class="s4">(*</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transformer_to_input_indices</span><span class="s4">.</span><span class="s1">values</span><span class="s4">()))</span>
        <span class="s1">remaining </span><span class="s4">= </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s1">range</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_features_in_</span><span class="s4">)) - </span><span class="s1">cols</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_transformer_to_input_indices</span><span class="s4">[</span><span class="s5">&quot;remainder&quot;</span><span class="s4">] = </span><span class="s1">remaining</span>
        <span class="s1">remainder_cols </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_remainder_cols</span><span class="s4">(</span><span class="s1">remaining</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_remainder </span><span class="s4">= (</span><span class="s5">&quot;remainder&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">remainder</span><span class="s4">, </span><span class="s1">remainder_cols</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_get_remainder_cols_dtype</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">all_dtypes </span><span class="s4">= {</span><span class="s1">_determine_key_type</span><span class="s4">(</span><span class="s1">c</span><span class="s4">) </span><span class="s3">for </span><span class="s4">(*</span><span class="s1">_</span><span class="s4">, </span><span class="s1">c</span><span class="s4">) </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformers</span><span class="s4">}</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">all_dtypes</span><span class="s4">) == </span><span class="s6">1</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">next</span><span class="s4">(</span><span class="s1">iter</span><span class="s4">(</span><span class="s1">all_dtypes</span><span class="s4">))</span>
        <span class="s3">except </span><span class="s1">ValueError</span><span class="s4">:</span>
            <span class="s2"># _determine_key_type raises a ValueError if some transformer</span>
            <span class="s2"># columns are Callables</span>
            <span class="s3">return </span><span class="s5">&quot;int&quot;</span>
        <span class="s3">return </span><span class="s5">&quot;int&quot;</span>

    <span class="s3">def </span><span class="s1">_get_remainder_cols</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">indices</span><span class="s4">):</span>
        <span class="s1">dtype </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_remainder_cols_dtype</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">force_int_remainder_cols </span><span class="s3">and </span><span class="s1">dtype </span><span class="s4">!= </span><span class="s5">&quot;int&quot;</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_RemainderColsList</span><span class="s4">(</span><span class="s1">indices</span><span class="s4">, </span><span class="s1">future_dtype</span><span class="s4">=</span><span class="s1">dtype</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">dtype </span><span class="s4">== </span><span class="s5">&quot;str&quot;</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">feature_names_in_</span><span class="s4">[</span><span class="s1">indices</span><span class="s4">])</span>
        <span class="s3">if </span><span class="s1">dtype </span><span class="s4">== </span><span class="s5">&quot;bool&quot;</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">[</span><span class="s1">i </span><span class="s3">in </span><span class="s1">indices </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_features_in_</span><span class="s4">)]</span>
        <span class="s3">return </span><span class="s1">indices</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">named_transformers_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Access the fitted transformer by name. 
 
        Read-only attribute to access any transformer by given name. 
        Keys are transformer names and values are the fitted transformer 
        objects. 
        &quot;&quot;&quot;</span>
        <span class="s2"># Use Bunch object to improve autocomplete</span>
        <span class="s3">return </span><span class="s1">Bunch</span><span class="s4">(**{</span><span class="s1">name</span><span class="s4">: </span><span class="s1">trans </span><span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformers_</span><span class="s4">})</span>

    <span class="s3">def </span><span class="s1">_get_feature_name_out_for_transformer</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">feature_names_in</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Gets feature names of transformer. 
 
        Used in conjunction with self._iter(fitted=True) in get_feature_names_out. 
        &quot;&quot;&quot;</span>
        <span class="s1">column_indices </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transformer_to_input_indices</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]</span>
        <span class="s1">names </span><span class="s4">= </span><span class="s1">feature_names_in</span><span class="s4">[</span><span class="s1">column_indices</span><span class="s4">]</span>
        <span class="s2"># An actual transformer</span>
        <span class="s3">if not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">trans</span><span class="s4">, </span><span class="s5">&quot;get_feature_names_out&quot;</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span>
                <span class="s5">f&quot;Transformer </span><span class="s3">{</span><span class="s1">name</span><span class="s3">} </span><span class="s5">(type </span><span class="s3">{</span><span class="s1">type</span><span class="s4">(</span><span class="s1">trans</span><span class="s4">).</span><span class="s1">__name__</span><span class="s3">}</span><span class="s5">) does &quot;</span>
                <span class="s5">&quot;not provide get_feature_names_out.&quot;</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">trans</span><span class="s4">.</span><span class="s1">get_feature_names_out</span><span class="s4">(</span><span class="s1">names</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_feature_names_out</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">input_features</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Get output feature names for transformation. 
 
        Parameters 
        ---------- 
        input_features : array-like of str or None, default=None 
            Input features. 
 
            - If `input_features` is `None`, then `feature_names_in_` is 
              used as feature names in. If `feature_names_in_` is not defined, 
              then the following input feature names are generated: 
              `[&quot;x0&quot;, &quot;x1&quot;, ..., &quot;x(n_features_in_ - 1)&quot;]`. 
            - If `input_features` is an array-like, then `input_features` must 
              match `feature_names_in_` if `feature_names_in_` is defined. 
 
        Returns 
        ------- 
        feature_names_out : ndarray of str objects 
            Transformed feature names. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s1">input_features </span><span class="s4">= </span><span class="s1">_check_feature_names_in</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">input_features</span><span class="s4">)</span>

        <span class="s2"># List of tuples (name, feature_names_out)</span>
        <span class="s1">transformer_with_feature_names_out </span><span class="s4">= []</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, *</span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span>
            <span class="s1">fitted</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s1">column_as_labels</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">skip_empty_columns</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s1">skip_drop</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s4">):</span>
            <span class="s1">feature_names_out </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_feature_name_out_for_transformer</span><span class="s4">(</span>
                <span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">input_features</span>
            <span class="s4">)</span>
            <span class="s3">if </span><span class="s1">feature_names_out </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s3">continue</span>
            <span class="s1">transformer_with_feature_names_out</span><span class="s4">.</span><span class="s1">append</span><span class="s4">((</span><span class="s1">name</span><span class="s4">, </span><span class="s1">feature_names_out</span><span class="s4">))</span>

        <span class="s3">if not </span><span class="s1">transformer_with_feature_names_out</span><span class="s4">:</span>
            <span class="s2"># No feature names</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">([], </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">object</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_add_prefix_for_feature_names_out</span><span class="s4">(</span>
            <span class="s1">transformer_with_feature_names_out</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_add_prefix_for_feature_names_out</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">transformer_with_feature_names_out</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Add prefix for feature names out that includes the transformer names. 
 
        Parameters 
        ---------- 
        transformer_with_feature_names_out : list of tuples of (str, array-like of str) 
            The tuple consistent of the transformer's name and its feature names out. 
 
        Returns 
        ------- 
        feature_names_out : ndarray of shape (n_features,), dtype=str 
            Transformed feature names. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose_feature_names_out</span><span class="s4">:</span>
            <span class="s2"># Prefix the feature names out with the transformers name</span>
            <span class="s1">names </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span>
                <span class="s1">chain</span><span class="s4">.</span><span class="s1">from_iterable</span><span class="s4">(</span>
                    <span class="s4">(</span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s5">__</span><span class="s3">{</span><span class="s1">i</span><span class="s3">}</span><span class="s5">&quot; </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">feature_names_out</span><span class="s4">)</span>
                    <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">feature_names_out </span><span class="s3">in </span><span class="s1">transformer_with_feature_names_out</span>
                <span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">names</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">object</span><span class="s4">)</span>

        <span class="s2"># verbose_feature_names_out is False</span>
        <span class="s2"># Check that names are all unique without a prefix</span>
        <span class="s1">feature_names_count </span><span class="s4">= </span><span class="s1">Counter</span><span class="s4">(</span>
            <span class="s1">chain</span><span class="s4">.</span><span class="s1">from_iterable</span><span class="s4">(</span><span class="s1">s </span><span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">s </span><span class="s3">in </span><span class="s1">transformer_with_feature_names_out</span><span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s1">top_6_overlap </span><span class="s4">= [</span>
            <span class="s1">name </span><span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">count </span><span class="s3">in </span><span class="s1">feature_names_count</span><span class="s4">.</span><span class="s1">most_common</span><span class="s4">(</span><span class="s6">6</span><span class="s4">) </span><span class="s3">if </span><span class="s1">count </span><span class="s4">&gt; </span><span class="s6">1</span>
        <span class="s4">]</span>
        <span class="s1">top_6_overlap</span><span class="s4">.</span><span class="s1">sort</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">top_6_overlap</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">top_6_overlap</span><span class="s4">) == </span><span class="s6">6</span><span class="s4">:</span>
                <span class="s2"># There are more than 5 overlapping names, we only show the 5</span>
                <span class="s2"># of the feature names</span>
                <span class="s1">names_repr </span><span class="s4">= </span><span class="s1">str</span><span class="s4">(</span><span class="s1">top_6_overlap</span><span class="s4">[:</span><span class="s6">5</span><span class="s4">])[:-</span><span class="s6">1</span><span class="s4">] + </span><span class="s5">&quot;, ...]&quot;</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">names_repr </span><span class="s4">= </span><span class="s1">str</span><span class="s4">(</span><span class="s1">top_6_overlap</span><span class="s4">)</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">f&quot;Output feature names: </span><span class="s3">{</span><span class="s1">names_repr</span><span class="s3">} </span><span class="s5">are not unique. Please set &quot;</span>
                <span class="s5">&quot;verbose_feature_names_out=True to add prefixes to feature names&quot;</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">concatenate</span><span class="s4">(</span>
            <span class="s4">[</span><span class="s1">name </span><span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">name </span><span class="s3">in </span><span class="s1">transformer_with_feature_names_out</span><span class="s4">],</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_update_fitted_transformers</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">transformers</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Set self.transformers_ from given transformers. 
 
        Parameters 
        ---------- 
        transformers : list of estimators 
            The fitted estimators as the output of 
            `self._call_func_on_transformers(func=_fit_transform_one, ...)`. 
            That function doesn't include 'drop' or transformers for which no 
            column is selected. 'drop' is kept as is, and for the no-column 
            transformers the unfitted transformer is put in 
            `self.transformers_`. 
        &quot;&quot;&quot;</span>
        <span class="s2"># transformers are fitted; excludes 'drop' cases</span>
        <span class="s1">fitted_transformers </span><span class="s4">= </span><span class="s1">iter</span><span class="s4">(</span><span class="s1">transformers</span><span class="s4">)</span>
        <span class="s1">transformers_ </span><span class="s4">= []</span>

        <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">old</span><span class="s4">, </span><span class="s1">column</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span>
            <span class="s1">fitted</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">column_as_labels</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">skip_drop</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">skip_empty_columns</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">):</span>
            <span class="s3">if </span><span class="s1">old </span><span class="s4">== </span><span class="s5">&quot;drop&quot;</span><span class="s4">:</span>
                <span class="s1">trans </span><span class="s4">= </span><span class="s5">&quot;drop&quot;</span>
            <span class="s3">elif </span><span class="s1">_is_empty_column_selection</span><span class="s4">(</span><span class="s1">column</span><span class="s4">):</span>
                <span class="s1">trans </span><span class="s4">= </span><span class="s1">old</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">trans </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span><span class="s1">fitted_transformers</span><span class="s4">)</span>
            <span class="s1">transformers_</span><span class="s4">.</span><span class="s1">append</span><span class="s4">((</span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">column</span><span class="s4">))</span>

        <span class="s2"># sanity check that transformers is exhausted</span>
        <span class="s3">assert not </span><span class="s1">list</span><span class="s4">(</span><span class="s1">fitted_transformers</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">transformers_ </span><span class="s4">= </span><span class="s1">_with_dtype_warning_enabled_set_to</span><span class="s4">(</span><span class="s3">True</span><span class="s4">, </span><span class="s1">transformers_</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_validate_output</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">result</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Ensure that the output of each transformer is 2D. Otherwise 
        hstack can raise an error or produce incorrect results. 
        &quot;&quot;&quot;</span>
        <span class="s1">names </span><span class="s4">= [</span>
            <span class="s1">name</span>
            <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span>
                <span class="s1">fitted</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                <span class="s1">column_as_labels</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                <span class="s1">skip_drop</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                <span class="s1">skip_empty_columns</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s4">]</span>
        <span class="s3">for </span><span class="s1">Xs</span><span class="s4">, </span><span class="s1">name </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">result</span><span class="s4">, </span><span class="s1">names</span><span class="s4">):</span>
            <span class="s3">if not </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">Xs</span><span class="s4">, </span><span class="s5">&quot;ndim&quot;</span><span class="s4">, </span><span class="s6">0</span><span class="s4">) == </span><span class="s6">2 </span><span class="s3">and not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">Xs</span><span class="s4">, </span><span class="s5">&quot;__dataframe__&quot;</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                    <span class="s5">&quot;The output of the '{0}' transformer should be 2D (numpy array, &quot;</span>
                    <span class="s5">&quot;scipy sparse array, dataframe).&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
                <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">_get_output_config</span><span class="s4">(</span><span class="s5">&quot;transform&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">)[</span><span class="s5">&quot;dense&quot;</span><span class="s4">] == </span><span class="s5">&quot;pandas&quot;</span><span class="s4">:</span>
            <span class="s3">return</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">import </span><span class="s1">pandas </span><span class="s3">as </span><span class="s1">pd</span>
        <span class="s3">except </span><span class="s1">ImportError</span><span class="s4">:</span>
            <span class="s3">return</span>
        <span class="s3">for </span><span class="s1">Xs</span><span class="s4">, </span><span class="s1">name </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">result</span><span class="s4">, </span><span class="s1">names</span><span class="s4">):</span>
            <span class="s3">if not </span><span class="s1">_is_pandas_df</span><span class="s4">(</span><span class="s1">Xs</span><span class="s4">):</span>
                <span class="s3">continue</span>
            <span class="s3">for </span><span class="s1">col_name</span><span class="s4">, </span><span class="s1">dtype </span><span class="s3">in </span><span class="s1">Xs</span><span class="s4">.</span><span class="s1">dtypes</span><span class="s4">.</span><span class="s1">to_dict</span><span class="s4">().</span><span class="s1">items</span><span class="s4">():</span>
                <span class="s3">if </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">dtype</span><span class="s4">, </span><span class="s5">&quot;na_value&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">is not </span><span class="s1">pd</span><span class="s4">.</span><span class="s1">NA</span><span class="s4">:</span>
                    <span class="s3">continue</span>
                <span class="s3">if </span><span class="s1">pd</span><span class="s4">.</span><span class="s1">NA </span><span class="s3">not in </span><span class="s1">Xs</span><span class="s4">[</span><span class="s1">col_name</span><span class="s4">].</span><span class="s1">values</span><span class="s4">:</span>
                    <span class="s3">continue</span>
                <span class="s1">class_name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span>
                <span class="s2"># TODO(1.6): replace warning with ValueError</span>
                <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                    <span class="s4">(</span>
                        <span class="s5">f&quot;The output of the '</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s5">' transformer for column&quot;</span>
                        <span class="s5">f&quot; '</span><span class="s3">{</span><span class="s1">col_name</span><span class="s3">}</span><span class="s5">' has dtype </span><span class="s3">{</span><span class="s1">dtype</span><span class="s3">} </span><span class="s5">and uses pandas.NA to&quot;</span>
                        <span class="s5">&quot; represent null values. Storing this output in a numpy array&quot;</span>
                        <span class="s5">&quot; can cause errors in downstream scikit-learn estimators, and&quot;</span>
                        <span class="s5">&quot; inefficiencies. Starting with scikit-learn version 1.6, this&quot;</span>
                        <span class="s5">&quot; will raise a ValueError. To avoid this problem you can (i)&quot;</span>
                        <span class="s5">&quot; store the output in a pandas DataFrame by using&quot;</span>
                        <span class="s5">f&quot; </span><span class="s3">{</span><span class="s1">class_name</span><span class="s3">}</span><span class="s5">.set_output(transform='pandas') or (ii) modify&quot;</span>
                        <span class="s5">f&quot; the input data or the '</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s5">' transformer to avoid the&quot;</span>
                        <span class="s5">&quot; presence of pandas.NA (for example by using&quot;</span>
                        <span class="s5">&quot; pandas.DataFrame.astype).&quot;</span>
                    <span class="s4">),</span>
                    <span class="s1">FutureWarning</span><span class="s4">,</span>
                <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_record_output_indices</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">Xs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Record which transformer produced which column. 
        &quot;&quot;&quot;</span>
        <span class="s1">idx </span><span class="s4">= </span><span class="s6">0</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">output_indices_ </span><span class="s4">= {}</span>

        <span class="s3">for </span><span class="s1">transformer_idx</span><span class="s4">, (</span><span class="s1">name</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">) </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span>
                <span class="s1">fitted</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                <span class="s1">column_as_labels</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                <span class="s1">skip_drop</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                <span class="s1">skip_empty_columns</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s4">):</span>
            <span class="s1">n_columns </span><span class="s4">= </span><span class="s1">Xs</span><span class="s4">[</span><span class="s1">transformer_idx</span><span class="s4">].</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">output_indices_</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">slice</span><span class="s4">(</span><span class="s1">idx</span><span class="s4">, </span><span class="s1">idx </span><span class="s4">+ </span><span class="s1">n_columns</span><span class="s4">)</span>
            <span class="s1">idx </span><span class="s4">+= </span><span class="s1">n_columns</span>

        <span class="s2"># `_iter` only generates transformers that have a non empty</span>
        <span class="s2"># selection. Here we set empty slices for transformers that</span>
        <span class="s2"># generate no output, which are safe for indexing</span>
        <span class="s1">all_names </span><span class="s4">= [</span><span class="s1">t</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformers</span><span class="s4">] + [</span><span class="s5">&quot;remainder&quot;</span><span class="s4">]</span>
        <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">all_names</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">output_indices_</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">output_indices_</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">slice</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s6">0</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_log_message</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">total</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose</span><span class="s4">:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s5">&quot;(%d of %d) Processing %s&quot; </span><span class="s4">% (</span><span class="s1">idx</span><span class="s4">, </span><span class="s1">total</span><span class="s4">, </span><span class="s1">name</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_call_func_on_transformers</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">func</span><span class="s4">, </span><span class="s1">column_as_labels</span><span class="s4">, </span><span class="s1">routed_params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Private function to fit and/or transform on demand. 
 
        Parameters 
        ---------- 
        X : {array-like, dataframe} of shape (n_samples, n_features) 
            The data to be used in fit and/or transform. 
 
        y : array-like of shape (n_samples,) 
            Targets. 
 
        func : callable 
            Function to call, which can be _fit_transform_one or 
            _transform_one. 
 
        column_as_labels : bool 
            Used to iterate through transformers. If True, columns are returned 
            as strings. If False, columns are returned as they were given by 
            the user. Can be True only if the ``ColumnTransformer`` is already 
            fitted. 
 
        routed_params : dict 
            The routed parameters as the output from ``process_routing``. 
 
        Returns 
        ------- 
        Return value (transformers and/or transformed X data) depends 
        on the passed function. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">func </span><span class="s3">is </span><span class="s1">_fit_transform_one</span><span class="s4">:</span>
            <span class="s1">fitted </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s3">else</span><span class="s4">:  </span><span class="s2"># func is _transform_one</span>
            <span class="s1">fitted </span><span class="s4">= </span><span class="s3">True</span>

        <span class="s1">transformers </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span>
                <span class="s1">fitted</span><span class="s4">=</span><span class="s1">fitted</span><span class="s4">,</span>
                <span class="s1">column_as_labels</span><span class="s4">=</span><span class="s1">column_as_labels</span><span class="s4">,</span>
                <span class="s1">skip_drop</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                <span class="s1">skip_empty_columns</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">jobs </span><span class="s4">= []</span>
            <span class="s3">for </span><span class="s1">idx</span><span class="s4">, (</span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">columns</span><span class="s4">, </span><span class="s1">weight</span><span class="s4">) </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">transformers</span><span class="s4">, </span><span class="s1">start</span><span class="s4">=</span><span class="s6">1</span><span class="s4">):</span>
                <span class="s3">if </span><span class="s1">func </span><span class="s3">is </span><span class="s1">_fit_transform_one</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">trans </span><span class="s4">== </span><span class="s5">&quot;passthrough&quot;</span><span class="s4">:</span>
                        <span class="s1">output_config </span><span class="s4">= </span><span class="s1">_get_output_config</span><span class="s4">(</span><span class="s5">&quot;transform&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">)</span>
                        <span class="s1">trans </span><span class="s4">= </span><span class="s1">FunctionTransformer</span><span class="s4">(</span>
                            <span class="s1">accept_sparse</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                            <span class="s1">check_inverse</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                            <span class="s1">feature_names_out</span><span class="s4">=</span><span class="s5">&quot;one-to-one&quot;</span><span class="s4">,</span>
                        <span class="s4">).</span><span class="s1">set_output</span><span class="s4">(</span><span class="s1">transform</span><span class="s4">=</span><span class="s1">output_config</span><span class="s4">[</span><span class="s5">&quot;dense&quot;</span><span class="s4">])</span>

                    <span class="s1">extra_args </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span>
                        <span class="s1">message_clsname</span><span class="s4">=</span><span class="s5">&quot;ColumnTransformer&quot;</span><span class="s4">,</span>
                        <span class="s1">message</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_log_message</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">len</span><span class="s4">(</span><span class="s1">transformers</span><span class="s4">)),</span>
                    <span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:  </span><span class="s2"># func is _transform_one</span>
                    <span class="s1">extra_args </span><span class="s4">= {}</span>
                <span class="s1">jobs</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span>
                    <span class="s1">delayed</span><span class="s4">(</span><span class="s1">func</span><span class="s4">)(</span>
                        <span class="s1">transformer</span><span class="s4">=</span><span class="s1">clone</span><span class="s4">(</span><span class="s1">trans</span><span class="s4">) </span><span class="s3">if not </span><span class="s1">fitted </span><span class="s3">else </span><span class="s1">trans</span><span class="s4">,</span>
                        <span class="s1">X</span><span class="s4">=</span><span class="s1">_safe_indexing</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">columns</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">1</span><span class="s4">),</span>
                        <span class="s1">y</span><span class="s4">=</span><span class="s1">y</span><span class="s4">,</span>
                        <span class="s1">weight</span><span class="s4">=</span><span class="s1">weight</span><span class="s4">,</span>
                        <span class="s4">**</span><span class="s1">extra_args</span><span class="s4">,</span>
                        <span class="s1">params</span><span class="s4">=</span><span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">],</span>
                    <span class="s4">)</span>
                <span class="s4">)</span>

            <span class="s3">return </span><span class="s1">Parallel</span><span class="s4">(</span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs</span><span class="s4">)(</span><span class="s1">jobs</span><span class="s4">)</span>

        <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s5">&quot;Expected 2D array, got 1D array instead&quot; </span><span class="s3">in </span><span class="s1">str</span><span class="s4">(</span><span class="s1">e</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s1">_ERR_MSG_1DCOLUMN</span><span class="s4">) </span><span class="s3">from </span><span class="s1">e</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise</span>

    <span class="s3">def </span><span class="s1">fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Fit all transformers using X. 
 
        Parameters 
        ---------- 
        X : {array-like, dataframe} of shape (n_samples, n_features) 
            Input data, of which specified subsets are used to fit the 
            transformers. 
 
        y : array-like of shape (n_samples,...), default=None 
            Targets for supervised learning. 
 
        **params : dict, default=None 
            Parameters to be passed to the underlying transformers' ``fit`` and 
            ``transform`` methods. 
 
            You can only pass this if metadata routing is enabled, which you 
            can enable using ``sklearn.set_config(enable_metadata_routing=True)``. 
 
            .. versionadded:: 1.4 
 
        Returns 
        ------- 
        self : ColumnTransformer 
            This estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">_raise_for_params</span><span class="s4">(</span><span class="s1">params</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;fit&quot;</span><span class="s4">)</span>
        <span class="s2"># we use fit_transform to make sure to set sparse_output_ (for which we</span>
        <span class="s2"># need the transformed data) to have consistent output type in predict</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">fit_transform</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s1">y</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_fit_context</span><span class="s4">(</span>
        <span class="s2"># estimators in ColumnTransformer.transformers are not validated yet</span>
        <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">False</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">fit_transform</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Fit all transformers, transform the data and concatenate results. 
 
        Parameters 
        ---------- 
        X : {array-like, dataframe} of shape (n_samples, n_features) 
            Input data, of which specified subsets are used to fit the 
            transformers. 
 
        y : array-like of shape (n_samples,), default=None 
            Targets for supervised learning. 
 
        **params : dict, default=None 
            Parameters to be passed to the underlying transformers' ``fit`` and 
            ``transform`` methods. 
 
            You can only pass this if metadata routing is enabled, which you 
            can enable using ``sklearn.set_config(enable_metadata_routing=True)``. 
 
            .. versionadded:: 1.4 
 
        Returns 
        ------- 
        X_t : {array-like, sparse matrix} of \ 
                shape (n_samples, sum_n_components) 
            Horizontally stacked results of transformers. sum_n_components is the 
            sum of n_components (output dimension) over transformers. If 
            any result is a sparse matrix, everything will be converted to 
            sparse matrices. 
        &quot;&quot;&quot;</span>
        <span class="s1">_raise_for_params</span><span class="s4">(</span><span class="s1">params</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_check_feature_names</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">reset</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

        <span class="s1">X </span><span class="s4">= </span><span class="s1">_check_X</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s2"># set n_features_in_ attribute</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_check_n_features</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">reset</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_transformers</span><span class="s4">()</span>
        <span class="s1">n_samples </span><span class="s4">= </span><span class="s1">_num_samples</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_column_callables</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_remainder</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">_routing_enabled</span><span class="s4">():</span>
            <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">process_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_empty_routing</span><span class="s4">()</span>

        <span class="s1">result </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_call_func_on_transformers</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">y</span><span class="s4">,</span>
            <span class="s1">_fit_transform_one</span><span class="s4">,</span>
            <span class="s1">column_as_labels</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">routed_params</span><span class="s4">=</span><span class="s1">routed_params</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">result</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_update_fitted_transformers</span><span class="s4">([])</span>
            <span class="s2"># All transformers are None</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s6">0</span><span class="s4">))</span>

        <span class="s1">Xs</span><span class="s4">, </span><span class="s1">transformers </span><span class="s4">= </span><span class="s1">zip</span><span class="s4">(*</span><span class="s1">result</span><span class="s4">)</span>

        <span class="s2"># determine if concatenated output will be sparse or not</span>
        <span class="s3">if </span><span class="s1">any</span><span class="s4">(</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">for </span><span class="s1">X </span><span class="s3">in </span><span class="s1">Xs</span><span class="s4">):</span>
            <span class="s1">nnz </span><span class="s4">= </span><span class="s1">sum</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">nnz </span><span class="s3">if </span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">else </span><span class="s1">X</span><span class="s4">.</span><span class="s1">size </span><span class="s3">for </span><span class="s1">X </span><span class="s3">in </span><span class="s1">Xs</span><span class="s4">)</span>
            <span class="s1">total </span><span class="s4">= </span><span class="s1">sum</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] * </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] </span><span class="s3">if </span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">else </span><span class="s1">X</span><span class="s4">.</span><span class="s1">size </span><span class="s3">for </span><span class="s1">X </span><span class="s3">in </span><span class="s1">Xs</span>
            <span class="s4">)</span>
            <span class="s1">density </span><span class="s4">= </span><span class="s1">nnz </span><span class="s4">/ </span><span class="s1">total</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">sparse_output_ </span><span class="s4">= </span><span class="s1">density </span><span class="s4">&lt; </span><span class="s1">self</span><span class="s4">.</span><span class="s1">sparse_threshold</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">sparse_output_ </span><span class="s4">= </span><span class="s3">False</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_update_fitted_transformers</span><span class="s4">(</span><span class="s1">transformers</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_output</span><span class="s4">(</span><span class="s1">Xs</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_record_output_indices</span><span class="s4">(</span><span class="s1">Xs</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_hstack</span><span class="s4">(</span><span class="s1">list</span><span class="s4">(</span><span class="s1">Xs</span><span class="s4">), </span><span class="s1">n_samples</span><span class="s4">=</span><span class="s1">n_samples</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">transform</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Transform X separately by each transformer, concatenate results. 
 
        Parameters 
        ---------- 
        X : {array-like, dataframe} of shape (n_samples, n_features) 
            The data to be transformed by subset. 
 
        **params : dict, default=None 
            Parameters to be passed to the underlying transformers' ``transform`` 
            method. 
 
            You can only pass this if metadata routing is enabled, which you 
            can enable using ``sklearn.set_config(enable_metadata_routing=True)``. 
 
            .. versionadded:: 1.4 
 
        Returns 
        ------- 
        X_t : {array-like, sparse matrix} of \ 
                shape (n_samples, sum_n_components) 
            Horizontally stacked results of transformers. sum_n_components is the 
            sum of n_components (output dimension) over transformers. If 
            any result is a sparse matrix, everything will be converted to 
            sparse matrices. 
        &quot;&quot;&quot;</span>
        <span class="s1">_raise_for_params</span><span class="s4">(</span><span class="s1">params</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>
        <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">_check_X</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

        <span class="s2"># If ColumnTransformer is fit using a dataframe, and now a dataframe is</span>
        <span class="s2"># passed to be transformed, we select columns by name instead. This</span>
        <span class="s2"># enables the user to pass X at transform time with extra columns which</span>
        <span class="s2"># were not present in fit time, and the order of the columns doesn't</span>
        <span class="s2"># matter.</span>
        <span class="s1">fit_dataframe_and_transform_dataframe </span><span class="s4">= </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;feature_names_in_&quot;</span><span class="s4">) </span><span class="s3">and </span><span class="s4">(</span>
            <span class="s1">_is_pandas_df</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">or </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s5">&quot;__dataframe__&quot;</span><span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s1">n_samples </span><span class="s4">= </span><span class="s1">_num_samples</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s1">column_names </span><span class="s4">= </span><span class="s1">_get_feature_names</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">fit_dataframe_and_transform_dataframe</span><span class="s4">:</span>
            <span class="s1">named_transformers </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">named_transformers_</span>
            <span class="s2"># check that all names seen in fit are in transform, unless</span>
            <span class="s2"># they were dropped</span>
            <span class="s1">non_dropped_indices </span><span class="s4">= [</span>
                <span class="s1">ind</span>
                <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">ind </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_transformer_to_input_indices</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()</span>
                <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">named_transformers </span><span class="s3">and </span><span class="s1">named_transformers</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] != </span><span class="s5">&quot;drop&quot;</span>
            <span class="s4">]</span>

            <span class="s1">all_indices </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">chain</span><span class="s4">(*</span><span class="s1">non_dropped_indices</span><span class="s4">))</span>
            <span class="s1">all_names </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">feature_names_in_</span><span class="s4">[</span><span class="s1">ind</span><span class="s4">] </span><span class="s3">for </span><span class="s1">ind </span><span class="s3">in </span><span class="s1">all_indices</span><span class="s4">)</span>

            <span class="s1">diff </span><span class="s4">= </span><span class="s1">all_names </span><span class="s4">- </span><span class="s1">set</span><span class="s4">(</span><span class="s1">column_names</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">diff</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;columns are missing: </span><span class="s3">{</span><span class="s1">diff</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># ndarray was used for fitting or transforming, thus we only</span>
            <span class="s2"># check that n_features_in_ is consistent</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_check_n_features</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">reset</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">_routing_enabled</span><span class="s4">():</span>
            <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">process_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;transform&quot;</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_empty_routing</span><span class="s4">()</span>

        <span class="s1">Xs </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_call_func_on_transformers</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s3">None</span><span class="s4">,</span>
            <span class="s1">_transform_one</span><span class="s4">,</span>
            <span class="s1">column_as_labels</span><span class="s4">=</span><span class="s1">fit_dataframe_and_transform_dataframe</span><span class="s4">,</span>
            <span class="s1">routed_params</span><span class="s4">=</span><span class="s1">routed_params</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_output</span><span class="s4">(</span><span class="s1">Xs</span><span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">Xs</span><span class="s4">:</span>
            <span class="s2"># All transformers are None</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s6">0</span><span class="s4">))</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_hstack</span><span class="s4">(</span><span class="s1">list</span><span class="s4">(</span><span class="s1">Xs</span><span class="s4">), </span><span class="s1">n_samples</span><span class="s4">=</span><span class="s1">n_samples</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_hstack</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">Xs</span><span class="s4">, *, </span><span class="s1">n_samples</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Stacks Xs horizontally. 
 
        This allows subclasses to control the stacking behavior, while reusing 
        everything else from ColumnTransformer. 
 
        Parameters 
        ---------- 
        Xs : list of {array-like, sparse matrix, dataframe} 
            The container to concatenate. 
        n_samples : int 
            The number of samples in the input data to checking the transformation 
            consistency. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">sparse_output_</span><span class="s4">:</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s2"># since all columns should be numeric before stacking them</span>
                <span class="s2"># in a sparse matrix, `check_array` is used for the</span>
                <span class="s2"># dtype conversion if necessary.</span>
                <span class="s1">converted_Xs </span><span class="s4">= [</span>
                    <span class="s1">check_array</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">accept_sparse</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">force_all_finite</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
                    <span class="s3">for </span><span class="s1">X </span><span class="s3">in </span><span class="s1">Xs</span>
                <span class="s4">]</span>
            <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                    <span class="s5">&quot;For a sparse output, all columns should &quot;</span>
                    <span class="s5">&quot;be a numeric or convertible to a numeric.&quot;</span>
                <span class="s4">) </span><span class="s3">from </span><span class="s1">e</span>

            <span class="s3">return </span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">(</span><span class="s1">converted_Xs</span><span class="s4">).</span><span class="s1">tocsr</span><span class="s4">()</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">Xs </span><span class="s4">= [</span><span class="s1">f</span><span class="s4">.</span><span class="s1">toarray</span><span class="s4">() </span><span class="s3">if </span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">f</span><span class="s4">) </span><span class="s3">else </span><span class="s1">f </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">Xs</span><span class="s4">]</span>
            <span class="s1">adapter </span><span class="s4">= </span><span class="s1">_get_container_adapter</span><span class="s4">(</span><span class="s5">&quot;transform&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">adapter </span><span class="s3">and </span><span class="s1">all</span><span class="s4">(</span><span class="s1">adapter</span><span class="s4">.</span><span class="s1">is_supported_container</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">for </span><span class="s1">X </span><span class="s3">in </span><span class="s1">Xs</span><span class="s4">):</span>
                <span class="s2"># rename before stacking as it avoids to error on temporary duplicated</span>
                <span class="s2"># columns</span>
                <span class="s1">transformer_names </span><span class="s4">= [</span>
                    <span class="s1">t</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
                    <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span>
                        <span class="s1">fitted</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                        <span class="s1">column_as_labels</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                        <span class="s1">skip_drop</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                        <span class="s1">skip_empty_columns</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                    <span class="s4">)</span>
                <span class="s4">]</span>
                <span class="s1">feature_names_outs </span><span class="s4">= [</span><span class="s1">X</span><span class="s4">.</span><span class="s1">columns </span><span class="s3">for </span><span class="s1">X </span><span class="s3">in </span><span class="s1">Xs </span><span class="s3">if </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] != </span><span class="s6">0</span><span class="s4">]</span>
                <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose_feature_names_out</span><span class="s4">:</span>
                    <span class="s2"># `_add_prefix_for_feature_names_out` takes care about raising</span>
                    <span class="s2"># an error if there are duplicated columns.</span>
                    <span class="s1">feature_names_outs </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_add_prefix_for_feature_names_out</span><span class="s4">(</span>
                        <span class="s1">list</span><span class="s4">(</span><span class="s1">zip</span><span class="s4">(</span><span class="s1">transformer_names</span><span class="s4">, </span><span class="s1">feature_names_outs</span><span class="s4">))</span>
                    <span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s2"># check for duplicated columns and raise if any</span>
                    <span class="s1">feature_names_outs </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">chain</span><span class="s4">.</span><span class="s1">from_iterable</span><span class="s4">(</span><span class="s1">feature_names_outs</span><span class="s4">))</span>
                    <span class="s1">feature_names_count </span><span class="s4">= </span><span class="s1">Counter</span><span class="s4">(</span><span class="s1">feature_names_outs</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">any</span><span class="s4">(</span><span class="s1">count </span><span class="s4">&gt; </span><span class="s6">1 </span><span class="s3">for </span><span class="s1">count </span><span class="s3">in </span><span class="s1">feature_names_count</span><span class="s4">.</span><span class="s1">values</span><span class="s4">()):</span>
                        <span class="s1">duplicated_feature_names </span><span class="s4">= </span><span class="s1">sorted</span><span class="s4">(</span>
                            <span class="s1">name</span>
                            <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">count </span><span class="s3">in </span><span class="s1">feature_names_count</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()</span>
                            <span class="s3">if </span><span class="s1">count </span><span class="s4">&gt; </span><span class="s6">1</span>
                        <span class="s4">)</span>
                        <span class="s1">err_msg </span><span class="s4">= (</span>
                            <span class="s5">&quot;Duplicated feature names found before concatenating the&quot;</span>
                            <span class="s5">&quot; outputs of the transformers:&quot;</span>
                            <span class="s5">f&quot; </span><span class="s3">{</span><span class="s1">duplicated_feature_names</span><span class="s3">}</span><span class="s5">.</span><span class="s3">\n</span><span class="s5">&quot;</span>
                        <span class="s4">)</span>
                        <span class="s3">for </span><span class="s1">transformer_name</span><span class="s4">, </span><span class="s1">X </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">transformer_names</span><span class="s4">, </span><span class="s1">Xs</span><span class="s4">):</span>
                            <span class="s3">if </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] == </span><span class="s6">0</span><span class="s4">:</span>
                                <span class="s3">continue</span>
                            <span class="s1">dup_cols_in_transformer </span><span class="s4">= </span><span class="s1">sorted</span><span class="s4">(</span>
                                <span class="s1">set</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">columns</span><span class="s4">).</span><span class="s1">intersection</span><span class="s4">(</span><span class="s1">duplicated_feature_names</span><span class="s4">)</span>
                            <span class="s4">)</span>
                            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">dup_cols_in_transformer</span><span class="s4">):</span>
                                <span class="s1">err_msg </span><span class="s4">+= (</span>
                                    <span class="s5">f&quot;Transformer </span><span class="s3">{</span><span class="s1">transformer_name</span><span class="s3">} </span><span class="s5">has conflicting &quot;</span>
                                    <span class="s5">f&quot;columns names: </span><span class="s3">{</span><span class="s1">dup_cols_in_transformer</span><span class="s3">}</span><span class="s5">.</span><span class="s3">\n</span><span class="s5">&quot;</span>
                                <span class="s4">)</span>
                        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                            <span class="s1">err_msg</span>
                            <span class="s4">+ </span><span class="s5">&quot;Either make sure that the transformers named above &quot;</span>
                            <span class="s5">&quot;do not generate columns with conflicting names or set &quot;</span>
                            <span class="s5">&quot;verbose_feature_names_out=True to automatically &quot;</span>
                            <span class="s5">&quot;prefix to the output feature names with the name &quot;</span>
                            <span class="s5">&quot;of the transformer to prevent any conflicting &quot;</span>
                            <span class="s5">&quot;names.&quot;</span>
                        <span class="s4">)</span>

                <span class="s1">names_idx </span><span class="s4">= </span><span class="s6">0</span>
                <span class="s3">for </span><span class="s1">X </span><span class="s3">in </span><span class="s1">Xs</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] == </span><span class="s6">0</span><span class="s4">:</span>
                        <span class="s3">continue</span>
                    <span class="s1">names_out </span><span class="s4">= </span><span class="s1">feature_names_outs</span><span class="s4">[</span><span class="s1">names_idx </span><span class="s4">: </span><span class="s1">names_idx </span><span class="s4">+ </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]]</span>
                    <span class="s1">adapter</span><span class="s4">.</span><span class="s1">rename_columns</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">names_out</span><span class="s4">)</span>
                    <span class="s1">names_idx </span><span class="s4">+= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>

                <span class="s1">output </span><span class="s4">= </span><span class="s1">adapter</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">(</span><span class="s1">Xs</span><span class="s4">)</span>
                <span class="s1">output_samples </span><span class="s4">= </span><span class="s1">output</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
                <span class="s3">if </span><span class="s1">output_samples </span><span class="s4">!= </span><span class="s1">n_samples</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                        <span class="s5">&quot;Concatenating DataFrames from the transformer's output lead to&quot;</span>
                        <span class="s5">&quot; an inconsistent number of samples. The output may have Pandas&quot;</span>
                        <span class="s5">&quot; Indexes that do not match, or that transformers are returning&quot;</span>
                        <span class="s5">&quot; number of samples which are not the same as the number input&quot;</span>
                        <span class="s5">&quot; samples.&quot;</span>
                    <span class="s4">)</span>

                <span class="s3">return </span><span class="s1">output</span>

            <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">(</span><span class="s1">Xs</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_sk_visual_block_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">remainder</span><span class="s4">, </span><span class="s1">str</span><span class="s4">) </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">remainder </span><span class="s4">== </span><span class="s5">&quot;drop&quot;</span><span class="s4">:</span>
            <span class="s1">transformers </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformers</span>
        <span class="s3">elif </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;_remainder&quot;</span><span class="s4">):</span>
            <span class="s1">remainder_columns </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_remainder</span><span class="s4">[</span><span class="s6">2</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s4">(</span>
                <span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;feature_names_in_&quot;</span><span class="s4">)</span>
                <span class="s3">and </span><span class="s1">remainder_columns</span>
                <span class="s3">and not </span><span class="s1">all</span><span class="s4">(</span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">col</span><span class="s4">, </span><span class="s1">str</span><span class="s4">) </span><span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">remainder_columns</span><span class="s4">)</span>
            <span class="s4">):</span>
                <span class="s1">remainder_columns </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">feature_names_in_</span><span class="s4">[</span><span class="s1">remainder_columns</span><span class="s4">].</span><span class="s1">tolist</span><span class="s4">()</span>
            <span class="s1">transformers </span><span class="s4">= </span><span class="s1">chain</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">transformers</span><span class="s4">, [(</span><span class="s5">&quot;remainder&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">remainder</span><span class="s4">, </span><span class="s1">remainder_columns</span><span class="s4">)]</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">transformers </span><span class="s4">= </span><span class="s1">chain</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformers</span><span class="s4">, [(</span><span class="s5">&quot;remainder&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">remainder</span><span class="s4">, </span><span class="s5">&quot;&quot;</span><span class="s4">)])</span>

        <span class="s1">names</span><span class="s4">, </span><span class="s1">transformers</span><span class="s4">, </span><span class="s1">name_details </span><span class="s4">= </span><span class="s1">zip</span><span class="s4">(*</span><span class="s1">transformers</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">_VisualBlock</span><span class="s4">(</span>
            <span class="s5">&quot;parallel&quot;</span><span class="s4">, </span><span class="s1">transformers</span><span class="s4">, </span><span class="s1">names</span><span class="s4">=</span><span class="s1">names</span><span class="s4">, </span><span class="s1">name_details</span><span class="s4">=</span><span class="s1">name_details</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__getitem__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">):</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">named_transformers_</span><span class="s4">[</span><span class="s1">key</span><span class="s4">]</span>
        <span class="s3">except </span><span class="s1">AttributeError </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span>
                <span class="s5">&quot;ColumnTransformer is subscriptable after it is fitted&quot;</span>
            <span class="s4">) </span><span class="s3">from </span><span class="s1">e</span>
        <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">KeyError</span><span class="s4">(</span><span class="s5">f&quot;'</span><span class="s3">{</span><span class="s1">key</span><span class="s3">}</span><span class="s5">' is not a valid transformer name&quot;</span><span class="s4">) </span><span class="s3">from </span><span class="s1">e</span>

    <span class="s3">def </span><span class="s1">_get_empty_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return empty routing. 
 
        Used while routing can be disabled. 
 
        TODO: Remove when ``set_config(enable_metadata_routing=False)`` is no 
        more an option. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Bunch</span><span class="s4">(</span>
            <span class="s4">**{</span>
                <span class="s1">name</span><span class="s4">: </span><span class="s1">Bunch</span><span class="s4">(**{</span><span class="s1">method</span><span class="s4">: {} </span><span class="s3">for </span><span class="s1">method </span><span class="s3">in </span><span class="s1">METHODS</span><span class="s4">})</span>
                <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">step</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span>
                    <span class="s1">fitted</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                    <span class="s1">column_as_labels</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                    <span class="s1">skip_drop</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                    <span class="s1">skip_empty_columns</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                <span class="s4">)</span>
            <span class="s4">}</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_metadata_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Get metadata routing of this object. 
 
        Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing 
        mechanism works. 
 
        .. versionadded:: 1.4 
 
        Returns 
        ------- 
        routing : MetadataRouter 
            A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating 
            routing information. 
        &quot;&quot;&quot;</span>
        <span class="s1">router </span><span class="s4">= </span><span class="s1">MetadataRouter</span><span class="s4">(</span><span class="s1">owner</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">)</span>
        <span class="s2"># Here we don't care about which columns are used for which</span>
        <span class="s2"># transformers, and whether or not a transformer is used at all, which</span>
        <span class="s2"># might happen if no columns are selected for that transformer. We</span>
        <span class="s2"># request all metadata requested by all transformers.</span>
        <span class="s1">transformers </span><span class="s4">= </span><span class="s1">chain</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformers</span><span class="s4">, [(</span><span class="s5">&quot;remainder&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">remainder</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)])</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">step</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">transformers</span><span class="s4">:</span>
            <span class="s1">method_mapping </span><span class="s4">= </span><span class="s1">MethodMapping</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">step</span><span class="s4">, </span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">):</span>
                <span class="s4">(</span>
                    <span class="s1">method_mapping</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">).</span><span class="s1">add</span><span class="s4">(</span>
                        <span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span>
                    <span class="s4">)</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s4">(</span>
                    <span class="s1">method_mapping</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">)</span>
                    <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>
                    <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">)</span>
                    <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>
                <span class="s4">)</span>
            <span class="s1">method_mapping</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>
            <span class="s1">router</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">method_mapping</span><span class="s4">=</span><span class="s1">method_mapping</span><span class="s4">, **{</span><span class="s1">name</span><span class="s4">: </span><span class="s1">step</span><span class="s4">})</span>

        <span class="s3">return </span><span class="s1">router</span>


<span class="s3">def </span><span class="s1">_check_X</span><span class="s4">(</span><span class="s1">X</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Use check_array only when necessary, e.g. on lists and other non-array-likes.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s5">&quot;__array__&quot;</span><span class="s4">) </span><span class="s3">or </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s5">&quot;__dataframe__&quot;</span><span class="s4">) </span><span class="s3">or </span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">X</span>
    <span class="s3">return </span><span class="s1">check_array</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">force_all_finite</span><span class="s4">=</span><span class="s5">&quot;allow-nan&quot;</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">object</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_is_empty_column_selection</span><span class="s4">(</span><span class="s1">column</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return True if the column selection is empty (empty list or all-False 
    boolean array). 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">column</span><span class="s4">, </span><span class="s5">&quot;dtype&quot;</span><span class="s4">) </span><span class="s3">and </span><span class="s1">np</span><span class="s4">.</span><span class="s1">issubdtype</span><span class="s4">(</span><span class="s1">column</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">bool_</span><span class="s4">):</span>
        <span class="s3">return not </span><span class="s1">column</span><span class="s4">.</span><span class="s1">any</span><span class="s4">()</span>
    <span class="s3">elif </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">column</span><span class="s4">, </span><span class="s5">&quot;__len__&quot;</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">len</span><span class="s4">(</span><span class="s1">column</span><span class="s4">) == </span><span class="s6">0</span>
            <span class="s3">or </span><span class="s1">all</span><span class="s4">(</span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">col</span><span class="s4">, </span><span class="s1">bool</span><span class="s4">) </span><span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">column</span><span class="s4">)</span>
            <span class="s3">and not </span><span class="s1">any</span><span class="s4">(</span><span class="s1">column</span><span class="s4">)</span>
        <span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return False</span>


<span class="s3">def </span><span class="s1">_get_transformer_list</span><span class="s4">(</span><span class="s1">estimators</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Construct (name, trans, column) tuples from list 
 
    &quot;&quot;&quot;</span>
    <span class="s1">transformers</span><span class="s4">, </span><span class="s1">columns </span><span class="s4">= </span><span class="s1">zip</span><span class="s4">(*</span><span class="s1">estimators</span><span class="s4">)</span>
    <span class="s1">names</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">zip</span><span class="s4">(*</span><span class="s1">_name_estimators</span><span class="s4">(</span><span class="s1">transformers</span><span class="s4">))</span>

    <span class="s1">transformer_list </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">zip</span><span class="s4">(</span><span class="s1">names</span><span class="s4">, </span><span class="s1">transformers</span><span class="s4">, </span><span class="s1">columns</span><span class="s4">))</span>
    <span class="s3">return </span><span class="s1">transformer_list</span>


<span class="s2"># This function is not validated using validate_params because</span>
<span class="s2"># it's just a factory for ColumnTransformer.</span>
<span class="s3">def </span><span class="s1">make_column_transformer</span><span class="s4">(</span>
    <span class="s4">*</span><span class="s1">transformers</span><span class="s4">,</span>
    <span class="s1">remainder</span><span class="s4">=</span><span class="s5">&quot;drop&quot;</span><span class="s4">,</span>
    <span class="s1">sparse_threshold</span><span class="s4">=</span><span class="s6">0.3</span><span class="s4">,</span>
    <span class="s1">n_jobs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">verbose</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s1">verbose_feature_names_out</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
    <span class="s1">force_int_remainder_cols</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Construct a ColumnTransformer from the given transformers. 
 
    This is a shorthand for the ColumnTransformer constructor; it does not 
    require, and does not permit, naming the transformers. Instead, they will 
    be given names automatically based on their types. It also does not allow 
    weighting with ``transformer_weights``. 
 
    Read more in the :ref:`User Guide &lt;make_column_transformer&gt;`. 
 
    Parameters 
    ---------- 
    *transformers : tuples 
        Tuples of the form (transformer, columns) specifying the 
        transformer objects to be applied to subsets of the data. 
 
        transformer : {'drop', 'passthrough'} or estimator 
            Estimator must support :term:`fit` and :term:`transform`. 
            Special-cased strings 'drop' and 'passthrough' are accepted as 
            well, to indicate to drop the columns or to pass them through 
            untransformed, respectively. 
        columns : str,  array-like of str, int, array-like of int, slice, \ 
                array-like of bool or callable 
            Indexes the data on its second axis. Integers are interpreted as 
            positional columns, while strings can reference DataFrame columns 
            by name. A scalar string or int should be used where 
            ``transformer`` expects X to be a 1d array-like (vector), 
            otherwise a 2d array will be passed to the transformer. 
            A callable is passed the input data `X` and can return any of the 
            above. To select multiple columns by name or dtype, you can use 
            :obj:`make_column_selector`. 
 
    remainder : {'drop', 'passthrough'} or estimator, default='drop' 
        By default, only the specified columns in `transformers` are 
        transformed and combined in the output, and the non-specified 
        columns are dropped. (default of ``'drop'``). 
        By specifying ``remainder='passthrough'``, all remaining columns that 
        were not specified in `transformers` will be automatically passed 
        through. This subset of columns is concatenated with the output of 
        the transformers. 
        By setting ``remainder`` to be an estimator, the remaining 
        non-specified columns will use the ``remainder`` estimator. The 
        estimator must support :term:`fit` and :term:`transform`. 
 
    sparse_threshold : float, default=0.3 
        If the transformed output consists of a mix of sparse and dense data, 
        it will be stacked as a sparse matrix if the density is lower than this 
        value. Use ``sparse_threshold=0`` to always return dense. 
        When the transformed output consists of all sparse or all dense data, 
        the stacked result will be sparse or dense, respectively, and this 
        keyword will be ignored. 
 
    n_jobs : int, default=None 
        Number of jobs to run in parallel. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    verbose : bool, default=False 
        If True, the time elapsed while fitting each transformer will be 
        printed as it is completed. 
 
    verbose_feature_names_out : bool, default=True 
        If True, :meth:`ColumnTransformer.get_feature_names_out` will prefix 
        all feature names with the name of the transformer that generated that 
        feature. 
        If False, :meth:`ColumnTransformer.get_feature_names_out` will not 
        prefix any feature names and will error if feature names are not 
        unique. 
 
        .. versionadded:: 1.0 
 
    force_int_remainder_cols : bool, default=True 
        Force the columns of the last entry of `transformers_`, which 
        corresponds to the &quot;remainder&quot; transformer, to always be stored as 
        indices (int) rather than column names (str). See description of the 
        :attr:`ColumnTransformer.transformers_` attribute for details. 
 
        .. note:: 
            If you do not access the list of columns for the remainder columns 
            in the :attr:`ColumnTransformer.transformers_` fitted attribute, 
            you do not need to set this parameter. 
 
        .. versionadded:: 1.5 
 
        .. versionchanged:: 1.7 
           The default value for `force_int_remainder_cols` will change from 
           `True` to `False` in version 1.7. 
 
    Returns 
    ------- 
    ct : ColumnTransformer 
        Returns a :class:`ColumnTransformer` object. 
 
    See Also 
    -------- 
    ColumnTransformer : Class that allows combining the 
        outputs of multiple transformer objects used on column subsets 
        of the data into a single feature space. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import StandardScaler, OneHotEncoder 
    &gt;&gt;&gt; from sklearn.compose import make_column_transformer 
    &gt;&gt;&gt; make_column_transformer( 
    ...     (StandardScaler(), ['numerical_column']), 
    ...     (OneHotEncoder(), ['categorical_column'])) 
    ColumnTransformer(transformers=[('standardscaler', StandardScaler(...), 
                                     ['numerical_column']), 
                                    ('onehotencoder', OneHotEncoder(...), 
                                     ['categorical_column'])]) 
    &quot;&quot;&quot;</span>
    <span class="s2"># transformer_weights keyword is not passed through because the user</span>
    <span class="s2"># would need to know the automatically generated names of the transformers</span>
    <span class="s1">transformer_list </span><span class="s4">= </span><span class="s1">_get_transformer_list</span><span class="s4">(</span><span class="s1">transformers</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">ColumnTransformer</span><span class="s4">(</span>
        <span class="s1">transformer_list</span><span class="s4">,</span>
        <span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">n_jobs</span><span class="s4">,</span>
        <span class="s1">remainder</span><span class="s4">=</span><span class="s1">remainder</span><span class="s4">,</span>
        <span class="s1">sparse_threshold</span><span class="s4">=</span><span class="s1">sparse_threshold</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">,</span>
        <span class="s1">verbose_feature_names_out</span><span class="s4">=</span><span class="s1">verbose_feature_names_out</span><span class="s4">,</span>
        <span class="s1">force_int_remainder_cols</span><span class="s4">=</span><span class="s1">force_int_remainder_cols</span><span class="s4">,</span>
    <span class="s4">)</span>


<span class="s3">class </span><span class="s1">make_column_selector</span><span class="s4">:</span>
    <span class="s0">&quot;&quot;&quot;Create a callable to select columns to be used with 
    :class:`ColumnTransformer`. 
 
    :func:`make_column_selector` can select columns based on datatype or the 
    columns name with a regex. When using multiple selection criteria, **all** 
    criteria must match for a column to be selected. 
 
    For an example of how to use :func:`make_column_selector` within a 
    :class:`ColumnTransformer` to select columns based on data type (i.e. 
    `dtype`), refer to 
    :ref:`sphx_glr_auto_examples_compose_plot_column_transformer_mixed_types.py`. 
 
    Parameters 
    ---------- 
    pattern : str, default=None 
        Name of columns containing this regex pattern will be included. If 
        None, column selection will not be selected based on pattern. 
 
    dtype_include : column dtype or list of column dtypes, default=None 
        A selection of dtypes to include. For more details, see 
        :meth:`pandas.DataFrame.select_dtypes`. 
 
    dtype_exclude : column dtype or list of column dtypes, default=None 
        A selection of dtypes to exclude. For more details, see 
        :meth:`pandas.DataFrame.select_dtypes`. 
 
    Returns 
    ------- 
    selector : callable 
        Callable for column selection to be used by a 
        :class:`ColumnTransformer`. 
 
    See Also 
    -------- 
    ColumnTransformer : Class that allows combining the 
        outputs of multiple transformer objects used on column subsets 
        of the data into a single feature space. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.preprocessing import StandardScaler, OneHotEncoder 
    &gt;&gt;&gt; from sklearn.compose import make_column_transformer 
    &gt;&gt;&gt; from sklearn.compose import make_column_selector 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import pandas as pd  # doctest: +SKIP 
    &gt;&gt;&gt; X = pd.DataFrame({'city': ['London', 'London', 'Paris', 'Sallisaw'], 
    ...                   'rating': [5, 3, 4, 5]})  # doctest: +SKIP 
    &gt;&gt;&gt; ct = make_column_transformer( 
    ...       (StandardScaler(), 
    ...        make_column_selector(dtype_include=np.number)),  # rating 
    ...       (OneHotEncoder(), 
    ...        make_column_selector(dtype_include=object)))  # city 
    &gt;&gt;&gt; ct.fit_transform(X)  # doctest: +SKIP 
    array([[ 0.90453403,  1.        ,  0.        ,  0.        ], 
           [-1.50755672,  1.        ,  0.        ,  0.        ], 
           [-0.30151134,  0.        ,  1.        ,  0.        ], 
           [ 0.90453403,  0.        ,  0.        ,  1.        ]]) 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">pattern</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, *, </span><span class="s1">dtype_include</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">dtype_exclude</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">pattern </span><span class="s4">= </span><span class="s1">pattern</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">dtype_include </span><span class="s4">= </span><span class="s1">dtype_include</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">dtype_exclude </span><span class="s4">= </span><span class="s1">dtype_exclude</span>

    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">df</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Callable for column selection to be used by a 
        :class:`ColumnTransformer`. 
 
        Parameters 
        ---------- 
        df : dataframe of shape (n_features, n_samples) 
            DataFrame to select columns from. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">df</span><span class="s4">, </span><span class="s5">&quot;iloc&quot;</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;make_column_selector can only be applied to pandas dataframes&quot;</span>
            <span class="s4">)</span>
        <span class="s1">df_row </span><span class="s4">= </span><span class="s1">df</span><span class="s4">.</span><span class="s1">iloc</span><span class="s4">[:</span><span class="s6">1</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dtype_include </span><span class="s3">is not None or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dtype_exclude </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">df_row </span><span class="s4">= </span><span class="s1">df_row</span><span class="s4">.</span><span class="s1">select_dtypes</span><span class="s4">(</span>
                <span class="s1">include</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">dtype_include</span><span class="s4">, </span><span class="s1">exclude</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">dtype_exclude</span>
            <span class="s4">)</span>
        <span class="s1">cols </span><span class="s4">= </span><span class="s1">df_row</span><span class="s4">.</span><span class="s1">columns</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">pattern </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">cols </span><span class="s4">= </span><span class="s1">cols</span><span class="s4">[</span><span class="s1">cols</span><span class="s4">.</span><span class="s1">str</span><span class="s4">.</span><span class="s1">contains</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">pattern</span><span class="s4">, </span><span class="s1">regex</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)]</span>
        <span class="s3">return </span><span class="s1">cols</span><span class="s4">.</span><span class="s1">tolist</span><span class="s4">()</span>


<span class="s3">class </span><span class="s1">_RemainderColsList</span><span class="s4">(</span><span class="s1">UserList</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;A list that raises a warning whenever items are accessed. 
 
    It is used to store the columns handled by the &quot;remainder&quot; entry of 
    ``ColumnTransformer.transformers_``, ie ``transformers_[-1][-1]``. 
 
    For some values of the ``ColumnTransformer`` ``transformers`` parameter, 
    this list of indices will be replaced by either a list of column names or a 
    boolean mask; in those cases we emit a ``FutureWarning`` the first time an 
    element is accessed. 
 
    Parameters 
    ---------- 
    columns : list of int 
        The remainder columns. 
 
    future_dtype : {'str', 'bool'}, default=None 
        The dtype that will be used by a ColumnTransformer with the same inputs 
        in a future release. There is a default value because providing a 
        constructor that takes a single argument is a requirement for 
        subclasses of UserList, but we do not use it in practice. It would only 
        be used if a user called methods that return a new list such are 
        copying or concatenating `_RemainderColsList`. 
 
    warning_was_emitted : bool, default=False 
       Whether the warning for that particular list was already shown, so we 
       only emit it once. 
 
    warning_enabled : bool, default=True 
        When False, the list never emits the warning nor updates 
        `warning_was_emitted``. This is used to obtain a quiet copy of the list 
        for use by the `ColumnTransformer` itself, so that the warning is only 
        shown when a user accesses it directly. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">columns</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">future_dtype</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">warning_was_emitted</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">warning_enabled</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">columns</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">future_dtype </span><span class="s4">= </span><span class="s1">future_dtype</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">warning_was_emitted </span><span class="s4">= </span><span class="s1">warning_was_emitted</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">warning_enabled </span><span class="s4">= </span><span class="s1">warning_enabled</span>

    <span class="s3">def </span><span class="s1">__getitem__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">index</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_show_remainder_cols_warning</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">__getitem__</span><span class="s4">(</span><span class="s1">index</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_show_remainder_cols_warning</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">warning_was_emitted </span><span class="s3">or not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">warning_enabled</span><span class="s4">:</span>
            <span class="s3">return</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">warning_was_emitted </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s1">future_dtype_description </span><span class="s4">= {</span>
            <span class="s5">&quot;str&quot;</span><span class="s4">: </span><span class="s5">&quot;column names (of type str)&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;bool&quot;</span><span class="s4">: </span><span class="s5">&quot;a mask array (of type bool)&quot;</span><span class="s4">,</span>
            <span class="s2"># shouldn't happen because we always initialize it with a</span>
            <span class="s2"># non-default future_dtype</span>
            <span class="s3">None</span><span class="s4">: </span><span class="s5">&quot;a different type depending on the ColumnTransformer inputs&quot;</span><span class="s4">,</span>
        <span class="s4">}.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">future_dtype</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">future_dtype</span><span class="s4">)</span>

        <span class="s2"># TODO(1.7) Update the warning to say that the old behavior will be</span>
        <span class="s2"># removed in 1.9.</span>
        <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
            <span class="s4">(</span>
                <span class="s5">&quot;</span><span class="s3">\n</span><span class="s5">The format of the columns of the 'remainder' transformer in&quot;</span>
                <span class="s5">&quot; ColumnTransformer.transformers_ will change in version 1.7 to&quot;</span>
                <span class="s5">&quot; match the format of the other transformers.</span><span class="s3">\n</span><span class="s5">At the moment the&quot;</span>
                <span class="s5">&quot; remainder columns are stored as indices (of type int). With the same&quot;</span>
                <span class="s5">&quot; ColumnTransformer configuration, in the future they will be stored&quot;</span>
                <span class="s5">f&quot; as </span><span class="s3">{</span><span class="s1">future_dtype_description</span><span class="s3">}</span><span class="s5">.</span><span class="s3">\n</span><span class="s5">To use the new behavior now and&quot;</span>
                <span class="s5">&quot; suppress this warning, use&quot;</span>
                <span class="s5">&quot; ColumnTransformer(force_int_remainder_cols=False).</span><span class="s3">\n</span><span class="s5">&quot;</span>
            <span class="s4">),</span>
            <span class="s1">category</span><span class="s4">=</span><span class="s1">FutureWarning</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_repr_pretty_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">printer</span><span class="s4">, *</span><span class="s1">_</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Override display in ipython console, otherwise the class name is shown.&quot;&quot;&quot;</span>
        <span class="s1">printer</span><span class="s4">.</span><span class="s1">text</span><span class="s4">(</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">data</span><span class="s4">))</span>


<span class="s3">def </span><span class="s1">_with_dtype_warning_enabled_set_to</span><span class="s4">(</span><span class="s1">warning_enabled</span><span class="s4">, </span><span class="s1">transformers</span><span class="s4">):</span>
    <span class="s1">result </span><span class="s4">= []</span>
    <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">columns </span><span class="s3">in </span><span class="s1">transformers</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">columns</span><span class="s4">, </span><span class="s1">_RemainderColsList</span><span class="s4">):</span>
            <span class="s1">columns </span><span class="s4">= </span><span class="s1">_RemainderColsList</span><span class="s4">(</span>
                <span class="s1">columns</span><span class="s4">.</span><span class="s1">data</span><span class="s4">,</span>
                <span class="s1">future_dtype</span><span class="s4">=</span><span class="s1">columns</span><span class="s4">.</span><span class="s1">future_dtype</span><span class="s4">,</span>
                <span class="s1">warning_was_emitted</span><span class="s4">=</span><span class="s1">columns</span><span class="s4">.</span><span class="s1">warning_was_emitted</span><span class="s4">,</span>
                <span class="s1">warning_enabled</span><span class="s4">=</span><span class="s1">warning_enabled</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s1">result</span><span class="s4">.</span><span class="s1">append</span><span class="s4">((</span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">columns</span><span class="s4">))</span>
    <span class="s3">return </span><span class="s1">result</span>
</pre>
</body>
</html>