<html>
<head>
<title>test_numpy.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_numpy.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
This file contains a minimal set of tests for compliance with the extension 
array interface test suite, and should contain no other tests. 
The test suite for the full functionality of the array is located in 
`pandas/tests/arrays/`. 
 
The tests in this file are inherited from the BaseExtensionTests, and only 
minimal tweaks should be applied to get the tests passing (by overwriting a 
parent method). 
 
Additional tests should either be added to one of the BaseExtensionTests 
classes (if they are relevant for the extension interface for all dtypes), or 
be added to the array-specific tests in `pandas/tests/arrays/`. 
 
Note: we do not bother with base.BaseIndexTests because NumpyExtensionArray 
will never be held in an Index. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">dtypes</span><span class="s3">.</span><span class="s1">dtypes </span><span class="s2">import </span><span class="s1">NumpyEADtype</span>

<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">_testing </span><span class="s2">as </span><span class="s1">tm</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">api</span><span class="s3">.</span><span class="s1">types </span><span class="s2">import </span><span class="s1">is_object_dtype</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">core</span><span class="s3">.</span><span class="s1">arrays</span><span class="s3">.</span><span class="s1">numpy_ </span><span class="s2">import </span><span class="s1">NumpyExtensionArray</span>
<span class="s2">from </span><span class="s1">pandas</span><span class="s3">.</span><span class="s1">tests</span><span class="s3">.</span><span class="s1">extension </span><span class="s2">import </span><span class="s1">base</span>

<span class="s1">orig_assert_attr_equal </span><span class="s3">= </span><span class="s1">tm</span><span class="s3">.</span><span class="s1">assert_attr_equal</span>


<span class="s2">def </span><span class="s1">_assert_attr_equal</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">str </span><span class="s3">= </span><span class="s4">&quot;Attributes&quot;</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    patch tm.assert_attr_equal so NumpyEADtype(&quot;object&quot;) is closed enough to 
    np.dtype(&quot;object&quot;) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">attr </span><span class="s3">== </span><span class="s4">&quot;dtype&quot;</span><span class="s3">:</span>
        <span class="s1">lattr </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">left</span><span class="s3">, </span><span class="s4">&quot;dtype&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">rattr </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">right</span><span class="s3">, </span><span class="s4">&quot;dtype&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">lattr</span><span class="s3">, </span><span class="s1">NumpyEADtype</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rattr</span><span class="s3">, </span><span class="s1">NumpyEADtype</span><span class="s3">):</span>
            <span class="s1">left </span><span class="s3">= </span><span class="s1">left</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">lattr</span><span class="s3">.</span><span class="s1">numpy_dtype</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">rattr</span><span class="s3">, </span><span class="s1">NumpyEADtype</span><span class="s3">) </span><span class="s2">and not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">lattr</span><span class="s3">, </span><span class="s1">NumpyEADtype</span><span class="s3">):</span>
            <span class="s1">right </span><span class="s3">= </span><span class="s1">right</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">rattr</span><span class="s3">.</span><span class="s1">numpy_dtype</span><span class="s3">)</span>

    <span class="s1">orig_assert_attr_equal</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">, </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span><span class="s3">(</span><span class="s1">params</span><span class="s3">=[</span><span class="s4">&quot;float&quot;</span><span class="s3">, </span><span class="s4">&quot;object&quot;</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">request</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">NumpyEADtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">request</span><span class="s3">.</span><span class="s1">param</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span>
<span class="s2">def </span><span class="s1">allow_in_pandas</span><span class="s3">(</span><span class="s1">monkeypatch</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A monkeypatch to tells pandas to let us in. 
 
    By default, passing a NumpyExtensionArray to an index / series / frame 
    constructor will unbox that NumpyExtensionArray to an ndarray, and treat 
    it as a non-EA column. We don't want people using EAs without 
    reason. 
 
    The mechanism for this is a check against ABCNumpyExtensionArray 
    in each constructor. 
 
    But, for testing, we need to allow them in pandas. So we patch 
    the _typ of NumpyExtensionArray, so that we evade the ABCNumpyExtensionArray 
    check. 
    &quot;&quot;&quot;</span>
    <span class="s2">with </span><span class="s1">monkeypatch</span><span class="s3">.</span><span class="s1">context</span><span class="s3">() </span><span class="s2">as </span><span class="s1">m</span><span class="s3">:</span>
        <span class="s1">m</span><span class="s3">.</span><span class="s1">setattr</span><span class="s3">(</span><span class="s1">NumpyExtensionArray</span><span class="s3">, </span><span class="s4">&quot;_typ&quot;</span><span class="s3">, </span><span class="s4">&quot;extension&quot;</span><span class="s3">)</span>
        <span class="s1">m</span><span class="s3">.</span><span class="s1">setattr</span><span class="s3">(</span><span class="s1">tm</span><span class="s3">.</span><span class="s1">asserters</span><span class="s3">, </span><span class="s4">&quot;assert_attr_equal&quot;</span><span class="s3">, </span><span class="s1">_assert_attr_equal</span><span class="s3">)</span>
        <span class="s2">yield</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span>
<span class="s2">def </span><span class="s1">data</span><span class="s3">(</span><span class="s1">allow_in_pandas</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">numpy_dtype </span><span class="s3">== </span><span class="s4">&quot;object&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">Series</span><span class="s3">([(</span><span class="s1">i</span><span class="s3">,) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">100</span><span class="s3">)]).</span><span class="s1">array</span>
    <span class="s2">return </span><span class="s1">NumpyExtensionArray</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">101</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">_dtype</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span>
<span class="s2">def </span><span class="s1">data_missing</span><span class="s3">(</span><span class="s1">allow_in_pandas</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">numpy_dtype </span><span class="s3">== </span><span class="s4">&quot;object&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">NumpyExtensionArray</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, (</span><span class="s5">1</span><span class="s3">,)], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">NumpyExtensionArray</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">]))</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span>
<span class="s2">def </span><span class="s1">na_cmp</span><span class="s3">():</span>
    <span class="s2">def </span><span class="s1">cmp</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) </span><span class="s2">and </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">cmp</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span>
<span class="s2">def </span><span class="s1">data_for_sorting</span><span class="s3">(</span><span class="s1">allow_in_pandas</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Length-3 array with a known sort order. 
 
    This should be three items [B, C, A] with 
    A &lt; B &lt; C 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">numpy_dtype </span><span class="s3">== </span><span class="s4">&quot;object&quot;</span><span class="s3">:</span>
        <span class="s6"># Use an empty tuple for first element, then remove,</span>
        <span class="s6"># to disable np.array's shape inference.</span>
        <span class="s2">return </span><span class="s1">NumpyExtensionArray</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([(), (</span><span class="s5">2</span><span class="s3">,), (</span><span class="s5">3</span><span class="s3">,), (</span><span class="s5">1</span><span class="s3">,)], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">)[</span><span class="s5">1</span><span class="s3">:])</span>
    <span class="s2">return </span><span class="s1">NumpyExtensionArray</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]))</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span>
<span class="s2">def </span><span class="s1">data_missing_for_sorting</span><span class="s3">(</span><span class="s1">allow_in_pandas</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Length-3 array with a known sort order. 
 
    This should be three items [B, NA, A] with 
    A &lt; B and NA missing. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">numpy_dtype </span><span class="s3">== </span><span class="s4">&quot;object&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">NumpyExtensionArray</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([(</span><span class="s5">1</span><span class="s3">,), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, (</span><span class="s5">0</span><span class="s3">,)], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">NumpyExtensionArray</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">1</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]))</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span>
<span class="s2">def </span><span class="s1">data_for_grouping</span><span class="s3">(</span><span class="s1">allow_in_pandas</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Data for factorization, grouping, and unique tests. 
 
    Expected to be like [B, B, NA, NA, A, A, B, C] 
 
    Where A &lt; B &lt; C and NA is missing 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">numpy_dtype </span><span class="s3">== </span><span class="s4">&quot;object&quot;</span><span class="s3">:</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c </span><span class="s3">= (</span><span class="s5">1</span><span class="s3">,), (</span><span class="s5">2</span><span class="s3">,), (</span><span class="s5">3</span><span class="s3">,)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">3</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">NumpyExtensionArray</span><span class="s3">(</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">b</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">numpy_dtype</span><span class="s3">)</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span>
<span class="s2">def </span><span class="s1">data_for_twos</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;O&quot;</span><span class="s3">:</span>
        <span class="s1">pytest</span><span class="s3">.</span><span class="s1">skip</span><span class="s3">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">} </span><span class="s4">is not a numeric dtype&quot;</span><span class="s3">)</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">100</span><span class="s3">) * </span><span class="s5">2</span>
    <span class="s2">return </span><span class="s1">NumpyExtensionArray</span><span class="s3">.</span><span class="s1">_from_sequence</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">fixture</span>
<span class="s2">def </span><span class="s1">skip_numpy_object</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">request</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests for NumpyExtensionArray with nested data. Users typically won't create 
    these objects via `pd.array`, but they can show up through `.array` 
    on a Series with nested data. Many of the base tests fail, as they aren't 
    appropriate for nested data. 
 
    This fixture allows these tests to be skipped when used as a usefixtures 
    marker to either an individual test or a test class. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s3">== </span><span class="s4">&quot;object&quot;</span><span class="s3">:</span>
        <span class="s1">mark </span><span class="s3">= </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">xfail</span><span class="s3">(</span><span class="s1">reason</span><span class="s3">=</span><span class="s4">&quot;Fails for object dtype&quot;</span><span class="s3">)</span>
        <span class="s1">request</span><span class="s3">.</span><span class="s1">applymarker</span><span class="s3">(</span><span class="s1">mark</span><span class="s3">)</span>


<span class="s1">skip_nested </span><span class="s3">= </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">usefixtures</span><span class="s3">(</span><span class="s4">&quot;skip_numpy_object&quot;</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">TestNumpyExtensionArray</span><span class="s3">(</span><span class="s1">base</span><span class="s3">.</span><span class="s1">ExtensionTests</span><span class="s3">):</span>
    <span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">skip</span><span class="s3">(</span><span class="s1">reason</span><span class="s3">=</span><span class="s4">&quot;We don't register our dtype&quot;</span><span class="s3">)</span>
    <span class="s6"># We don't want to register. This test should probably be split in two.</span>
    <span class="s2">def </span><span class="s1">test_from_dtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s2">def </span><span class="s1">test_series_constructor_scalar_with_index</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">):</span>
        <span class="s6"># ValueError: Length of passed values is 1, index implies 3.</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_series_constructor_scalar_with_index</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_check_dtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">request</span><span class="s3">, </span><span class="s1">using_infer_string</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">numpy_dtype </span><span class="s3">== </span><span class="s4">&quot;object&quot;</span><span class="s3">:</span>
            <span class="s1">request</span><span class="s3">.</span><span class="s1">applymarker</span><span class="s3">(</span>
                <span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">xfail</span><span class="s3">(</span>
                    <span class="s1">reason</span><span class="s3">=</span><span class="s4">f&quot;NumpyExtensionArray expectedly clashes with a &quot;</span>
                    <span class="s4">f&quot;NumPy name: </span><span class="s2">{</span><span class="s1">data</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">numpy_dtype</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s3">)</span>
            <span class="s3">)</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_check_dtype</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_is_not_object_type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">request</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">numpy_dtype </span><span class="s3">== </span><span class="s4">&quot;object&quot;</span><span class="s3">:</span>
            <span class="s6"># Different from BaseDtypeTests.test_is_not_object_type</span>
            <span class="s6"># because NumpyEADtype(object) is an object type</span>
            <span class="s2">assert </span><span class="s1">is_object_dtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">super</span><span class="s3">().</span><span class="s1">test_is_not_object_type</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s2">def </span><span class="s1">test_getitem_scalar</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
        <span class="s6"># AssertionError</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_getitem_scalar</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s2">def </span><span class="s1">test_shift_fill_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
        <span class="s6"># np.array shape inference. Shift implementation fails.</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_shift_fill_value</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s2">def </span><span class="s1">test_fillna_copy_frame</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data_missing</span><span class="s3">):</span>
        <span class="s6"># The &quot;scalar&quot; for this array isn't a scalar.</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_fillna_copy_frame</span><span class="s3">(</span><span class="s1">data_missing</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s2">def </span><span class="s1">test_fillna_copy_series</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data_missing</span><span class="s3">):</span>
        <span class="s6"># The &quot;scalar&quot; for this array isn't a scalar.</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_fillna_copy_series</span><span class="s3">(</span><span class="s1">data_missing</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s2">def </span><span class="s1">test_searchsorted</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data_for_sorting</span><span class="s3">, </span><span class="s1">as_series</span><span class="s3">):</span>
        <span class="s6"># TODO: NumpyExtensionArray.searchsorted calls ndarray.searchsorted which</span>
        <span class="s6">#  isn't quite what we want in nested data cases. Instead we need to</span>
        <span class="s6">#  adapt something like libindex._bin_search.</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_searchsorted</span><span class="s3">(</span><span class="s1">data_for_sorting</span><span class="s3">, </span><span class="s1">as_series</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">xfail</span><span class="s3">(</span><span class="s1">reason</span><span class="s3">=</span><span class="s4">&quot;NumpyExtensionArray.diff may fail on dtype&quot;</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">test_diff</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">periods</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">super</span><span class="s3">().</span><span class="s1">test_diff</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">periods</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_insert</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">request</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">numpy_dtype </span><span class="s3">== </span><span class="s1">object</span><span class="s3">:</span>
            <span class="s1">mark </span><span class="s3">= </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">xfail</span><span class="s3">(</span><span class="s1">reason</span><span class="s3">=</span><span class="s4">&quot;Dimension mismatch in np.concatenate&quot;</span><span class="s3">)</span>
            <span class="s1">request</span><span class="s3">.</span><span class="s1">applymarker</span><span class="s3">(</span><span class="s1">mark</span><span class="s3">)</span>

        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_insert</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s2">def </span><span class="s1">test_insert_invalid</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">invalid_scalar</span><span class="s3">):</span>
        <span class="s6"># NumpyExtensionArray[object] can hold anything, so skip</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_insert_invalid</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">invalid_scalar</span><span class="s3">)</span>

    <span class="s1">divmod_exc </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s1">series_scalar_exc </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s1">frame_scalar_exc </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s1">series_array_exc </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">test_divmod</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
        <span class="s1">divmod_exc </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;O&quot;</span><span class="s3">:</span>
            <span class="s1">divmod_exc </span><span class="s3">= </span><span class="s1">TypeError</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">divmod_exc </span><span class="s3">= </span><span class="s1">divmod_exc</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_divmod</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_divmod_series_array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
        <span class="s1">ser </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">Series</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
        <span class="s1">exc </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;O&quot;</span><span class="s3">:</span>
            <span class="s1">exc </span><span class="s3">= </span><span class="s1">TypeError</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">divmod_exc </span><span class="s3">= </span><span class="s1">exc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_check_divmod_op</span><span class="s3">(</span><span class="s1">ser</span><span class="s3">, </span><span class="s1">divmod</span><span class="s3">, </span><span class="s1">data</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_arith_series_with_scalar</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">all_arithmetic_operators</span><span class="s3">, </span><span class="s1">request</span><span class="s3">):</span>
        <span class="s1">opname </span><span class="s3">= </span><span class="s1">all_arithmetic_operators</span>
        <span class="s1">series_scalar_exc </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">numpy_dtype </span><span class="s3">== </span><span class="s1">object</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">opname </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;__mul__&quot;</span><span class="s3">, </span><span class="s4">&quot;__rmul__&quot;</span><span class="s3">]:</span>
                <span class="s1">mark </span><span class="s3">= </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">xfail</span><span class="s3">(</span>
                    <span class="s1">reason</span><span class="s3">=</span><span class="s4">&quot;the Series.combine step raises but not the Series method.&quot;</span>
                <span class="s3">)</span>
                <span class="s1">request</span><span class="s3">.</span><span class="s1">node</span><span class="s3">.</span><span class="s1">add_marker</span><span class="s3">(</span><span class="s1">mark</span><span class="s3">)</span>
            <span class="s1">series_scalar_exc </span><span class="s3">= </span><span class="s1">TypeError</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">series_scalar_exc </span><span class="s3">= </span><span class="s1">series_scalar_exc</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_arith_series_with_scalar</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">all_arithmetic_operators</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_arith_series_with_array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">all_arithmetic_operators</span><span class="s3">):</span>
        <span class="s1">opname </span><span class="s3">= </span><span class="s1">all_arithmetic_operators</span>
        <span class="s1">series_array_exc </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">numpy_dtype </span><span class="s3">== </span><span class="s1">object </span><span class="s2">and </span><span class="s1">opname </span><span class="s2">not in </span><span class="s3">[</span><span class="s4">&quot;__add__&quot;</span><span class="s3">, </span><span class="s4">&quot;__radd__&quot;</span><span class="s3">]:</span>
            <span class="s1">series_array_exc </span><span class="s3">= </span><span class="s1">TypeError</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">series_array_exc </span><span class="s3">= </span><span class="s1">series_array_exc</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_arith_series_with_array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">all_arithmetic_operators</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_arith_frame_with_scalar</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">all_arithmetic_operators</span><span class="s3">, </span><span class="s1">request</span><span class="s3">):</span>
        <span class="s1">opname </span><span class="s3">= </span><span class="s1">all_arithmetic_operators</span>
        <span class="s1">frame_scalar_exc </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">numpy_dtype </span><span class="s3">== </span><span class="s1">object</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">opname </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;__mul__&quot;</span><span class="s3">, </span><span class="s4">&quot;__rmul__&quot;</span><span class="s3">]:</span>
                <span class="s1">mark </span><span class="s3">= </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">xfail</span><span class="s3">(</span>
                    <span class="s1">reason</span><span class="s3">=</span><span class="s4">&quot;the Series.combine step raises but not the Series method.&quot;</span>
                <span class="s3">)</span>
                <span class="s1">request</span><span class="s3">.</span><span class="s1">node</span><span class="s3">.</span><span class="s1">add_marker</span><span class="s3">(</span><span class="s1">mark</span><span class="s3">)</span>
            <span class="s1">frame_scalar_exc </span><span class="s3">= </span><span class="s1">TypeError</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">frame_scalar_exc </span><span class="s3">= </span><span class="s1">frame_scalar_exc</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_arith_frame_with_scalar</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">all_arithmetic_operators</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_supports_reduction</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ser</span><span class="s3">: </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">Series</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">ser</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;O&quot;</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">op_name </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;sum&quot;</span><span class="s3">, </span><span class="s4">&quot;min&quot;</span><span class="s3">, </span><span class="s4">&quot;max&quot;</span><span class="s3">, </span><span class="s4">&quot;any&quot;</span><span class="s3">, </span><span class="s4">&quot;all&quot;</span><span class="s3">]</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">check_reduce</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ser</span><span class="s3">: </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">Series</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">: </span><span class="s1">bool</span><span class="s3">):</span>
        <span class="s1">res_op </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">ser</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">)</span>
        <span class="s6"># avoid coercing int -&gt; float. Just cast to the actual numpy type.</span>
        <span class="s6"># error: Item &quot;ExtensionDtype&quot; of &quot;dtype[Any] | ExtensionDtype&quot; has</span>
        <span class="s6"># no attribute &quot;numpy_dtype&quot;</span>
        <span class="s1">cmp_dtype </span><span class="s3">= </span><span class="s1">ser</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">numpy_dtype  </span><span class="s6"># type: ignore[union-attr]</span>
        <span class="s1">alt </span><span class="s3">= </span><span class="s1">ser</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">cmp_dtype</span><span class="s3">)</span>
        <span class="s1">exp_op </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">alt</span><span class="s3">, </span><span class="s1">op_name</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">op_name </span><span class="s3">== </span><span class="s4">&quot;count&quot;</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">res_op</span><span class="s3">()</span>
            <span class="s1">expected </span><span class="s3">= </span><span class="s1">exp_op</span><span class="s3">()</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">res_op</span><span class="s3">(</span><span class="s1">skipna</span><span class="s3">=</span><span class="s1">skipna</span><span class="s3">)</span>
            <span class="s1">expected </span><span class="s3">= </span><span class="s1">exp_op</span><span class="s3">(</span><span class="s1">skipna</span><span class="s3">=</span><span class="s1">skipna</span><span class="s3">)</span>
        <span class="s1">tm</span><span class="s3">.</span><span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">skip</span><span class="s3">(</span><span class="s4">&quot;TODO: tests not written yet&quot;</span><span class="s3">)</span>
    <span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;skipna&quot;</span><span class="s3">, [</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">])</span>
    <span class="s2">def </span><span class="s1">test_reduce_frame</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">all_numeric_reductions</span><span class="s3">, </span><span class="s1">skipna</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s2">def </span><span class="s1">test_fillna_series</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data_missing</span><span class="s3">):</span>
        <span class="s6"># Non-scalar &quot;scalar&quot; values.</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_fillna_series</span><span class="s3">(</span><span class="s1">data_missing</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s2">def </span><span class="s1">test_fillna_frame</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data_missing</span><span class="s3">):</span>
        <span class="s6"># Non-scalar &quot;scalar&quot; values.</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_fillna_frame</span><span class="s3">(</span><span class="s1">data_missing</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s2">def </span><span class="s1">test_setitem_invalid</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">invalid_scalar</span><span class="s3">):</span>
        <span class="s6"># object dtype can hold anything, so doesn't raise</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_setitem_invalid</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">invalid_scalar</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s2">def </span><span class="s1">test_setitem_sequence_broadcasts</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">box_in_series</span><span class="s3">):</span>
        <span class="s6"># ValueError: cannot set using a list-like indexer with a different</span>
        <span class="s6"># length than the value</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_setitem_sequence_broadcasts</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">box_in_series</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;setter&quot;</span><span class="s3">, [</span><span class="s4">&quot;loc&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">])</span>
    <span class="s2">def </span><span class="s1">test_setitem_mask_broadcast</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">setter</span><span class="s3">):</span>
        <span class="s6"># ValueError: cannot set using a list-like indexer with a different</span>
        <span class="s6"># length than the value</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_setitem_mask_broadcast</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">setter</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s2">def </span><span class="s1">test_setitem_scalar_key_sequence_raise</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
        <span class="s6"># Failed: DID NOT RAISE &lt;class 'ValueError'&gt;</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_setitem_scalar_key_sequence_raise</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>

    <span class="s6"># TODO: there is some issue with NumpyExtensionArray, therefore,</span>
    <span class="s6">#   skip the setitem test for now, and fix it later (GH 31446)</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
        <span class="s4">&quot;mask&quot;</span><span class="s3">,</span>
        <span class="s3">[</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s2">True</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">]),</span>
            <span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s2">True</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, </span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, </span><span class="s2">False</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s4">&quot;boolean&quot;</span><span class="s3">),</span>
        <span class="s3">],</span>
        <span class="s1">ids</span><span class="s3">=[</span><span class="s4">&quot;numpy-array&quot;</span><span class="s3">, </span><span class="s4">&quot;boolean-array&quot;</span><span class="s3">],</span>
    <span class="s3">)</span>
    <span class="s2">def </span><span class="s1">test_setitem_mask</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">box_in_series</span><span class="s3">):</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_setitem_mask</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">box_in_series</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
        <span class="s4">&quot;idx&quot;</span><span class="s3">,</span>
        <span class="s3">[[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">], </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s4">&quot;Int64&quot;</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">])],</span>
        <span class="s1">ids</span><span class="s3">=[</span><span class="s4">&quot;list&quot;</span><span class="s3">, </span><span class="s4">&quot;integer-array&quot;</span><span class="s3">, </span><span class="s4">&quot;numpy-array&quot;</span><span class="s3">],</span>
    <span class="s3">)</span>
    <span class="s2">def </span><span class="s1">test_setitem_integer_array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">box_in_series</span><span class="s3">):</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_setitem_integer_array</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">box_in_series</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
        <span class="s4">&quot;idx, box_in_series&quot;</span><span class="s3">,</span>
        <span class="s3">[</span>
            <span class="s3">([</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NA</span><span class="s3">], </span><span class="s2">False</span><span class="s3">),</span>
            <span class="s1">pytest</span><span class="s3">.</span><span class="s1">param</span><span class="s3">([</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NA</span><span class="s3">], </span><span class="s2">True</span><span class="s3">, </span><span class="s1">marks</span><span class="s3">=</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">xfail</span><span class="s3">),</span>
            <span class="s3">(</span><span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NA</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s4">&quot;Int64&quot;</span><span class="s3">), </span><span class="s2">False</span><span class="s3">),</span>
            <span class="s3">(</span><span class="s1">pd</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">NA</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s4">&quot;Int64&quot;</span><span class="s3">), </span><span class="s2">False</span><span class="s3">),</span>
        <span class="s3">],</span>
        <span class="s1">ids</span><span class="s3">=[</span><span class="s4">&quot;list-False&quot;</span><span class="s3">, </span><span class="s4">&quot;list-True&quot;</span><span class="s3">, </span><span class="s4">&quot;integer-array-False&quot;</span><span class="s3">, </span><span class="s4">&quot;integer-array-True&quot;</span><span class="s3">],</span>
    <span class="s3">)</span>
    <span class="s2">def </span><span class="s1">test_setitem_integer_with_missing_raises</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">box_in_series</span><span class="s3">):</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_setitem_integer_with_missing_raises</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">box_in_series</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s2">def </span><span class="s1">test_setitem_slice</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">box_in_series</span><span class="s3">):</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_setitem_slice</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">box_in_series</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s2">def </span><span class="s1">test_setitem_loc_iloc_slice</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_setitem_loc_iloc_slice</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_setitem_with_expansion_dataframe_column</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">full_indexer</span><span class="s3">):</span>
        <span class="s6"># https://github.com/pandas-dev/pandas/issues/32395</span>
        <span class="s1">df </span><span class="s3">= </span><span class="s1">expected </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">DataFrame</span><span class="s3">({</span><span class="s4">&quot;data&quot;</span><span class="s3">: </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">Series</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)})</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">DataFrame</span><span class="s3">(</span><span class="s1">index</span><span class="s3">=</span><span class="s1">df</span><span class="s3">.</span><span class="s1">index</span><span class="s3">)</span>

        <span class="s6"># because result has object dtype, the attempt to do setting inplace</span>
        <span class="s6">#  is successful, and object dtype is retained</span>
        <span class="s1">key </span><span class="s3">= </span><span class="s1">full_indexer</span><span class="s3">(</span><span class="s1">df</span><span class="s3">)</span>
        <span class="s1">result</span><span class="s3">.</span><span class="s1">loc</span><span class="s3">[</span><span class="s1">key</span><span class="s3">, </span><span class="s4">&quot;data&quot;</span><span class="s3">] = </span><span class="s1">df</span><span class="s3">[</span><span class="s4">&quot;data&quot;</span><span class="s3">]</span>

        <span class="s6"># base class method has expected = df; NumpyExtensionArray behaves oddly because</span>
        <span class="s6">#  we patch _typ for these tests.</span>
        <span class="s2">if </span><span class="s1">data</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">numpy_dtype </span><span class="s3">!= </span><span class="s1">object</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">key</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">) </span><span class="s2">or </span><span class="s1">key </span><span class="s3">!= </span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">):</span>
                <span class="s1">expected </span><span class="s3">= </span><span class="s1">pd</span><span class="s3">.</span><span class="s1">DataFrame</span><span class="s3">({</span><span class="s4">&quot;data&quot;</span><span class="s3">: </span><span class="s1">data</span><span class="s3">.</span><span class="s1">to_numpy</span><span class="s3">()})</span>
        <span class="s1">tm</span><span class="s3">.</span><span class="s1">assert_frame_equal</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">, </span><span class="s1">check_column_type</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">xfail</span><span class="s3">(</span><span class="s1">reason</span><span class="s3">=</span><span class="s4">&quot;NumpyEADtype is unpacked&quot;</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">test_index_from_listlike_with_dtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_index_from_listlike_with_dtype</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">skip_nested</span>
    <span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;engine&quot;</span><span class="s3">, [</span><span class="s4">&quot;c&quot;</span><span class="s3">, </span><span class="s4">&quot;python&quot;</span><span class="s3">])</span>
    <span class="s2">def </span><span class="s1">test_EA_types</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">engine</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">request</span><span class="s3">):</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">test_EA_types</span><span class="s3">(</span><span class="s1">engine</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">request</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">Test2DCompat</span><span class="s3">(</span><span class="s1">base</span><span class="s3">.</span><span class="s1">NDArrayBacked2DTests</span><span class="s3">):</span>
    <span class="s2">pass</span>
</pre>
</body>
</html>