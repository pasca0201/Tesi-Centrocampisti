<html>
<head>
<title>fixes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fixes.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Compatibility fixes for older version of python, numpy and scipy 
 
If you add content to this file, please give the version of the package 
at which the fix is no longer needed. 
&quot;&quot;&quot;</span>

<span class="s2"># Authors: Emmanuelle Gouillart &lt;emmanuelle.gouillart@normalesup.org&gt;</span>
<span class="s2">#          Gael Varoquaux &lt;gael.varoquaux@normalesup.org&gt;</span>
<span class="s2">#          Fabian Pedregosa &lt;fpedregosa@acm.org&gt;</span>
<span class="s2">#          Lars Buitinck</span>
<span class="s2">#</span>
<span class="s2"># License: BSD 3 clause</span>

<span class="s3">import </span><span class="s1">platform</span>
<span class="s3">import </span><span class="s1">struct</span>
<span class="s3">import </span><span class="s1">sys</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">scipy</span>
<span class="s3">import </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">linalg</span>
<span class="s3">import </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">stats</span>

<span class="s3">try</span><span class="s4">:</span>
    <span class="s3">import </span><span class="s1">pandas </span><span class="s3">as </span><span class="s1">pd</span>
<span class="s3">except </span><span class="s1">ImportError</span><span class="s4">:</span>
    <span class="s1">pd </span><span class="s4">= </span><span class="s3">None</span>

<span class="s3">from </span><span class="s4">..</span><span class="s1">externals</span><span class="s4">.</span><span class="s1">_packaging</span><span class="s4">.</span><span class="s1">version </span><span class="s3">import </span><span class="s1">parse </span><span class="s3">as </span><span class="s1">parse_version</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">parallel </span><span class="s3">import </span><span class="s1">_get_threadpool_controller</span>

<span class="s1">_IS_PYPY </span><span class="s4">= </span><span class="s1">platform</span><span class="s4">.</span><span class="s1">python_implementation</span><span class="s4">() == </span><span class="s5">&quot;PyPy&quot;</span>
<span class="s1">_IS_32BIT </span><span class="s4">= </span><span class="s6">8 </span><span class="s4">* </span><span class="s1">struct</span><span class="s4">.</span><span class="s1">calcsize</span><span class="s4">(</span><span class="s5">&quot;P&quot;</span><span class="s4">) == </span><span class="s6">32</span>
<span class="s1">_IS_WASM </span><span class="s4">= </span><span class="s1">platform</span><span class="s4">.</span><span class="s1">machine</span><span class="s4">() </span><span class="s3">in </span><span class="s4">[</span><span class="s5">&quot;wasm32&quot;</span><span class="s4">, </span><span class="s5">&quot;wasm64&quot;</span><span class="s4">]</span>

<span class="s1">np_version </span><span class="s4">= </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">__version__</span><span class="s4">)</span>
<span class="s1">np_base_version </span><span class="s4">= </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s1">np_version</span><span class="s4">.</span><span class="s1">base_version</span><span class="s4">)</span>
<span class="s1">sp_version </span><span class="s4">= </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">__version__</span><span class="s4">)</span>
<span class="s1">sp_base_version </span><span class="s4">= </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s1">sp_version</span><span class="s4">.</span><span class="s1">base_version</span><span class="s4">)</span>

<span class="s2"># TODO: We can consider removing the containers and importing</span>
<span class="s2"># directly from SciPy when sparse matrices will be deprecated.</span>
<span class="s1">CSR_CONTAINERS </span><span class="s4">= [</span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">csr_matrix</span><span class="s4">]</span>
<span class="s1">CSC_CONTAINERS </span><span class="s4">= [</span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">csc_matrix</span><span class="s4">]</span>
<span class="s1">COO_CONTAINERS </span><span class="s4">= [</span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">coo_matrix</span><span class="s4">]</span>
<span class="s1">LIL_CONTAINERS </span><span class="s4">= [</span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">lil_matrix</span><span class="s4">]</span>
<span class="s1">DOK_CONTAINERS </span><span class="s4">= [</span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">dok_matrix</span><span class="s4">]</span>
<span class="s1">BSR_CONTAINERS </span><span class="s4">= [</span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">bsr_matrix</span><span class="s4">]</span>
<span class="s1">DIA_CONTAINERS </span><span class="s4">= [</span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">dia_matrix</span><span class="s4">]</span>

<span class="s3">if </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">__version__</span><span class="s4">) &gt;= </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s5">&quot;1.8&quot;</span><span class="s4">):</span>
    <span class="s2"># Sparse Arrays have been added in SciPy 1.8</span>
    <span class="s2"># TODO: When SciPy 1.8 is the minimum supported version,</span>
    <span class="s2"># those list can be created directly without this condition.</span>
    <span class="s2"># See: https://github.com/scikit-learn/scikit-learn/issues/27090</span>
    <span class="s1">CSR_CONTAINERS</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">csr_array</span><span class="s4">)</span>
    <span class="s1">CSC_CONTAINERS</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">csc_array</span><span class="s4">)</span>
    <span class="s1">COO_CONTAINERS</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">coo_array</span><span class="s4">)</span>
    <span class="s1">LIL_CONTAINERS</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">lil_array</span><span class="s4">)</span>
    <span class="s1">DOK_CONTAINERS</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">dok_array</span><span class="s4">)</span>
    <span class="s1">BSR_CONTAINERS</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">bsr_array</span><span class="s4">)</span>
    <span class="s1">DIA_CONTAINERS</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">dia_array</span><span class="s4">)</span>


<span class="s2"># Remove when minimum scipy version is 1.11.0</span>
<span class="s3">try</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse </span><span class="s3">import </span><span class="s1">sparray  </span><span class="s2"># noqa</span>

    <span class="s1">SPARRAY_PRESENT </span><span class="s4">= </span><span class="s3">True</span>
<span class="s3">except </span><span class="s1">ImportError</span><span class="s4">:</span>
    <span class="s1">SPARRAY_PRESENT </span><span class="s4">= </span><span class="s3">False</span>


<span class="s2"># Remove when minimum scipy version is 1.8</span>
<span class="s3">try</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse </span><span class="s3">import </span><span class="s1">csr_array  </span><span class="s2"># noqa</span>

    <span class="s1">SPARSE_ARRAY_PRESENT </span><span class="s4">= </span><span class="s3">True</span>
<span class="s3">except </span><span class="s1">ImportError</span><span class="s4">:</span>
    <span class="s1">SPARSE_ARRAY_PRESENT </span><span class="s4">= </span><span class="s3">False</span>


<span class="s3">try</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">optimize</span><span class="s4">.</span><span class="s1">_linesearch </span><span class="s3">import </span><span class="s1">line_search_wolfe1</span><span class="s4">, </span><span class="s1">line_search_wolfe2</span>
<span class="s3">except </span><span class="s1">ImportError</span><span class="s4">:  </span><span class="s2"># SciPy &lt; 1.8</span>
    <span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">optimize</span><span class="s4">.</span><span class="s1">linesearch </span><span class="s3">import </span><span class="s1">line_search_wolfe2</span><span class="s4">, </span><span class="s1">line_search_wolfe1  </span><span class="s2"># type: ignore  # noqa</span>


<span class="s3">def </span><span class="s1">_object_dtype_isnan</span><span class="s4">(</span><span class="s1">X</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s1">X </span><span class="s4">!= </span><span class="s1">X</span>


<span class="s2"># Rename the `method` kwarg to `interpolation` for NumPy &lt; 1.22, because</span>
<span class="s2"># `interpolation` kwarg was deprecated in favor of `method` in NumPy &gt;= 1.22.</span>
<span class="s3">def </span><span class="s1">_percentile</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">q</span><span class="s4">, *, </span><span class="s1">method</span><span class="s4">=</span><span class="s5">&quot;linear&quot;</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">percentile</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">q</span><span class="s4">, </span><span class="s1">interpolation</span><span class="s4">=</span><span class="s1">method</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>


<span class="s3">if </span><span class="s1">np_version </span><span class="s4">&lt; </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s5">&quot;1.22&quot;</span><span class="s4">):</span>
    <span class="s1">percentile </span><span class="s4">= </span><span class="s1">_percentile</span>
<span class="s3">else</span><span class="s4">:  </span><span class="s2"># &gt;= 1.22</span>
    <span class="s3">from </span><span class="s1">numpy </span><span class="s3">import </span><span class="s1">percentile  </span><span class="s2"># type: ignore  # noqa</span>


<span class="s2"># TODO: Remove when SciPy 1.11 is the minimum supported version</span>
<span class="s3">def </span><span class="s1">_mode</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">0</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">sp_version </span><span class="s4">&gt;= </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s5">&quot;1.9.0&quot;</span><span class="s4">):</span>
        <span class="s1">mode </span><span class="s4">= </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">stats</span><span class="s4">.</span><span class="s1">mode</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s1">axis</span><span class="s4">, </span><span class="s1">keepdims</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">sp_version </span><span class="s4">&gt;= </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s5">&quot;1.10.999&quot;</span><span class="s4">):</span>
            <span class="s2"># scipy.stats.mode has changed returned array shape with axis=None</span>
            <span class="s2"># and keepdims=True, see https://github.com/scipy/scipy/pull/17561</span>
            <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">mode </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">(</span><span class="s1">mode</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">mode</span>
    <span class="s3">return </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">stats</span><span class="s4">.</span><span class="s1">mode</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s1">axis</span><span class="s4">)</span>


<span class="s2"># TODO: Remove when Scipy 1.12 is the minimum supported version</span>
<span class="s3">if </span><span class="s1">sp_base_version </span><span class="s4">&gt;= </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s5">&quot;1.12.0&quot;</span><span class="s4">):</span>
    <span class="s1">_sparse_linalg_cg </span><span class="s4">= </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">cg</span>
<span class="s3">else</span><span class="s4">:</span>

    <span class="s3">def </span><span class="s1">_sparse_linalg_cg</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s5">&quot;rtol&quot; </span><span class="s3">in </span><span class="s1">kwargs</span><span class="s4">:</span>
            <span class="s1">kwargs</span><span class="s4">[</span><span class="s5">&quot;tol&quot;</span><span class="s4">] = </span><span class="s1">kwargs</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;rtol&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s5">&quot;atol&quot; </span><span class="s3">not in </span><span class="s1">kwargs</span><span class="s4">:</span>
            <span class="s1">kwargs</span><span class="s4">[</span><span class="s5">&quot;atol&quot;</span><span class="s4">] = </span><span class="s5">&quot;legacy&quot;</span>
        <span class="s3">return </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">cg</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>


<span class="s2"># TODO: Fuse the modern implementations of _sparse_min_max and _sparse_nan_min_max</span>
<span class="s2"># into the public min_max_axis function when Scipy 1.11 is the minimum supported</span>
<span class="s2"># version and delete the backport in the else branch below.</span>
<span class="s3">if </span><span class="s1">sp_base_version </span><span class="s4">&gt;= </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s5">&quot;1.11.0&quot;</span><span class="s4">):</span>

    <span class="s3">def </span><span class="s1">_sparse_min_max</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">):</span>
        <span class="s1">the_min </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">min</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s1">axis</span><span class="s4">)</span>
        <span class="s1">the_max </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">max</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s1">axis</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">axis </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">the_min </span><span class="s4">= </span><span class="s1">the_min</span><span class="s4">.</span><span class="s1">toarray</span><span class="s4">().</span><span class="s1">ravel</span><span class="s4">()</span>
            <span class="s1">the_max </span><span class="s4">= </span><span class="s1">the_max</span><span class="s4">.</span><span class="s1">toarray</span><span class="s4">().</span><span class="s1">ravel</span><span class="s4">()</span>

        <span class="s3">return </span><span class="s1">the_min</span><span class="s4">, </span><span class="s1">the_max</span>

    <span class="s3">def </span><span class="s1">_sparse_nan_min_max</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">):</span>
        <span class="s1">the_min </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">nanmin</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s1">axis</span><span class="s4">)</span>
        <span class="s1">the_max </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">nanmax</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s1">axis</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">axis </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">the_min </span><span class="s4">= </span><span class="s1">the_min</span><span class="s4">.</span><span class="s1">toarray</span><span class="s4">().</span><span class="s1">ravel</span><span class="s4">()</span>
            <span class="s1">the_max </span><span class="s4">= </span><span class="s1">the_max</span><span class="s4">.</span><span class="s1">toarray</span><span class="s4">().</span><span class="s1">ravel</span><span class="s4">()</span>

        <span class="s3">return </span><span class="s1">the_min</span><span class="s4">, </span><span class="s1">the_max</span>

<span class="s3">else</span><span class="s4">:</span>
    <span class="s2"># This code is mostly taken from scipy 0.14 and extended to handle nans, see</span>
    <span class="s2"># https://github.com/scikit-learn/scikit-learn/pull/11196</span>
    <span class="s3">def </span><span class="s1">_minor_reduce</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">ufunc</span><span class="s4">):</span>
        <span class="s1">major_index </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">flatnonzero</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">diff</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">))</span>

        <span class="s2"># reduceat tries casts X.indptr to intp, which errors</span>
        <span class="s2"># if it is int64 on a 32 bit system.</span>
        <span class="s2"># Reinitializing prevents this where possible, see #13737</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">type</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)((</span><span class="s1">X</span><span class="s4">.</span><span class="s1">data</span><span class="s4">, </span><span class="s1">X</span><span class="s4">.</span><span class="s1">indices</span><span class="s4">, </span><span class="s1">X</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">), </span><span class="s1">shape</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">)</span>
        <span class="s1">value </span><span class="s4">= </span><span class="s1">ufunc</span><span class="s4">.</span><span class="s1">reduceat</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">data</span><span class="s4">, </span><span class="s1">X</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">[</span><span class="s1">major_index</span><span class="s4">])</span>
        <span class="s3">return </span><span class="s1">major_index</span><span class="s4">, </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">_min_or_max_axis</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">, </span><span class="s1">min_or_max</span><span class="s4">):</span>
        <span class="s1">N </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s1">axis</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">N </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;zero-size array to reduction operation&quot;</span><span class="s4">)</span>
        <span class="s1">M </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1 </span><span class="s4">- </span><span class="s1">axis</span><span class="s4">]</span>
        <span class="s1">mat </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">tocsc</span><span class="s4">() </span><span class="s3">if </span><span class="s1">axis </span><span class="s4">== </span><span class="s6">0 </span><span class="s3">else </span><span class="s1">X</span><span class="s4">.</span><span class="s1">tocsr</span><span class="s4">()</span>
        <span class="s1">mat</span><span class="s4">.</span><span class="s1">sum_duplicates</span><span class="s4">()</span>
        <span class="s1">major_index</span><span class="s4">, </span><span class="s1">value </span><span class="s4">= </span><span class="s1">_minor_reduce</span><span class="s4">(</span><span class="s1">mat</span><span class="s4">, </span><span class="s1">min_or_max</span><span class="s4">)</span>
        <span class="s1">not_full </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">diff</span><span class="s4">(</span><span class="s1">mat</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">)[</span><span class="s1">major_index</span><span class="s4">] &lt; </span><span class="s1">N</span>
        <span class="s1">value</span><span class="s4">[</span><span class="s1">not_full</span><span class="s4">] = </span><span class="s1">min_or_max</span><span class="s4">(</span><span class="s1">value</span><span class="s4">[</span><span class="s1">not_full</span><span class="s4">], </span><span class="s6">0</span><span class="s4">)</span>
        <span class="s1">mask </span><span class="s4">= </span><span class="s1">value </span><span class="s4">!= </span><span class="s6">0</span>
        <span class="s1">major_index </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">compress</span><span class="s4">(</span><span class="s1">mask</span><span class="s4">, </span><span class="s1">major_index</span><span class="s4">)</span>
        <span class="s1">value </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">compress</span><span class="s4">(</span><span class="s1">mask</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">axis </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">res </span><span class="s4">= </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">coo_matrix</span><span class="s4">(</span>
                <span class="s4">(</span><span class="s1">value</span><span class="s4">, (</span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)), </span><span class="s1">major_index</span><span class="s4">)),</span>
                <span class="s1">dtype</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">,</span>
                <span class="s1">shape</span><span class="s4">=(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">M</span><span class="s4">),</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">res </span><span class="s4">= </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">coo_matrix</span><span class="s4">(</span>
                <span class="s4">(</span><span class="s1">value</span><span class="s4">, (</span><span class="s1">major_index</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)))),</span>
                <span class="s1">dtype</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">,</span>
                <span class="s1">shape</span><span class="s4">=(</span><span class="s1">M</span><span class="s4">, </span><span class="s6">1</span><span class="s4">),</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">res</span><span class="s4">.</span><span class="s1">A</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_sparse_min_or_max</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">, </span><span class="s1">min_or_max</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s6">0 </span><span class="s3">in </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;zero-size array to reduction operation&quot;</span><span class="s4">)</span>
            <span class="s1">zero </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">.</span><span class="s1">type</span><span class="s4">(</span><span class="s6">0</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">X</span><span class="s4">.</span><span class="s1">nnz </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">zero</span>
            <span class="s1">m </span><span class="s4">= </span><span class="s1">min_or_max</span><span class="s4">.</span><span class="s1">reduce</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">data</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">())</span>
            <span class="s3">if </span><span class="s1">X</span><span class="s4">.</span><span class="s1">nnz </span><span class="s4">!= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">prod</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">):</span>
                <span class="s1">m </span><span class="s4">= </span><span class="s1">min_or_max</span><span class="s4">(</span><span class="s1">zero</span><span class="s4">, </span><span class="s1">m</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">m</span>
        <span class="s3">if </span><span class="s1">axis </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">axis </span><span class="s4">+= </span><span class="s6">2</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s1">axis </span><span class="s4">== </span><span class="s6">0</span><span class="s4">) </span><span class="s3">or </span><span class="s4">(</span><span class="s1">axis </span><span class="s4">== </span><span class="s6">1</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">_min_or_max_axis</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">, </span><span class="s1">min_or_max</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;invalid axis, use 0 for rows, or 1 for columns&quot;</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_sparse_min_max</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">_sparse_min_or_max</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">minimum</span><span class="s4">),</span>
            <span class="s1">_sparse_min_or_max</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">maximum</span><span class="s4">),</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_sparse_nan_min_max</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">_sparse_min_or_max</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">fmin</span><span class="s4">),</span>
            <span class="s1">_sparse_min_or_max</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">fmax</span><span class="s4">),</span>
        <span class="s4">)</span>


<span class="s2"># For +1.25 NumPy versions exceptions and warnings are being moved</span>
<span class="s2"># to a dedicated submodule.</span>
<span class="s3">if </span><span class="s1">np_version </span><span class="s4">&gt;= </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s5">&quot;1.25.0&quot;</span><span class="s4">):</span>
    <span class="s3">from </span><span class="s1">numpy</span><span class="s4">.</span><span class="s1">exceptions </span><span class="s3">import </span><span class="s1">ComplexWarning</span><span class="s4">, </span><span class="s1">VisibleDeprecationWarning</span>
<span class="s3">else</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s1">numpy </span><span class="s3">import </span><span class="s1">ComplexWarning</span><span class="s4">, </span><span class="s1">VisibleDeprecationWarning  </span><span class="s2"># type: ignore  # noqa</span>


<span class="s2"># TODO: Remove when Scipy 1.6 is the minimum supported version</span>
<span class="s3">try</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">integrate </span><span class="s3">import </span><span class="s1">trapezoid  </span><span class="s2"># type: ignore  # noqa</span>
<span class="s3">except </span><span class="s1">ImportError</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">integrate </span><span class="s3">import </span><span class="s1">trapz </span><span class="s3">as </span><span class="s1">trapezoid  </span><span class="s2"># type: ignore  # noqa</span>


<span class="s2"># TODO: Adapt when Pandas &gt; 2.2 is the minimum supported version</span>
<span class="s3">def </span><span class="s1">pd_fillna</span><span class="s4">(</span><span class="s1">pd</span><span class="s4">, </span><span class="s1">frame</span><span class="s4">):</span>
    <span class="s1">pd_version </span><span class="s4">= </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s1">pd</span><span class="s4">.</span><span class="s1">__version__</span><span class="s4">).</span><span class="s1">base_version</span>
    <span class="s3">if </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s1">pd_version</span><span class="s4">) &lt; </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s5">&quot;2.2&quot;</span><span class="s4">):</span>
        <span class="s1">frame </span><span class="s4">= </span><span class="s1">frame</span><span class="s4">.</span><span class="s1">fillna</span><span class="s4">(</span><span class="s1">value</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">nan</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">infer_objects_kwargs </span><span class="s4">= (</span>
            <span class="s4">{} </span><span class="s3">if </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s1">pd_version</span><span class="s4">) &gt;= </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s5">&quot;3&quot;</span><span class="s4">) </span><span class="s3">else </span><span class="s4">{</span><span class="s5">&quot;copy&quot;</span><span class="s4">: </span><span class="s3">False</span><span class="s4">}</span>
        <span class="s4">)</span>
        <span class="s3">with </span><span class="s1">pd</span><span class="s4">.</span><span class="s1">option_context</span><span class="s4">(</span><span class="s5">&quot;future.no_silent_downcasting&quot;</span><span class="s4">, </span><span class="s3">True</span><span class="s4">):</span>
            <span class="s1">frame </span><span class="s4">= </span><span class="s1">frame</span><span class="s4">.</span><span class="s1">fillna</span><span class="s4">(</span><span class="s1">value</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">nan</span><span class="s4">).</span><span class="s1">infer_objects</span><span class="s4">(**</span><span class="s1">infer_objects_kwargs</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">frame</span>


<span class="s2"># TODO: remove when SciPy 1.12 is the minimum supported version</span>
<span class="s3">def </span><span class="s1">_preserve_dia_indices_dtype</span><span class="s4">(</span>
    <span class="s1">sparse_container</span><span class="s4">, </span><span class="s1">original_container_format</span><span class="s4">, </span><span class="s1">requested_sparse_format</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Preserve indices dtype for SciPy &lt; 1.12 when converting from DIA to CSR/CSC. 
 
    For SciPy &lt; 1.12, DIA arrays indices are upcasted to `np.int64` that is 
    inconsistent with DIA matrices. We downcast the indices dtype to `np.int32` to 
    be consistent with DIA matrices. 
 
    The converted indices arrays are affected back inplace to the sparse container. 
 
    Parameters 
    ---------- 
    sparse_container : sparse container 
        Sparse container to be checked. 
    requested_sparse_format : str or bool 
        The type of format of `sparse_container`. 
 
    Notes 
    ----- 
    See https://github.com/scipy/scipy/issues/19245 for more details. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">original_container_format </span><span class="s4">== </span><span class="s5">&quot;dia_array&quot; </span><span class="s3">and </span><span class="s1">requested_sparse_format </span><span class="s3">in </span><span class="s4">(</span>
        <span class="s5">&quot;csr&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;coo&quot;</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s3">if </span><span class="s1">requested_sparse_format </span><span class="s4">== </span><span class="s5">&quot;csr&quot;</span><span class="s4">:</span>
            <span class="s1">index_dtype </span><span class="s4">= </span><span class="s1">_smallest_admissible_index_dtype</span><span class="s4">(</span>
                <span class="s1">arrays</span><span class="s4">=(</span><span class="s1">sparse_container</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">, </span><span class="s1">sparse_container</span><span class="s4">.</span><span class="s1">indices</span><span class="s4">),</span>
                <span class="s1">maxval</span><span class="s4">=</span><span class="s1">max</span><span class="s4">(</span><span class="s1">sparse_container</span><span class="s4">.</span><span class="s1">nnz</span><span class="s4">, </span><span class="s1">sparse_container</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]),</span>
                <span class="s1">check_contents</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s1">sparse_container</span><span class="s4">.</span><span class="s1">indices </span><span class="s4">= </span><span class="s1">sparse_container</span><span class="s4">.</span><span class="s1">indices</span><span class="s4">.</span><span class="s1">astype</span><span class="s4">(</span>
                <span class="s1">index_dtype</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s3">False</span>
            <span class="s4">)</span>
            <span class="s1">sparse_container</span><span class="s4">.</span><span class="s1">indptr </span><span class="s4">= </span><span class="s1">sparse_container</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">.</span><span class="s1">astype</span><span class="s4">(</span>
                <span class="s1">index_dtype</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s3">False</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:  </span><span class="s2"># requested_sparse_format == &quot;coo&quot;</span>
            <span class="s1">index_dtype </span><span class="s4">= </span><span class="s1">_smallest_admissible_index_dtype</span><span class="s4">(</span>
                <span class="s1">maxval</span><span class="s4">=</span><span class="s1">max</span><span class="s4">(</span><span class="s1">sparse_container</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s1">sparse_container</span><span class="s4">.</span><span class="s1">row </span><span class="s4">= </span><span class="s1">sparse_container</span><span class="s4">.</span><span class="s1">row</span><span class="s4">.</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">index_dtype</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
            <span class="s1">sparse_container</span><span class="s4">.</span><span class="s1">col </span><span class="s4">= </span><span class="s1">sparse_container</span><span class="s4">.</span><span class="s1">col</span><span class="s4">.</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">index_dtype</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>


<span class="s2"># TODO: remove when SciPy 1.12 is the minimum supported version</span>
<span class="s3">def </span><span class="s1">_smallest_admissible_index_dtype</span><span class="s4">(</span><span class="s1">arrays</span><span class="s4">=(), </span><span class="s1">maxval</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">check_contents</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Based on input (integer) arrays `a`, determine a suitable index data 
    type that can hold the data in the arrays. 
 
    This function returns `np.int64` if it either required by `maxval` or based on the 
    largest precision of the dtype of the arrays passed as argument, or by the their 
    contents (when `check_contents is True`). If none of the condition requires 
    `np.int64` then this function returns `np.int32`. 
 
    Parameters 
    ---------- 
    arrays : ndarray or tuple of ndarrays, default=() 
        Input arrays whose types/contents to check. 
 
    maxval : float, default=None 
        Maximum value needed. 
 
    check_contents : bool, default=False 
        Whether to check the values in the arrays and not just their types. 
        By default, check only the types. 
 
    Returns 
    ------- 
    dtype : {np.int32, np.int64} 
        Suitable index data type (int32 or int64). 
    &quot;&quot;&quot;</span>

    <span class="s1">int32min </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">int32</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">iinfo</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">int32</span><span class="s4">).</span><span class="s1">min</span><span class="s4">)</span>
    <span class="s1">int32max </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">int32</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">iinfo</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">int32</span><span class="s4">).</span><span class="s1">max</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">maxval </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">maxval </span><span class="s4">&gt; </span><span class="s1">np</span><span class="s4">.</span><span class="s1">iinfo</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">int64</span><span class="s4">).</span><span class="s1">max</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">f&quot;maxval=</span><span class="s3">{</span><span class="s1">maxval</span><span class="s3">} </span><span class="s5">is to large to be represented as np.int64.&quot;</span>
            <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">maxval </span><span class="s4">&gt; </span><span class="s1">int32max</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">int64</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">arrays</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">):</span>
        <span class="s1">arrays </span><span class="s4">= (</span><span class="s1">arrays</span><span class="s4">,)</span>

    <span class="s3">for </span><span class="s1">arr </span><span class="s3">in </span><span class="s1">arrays</span><span class="s4">:</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">arr</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span>
                <span class="s5">f&quot;Arrays should be of type np.ndarray, got </span><span class="s3">{</span><span class="s1">type</span><span class="s4">(</span><span class="s1">arr</span><span class="s4">)</span><span class="s3">} </span><span class="s5">instead.&quot;</span>
            <span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">issubdtype</span><span class="s4">(</span><span class="s1">arr</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">integer</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">f&quot;Array dtype </span><span class="s3">{</span><span class="s1">arr</span><span class="s4">.</span><span class="s1">dtype</span><span class="s3">} </span><span class="s5">is not supported for index dtype. We expect &quot;</span>
                <span class="s5">&quot;integral values.&quot;</span>
            <span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">can_cast</span><span class="s4">(</span><span class="s1">arr</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">int32</span><span class="s4">):</span>
            <span class="s3">if not </span><span class="s1">check_contents</span><span class="s4">:</span>
                <span class="s2"># when `check_contents` is False, we stay on the safe side and return</span>
                <span class="s2"># np.int64.</span>
                <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">int64</span>
            <span class="s3">if </span><span class="s1">arr</span><span class="s4">.</span><span class="s1">size </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
                <span class="s2"># a bigger type not needed yet, let's look at the next array</span>
                <span class="s3">continue</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">maxval </span><span class="s4">= </span><span class="s1">arr</span><span class="s4">.</span><span class="s1">max</span><span class="s4">()</span>
                <span class="s1">minval </span><span class="s4">= </span><span class="s1">arr</span><span class="s4">.</span><span class="s1">min</span><span class="s4">()</span>
                <span class="s3">if </span><span class="s1">minval </span><span class="s4">&lt; </span><span class="s1">int32min </span><span class="s3">or </span><span class="s1">maxval </span><span class="s4">&gt; </span><span class="s1">int32max</span><span class="s4">:</span>
                    <span class="s2"># a big index type is actually needed</span>
                    <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">int64</span>

    <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">int32</span>


<span class="s2"># TODO: Remove when Scipy 1.12 is the minimum supported version</span>
<span class="s3">if </span><span class="s1">sp_version </span><span class="s4">&lt; </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s5">&quot;1.12&quot;</span><span class="s4">):</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">externals</span><span class="s4">.</span><span class="s1">_scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">csgraph </span><span class="s3">import </span><span class="s1">laplacian  </span><span class="s2"># type: ignore  # noqa</span>
<span class="s3">else</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">csgraph </span><span class="s3">import </span><span class="s1">laplacian  </span><span class="s2"># type: ignore  # noqa  # pragma: no cover</span>


<span class="s2"># TODO: Remove when we drop support for Python 3.9. Note the filter argument has</span>
<span class="s2"># been back-ported in 3.9.17 but we can not assume anything about the micro</span>
<span class="s2"># version, see</span>
<span class="s2"># https://docs.python.org/3.9/library/tarfile.html#tarfile.TarFile.extractall</span>
<span class="s2"># for more details</span>
<span class="s3">def </span><span class="s1">tarfile_extractall</span><span class="s4">(</span><span class="s1">tarfile</span><span class="s4">, </span><span class="s1">path</span><span class="s4">):</span>
    <span class="s3">try</span><span class="s4">:</span>
        <span class="s1">tarfile</span><span class="s4">.</span><span class="s1">extractall</span><span class="s4">(</span><span class="s1">path</span><span class="s4">, </span><span class="s1">filter</span><span class="s4">=</span><span class="s5">&quot;data&quot;</span><span class="s4">)</span>
    <span class="s3">except </span><span class="s1">TypeError</span><span class="s4">:</span>
        <span class="s1">tarfile</span><span class="s4">.</span><span class="s1">extractall</span><span class="s4">(</span><span class="s1">path</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_in_unstable_openblas_configuration</span><span class="s4">():</span>
    <span class="s0">&quot;&quot;&quot;Return True if in an unstable configuration for OpenBLAS&quot;&quot;&quot;</span>

    <span class="s2"># Import libraries which might load OpenBLAS.</span>
    <span class="s3">import </span><span class="s1">numpy  </span><span class="s2"># noqa</span>
    <span class="s3">import </span><span class="s1">scipy  </span><span class="s2"># noqa</span>

    <span class="s1">modules_info </span><span class="s4">= </span><span class="s1">_get_threadpool_controller</span><span class="s4">().</span><span class="s1">info</span><span class="s4">()</span>

    <span class="s1">open_blas_used </span><span class="s4">= </span><span class="s1">any</span><span class="s4">(</span><span class="s1">info</span><span class="s4">[</span><span class="s5">&quot;internal_api&quot;</span><span class="s4">] == </span><span class="s5">&quot;openblas&quot; </span><span class="s3">for </span><span class="s1">info </span><span class="s3">in </span><span class="s1">modules_info</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">open_blas_used</span><span class="s4">:</span>
        <span class="s3">return False</span>

    <span class="s2"># OpenBLAS 0.3.16 fixed instability for arm64, see:</span>
    <span class="s2"># https://github.com/xianyi/OpenBLAS/blob/1b6db3dbba672b4f8af935bd43a1ff6cff4d20b7/Changelog.txt#L56-L58 # noqa</span>
    <span class="s1">openblas_arm64_stable_version </span><span class="s4">= </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s5">&quot;0.3.16&quot;</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">info </span><span class="s3">in </span><span class="s1">modules_info</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">info</span><span class="s4">[</span><span class="s5">&quot;internal_api&quot;</span><span class="s4">] != </span><span class="s5">&quot;openblas&quot;</span><span class="s4">:</span>
            <span class="s3">continue</span>
        <span class="s1">openblas_version </span><span class="s4">= </span><span class="s1">info</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;version&quot;</span><span class="s4">)</span>
        <span class="s1">openblas_architecture </span><span class="s4">= </span><span class="s1">info</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;architecture&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">openblas_version </span><span class="s3">is None or </span><span class="s1">openblas_architecture </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s2"># Cannot be sure that OpenBLAS is good enough. Assume unstable:</span>
            <span class="s3">return True  </span><span class="s2"># pragma: no cover</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">openblas_architecture </span><span class="s4">== </span><span class="s5">&quot;neoversen1&quot;</span>
            <span class="s3">and </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s1">openblas_version</span><span class="s4">) &lt; </span><span class="s1">openblas_arm64_stable_version</span>
        <span class="s4">):</span>
            <span class="s2"># See discussions in https://github.com/numpy/numpy/issues/19411</span>
            <span class="s3">return True  </span><span class="s2"># pragma: no cover</span>
    <span class="s3">return False</span>


<span class="s2"># TODO: remove when pandas &gt;= 1.4 is the minimum supported version</span>
<span class="s3">if </span><span class="s1">pd </span><span class="s3">is not None and </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s1">pd</span><span class="s4">.</span><span class="s1">__version__</span><span class="s4">) &lt; </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s5">&quot;1.4&quot;</span><span class="s4">):</span>

    <span class="s3">def </span><span class="s1">_create_pandas_dataframe_from_non_pandas_container</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, *, </span><span class="s1">index</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">):</span>
        <span class="s1">pl </span><span class="s4">= </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">modules</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;polars&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">pl </span><span class="s3">is None or not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">pl</span><span class="s4">.</span><span class="s1">DataFrame</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">pd</span><span class="s4">.</span><span class="s1">DataFrame</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">index</span><span class="s4">=</span><span class="s1">index</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s1">copy</span><span class="s4">)</span>

        <span class="s2"># Bug in pandas&lt;1.4: when constructing a pandas DataFrame from a polars</span>
        <span class="s2"># DataFrame, the data is transposed ...</span>
        <span class="s3">return </span><span class="s1">pd</span><span class="s4">.</span><span class="s1">DataFrame</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">to_numpy</span><span class="s4">(), </span><span class="s1">index</span><span class="s4">=</span><span class="s1">index</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s1">copy</span><span class="s4">)</span>

<span class="s3">else</span><span class="s4">:</span>

    <span class="s3">def </span><span class="s1">_create_pandas_dataframe_from_non_pandas_container</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, *, </span><span class="s1">index</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">pd</span><span class="s4">.</span><span class="s1">DataFrame</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">index</span><span class="s4">=</span><span class="s1">index</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s1">copy</span><span class="s4">)</span>
</pre>
</body>
</html>