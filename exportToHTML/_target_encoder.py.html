<html>
<head>
<title>_target_encoder.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_target_encoder.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">numbers </span><span class="s0">import </span><span class="s1">Integral</span><span class="s2">, </span><span class="s1">Real</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s2">..</span><span class="s1">base </span><span class="s0">import </span><span class="s1">OneToOneFeatureMixin</span><span class="s2">, </span><span class="s1">_fit_context</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">utils</span><span class="s2">.</span><span class="s1">_param_validation </span><span class="s0">import </span><span class="s1">Interval</span><span class="s2">, </span><span class="s1">StrOptions</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">utils</span><span class="s2">.</span><span class="s1">multiclass </span><span class="s0">import </span><span class="s1">type_of_target</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">utils</span><span class="s2">.</span><span class="s1">validation </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">_check_feature_names_in</span><span class="s2">,</span>
    <span class="s1">_check_y</span><span class="s2">,</span>
    <span class="s1">check_consistent_length</span><span class="s2">,</span>
    <span class="s1">check_is_fitted</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_encoders </span><span class="s0">import </span><span class="s1">_BaseEncoder</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_target_encoder_fast </span><span class="s0">import </span><span class="s1">_fit_encoding_fast</span><span class="s2">, </span><span class="s1">_fit_encoding_fast_auto_smooth</span>


<span class="s0">class </span><span class="s1">TargetEncoder</span><span class="s2">(</span><span class="s1">OneToOneFeatureMixin</span><span class="s2">, </span><span class="s1">_BaseEncoder</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Target Encoder for regression and classification targets. 
 
    Each category is encoded based on a shrunk estimate of the average target 
    values for observations belonging to the category. The encoding scheme mixes 
    the global target mean with the target mean conditioned on the value of the 
    category (see [MIC]_). 
 
    When the target type is &quot;multiclass&quot;, encodings are based 
    on the conditional probability estimate for each class. The target is first 
    binarized using the &quot;one-vs-all&quot; scheme via 
    :class:`~sklearn.preprocessing.LabelBinarizer`, then the average target 
    value for each class and each category is used for encoding, resulting in 
    `n_features` * `n_classes` encoded output features. 
 
    :class:`TargetEncoder` considers missing values, such as `np.nan` or `None`, 
    as another category and encodes them like any other category. Categories 
    that are not seen during :meth:`fit` are encoded with the target mean, i.e. 
    `target_mean_`. 
 
    For a demo on the importance of the `TargetEncoder` internal cross-fitting, 
    see 
    :ref:`sphx_glr_auto_examples_preprocessing_plot_target_encoder_cross_val.py`. 
    For a comparison of different encoders, refer to 
    :ref:`sphx_glr_auto_examples_preprocessing_plot_target_encoder.py`. Read 
    more in the :ref:`User Guide &lt;target_encoder&gt;`. 
 
    .. note:: 
        `fit(X, y).transform(X)` does not equal `fit_transform(X, y)` because a 
        :term:`cross fitting` scheme is used in `fit_transform` for encoding. 
        See the :ref:`User Guide &lt;target_encoder&gt;` for details. 
 
    .. versionadded:: 1.3 
 
    Parameters 
    ---------- 
    categories : &quot;auto&quot; or list of shape (n_features,) of array-like, default=&quot;auto&quot; 
        Categories (unique values) per feature: 
 
        - `&quot;auto&quot;` : Determine categories automatically from the training data. 
        - list : `categories[i]` holds the categories expected in the i-th column. The 
          passed categories should not mix strings and numeric values within a single 
          feature, and should be sorted in case of numeric values. 
 
        The used categories are stored in the `categories_` fitted attribute. 
 
    target_type : {&quot;auto&quot;, &quot;continuous&quot;, &quot;binary&quot;, &quot;multiclass&quot;}, default=&quot;auto&quot; 
        Type of target. 
 
        - `&quot;auto&quot;` : Type of target is inferred with 
          :func:`~sklearn.utils.multiclass.type_of_target`. 
        - `&quot;continuous&quot;` : Continuous target 
        - `&quot;binary&quot;` : Binary target 
        - `&quot;multiclass&quot;` : Multiclass target 
 
        .. note:: 
            The type of target inferred with `&quot;auto&quot;` may not be the desired target 
            type used for modeling. For example, if the target consisted of integers 
            between 0 and 100, then :func:`~sklearn.utils.multiclass.type_of_target` 
            will infer the target as `&quot;multiclass&quot;`. In this case, setting 
            `target_type=&quot;continuous&quot;` will specify the target as a regression 
            problem. The `target_type_` attribute gives the target type used by the 
            encoder. 
 
        .. versionchanged:: 1.4 
           Added the option 'multiclass'. 
 
    smooth : &quot;auto&quot; or float, default=&quot;auto&quot; 
        The amount of mixing of the target mean conditioned on the value of the 
        category with the global target mean. A larger `smooth` value will put 
        more weight on the global target mean. 
        If `&quot;auto&quot;`, then `smooth` is set to an empirical Bayes estimate. 
 
    cv : int, default=5 
        Determines the number of folds in the :term:`cross fitting` strategy used in 
        :meth:`fit_transform`. For classification targets, `StratifiedKFold` is used 
        and for continuous targets, `KFold` is used. 
 
    shuffle : bool, default=True 
        Whether to shuffle the data in :meth:`fit_transform` before splitting into 
        folds. Note that the samples within each split will not be shuffled. 
 
    random_state : int, RandomState instance or None, default=None 
        When `shuffle` is True, `random_state` affects the ordering of the 
        indices, which controls the randomness of each fold. Otherwise, this 
        parameter has no effect. 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    Attributes 
    ---------- 
    encodings_ : list of shape (n_features,) or (n_features * n_classes) of \ 
                    ndarray 
        Encodings learnt on all of `X`. 
        For feature `i`, `encodings_[i]` are the encodings matching the 
        categories listed in `categories_[i]`. When `target_type_` is 
        &quot;multiclass&quot;, the encoding for feature `i` and class `j` is stored in 
        `encodings_[j + (i * len(classes_))]`. E.g., for 2 features (f) and 
        3 classes (c), encodings are ordered: 
        f0_c0, f0_c1, f0_c2, f1_c0, f1_c1, f1_c2, 
 
    categories_ : list of shape (n_features,) of ndarray 
        The categories of each input feature determined during fitting or 
        specified in `categories` 
        (in order of the features in `X` and corresponding with the output 
        of :meth:`transform`). 
 
    target_type_ : str 
        Type of target. 
 
    target_mean_ : float 
        The overall mean of the target. This value is only used in :meth:`transform` 
        to encode categories. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
    classes_ : ndarray or None 
        If `target_type_` is 'binary' or 'multiclass', holds the label for each class, 
        otherwise `None`. 
 
    See Also 
    -------- 
    OrdinalEncoder : Performs an ordinal (integer) encoding of the categorical features. 
        Contrary to TargetEncoder, this encoding is not supervised. Treating the 
        resulting encoding as a numerical features therefore lead arbitrarily 
        ordered values and therefore typically lead to lower predictive performance 
        when used as preprocessing for a classifier or regressor. 
    OneHotEncoder : Performs a one-hot encoding of categorical features. This 
        unsupervised encoding is better suited for low cardinality categorical 
        variables as it generate one new feature per unique category. 
 
    References 
    ---------- 
    .. [MIC] :doi:`Micci-Barreca, Daniele. &quot;A preprocessing scheme for high-cardinality 
       categorical attributes in classification and prediction problems&quot; 
       SIGKDD Explor. Newsl. 3, 1 (July 2001), 27â€“32. &lt;10.1145/507533.507538&gt;` 
 
    Examples 
    -------- 
    With `smooth=&quot;auto&quot;`, the smoothing parameter is set to an empirical Bayes estimate: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.preprocessing import TargetEncoder 
    &gt;&gt;&gt; X = np.array([[&quot;dog&quot;] * 20 + [&quot;cat&quot;] * 30 + [&quot;snake&quot;] * 38], dtype=object).T 
    &gt;&gt;&gt; y = [90.3] * 5 + [80.1] * 15 + [20.4] * 5 + [20.1] * 25 + [21.2] * 8 + [49] * 30 
    &gt;&gt;&gt; enc_auto = TargetEncoder(smooth=&quot;auto&quot;) 
    &gt;&gt;&gt; X_trans = enc_auto.fit_transform(X, y) 
 
    &gt;&gt;&gt; # A high `smooth` parameter puts more weight on global mean on the categorical 
    &gt;&gt;&gt; # encodings: 
    &gt;&gt;&gt; enc_high_smooth = TargetEncoder(smooth=5000.0).fit(X, y) 
    &gt;&gt;&gt; enc_high_smooth.target_mean_ 
    np.float64(44...) 
    &gt;&gt;&gt; enc_high_smooth.encodings_ 
    [array([44..., 44..., 44...])] 
 
    &gt;&gt;&gt; # On the other hand, a low `smooth` parameter puts more weight on target 
    &gt;&gt;&gt; # conditioned on the value of the categorical: 
    &gt;&gt;&gt; enc_low_smooth = TargetEncoder(smooth=1.0).fit(X, y) 
    &gt;&gt;&gt; enc_low_smooth.encodings_ 
    [array([20..., 80..., 43...])] 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s2">: </span><span class="s1">dict </span><span class="s2">= {</span>
        <span class="s4">&quot;categories&quot;</span><span class="s2">: [</span><span class="s1">StrOptions</span><span class="s2">({</span><span class="s4">&quot;auto&quot;</span><span class="s2">}), </span><span class="s1">list</span><span class="s2">],</span>
        <span class="s4">&quot;target_type&quot;</span><span class="s2">: [</span><span class="s1">StrOptions</span><span class="s2">({</span><span class="s4">&quot;auto&quot;</span><span class="s2">, </span><span class="s4">&quot;continuous&quot;</span><span class="s2">, </span><span class="s4">&quot;binary&quot;</span><span class="s2">, </span><span class="s4">&quot;multiclass&quot;</span><span class="s2">})],</span>
        <span class="s4">&quot;smooth&quot;</span><span class="s2">: [</span><span class="s1">StrOptions</span><span class="s2">({</span><span class="s4">&quot;auto&quot;</span><span class="s2">}), </span><span class="s1">Interval</span><span class="s2">(</span><span class="s1">Real</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s1">closed</span><span class="s2">=</span><span class="s4">&quot;left&quot;</span><span class="s2">)],</span>
        <span class="s4">&quot;cv&quot;</span><span class="s2">: [</span><span class="s1">Interval</span><span class="s2">(</span><span class="s1">Integral</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s1">closed</span><span class="s2">=</span><span class="s4">&quot;left&quot;</span><span class="s2">)],</span>
        <span class="s4">&quot;shuffle&quot;</span><span class="s2">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s2">],</span>
        <span class="s4">&quot;random_state&quot;</span><span class="s2">: [</span><span class="s4">&quot;random_state&quot;</span><span class="s2">],</span>
    <span class="s2">}</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">categories</span><span class="s2">=</span><span class="s4">&quot;auto&quot;</span><span class="s2">,</span>
        <span class="s1">target_type</span><span class="s2">=</span><span class="s4">&quot;auto&quot;</span><span class="s2">,</span>
        <span class="s1">smooth</span><span class="s2">=</span><span class="s4">&quot;auto&quot;</span><span class="s2">,</span>
        <span class="s1">cv</span><span class="s2">=</span><span class="s5">5</span><span class="s2">,</span>
        <span class="s1">shuffle</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">random_state</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">categories </span><span class="s2">= </span><span class="s1">categories</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">smooth </span><span class="s2">= </span><span class="s1">smooth</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">target_type </span><span class="s2">= </span><span class="s1">target_type</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">cv </span><span class="s2">= </span><span class="s1">cv</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">shuffle </span><span class="s2">= </span><span class="s1">shuffle</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">random_state </span><span class="s2">= </span><span class="s1">random_state</span>

    <span class="s2">@</span><span class="s1">_fit_context</span><span class="s2">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">fit</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Fit the :class:`TargetEncoder` to X and y. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            The data to determine the categories of each feature. 
 
        y : array-like of shape (n_samples,) 
            The target data used to encode the categories. 
 
        Returns 
        ------- 
        self : object 
            Fitted encoder. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_fit_encodings_all</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s2">@</span><span class="s1">_fit_context</span><span class="s2">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">fit_transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Fit :class:`TargetEncoder` and transform X with the target encoding. 
 
        .. note:: 
            `fit(X, y).transform(X)` does not equal `fit_transform(X, y)` because a 
            :term:`cross fitting` scheme is used in `fit_transform` for encoding. 
            See the :ref:`User Guide &lt;target_encoder&gt;`. for details. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            The data to determine the categories of each feature. 
 
        y : array-like of shape (n_samples,) 
            The target data used to encode the categories. 
 
        Returns 
        ------- 
        X_trans : ndarray of shape (n_samples, n_features) or \ 
                    (n_samples, (n_features * n_classes)) 
            Transformed input. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s2">..</span><span class="s1">model_selection </span><span class="s0">import </span><span class="s1">KFold</span><span class="s2">, </span><span class="s1">StratifiedKFold  </span><span class="s6"># avoid circular import</span>

        <span class="s1">X_ordinal</span><span class="s2">, </span><span class="s1">X_known_mask</span><span class="s2">, </span><span class="s1">y_encoded</span><span class="s2">, </span><span class="s1">n_categories </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_fit_encodings_all</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>

        <span class="s6"># The cv splitter is voluntarily restricted to *KFold to enforce non</span>
        <span class="s6"># overlapping validation folds, otherwise the fit_transform output will</span>
        <span class="s6"># not be well-specified.</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_type_ </span><span class="s2">== </span><span class="s4">&quot;continuous&quot;</span><span class="s2">:</span>
            <span class="s1">cv </span><span class="s2">= </span><span class="s1">KFold</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cv</span><span class="s2">, </span><span class="s1">shuffle</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shuffle</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">random_state</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">cv </span><span class="s2">= </span><span class="s1">StratifiedKFold</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">cv</span><span class="s2">, </span><span class="s1">shuffle</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shuffle</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">random_state</span>
            <span class="s2">)</span>

        <span class="s6"># If 'multiclass' multiply axis=1 by num classes else keep shape the same</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_type_ </span><span class="s2">== </span><span class="s4">&quot;multiclass&quot;</span><span class="s2">:</span>
            <span class="s1">X_out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span>
                <span class="s2">(</span><span class="s1">X_ordinal</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">X_ordinal</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] * </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">classes_</span><span class="s2">)),</span>
                <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">X_out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">X_ordinal</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">train_idx</span><span class="s2">, </span><span class="s1">test_idx </span><span class="s0">in </span><span class="s1">cv</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
            <span class="s1">X_train</span><span class="s2">, </span><span class="s1">y_train </span><span class="s2">= </span><span class="s1">X_ordinal</span><span class="s2">[</span><span class="s1">train_idx</span><span class="s2">, :], </span><span class="s1">y_encoded</span><span class="s2">[</span><span class="s1">train_idx</span><span class="s2">]</span>
            <span class="s1">y_train_mean </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">y_train</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_type_ </span><span class="s2">== </span><span class="s4">&quot;multiclass&quot;</span><span class="s2">:</span>
                <span class="s1">encodings </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_fit_encoding_multiclass</span><span class="s2">(</span>
                    <span class="s1">X_train</span><span class="s2">,</span>
                    <span class="s1">y_train</span><span class="s2">,</span>
                    <span class="s1">n_categories</span><span class="s2">,</span>
                    <span class="s1">y_train_mean</span><span class="s2">,</span>
                <span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">encodings </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_fit_encoding_binary_or_continuous</span><span class="s2">(</span>
                    <span class="s1">X_train</span><span class="s2">,</span>
                    <span class="s1">y_train</span><span class="s2">,</span>
                    <span class="s1">n_categories</span><span class="s2">,</span>
                    <span class="s1">y_train_mean</span><span class="s2">,</span>
                <span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_transform_X_ordinal</span><span class="s2">(</span>
                <span class="s1">X_out</span><span class="s2">,</span>
                <span class="s1">X_ordinal</span><span class="s2">,</span>
                <span class="s2">~</span><span class="s1">X_known_mask</span><span class="s2">,</span>
                <span class="s1">test_idx</span><span class="s2">,</span>
                <span class="s1">encodings</span><span class="s2">,</span>
                <span class="s1">y_train_mean</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">X_out</span>

    <span class="s0">def </span><span class="s1">transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Transform X with the target encoding. 
 
        .. note:: 
            `fit(X, y).transform(X)` does not equal `fit_transform(X, y)` because a 
            :term:`cross fitting` scheme is used in `fit_transform` for encoding. 
            See the :ref:`User Guide &lt;target_encoder&gt;`. for details. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            The data to determine the categories of each feature. 
 
        Returns 
        ------- 
        X_trans : ndarray of shape (n_samples, n_features) or \ 
                    (n_samples, (n_features * n_classes)) 
            Transformed input. 
        &quot;&quot;&quot;</span>
        <span class="s1">X_ordinal</span><span class="s2">, </span><span class="s1">X_known_mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_transform</span><span class="s2">(</span>
            <span class="s1">X</span><span class="s2">, </span><span class="s1">handle_unknown</span><span class="s2">=</span><span class="s4">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">force_all_finite</span><span class="s2">=</span><span class="s4">&quot;allow-nan&quot;</span>
        <span class="s2">)</span>

        <span class="s6"># If 'multiclass' multiply axis=1 by num of classes else keep shape the same</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_type_ </span><span class="s2">== </span><span class="s4">&quot;multiclass&quot;</span><span class="s2">:</span>
            <span class="s1">X_out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span>
                <span class="s2">(</span><span class="s1">X_ordinal</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">X_ordinal</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] * </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">classes_</span><span class="s2">)),</span>
                <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">X_out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">X_ordinal</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_transform_X_ordinal</span><span class="s2">(</span>
            <span class="s1">X_out</span><span class="s2">,</span>
            <span class="s1">X_ordinal</span><span class="s2">,</span>
            <span class="s2">~</span><span class="s1">X_known_mask</span><span class="s2">,</span>
            <span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">),</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">encodings_</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">target_mean_</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">X_out</span>

    <span class="s0">def </span><span class="s1">_fit_encodings_all</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Fit a target encoding with all the data.&quot;&quot;&quot;</span>
        <span class="s6"># avoid circular import</span>
        <span class="s0">from </span><span class="s2">..</span><span class="s1">preprocessing </span><span class="s0">import </span><span class="s2">(</span>
            <span class="s1">LabelBinarizer</span><span class="s2">,</span>
            <span class="s1">LabelEncoder</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s1">check_consistent_length</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_fit</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">handle_unknown</span><span class="s2">=</span><span class="s4">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">force_all_finite</span><span class="s2">=</span><span class="s4">&quot;allow-nan&quot;</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_type </span><span class="s2">== </span><span class="s4">&quot;auto&quot;</span><span class="s2">:</span>
            <span class="s1">accepted_target_types </span><span class="s2">= (</span><span class="s4">&quot;binary&quot;</span><span class="s2">, </span><span class="s4">&quot;multiclass&quot;</span><span class="s2">, </span><span class="s4">&quot;continuous&quot;</span><span class="s2">)</span>
            <span class="s1">inferred_type_of_target </span><span class="s2">= </span><span class="s1">type_of_target</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">input_name</span><span class="s2">=</span><span class="s4">&quot;y&quot;</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">inferred_type_of_target </span><span class="s0">not in </span><span class="s1">accepted_target_types</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s4">&quot;Unknown label type: Target type was inferred to be &quot;</span>
                    <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">inferred_type_of_target</span><span class="s0">!r}</span><span class="s4">. Only </span><span class="s0">{</span><span class="s1">accepted_target_types</span><span class="s0">} </span><span class="s4">are &quot;</span>
                    <span class="s4">&quot;supported.&quot;</span>
                <span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">target_type_ </span><span class="s2">= </span><span class="s1">inferred_type_of_target</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">target_type_ </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_type</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">classes_ </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_type_ </span><span class="s2">== </span><span class="s4">&quot;binary&quot;</span><span class="s2">:</span>
            <span class="s1">label_encoder </span><span class="s2">= </span><span class="s1">LabelEncoder</span><span class="s2">()</span>
            <span class="s1">y </span><span class="s2">= </span><span class="s1">label_encoder</span><span class="s2">.</span><span class="s1">fit_transform</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">classes_ </span><span class="s2">= </span><span class="s1">label_encoder</span><span class="s2">.</span><span class="s1">classes_</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_type_ </span><span class="s2">== </span><span class="s4">&quot;multiclass&quot;</span><span class="s2">:</span>
            <span class="s1">label_binarizer </span><span class="s2">= </span><span class="s1">LabelBinarizer</span><span class="s2">()</span>
            <span class="s1">y </span><span class="s2">= </span><span class="s1">label_binarizer</span><span class="s2">.</span><span class="s1">fit_transform</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">classes_ </span><span class="s2">= </span><span class="s1">label_binarizer</span><span class="s2">.</span><span class="s1">classes_</span>
        <span class="s0">else</span><span class="s2">:  </span><span class="s6"># continuous</span>
            <span class="s1">y </span><span class="s2">= </span><span class="s1">_check_y</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">y_numeric</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">estimator</span><span class="s2">=</span><span class="s1">self</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">target_mean_ </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">)</span>

        <span class="s1">X_ordinal</span><span class="s2">, </span><span class="s1">X_known_mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_transform</span><span class="s2">(</span>
            <span class="s1">X</span><span class="s2">, </span><span class="s1">handle_unknown</span><span class="s2">=</span><span class="s4">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">force_all_finite</span><span class="s2">=</span><span class="s4">&quot;allow-nan&quot;</span>
        <span class="s2">)</span>
        <span class="s1">n_categories </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">fromiter</span><span class="s2">(</span>
            <span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">category_for_feature</span><span class="s2">) </span><span class="s0">for </span><span class="s1">category_for_feature </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">categories_</span><span class="s2">),</span>
            <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int64</span><span class="s2">,</span>
            <span class="s1">count</span><span class="s2">=</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">categories_</span><span class="s2">),</span>
        <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_type_ </span><span class="s2">== </span><span class="s4">&quot;multiclass&quot;</span><span class="s2">:</span>
            <span class="s1">encodings </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_fit_encoding_multiclass</span><span class="s2">(</span>
                <span class="s1">X_ordinal</span><span class="s2">,</span>
                <span class="s1">y</span><span class="s2">,</span>
                <span class="s1">n_categories</span><span class="s2">,</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">target_mean_</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">encodings </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_fit_encoding_binary_or_continuous</span><span class="s2">(</span>
                <span class="s1">X_ordinal</span><span class="s2">,</span>
                <span class="s1">y</span><span class="s2">,</span>
                <span class="s1">n_categories</span><span class="s2">,</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">target_mean_</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">encodings_ </span><span class="s2">= </span><span class="s1">encodings</span>

        <span class="s0">return </span><span class="s1">X_ordinal</span><span class="s2">, </span><span class="s1">X_known_mask</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">n_categories</span>

    <span class="s0">def </span><span class="s1">_fit_encoding_binary_or_continuous</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">X_ordinal</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">n_categories</span><span class="s2">, </span><span class="s1">target_mean</span>
    <span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Learn target encodings.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">smooth </span><span class="s2">== </span><span class="s4">&quot;auto&quot;</span><span class="s2">:</span>
            <span class="s1">y_variance </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">var</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>
            <span class="s1">encodings </span><span class="s2">= </span><span class="s1">_fit_encoding_fast_auto_smooth</span><span class="s2">(</span>
                <span class="s1">X_ordinal</span><span class="s2">,</span>
                <span class="s1">y</span><span class="s2">,</span>
                <span class="s1">n_categories</span><span class="s2">,</span>
                <span class="s1">target_mean</span><span class="s2">,</span>
                <span class="s1">y_variance</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">encodings </span><span class="s2">= </span><span class="s1">_fit_encoding_fast</span><span class="s2">(</span>
                <span class="s1">X_ordinal</span><span class="s2">,</span>
                <span class="s1">y</span><span class="s2">,</span>
                <span class="s1">n_categories</span><span class="s2">,</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">smooth</span><span class="s2">,</span>
                <span class="s1">target_mean</span><span class="s2">,</span>
            <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">encodings</span>

    <span class="s0">def </span><span class="s1">_fit_encoding_multiclass</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">X_ordinal</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">n_categories</span><span class="s2">, </span><span class="s1">target_mean</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Learn multiclass encodings. 
 
        Learn encodings for each class (c) then reorder encodings such that 
        the same features (f) are grouped together. `reorder_index` enables 
        converting from: 
        f0_c0, f1_c0, f0_c1, f1_c1, f0_c2, f1_c2 
        to: 
        f0_c0, f0_c1, f0_c2, f1_c0, f1_c1, f1_c2 
        &quot;&quot;&quot;</span>
        <span class="s1">n_features </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">n_features_in_</span>
        <span class="s1">n_classes </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">classes_</span><span class="s2">)</span>

        <span class="s1">encodings </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">n_classes</span><span class="s2">):</span>
            <span class="s1">y_class </span><span class="s2">= </span><span class="s1">y</span><span class="s2">[:, </span><span class="s1">i</span><span class="s2">]</span>
            <span class="s1">encoding </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_fit_encoding_binary_or_continuous</span><span class="s2">(</span>
                <span class="s1">X_ordinal</span><span class="s2">,</span>
                <span class="s1">y_class</span><span class="s2">,</span>
                <span class="s1">n_categories</span><span class="s2">,</span>
                <span class="s1">target_mean</span><span class="s2">[</span><span class="s1">i</span><span class="s2">],</span>
            <span class="s2">)</span>
            <span class="s1">encodings</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">encoding</span><span class="s2">)</span>

        <span class="s1">reorder_index </span><span class="s2">= (</span>
            <span class="s1">idx</span>
            <span class="s0">for </span><span class="s1">start </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">n_features</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, (</span><span class="s1">n_classes </span><span class="s2">* </span><span class="s1">n_features</span><span class="s2">), </span><span class="s1">n_features</span><span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s2">[</span><span class="s1">encodings</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">] </span><span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">reorder_index</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">_transform_X_ordinal</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">X_out</span><span class="s2">,</span>
        <span class="s1">X_ordinal</span><span class="s2">,</span>
        <span class="s1">X_unknown_mask</span><span class="s2">,</span>
        <span class="s1">row_indices</span><span class="s2">,</span>
        <span class="s1">encodings</span><span class="s2">,</span>
        <span class="s1">target_mean</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Transform X_ordinal using encodings. 
 
        In the multiclass case, `X_ordinal` and `X_unknown_mask` have column 
        (axis=1) size `n_features`, while `encodings` has length of size 
        `n_features * n_classes`. `feat_idx` deals with this by repeating 
        feature indices by `n_classes` E.g., for 3 features, 2 classes: 
        0,0,1,1,2,2 
 
        Additionally, `target_mean` is of shape (`n_classes`,) so `mean_idx` 
        cycles through 0 to `n_classes` - 1, `n_features` times. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_type_ </span><span class="s2">== </span><span class="s4">&quot;multiclass&quot;</span><span class="s2">:</span>
            <span class="s1">n_classes </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">classes_</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">e_idx</span><span class="s2">, </span><span class="s1">encoding </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">encodings</span><span class="s2">):</span>
                <span class="s6"># Repeat feature indices by n_classes</span>
                <span class="s1">feat_idx </span><span class="s2">= </span><span class="s1">e_idx </span><span class="s2">// </span><span class="s1">n_classes</span>
                <span class="s6"># Cycle through each class</span>
                <span class="s1">mean_idx </span><span class="s2">= </span><span class="s1">e_idx </span><span class="s2">% </span><span class="s1">n_classes</span>
                <span class="s1">X_out</span><span class="s2">[</span><span class="s1">row_indices</span><span class="s2">, </span><span class="s1">e_idx</span><span class="s2">] = </span><span class="s1">encoding</span><span class="s2">[</span><span class="s1">X_ordinal</span><span class="s2">[</span><span class="s1">row_indices</span><span class="s2">, </span><span class="s1">feat_idx</span><span class="s2">]]</span>
                <span class="s1">X_out</span><span class="s2">[</span><span class="s1">X_unknown_mask</span><span class="s2">[:, </span><span class="s1">feat_idx</span><span class="s2">], </span><span class="s1">e_idx</span><span class="s2">] = </span><span class="s1">target_mean</span><span class="s2">[</span><span class="s1">mean_idx</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">for </span><span class="s1">e_idx</span><span class="s2">, </span><span class="s1">encoding </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">encodings</span><span class="s2">):</span>
                <span class="s1">X_out</span><span class="s2">[</span><span class="s1">row_indices</span><span class="s2">, </span><span class="s1">e_idx</span><span class="s2">] = </span><span class="s1">encoding</span><span class="s2">[</span><span class="s1">X_ordinal</span><span class="s2">[</span><span class="s1">row_indices</span><span class="s2">, </span><span class="s1">e_idx</span><span class="s2">]]</span>
                <span class="s1">X_out</span><span class="s2">[</span><span class="s1">X_unknown_mask</span><span class="s2">[:, </span><span class="s1">e_idx</span><span class="s2">], </span><span class="s1">e_idx</span><span class="s2">] = </span><span class="s1">target_mean</span>

    <span class="s0">def </span><span class="s1">get_feature_names_out</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">input_features</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Get output feature names for transformation. 
 
        Parameters 
        ---------- 
        input_features : array-like of str or None, default=None 
            Not used, present here for API consistency by convention. 
 
        Returns 
        ------- 
        feature_names_out : ndarray of str objects 
            Transformed feature names. `feature_names_in_` is used unless it is 
            not defined, in which case the following input feature names are 
            generated: `[&quot;x0&quot;, &quot;x1&quot;, ..., &quot;x(n_features_in_ - 1)&quot;]`. 
            When `type_of_target_` is &quot;multiclass&quot; the names are of the format 
            '&lt;feature_name&gt;_&lt;class_name&gt;'. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s4">&quot;n_features_in_&quot;</span><span class="s2">)</span>
        <span class="s1">feature_names </span><span class="s2">= </span><span class="s1">_check_feature_names_in</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">input_features</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">target_type_ </span><span class="s2">== </span><span class="s4">&quot;multiclass&quot;</span><span class="s2">:</span>
            <span class="s1">feature_names </span><span class="s2">= [</span>
                <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">feature_name</span><span class="s0">}</span><span class="s4">_</span><span class="s0">{</span><span class="s1">class_name</span><span class="s0">}</span><span class="s4">&quot;</span>
                <span class="s0">for </span><span class="s1">feature_name </span><span class="s0">in </span><span class="s1">feature_names</span>
                <span class="s0">for </span><span class="s1">class_name </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">classes_</span>
            <span class="s2">]</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">feature_names</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">object</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">feature_names</span>

    <span class="s0">def </span><span class="s1">_more_tags</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s4">&quot;requires_y&quot;</span><span class="s2">: </span><span class="s0">True</span><span class="s2">,</span>
        <span class="s2">}</span>
</pre>
</body>
</html>