<html>
<head>
<title>_page_trend_test.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #5f826b; font-style: italic;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_page_trend_test.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">permutations</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">math</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_continuous_distns </span><span class="s0">import </span><span class="s1">norm</span>
<span class="s0">import </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">stats</span>
<span class="s0">from </span><span class="s1">dataclasses </span><span class="s0">import </span><span class="s1">dataclass</span>


<span class="s2">@</span><span class="s1">dataclass</span>
<span class="s0">class </span><span class="s1">PageTrendTestResult</span><span class="s2">:</span>
    <span class="s1">statistic</span><span class="s2">: </span><span class="s1">float</span>
    <span class="s1">pvalue</span><span class="s2">: </span><span class="s1">float</span>
    <span class="s1">method</span><span class="s2">: </span><span class="s1">str</span>


<span class="s0">def </span><span class="s1">page_trend_test</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">ranked</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">predicted_ranks</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s3">'auto'</span><span class="s2">):</span>
    <span class="s4">r&quot;&quot;&quot; 
    Perform Page's Test, a measure of trend in observations between treatments. 
 
    Page's Test (also known as Page's :math:`L` test) is useful when: 
 
    * there are :math:`n \geq 3` treatments, 
    * :math:`m \geq 2` subjects are observed for each treatment, and 
    * the observations are hypothesized to have a particular order. 
 
    Specifically, the test considers the null hypothesis that 
 
    .. math:: 
 
        m_1 = m_2 = m_3 \cdots = m_n, 
 
    where :math:`m_j` is the mean of the observed quantity under treatment 
    :math:`j`, against the alternative hypothesis that 
 
    .. math:: 
 
        m_1 \leq m_2 \leq m_3 \leq \cdots \leq m_n, 
 
    where at least one inequality is strict. 
 
    As noted by [4]_, Page's :math:`L` test has greater statistical power than 
    the Friedman test against the alternative that there is a difference in 
    trend, as Friedman's test only considers a difference in the means of the 
    observations without considering their order. Whereas Spearman :math:`\rho` 
    considers the correlation between the ranked observations of two variables 
    (e.g. the airspeed velocity of a swallow vs. the weight of the coconut it 
    carries), Page's :math:`L` is concerned with a trend in an observation 
    (e.g. the airspeed velocity of a swallow) across several distinct 
    treatments (e.g. carrying each of five coconuts of different weight) even 
    as the observation is repeated with multiple subjects (e.g. one European 
    swallow and one African swallow). 
 
    Parameters 
    ---------- 
    data : array-like 
        A :math:`m \times n` array; the element in row :math:`i` and 
        column :math:`j` is the observation corresponding with subject 
        :math:`i` and treatment :math:`j`. By default, the columns are 
        assumed to be arranged in order of increasing predicted mean. 
 
    ranked : boolean, optional 
        By default, `data` is assumed to be observations rather than ranks; 
        it will be ranked with `scipy.stats.rankdata` along ``axis=1``. If 
        `data` is provided in the form of ranks, pass argument ``True``. 
 
    predicted_ranks : array-like, optional 
        The predicted ranks of the column means. If not specified, 
        the columns are assumed to be arranged in order of increasing 
        predicted mean, so the default `predicted_ranks` are 
        :math:`[1, 2, \dots, n-1, n]`. 
 
    method : {'auto', 'asymptotic', 'exact'}, optional 
        Selects the method used to calculate the *p*-value. The following 
        options are available. 
 
        * 'auto': selects between 'exact' and 'asymptotic' to 
          achieve reasonably accurate results in reasonable time (default) 
        * 'asymptotic': compares the standardized test statistic against 
          the normal distribution 
        * 'exact': computes the exact *p*-value by comparing the observed 
          :math:`L` statistic against those realized by all possible 
          permutations of ranks (under the null hypothesis that each 
          permutation is equally likely) 
 
    Returns 
    ------- 
    res : PageTrendTestResult 
        An object containing attributes: 
 
        statistic : float 
            Page's :math:`L` test statistic. 
        pvalue : float 
            The associated *p*-value 
        method : {'asymptotic', 'exact'} 
            The method used to compute the *p*-value 
 
    See Also 
    -------- 
    rankdata, friedmanchisquare, spearmanr 
 
    Notes 
    ----- 
    As noted in [1]_, &quot;the :math:`n` 'treatments' could just as well represent 
    :math:`n` objects or events or performances or persons or trials ranked.&quot; 
    Similarly, the :math:`m` 'subjects' could equally stand for :math:`m` 
    &quot;groupings by ability or some other control variable, or judges doing 
    the ranking, or random replications of some other sort.&quot; 
 
    The procedure for calculating the :math:`L` statistic, adapted from 
    [1]_, is: 
 
    1. &quot;Predetermine with careful logic the appropriate hypotheses 
       concerning the predicted ordering of the experimental results. 
       If no reasonable basis for ordering any treatments is known, the 
       :math:`L` test is not appropriate.&quot; 
    2. &quot;As in other experiments, determine at what level of confidence 
       you will reject the null hypothesis that there is no agreement of 
       experimental results with the monotonic hypothesis.&quot; 
    3. &quot;Cast the experimental material into a two-way table of :math:`n` 
       columns (treatments, objects ranked, conditions) and :math:`m` 
       rows (subjects, replication groups, levels of control variables).&quot; 
    4. &quot;When experimental observations are recorded, rank them across each 
       row&quot;, e.g. ``ranks = scipy.stats.rankdata(data, axis=1)``. 
    5. &quot;Add the ranks in each column&quot;, e.g. 
       ``colsums = np.sum(ranks, axis=0)``. 
    6. &quot;Multiply each sum of ranks by the predicted rank for that same 
       column&quot;, e.g. ``products = predicted_ranks * colsums``. 
    7. &quot;Sum all such products&quot;, e.g. ``L = products.sum()``. 
 
    [1]_ continues by suggesting use of the standardized statistic 
 
    .. math:: 
 
        \chi_L^2 = \frac{\left[12L-3mn(n+1)^2\right]^2}{mn^2(n^2-1)(n+1)} 
 
    &quot;which is distributed approximately as chi-square with 1 degree of 
    freedom. The ordinary use of :math:`\chi^2` tables would be 
    equivalent to a two-sided test of agreement. If a one-sided test 
    is desired, *as will almost always be the case*, the probability 
    discovered in the chi-square table should be *halved*.&quot; 
 
    However, this standardized statistic does not distinguish between the 
    observed values being well correlated with the predicted ranks and being 
    _anti_-correlated with the predicted ranks. Instead, we follow [2]_ 
    and calculate the standardized statistic 
 
    .. math:: 
 
        \Lambda = \frac{L - E_0}{\sqrt{V_0}}, 
 
    where :math:`E_0 = \frac{1}{4} mn(n+1)^2` and 
    :math:`V_0 = \frac{1}{144} mn^2(n+1)(n^2-1)`, &quot;which is asymptotically 
    normal under the null hypothesis&quot;. 
 
    The *p*-value for ``method='exact'`` is generated by comparing the observed 
    value of :math:`L` against the :math:`L` values generated for all 
    :math:`(n!)^m` possible permutations of ranks. The calculation is performed 
    using the recursive method of [5]. 
 
    The *p*-values are not adjusted for the possibility of ties. When 
    ties are present, the reported  ``'exact'`` *p*-values may be somewhat 
    larger (i.e. more conservative) than the true *p*-value [2]_. The 
    ``'asymptotic'``` *p*-values, however, tend to be smaller (i.e. less 
    conservative) than the ``'exact'`` *p*-values. 
 
    References 
    ---------- 
    .. [1] Ellis Batten Page, &quot;Ordered hypotheses for multiple treatments: 
       a significant test for linear ranks&quot;, *Journal of the American 
       Statistical Association* 58(301), p. 216--230, 1963. 
 
    .. [2] Markus Neuhauser, *Nonparametric Statistical Test: A computational 
       approach*, CRC Press, p. 150--152, 2012. 
 
    .. [3] Statext LLC, &quot;Page's L Trend Test - Easy Statistics&quot;, *Statext - 
       Statistics Study*, https://www.statext.com/practice/PageTrendTest03.php, 
       Accessed July 12, 2020. 
 
    .. [4] &quot;Page's Trend Test&quot;, *Wikipedia*, WikimediaFoundation, 
       https://en.wikipedia.org/wiki/Page%27s_trend_test, 
       Accessed July 12, 2020. 
 
    .. [5] Robert E. Odeh, &quot;The exact distribution of Page's L-statistic in 
       the two-way layout&quot;, *Communications in Statistics - Simulation and 
       Computation*,  6(1), p. 49--61, 1977. 
 
    Examples 
    -------- 
    We use the example from [3]_: 10 students are asked to rate three 
    teaching methods - tutorial, lecture, and seminar - on a scale of 1-5, 
    with 1 being the lowest and 5 being the highest. We have decided that 
    a confidence level of 99% is required to reject the null hypothesis in 
    favor of our alternative: that the seminar will have the highest ratings 
    and the tutorial will have the lowest. Initially, the data have been 
    tabulated with each row representing an individual student's ratings of 
    the three methods in the following order: tutorial, lecture, seminar. 
 
    &gt;&gt;&gt; table = [[3, 4, 3], 
    ...          [2, 2, 4], 
    ...          [3, 3, 5], 
    ...          [1, 3, 2], 
    ...          [2, 3, 2], 
    ...          [2, 4, 5], 
    ...          [1, 2, 4], 
    ...          [3, 4, 4], 
    ...          [2, 4, 5], 
    ...          [1, 3, 4]] 
 
    Because the tutorial is hypothesized to have the lowest ratings, the 
    column corresponding with tutorial rankings should be first; the seminar 
    is hypothesized to have the highest ratings, so its column should be last. 
    Since the columns are already arranged in this order of increasing 
    predicted mean, we can pass the table directly into `page_trend_test`. 
 
    &gt;&gt;&gt; from scipy.stats import page_trend_test 
    &gt;&gt;&gt; res = page_trend_test(table) 
    &gt;&gt;&gt; res 
    PageTrendTestResult(statistic=133.5, pvalue=0.0018191161948127822, 
                        method='exact') 
 
    This *p*-value indicates that there is a 0.1819% chance that 
    the :math:`L` statistic would reach such an extreme value under the null 
    hypothesis. Because 0.1819% is less than 1%, we have evidence to reject 
    the null hypothesis in favor of our alternative at a 99% confidence level. 
 
    The value of the :math:`L` statistic is 133.5. To check this manually, 
    we rank the data such that high scores correspond with high ranks, settling 
    ties with an average rank: 
 
    &gt;&gt;&gt; from scipy.stats import rankdata 
    &gt;&gt;&gt; ranks = rankdata(table, axis=1) 
    &gt;&gt;&gt; ranks 
    array([[1.5, 3. , 1.5], 
           [1.5, 1.5, 3. ], 
           [1.5, 1.5, 3. ], 
           [1. , 3. , 2. ], 
           [1.5, 3. , 1.5], 
           [1. , 2. , 3. ], 
           [1. , 2. , 3. ], 
           [1. , 2.5, 2.5], 
           [1. , 2. , 3. ], 
           [1. , 2. , 3. ]]) 
 
    We add the ranks within each column, multiply the sums by the 
    predicted ranks, and sum the products. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; m, n = ranks.shape 
    &gt;&gt;&gt; predicted_ranks = np.arange(1, n+1) 
    &gt;&gt;&gt; L = (predicted_ranks * np.sum(ranks, axis=0)).sum() 
    &gt;&gt;&gt; res.statistic == L 
    True 
 
    As presented in [3]_, the asymptotic approximation of the *p*-value is the 
    survival function of the normal distribution evaluated at the standardized 
    test statistic: 
 
    &gt;&gt;&gt; from scipy.stats import norm 
    &gt;&gt;&gt; E0 = (m*n*(n+1)**2)/4 
    &gt;&gt;&gt; V0 = (m*n**2*(n+1)*(n**2-1))/144 
    &gt;&gt;&gt; Lambda = (L-E0)/np.sqrt(V0) 
    &gt;&gt;&gt; p = norm.sf(Lambda) 
    &gt;&gt;&gt; p 
    0.0012693433690751756 
 
    This does not precisely match the *p*-value reported by `page_trend_test` 
    above. The asymptotic distribution is not very accurate, nor conservative, 
    for :math:`m \leq 12` and :math:`n \leq 8`, so `page_trend_test` chose to 
    use ``method='exact'`` based on the dimensions of the table and the 
    recommendations in Page's original paper [1]_. To override 
    `page_trend_test`'s choice, provide the `method` argument. 
 
    &gt;&gt;&gt; res = page_trend_test(table, method=&quot;asymptotic&quot;) 
    &gt;&gt;&gt; res 
    PageTrendTestResult(statistic=133.5, pvalue=0.0012693433690751756, 
                        method='asymptotic') 
 
    If the data are already ranked, we can pass in the ``ranks`` instead of 
    the ``table`` to save computation time. 
 
    &gt;&gt;&gt; res = page_trend_test(ranks,             # ranks of data 
    ...                       ranked=True,       # data is already ranked 
    ...                       ) 
    &gt;&gt;&gt; res 
    PageTrendTestResult(statistic=133.5, pvalue=0.0018191161948127822, 
                        method='exact') 
 
    Suppose the raw data had been tabulated in an order different from the 
    order of predicted means, say lecture, seminar, tutorial. 
 
    &gt;&gt;&gt; table = np.asarray(table)[:, [1, 2, 0]] 
 
    Since the arrangement of this table is not consistent with the assumed 
    ordering, we can either rearrange the table or provide the 
    `predicted_ranks`. Remembering that the lecture is predicted 
    to have the middle rank, the seminar the highest, and tutorial the lowest, 
    we pass: 
 
    &gt;&gt;&gt; res = page_trend_test(table,             # data as originally tabulated 
    ...                       predicted_ranks=[2, 3, 1],  # our predicted order 
    ...                       ) 
    &gt;&gt;&gt; res 
    PageTrendTestResult(statistic=133.5, pvalue=0.0018191161948127822, 
                        method='exact') 
 
    &quot;&quot;&quot;</span>

    <span class="s5"># Possible values of the method parameter and the corresponding function</span>
    <span class="s5"># used to evaluate the p value</span>
    <span class="s1">methods </span><span class="s2">= {</span><span class="s3">&quot;asymptotic&quot;</span><span class="s2">: </span><span class="s1">_l_p_asymptotic</span><span class="s2">,</span>
               <span class="s3">&quot;exact&quot;</span><span class="s2">: </span><span class="s1">_l_p_exact</span><span class="s2">,</span>
               <span class="s3">&quot;auto&quot;</span><span class="s2">: </span><span class="s0">None</span><span class="s2">}</span>
    <span class="s0">if </span><span class="s1">method </span><span class="s0">not in </span><span class="s1">methods</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f&quot;`method` must be in </span><span class="s0">{</span><span class="s1">set</span><span class="s2">(</span><span class="s1">methods</span><span class="s2">)</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s2">)</span>

    <span class="s1">ranks </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">ranks</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s6">2</span><span class="s2">:  </span><span class="s5"># TODO: relax this to accept 3d arrays?</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;`data` must be a 2d array.&quot;</span><span class="s2">)</span>

    <span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">ranks</span><span class="s2">.</span><span class="s1">shape</span>
    <span class="s0">if </span><span class="s1">m </span><span class="s2">&lt; </span><span class="s6">2 </span><span class="s0">or </span><span class="s1">n </span><span class="s2">&lt; </span><span class="s6">3</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Page's L is only appropriate for data with two &quot;</span>
                         <span class="s3">&quot;or more rows and three or more columns.&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;`data` contains NaNs, which cannot be ranked &quot;</span>
                         <span class="s3">&quot;meaningfully&quot;</span><span class="s2">)</span>

    <span class="s5"># ensure NumPy array and rank the data if it's not already ranked</span>
    <span class="s0">if </span><span class="s1">ranked</span><span class="s2">:</span>
        <span class="s5"># Only a basic check on whether data is ranked. Checking that the data</span>
        <span class="s5"># is properly ranked could take as much time as ranking it.</span>
        <span class="s0">if not </span><span class="s2">(</span><span class="s1">ranks</span><span class="s2">.</span><span class="s1">min</span><span class="s2">() &gt;= </span><span class="s6">1 </span><span class="s0">and </span><span class="s1">ranks</span><span class="s2">.</span><span class="s1">max</span><span class="s2">() &lt;= </span><span class="s1">ranks</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;`data` is not properly ranked. Rank the data or &quot;</span>
                             <span class="s3">&quot;pass `ranked=False`.&quot;</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">ranks </span><span class="s2">= </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">stats</span><span class="s2">.</span><span class="s1">rankdata</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">)</span>

    <span class="s5"># generate predicted ranks if not provided, ensure valid NumPy array</span>
    <span class="s0">if </span><span class="s1">predicted_ranks </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">predicted_ranks </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s1">n</span><span class="s2">+</span><span class="s6">1</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">predicted_ranks </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">predicted_ranks</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s2">(</span><span class="s1">predicted_ranks</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&lt; </span><span class="s6">1 </span><span class="s0">or</span>
                <span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">predicted_ranks</span><span class="s2">) != </span><span class="s1">set</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s1">n</span><span class="s2">+</span><span class="s6">1</span><span class="s2">)) </span><span class="s0">or</span>
                 <span class="s1">len</span><span class="s2">(</span><span class="s1">predicted_ranks</span><span class="s2">) != </span><span class="s1">n</span><span class="s2">)):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f&quot;`predicted_ranks` must include each integer &quot;</span>
                             <span class="s3">f&quot;from 1 to </span><span class="s0">{</span><span class="s1">n</span><span class="s0">} </span><span class="s3">(the number of columns in &quot;</span>
                             <span class="s3">f&quot;`data`) exactly once.&quot;</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">ranked</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">&quot;`ranked` must be boolean.&quot;</span><span class="s2">)</span>

    <span class="s5"># Calculate the L statistic</span>
    <span class="s1">L </span><span class="s2">= </span><span class="s1">_l_vectorized</span><span class="s2">(</span><span class="s1">ranks</span><span class="s2">, </span><span class="s1">predicted_ranks</span><span class="s2">)</span>

    <span class="s5"># Calculate the p-value</span>
    <span class="s0">if </span><span class="s1">method </span><span class="s2">== </span><span class="s3">&quot;auto&quot;</span><span class="s2">:</span>
        <span class="s1">method </span><span class="s2">= </span><span class="s1">_choose_method</span><span class="s2">(</span><span class="s1">ranks</span><span class="s2">)</span>
    <span class="s1">p_fun </span><span class="s2">= </span><span class="s1">methods</span><span class="s2">[</span><span class="s1">method</span><span class="s2">]  </span><span class="s5"># get the function corresponding with the method</span>
    <span class="s1">p </span><span class="s2">= </span><span class="s1">p_fun</span><span class="s2">(</span><span class="s1">L</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>

    <span class="s1">page_result </span><span class="s2">= </span><span class="s1">PageTrendTestResult</span><span class="s2">(</span><span class="s1">statistic</span><span class="s2">=</span><span class="s1">L</span><span class="s2">, </span><span class="s1">pvalue</span><span class="s2">=</span><span class="s1">p</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s1">method</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">page_result</span>


<span class="s0">def </span><span class="s1">_choose_method</span><span class="s2">(</span><span class="s1">ranks</span><span class="s2">):</span>
    <span class="s4">'''Choose method for computing p-value automatically'''</span>
    <span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">ranks</span><span class="s2">.</span><span class="s1">shape</span>
    <span class="s0">if </span><span class="s1">n </span><span class="s2">&gt; </span><span class="s6">8 </span><span class="s0">or </span><span class="s2">(</span><span class="s1">m </span><span class="s2">&gt; </span><span class="s6">12 </span><span class="s0">and </span><span class="s1">n </span><span class="s2">&gt; </span><span class="s6">3</span><span class="s2">) </span><span class="s0">or </span><span class="s1">m </span><span class="s2">&gt; </span><span class="s6">20</span><span class="s2">:  </span><span class="s5"># as in [1], [4]</span>
        <span class="s1">method </span><span class="s2">= </span><span class="s3">&quot;asymptotic&quot;</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">method </span><span class="s2">= </span><span class="s3">&quot;exact&quot;</span>
    <span class="s0">return </span><span class="s1">method</span>


<span class="s0">def </span><span class="s1">_l_vectorized</span><span class="s2">(</span><span class="s1">ranks</span><span class="s2">, </span><span class="s1">predicted_ranks</span><span class="s2">):</span>
    <span class="s4">'''Calculate's Page's L statistic for each page of a 3d array'''</span>
    <span class="s1">colsums </span><span class="s2">= </span><span class="s1">ranks</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=-</span><span class="s6">2</span><span class="s2">, </span><span class="s1">keepdims</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s1">products </span><span class="s2">= </span><span class="s1">predicted_ranks </span><span class="s2">* </span><span class="s1">colsums</span>
    <span class="s1">Ls </span><span class="s2">= </span><span class="s1">products</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">)</span>
    <span class="s1">Ls </span><span class="s2">= </span><span class="s1">Ls</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] </span><span class="s0">if </span><span class="s1">Ls</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s6">1 </span><span class="s0">else </span><span class="s1">Ls</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">()</span>
    <span class="s0">return </span><span class="s1">Ls</span>


<span class="s0">def </span><span class="s1">_l_p_asymptotic</span><span class="s2">(</span><span class="s1">L</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">):</span>
    <span class="s4">'''Calculate the p-value of Page's L from the asymptotic distribution'''</span>
    <span class="s5"># Using [1] as a reference, the asymptotic p-value would be calculated as:</span>
    <span class="s5"># chi_L = (12*L - 3*m*n*(n+1)**2)**2/(m*n**2*(n**2-1)*(n+1))</span>
    <span class="s5"># p = chi2.sf(chi_L, df=1, loc=0, scale=1)/2</span>
    <span class="s5"># but this is insensitive to the direction of the hypothesized ranking</span>

    <span class="s5"># See [2] page 151</span>
    <span class="s1">E0 </span><span class="s2">= (</span><span class="s1">m</span><span class="s2">*</span><span class="s1">n</span><span class="s2">*(</span><span class="s1">n</span><span class="s2">+</span><span class="s6">1</span><span class="s2">)**</span><span class="s6">2</span><span class="s2">)/</span><span class="s6">4</span>
    <span class="s1">V0 </span><span class="s2">= (</span><span class="s1">m</span><span class="s2">*</span><span class="s1">n</span><span class="s2">**</span><span class="s6">2</span><span class="s2">*(</span><span class="s1">n</span><span class="s2">+</span><span class="s6">1</span><span class="s2">)*(</span><span class="s1">n</span><span class="s2">**</span><span class="s6">2</span><span class="s2">-</span><span class="s6">1</span><span class="s2">))/</span><span class="s6">144</span>
    <span class="s1">Lambda </span><span class="s2">= (</span><span class="s1">L</span><span class="s2">-</span><span class="s1">E0</span><span class="s2">)/</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">V0</span><span class="s2">)</span>
    <span class="s5"># This is a one-sided &quot;greater&quot; test - calculate the probability that the</span>
    <span class="s5"># L statistic under H0 would be greater than the observed L statistic</span>
    <span class="s1">p </span><span class="s2">= </span><span class="s1">norm</span><span class="s2">.</span><span class="s1">sf</span><span class="s2">(</span><span class="s1">Lambda</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">p</span>


<span class="s0">def </span><span class="s1">_l_p_exact</span><span class="s2">(</span><span class="s1">L</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">):</span>
    <span class="s4">'''Calculate the p-value of Page's L exactly'''</span>
    <span class="s5"># [1] uses m, n; [5] uses n, k.</span>
    <span class="s5"># Switch convention here because exact calculation code references [5].</span>
    <span class="s1">L</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">k </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">L</span><span class="s2">), </span><span class="s1">int</span><span class="s2">(</span><span class="s1">m</span><span class="s2">), </span><span class="s1">int</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
    <span class="s1">_pagel_state</span><span class="s2">.</span><span class="s1">set_k</span><span class="s2">(</span><span class="s1">k</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">_pagel_state</span><span class="s2">.</span><span class="s1">sf</span><span class="s2">(</span><span class="s1">L</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">_PageL</span><span class="s2">:</span>
    <span class="s4">'''Maintains state between `page_trend_test` executions'''</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">'''Lightweight initialization'''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">all_pmfs </span><span class="s2">= {}</span>

    <span class="s0">def </span><span class="s1">set_k</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">):</span>
        <span class="s4">'''Calculate lower and upper limits of L for single row'''</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">k </span><span class="s2">= </span><span class="s1">k</span>
        <span class="s5"># See [5] top of page 52</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">a</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">b </span><span class="s2">= (</span><span class="s1">k</span><span class="s2">*(</span><span class="s1">k</span><span class="s2">+</span><span class="s6">1</span><span class="s2">)*(</span><span class="s1">k</span><span class="s2">+</span><span class="s6">2</span><span class="s2">))//</span><span class="s6">6</span><span class="s2">, (</span><span class="s1">k</span><span class="s2">*(</span><span class="s1">k</span><span class="s2">+</span><span class="s6">1</span><span class="s2">)*(</span><span class="s6">2</span><span class="s2">*</span><span class="s1">k</span><span class="s2">+</span><span class="s6">1</span><span class="s2">))//</span><span class="s6">6</span>

    <span class="s0">def </span><span class="s1">sf</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">n</span><span class="s2">):</span>
        <span class="s4">'''Survival function of Page's L statistic'''</span>
        <span class="s1">ps </span><span class="s2">= [</span><span class="s1">self</span><span class="s2">.</span><span class="s1">pmf</span><span class="s2">(</span><span class="s1">l</span><span class="s2">, </span><span class="s1">n</span><span class="s2">) </span><span class="s0">for </span><span class="s1">l </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">l</span><span class="s2">, </span><span class="s1">n</span><span class="s2">*</span><span class="s1">self</span><span class="s2">.</span><span class="s1">b </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">)]</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">ps</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">p_l_k_1</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s4">'''Relative frequency of each L value over all possible single rows'''</span>

        <span class="s5"># See [5] Equation (6)</span>
        <span class="s1">ranks </span><span class="s2">= </span><span class="s1">range</span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">k</span><span class="s2">+</span><span class="s6">1</span><span class="s2">)</span>
        <span class="s5"># generate all possible rows of length k</span>
        <span class="s1">rank_perms </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">permutations</span><span class="s2">(</span><span class="s1">ranks</span><span class="s2">)))</span>
        <span class="s5"># compute Page's L for all possible rows</span>
        <span class="s1">Ls </span><span class="s2">= (</span><span class="s1">ranks</span><span class="s2">*</span><span class="s1">rank_perms</span><span class="s2">).</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s6">1</span><span class="s2">)</span>
        <span class="s5"># count occurrences of each L value</span>
        <span class="s1">counts </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">histogram</span><span class="s2">(</span><span class="s1">Ls</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">a</span><span class="s2">-</span><span class="s6">0.5</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">b</span><span class="s2">+</span><span class="s6">1.5</span><span class="s2">))[</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s5"># factorial(k) is number of possible permutations</span>
        <span class="s0">return </span><span class="s1">counts</span><span class="s2">/</span><span class="s1">math</span><span class="s2">.</span><span class="s1">factorial</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">k</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">pmf</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">n</span><span class="s2">):</span>
        <span class="s4">'''Recursive function to evaluate p(l, k, n); see [5] Equation 1'''</span>

        <span class="s0">if </span><span class="s1">n </span><span class="s0">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">all_pmfs</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">all_pmfs</span><span class="s2">[</span><span class="s1">n</span><span class="s2">] = {}</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">k </span><span class="s0">not in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">all_pmfs</span><span class="s2">[</span><span class="s1">n</span><span class="s2">]:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">all_pmfs</span><span class="s2">[</span><span class="s1">n</span><span class="s2">][</span><span class="s1">self</span><span class="s2">.</span><span class="s1">k</span><span class="s2">] = {}</span>

        <span class="s5"># Cache results to avoid repeating calculation. Initially this was</span>
        <span class="s5"># written with lru_cache, but this seems faster? Also, we could add</span>
        <span class="s5"># an option to save this for future lookup.</span>
        <span class="s0">if </span><span class="s1">l </span><span class="s0">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">all_pmfs</span><span class="s2">[</span><span class="s1">n</span><span class="s2">][</span><span class="s1">self</span><span class="s2">.</span><span class="s1">k</span><span class="s2">]:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">all_pmfs</span><span class="s2">[</span><span class="s1">n</span><span class="s2">][</span><span class="s1">self</span><span class="s2">.</span><span class="s1">k</span><span class="s2">][</span><span class="s1">l</span><span class="s2">]</span>

        <span class="s0">if </span><span class="s1">n </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">ps </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">p_l_k_1</span><span class="s2">()  </span><span class="s5"># [5] Equation 6</span>
            <span class="s1">ls </span><span class="s2">= </span><span class="s1">range</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">a</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">b</span><span class="s2">+</span><span class="s6">1</span><span class="s2">)</span>
            <span class="s5"># not fast, but we'll only be here once</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">all_pmfs</span><span class="s2">[</span><span class="s1">n</span><span class="s2">][</span><span class="s1">self</span><span class="s2">.</span><span class="s1">k</span><span class="s2">] = {</span><span class="s1">l</span><span class="s2">: </span><span class="s1">p </span><span class="s0">for </span><span class="s1">l</span><span class="s2">, </span><span class="s1">p </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">ls</span><span class="s2">, </span><span class="s1">ps</span><span class="s2">)}</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">all_pmfs</span><span class="s2">[</span><span class="s1">n</span><span class="s2">][</span><span class="s1">self</span><span class="s2">.</span><span class="s1">k</span><span class="s2">][</span><span class="s1">l</span><span class="s2">]</span>

        <span class="s1">p </span><span class="s2">= </span><span class="s6">0</span>
        <span class="s1">low </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">l</span><span class="s2">-(</span><span class="s1">n</span><span class="s2">-</span><span class="s6">1</span><span class="s2">)*</span><span class="s1">self</span><span class="s2">.</span><span class="s1">b</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">a</span><span class="s2">)  </span><span class="s5"># [5] Equation 2</span>
        <span class="s1">high </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">l</span><span class="s2">-(</span><span class="s1">n</span><span class="s2">-</span><span class="s6">1</span><span class="s2">)*</span><span class="s1">self</span><span class="s2">.</span><span class="s1">a</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">b</span><span class="s2">)</span>

        <span class="s5"># [5] Equation 1</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">low</span><span class="s2">, </span><span class="s1">high</span><span class="s2">+</span><span class="s6">1</span><span class="s2">):</span>
            <span class="s1">p1 </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pmf</span><span class="s2">(</span><span class="s1">l</span><span class="s2">-</span><span class="s1">t</span><span class="s2">, </span><span class="s1">n</span><span class="s2">-</span><span class="s6">1</span><span class="s2">)</span>
            <span class="s1">p2 </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pmf</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s6">1</span><span class="s2">)</span>
            <span class="s1">p </span><span class="s2">+= </span><span class="s1">p1</span><span class="s2">*</span><span class="s1">p2</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">all_pmfs</span><span class="s2">[</span><span class="s1">n</span><span class="s2">][</span><span class="s1">self</span><span class="s2">.</span><span class="s1">k</span><span class="s2">][</span><span class="s1">l</span><span class="s2">] = </span><span class="s1">p</span>
        <span class="s0">return </span><span class="s1">p</span>


<span class="s5"># Maintain state for faster repeat calls to page_trend_test w/ method='exact'</span>
<span class="s1">_pagel_state </span><span class="s2">= </span><span class="s1">_PageL</span><span class="s2">()</span>
</pre>
</body>
</html>