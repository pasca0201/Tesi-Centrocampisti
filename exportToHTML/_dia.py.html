<html>
<head>
<title>_dia.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_dia.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Sparse DIAgonal format&quot;&quot;&quot;</span>

<span class="s1">__docformat__ </span><span class="s2">= </span><span class="s3">&quot;restructuredtext en&quot;</span>

<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">'dia_array'</span><span class="s2">, </span><span class="s3">'dia_matrix'</span><span class="s2">, </span><span class="s3">'isspmatrix_dia'</span><span class="s2">]</span>

<span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>

<span class="s4">from </span><span class="s2">..</span><span class="s1">_lib</span><span class="s2">.</span><span class="s1">_util </span><span class="s4">import </span><span class="s1">copy_if_needed</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_matrix </span><span class="s4">import </span><span class="s1">spmatrix</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_base </span><span class="s4">import </span><span class="s1">issparse</span><span class="s2">, </span><span class="s1">_formats</span><span class="s2">, </span><span class="s1">_spbase</span><span class="s2">, </span><span class="s1">sparray</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_data </span><span class="s4">import </span><span class="s1">_data_matrix</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_sputils </span><span class="s4">import </span><span class="s2">(</span>
    <span class="s1">isshape</span><span class="s2">, </span><span class="s1">upcast_char</span><span class="s2">, </span><span class="s1">getdtype</span><span class="s2">, </span><span class="s1">get_sum_dtype</span><span class="s2">, </span><span class="s1">validateaxis</span><span class="s2">, </span><span class="s1">check_shape</span>
<span class="s2">)</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_sparsetools </span><span class="s4">import </span><span class="s1">dia_matvec</span>


<span class="s4">class </span><span class="s1">_dia_base</span><span class="s2">(</span><span class="s1">_data_matrix</span><span class="s2">):</span>
    <span class="s1">_format </span><span class="s2">= </span><span class="s3">'dia'</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s1">_data_matrix</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arg1</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">issparse</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">format </span><span class="s2">== </span><span class="s3">&quot;dia&quot;</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">copy</span><span class="s2">:</span>
                    <span class="s1">arg1 </span><span class="s2">= </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">data</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">offsets </span><span class="s2">= </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">offsets</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">format </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s4">and </span><span class="s1">copy</span><span class="s2">:</span>
                    <span class="s1">A </span><span class="s2">= </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">A </span><span class="s2">= </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">todia</span><span class="s2">()</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">data</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">offsets </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">offsets</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">isshape</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">):</span>
                <span class="s5"># It's a tuple of matrix dimensions (M, N)</span>
                <span class="s5"># create empty matrix</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s6">0</span><span class="s2">,</span><span class="s6">0</span><span class="s2">), </span><span class="s1">getdtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">default</span><span class="s2">=</span><span class="s1">float</span><span class="s2">))</span>
                <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">(</span><span class="s1">maxval</span><span class="s2">=</span><span class="s1">max</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">))</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">offsets </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s6">0</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">try</span><span class="s2">:</span>
                    <span class="s5"># Try interpreting it as (data, offsets)</span>
                    <span class="s1">data</span><span class="s2">, </span><span class="s1">offsets </span><span class="s2">= </span><span class="s1">arg1</span>
                <span class="s4">except </span><span class="s1">Exception </span><span class="s4">as </span><span class="s1">e</span><span class="s2">:</span>
                    <span class="s1">message </span><span class="s2">= </span><span class="s3">'unrecognized form for dia_array constructor'</span>
                    <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">message</span><span class="s2">) </span><span class="s4">from </span><span class="s1">e</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s4">if </span><span class="s1">shape </span><span class="s4">is None</span><span class="s2">:</span>
                        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'expected a shape argument'</span><span class="s2">)</span>
                    <span class="s4">if not </span><span class="s1">copy</span><span class="s2">:</span>
                        <span class="s1">copy </span><span class="s2">= </span><span class="s1">copy_if_needed</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_2d</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">))</span>
                    <span class="s1">offsets </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">[</span><span class="s6">1</span><span class="s2">],</span>
                                       <span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">(</span><span class="s1">maxval</span><span class="s2">=</span><span class="s1">max</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)),</span>
                                       <span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">offsets </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">offsets</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5"># must be dense, convert to COO first, then to DIA</span>
            <span class="s4">try</span><span class="s2">:</span>
                <span class="s1">arg1 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">)</span>
            <span class="s4">except </span><span class="s1">Exception </span><span class="s4">as </span><span class="s1">e</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;unrecognized form for&quot;</span>
                        <span class="s3">&quot; %s_matrix constructor&quot; </span><span class="s2">% </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">) </span><span class="s4">from </span><span class="s1">e</span>
            <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">) </span><span class="s4">and </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s6">2</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f&quot;DIA arrays don't support </span><span class="s4">{</span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">ndim</span><span class="s4">}</span><span class="s3">D input. Use 2D&quot;</span><span class="s2">)</span>
            <span class="s1">A </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_coo_container</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">shape</span><span class="s2">).</span><span class="s1">todia</span><span class="s2">()</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">data</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">offsets </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">offsets</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">A</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">dtype </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s5"># check format</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'offsets array must have rank 1'</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'data array must have rank 2'</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'number of diagonals (%d) '</span>
                    <span class="s3">'does not match the number of offsets (%d)'</span>
                    <span class="s2">% (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">)))</span>

        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">unique</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">)) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'offset array contains duplicate values'</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">__repr__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">fmt </span><span class="s2">= </span><span class="s1">_formats</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">]</span>
        <span class="s1">sparse_cls </span><span class="s2">= </span><span class="s3">'array' </span><span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">) </span><span class="s4">else </span><span class="s3">'matrix'</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s4">return </span><span class="s2">(</span>
            <span class="s3">f&quot;&lt;</span><span class="s4">{</span><span class="s1">fmt</span><span class="s4">} </span><span class="s3">sparse </span><span class="s4">{</span><span class="s1">sparse_cls</span><span class="s4">} </span><span class="s3">of dtype '</span><span class="s4">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s4">}</span><span class="s3">'</span><span class="s4">\n</span><span class="s3">&quot;</span>
            <span class="s3">f&quot;</span><span class="s4">\t</span><span class="s3">with </span><span class="s4">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz</span><span class="s4">} </span><span class="s3">stored elements (</span><span class="s4">{</span><span class="s1">d</span><span class="s4">} </span><span class="s3">diagonals) and shape </span><span class="s4">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s4">}</span><span class="s3">&gt;&quot;</span>
        <span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_data_mask</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Returns a mask of the same shape as self.data, where 
        mask[i,j] is True when data[i,j] corresponds to a stored element.&quot;&quot;&quot;</span>
        <span class="s1">num_rows</span><span class="s2">, </span><span class="s1">num_cols </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s1">offset_inds </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">])</span>
        <span class="s1">row </span><span class="s2">= </span><span class="s1">offset_inds </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">[:,</span><span class="s4">None</span><span class="s2">]</span>
        <span class="s1">mask </span><span class="s2">= (</span><span class="s1">row </span><span class="s2">&gt;= </span><span class="s6">0</span><span class="s2">)</span>
        <span class="s1">mask </span><span class="s2">&amp;= (</span><span class="s1">row </span><span class="s2">&lt; </span><span class="s1">num_rows</span><span class="s2">)</span>
        <span class="s1">mask </span><span class="s2">&amp;= (</span><span class="s1">offset_inds </span><span class="s2">&lt; </span><span class="s1">num_cols</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">mask</span>

    <span class="s4">def </span><span class="s1">count_nonzero</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data_mask</span><span class="s2">()</span>
        <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">count_nonzero</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">])</span>

    <span class="s4">def </span><span class="s1">_getnnz</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">axis </span><span class="s4">is not None</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s3">&quot;_getnnz over an axis is not implemented &quot;</span>
                                      <span class="s3">&quot;for DIA format&quot;</span><span class="s2">)</span>
        <span class="s1">M</span><span class="s2">,</span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s1">nnz </span><span class="s2">= </span><span class="s6">0</span>
        <span class="s4">for </span><span class="s1">k </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">k </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s1">nnz </span><span class="s2">+= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">M</span><span class="s2">,</span><span class="s1">N</span><span class="s2">-</span><span class="s1">k</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">nnz </span><span class="s2">+= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">M</span><span class="s2">+</span><span class="s1">k</span><span class="s2">,</span><span class="s1">N</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">int</span><span class="s2">(</span><span class="s1">nnz</span><span class="s2">)</span>

    <span class="s1">_getnnz</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">_getnnz</span><span class="s2">.</span><span class="s1">__doc__</span>
    <span class="s1">count_nonzero</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">count_nonzero</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s1">validateaxis</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">axis </span><span class="s4">is not None and </span><span class="s1">axis </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">axis </span><span class="s2">+= </span><span class="s6">2</span>

        <span class="s1">res_dtype </span><span class="s2">= </span><span class="s1">get_sum_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">num_rows</span><span class="s2">, </span><span class="s1">num_cols </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s1">ret </span><span class="s2">= </span><span class="s4">None</span>

        <span class="s4">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_data_mask</span><span class="s2">()</span>
            <span class="s1">x </span><span class="s2">= (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">* </span><span class="s1">mask</span><span class="s2">).</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s6">0</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] == </span><span class="s1">num_cols</span><span class="s2">:</span>
                <span class="s1">res </span><span class="s2">= </span><span class="s1">x</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">res </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">num_cols</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
                <span class="s1">res</span><span class="s2">[:</span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]] = </span><span class="s1">x</span>
            <span class="s1">ret </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ascontainer</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">res_dtype</span><span class="s2">)</span>

        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">row_sums </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">num_rows</span><span class="s2">, </span><span class="s6">1</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">res_dtype</span><span class="s2">)</span>
            <span class="s1">one </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">num_cols</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">res_dtype</span><span class="s2">)</span>
            <span class="s1">dia_matvec</span><span class="s2">(</span><span class="s1">num_rows</span><span class="s2">, </span><span class="s1">num_cols</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">),</span>
                       <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">], </span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">one</span><span class="s2">, </span><span class="s1">row_sums</span><span class="s2">)</span>

            <span class="s1">row_sums </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ascontainer</span><span class="s2">(</span><span class="s1">row_sums</span><span class="s2">)</span>

            <span class="s4">if </span><span class="s1">axis </span><span class="s4">is None</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">row_sums</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">out</span><span class="s2">)</span>

            <span class="s1">ret </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ascontainer</span><span class="s2">(</span><span class="s1">row_sums</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">))</span>

        <span class="s4">if </span><span class="s1">out </span><span class="s4">is not None and </span><span class="s1">out</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">ret</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;dimensions do not match&quot;</span><span class="s2">)</span>

        <span class="s4">return </span><span class="s1">ret</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=(), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">out</span><span class="s2">)</span>

    <span class="s1">sum</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">_add_sparse</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s5"># If other is not DIA format, let them handle us instead.</span>
        <span class="s4">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">_dia_base</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">other</span><span class="s2">.</span><span class="s1">_add_sparse</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>

        <span class="s5"># Fast path for exact equality of the sparsity structure.</span>
        <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array_equal</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_with_data</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">+ </span><span class="s1">other</span><span class="s2">.</span><span class="s1">data</span><span class="s2">)</span>

        <span class="s5"># Find the union of the offsets (which will be sorted and unique).</span>
        <span class="s1">new_offsets </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">union1d</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">)</span>
        <span class="s1">self_idx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">searchsorted</span><span class="s2">(</span><span class="s1">new_offsets</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">)</span>
        <span class="s1">other_idx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">searchsorted</span><span class="s2">(</span><span class="s1">new_offsets</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">)</span>

        <span class="s1">self_d </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]</span>
        <span class="s1">other_d </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]</span>
        <span class="s5"># Fast path for a sparsity structure where the final offsets are a</span>
        <span class="s5"># permutation of the existing offsets and the diagonal lengths match.</span>
        <span class="s4">if </span><span class="s1">self_d </span><span class="s2">== </span><span class="s1">other_d </span><span class="s4">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">new_offsets</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">):</span>
            <span class="s1">new_data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">_invert_index</span><span class="s2">(</span><span class="s1">self_idx</span><span class="s2">)]</span>
            <span class="s1">new_data</span><span class="s2">[</span><span class="s1">other_idx</span><span class="s2">, :] += </span><span class="s1">other</span><span class="s2">.</span><span class="s1">data</span>
        <span class="s4">elif </span><span class="s1">self_d </span><span class="s2">== </span><span class="s1">other_d </span><span class="s4">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">new_offsets</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">):</span>
            <span class="s1">new_data </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">_invert_index</span><span class="s2">(</span><span class="s1">other_idx</span><span class="s2">)]</span>
            <span class="s1">new_data</span><span class="s2">[</span><span class="s1">self_idx</span><span class="s2">, :] += </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s5"># Maximum diagonal length of the result.</span>
            <span class="s1">d </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] + </span><span class="s1">new_offsets</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">], </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">])</span>

            <span class="s5"># Add all diagonals to a freshly-allocated data array.</span>
            <span class="s1">new_data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span>
                <span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">new_offsets</span><span class="s2">), </span><span class="s1">d</span><span class="s2">),</span>
                <span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">result_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">data</span><span class="s2">),</span>
            <span class="s2">)</span>
            <span class="s1">new_data</span><span class="s2">[</span><span class="s1">self_idx</span><span class="s2">, :</span><span class="s1">self_d</span><span class="s2">] += </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[:, :</span><span class="s1">d</span><span class="s2">]</span>
            <span class="s1">new_data</span><span class="s2">[</span><span class="s1">other_idx</span><span class="s2">, :</span><span class="s1">other_d</span><span class="s2">] += </span><span class="s1">other</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[:, :</span><span class="s1">d</span><span class="s2">]</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dia_container</span><span class="s2">((</span><span class="s1">new_data</span><span class="s2">, </span><span class="s1">new_offsets</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_mul_scalar</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_with_data</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">* </span><span class="s1">other</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">_matmul_vector</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">other</span>

        <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">upcast_char</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">,</span>
                                                       <span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">))</span>

        <span class="s1">L </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]</span>

        <span class="s1">M</span><span class="s2">,</span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>

        <span class="s1">dia_matvec</span><span class="s2">(</span><span class="s1">M</span><span class="s2">,</span><span class="s1">N</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">), </span><span class="s1">L</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">,</span>
                   <span class="s1">x</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">(), </span><span class="s1">y</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">())</span>

        <span class="s4">return </span><span class="s1">y</span>

    <span class="s4">def </span><span class="s1">_setdiag</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s6">0</span><span class="s2">):</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>

        <span class="s4">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s5"># broadcast</span>
            <span class="s1">values_n </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">values_n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">values</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">k </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">n </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">M </span><span class="s2">+ </span><span class="s1">k</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">values_n</span><span class="s2">)</span>
            <span class="s1">min_index </span><span class="s2">= </span><span class="s6">0</span>
            <span class="s1">max_index </span><span class="s2">= </span><span class="s1">n</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">n </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">- </span><span class="s1">k</span><span class="s2">, </span><span class="s1">values_n</span><span class="s2">)</span>
            <span class="s1">min_index </span><span class="s2">= </span><span class="s1">k</span>
            <span class="s1">max_index </span><span class="s2">= </span><span class="s1">k </span><span class="s2">+ </span><span class="s1">n</span>

        <span class="s4">if </span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s5"># allow also longer sequences</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">[:</span><span class="s1">n</span><span class="s2">]</span>

        <span class="s1">data_rows</span><span class="s2">, </span><span class="s1">data_cols </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s4">if </span><span class="s1">k </span><span class="s4">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">max_index </span><span class="s2">&gt; </span><span class="s1">data_cols</span><span class="s2">:</span>
                <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">data_rows</span><span class="s2">, </span><span class="s1">max_index</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
                <span class="s1">data</span><span class="s2">[:, :</span><span class="s1">data_cols</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">data</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets </span><span class="s2">== </span><span class="s1">k</span><span class="s2">, </span><span class="s1">min_index</span><span class="s2">:</span><span class="s1">max_index</span><span class="s2">] = </span><span class="s1">values</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">offsets </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">(</span><span class="s1">k</span><span class="s2">))</span>
            <span class="s1">m </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">max_index</span><span class="s2">, </span><span class="s1">data_cols</span><span class="s2">)</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">data_rows </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">, </span><span class="s1">m</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">data</span><span class="s2">[:-</span><span class="s6">1</span><span class="s2">, :</span><span class="s1">data_cols</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>
            <span class="s1">data</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">, </span><span class="s1">min_index</span><span class="s2">:</span><span class="s1">max_index</span><span class="s2">] = </span><span class="s1">values</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">data</span>

    <span class="s4">def </span><span class="s1">todia</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">copy</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span>

    <span class="s1">todia</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">todia</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">transpose</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">axes </span><span class="s4">is not None and </span><span class="s1">axes </span><span class="s2">!= (</span><span class="s6">1</span><span class="s2">, </span><span class="s6">0</span><span class="s2">):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Sparse arrays/matrices do not support &quot;</span>
                              <span class="s3">&quot;an 'axes' parameter because swapping &quot;</span>
                              <span class="s3">&quot;dimensions is the only logical permutation.&quot;</span><span class="s2">)</span>

        <span class="s1">num_rows</span><span class="s2">, </span><span class="s1">num_cols </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s1">max_dim </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>

        <span class="s5"># flip diagonal offsets</span>
        <span class="s1">offsets </span><span class="s2">= -</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span>

        <span class="s5"># re-align the data matrix</span>
        <span class="s1">r </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">offsets</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intc</span><span class="s2">)[:, </span><span class="s4">None</span><span class="s2">]</span>
        <span class="s1">c </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">num_rows</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">intc</span><span class="s2">) - (</span><span class="s1">offsets </span><span class="s2">% </span><span class="s1">max_dim</span><span class="s2">)[:, </span><span class="s4">None</span><span class="s2">]</span>
        <span class="s1">pad_amount </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">max_dim</span><span class="s2">-</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">])</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">hstack</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">pad_amount</span><span class="s2">),</span>
                                              <span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)))</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">data</span><span class="s2">[</span><span class="s1">r</span><span class="s2">, </span><span class="s1">c</span><span class="s2">]</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dia_container</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=(</span>
            <span class="s1">num_cols</span><span class="s2">, </span><span class="s1">num_rows</span><span class="s2">), </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>

    <span class="s1">transpose</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">transpose</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">diagonal</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s6">0</span><span class="s2">):</span>
        <span class="s1">rows</span><span class="s2">, </span><span class="s1">cols </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s4">if </span><span class="s1">k </span><span class="s2">&lt;= -</span><span class="s1">rows </span><span class="s4">or </span><span class="s1">k </span><span class="s2">&gt;= </span><span class="s1">cols</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">idx</span><span class="s2">, = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets </span><span class="s2">== </span><span class="s1">k</span><span class="s2">)</span>
        <span class="s1">first_col </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">k</span><span class="s2">)</span>
        <span class="s1">last_col </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">rows </span><span class="s2">+ </span><span class="s1">k</span><span class="s2">, </span><span class="s1">cols</span><span class="s2">)</span>
        <span class="s1">result_size </span><span class="s2">= </span><span class="s1">last_col </span><span class="s2">- </span><span class="s1">first_col</span>
        <span class="s4">if </span><span class="s1">idx</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">result_size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">first_col</span><span class="s2">:</span><span class="s1">last_col</span><span class="s2">]</span>
        <span class="s1">padding </span><span class="s2">= </span><span class="s1">result_size </span><span class="s2">- </span><span class="s1">len</span><span class="s2">(</span><span class="s1">result</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">padding </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pad</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, (</span><span class="s6">0</span><span class="s2">, </span><span class="s1">padding</span><span class="s2">), </span><span class="s1">mode</span><span class="s2">=</span><span class="s3">'constant'</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">result</span>

    <span class="s1">diagonal</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">diagonal</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">tocsc</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_csc_container</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s1">num_rows</span><span class="s2">, </span><span class="s1">num_cols </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s1">num_offsets</span><span class="s2">, </span><span class="s1">offset_len </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s1">offset_inds </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">offset_len</span><span class="s2">)</span>

        <span class="s1">row </span><span class="s2">= </span><span class="s1">offset_inds </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">[:,</span><span class="s4">None</span><span class="s2">]</span>
        <span class="s1">mask </span><span class="s2">= (</span><span class="s1">row </span><span class="s2">&gt;= </span><span class="s6">0</span><span class="s2">)</span>
        <span class="s1">mask </span><span class="s2">&amp;= (</span><span class="s1">row </span><span class="s2">&lt; </span><span class="s1">num_rows</span><span class="s2">)</span>
        <span class="s1">mask </span><span class="s2">&amp;= (</span><span class="s1">offset_inds </span><span class="s2">&lt; </span><span class="s1">num_cols</span><span class="s2">)</span>
        <span class="s1">mask </span><span class="s2">&amp;= (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">!= </span><span class="s6">0</span><span class="s2">)</span>

        <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">(</span><span class="s1">maxval</span><span class="s2">=</span><span class="s1">max</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">))</span>
        <span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">num_cols </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">indptr</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:</span><span class="s1">offset_len</span><span class="s2">+</span><span class="s6">1</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">mask</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=</span><span class="s6">0</span><span class="s2">)[:</span><span class="s1">num_cols</span><span class="s2">])</span>
        <span class="s4">if </span><span class="s1">offset_len </span><span class="s2">&lt; </span><span class="s1">num_cols</span><span class="s2">:</span>
            <span class="s1">indptr</span><span class="s2">[</span><span class="s1">offset_len</span><span class="s2">+</span><span class="s6">1</span><span class="s2">:] = </span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">offset_len</span><span class="s2">]</span>
        <span class="s1">indices </span><span class="s2">= </span><span class="s1">row</span><span class="s2">.</span><span class="s1">T</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">.</span><span class="s1">T</span><span class="s2">].</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">idx_dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">T</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">.</span><span class="s1">T</span><span class="s2">]</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_csc_container</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">,</span>
                                   <span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s1">tocsc</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">tocsc</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">def </span><span class="s1">tocoo</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s1">num_rows</span><span class="s2">, </span><span class="s1">num_cols </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s1">num_offsets</span><span class="s2">, </span><span class="s1">offset_len </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s1">offset_inds </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">offset_len</span><span class="s2">)</span>

        <span class="s1">row </span><span class="s2">= </span><span class="s1">offset_inds </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">[:,</span><span class="s4">None</span><span class="s2">]</span>
        <span class="s1">mask </span><span class="s2">= (</span><span class="s1">row </span><span class="s2">&gt;= </span><span class="s6">0</span><span class="s2">)</span>
        <span class="s1">mask </span><span class="s2">&amp;= (</span><span class="s1">row </span><span class="s2">&lt; </span><span class="s1">num_rows</span><span class="s2">)</span>
        <span class="s1">mask </span><span class="s2">&amp;= (</span><span class="s1">offset_inds </span><span class="s2">&lt; </span><span class="s1">num_cols</span><span class="s2">)</span>
        <span class="s1">mask </span><span class="s2">&amp;= (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">!= </span><span class="s6">0</span><span class="s2">)</span>
        <span class="s1">row </span><span class="s2">= </span><span class="s1">row</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]</span>
        <span class="s1">col </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">tile</span><span class="s2">(</span><span class="s1">offset_inds</span><span class="s2">, </span><span class="s1">num_offsets</span><span class="s2">)[</span><span class="s1">mask</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">()]</span>
        <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">(</span>
            <span class="s1">arrays</span><span class="s2">=(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">,), </span><span class="s1">maxval</span><span class="s2">=</span><span class="s1">max</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s1">row </span><span class="s2">= </span><span class="s1">row</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">idx_dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>
        <span class="s1">col </span><span class="s2">= </span><span class="s1">col</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">idx_dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]</span>
        <span class="s5"># Note: this cannot set has_canonical_format=True, because despite the</span>
        <span class="s5"># lack of duplicates, we do not generate sorted indices.</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_coo_container</span><span class="s2">(</span>
            <span class="s2">(</span><span class="s1">data</span><span class="s2">, (</span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">)), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">False</span>
        <span class="s2">)</span>

    <span class="s1">tocoo</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">tocoo</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s5"># needed by _data_matrix</span>
    <span class="s4">def </span><span class="s1">_with_data</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">True</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Returns a matrix with the same sparsity structure as self, 
        but with different data.  By default the structure arrays are copied. 
        &quot;&quot;&quot;</span>
        <span class="s4">if </span><span class="s1">copy</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dia_container</span><span class="s2">(</span>
                <span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
            <span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_dia_container</span><span class="s2">(</span>
                <span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
            <span class="s2">)</span>

    <span class="s4">def </span><span class="s1">resize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">shape</span><span class="s2">):</span>
        <span class="s1">shape </span><span class="s2">= </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">shape</span>
        <span class="s5"># we do not need to handle the case of expanding N</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[:, :</span><span class="s1">N</span><span class="s2">]</span>

        <span class="s4">if </span><span class="s2">(</span><span class="s1">M </span><span class="s2">&gt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] </span><span class="s4">and</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] &lt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">])):</span>
            <span class="s5"># explicitly clear values that were previously hidden</span>
            <span class="s1">mask </span><span class="s2">= (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">offsets</span><span class="s2">[:, </span><span class="s4">None</span><span class="s2">] + </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] &lt;=</span>
                    <span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]))</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">] = </span><span class="s6">0</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">shape</span>

    <span class="s1">resize</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">resize</span><span class="s2">.</span><span class="s1">__doc__</span>


<span class="s4">def </span><span class="s1">_invert_index</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Helper function to invert an index array.&quot;&quot;&quot;</span>
    <span class="s1">inv </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">)</span>
    <span class="s1">inv</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">))</span>
    <span class="s4">return </span><span class="s1">inv</span>


<span class="s4">def </span><span class="s1">isspmatrix_dia</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;Is `x` of dia_matrix type? 
 
    Parameters 
    ---------- 
    x 
        object to check for being a dia matrix 
 
    Returns 
    ------- 
    bool 
        True if `x` is a dia matrix, False otherwise 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import dia_array, dia_matrix, coo_matrix, isspmatrix_dia 
    &gt;&gt;&gt; isspmatrix_dia(dia_matrix([[5]])) 
    True 
    &gt;&gt;&gt; isspmatrix_dia(dia_array([[5]])) 
    False 
    &gt;&gt;&gt; isspmatrix_dia(coo_matrix([[5]])) 
    False 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">dia_matrix</span><span class="s2">)</span>


<span class="s5"># This namespace class separates array from matrix with isinstance</span>
<span class="s4">class </span><span class="s1">dia_array</span><span class="s2">(</span><span class="s1">_dia_base</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Sparse array with DIAgonal storage. 
 
    This can be instantiated in several ways: 
        dia_array(D) 
            where D is a 2-D ndarray 
 
        dia_array(S) 
            with another sparse array or matrix S (equivalent to S.todia()) 
 
        dia_array((M, N), [dtype]) 
            to construct an empty array with shape (M, N), 
            dtype is optional, defaulting to dtype='d'. 
 
        dia_array((data, offsets), shape=(M, N)) 
            where the ``data[k,:]`` stores the diagonal entries for 
            diagonal ``offsets[k]`` (See example below) 
 
    Attributes 
    ---------- 
    dtype : dtype 
        Data type of the array 
    shape : 2-tuple 
        Shape of the array 
    ndim : int 
        Number of dimensions (this is always 2) 
    nnz 
    size 
    data 
        DIA format data array of the array 
    offsets 
        DIA format offset array of the array 
    T 
 
    Notes 
    ----- 
 
    Sparse arrays can be used in arithmetic operations: they support 
    addition, subtraction, multiplication, division, and matrix power. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import dia_array 
    &gt;&gt;&gt; dia_array((3, 4), dtype=np.int8).toarray() 
    array([[0, 0, 0, 0], 
           [0, 0, 0, 0], 
           [0, 0, 0, 0]], dtype=int8) 
 
    &gt;&gt;&gt; data = np.array([[1, 2, 3, 4]]).repeat(3, axis=0) 
    &gt;&gt;&gt; offsets = np.array([0, -1, 2]) 
    &gt;&gt;&gt; dia_array((data, offsets), shape=(4, 4)).toarray() 
    array([[1, 0, 3, 0], 
           [1, 2, 0, 4], 
           [0, 2, 3, 0], 
           [0, 0, 3, 4]]) 
 
    &gt;&gt;&gt; from scipy.sparse import dia_array 
    &gt;&gt;&gt; n = 10 
    &gt;&gt;&gt; ex = np.ones(n) 
    &gt;&gt;&gt; data = np.array([ex, 2 * ex, ex]) 
    &gt;&gt;&gt; offsets = np.array([-1, 0, 1]) 
    &gt;&gt;&gt; dia_array((data, offsets), shape=(n, n)).toarray() 
    array([[2., 1., 0., ..., 0., 0., 0.], 
           [1., 2., 1., ..., 0., 0., 0.], 
           [0., 1., 2., ..., 0., 0., 0.], 
           ..., 
           [0., 0., 0., ..., 2., 1., 0.], 
           [0., 0., 0., ..., 1., 2., 1.], 
           [0., 0., 0., ..., 0., 1., 2.]]) 
    &quot;&quot;&quot;</span>


<span class="s4">class </span><span class="s1">dia_matrix</span><span class="s2">(</span><span class="s1">spmatrix</span><span class="s2">, </span><span class="s1">_dia_base</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Sparse matrix with DIAgonal storage. 
 
    This can be instantiated in several ways: 
        dia_matrix(D) 
            where D is a 2-D ndarray 
 
        dia_matrix(S) 
            with another sparse array or matrix S (equivalent to S.todia()) 
 
        dia_matrix((M, N), [dtype]) 
            to construct an empty matrix with shape (M, N), 
            dtype is optional, defaulting to dtype='d'. 
 
        dia_matrix((data, offsets), shape=(M, N)) 
            where the ``data[k,:]`` stores the diagonal entries for 
            diagonal ``offsets[k]`` (See example below) 
 
    Attributes 
    ---------- 
    dtype : dtype 
        Data type of the matrix 
    shape : 2-tuple 
        Shape of the matrix 
    ndim : int 
        Number of dimensions (this is always 2) 
    nnz 
    size 
    data 
        DIA format data array of the matrix 
    offsets 
        DIA format offset array of the matrix 
    T 
 
    Notes 
    ----- 
 
    Sparse matrices can be used in arithmetic operations: they support 
    addition, subtraction, multiplication, division, and matrix power. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import dia_matrix 
    &gt;&gt;&gt; dia_matrix((3, 4), dtype=np.int8).toarray() 
    array([[0, 0, 0, 0], 
           [0, 0, 0, 0], 
           [0, 0, 0, 0]], dtype=int8) 
 
    &gt;&gt;&gt; data = np.array([[1, 2, 3, 4]]).repeat(3, axis=0) 
    &gt;&gt;&gt; offsets = np.array([0, -1, 2]) 
    &gt;&gt;&gt; dia_matrix((data, offsets), shape=(4, 4)).toarray() 
    array([[1, 0, 3, 0], 
           [1, 2, 0, 4], 
           [0, 2, 3, 0], 
           [0, 0, 3, 4]]) 
 
    &gt;&gt;&gt; from scipy.sparse import dia_matrix 
    &gt;&gt;&gt; n = 10 
    &gt;&gt;&gt; ex = np.ones(n) 
    &gt;&gt;&gt; data = np.array([ex, 2 * ex, ex]) 
    &gt;&gt;&gt; offsets = np.array([-1, 0, 1]) 
    &gt;&gt;&gt; dia_matrix((data, offsets), shape=(n, n)).toarray() 
    array([[2., 1., 0., ..., 0., 0., 0.], 
           [1., 2., 1., ..., 0., 0., 0.], 
           [0., 1., 2., ..., 0., 0., 0.], 
           ..., 
           [0., 0., 0., ..., 2., 1., 0.], 
           [0., 0., 0., ..., 1., 2., 1.], 
           [0., 0., 0., ..., 0., 1., 2.]]) 
    &quot;&quot;&quot;</span>
</pre>
</body>
</html>