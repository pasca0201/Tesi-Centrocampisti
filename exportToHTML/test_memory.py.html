<html>
<head>
<title>test_memory.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_memory.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Test the memory module. 
&quot;&quot;&quot;</span>

<span class="s2"># Author: Gael Varoquaux &lt;gael dot varoquaux at normalesup dot org&gt;</span>
<span class="s2"># Copyright (c) 2009 Gael Varoquaux</span>
<span class="s2"># License: BSD Style, 3 clauses.</span>

<span class="s3">import </span><span class="s1">functools</span>
<span class="s3">import </span><span class="s1">gc</span>
<span class="s3">import </span><span class="s1">logging</span>
<span class="s3">import </span><span class="s1">shutil</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span>
<span class="s3">import </span><span class="s1">pathlib</span>
<span class="s3">import </span><span class="s1">pickle</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">time</span>
<span class="s3">import </span><span class="s1">datetime</span>
<span class="s3">import </span><span class="s1">textwrap</span>

<span class="s3">import </span><span class="s1">pytest</span>

<span class="s3">from </span><span class="s1">joblib</span><span class="s4">.</span><span class="s1">memory </span><span class="s3">import </span><span class="s1">Memory</span>
<span class="s3">from </span><span class="s1">joblib</span><span class="s4">.</span><span class="s1">memory </span><span class="s3">import </span><span class="s1">expires_after</span>
<span class="s3">from </span><span class="s1">joblib</span><span class="s4">.</span><span class="s1">memory </span><span class="s3">import </span><span class="s1">MemorizedFunc</span><span class="s4">, </span><span class="s1">NotMemorizedFunc</span>
<span class="s3">from </span><span class="s1">joblib</span><span class="s4">.</span><span class="s1">memory </span><span class="s3">import </span><span class="s1">MemorizedResult</span><span class="s4">, </span><span class="s1">NotMemorizedResult</span>
<span class="s3">from </span><span class="s1">joblib</span><span class="s4">.</span><span class="s1">memory </span><span class="s3">import </span><span class="s1">_FUNCTION_HASHES</span>
<span class="s3">from </span><span class="s1">joblib</span><span class="s4">.</span><span class="s1">memory </span><span class="s3">import </span><span class="s1">register_store_backend</span><span class="s4">, </span><span class="s1">_STORE_BACKENDS</span>
<span class="s3">from </span><span class="s1">joblib</span><span class="s4">.</span><span class="s1">memory </span><span class="s3">import </span><span class="s1">_build_func_identifier</span><span class="s4">, </span><span class="s1">_store_backend_factory</span>
<span class="s3">from </span><span class="s1">joblib</span><span class="s4">.</span><span class="s1">memory </span><span class="s3">import </span><span class="s1">JobLibCollisionWarning</span>
<span class="s3">from </span><span class="s1">joblib</span><span class="s4">.</span><span class="s1">parallel </span><span class="s3">import </span><span class="s1">Parallel</span><span class="s4">, </span><span class="s1">delayed</span>
<span class="s3">from </span><span class="s1">joblib</span><span class="s4">.</span><span class="s1">_store_backends </span><span class="s3">import </span><span class="s1">StoreBackendBase</span><span class="s4">, </span><span class="s1">FileSystemStoreBackend</span>
<span class="s3">from </span><span class="s1">joblib</span><span class="s4">.</span><span class="s1">test</span><span class="s4">.</span><span class="s1">common </span><span class="s3">import </span><span class="s1">with_numpy</span><span class="s4">, </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">joblib</span><span class="s4">.</span><span class="s1">test</span><span class="s4">.</span><span class="s1">common </span><span class="s3">import </span><span class="s1">with_multiprocessing</span>
<span class="s3">from </span><span class="s1">joblib</span><span class="s4">.</span><span class="s1">testing </span><span class="s3">import </span><span class="s1">parametrize</span><span class="s4">, </span><span class="s1">raises</span><span class="s4">, </span><span class="s1">warns</span>
<span class="s3">from </span><span class="s1">joblib</span><span class="s4">.</span><span class="s1">hashing </span><span class="s3">import </span><span class="s1">hash</span>


<span class="s2">###############################################################################</span>
<span class="s2"># Module-level variables for the tests</span>
<span class="s3">def </span><span class="s1">f</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s5">1</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; A module-level function for testing purposes. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">x </span><span class="s4">** </span><span class="s5">2 </span><span class="s4">+ </span><span class="s1">y</span>


<span class="s2">###############################################################################</span>
<span class="s2"># Helper function for the tests</span>
<span class="s3">def </span><span class="s1">check_identity_lazy</span><span class="s4">(</span><span class="s1">func</span><span class="s4">, </span><span class="s1">accumulator</span><span class="s4">, </span><span class="s1">location</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; Given a function and an accumulator (a list that grows every 
        time the function is called), check that the function can be 
        decorated by memory to be a lazy identity. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Call each function with several arguments, and check that it is</span>
    <span class="s2"># evaluated only once per argument.</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">location</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">func </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">func</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s5">3</span><span class="s4">):</span>
        <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s5">2</span><span class="s4">):</span>
            <span class="s3">assert </span><span class="s1">func</span><span class="s4">(</span><span class="s1">i</span><span class="s4">) == </span><span class="s1">i</span>
            <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">accumulator</span><span class="s4">) == </span><span class="s1">i </span><span class="s4">+ </span><span class="s5">1</span>


<span class="s3">def </span><span class="s1">corrupt_single_cache_item</span><span class="s4">(</span><span class="s1">memory</span><span class="s4">):</span>
    <span class="s1">single_cache_item</span><span class="s4">, = </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>
    <span class="s1">output_filename </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">single_cache_item</span><span class="s4">.</span><span class="s1">path</span><span class="s4">, </span><span class="s6">'output.pkl'</span><span class="s4">)</span>
    <span class="s3">with </span><span class="s1">open</span><span class="s4">(</span><span class="s1">output_filename</span><span class="s4">, </span><span class="s6">'w'</span><span class="s4">) </span><span class="s3">as </span><span class="s1">f</span><span class="s4">:</span>
        <span class="s1">f</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s6">'garbage'</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">monkeypatch_cached_func_warn</span><span class="s4">(</span><span class="s1">func</span><span class="s4">, </span><span class="s1">monkeypatch_fixture</span><span class="s4">):</span>
    <span class="s2"># Need monkeypatch because pytest does not</span>
    <span class="s2"># capture stdlib logging output (see</span>
    <span class="s2"># https://github.com/pytest-dev/pytest/issues/2079)</span>

    <span class="s1">recorded </span><span class="s4">= []</span>

    <span class="s3">def </span><span class="s1">append_to_record</span><span class="s4">(</span><span class="s1">item</span><span class="s4">):</span>
        <span class="s1">recorded</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">item</span><span class="s4">)</span>
    <span class="s1">monkeypatch_fixture</span><span class="s4">.</span><span class="s1">setattr</span><span class="s4">(</span><span class="s1">func</span><span class="s4">, </span><span class="s6">'warn'</span><span class="s4">, </span><span class="s1">append_to_record</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">recorded</span>


<span class="s2">###############################################################################</span>
<span class="s2"># Tests</span>
<span class="s3">def </span><span class="s1">test_memory_integration</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; Simple test of memory lazy evaluation. 
    &quot;&quot;&quot;</span>
    <span class="s1">accumulator </span><span class="s4">= </span><span class="s1">list</span><span class="s4">()</span>

    <span class="s2"># Rmk: this function has the same name than a module-level function,</span>
    <span class="s2"># thus it serves as a test to see that both are identified</span>
    <span class="s2"># as different.</span>
    <span class="s3">def </span><span class="s1">f</span><span class="s4">(</span><span class="s1">arg</span><span class="s4">):</span>
        <span class="s1">accumulator</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">arg</span>

    <span class="s1">check_identity_lazy</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">accumulator</span><span class="s4">, </span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">)</span>

    <span class="s2"># Now test clearing</span>
    <span class="s3">for </span><span class="s1">compress </span><span class="s3">in </span><span class="s4">(</span><span class="s3">False</span><span class="s4">, </span><span class="s3">True</span><span class="s4">):</span>
        <span class="s3">for </span><span class="s1">mmap_mode </span><span class="s3">in </span><span class="s4">(</span><span class="s6">'r'</span><span class="s4">, </span><span class="s3">None</span><span class="s4">):</span>
            <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">10</span><span class="s4">,</span>
                            <span class="s1">mmap_mode</span><span class="s4">=</span><span class="s1">mmap_mode</span><span class="s4">, </span><span class="s1">compress</span><span class="s4">=</span><span class="s1">compress</span><span class="s4">)</span>
            <span class="s2"># First clear the cache directory, to check that our code can</span>
            <span class="s2"># handle that</span>
            <span class="s2"># NOTE: this line would raise an exception, as the database file is</span>
            <span class="s2"># still open; we ignore the error since we want to test what</span>
            <span class="s2"># happens if the directory disappears</span>
            <span class="s1">shutil</span><span class="s4">.</span><span class="s1">rmtree</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">ignore_errors</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
            <span class="s1">g </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
            <span class="s1">g</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
            <span class="s1">g</span><span class="s4">.</span><span class="s1">clear</span><span class="s4">(</span><span class="s1">warn</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
            <span class="s1">current_accumulator </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">accumulator</span><span class="s4">)</span>
            <span class="s1">out </span><span class="s4">= </span><span class="s1">g</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>

        <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">accumulator</span><span class="s4">) == </span><span class="s1">current_accumulator </span><span class="s4">+ </span><span class="s5">1</span>
        <span class="s2"># Also, check that Memory.eval works similarly</span>
        <span class="s3">assert </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">eval</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s5">1</span><span class="s4">) == </span><span class="s1">out</span>
        <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">accumulator</span><span class="s4">) == </span><span class="s1">current_accumulator </span><span class="s4">+ </span><span class="s5">1</span>

    <span class="s2"># Now do a smoke test with a function defined in __main__, as the name</span>
    <span class="s2"># mangling rules are more complex</span>
    <span class="s1">f</span><span class="s4">.</span><span class="s1">__module__ </span><span class="s4">= </span><span class="s6">'__main__'</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)(</span><span class="s5">1</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;call_before_reducing&quot;</span><span class="s4">, [</span><span class="s3">True</span><span class="s4">, </span><span class="s3">False</span><span class="s4">])</span>
<span class="s3">def </span><span class="s1">test_parallel_call_cached_function_defined_in_jupyter</span><span class="s4">(</span>
    <span class="s1">tmpdir</span><span class="s4">, </span><span class="s1">call_before_reducing</span>
<span class="s4">):</span>
    <span class="s2"># Calling an interactively defined memory.cache()'d function inside a</span>
    <span class="s2"># Parallel call used to clear the existing cache related to the said</span>
    <span class="s2"># function (https://github.com/joblib/joblib/issues/1035)</span>

    <span class="s2"># This tests checks that this is no longer the case.</span>

    <span class="s2"># TODO: test that the cache related to the function cache persists across</span>
    <span class="s2"># ipython sessions (provided that no code change were made to the</span>
    <span class="s2"># function's source)?</span>

    <span class="s2"># The first part of the test makes the necessary low-level calls to emulate</span>
    <span class="s2"># the definition of a function in an jupyter notebook cell. Joblib has</span>
    <span class="s2"># some custom code to treat functions defined specifically in jupyter</span>
    <span class="s2"># notebooks/ipython session -- we want to test this code, which requires</span>
    <span class="s2"># the emulation to be rigorous.</span>
    <span class="s3">for </span><span class="s1">session_no </span><span class="s3">in </span><span class="s4">[</span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">]:</span>
        <span class="s1">ipython_cell_source </span><span class="s4">= </span><span class="s6">''' 
        def f(x): 
            return x 
        '''</span>

        <span class="s1">ipython_cell_id </span><span class="s4">= </span><span class="s6">'&lt;ipython-input-{}-000000000000&gt;'</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">session_no</span><span class="s4">)</span>

        <span class="s1">exec</span><span class="s4">(</span>
            <span class="s1">compile</span><span class="s4">(</span>
                <span class="s1">textwrap</span><span class="s4">.</span><span class="s1">dedent</span><span class="s4">(</span><span class="s1">ipython_cell_source</span><span class="s4">),</span>
                <span class="s1">filename</span><span class="s4">=</span><span class="s1">ipython_cell_id</span><span class="s4">,</span>
                <span class="s1">mode</span><span class="s4">=</span><span class="s6">'exec'</span>
            <span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s2"># f is now accessible in the locals mapping - but for some unknown</span>
        <span class="s2"># reason, f = locals()['f'] throws a KeyError at runtime, we need to</span>
        <span class="s2"># bind locals()['f'] to a different name in the local namespace</span>
        <span class="s1">aliased_f </span><span class="s4">= </span><span class="s1">locals</span><span class="s4">()[</span><span class="s6">'f'</span><span class="s4">]</span>
        <span class="s1">aliased_f</span><span class="s4">.</span><span class="s1">__module__ </span><span class="s4">= </span><span class="s6">&quot;__main__&quot;</span>

        <span class="s2"># Preliminary sanity checks, and tests checking that joblib properly</span>
        <span class="s2"># identified f as an interactive function defined in a jupyter notebook</span>
        <span class="s3">assert </span><span class="s1">aliased_f</span><span class="s4">(</span><span class="s5">1</span><span class="s4">) == </span><span class="s5">1</span>
        <span class="s3">assert </span><span class="s1">aliased_f</span><span class="s4">.</span><span class="s1">__code__</span><span class="s4">.</span><span class="s1">co_filename </span><span class="s4">== </span><span class="s1">ipython_cell_id</span>

        <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
        <span class="s1">cached_f </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">aliased_f</span><span class="s4">)</span>

        <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">os</span><span class="s4">.</span><span class="s1">listdir</span><span class="s4">(</span><span class="s1">tmpdir </span><span class="s4">/ </span><span class="s6">'joblib'</span><span class="s4">)) == </span><span class="s5">1</span>
        <span class="s1">f_cache_relative_directory </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">listdir</span><span class="s4">(</span><span class="s1">tmpdir </span><span class="s4">/ </span><span class="s6">'joblib'</span><span class="s4">)[</span><span class="s5">0</span><span class="s4">]</span>
        <span class="s3">assert </span><span class="s6">'ipython-input' </span><span class="s3">in </span><span class="s1">f_cache_relative_directory</span>

        <span class="s1">f_cache_directory </span><span class="s4">= </span><span class="s1">tmpdir </span><span class="s4">/ </span><span class="s6">'joblib' </span><span class="s4">/ </span><span class="s1">f_cache_relative_directory</span>

        <span class="s3">if </span><span class="s1">session_no </span><span class="s4">== </span><span class="s5">0</span><span class="s4">:</span>
            <span class="s2"># The cache should be empty as cached_f has not been called yet.</span>
            <span class="s3">assert </span><span class="s1">os</span><span class="s4">.</span><span class="s1">listdir</span><span class="s4">(</span><span class="s1">f_cache_directory</span><span class="s4">) == [</span><span class="s6">'f'</span><span class="s4">]</span>
            <span class="s3">assert </span><span class="s1">os</span><span class="s4">.</span><span class="s1">listdir</span><span class="s4">(</span><span class="s1">f_cache_directory </span><span class="s4">/ </span><span class="s6">'f'</span><span class="s4">) == []</span>

            <span class="s3">if </span><span class="s1">call_before_reducing</span><span class="s4">:</span>
                <span class="s1">cached_f</span><span class="s4">(</span><span class="s5">3</span><span class="s4">)</span>
                <span class="s2"># Two files were just created, func_code.py, and a folder</span>
                <span class="s2"># containing the information (inputs hash/ouptput) of</span>
                <span class="s2"># cached_f(3)</span>
                <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">os</span><span class="s4">.</span><span class="s1">listdir</span><span class="s4">(</span><span class="s1">f_cache_directory </span><span class="s4">/ </span><span class="s6">'f'</span><span class="s4">)) == </span><span class="s5">2</span>

                <span class="s2"># Now, testing  #1035: when calling a cached function, joblib</span>
                <span class="s2"># used to dynamically inspect the underlying function to</span>
                <span class="s2"># extract its source code (to verify it matches the source code</span>
                <span class="s2"># of the function as last inspected by joblib) -- however,</span>
                <span class="s2"># source code introspection fails for dynamic functions sent to</span>
                <span class="s2"># child processes - which would eventually make joblib clear</span>
                <span class="s2"># the cache associated to f</span>
                <span class="s1">res </span><span class="s4">= </span><span class="s1">Parallel</span><span class="s4">(</span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s5">2</span><span class="s4">)(</span><span class="s1">delayed</span><span class="s4">(</span><span class="s1">cached_f</span><span class="s4">)(</span><span class="s1">i</span><span class="s4">) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s4">[</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">])</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s2"># Submit the function to the joblib child processes, although</span>
                <span class="s2"># the function has never been called in the parent yet. This</span>
                <span class="s2"># triggers a specific code branch inside</span>
                <span class="s2"># MemorizedFunc.__reduce__.</span>
                <span class="s1">res </span><span class="s4">= </span><span class="s1">Parallel</span><span class="s4">(</span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s5">2</span><span class="s4">)(</span><span class="s1">delayed</span><span class="s4">(</span><span class="s1">cached_f</span><span class="s4">)(</span><span class="s1">i</span><span class="s4">) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s4">[</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">])</span>
                <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">os</span><span class="s4">.</span><span class="s1">listdir</span><span class="s4">(</span><span class="s1">f_cache_directory </span><span class="s4">/ </span><span class="s6">'f'</span><span class="s4">)) == </span><span class="s5">3</span>

                <span class="s1">cached_f</span><span class="s4">(</span><span class="s5">3</span><span class="s4">)</span>

            <span class="s2"># Making sure f's cache does not get cleared after the parallel</span>
            <span class="s2"># calls, and contains ALL cached functions calls (f(1), f(2), f(3))</span>
            <span class="s2"># and 'func_code.py'</span>
            <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">os</span><span class="s4">.</span><span class="s1">listdir</span><span class="s4">(</span><span class="s1">f_cache_directory </span><span class="s4">/ </span><span class="s6">'f'</span><span class="s4">)) == </span><span class="s5">4</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># For the second session, there should be an already existing cache</span>
            <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">os</span><span class="s4">.</span><span class="s1">listdir</span><span class="s4">(</span><span class="s1">f_cache_directory </span><span class="s4">/ </span><span class="s6">'f'</span><span class="s4">)) == </span><span class="s5">4</span>

            <span class="s1">cached_f</span><span class="s4">(</span><span class="s5">3</span><span class="s4">)</span>

            <span class="s2"># The previous cache should not be invalidated after calling the</span>
            <span class="s2"># function in a new session</span>
            <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">os</span><span class="s4">.</span><span class="s1">listdir</span><span class="s4">(</span><span class="s1">f_cache_directory </span><span class="s4">/ </span><span class="s6">'f'</span><span class="s4">)) == </span><span class="s5">4</span>


<span class="s3">def </span><span class="s1">test_no_memory</span><span class="s4">():</span>
    <span class="s0">&quot;&quot;&quot; Test memory with location=None: no memoize &quot;&quot;&quot;</span>
    <span class="s1">accumulator </span><span class="s4">= </span><span class="s1">list</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">ff</span><span class="s4">(</span><span class="s1">arg</span><span class="s4">):</span>
        <span class="s1">accumulator</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">arg</span>

    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">gg </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">ff</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s5">4</span><span class="s4">):</span>
        <span class="s1">current_accumulator </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">accumulator</span><span class="s4">)</span>
        <span class="s1">gg</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">accumulator</span><span class="s4">) == </span><span class="s1">current_accumulator </span><span class="s4">+ </span><span class="s5">1</span>


<span class="s3">def </span><span class="s1">test_memory_kwarg</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s0">&quot; Test memory with a function with keyword arguments.&quot;</span>
    <span class="s1">accumulator </span><span class="s4">= </span><span class="s1">list</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">g</span><span class="s4">(</span><span class="s1">arg1</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">arg2</span><span class="s4">=</span><span class="s5">1</span><span class="s4">):</span>
        <span class="s1">accumulator</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">arg1</span>

    <span class="s1">check_identity_lazy</span><span class="s4">(</span><span class="s1">g</span><span class="s4">, </span><span class="s1">accumulator</span><span class="s4">, </span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">)</span>

    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">g </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">g</span><span class="s4">)</span>
    <span class="s2"># Smoke test with an explicit keyword argument:</span>
    <span class="s3">assert </span><span class="s1">g</span><span class="s4">(</span><span class="s1">arg1</span><span class="s4">=</span><span class="s5">30</span><span class="s4">, </span><span class="s1">arg2</span><span class="s4">=</span><span class="s5">2</span><span class="s4">) == </span><span class="s5">30</span>


<span class="s3">def </span><span class="s1">test_memory_lambda</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s0">&quot; Test memory with a function with a lambda.&quot;</span>
    <span class="s1">accumulator </span><span class="s4">= </span><span class="s1">list</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">helper</span><span class="s4">(</span><span class="s1">x</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; A helper function to define l as a lambda. 
        &quot;&quot;&quot;</span>
        <span class="s1">accumulator</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">x</span>

    <span class="s1">check_identity_lazy</span><span class="s4">(</span><span class="s3">lambda </span><span class="s1">x</span><span class="s4">: </span><span class="s1">helper</span><span class="s4">(</span><span class="s1">x</span><span class="s4">), </span><span class="s1">accumulator</span><span class="s4">, </span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_memory_name_collision</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s0">&quot; Check that name collisions with functions will raise warnings&quot;</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">name_collision</span><span class="s4">(</span><span class="s1">x</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; A first function called name_collision 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">x</span>

    <span class="s1">a </span><span class="s4">= </span><span class="s1">name_collision</span>

    <span class="s4">@</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">name_collision</span><span class="s4">(</span><span class="s1">x</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; A second function called name_collision 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">x</span>

    <span class="s1">b </span><span class="s4">= </span><span class="s1">name_collision</span>

    <span class="s3">with </span><span class="s1">warns</span><span class="s4">(</span><span class="s1">JobLibCollisionWarning</span><span class="s4">) </span><span class="s3">as </span><span class="s1">warninfo</span><span class="s4">:</span>
        <span class="s1">a</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
        <span class="s1">b</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>

    <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">warninfo</span><span class="s4">) == </span><span class="s5">1</span>
    <span class="s3">assert </span><span class="s6">&quot;collision&quot; </span><span class="s3">in </span><span class="s1">str</span><span class="s4">(</span><span class="s1">warninfo</span><span class="s4">[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">message</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_memory_warning_lambda_collisions</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s2"># Check that multiple use of lambda will raise collisions</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">a </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s3">lambda </span><span class="s1">x</span><span class="s4">: </span><span class="s1">x</span><span class="s4">)</span>
    <span class="s1">b </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s3">lambda </span><span class="s1">x</span><span class="s4">: </span><span class="s1">x </span><span class="s4">+ </span><span class="s5">1</span><span class="s4">)</span>

    <span class="s3">with </span><span class="s1">warns</span><span class="s4">(</span><span class="s1">JobLibCollisionWarning</span><span class="s4">) </span><span class="s3">as </span><span class="s1">warninfo</span><span class="s4">:</span>
        <span class="s3">assert </span><span class="s1">a</span><span class="s4">(</span><span class="s5">0</span><span class="s4">) == </span><span class="s5">0</span>
        <span class="s3">assert </span><span class="s1">b</span><span class="s4">(</span><span class="s5">1</span><span class="s4">) == </span><span class="s5">2</span>
        <span class="s3">assert </span><span class="s1">a</span><span class="s4">(</span><span class="s5">1</span><span class="s4">) == </span><span class="s5">1</span>

    <span class="s2"># In recent Python versions, we can retrieve the code of lambdas,</span>
    <span class="s2"># thus nothing is raised</span>
    <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">warninfo</span><span class="s4">) == </span><span class="s5">4</span>


<span class="s3">def </span><span class="s1">test_memory_warning_collision_detection</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s2"># Check that collisions impossible to detect will raise appropriate</span>
    <span class="s2"># warnings.</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">a1 </span><span class="s4">= </span><span class="s1">eval</span><span class="s4">(</span><span class="s6">'lambda x: x'</span><span class="s4">)</span>
    <span class="s1">a1 </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">a1</span><span class="s4">)</span>
    <span class="s1">b1 </span><span class="s4">= </span><span class="s1">eval</span><span class="s4">(</span><span class="s6">'lambda x: x+1'</span><span class="s4">)</span>
    <span class="s1">b1 </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">b1</span><span class="s4">)</span>

    <span class="s3">with </span><span class="s1">warns</span><span class="s4">(</span><span class="s1">JobLibCollisionWarning</span><span class="s4">) </span><span class="s3">as </span><span class="s1">warninfo</span><span class="s4">:</span>
        <span class="s1">a1</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
        <span class="s1">b1</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
        <span class="s1">a1</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>

    <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">warninfo</span><span class="s4">) == </span><span class="s5">2</span>
    <span class="s3">assert </span><span class="s6">&quot;cannot detect&quot; </span><span class="s3">in </span><span class="s1">str</span><span class="s4">(</span><span class="s1">warninfo</span><span class="s4">[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">message</span><span class="s4">).</span><span class="s1">lower</span><span class="s4">()</span>


<span class="s3">def </span><span class="s1">test_memory_partial</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s0">&quot; Test memory with functools.partial.&quot;</span>
    <span class="s1">accumulator </span><span class="s4">= </span><span class="s1">list</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">func</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; A helper function to define l as a lambda. 
        &quot;&quot;&quot;</span>
        <span class="s1">accumulator</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">y</span>

    <span class="s3">import </span><span class="s1">functools</span>
    <span class="s1">function </span><span class="s4">= </span><span class="s1">functools</span><span class="s4">.</span><span class="s1">partial</span><span class="s4">(</span><span class="s1">func</span><span class="s4">, </span><span class="s5">1</span><span class="s4">)</span>

    <span class="s1">check_identity_lazy</span><span class="s4">(</span><span class="s1">function</span><span class="s4">, </span><span class="s1">accumulator</span><span class="s4">, </span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_memory_eval</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s0">&quot; Smoke test memory with a function with a function defined in an eval.&quot;</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>

    <span class="s1">m </span><span class="s4">= </span><span class="s1">eval</span><span class="s4">(</span><span class="s6">'lambda x: x'</span><span class="s4">)</span>
    <span class="s1">mm </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">m</span><span class="s4">)</span>

    <span class="s3">assert </span><span class="s1">mm</span><span class="s4">(</span><span class="s5">1</span><span class="s4">) == </span><span class="s5">1</span>


<span class="s3">def </span><span class="s1">count_and_append</span><span class="s4">(</span><span class="s1">x</span><span class="s4">=[]):</span>
    <span class="s0">&quot;&quot;&quot; A function with a side effect in its arguments. 
 
        Return the length of its argument and append one element. 
    &quot;&quot;&quot;</span>
    <span class="s1">len_x </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
    <span class="s1">x</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s3">None</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">len_x</span>


<span class="s3">def </span><span class="s1">test_argument_change</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; Check that if a function has a side effect in its arguments, it 
        should use the hash of changing arguments. 
    &quot;&quot;&quot;</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">func </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">count_and_append</span><span class="s4">)</span>
    <span class="s2"># call the function for the first time, is should cache it with</span>
    <span class="s2"># argument x=[]</span>
    <span class="s3">assert </span><span class="s1">func</span><span class="s4">() == </span><span class="s5">0</span>
    <span class="s2"># the second time the argument is x=[None], which is not cached</span>
    <span class="s2"># yet, so the functions should be called a second time</span>
    <span class="s3">assert </span><span class="s1">func</span><span class="s4">() == </span><span class="s5">1</span>


<span class="s4">@</span><span class="s1">with_numpy</span>
<span class="s4">@</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">'mmap_mode'</span><span class="s4">, [</span><span class="s3">None</span><span class="s4">, </span><span class="s6">'r'</span><span class="s4">])</span>
<span class="s3">def </span><span class="s1">test_memory_numpy</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">, </span><span class="s1">mmap_mode</span><span class="s4">):</span>
    <span class="s0">&quot; Test memory with a function with numpy arrays.&quot;</span>
    <span class="s1">accumulator </span><span class="s4">= </span><span class="s1">list</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">n</span><span class="s4">(</span><span class="s1">arg</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s1">accumulator</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">arg</span>

    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">mmap_mode</span><span class="s4">=</span><span class="s1">mmap_mode</span><span class="s4">,</span>
                    <span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">cached_n </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)</span>

    <span class="s1">rnd </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s5">3</span><span class="s4">):</span>
        <span class="s1">a </span><span class="s4">= </span><span class="s1">rnd</span><span class="s4">.</span><span class="s1">random_sample</span><span class="s4">((</span><span class="s5">10</span><span class="s4">, </span><span class="s5">10</span><span class="s4">))</span>
        <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s5">3</span><span class="s4">):</span>
            <span class="s3">assert </span><span class="s1">np</span><span class="s4">.</span><span class="s1">all</span><span class="s4">(</span><span class="s1">cached_n</span><span class="s4">(</span><span class="s1">a</span><span class="s4">) == </span><span class="s1">a</span><span class="s4">)</span>
            <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">accumulator</span><span class="s4">) == </span><span class="s1">i </span><span class="s4">+ </span><span class="s5">1</span>


<span class="s4">@</span><span class="s1">with_numpy</span>
<span class="s3">def </span><span class="s1">test_memory_numpy_check_mmap_mode</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">, </span><span class="s1">monkeypatch</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Check that mmap_mode is respected even at the first call&quot;&quot;&quot;</span>

    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">mmap_mode</span><span class="s4">=</span><span class="s6">'r'</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">()</span>
    <span class="s3">def </span><span class="s1">twice</span><span class="s4">(</span><span class="s1">a</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">a </span><span class="s4">* </span><span class="s5">2</span>

    <span class="s1">a </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">(</span><span class="s5">3</span><span class="s4">)</span>

    <span class="s1">b </span><span class="s4">= </span><span class="s1">twice</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
    <span class="s1">c </span><span class="s4">= </span><span class="s1">twice</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>

    <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">c</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">memmap</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">c</span><span class="s4">.</span><span class="s1">mode </span><span class="s4">== </span><span class="s6">'r'</span>

    <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">b</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">memmap</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">b</span><span class="s4">.</span><span class="s1">mode </span><span class="s4">== </span><span class="s6">'r'</span>

    <span class="s2"># Corrupts the file,  Deleting b and c mmaps</span>
    <span class="s2"># is necessary to be able edit the file</span>
    <span class="s3">del </span><span class="s1">b</span>
    <span class="s3">del </span><span class="s1">c</span>
    <span class="s1">gc</span><span class="s4">.</span><span class="s1">collect</span><span class="s4">()</span>
    <span class="s1">corrupt_single_cache_item</span><span class="s4">(</span><span class="s1">memory</span><span class="s4">)</span>

    <span class="s2"># Make sure that corrupting the file causes recomputation and that</span>
    <span class="s2"># a warning is issued.</span>
    <span class="s1">recorded_warnings </span><span class="s4">= </span><span class="s1">monkeypatch_cached_func_warn</span><span class="s4">(</span><span class="s1">twice</span><span class="s4">, </span><span class="s1">monkeypatch</span><span class="s4">)</span>
    <span class="s1">d </span><span class="s4">= </span><span class="s1">twice</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">recorded_warnings</span><span class="s4">) == </span><span class="s5">1</span>
    <span class="s1">exception_msg </span><span class="s4">= </span><span class="s6">'Exception while loading results'</span>
    <span class="s3">assert </span><span class="s1">exception_msg </span><span class="s3">in </span><span class="s1">recorded_warnings</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
    <span class="s2"># Asserts that the recomputation returns a mmap</span>
    <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">d</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">memmap</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">d</span><span class="s4">.</span><span class="s1">mode </span><span class="s4">== </span><span class="s6">'r'</span>


<span class="s3">def </span><span class="s1">test_memory_exception</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; Smoketest the exception handling of Memory. 
    &quot;&quot;&quot;</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>

    <span class="s3">class </span><span class="s1">MyException</span><span class="s4">(</span><span class="s1">Exception</span><span class="s4">):</span>
        <span class="s3">pass</span>

    <span class="s4">@</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">h</span><span class="s4">(</span><span class="s1">exc</span><span class="s4">=</span><span class="s5">0</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">exc</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">MyException</span>

    <span class="s2"># Call once, to initialise the cache</span>
    <span class="s1">h</span><span class="s4">()</span>

    <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s5">3</span><span class="s4">):</span>
        <span class="s2"># Call 3 times, to be sure that the Exception is always raised</span>
        <span class="s3">with </span><span class="s1">raises</span><span class="s4">(</span><span class="s1">MyException</span><span class="s4">):</span>
            <span class="s1">h</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_memory_ignore</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s0">&quot; Test the ignore feature of memory &quot;</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">accumulator </span><span class="s4">= </span><span class="s1">list</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">ignore</span><span class="s4">=[</span><span class="s6">'y'</span><span class="s4">])</span>
    <span class="s3">def </span><span class="s1">z</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s5">1</span><span class="s4">):</span>
        <span class="s1">accumulator</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>

    <span class="s3">assert </span><span class="s1">z</span><span class="s4">.</span><span class="s1">ignore </span><span class="s4">== [</span><span class="s6">'y'</span><span class="s4">]</span>

    <span class="s1">z</span><span class="s4">(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">accumulator</span><span class="s4">) == </span><span class="s5">1</span>
    <span class="s1">z</span><span class="s4">(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">accumulator</span><span class="s4">) == </span><span class="s5">1</span>
    <span class="s1">z</span><span class="s4">(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s5">2</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">accumulator</span><span class="s4">) == </span><span class="s5">1</span>


<span class="s3">def </span><span class="s1">test_memory_ignore_decorated</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s0">&quot; Test the ignore feature of memory on a decorated function &quot;</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">accumulator </span><span class="s4">= </span><span class="s1">list</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">decorate</span><span class="s4">(</span><span class="s1">f</span><span class="s4">):</span>
        <span class="s4">@</span><span class="s1">functools</span><span class="s4">.</span><span class="s1">wraps</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
        <span class="s3">def </span><span class="s1">wrapped</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">f</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">wrapped</span>

    <span class="s4">@</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">ignore</span><span class="s4">=[</span><span class="s6">'y'</span><span class="s4">])</span>
    <span class="s4">@</span><span class="s1">decorate</span>
    <span class="s3">def </span><span class="s1">z</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s5">1</span><span class="s4">):</span>
        <span class="s1">accumulator</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>

    <span class="s3">assert </span><span class="s1">z</span><span class="s4">.</span><span class="s1">ignore </span><span class="s4">== [</span><span class="s6">'y'</span><span class="s4">]</span>

    <span class="s1">z</span><span class="s4">(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">accumulator</span><span class="s4">) == </span><span class="s5">1</span>
    <span class="s1">z</span><span class="s4">(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">accumulator</span><span class="s4">) == </span><span class="s5">1</span>
    <span class="s1">z</span><span class="s4">(</span><span class="s5">0</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s5">2</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">accumulator</span><span class="s4">) == </span><span class="s5">1</span>


<span class="s3">def </span><span class="s1">test_memory_args_as_kwargs</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Non-regression test against 0.12.0 changes. 
 
    https://github.com/joblib/joblib/pull/751 
    &quot;&quot;&quot;</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">plus_one</span><span class="s4">(</span><span class="s1">a</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">a </span><span class="s4">+ </span><span class="s5">1</span>

    <span class="s2"># It's possible to call a positional arg as a kwarg.</span>
    <span class="s3">assert </span><span class="s1">plus_one</span><span class="s4">(</span><span class="s5">1</span><span class="s4">) == </span><span class="s5">2</span>
    <span class="s3">assert </span><span class="s1">plus_one</span><span class="s4">(</span><span class="s1">a</span><span class="s4">=</span><span class="s5">1</span><span class="s4">) == </span><span class="s5">2</span>

    <span class="s2"># However, a positional argument that joblib hadn't seen</span>
    <span class="s2"># before would cause a failure if it was passed as a kwarg.</span>
    <span class="s3">assert </span><span class="s1">plus_one</span><span class="s4">(</span><span class="s1">a</span><span class="s4">=</span><span class="s5">2</span><span class="s4">) == </span><span class="s5">3</span>


<span class="s4">@</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">'ignore, verbose, mmap_mode'</span><span class="s4">, [([</span><span class="s6">'x'</span><span class="s4">], </span><span class="s5">100</span><span class="s4">, </span><span class="s6">'r'</span><span class="s4">),</span>
                                            <span class="s4">([], </span><span class="s5">10</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)])</span>
<span class="s3">def </span><span class="s1">test_partial_decoration</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">, </span><span class="s1">ignore</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">, </span><span class="s1">mmap_mode</span><span class="s4">):</span>
    <span class="s0">&quot;Check cache may be called with kwargs before decorating&quot;</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">ignore</span><span class="s4">=</span><span class="s1">ignore</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">, </span><span class="s1">mmap_mode</span><span class="s4">=</span><span class="s1">mmap_mode</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">z</span><span class="s4">(</span><span class="s1">x</span><span class="s4">):</span>
        <span class="s3">pass</span>

    <span class="s3">assert </span><span class="s1">z</span><span class="s4">.</span><span class="s1">ignore </span><span class="s4">== </span><span class="s1">ignore</span>
    <span class="s3">assert </span><span class="s1">z</span><span class="s4">.</span><span class="s1">_verbose </span><span class="s4">== </span><span class="s1">verbose</span>
    <span class="s3">assert </span><span class="s1">z</span><span class="s4">.</span><span class="s1">mmap_mode </span><span class="s4">== </span><span class="s1">mmap_mode</span>


<span class="s3">def </span><span class="s1">test_func_dir</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s2"># Test the creation of the memory cache directory for the function.</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">path </span><span class="s4">= </span><span class="s1">__name__</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'.'</span><span class="s4">)</span>
    <span class="s1">path</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s6">'f'</span><span class="s4">)</span>
    <span class="s1">path </span><span class="s4">= </span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s6">'joblib'</span><span class="s4">, *</span><span class="s1">path</span><span class="s4">).</span><span class="s1">strpath</span>

    <span class="s1">g </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
    <span class="s2"># Test that the function directory is created on demand</span>
    <span class="s1">func_id </span><span class="s4">= </span><span class="s1">_build_func_identifier</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
    <span class="s1">location </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">g</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">location</span><span class="s4">, </span><span class="s1">func_id</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">location </span><span class="s4">== </span><span class="s1">path</span>
    <span class="s3">assert </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">exists</span><span class="s4">(</span><span class="s1">path</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">location </span><span class="s4">== </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">dirname</span><span class="s4">(</span><span class="s1">g</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">location</span><span class="s4">)</span>

    <span class="s2"># Test that the code is stored.</span>
    <span class="s2"># For the following test to be robust to previous execution, we clear</span>
    <span class="s2"># the in-memory store</span>
    <span class="s1">_FUNCTION_HASHES</span><span class="s4">.</span><span class="s1">clear</span><span class="s4">()</span>
    <span class="s3">assert not </span><span class="s1">g</span><span class="s4">.</span><span class="s1">_check_previous_func_code</span><span class="s4">()</span>
    <span class="s3">assert </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">exists</span><span class="s4">(</span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">path</span><span class="s4">, </span><span class="s6">'func_code.py'</span><span class="s4">))</span>
    <span class="s3">assert </span><span class="s1">g</span><span class="s4">.</span><span class="s1">_check_previous_func_code</span><span class="s4">()</span>

    <span class="s2"># Test the robustness to failure of loading previous results.</span>
    <span class="s1">args_id </span><span class="s4">= </span><span class="s1">g</span><span class="s4">.</span><span class="s1">_get_args_id</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s1">output_dir </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">g</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">location</span><span class="s4">, </span><span class="s1">g</span><span class="s4">.</span><span class="s1">func_id</span><span class="s4">, </span><span class="s1">args_id</span><span class="s4">)</span>
    <span class="s1">a </span><span class="s4">= </span><span class="s1">g</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">exists</span><span class="s4">(</span><span class="s1">output_dir</span><span class="s4">)</span>
    <span class="s1">os</span><span class="s4">.</span><span class="s1">remove</span><span class="s4">(</span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">output_dir</span><span class="s4">, </span><span class="s6">'output.pkl'</span><span class="s4">))</span>
    <span class="s3">assert </span><span class="s1">a </span><span class="s4">== </span><span class="s1">g</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_persistence</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s2"># Test the memorized functions can be pickled and restored.</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">g </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
    <span class="s1">output </span><span class="s4">= </span><span class="s1">g</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>

    <span class="s1">h </span><span class="s4">= </span><span class="s1">pickle</span><span class="s4">.</span><span class="s1">loads</span><span class="s4">(</span><span class="s1">pickle</span><span class="s4">.</span><span class="s1">dumps</span><span class="s4">(</span><span class="s1">g</span><span class="s4">))</span>

    <span class="s1">args_id </span><span class="s4">= </span><span class="s1">h</span><span class="s4">.</span><span class="s1">_get_args_id</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s1">output_dir </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">h</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">location</span><span class="s4">, </span><span class="s1">h</span><span class="s4">.</span><span class="s1">func_id</span><span class="s4">, </span><span class="s1">args_id</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">exists</span><span class="s4">(</span><span class="s1">output_dir</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">output </span><span class="s4">== </span><span class="s1">h</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">load_item</span><span class="s4">([</span><span class="s1">h</span><span class="s4">.</span><span class="s1">func_id</span><span class="s4">, </span><span class="s1">args_id</span><span class="s4">])</span>
    <span class="s1">memory2 </span><span class="s4">= </span><span class="s1">pickle</span><span class="s4">.</span><span class="s1">loads</span><span class="s4">(</span><span class="s1">pickle</span><span class="s4">.</span><span class="s1">dumps</span><span class="s4">(</span><span class="s1">memory</span><span class="s4">))</span>
    <span class="s3">assert </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">location </span><span class="s4">== </span><span class="s1">memory2</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">location</span>

    <span class="s2"># Smoke test that pickling a memory with location=None works</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">pickle</span><span class="s4">.</span><span class="s1">loads</span><span class="s4">(</span><span class="s1">pickle</span><span class="s4">.</span><span class="s1">dumps</span><span class="s4">(</span><span class="s1">memory</span><span class="s4">))</span>
    <span class="s1">g </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
    <span class="s1">gp </span><span class="s4">= </span><span class="s1">pickle</span><span class="s4">.</span><span class="s1">loads</span><span class="s4">(</span><span class="s1">pickle</span><span class="s4">.</span><span class="s1">dumps</span><span class="s4">(</span><span class="s1">g</span><span class="s4">))</span>
    <span class="s1">gp</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_check_call_in_cache</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s3">for </span><span class="s1">func </span><span class="s3">in </span><span class="s4">(</span><span class="s1">MemorizedFunc</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">),</span>
                 <span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">).</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)):</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">func</span><span class="s4">.</span><span class="s1">check_call_in_cache</span><span class="s4">(</span><span class="s5">2</span><span class="s4">)</span>
        <span class="s3">assert not </span><span class="s1">result</span>
        <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">result</span><span class="s4">, </span><span class="s1">bool</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">func</span><span class="s4">(</span><span class="s5">2</span><span class="s4">) == </span><span class="s5">5</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">func</span><span class="s4">.</span><span class="s1">check_call_in_cache</span><span class="s4">(</span><span class="s5">2</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">result</span>
        <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">result</span><span class="s4">, </span><span class="s1">bool</span><span class="s4">)</span>
        <span class="s1">func</span><span class="s4">.</span><span class="s1">clear</span><span class="s4">()</span>


<span class="s3">def </span><span class="s1">test_call_and_shelve</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s2"># Test MemorizedFunc outputting a reference to cache.</span>

    <span class="s3">for </span><span class="s1">func</span><span class="s4">, </span><span class="s1">Result </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">((</span><span class="s1">MemorizedFunc</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">),</span>
                             <span class="s1">NotMemorizedFunc</span><span class="s4">(</span><span class="s1">f</span><span class="s4">),</span>
                             <span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">,</span>
                                    <span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">).</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">f</span><span class="s4">),</span>
                             <span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s3">None</span><span class="s4">).</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">f</span><span class="s4">),</span>
                             <span class="s4">),</span>
                            <span class="s4">(</span><span class="s1">MemorizedResult</span><span class="s4">, </span><span class="s1">NotMemorizedResult</span><span class="s4">,</span>
                             <span class="s1">MemorizedResult</span><span class="s4">, </span><span class="s1">NotMemorizedResult</span><span class="s4">)):</span>
        <span class="s3">assert </span><span class="s1">func</span><span class="s4">(</span><span class="s5">2</span><span class="s4">) == </span><span class="s5">5</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">func</span><span class="s4">.</span><span class="s1">call_and_shelve</span><span class="s4">(</span><span class="s5">2</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">result</span><span class="s4">, </span><span class="s1">Result</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">result</span><span class="s4">.</span><span class="s1">get</span><span class="s4">() == </span><span class="s5">5</span>

        <span class="s1">result</span><span class="s4">.</span><span class="s1">clear</span><span class="s4">()</span>
        <span class="s3">with </span><span class="s1">raises</span><span class="s4">(</span><span class="s1">KeyError</span><span class="s4">):</span>
            <span class="s1">result</span><span class="s4">.</span><span class="s1">get</span><span class="s4">()</span>
        <span class="s1">result</span><span class="s4">.</span><span class="s1">clear</span><span class="s4">()  </span><span class="s2"># Do nothing if there is no cache.</span>


<span class="s3">def </span><span class="s1">test_call_and_shelve_argument_hash</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s2"># Verify that a warning is raised when accessing arguments_hash</span>
    <span class="s2"># attribute from MemorizedResult</span>
    <span class="s1">func </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">).</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
    <span class="s1">result </span><span class="s4">= </span><span class="s1">func</span><span class="s4">.</span><span class="s1">call_and_shelve</span><span class="s4">(</span><span class="s5">2</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">result</span><span class="s4">, </span><span class="s1">MemorizedResult</span><span class="s4">)</span>
    <span class="s3">with </span><span class="s1">warns</span><span class="s4">(</span><span class="s1">DeprecationWarning</span><span class="s4">) </span><span class="s3">as </span><span class="s1">w</span><span class="s4">:</span>
        <span class="s3">assert </span><span class="s1">result</span><span class="s4">.</span><span class="s1">argument_hash </span><span class="s4">== </span><span class="s1">result</span><span class="s4">.</span><span class="s1">args_id</span>
    <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">w</span><span class="s4">) == </span><span class="s5">1</span>
    <span class="s3">assert </span><span class="s6">&quot;The 'argument_hash' attribute has been deprecated&quot; </span><span class="s1">\</span>
        <span class="s3">in </span><span class="s1">str</span><span class="s4">(</span><span class="s1">w</span><span class="s4">[-</span><span class="s5">1</span><span class="s4">].</span><span class="s1">message</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_call_and_shelve_lazily_load_stored_result</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Check call_and_shelve only load stored data if needed.&quot;&quot;&quot;</span>
    <span class="s1">test_access_time_file </span><span class="s4">= </span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s6">'test_access'</span><span class="s4">)</span>
    <span class="s1">test_access_time_file</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s6">'test_access'</span><span class="s4">)</span>
    <span class="s1">test_access_time </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">stat</span><span class="s4">(</span><span class="s1">test_access_time_file</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">).</span><span class="s1">st_atime</span>
    <span class="s2"># check file system access time stats resolution is lower than test wait</span>
    <span class="s2"># timings.</span>
    <span class="s1">time</span><span class="s4">.</span><span class="s1">sleep</span><span class="s4">(</span><span class="s5">0.5</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">test_access_time_file</span><span class="s4">.</span><span class="s1">read</span><span class="s4">() == </span><span class="s6">'test_access'</span>

    <span class="s3">if </span><span class="s1">test_access_time </span><span class="s4">== </span><span class="s1">os</span><span class="s4">.</span><span class="s1">stat</span><span class="s4">(</span><span class="s1">test_access_time_file</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">).</span><span class="s1">st_atime</span><span class="s4">:</span>
        <span class="s2"># Skip this test when access time cannot be retrieved with enough</span>
        <span class="s2"># precision from the file system (e.g. NTFS on windows).</span>
        <span class="s1">pytest</span><span class="s4">.</span><span class="s1">skip</span><span class="s4">(</span><span class="s6">&quot;filesystem does not support fine-grained access time &quot;</span>
                    <span class="s6">&quot;attribute&quot;</span><span class="s4">)</span>

    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">func </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
    <span class="s1">args_id </span><span class="s4">= </span><span class="s1">func</span><span class="s4">.</span><span class="s1">_get_args_id</span><span class="s4">(</span><span class="s5">2</span><span class="s4">)</span>
    <span class="s1">result_path </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">location</span><span class="s4">,</span>
                               <span class="s1">func</span><span class="s4">.</span><span class="s1">func_id</span><span class="s4">, </span><span class="s1">args_id</span><span class="s4">, </span><span class="s6">'output.pkl'</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">func</span><span class="s4">(</span><span class="s5">2</span><span class="s4">) == </span><span class="s5">5</span>
    <span class="s1">first_access_time </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">stat</span><span class="s4">(</span><span class="s1">result_path</span><span class="s4">).</span><span class="s1">st_atime</span>
    <span class="s1">time</span><span class="s4">.</span><span class="s1">sleep</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>

    <span class="s2"># Should not access the stored data</span>
    <span class="s1">result </span><span class="s4">= </span><span class="s1">func</span><span class="s4">.</span><span class="s1">call_and_shelve</span><span class="s4">(</span><span class="s5">2</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">result</span><span class="s4">, </span><span class="s1">MemorizedResult</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">os</span><span class="s4">.</span><span class="s1">stat</span><span class="s4">(</span><span class="s1">result_path</span><span class="s4">).</span><span class="s1">st_atime </span><span class="s4">== </span><span class="s1">first_access_time</span>
    <span class="s1">time</span><span class="s4">.</span><span class="s1">sleep</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>

    <span class="s2"># Read the stored data =&gt; last access time is greater than first_access</span>
    <span class="s3">assert </span><span class="s1">result</span><span class="s4">.</span><span class="s1">get</span><span class="s4">() == </span><span class="s5">5</span>
    <span class="s3">assert </span><span class="s1">os</span><span class="s4">.</span><span class="s1">stat</span><span class="s4">(</span><span class="s1">result_path</span><span class="s4">).</span><span class="s1">st_atime </span><span class="s4">&gt; </span><span class="s1">first_access_time</span>


<span class="s3">def </span><span class="s1">test_memorized_pickling</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s3">for </span><span class="s1">func </span><span class="s3">in </span><span class="s4">(</span><span class="s1">MemorizedFunc</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">), </span><span class="s1">NotMemorizedFunc</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)):</span>
        <span class="s1">filename </span><span class="s4">= </span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s6">'pickling_test.dat'</span><span class="s4">).</span><span class="s1">strpath</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">func</span><span class="s4">.</span><span class="s1">call_and_shelve</span><span class="s4">(</span><span class="s5">2</span><span class="s4">)</span>
        <span class="s3">with </span><span class="s1">open</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">, </span><span class="s6">'wb'</span><span class="s4">) </span><span class="s3">as </span><span class="s1">fp</span><span class="s4">:</span>
            <span class="s1">pickle</span><span class="s4">.</span><span class="s1">dump</span><span class="s4">(</span><span class="s1">result</span><span class="s4">, </span><span class="s1">fp</span><span class="s4">)</span>
        <span class="s3">with </span><span class="s1">open</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">, </span><span class="s6">'rb'</span><span class="s4">) </span><span class="s3">as </span><span class="s1">fp</span><span class="s4">:</span>
            <span class="s1">result2 </span><span class="s4">= </span><span class="s1">pickle</span><span class="s4">.</span><span class="s1">load</span><span class="s4">(</span><span class="s1">fp</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">result2</span><span class="s4">.</span><span class="s1">get</span><span class="s4">() == </span><span class="s1">result</span><span class="s4">.</span><span class="s1">get</span><span class="s4">()</span>
        <span class="s1">os</span><span class="s4">.</span><span class="s1">remove</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_memorized_repr</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s1">func </span><span class="s4">= </span><span class="s1">MemorizedFunc</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">)</span>
    <span class="s1">result </span><span class="s4">= </span><span class="s1">func</span><span class="s4">.</span><span class="s1">call_and_shelve</span><span class="s4">(</span><span class="s5">2</span><span class="s4">)</span>

    <span class="s1">func2 </span><span class="s4">= </span><span class="s1">MemorizedFunc</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">)</span>
    <span class="s1">result2 </span><span class="s4">= </span><span class="s1">func2</span><span class="s4">.</span><span class="s1">call_and_shelve</span><span class="s4">(</span><span class="s5">2</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">result</span><span class="s4">.</span><span class="s1">get</span><span class="s4">() == </span><span class="s1">result2</span><span class="s4">.</span><span class="s1">get</span><span class="s4">()</span>
    <span class="s3">assert </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">func</span><span class="s4">) == </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">func2</span><span class="s4">)</span>

    <span class="s2"># Smoke test with NotMemorizedFunc</span>
    <span class="s1">func </span><span class="s4">= </span><span class="s1">NotMemorizedFunc</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
    <span class="s1">repr</span><span class="s4">(</span><span class="s1">func</span><span class="s4">)</span>
    <span class="s1">repr</span><span class="s4">(</span><span class="s1">func</span><span class="s4">.</span><span class="s1">call_and_shelve</span><span class="s4">(</span><span class="s5">2</span><span class="s4">))</span>

    <span class="s2"># Smoke test for message output (increase code coverage)</span>
    <span class="s1">func </span><span class="s4">= </span><span class="s1">MemorizedFunc</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">11</span><span class="s4">, </span><span class="s1">timestamp</span><span class="s4">=</span><span class="s1">time</span><span class="s4">.</span><span class="s1">time</span><span class="s4">())</span>
    <span class="s1">result </span><span class="s4">= </span><span class="s1">func</span><span class="s4">.</span><span class="s1">call_and_shelve</span><span class="s4">(</span><span class="s5">11</span><span class="s4">)</span>
    <span class="s1">result</span><span class="s4">.</span><span class="s1">get</span><span class="s4">()</span>

    <span class="s1">func </span><span class="s4">= </span><span class="s1">MemorizedFunc</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">11</span><span class="s4">)</span>
    <span class="s1">result </span><span class="s4">= </span><span class="s1">func</span><span class="s4">.</span><span class="s1">call_and_shelve</span><span class="s4">(</span><span class="s5">11</span><span class="s4">)</span>
    <span class="s1">result</span><span class="s4">.</span><span class="s1">get</span><span class="s4">()</span>

    <span class="s1">func </span><span class="s4">= </span><span class="s1">MemorizedFunc</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">5</span><span class="s4">, </span><span class="s1">timestamp</span><span class="s4">=</span><span class="s1">time</span><span class="s4">.</span><span class="s1">time</span><span class="s4">())</span>
    <span class="s1">result </span><span class="s4">= </span><span class="s1">func</span><span class="s4">.</span><span class="s1">call_and_shelve</span><span class="s4">(</span><span class="s5">11</span><span class="s4">)</span>
    <span class="s1">result</span><span class="s4">.</span><span class="s1">get</span><span class="s4">()</span>

    <span class="s1">func </span><span class="s4">= </span><span class="s1">MemorizedFunc</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">5</span><span class="s4">)</span>
    <span class="s1">result </span><span class="s4">= </span><span class="s1">func</span><span class="s4">.</span><span class="s1">call_and_shelve</span><span class="s4">(</span><span class="s5">11</span><span class="s4">)</span>
    <span class="s1">result</span><span class="s4">.</span><span class="s1">get</span><span class="s4">()</span>


<span class="s3">def </span><span class="s1">test_memory_file_modification</span><span class="s4">(</span><span class="s1">capsys</span><span class="s4">, </span><span class="s1">tmpdir</span><span class="s4">, </span><span class="s1">monkeypatch</span><span class="s4">):</span>
    <span class="s2"># Test that modifying a Python file after loading it does not lead to</span>
    <span class="s2"># Recomputation</span>
    <span class="s1">dir_name </span><span class="s4">= </span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">mkdir</span><span class="s4">(</span><span class="s6">'tmp_import'</span><span class="s4">).</span><span class="s1">strpath</span>
    <span class="s1">filename </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">dir_name</span><span class="s4">, </span><span class="s6">'tmp_joblib_.py'</span><span class="s4">)</span>
    <span class="s1">content </span><span class="s4">= </span><span class="s6">'def f(x):</span><span class="s3">\n    </span><span class="s6">print(x)</span><span class="s3">\n    </span><span class="s6">return x</span><span class="s3">\n</span><span class="s6">'</span>
    <span class="s3">with </span><span class="s1">open</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">, </span><span class="s6">'w'</span><span class="s4">) </span><span class="s3">as </span><span class="s1">module_file</span><span class="s4">:</span>
        <span class="s1">module_file</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s1">content</span><span class="s4">)</span>

    <span class="s2"># Load the module:</span>
    <span class="s1">monkeypatch</span><span class="s4">.</span><span class="s1">syspath_prepend</span><span class="s4">(</span><span class="s1">dir_name</span><span class="s4">)</span>
    <span class="s3">import </span><span class="s1">tmp_joblib_ </span><span class="s3">as </span><span class="s1">tmp</span>

    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">f </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">tmp</span><span class="s4">.</span><span class="s1">f</span><span class="s4">)</span>
    <span class="s2"># First call f a few times</span>
    <span class="s1">f</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s1">f</span><span class="s4">(</span><span class="s5">2</span><span class="s4">)</span>
    <span class="s1">f</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>

    <span class="s2"># Now modify the module where f is stored without modifying f</span>
    <span class="s3">with </span><span class="s1">open</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">, </span><span class="s6">'w'</span><span class="s4">) </span><span class="s3">as </span><span class="s1">module_file</span><span class="s4">:</span>
        <span class="s1">module_file</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s6">'</span><span class="s3">\n\n</span><span class="s6">' </span><span class="s4">+ </span><span class="s1">content</span><span class="s4">)</span>

    <span class="s2"># And call f a couple more times</span>
    <span class="s1">f</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s1">f</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>

    <span class="s2"># Flush the .pyc files</span>
    <span class="s1">shutil</span><span class="s4">.</span><span class="s1">rmtree</span><span class="s4">(</span><span class="s1">dir_name</span><span class="s4">)</span>
    <span class="s1">os</span><span class="s4">.</span><span class="s1">mkdir</span><span class="s4">(</span><span class="s1">dir_name</span><span class="s4">)</span>
    <span class="s2"># Now modify the module where f is stored, modifying f</span>
    <span class="s1">content </span><span class="s4">= </span><span class="s6">'def f(x):</span><span class="s3">\n    </span><span class="s6">print(&quot;x=%s&quot; % x)</span><span class="s3">\n    </span><span class="s6">return x</span><span class="s3">\n</span><span class="s6">'</span>
    <span class="s3">with </span><span class="s1">open</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">, </span><span class="s6">'w'</span><span class="s4">) </span><span class="s3">as </span><span class="s1">module_file</span><span class="s4">:</span>
        <span class="s1">module_file</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s1">content</span><span class="s4">)</span>

    <span class="s2"># And call f more times prior to reloading: the cache should not be</span>
    <span class="s2"># invalidated at this point as the active function definition has not</span>
    <span class="s2"># changed in memory yet.</span>
    <span class="s1">f</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s1">f</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>

    <span class="s2"># Now reload</span>
    <span class="s1">sys</span><span class="s4">.</span><span class="s1">stdout</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s6">'Reloading</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">)</span>
    <span class="s1">sys</span><span class="s4">.</span><span class="s1">modules</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s6">'tmp_joblib_'</span><span class="s4">)</span>
    <span class="s3">import </span><span class="s1">tmp_joblib_ </span><span class="s3">as </span><span class="s1">tmp</span>
    <span class="s1">f </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">tmp</span><span class="s4">.</span><span class="s1">f</span><span class="s4">)</span>

    <span class="s2"># And call f more times</span>
    <span class="s1">f</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s1">f</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>

    <span class="s1">out</span><span class="s4">, </span><span class="s1">err </span><span class="s4">= </span><span class="s1">capsys</span><span class="s4">.</span><span class="s1">readouterr</span><span class="s4">()</span>
    <span class="s3">assert </span><span class="s1">out </span><span class="s4">== </span><span class="s6">'1</span><span class="s3">\n</span><span class="s6">2</span><span class="s3">\n</span><span class="s6">Reloading</span><span class="s3">\n</span><span class="s6">x=1</span><span class="s3">\n</span><span class="s6">'</span>


<span class="s3">def </span><span class="s1">_function_to_cache</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">):</span>
    <span class="s2"># Just a place holder function to be mutated by tests</span>
    <span class="s3">pass</span>


<span class="s3">def </span><span class="s1">_sum</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s1">a </span><span class="s4">+ </span><span class="s1">b</span>


<span class="s3">def </span><span class="s1">_product</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s1">a </span><span class="s4">* </span><span class="s1">b</span>


<span class="s3">def </span><span class="s1">test_memory_in_memory_function_code_change</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s1">_function_to_cache</span><span class="s4">.</span><span class="s1">__code__ </span><span class="s4">= </span><span class="s1">_sum</span><span class="s4">.</span><span class="s1">__code__</span>

    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">f </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">_function_to_cache</span><span class="s4">)</span>

    <span class="s3">assert </span><span class="s1">f</span><span class="s4">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">) == </span><span class="s5">3</span>
    <span class="s3">assert </span><span class="s1">f</span><span class="s4">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">) == </span><span class="s5">3</span>

    <span class="s3">with </span><span class="s1">warns</span><span class="s4">(</span><span class="s1">JobLibCollisionWarning</span><span class="s4">):</span>
        <span class="s2"># Check that inline function modification triggers a cache invalidation</span>
        <span class="s1">_function_to_cache</span><span class="s4">.</span><span class="s1">__code__ </span><span class="s4">= </span><span class="s1">_product</span><span class="s4">.</span><span class="s1">__code__</span>
        <span class="s3">assert </span><span class="s1">f</span><span class="s4">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">) == </span><span class="s5">2</span>
        <span class="s3">assert </span><span class="s1">f</span><span class="s4">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">) == </span><span class="s5">2</span>


<span class="s3">def </span><span class="s1">test_clear_memory_with_none_location</span><span class="s4">():</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s3">None</span><span class="s4">)</span>
    <span class="s1">memory</span><span class="s4">.</span><span class="s1">clear</span><span class="s4">()</span>


<span class="s3">def </span><span class="s1">func_with_kwonly_args</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, *, </span><span class="s1">kw1</span><span class="s4">=</span><span class="s6">'kw1'</span><span class="s4">, </span><span class="s1">kw2</span><span class="s4">=</span><span class="s6">'kw2'</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">kw1</span><span class="s4">, </span><span class="s1">kw2</span>


<span class="s3">def </span><span class="s1">func_with_signature</span><span class="s4">(</span><span class="s1">a</span><span class="s4">: </span><span class="s1">int</span><span class="s4">, </span><span class="s1">b</span><span class="s4">: </span><span class="s1">float</span><span class="s4">) </span><span class="s1">-&gt; float</span><span class="s4">:</span>
    <span class="s3">return </span><span class="s1">a </span><span class="s4">+ </span><span class="s1">b</span>


<span class="s3">def </span><span class="s1">test_memory_func_with_kwonly_args</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">func_cached </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">func_with_kwonly_args</span><span class="s4">)</span>

    <span class="s3">assert </span><span class="s1">func_cached</span><span class="s4">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s1">kw1</span><span class="s4">=</span><span class="s5">3</span><span class="s4">) == (</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s6">'kw2'</span><span class="s4">)</span>

    <span class="s2"># Making sure that providing a keyword-only argument by</span>
    <span class="s2"># position raises an exception</span>
    <span class="s3">with </span><span class="s1">raises</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">) </span><span class="s3">as </span><span class="s1">excinfo</span><span class="s4">:</span>
        <span class="s1">func_cached</span><span class="s4">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s1">kw2</span><span class="s4">=</span><span class="s5">4</span><span class="s4">)</span>
    <span class="s1">excinfo</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s6">&quot;Keyword-only parameter 'kw1' was passed as positional &quot;</span>
                  <span class="s6">&quot;parameter&quot;</span><span class="s4">)</span>

    <span class="s2"># Keyword-only parameter passed by position with cached call</span>
    <span class="s2"># should still raise ValueError</span>
    <span class="s1">func_cached</span><span class="s4">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s1">kw1</span><span class="s4">=</span><span class="s5">3</span><span class="s4">, </span><span class="s1">kw2</span><span class="s4">=</span><span class="s5">4</span><span class="s4">)</span>

    <span class="s3">with </span><span class="s1">raises</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">) </span><span class="s3">as </span><span class="s1">excinfo</span><span class="s4">:</span>
        <span class="s1">func_cached</span><span class="s4">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s1">kw2</span><span class="s4">=</span><span class="s5">4</span><span class="s4">)</span>
    <span class="s1">excinfo</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s6">&quot;Keyword-only parameter 'kw1' was passed as positional &quot;</span>
                  <span class="s6">&quot;parameter&quot;</span><span class="s4">)</span>

    <span class="s2"># Test 'ignore' parameter</span>
    <span class="s1">func_cached </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">func_with_kwonly_args</span><span class="s4">, </span><span class="s1">ignore</span><span class="s4">=[</span><span class="s6">'kw2'</span><span class="s4">])</span>
    <span class="s3">assert </span><span class="s1">func_cached</span><span class="s4">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s1">kw1</span><span class="s4">=</span><span class="s5">3</span><span class="s4">, </span><span class="s1">kw2</span><span class="s4">=</span><span class="s5">4</span><span class="s4">) == (</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s5">4</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">func_cached</span><span class="s4">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s1">kw1</span><span class="s4">=</span><span class="s5">3</span><span class="s4">, </span><span class="s1">kw2</span><span class="s4">=</span><span class="s6">'ignored'</span><span class="s4">) == (</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2</span><span class="s4">, </span><span class="s5">3</span><span class="s4">, </span><span class="s5">4</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_memory_func_with_signature</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">func_cached </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">func_with_signature</span><span class="s4">)</span>

    <span class="s3">assert </span><span class="s1">func_cached</span><span class="s4">(</span><span class="s5">1</span><span class="s4">, </span><span class="s5">2.</span><span class="s4">) == </span><span class="s5">3.</span>


<span class="s3">def </span><span class="s1">_setup_toy_cache</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">, </span><span class="s1">num_inputs</span><span class="s4">=</span><span class="s5">10</span><span class="s4">):</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">()</span>
    <span class="s3">def </span><span class="s1">get_1000_bytes</span><span class="s4">(</span><span class="s1">arg</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s6">'a' </span><span class="s4">* </span><span class="s5">1000</span>

    <span class="s1">inputs </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">range</span><span class="s4">(</span><span class="s1">num_inputs</span><span class="s4">))</span>
    <span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">inputs</span><span class="s4">:</span>
        <span class="s1">get_1000_bytes</span><span class="s4">(</span><span class="s1">arg</span><span class="s4">)</span>

    <span class="s1">func_id </span><span class="s4">= </span><span class="s1">_build_func_identifier</span><span class="s4">(</span><span class="s1">get_1000_bytes</span><span class="s4">)</span>
    <span class="s1">hash_dirnames </span><span class="s4">= [</span><span class="s1">get_1000_bytes</span><span class="s4">.</span><span class="s1">_get_args_id</span><span class="s4">(</span><span class="s1">arg</span><span class="s4">)</span>
                     <span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">inputs</span><span class="s4">]</span>

    <span class="s1">full_hashdirs </span><span class="s4">= [</span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">get_1000_bytes</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">location</span><span class="s4">,</span>
                                  <span class="s1">func_id</span><span class="s4">, </span><span class="s1">dirname</span><span class="s4">)</span>
                     <span class="s3">for </span><span class="s1">dirname </span><span class="s3">in </span><span class="s1">hash_dirnames</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">memory</span><span class="s4">, </span><span class="s1">full_hashdirs</span><span class="s4">, </span><span class="s1">get_1000_bytes</span>


<span class="s3">def </span><span class="s1">test__get_items</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s1">memory</span><span class="s4">, </span><span class="s1">expected_hash_dirs</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">_setup_toy_cache</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">)</span>
    <span class="s1">items </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>
    <span class="s1">hash_dirs </span><span class="s4">= [</span><span class="s1">ci</span><span class="s4">.</span><span class="s1">path </span><span class="s3">for </span><span class="s1">ci </span><span class="s3">in </span><span class="s1">items</span><span class="s4">]</span>
    <span class="s3">assert </span><span class="s1">set</span><span class="s4">(</span><span class="s1">hash_dirs</span><span class="s4">) == </span><span class="s1">set</span><span class="s4">(</span><span class="s1">expected_hash_dirs</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_files_size</span><span class="s4">(</span><span class="s1">directory</span><span class="s4">):</span>
        <span class="s1">full_paths </span><span class="s4">= [</span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">directory</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">)</span>
                      <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">os</span><span class="s4">.</span><span class="s1">listdir</span><span class="s4">(</span><span class="s1">directory</span><span class="s4">)]</span>
        <span class="s3">return </span><span class="s1">sum</span><span class="s4">(</span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">getsize</span><span class="s4">(</span><span class="s1">fp</span><span class="s4">) </span><span class="s3">for </span><span class="s1">fp </span><span class="s3">in </span><span class="s1">full_paths</span><span class="s4">)</span>

    <span class="s1">expected_hash_cache_sizes </span><span class="s4">= [</span><span class="s1">get_files_size</span><span class="s4">(</span><span class="s1">hash_dir</span><span class="s4">)</span>
                                 <span class="s3">for </span><span class="s1">hash_dir </span><span class="s3">in </span><span class="s1">hash_dirs</span><span class="s4">]</span>
    <span class="s1">hash_cache_sizes </span><span class="s4">= [</span><span class="s1">ci</span><span class="s4">.</span><span class="s1">size </span><span class="s3">for </span><span class="s1">ci </span><span class="s3">in </span><span class="s1">items</span><span class="s4">]</span>
    <span class="s3">assert </span><span class="s1">hash_cache_sizes </span><span class="s4">== </span><span class="s1">expected_hash_cache_sizes</span>

    <span class="s1">output_filenames </span><span class="s4">= [</span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">hash_dir</span><span class="s4">, </span><span class="s6">'output.pkl'</span><span class="s4">)</span>
                        <span class="s3">for </span><span class="s1">hash_dir </span><span class="s3">in </span><span class="s1">hash_dirs</span><span class="s4">]</span>

    <span class="s1">expected_last_accesses </span><span class="s4">= [</span>
        <span class="s1">datetime</span><span class="s4">.</span><span class="s1">datetime</span><span class="s4">.</span><span class="s1">fromtimestamp</span><span class="s4">(</span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">getatime</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">))</span>
        <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">output_filenames</span><span class="s4">]</span>
    <span class="s1">last_accesses </span><span class="s4">= [</span><span class="s1">ci</span><span class="s4">.</span><span class="s1">last_access </span><span class="s3">for </span><span class="s1">ci </span><span class="s3">in </span><span class="s1">items</span><span class="s4">]</span>
    <span class="s3">assert </span><span class="s1">last_accesses </span><span class="s4">== </span><span class="s1">expected_last_accesses</span>


<span class="s3">def </span><span class="s1">test__get_items_to_delete</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s2"># test empty cache</span>
    <span class="s1">memory</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">_setup_toy_cache</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">, </span><span class="s1">num_inputs</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">items_to_delete </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">_get_items_to_delete</span><span class="s4">(</span><span class="s6">'1K'</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">items_to_delete </span><span class="s4">== []</span>

    <span class="s1">memory</span><span class="s4">, </span><span class="s1">expected_hash_cachedirs</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">_setup_toy_cache</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">)</span>
    <span class="s1">items </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>
    <span class="s2"># bytes_limit set to keep only one cache item (each hash cache</span>
    <span class="s2"># folder is about 1000 bytes + metadata)</span>
    <span class="s1">items_to_delete </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">_get_items_to_delete</span><span class="s4">(</span><span class="s6">'2K'</span><span class="s4">)</span>
    <span class="s1">nb_hashes </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">expected_hash_cachedirs</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">set</span><span class="s4">.</span><span class="s1">issubset</span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s1">items_to_delete</span><span class="s4">), </span><span class="s1">set</span><span class="s4">(</span><span class="s1">items</span><span class="s4">))</span>
    <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">items_to_delete</span><span class="s4">) == </span><span class="s1">nb_hashes </span><span class="s4">- </span><span class="s5">1</span>

    <span class="s2"># Sanity check bytes_limit=2048 is the same as bytes_limit='2K'</span>
    <span class="s1">items_to_delete_2048b </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">_get_items_to_delete</span><span class="s4">(</span><span class="s5">2048</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">items_to_delete</span><span class="s4">) == </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">items_to_delete_2048b</span><span class="s4">)</span>

    <span class="s2"># bytes_limit greater than the size of the cache</span>
    <span class="s1">items_to_delete_empty </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">_get_items_to_delete</span><span class="s4">(</span><span class="s6">'1M'</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">items_to_delete_empty </span><span class="s4">== []</span>

    <span class="s2"># All the cache items need to be deleted</span>
    <span class="s1">bytes_limit_too_small </span><span class="s4">= </span><span class="s5">500</span>
    <span class="s1">items_to_delete_500b </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">_get_items_to_delete</span><span class="s4">(</span>
        <span class="s1">bytes_limit_too_small</span>
    <span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">set</span><span class="s4">(</span><span class="s1">items_to_delete_500b</span><span class="s4">), </span><span class="s1">set</span><span class="s4">(</span><span class="s1">items</span><span class="s4">)</span>

    <span class="s2"># Test LRU property: surviving cache items should all have a more</span>
    <span class="s2"># recent last_access that the ones that have been deleted</span>
    <span class="s1">items_to_delete_6000b </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">_get_items_to_delete</span><span class="s4">(</span><span class="s5">6000</span><span class="s4">)</span>
    <span class="s1">surviving_items </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">items</span><span class="s4">).</span><span class="s1">difference</span><span class="s4">(</span><span class="s1">items_to_delete_6000b</span><span class="s4">)</span>

    <span class="s3">assert </span><span class="s4">(</span><span class="s1">max</span><span class="s4">(</span><span class="s1">ci</span><span class="s4">.</span><span class="s1">last_access </span><span class="s3">for </span><span class="s1">ci </span><span class="s3">in </span><span class="s1">items_to_delete_6000b</span><span class="s4">) &lt;=</span>
            <span class="s1">min</span><span class="s4">(</span><span class="s1">ci</span><span class="s4">.</span><span class="s1">last_access </span><span class="s3">for </span><span class="s1">ci </span><span class="s3">in </span><span class="s1">surviving_items</span><span class="s4">))</span>


<span class="s3">def </span><span class="s1">test_memory_reduce_size_bytes_limit</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s1">memory</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">_setup_toy_cache</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">)</span>
    <span class="s1">ref_cache_items </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>

    <span class="s2"># By default memory.bytes_limit is None and reduce_size is a noop</span>
    <span class="s1">memory</span><span class="s4">.</span><span class="s1">reduce_size</span><span class="s4">()</span>
    <span class="s1">cache_items </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>
    <span class="s3">assert </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">ref_cache_items</span><span class="s4">) == </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">cache_items</span><span class="s4">)</span>

    <span class="s2"># No cache items deleted if bytes_limit greater than the size of</span>
    <span class="s2"># the cache</span>
    <span class="s1">memory</span><span class="s4">.</span><span class="s1">reduce_size</span><span class="s4">(</span><span class="s1">bytes_limit</span><span class="s4">=</span><span class="s6">'1M'</span><span class="s4">)</span>
    <span class="s1">cache_items </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>
    <span class="s3">assert </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">ref_cache_items</span><span class="s4">) == </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">cache_items</span><span class="s4">)</span>

    <span class="s2"># bytes_limit is set so that only two cache items are kept</span>
    <span class="s1">memory</span><span class="s4">.</span><span class="s1">reduce_size</span><span class="s4">(</span><span class="s1">bytes_limit</span><span class="s4">=</span><span class="s6">'3K'</span><span class="s4">)</span>
    <span class="s1">cache_items </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>
    <span class="s3">assert </span><span class="s1">set</span><span class="s4">.</span><span class="s1">issubset</span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s1">cache_items</span><span class="s4">), </span><span class="s1">set</span><span class="s4">(</span><span class="s1">ref_cache_items</span><span class="s4">))</span>
    <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">cache_items</span><span class="s4">) == </span><span class="s5">2</span>

    <span class="s2"># bytes_limit set so that no cache item is kept</span>
    <span class="s1">bytes_limit_too_small </span><span class="s4">= </span><span class="s5">500</span>
    <span class="s1">memory</span><span class="s4">.</span><span class="s1">reduce_size</span><span class="s4">(</span><span class="s1">bytes_limit</span><span class="s4">=</span><span class="s1">bytes_limit_too_small</span><span class="s4">)</span>
    <span class="s1">cache_items </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>
    <span class="s3">assert </span><span class="s1">cache_items </span><span class="s4">== []</span>


<span class="s3">def </span><span class="s1">test_memory_reduce_size_items_limit</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s1">memory</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">_setup_toy_cache</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">)</span>
    <span class="s1">ref_cache_items </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>

    <span class="s2"># By default reduce_size is a noop</span>
    <span class="s1">memory</span><span class="s4">.</span><span class="s1">reduce_size</span><span class="s4">()</span>
    <span class="s1">cache_items </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>
    <span class="s3">assert </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">ref_cache_items</span><span class="s4">) == </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">cache_items</span><span class="s4">)</span>

    <span class="s2"># No cache items deleted if items_limit greater than the size of</span>
    <span class="s2"># the cache</span>
    <span class="s1">memory</span><span class="s4">.</span><span class="s1">reduce_size</span><span class="s4">(</span><span class="s1">items_limit</span><span class="s4">=</span><span class="s5">10</span><span class="s4">)</span>
    <span class="s1">cache_items </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>
    <span class="s3">assert </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">ref_cache_items</span><span class="s4">) == </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">cache_items</span><span class="s4">)</span>

    <span class="s2"># items_limit is set so that only two cache items are kept</span>
    <span class="s1">memory</span><span class="s4">.</span><span class="s1">reduce_size</span><span class="s4">(</span><span class="s1">items_limit</span><span class="s4">=</span><span class="s5">2</span><span class="s4">)</span>
    <span class="s1">cache_items </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>
    <span class="s3">assert </span><span class="s1">set</span><span class="s4">.</span><span class="s1">issubset</span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s1">cache_items</span><span class="s4">), </span><span class="s1">set</span><span class="s4">(</span><span class="s1">ref_cache_items</span><span class="s4">))</span>
    <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">cache_items</span><span class="s4">) == </span><span class="s5">2</span>

    <span class="s2"># item_limit set so that no cache item is kept</span>
    <span class="s1">memory</span><span class="s4">.</span><span class="s1">reduce_size</span><span class="s4">(</span><span class="s1">items_limit</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">cache_items </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>
    <span class="s3">assert </span><span class="s1">cache_items </span><span class="s4">== []</span>


<span class="s3">def </span><span class="s1">test_memory_reduce_size_age_limit</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s3">import </span><span class="s1">time</span>
    <span class="s3">import </span><span class="s1">datetime</span>
    <span class="s1">memory</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">put_cache </span><span class="s4">= </span><span class="s1">_setup_toy_cache</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">)</span>
    <span class="s1">ref_cache_items </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>

    <span class="s2"># By default reduce_size is a noop</span>
    <span class="s1">memory</span><span class="s4">.</span><span class="s1">reduce_size</span><span class="s4">()</span>
    <span class="s1">cache_items </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>
    <span class="s3">assert </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">ref_cache_items</span><span class="s4">) == </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">cache_items</span><span class="s4">)</span>

    <span class="s2"># No cache items deleted if age_limit big.</span>
    <span class="s1">memory</span><span class="s4">.</span><span class="s1">reduce_size</span><span class="s4">(</span><span class="s1">age_limit</span><span class="s4">=</span><span class="s1">datetime</span><span class="s4">.</span><span class="s1">timedelta</span><span class="s4">(</span><span class="s1">days</span><span class="s4">=</span><span class="s5">1</span><span class="s4">))</span>
    <span class="s1">cache_items </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>
    <span class="s3">assert </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">ref_cache_items</span><span class="s4">) == </span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">cache_items</span><span class="s4">)</span>

    <span class="s2"># age_limit is set so that only two cache items are kept</span>
    <span class="s1">time</span><span class="s4">.</span><span class="s1">sleep</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s1">put_cache</span><span class="s4">(-</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s1">put_cache</span><span class="s4">(-</span><span class="s5">2</span><span class="s4">)</span>
    <span class="s1">memory</span><span class="s4">.</span><span class="s1">reduce_size</span><span class="s4">(</span><span class="s1">age_limit</span><span class="s4">=</span><span class="s1">datetime</span><span class="s4">.</span><span class="s1">timedelta</span><span class="s4">(</span><span class="s1">seconds</span><span class="s4">=</span><span class="s5">1</span><span class="s4">))</span>
    <span class="s1">cache_items </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>
    <span class="s3">assert not </span><span class="s1">set</span><span class="s4">.</span><span class="s1">issubset</span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s1">cache_items</span><span class="s4">), </span><span class="s1">set</span><span class="s4">(</span><span class="s1">ref_cache_items</span><span class="s4">))</span>
    <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">cache_items</span><span class="s4">) == </span><span class="s5">2</span>

    <span class="s2"># age_limit set so that no cache item is kept</span>
    <span class="s1">memory</span><span class="s4">.</span><span class="s1">reduce_size</span><span class="s4">(</span><span class="s1">age_limit</span><span class="s4">=</span><span class="s1">datetime</span><span class="s4">.</span><span class="s1">timedelta</span><span class="s4">(</span><span class="s1">seconds</span><span class="s4">=</span><span class="s5">0</span><span class="s4">))</span>
    <span class="s1">cache_items </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">get_items</span><span class="s4">()</span>
    <span class="s3">assert </span><span class="s1">cache_items </span><span class="s4">== []</span>


<span class="s3">def </span><span class="s1">test_memory_clear</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s1">memory</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">g </span><span class="s4">= </span><span class="s1">_setup_toy_cache</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">)</span>
    <span class="s1">memory</span><span class="s4">.</span><span class="s1">clear</span><span class="s4">()</span>

    <span class="s3">assert </span><span class="s1">os</span><span class="s4">.</span><span class="s1">listdir</span><span class="s4">(</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">location</span><span class="s4">) == []</span>

    <span class="s2"># Check that the cache for functions hash is also reset.</span>
    <span class="s3">assert not </span><span class="s1">g</span><span class="s4">.</span><span class="s1">_check_previous_func_code</span><span class="s4">(</span><span class="s1">stacklevel</span><span class="s4">=</span><span class="s5">4</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">fast_func_with_complex_output</span><span class="s4">():</span>
    <span class="s1">complex_obj </span><span class="s4">= [</span><span class="s6">'a' </span><span class="s4">* </span><span class="s5">1000</span><span class="s4">] * </span><span class="s5">1000</span>
    <span class="s3">return </span><span class="s1">complex_obj</span>


<span class="s3">def </span><span class="s1">fast_func_with_conditional_complex_output</span><span class="s4">(</span><span class="s1">complex_output</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
    <span class="s1">complex_obj </span><span class="s4">= {</span><span class="s1">str</span><span class="s4">(</span><span class="s1">i</span><span class="s4">): </span><span class="s1">i </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">int</span><span class="s4">(</span><span class="s5">1e5</span><span class="s4">))}</span>
    <span class="s3">return </span><span class="s1">complex_obj </span><span class="s3">if </span><span class="s1">complex_output </span><span class="s3">else </span><span class="s6">'simple output'</span>


<span class="s4">@</span><span class="s1">with_multiprocessing</span>
<span class="s3">def </span><span class="s1">test_cached_function_race_condition_when_persisting_output</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">, </span><span class="s1">capfd</span><span class="s4">):</span>
    <span class="s2"># Test race condition where multiple processes are writing into</span>
    <span class="s2"># the same output.pkl. See</span>
    <span class="s2"># https://github.com/joblib/joblib/issues/490 for more details.</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">)</span>
    <span class="s1">func_cached </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">fast_func_with_complex_output</span><span class="s4">)</span>

    <span class="s1">Parallel</span><span class="s4">(</span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s5">2</span><span class="s4">)(</span><span class="s1">delayed</span><span class="s4">(</span><span class="s1">func_cached</span><span class="s4">)() </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s5">3</span><span class="s4">))</span>

    <span class="s1">stdout</span><span class="s4">, </span><span class="s1">stderr </span><span class="s4">= </span><span class="s1">capfd</span><span class="s4">.</span><span class="s1">readouterr</span><span class="s4">()</span>

    <span class="s2"># Checking both stdout and stderr (ongoing PR #434 may change</span>
    <span class="s2"># logging destination) to make sure there is no exception while</span>
    <span class="s2"># loading the results</span>
    <span class="s1">exception_msg </span><span class="s4">= </span><span class="s6">'Exception while loading results'</span>
    <span class="s3">assert </span><span class="s1">exception_msg </span><span class="s3">not in </span><span class="s1">stdout</span>
    <span class="s3">assert </span><span class="s1">exception_msg </span><span class="s3">not in </span><span class="s1">stderr</span>


<span class="s4">@</span><span class="s1">with_multiprocessing</span>
<span class="s3">def </span><span class="s1">test_cached_function_race_condition_when_persisting_output_2</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">,</span>
                                                                 <span class="s1">capfd</span><span class="s4">):</span>
    <span class="s2"># Test race condition in first attempt at solving</span>
    <span class="s2"># https://github.com/joblib/joblib/issues/490. The race condition</span>
    <span class="s2"># was due to the delay between seeing the cache directory created</span>
    <span class="s2"># (interpreted as the result being cached) and the output.pkl being</span>
    <span class="s2"># pickled.</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">)</span>
    <span class="s1">func_cached </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">fast_func_with_conditional_complex_output</span><span class="s4">)</span>

    <span class="s1">Parallel</span><span class="s4">(</span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s5">2</span><span class="s4">)(</span><span class="s1">delayed</span><span class="s4">(</span><span class="s1">func_cached</span><span class="s4">)(</span><span class="s3">True if </span><span class="s1">i </span><span class="s4">% </span><span class="s5">2 </span><span class="s4">== </span><span class="s5">0 </span><span class="s3">else False</span><span class="s4">)</span>
                       <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s5">3</span><span class="s4">))</span>

    <span class="s1">stdout</span><span class="s4">, </span><span class="s1">stderr </span><span class="s4">= </span><span class="s1">capfd</span><span class="s4">.</span><span class="s1">readouterr</span><span class="s4">()</span>

    <span class="s2"># Checking both stdout and stderr (ongoing PR #434 may change</span>
    <span class="s2"># logging destination) to make sure there is no exception while</span>
    <span class="s2"># loading the results</span>
    <span class="s1">exception_msg </span><span class="s4">= </span><span class="s6">'Exception while loading results'</span>
    <span class="s3">assert </span><span class="s1">exception_msg </span><span class="s3">not in </span><span class="s1">stdout</span>
    <span class="s3">assert </span><span class="s1">exception_msg </span><span class="s3">not in </span><span class="s1">stderr</span>


<span class="s3">def </span><span class="s1">test_memory_recomputes_after_an_error_while_loading_results</span><span class="s4">(</span>
        <span class="s1">tmpdir</span><span class="s4">, </span><span class="s1">monkeypatch</span><span class="s4">):</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">func</span><span class="s4">(</span><span class="s1">arg</span><span class="s4">):</span>
        <span class="s2"># This makes sure that the timestamp returned by two calls of</span>
        <span class="s2"># func are different. This is needed on Windows where</span>
        <span class="s2"># time.time resolution may not be accurate enough</span>
        <span class="s1">time</span><span class="s4">.</span><span class="s1">sleep</span><span class="s4">(</span><span class="s5">0.01</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">arg</span><span class="s4">, </span><span class="s1">time</span><span class="s4">.</span><span class="s1">time</span><span class="s4">()</span>

    <span class="s1">cached_func </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">func</span><span class="s4">)</span>
    <span class="s1">input_arg </span><span class="s4">= </span><span class="s6">'arg'</span>
    <span class="s1">arg</span><span class="s4">, </span><span class="s1">timestamp </span><span class="s4">= </span><span class="s1">cached_func</span><span class="s4">(</span><span class="s1">input_arg</span><span class="s4">)</span>

    <span class="s2"># Make sure the function is correctly cached</span>
    <span class="s3">assert </span><span class="s1">arg </span><span class="s4">== </span><span class="s1">input_arg</span>

    <span class="s2"># Corrupting output.pkl to make sure that an error happens when</span>
    <span class="s2"># loading the cached result</span>
    <span class="s1">corrupt_single_cache_item</span><span class="s4">(</span><span class="s1">memory</span><span class="s4">)</span>

    <span class="s2"># Make sure that corrupting the file causes recomputation and that</span>
    <span class="s2"># a warning is issued.</span>
    <span class="s1">recorded_warnings </span><span class="s4">= </span><span class="s1">monkeypatch_cached_func_warn</span><span class="s4">(</span><span class="s1">cached_func</span><span class="s4">, </span><span class="s1">monkeypatch</span><span class="s4">)</span>
    <span class="s1">recomputed_arg</span><span class="s4">, </span><span class="s1">recomputed_timestamp </span><span class="s4">= </span><span class="s1">cached_func</span><span class="s4">(</span><span class="s1">arg</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">len</span><span class="s4">(</span><span class="s1">recorded_warnings</span><span class="s4">) == </span><span class="s5">1</span>
    <span class="s1">exception_msg </span><span class="s4">= </span><span class="s6">'Exception while loading results'</span>
    <span class="s3">assert </span><span class="s1">exception_msg </span><span class="s3">in </span><span class="s1">recorded_warnings</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
    <span class="s3">assert </span><span class="s1">recomputed_arg </span><span class="s4">== </span><span class="s1">arg</span>
    <span class="s3">assert </span><span class="s1">recomputed_timestamp </span><span class="s4">&gt; </span><span class="s1">timestamp</span>

    <span class="s2"># Corrupting output.pkl to make sure that an error happens when</span>
    <span class="s2"># loading the cached result</span>
    <span class="s1">corrupt_single_cache_item</span><span class="s4">(</span><span class="s1">memory</span><span class="s4">)</span>
    <span class="s1">reference </span><span class="s4">= </span><span class="s1">cached_func</span><span class="s4">.</span><span class="s1">call_and_shelve</span><span class="s4">(</span><span class="s1">arg</span><span class="s4">)</span>
    <span class="s3">try</span><span class="s4">:</span>
        <span class="s1">reference</span><span class="s4">.</span><span class="s1">get</span><span class="s4">()</span>
        <span class="s3">raise </span><span class="s1">AssertionError</span><span class="s4">(</span>
            <span class="s6">&quot;It normally not possible to load a corrupted&quot;</span>
            <span class="s6">&quot; MemorizedResult&quot;</span>
        <span class="s4">)</span>
    <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
        <span class="s1">message </span><span class="s4">= </span><span class="s6">&quot;is corrupted&quot;</span>
        <span class="s3">assert </span><span class="s1">message </span><span class="s3">in </span><span class="s1">str</span><span class="s4">(</span><span class="s1">e</span><span class="s4">.</span><span class="s1">args</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">IncompleteStoreBackend</span><span class="s4">(</span><span class="s1">StoreBackendBase</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;This backend cannot be instantiated and should raise a TypeError.&quot;&quot;&quot;</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">DummyStoreBackend</span><span class="s4">(</span><span class="s1">StoreBackendBase</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;A dummy store backend that does nothing.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">_open_item</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Open an item on store.&quot;&quot;&quot;</span>
        <span class="s6">&quot;Does nothing&quot;</span>

    <span class="s3">def </span><span class="s1">_item_exists</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">location</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Check if an item location exists.&quot;&quot;&quot;</span>
        <span class="s6">&quot;Does nothing&quot;</span>

    <span class="s3">def </span><span class="s1">_move_item</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">src</span><span class="s4">, </span><span class="s1">dst</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Move an item from src to dst in store.&quot;&quot;&quot;</span>
        <span class="s6">&quot;Does nothing&quot;</span>

    <span class="s3">def </span><span class="s1">create_location</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">location</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Create location on store.&quot;&quot;&quot;</span>
        <span class="s6">&quot;Does nothing&quot;</span>

    <span class="s3">def </span><span class="s1">exists</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Check if an object exists in the store&quot;&quot;&quot;</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">clear_location</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Clear object on store&quot;&quot;&quot;</span>
        <span class="s6">&quot;Does nothing&quot;</span>

    <span class="s3">def </span><span class="s1">get_items</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Returns the whole list of items available in cache.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s4">[]</span>

    <span class="s3">def </span><span class="s1">configure</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">location</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Configure the store&quot;&quot;&quot;</span>
        <span class="s6">&quot;Does nothing&quot;</span>


<span class="s4">@</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;invalid_prefix&quot;</span><span class="s4">, [</span><span class="s3">None</span><span class="s4">, </span><span class="s1">dict</span><span class="s4">(), </span><span class="s1">list</span><span class="s4">()])</span>
<span class="s3">def </span><span class="s1">test_register_invalid_store_backends_key</span><span class="s4">(</span><span class="s1">invalid_prefix</span><span class="s4">):</span>
    <span class="s2"># verify the right exceptions are raised when passing a wrong backend key.</span>
    <span class="s3">with </span><span class="s1">raises</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">) </span><span class="s3">as </span><span class="s1">excinfo</span><span class="s4">:</span>
        <span class="s1">register_store_backend</span><span class="s4">(</span><span class="s1">invalid_prefix</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
    <span class="s1">excinfo</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s6">r'Store backend name should be a string*'</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_register_invalid_store_backends_object</span><span class="s4">():</span>
    <span class="s2"># verify the right exceptions are raised when passing a wrong backend</span>
    <span class="s2"># object.</span>
    <span class="s3">with </span><span class="s1">raises</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">) </span><span class="s3">as </span><span class="s1">excinfo</span><span class="s4">:</span>
        <span class="s1">register_store_backend</span><span class="s4">(</span><span class="s6">&quot;fs&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
    <span class="s1">excinfo</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s6">r'Store backend should inherit StoreBackendBase*'</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_memory_default_store_backend</span><span class="s4">():</span>
    <span class="s2"># test an unknown backend falls back into a FileSystemStoreBackend</span>
    <span class="s3">with </span><span class="s1">raises</span><span class="s4">(</span><span class="s1">TypeError</span><span class="s4">) </span><span class="s3">as </span><span class="s1">excinfo</span><span class="s4">:</span>
        <span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s6">'/tmp/joblib'</span><span class="s4">, </span><span class="s1">backend</span><span class="s4">=</span><span class="s6">'unknown'</span><span class="s4">)</span>
    <span class="s1">excinfo</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s6">r&quot;Unknown location*&quot;</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_warning_on_unknown_location_type</span><span class="s4">():</span>
    <span class="s3">class </span><span class="s1">NonSupportedLocationClass</span><span class="s4">:</span>
        <span class="s3">pass</span>
    <span class="s1">unsupported_location </span><span class="s4">= </span><span class="s1">NonSupportedLocationClass</span><span class="s4">()</span>

    <span class="s3">with </span><span class="s1">warns</span><span class="s4">(</span><span class="s1">UserWarning</span><span class="s4">) </span><span class="s3">as </span><span class="s1">warninfo</span><span class="s4">:</span>
        <span class="s1">_store_backend_factory</span><span class="s4">(</span><span class="s6">&quot;local&quot;</span><span class="s4">, </span><span class="s1">location</span><span class="s4">=</span><span class="s1">unsupported_location</span><span class="s4">)</span>

    <span class="s1">expected_mesage </span><span class="s4">= (</span><span class="s6">&quot;Instantiating a backend using a &quot;</span>
                       <span class="s6">&quot;NonSupportedLocationClass as a location is not &quot;</span>
                       <span class="s6">&quot;supported by joblib&quot;</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">expected_mesage </span><span class="s3">in </span><span class="s1">str</span><span class="s4">(</span><span class="s1">warninfo</span><span class="s4">[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">message</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_instanciate_incomplete_store_backend</span><span class="s4">():</span>
    <span class="s2"># Verify that registering an external incomplete store backend raises an</span>
    <span class="s2"># exception when one tries to instantiate it.</span>
    <span class="s1">backend_name </span><span class="s4">= </span><span class="s6">&quot;isb&quot;</span>
    <span class="s1">register_store_backend</span><span class="s4">(</span><span class="s1">backend_name</span><span class="s4">, </span><span class="s1">IncompleteStoreBackend</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s4">(</span><span class="s1">backend_name</span><span class="s4">, </span><span class="s1">IncompleteStoreBackend</span><span class="s4">) </span><span class="s3">in </span><span class="s1">_STORE_BACKENDS</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()</span>
    <span class="s3">with </span><span class="s1">raises</span><span class="s4">(</span><span class="s1">TypeError</span><span class="s4">) </span><span class="s3">as </span><span class="s1">excinfo</span><span class="s4">:</span>
        <span class="s1">_store_backend_factory</span><span class="s4">(</span><span class="s1">backend_name</span><span class="s4">, </span><span class="s6">&quot;fake_location&quot;</span><span class="s4">)</span>
    <span class="s1">excinfo</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s6">r&quot;Can't instantiate abstract class IncompleteStoreBackend &quot;</span>
                  <span class="s6">&quot;(without an implementation for|with) abstract methods*&quot;</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_dummy_store_backend</span><span class="s4">():</span>
    <span class="s2"># Verify that registering an external store backend works.</span>

    <span class="s1">backend_name </span><span class="s4">= </span><span class="s6">&quot;dsb&quot;</span>
    <span class="s1">register_store_backend</span><span class="s4">(</span><span class="s1">backend_name</span><span class="s4">, </span><span class="s1">DummyStoreBackend</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s4">(</span><span class="s1">backend_name</span><span class="s4">, </span><span class="s1">DummyStoreBackend</span><span class="s4">) </span><span class="s3">in </span><span class="s1">_STORE_BACKENDS</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()</span>

    <span class="s1">backend_obj </span><span class="s4">= </span><span class="s1">_store_backend_factory</span><span class="s4">(</span><span class="s1">backend_name</span><span class="s4">, </span><span class="s6">&quot;dummy_location&quot;</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">backend_obj</span><span class="s4">, </span><span class="s1">DummyStoreBackend</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_instanciate_store_backend_with_pathlib_path</span><span class="s4">():</span>
    <span class="s2"># Instantiate a FileSystemStoreBackend using a pathlib.Path object</span>
    <span class="s1">path </span><span class="s4">= </span><span class="s1">pathlib</span><span class="s4">.</span><span class="s1">Path</span><span class="s4">(</span><span class="s6">&quot;some_folder&quot;</span><span class="s4">)</span>
    <span class="s1">backend_obj </span><span class="s4">= </span><span class="s1">_store_backend_factory</span><span class="s4">(</span><span class="s6">&quot;local&quot;</span><span class="s4">, </span><span class="s1">path</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">backend_obj</span><span class="s4">.</span><span class="s1">location </span><span class="s4">== </span><span class="s6">&quot;some_folder&quot;</span>


<span class="s3">def </span><span class="s1">test_filesystem_store_backend_repr</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s2"># Verify string representation of a filesystem store backend.</span>

    <span class="s1">repr_pattern </span><span class="s4">= </span><span class="s6">'FileSystemStoreBackend(location=&quot;{location}&quot;)'</span>
    <span class="s1">backend </span><span class="s4">= </span><span class="s1">FileSystemStoreBackend</span><span class="s4">()</span>
    <span class="s3">assert </span><span class="s1">backend</span><span class="s4">.</span><span class="s1">location </span><span class="s3">is None</span>

    <span class="s1">repr</span><span class="s4">(</span><span class="s1">backend</span><span class="s4">)  </span><span class="s2"># Should not raise an exception</span>

    <span class="s3">assert </span><span class="s1">str</span><span class="s4">(</span><span class="s1">backend</span><span class="s4">) == </span><span class="s1">repr_pattern</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s3">None</span><span class="s4">)</span>

    <span class="s2"># backend location is passed explicitly via the configure method (called</span>
    <span class="s2"># by the internal _store_backend_factory function)</span>
    <span class="s1">backend</span><span class="s4">.</span><span class="s1">configure</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">)</span>

    <span class="s3">assert </span><span class="s1">str</span><span class="s4">(</span><span class="s1">backend</span><span class="s4">) == </span><span class="s1">repr_pattern</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">)</span>

    <span class="s1">repr</span><span class="s4">(</span><span class="s1">backend</span><span class="s4">)  </span><span class="s2"># Should not raise an exception</span>


<span class="s3">def </span><span class="s1">test_memory_objects_repr</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s2"># Verify printable reprs of MemorizedResult, MemorizedFunc and Memory.</span>

    <span class="s3">def </span><span class="s1">my_func</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">a </span><span class="s4">+ </span><span class="s1">b</span>

    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">memorized_func </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">my_func</span><span class="s4">)</span>

    <span class="s1">memorized_func_repr </span><span class="s4">= </span><span class="s6">'MemorizedFunc(func={func}, location={location})'</span>

    <span class="s3">assert </span><span class="s1">str</span><span class="s4">(</span><span class="s1">memorized_func</span><span class="s4">) == </span><span class="s1">memorized_func_repr</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span>
        <span class="s1">func</span><span class="s4">=</span><span class="s1">my_func</span><span class="s4">,</span>
        <span class="s1">location</span><span class="s4">=</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">location</span><span class="s4">)</span>

    <span class="s1">memorized_result </span><span class="s4">= </span><span class="s1">memorized_func</span><span class="s4">.</span><span class="s1">call_and_shelve</span><span class="s4">(</span><span class="s5">42</span><span class="s4">, </span><span class="s5">42</span><span class="s4">)</span>

    <span class="s1">memorized_result_repr </span><span class="s4">= (</span><span class="s6">'MemorizedResult(location=&quot;{location}&quot;, '</span>
                             <span class="s6">'func=&quot;{func}&quot;, args_id=&quot;{args_id}&quot;)'</span><span class="s4">)</span>

    <span class="s3">assert </span><span class="s1">str</span><span class="s4">(</span><span class="s1">memorized_result</span><span class="s4">) == </span><span class="s1">memorized_result_repr</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span>
        <span class="s1">location</span><span class="s4">=</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">location</span><span class="s4">,</span>
        <span class="s1">func</span><span class="s4">=</span><span class="s1">memorized_result</span><span class="s4">.</span><span class="s1">func_id</span><span class="s4">,</span>
        <span class="s1">args_id</span><span class="s4">=</span><span class="s1">memorized_result</span><span class="s4">.</span><span class="s1">args_id</span><span class="s4">)</span>

    <span class="s3">assert </span><span class="s1">str</span><span class="s4">(</span><span class="s1">memory</span><span class="s4">) == </span><span class="s6">'Memory(location={location})'</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span>
        <span class="s1">location</span><span class="s4">=</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">location</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_memorized_result_pickle</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s2"># Verify a MemoryResult object can be pickled/depickled. Non regression</span>
    <span class="s2"># test introduced following issue</span>
    <span class="s2"># https://github.com/joblib/joblib/issues/747</span>

    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">g</span><span class="s4">(</span><span class="s1">x</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s4">**</span><span class="s5">2</span>

    <span class="s1">memorized_result </span><span class="s4">= </span><span class="s1">g</span><span class="s4">.</span><span class="s1">call_and_shelve</span><span class="s4">(</span><span class="s5">4</span><span class="s4">)</span>
    <span class="s1">memorized_result_pickle </span><span class="s4">= </span><span class="s1">pickle</span><span class="s4">.</span><span class="s1">dumps</span><span class="s4">(</span><span class="s1">memorized_result</span><span class="s4">)</span>
    <span class="s1">memorized_result_loads </span><span class="s4">= </span><span class="s1">pickle</span><span class="s4">.</span><span class="s1">loads</span><span class="s4">(</span><span class="s1">memorized_result_pickle</span><span class="s4">)</span>

    <span class="s3">assert </span><span class="s1">memorized_result</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">location </span><span class="s4">== </span><span class="s1">\</span>
        <span class="s1">memorized_result_loads</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">.</span><span class="s1">location</span>
    <span class="s3">assert </span><span class="s1">memorized_result</span><span class="s4">.</span><span class="s1">func </span><span class="s4">== </span><span class="s1">memorized_result_loads</span><span class="s4">.</span><span class="s1">func</span>
    <span class="s3">assert </span><span class="s1">memorized_result</span><span class="s4">.</span><span class="s1">args_id </span><span class="s4">== </span><span class="s1">memorized_result_loads</span><span class="s4">.</span><span class="s1">args_id</span>
    <span class="s3">assert </span><span class="s1">str</span><span class="s4">(</span><span class="s1">memorized_result</span><span class="s4">) == </span><span class="s1">str</span><span class="s4">(</span><span class="s1">memorized_result_loads</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">compare</span><span class="s4">(</span><span class="s1">left</span><span class="s4">, </span><span class="s1">right</span><span class="s4">, </span><span class="s1">ignored_attrs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">ignored_attrs </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">ignored_attrs </span><span class="s4">= []</span>

    <span class="s1">left_vars </span><span class="s4">= </span><span class="s1">vars</span><span class="s4">(</span><span class="s1">left</span><span class="s4">)</span>
    <span class="s1">right_vars </span><span class="s4">= </span><span class="s1">vars</span><span class="s4">(</span><span class="s1">right</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">set</span><span class="s4">(</span><span class="s1">left_vars</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()) == </span><span class="s1">set</span><span class="s4">(</span><span class="s1">right_vars</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">())</span>
    <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">left_vars</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">():</span>
        <span class="s3">if </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">ignored_attrs</span><span class="s4">:</span>
            <span class="s3">continue</span>
        <span class="s3">assert </span><span class="s1">left_vars</span><span class="s4">[</span><span class="s1">attr</span><span class="s4">] == </span><span class="s1">right_vars</span><span class="s4">[</span><span class="s1">attr</span><span class="s4">]</span>


<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">'memory_kwargs'</span><span class="s4">,</span>
                         <span class="s4">[{</span><span class="s6">'compress'</span><span class="s4">: </span><span class="s5">3</span><span class="s4">, </span><span class="s6">'verbose'</span><span class="s4">: </span><span class="s5">2</span><span class="s4">},</span>
                          <span class="s4">{</span><span class="s6">'mmap_mode'</span><span class="s4">: </span><span class="s6">'r'</span><span class="s4">, </span><span class="s6">'verbose'</span><span class="s4">: </span><span class="s5">5</span><span class="s4">,</span>
                           <span class="s6">'backend_options'</span><span class="s4">: {</span><span class="s6">'parameter'</span><span class="s4">: </span><span class="s6">'unused'</span><span class="s4">}}])</span>
<span class="s3">def </span><span class="s1">test_memory_pickle_dump_load</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">, </span><span class="s1">memory_kwargs</span><span class="s4">):</span>
    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, **</span><span class="s1">memory_kwargs</span><span class="s4">)</span>

    <span class="s1">memory_reloaded </span><span class="s4">= </span><span class="s1">pickle</span><span class="s4">.</span><span class="s1">loads</span><span class="s4">(</span><span class="s1">pickle</span><span class="s4">.</span><span class="s1">dumps</span><span class="s4">(</span><span class="s1">memory</span><span class="s4">))</span>

    <span class="s2"># Compare Memory instance before and after pickle roundtrip</span>
    <span class="s1">compare</span><span class="s4">(</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">, </span><span class="s1">memory_reloaded</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">)</span>
    <span class="s1">compare</span><span class="s4">(</span><span class="s1">memory</span><span class="s4">, </span><span class="s1">memory_reloaded</span><span class="s4">,</span>
            <span class="s1">ignored_attrs</span><span class="s4">=</span><span class="s1">set</span><span class="s4">([</span><span class="s6">'store_backend'</span><span class="s4">, </span><span class="s6">'timestamp'</span><span class="s4">, </span><span class="s6">'_func_code_id'</span><span class="s4">]))</span>
    <span class="s3">assert </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">memory</span><span class="s4">) == </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">memory_reloaded</span><span class="s4">)</span>

    <span class="s1">func_cached </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>

    <span class="s1">func_cached_reloaded </span><span class="s4">= </span><span class="s1">pickle</span><span class="s4">.</span><span class="s1">loads</span><span class="s4">(</span><span class="s1">pickle</span><span class="s4">.</span><span class="s1">dumps</span><span class="s4">(</span><span class="s1">func_cached</span><span class="s4">))</span>

    <span class="s2"># Compare MemorizedFunc instance before/after pickle roundtrip</span>
    <span class="s1">compare</span><span class="s4">(</span><span class="s1">func_cached</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">, </span><span class="s1">func_cached_reloaded</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">)</span>
    <span class="s1">compare</span><span class="s4">(</span><span class="s1">func_cached</span><span class="s4">, </span><span class="s1">func_cached_reloaded</span><span class="s4">,</span>
            <span class="s1">ignored_attrs</span><span class="s4">=</span><span class="s1">set</span><span class="s4">([</span><span class="s6">'store_backend'</span><span class="s4">, </span><span class="s6">'timestamp'</span><span class="s4">, </span><span class="s6">'_func_code_id'</span><span class="s4">]))</span>
    <span class="s3">assert </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">func_cached</span><span class="s4">) == </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">func_cached_reloaded</span><span class="s4">)</span>

    <span class="s2"># Compare MemorizedResult instance before/after pickle roundtrip</span>
    <span class="s1">memorized_result </span><span class="s4">= </span><span class="s1">func_cached</span><span class="s4">.</span><span class="s1">call_and_shelve</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s1">memorized_result_reloaded </span><span class="s4">= </span><span class="s1">pickle</span><span class="s4">.</span><span class="s1">loads</span><span class="s4">(</span><span class="s1">pickle</span><span class="s4">.</span><span class="s1">dumps</span><span class="s4">(</span><span class="s1">memorized_result</span><span class="s4">))</span>

    <span class="s1">compare</span><span class="s4">(</span><span class="s1">memorized_result</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">,</span>
            <span class="s1">memorized_result_reloaded</span><span class="s4">.</span><span class="s1">store_backend</span><span class="s4">)</span>
    <span class="s1">compare</span><span class="s4">(</span><span class="s1">memorized_result</span><span class="s4">, </span><span class="s1">memorized_result_reloaded</span><span class="s4">,</span>
            <span class="s1">ignored_attrs</span><span class="s4">=</span><span class="s1">set</span><span class="s4">([</span><span class="s6">'store_backend'</span><span class="s4">, </span><span class="s6">'timestamp'</span><span class="s4">, </span><span class="s6">'_func_code_id'</span><span class="s4">]))</span>
    <span class="s3">assert </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">memorized_result</span><span class="s4">) == </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">memorized_result_reloaded</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_info_log</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">, </span><span class="s1">caplog</span><span class="s4">):</span>
    <span class="s1">caplog</span><span class="s4">.</span><span class="s1">set_level</span><span class="s4">(</span><span class="s1">logging</span><span class="s4">.</span><span class="s1">INFO</span><span class="s4">)</span>
    <span class="s1">x </span><span class="s4">= </span><span class="s5">3</span>

    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">20</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">f</span><span class="s4">(</span><span class="s1">x</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">x </span><span class="s4">** </span><span class="s5">2</span>

    <span class="s1">_ </span><span class="s4">= </span><span class="s1">f</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s6">&quot;Querying&quot; </span><span class="s3">in </span><span class="s1">caplog</span><span class="s4">.</span><span class="s1">text</span>
    <span class="s1">caplog</span><span class="s4">.</span><span class="s1">clear</span><span class="s4">()</span>

    <span class="s1">memory </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span>
    <span class="s3">def </span><span class="s1">f</span><span class="s4">(</span><span class="s1">x</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">x </span><span class="s4">** </span><span class="s5">2</span>

    <span class="s1">_ </span><span class="s4">= </span><span class="s1">f</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
    <span class="s3">assert </span><span class="s6">&quot;Querying&quot; </span><span class="s3">not in </span><span class="s1">caplog</span><span class="s4">.</span><span class="s1">text</span>
    <span class="s1">caplog</span><span class="s4">.</span><span class="s1">clear</span><span class="s4">()</span>


<span class="s3">def </span><span class="s1">test_deprecated_bytes_limit</span><span class="s4">(</span><span class="s1">tmpdir</span><span class="s4">):</span>
    <span class="s3">from </span><span class="s1">joblib </span><span class="s3">import </span><span class="s1">__version__</span>
    <span class="s3">if </span><span class="s1">__version__ </span><span class="s4">&gt;= </span><span class="s6">&quot;1.5&quot;</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">DeprecationWarning</span><span class="s4">(</span>
            <span class="s6">&quot;Bytes limit is deprecated and should be removed by 1.4&quot;</span>
        <span class="s4">)</span>
    <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">warns</span><span class="s4">(</span><span class="s1">DeprecationWarning</span><span class="s4">, </span><span class="s1">match</span><span class="s4">=</span><span class="s6">&quot;bytes_limit&quot;</span><span class="s4">):</span>
        <span class="s1">_ </span><span class="s4">= </span><span class="s1">Memory</span><span class="s4">(</span><span class="s1">location</span><span class="s4">=</span><span class="s1">tmpdir</span><span class="s4">.</span><span class="s1">strpath</span><span class="s4">, </span><span class="s1">bytes_limit</span><span class="s4">=</span><span class="s6">'1K'</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">TestCacheValidationCallback</span><span class="s4">:</span>
    <span class="s0">&quot;Tests on parameter `cache_validation_callback`&quot;</span>

    <span class="s3">def </span><span class="s1">foo</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">x</span><span class="s4">, </span><span class="s1">d</span><span class="s4">, </span><span class="s1">delay</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s1">d</span><span class="s4">[</span><span class="s6">&quot;run&quot;</span><span class="s4">] = </span><span class="s3">True</span>
        <span class="s3">if </span><span class="s1">delay </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">time</span><span class="s4">.</span><span class="s1">sleep</span><span class="s4">(</span><span class="s1">delay</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">x </span><span class="s4">* </span><span class="s5">2</span>

    <span class="s3">def </span><span class="s1">test_invalid_cache_validation_callback</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">memory</span><span class="s4">):</span>
        <span class="s0">&quot;Test invalid values for `cache_validation_callback&quot;</span>
        <span class="s1">match </span><span class="s4">= </span><span class="s6">&quot;cache_validation_callback needs to be callable. Got True.&quot;</span>
        <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">raises</span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">, </span><span class="s1">match</span><span class="s4">=</span><span class="s1">match</span><span class="s4">):</span>
            <span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">cache_validation_callback</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;consider_cache_valid&quot;</span><span class="s4">, [</span><span class="s3">True</span><span class="s4">, </span><span class="s3">False</span><span class="s4">])</span>
    <span class="s3">def </span><span class="s1">test_constant_cache_validation_callback</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">memory</span><span class="s4">, </span><span class="s1">consider_cache_valid</span>
    <span class="s4">):</span>
        <span class="s0">&quot;Test expiry of old results&quot;</span>
        <span class="s1">f </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">foo</span><span class="s4">, </span><span class="s1">cache_validation_callback</span><span class="s4">=</span><span class="s3">lambda </span><span class="s1">_</span><span class="s4">: </span><span class="s1">consider_cache_valid</span><span class="s4">,</span>
            <span class="s1">ignore</span><span class="s4">=[</span><span class="s6">&quot;d&quot;</span><span class="s4">]</span>
        <span class="s4">)</span>

        <span class="s1">d1</span><span class="s4">, </span><span class="s1">d2 </span><span class="s4">= {</span><span class="s6">&quot;run&quot;</span><span class="s4">: </span><span class="s3">False</span><span class="s4">}, {</span><span class="s6">&quot;run&quot;</span><span class="s4">: </span><span class="s3">False</span><span class="s4">}</span>
        <span class="s3">assert </span><span class="s1">f</span><span class="s4">(</span><span class="s5">2</span><span class="s4">, </span><span class="s1">d1</span><span class="s4">) == </span><span class="s5">4</span>
        <span class="s3">assert </span><span class="s1">f</span><span class="s4">(</span><span class="s5">2</span><span class="s4">, </span><span class="s1">d2</span><span class="s4">) == </span><span class="s5">4</span>

        <span class="s3">assert </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">&quot;run&quot;</span><span class="s4">]</span>
        <span class="s3">assert </span><span class="s1">d2</span><span class="s4">[</span><span class="s6">&quot;run&quot;</span><span class="s4">] != </span><span class="s1">consider_cache_valid</span>

    <span class="s3">def </span><span class="s1">test_memory_only_cache_long_run</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">memory</span><span class="s4">):</span>
        <span class="s0">&quot;Test cache validity based on run duration.&quot;</span>

        <span class="s3">def </span><span class="s1">cache_validation_callback</span><span class="s4">(</span><span class="s1">metadata</span><span class="s4">):</span>
            <span class="s1">duration </span><span class="s4">= </span><span class="s1">metadata</span><span class="s4">[</span><span class="s6">'duration'</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">duration </span><span class="s4">&gt; </span><span class="s5">0.1</span><span class="s4">:</span>
                <span class="s3">return True</span>

        <span class="s1">f </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">foo</span><span class="s4">, </span><span class="s1">cache_validation_callback</span><span class="s4">=</span><span class="s1">cache_validation_callback</span><span class="s4">,</span>
            <span class="s1">ignore</span><span class="s4">=[</span><span class="s6">&quot;d&quot;</span><span class="s4">]</span>
        <span class="s4">)</span>

        <span class="s2"># Short run are not cached</span>
        <span class="s1">d1</span><span class="s4">, </span><span class="s1">d2 </span><span class="s4">= {</span><span class="s6">&quot;run&quot;</span><span class="s4">: </span><span class="s3">False</span><span class="s4">}, {</span><span class="s6">&quot;run&quot;</span><span class="s4">: </span><span class="s3">False</span><span class="s4">}</span>
        <span class="s3">assert </span><span class="s1">f</span><span class="s4">(</span><span class="s5">2</span><span class="s4">, </span><span class="s1">d1</span><span class="s4">, </span><span class="s1">delay</span><span class="s4">=</span><span class="s5">0</span><span class="s4">) == </span><span class="s5">4</span>
        <span class="s3">assert </span><span class="s1">f</span><span class="s4">(</span><span class="s5">2</span><span class="s4">, </span><span class="s1">d2</span><span class="s4">, </span><span class="s1">delay</span><span class="s4">=</span><span class="s5">0</span><span class="s4">) == </span><span class="s5">4</span>
        <span class="s3">assert </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">&quot;run&quot;</span><span class="s4">]</span>
        <span class="s3">assert </span><span class="s1">d2</span><span class="s4">[</span><span class="s6">&quot;run&quot;</span><span class="s4">]</span>

        <span class="s2"># Longer run are cached</span>
        <span class="s1">d1</span><span class="s4">, </span><span class="s1">d2 </span><span class="s4">= {</span><span class="s6">&quot;run&quot;</span><span class="s4">: </span><span class="s3">False</span><span class="s4">}, {</span><span class="s6">&quot;run&quot;</span><span class="s4">: </span><span class="s3">False</span><span class="s4">}</span>
        <span class="s3">assert </span><span class="s1">f</span><span class="s4">(</span><span class="s5">2</span><span class="s4">, </span><span class="s1">d1</span><span class="s4">, </span><span class="s1">delay</span><span class="s4">=</span><span class="s5">0.2</span><span class="s4">) == </span><span class="s5">4</span>
        <span class="s3">assert </span><span class="s1">f</span><span class="s4">(</span><span class="s5">2</span><span class="s4">, </span><span class="s1">d2</span><span class="s4">, </span><span class="s1">delay</span><span class="s4">=</span><span class="s5">0.2</span><span class="s4">) == </span><span class="s5">4</span>
        <span class="s3">assert </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">&quot;run&quot;</span><span class="s4">]</span>
        <span class="s3">assert not </span><span class="s1">d2</span><span class="s4">[</span><span class="s6">&quot;run&quot;</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">test_memory_expires_after</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">memory</span><span class="s4">):</span>
        <span class="s0">&quot;Test expiry of old cached results&quot;</span>

        <span class="s1">f </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">foo</span><span class="s4">, </span><span class="s1">cache_validation_callback</span><span class="s4">=</span><span class="s1">expires_after</span><span class="s4">(</span><span class="s1">seconds</span><span class="s4">=</span><span class="s5">.3</span><span class="s4">),</span>
            <span class="s1">ignore</span><span class="s4">=[</span><span class="s6">&quot;d&quot;</span><span class="s4">]</span>
        <span class="s4">)</span>

        <span class="s1">d1</span><span class="s4">, </span><span class="s1">d2</span><span class="s4">, </span><span class="s1">d3 </span><span class="s4">= {</span><span class="s6">&quot;run&quot;</span><span class="s4">: </span><span class="s3">False</span><span class="s4">}, {</span><span class="s6">&quot;run&quot;</span><span class="s4">: </span><span class="s3">False</span><span class="s4">}, {</span><span class="s6">&quot;run&quot;</span><span class="s4">: </span><span class="s3">False</span><span class="s4">}</span>
        <span class="s3">assert </span><span class="s1">f</span><span class="s4">(</span><span class="s5">2</span><span class="s4">, </span><span class="s1">d1</span><span class="s4">) == </span><span class="s5">4</span>
        <span class="s3">assert </span><span class="s1">f</span><span class="s4">(</span><span class="s5">2</span><span class="s4">, </span><span class="s1">d2</span><span class="s4">) == </span><span class="s5">4</span>
        <span class="s1">time</span><span class="s4">.</span><span class="s1">sleep</span><span class="s4">(</span><span class="s5">.5</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">f</span><span class="s4">(</span><span class="s5">2</span><span class="s4">, </span><span class="s1">d3</span><span class="s4">) == </span><span class="s5">4</span>

        <span class="s3">assert </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">&quot;run&quot;</span><span class="s4">]</span>
        <span class="s3">assert not </span><span class="s1">d2</span><span class="s4">[</span><span class="s6">&quot;run&quot;</span><span class="s4">]</span>
        <span class="s3">assert </span><span class="s1">d3</span><span class="s4">[</span><span class="s6">&quot;run&quot;</span><span class="s4">]</span>


<span class="s3">class </span><span class="s1">TestMemorizedFunc</span><span class="s4">:</span>
    <span class="s0">&quot;Tests for the MemorizedFunc and NotMemorizedFunc classes&quot;</span>

    <span class="s4">@</span><span class="s1">staticmethod</span>
    <span class="s3">def </span><span class="s1">f</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">counter</span><span class="s4">):</span>
        <span class="s1">counter</span><span class="s4">[</span><span class="s1">x</span><span class="s4">] = </span><span class="s1">counter</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s5">0</span><span class="s4">) + </span><span class="s5">1</span>
        <span class="s3">return </span><span class="s1">counter</span><span class="s4">[</span><span class="s1">x</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">test_call_method_memorized</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">memory</span><span class="s4">):</span>
        <span class="s0">&quot;Test calling the function&quot;</span>

        <span class="s1">f </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">f</span><span class="s4">, </span><span class="s1">ignore</span><span class="s4">=[</span><span class="s6">'counter'</span><span class="s4">])</span>

        <span class="s1">counter </span><span class="s4">= {}</span>
        <span class="s3">assert </span><span class="s1">f</span><span class="s4">(</span><span class="s5">2</span><span class="s4">, </span><span class="s1">counter</span><span class="s4">) == </span><span class="s5">1</span>
        <span class="s3">assert </span><span class="s1">f</span><span class="s4">(</span><span class="s5">2</span><span class="s4">, </span><span class="s1">counter</span><span class="s4">) == </span><span class="s5">1</span>

        <span class="s1">x</span><span class="s4">, </span><span class="s1">meta </span><span class="s4">= </span><span class="s1">f</span><span class="s4">.</span><span class="s1">call</span><span class="s4">(</span><span class="s5">2</span><span class="s4">, </span><span class="s1">counter</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">x </span><span class="s4">== </span><span class="s5">2</span><span class="s4">, </span><span class="s6">&quot;f has not been called properly&quot;</span>
        <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">meta</span><span class="s4">, </span><span class="s1">dict</span><span class="s4">), (</span>
            <span class="s6">&quot;Metadata are not returned by MemorizedFunc.call.&quot;</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">test_call_method_not_memorized</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">memory</span><span class="s4">):</span>
        <span class="s0">&quot;Test calling the function&quot;</span>

        <span class="s1">f </span><span class="s4">= </span><span class="s1">NotMemorizedFunc</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">f</span><span class="s4">)</span>

        <span class="s1">counter </span><span class="s4">= {}</span>
        <span class="s3">assert </span><span class="s1">f</span><span class="s4">(</span><span class="s5">2</span><span class="s4">, </span><span class="s1">counter</span><span class="s4">) == </span><span class="s5">1</span>
        <span class="s3">assert </span><span class="s1">f</span><span class="s4">(</span><span class="s5">2</span><span class="s4">, </span><span class="s1">counter</span><span class="s4">) == </span><span class="s5">2</span>

        <span class="s1">x</span><span class="s4">, </span><span class="s1">meta </span><span class="s4">= </span><span class="s1">f</span><span class="s4">.</span><span class="s1">call</span><span class="s4">(</span><span class="s5">2</span><span class="s4">, </span><span class="s1">counter</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">x </span><span class="s4">== </span><span class="s5">3</span><span class="s4">, </span><span class="s6">&quot;f has not been called properly&quot;</span>
        <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">meta</span><span class="s4">, </span><span class="s1">dict</span><span class="s4">), (</span>
            <span class="s6">&quot;Metadata are not returned by MemorizedFunc.call.&quot;</span>
        <span class="s4">)</span>
</pre>
</body>
</html>