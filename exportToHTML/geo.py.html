<html>
<head>
<title>geo.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
geo.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
<span class="s0">from </span><span class="s1">matplotlib </span><span class="s0">import </span><span class="s1">_api</span>
<span class="s0">from </span><span class="s1">matplotlib</span><span class="s2">.</span><span class="s1">axes </span><span class="s0">import </span><span class="s1">Axes</span>
<span class="s0">import </span><span class="s1">matplotlib</span><span class="s2">.</span><span class="s1">axis </span><span class="s0">as </span><span class="s1">maxis</span>
<span class="s0">from </span><span class="s1">matplotlib</span><span class="s2">.</span><span class="s1">patches </span><span class="s0">import </span><span class="s1">Circle</span>
<span class="s0">from </span><span class="s1">matplotlib</span><span class="s2">.</span><span class="s1">path </span><span class="s0">import </span><span class="s1">Path</span>
<span class="s0">import </span><span class="s1">matplotlib</span><span class="s2">.</span><span class="s1">spines </span><span class="s0">as </span><span class="s1">mspines</span>
<span class="s0">from </span><span class="s1">matplotlib</span><span class="s2">.</span><span class="s1">ticker </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">Formatter</span><span class="s2">, </span><span class="s1">NullLocator</span><span class="s2">, </span><span class="s1">FixedLocator</span><span class="s2">, </span><span class="s1">NullFormatter</span><span class="s2">)</span>
<span class="s0">from </span><span class="s1">matplotlib</span><span class="s2">.</span><span class="s1">transforms </span><span class="s0">import </span><span class="s1">Affine2D</span><span class="s2">, </span><span class="s1">BboxTransformTo</span><span class="s2">, </span><span class="s1">Transform</span>


<span class="s0">class </span><span class="s1">GeoAxes</span><span class="s2">(</span><span class="s1">Axes</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;An abstract base class for geographic projections.&quot;&quot;&quot;</span>

    <span class="s0">class </span><span class="s1">ThetaFormatter</span><span class="s2">(</span><span class="s1">Formatter</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Used to format the theta tick labels.  Converts the native 
        unit of radians into degrees and adds a degree symbol. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">round_to</span><span class="s2">=</span><span class="s4">1.0</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_round_to </span><span class="s2">= </span><span class="s1">round_to</span>

        <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
            <span class="s1">degrees </span><span class="s2">= </span><span class="s1">round</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">rad2deg</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) / </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_round_to</span><span class="s2">) * </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_round_to</span>
            <span class="s0">return </span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">degrees</span><span class="s0">:</span><span class="s5">0.0f</span><span class="s0">}\N{DEGREE SIGN}</span><span class="s5">&quot;</span>

    <span class="s1">RESOLUTION </span><span class="s2">= </span><span class="s4">75</span>

    <span class="s0">def </span><span class="s1">_init_axis</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">xaxis </span><span class="s2">= </span><span class="s1">maxis</span><span class="s2">.</span><span class="s1">XAxis</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">clear</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">yaxis </span><span class="s2">= </span><span class="s1">maxis</span><span class="s2">.</span><span class="s1">YAxis</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">clear</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">spines</span><span class="s2">[</span><span class="s5">'geo'</span><span class="s2">].</span><span class="s1">register_axis</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">yaxis</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">clear</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># docstring inherited</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">clear</span><span class="s2">()</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">set_longitude_grid</span><span class="s2">(</span><span class="s4">30</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">set_latitude_grid</span><span class="s2">(</span><span class="s4">15</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">set_longitude_grid_ends</span><span class="s2">(</span><span class="s4">75</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">xaxis</span><span class="s2">.</span><span class="s1">set_minor_locator</span><span class="s2">(</span><span class="s1">NullLocator</span><span class="s2">())</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">yaxis</span><span class="s2">.</span><span class="s1">set_minor_locator</span><span class="s2">(</span><span class="s1">NullLocator</span><span class="s2">())</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">xaxis</span><span class="s2">.</span><span class="s1">set_ticks_position</span><span class="s2">(</span><span class="s5">'none'</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">yaxis</span><span class="s2">.</span><span class="s1">set_ticks_position</span><span class="s2">(</span><span class="s5">'none'</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">yaxis</span><span class="s2">.</span><span class="s1">set_tick_params</span><span class="s2">(</span><span class="s1">label1On</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s6"># Why do we need to turn on yaxis tick labels, but</span>
        <span class="s6"># xaxis tick labels are already on?</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">grid</span><span class="s2">(</span><span class="s1">mpl</span><span class="s2">.</span><span class="s1">rcParams</span><span class="s2">[</span><span class="s5">'axes.grid'</span><span class="s2">])</span>

        <span class="s1">Axes</span><span class="s2">.</span><span class="s1">set_xlim</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi</span><span class="s2">)</span>
        <span class="s1">Axes</span><span class="s2">.</span><span class="s1">set_ylim</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">/ </span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">/ </span><span class="s4">2.0</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_set_lim_and_transforms</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># A (possibly non-linear) projection on the (already scaled) data</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">transProjection </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_core_transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">RESOLUTION</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">transAffine </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_affine_transform</span><span class="s2">()</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">transAxes </span><span class="s2">= </span><span class="s1">BboxTransformTo</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">bbox</span><span class="s2">)</span>

        <span class="s6"># The complete data transformation stack -- from data all the</span>
        <span class="s6"># way to display coordinates</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">transData </span><span class="s2">= </span><span class="s1">\</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">transProjection </span><span class="s2">+ </span><span class="s1">\</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">transAffine </span><span class="s2">+ </span><span class="s1">\</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">transAxes</span>

        <span class="s6"># This is the transform for longitude ticks.</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_xaxis_pretransform </span><span class="s2">= </span><span class="s1">\</span>
            <span class="s1">Affine2D</span><span class="s2">() </span><span class="s1">\</span>
            <span class="s2">.</span><span class="s1">scale</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_longitude_cap </span><span class="s2">* </span><span class="s4">2</span><span class="s2">) </span><span class="s1">\</span>
            <span class="s2">.</span><span class="s1">translate</span><span class="s2">(</span><span class="s4">0</span><span class="s2">, -</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_longitude_cap</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_xaxis_transform </span><span class="s2">= </span><span class="s1">\</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_xaxis_pretransform </span><span class="s2">+ </span><span class="s1">\</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">transData</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_xaxis_text1_transform </span><span class="s2">= </span><span class="s1">\</span>
            <span class="s1">Affine2D</span><span class="s2">().</span><span class="s1">scale</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">) + </span><span class="s1">\</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">transData </span><span class="s2">+ </span><span class="s1">\</span>
            <span class="s1">Affine2D</span><span class="s2">().</span><span class="s1">translate</span><span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_xaxis_text2_transform </span><span class="s2">= </span><span class="s1">\</span>
            <span class="s1">Affine2D</span><span class="s2">().</span><span class="s1">scale</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">) + </span><span class="s1">\</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">transData </span><span class="s2">+ </span><span class="s1">\</span>
            <span class="s1">Affine2D</span><span class="s2">().</span><span class="s1">translate</span><span class="s2">(</span><span class="s4">0</span><span class="s2">, -</span><span class="s4">4</span><span class="s2">)</span>

        <span class="s6"># This is the transform for latitude ticks.</span>
        <span class="s1">yaxis_stretch </span><span class="s2">= </span><span class="s1">Affine2D</span><span class="s2">().</span><span class="s1">scale</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">* </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">).</span><span class="s1">translate</span><span class="s2">(-</span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)</span>
        <span class="s1">yaxis_space </span><span class="s2">= </span><span class="s1">Affine2D</span><span class="s2">().</span><span class="s1">scale</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.1</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_yaxis_transform </span><span class="s2">= </span><span class="s1">\</span>
            <span class="s1">yaxis_stretch </span><span class="s2">+ </span><span class="s1">\</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">transData</span>
        <span class="s1">yaxis_text_base </span><span class="s2">= </span><span class="s1">\</span>
            <span class="s1">yaxis_stretch </span><span class="s2">+ </span><span class="s1">\</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">transProjection </span><span class="s2">+ </span><span class="s1">\</span>
            <span class="s2">(</span><span class="s1">yaxis_space </span><span class="s2">+</span>
             <span class="s1">self</span><span class="s2">.</span><span class="s1">transAffine </span><span class="s2">+</span>
             <span class="s1">self</span><span class="s2">.</span><span class="s1">transAxes</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_yaxis_text1_transform </span><span class="s2">= </span><span class="s1">\</span>
            <span class="s1">yaxis_text_base </span><span class="s2">+ </span><span class="s1">\</span>
            <span class="s1">Affine2D</span><span class="s2">().</span><span class="s1">translate</span><span class="s2">(-</span><span class="s4">8</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_yaxis_text2_transform </span><span class="s2">= </span><span class="s1">\</span>
            <span class="s1">yaxis_text_base </span><span class="s2">+ </span><span class="s1">\</span>
            <span class="s1">Affine2D</span><span class="s2">().</span><span class="s1">translate</span><span class="s2">(</span><span class="s4">8</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_get_affine_transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">transform </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_core_transform</span><span class="s2">(</span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">xscale</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">transform</span><span class="s2">.</span><span class="s1">transform</span><span class="s2">((</span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi</span><span class="s2">, </span><span class="s4">0</span><span class="s2">))</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">yscale </span><span class="s2">= </span><span class="s1">transform</span><span class="s2">.</span><span class="s1">transform</span><span class="s2">((</span><span class="s4">0</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi</span><span class="s2">/</span><span class="s4">2</span><span class="s2">))</span>
        <span class="s0">return </span><span class="s1">Affine2D</span><span class="s2">() </span><span class="s1">\</span>
            <span class="s2">.</span><span class="s1">scale</span><span class="s2">(</span><span class="s4">0.5 </span><span class="s2">/ </span><span class="s1">xscale</span><span class="s2">, </span><span class="s4">0.5 </span><span class="s2">/ </span><span class="s1">yscale</span><span class="s2">) </span><span class="s1">\</span>
            <span class="s2">.</span><span class="s1">translate</span><span class="s2">(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_xaxis_transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">which</span><span class="s2">=</span><span class="s5">'grid'</span><span class="s2">):</span>
        <span class="s1">_api</span><span class="s2">.</span><span class="s1">check_in_list</span><span class="s2">([</span><span class="s5">'tick1'</span><span class="s2">, </span><span class="s5">'tick2'</span><span class="s2">, </span><span class="s5">'grid'</span><span class="s2">], </span><span class="s1">which</span><span class="s2">=</span><span class="s1">which</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_xaxis_transform</span>

    <span class="s0">def </span><span class="s1">get_xaxis_text1_transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">pad</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_xaxis_text1_transform</span><span class="s2">, </span><span class="s5">'bottom'</span><span class="s2">, </span><span class="s5">'center'</span>

    <span class="s0">def </span><span class="s1">get_xaxis_text2_transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">pad</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_xaxis_text2_transform</span><span class="s2">, </span><span class="s5">'top'</span><span class="s2">, </span><span class="s5">'center'</span>

    <span class="s0">def </span><span class="s1">get_yaxis_transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">which</span><span class="s2">=</span><span class="s5">'grid'</span><span class="s2">):</span>
        <span class="s1">_api</span><span class="s2">.</span><span class="s1">check_in_list</span><span class="s2">([</span><span class="s5">'tick1'</span><span class="s2">, </span><span class="s5">'tick2'</span><span class="s2">, </span><span class="s5">'grid'</span><span class="s2">], </span><span class="s1">which</span><span class="s2">=</span><span class="s1">which</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_yaxis_transform</span>

    <span class="s0">def </span><span class="s1">get_yaxis_text1_transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">pad</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_yaxis_text1_transform</span><span class="s2">, </span><span class="s5">'center'</span><span class="s2">, </span><span class="s5">'right'</span>

    <span class="s0">def </span><span class="s1">get_yaxis_text2_transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">pad</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_yaxis_text2_transform</span><span class="s2">, </span><span class="s5">'center'</span><span class="s2">, </span><span class="s5">'left'</span>

    <span class="s0">def </span><span class="s1">_gen_axes_patch</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">Circle</span><span class="s2">((</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">), </span><span class="s4">0.5</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_gen_axes_spines</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span><span class="s5">'geo'</span><span class="s2">: </span><span class="s1">mspines</span><span class="s2">.</span><span class="s1">Spine</span><span class="s2">.</span><span class="s1">circular_spine</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, (</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">), </span><span class="s4">0.5</span><span class="s2">)}</span>

    <span class="s0">def </span><span class="s1">set_yscale</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">args</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] != </span><span class="s5">'linear'</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">set_xscale </span><span class="s2">= </span><span class="s1">set_yscale</span>

    <span class="s0">def </span><span class="s1">set_xlim</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Not supported. Please consider using Cartopy.&quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s5">&quot;Changing axes limits of a geographic projection is &quot;</span>
                        <span class="s5">&quot;not supported.  Please consider using Cartopy.&quot;</span><span class="s2">)</span>

    <span class="s1">set_ylim </span><span class="s2">= </span><span class="s1">set_xlim</span>

    <span class="s0">def </span><span class="s1">format_coord</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">lon</span><span class="s2">, </span><span class="s1">lat</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Return a format string formatting the coordinate.&quot;&quot;&quot;</span>
        <span class="s1">lon</span><span class="s2">, </span><span class="s1">lat </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">rad2deg</span><span class="s2">([</span><span class="s1">lon</span><span class="s2">, </span><span class="s1">lat</span><span class="s2">])</span>
        <span class="s1">ns </span><span class="s2">= </span><span class="s5">'N' </span><span class="s0">if </span><span class="s1">lat </span><span class="s2">&gt;= </span><span class="s4">0.0 </span><span class="s0">else </span><span class="s5">'S'</span>
        <span class="s1">ew </span><span class="s2">= </span><span class="s5">'E' </span><span class="s0">if </span><span class="s1">lon </span><span class="s2">&gt;= </span><span class="s4">0.0 </span><span class="s0">else </span><span class="s5">'W'</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s5">'%f</span><span class="s0">\N{DEGREE SIGN}</span><span class="s5">%s, %f</span><span class="s0">\N{DEGREE SIGN}</span><span class="s5">%s'</span>
                <span class="s2">% (</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">lat</span><span class="s2">), </span><span class="s1">ns</span><span class="s2">, </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">lon</span><span class="s2">), </span><span class="s1">ew</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">set_longitude_grid</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">degrees</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Set the number of degrees between each longitude grid. 
        &quot;&quot;&quot;</span>
        <span class="s6"># Skip -180 and 180, which are the fixed limits.</span>
        <span class="s1">grid </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(-</span><span class="s4">180 </span><span class="s2">+ </span><span class="s1">degrees</span><span class="s2">, </span><span class="s4">180</span><span class="s2">, </span><span class="s1">degrees</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">xaxis</span><span class="s2">.</span><span class="s1">set_major_locator</span><span class="s2">(</span><span class="s1">FixedLocator</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">deg2rad</span><span class="s2">(</span><span class="s1">grid</span><span class="s2">)))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">xaxis</span><span class="s2">.</span><span class="s1">set_major_formatter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ThetaFormatter</span><span class="s2">(</span><span class="s1">degrees</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">set_latitude_grid</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">degrees</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Set the number of degrees between each latitude grid. 
        &quot;&quot;&quot;</span>
        <span class="s6"># Skip -90 and 90, which are the fixed limits.</span>
        <span class="s1">grid </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(-</span><span class="s4">90 </span><span class="s2">+ </span><span class="s1">degrees</span><span class="s2">, </span><span class="s4">90</span><span class="s2">, </span><span class="s1">degrees</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">yaxis</span><span class="s2">.</span><span class="s1">set_major_locator</span><span class="s2">(</span><span class="s1">FixedLocator</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">deg2rad</span><span class="s2">(</span><span class="s1">grid</span><span class="s2">)))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">yaxis</span><span class="s2">.</span><span class="s1">set_major_formatter</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ThetaFormatter</span><span class="s2">(</span><span class="s1">degrees</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">set_longitude_grid_ends</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">degrees</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Set the latitude(s) at which to stop drawing the longitude grids. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_longitude_cap </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">deg2rad</span><span class="s2">(</span><span class="s1">degrees</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_xaxis_pretransform \</span>
            <span class="s2">.</span><span class="s1">clear</span><span class="s2">() </span><span class="s1">\</span>
            <span class="s2">.</span><span class="s1">scale</span><span class="s2">(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_longitude_cap </span><span class="s2">* </span><span class="s4">2.0</span><span class="s2">) </span><span class="s1">\</span>
            <span class="s2">.</span><span class="s1">translate</span><span class="s2">(</span><span class="s4">0.0</span><span class="s2">, -</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_longitude_cap</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_data_ratio</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Return the aspect ratio of the data itself.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s4">1.0</span>

    <span class="s6">### Interactive panning</span>

    <span class="s0">def </span><span class="s1">can_zoom</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return whether this Axes supports the zoom box button functionality. 
 
        This Axes object does not support interactive zoom box. 
        &quot;&quot;&quot;</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">can_pan</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Return whether this Axes supports the pan/zoom button functionality. 
 
        This Axes object does not support interactive pan/zoom. 
        &quot;&quot;&quot;</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">start_pan</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">button</span><span class="s2">):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">end_pan</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">drag_pan</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">button</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">):</span>
        <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">_GeoTransform</span><span class="s2">(</span><span class="s1">Transform</span><span class="s2">):</span>
    <span class="s6"># Factoring out some common functionality.</span>
    <span class="s1">input_dims </span><span class="s2">= </span><span class="s1">output_dims </span><span class="s2">= </span><span class="s4">2</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">resolution</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Create a new geographical transform. 
 
        Resolution is the number of steps to interpolate between each input 
        line segment to approximate its path in curved space. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_resolution </span><span class="s2">= </span><span class="s1">resolution</span>

    <span class="s0">def </span><span class="s1">__str__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">).</span><span class="s1">__name__</span><span class="s0">}</span><span class="s5">(</span><span class="s0">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_resolution</span><span class="s0">}</span><span class="s5">)&quot;</span>

    <span class="s0">def </span><span class="s1">transform_path_non_affine</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">):</span>
        <span class="s6"># docstring inherited</span>
        <span class="s1">ipath </span><span class="s2">= </span><span class="s1">path</span><span class="s2">.</span><span class="s1">interpolated</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_resolution</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">Path</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">transform</span><span class="s2">(</span><span class="s1">ipath</span><span class="s2">.</span><span class="s1">vertices</span><span class="s2">), </span><span class="s1">ipath</span><span class="s2">.</span><span class="s1">codes</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">AitoffAxes</span><span class="s2">(</span><span class="s1">GeoAxes</span><span class="s2">):</span>
    <span class="s1">name </span><span class="s2">= </span><span class="s5">'aitoff'</span>

    <span class="s0">class </span><span class="s1">AitoffTransform</span><span class="s2">(</span><span class="s1">_GeoTransform</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;The base Aitoff transform.&quot;&quot;&quot;</span>

        <span class="s2">@</span><span class="s1">_api</span><span class="s2">.</span><span class="s1">rename_parameter</span><span class="s2">(</span><span class="s5">&quot;3.8&quot;</span><span class="s2">, </span><span class="s5">&quot;ll&quot;</span><span class="s2">, </span><span class="s5">&quot;values&quot;</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">transform_non_affine</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">):</span>
            <span class="s6"># docstring inherited</span>
            <span class="s1">longitude</span><span class="s2">, </span><span class="s1">latitude </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span>

            <span class="s6"># Pre-compute some values</span>
            <span class="s1">half_long </span><span class="s2">= </span><span class="s1">longitude </span><span class="s2">/ </span><span class="s4">2.0</span>
            <span class="s1">cos_latitude </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">latitude</span><span class="s2">)</span>

            <span class="s1">alpha </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arccos</span><span class="s2">(</span><span class="s1">cos_latitude </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">half_long</span><span class="s2">))</span>
            <span class="s1">sinc_alpha </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sinc</span><span class="s2">(</span><span class="s1">alpha </span><span class="s2">/ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi</span><span class="s2">)  </span><span class="s6"># np.sinc is sin(pi*x)/(pi*x).</span>

            <span class="s1">x </span><span class="s2">= (</span><span class="s1">cos_latitude </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">half_long</span><span class="s2">)) / </span><span class="s1">sinc_alpha</span>
            <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">latitude</span><span class="s2">) / </span><span class="s1">sinc_alpha</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">column_stack</span><span class="s2">([</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">])</span>

        <span class="s0">def </span><span class="s1">inverted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s6"># docstring inherited</span>
            <span class="s0">return </span><span class="s1">AitoffAxes</span><span class="s2">.</span><span class="s1">InvertedAitoffTransform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_resolution</span><span class="s2">)</span>

    <span class="s0">class </span><span class="s1">InvertedAitoffTransform</span><span class="s2">(</span><span class="s1">_GeoTransform</span><span class="s2">):</span>

        <span class="s2">@</span><span class="s1">_api</span><span class="s2">.</span><span class="s1">rename_parameter</span><span class="s2">(</span><span class="s5">&quot;3.8&quot;</span><span class="s2">, </span><span class="s5">&quot;xy&quot;</span><span class="s2">, </span><span class="s5">&quot;values&quot;</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">transform_non_affine</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">):</span>
            <span class="s6"># docstring inherited</span>
            <span class="s6"># MGDTODO: Math is hard ;(</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full_like</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">)</span>

        <span class="s0">def </span><span class="s1">inverted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s6"># docstring inherited</span>
            <span class="s0">return </span><span class="s1">AitoffAxes</span><span class="s2">.</span><span class="s1">AitoffTransform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_resolution</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_longitude_cap </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">/ </span><span class="s4">2.0</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">set_aspect</span><span class="s2">(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">adjustable</span><span class="s2">=</span><span class="s5">'box'</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">=</span><span class="s5">'C'</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">_get_core_transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">resolution</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">AitoffTransform</span><span class="s2">(</span><span class="s1">resolution</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">HammerAxes</span><span class="s2">(</span><span class="s1">GeoAxes</span><span class="s2">):</span>
    <span class="s1">name </span><span class="s2">= </span><span class="s5">'hammer'</span>

    <span class="s0">class </span><span class="s1">HammerTransform</span><span class="s2">(</span><span class="s1">_GeoTransform</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;The base Hammer transform.&quot;&quot;&quot;</span>

        <span class="s2">@</span><span class="s1">_api</span><span class="s2">.</span><span class="s1">rename_parameter</span><span class="s2">(</span><span class="s5">&quot;3.8&quot;</span><span class="s2">, </span><span class="s5">&quot;ll&quot;</span><span class="s2">, </span><span class="s5">&quot;values&quot;</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">transform_non_affine</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">):</span>
            <span class="s6"># docstring inherited</span>
            <span class="s1">longitude</span><span class="s2">, </span><span class="s1">latitude </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span>
            <span class="s1">half_long </span><span class="s2">= </span><span class="s1">longitude </span><span class="s2">/ </span><span class="s4">2.0</span>
            <span class="s1">cos_latitude </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">latitude</span><span class="s2">)</span>
            <span class="s1">sqrt2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s4">2.0</span><span class="s2">)</span>
            <span class="s1">alpha </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s4">1.0 </span><span class="s2">+ </span><span class="s1">cos_latitude </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">half_long</span><span class="s2">))</span>
            <span class="s1">x </span><span class="s2">= (</span><span class="s4">2.0 </span><span class="s2">* </span><span class="s1">sqrt2</span><span class="s2">) * (</span><span class="s1">cos_latitude </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">half_long</span><span class="s2">)) / </span><span class="s1">alpha</span>
            <span class="s1">y </span><span class="s2">= (</span><span class="s1">sqrt2 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">latitude</span><span class="s2">)) / </span><span class="s1">alpha</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">column_stack</span><span class="s2">([</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">])</span>

        <span class="s0">def </span><span class="s1">inverted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s6"># docstring inherited</span>
            <span class="s0">return </span><span class="s1">HammerAxes</span><span class="s2">.</span><span class="s1">InvertedHammerTransform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_resolution</span><span class="s2">)</span>

    <span class="s0">class </span><span class="s1">InvertedHammerTransform</span><span class="s2">(</span><span class="s1">_GeoTransform</span><span class="s2">):</span>

        <span class="s2">@</span><span class="s1">_api</span><span class="s2">.</span><span class="s1">rename_parameter</span><span class="s2">(</span><span class="s5">&quot;3.8&quot;</span><span class="s2">, </span><span class="s5">&quot;xy&quot;</span><span class="s2">, </span><span class="s5">&quot;values&quot;</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">transform_non_affine</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">):</span>
            <span class="s6"># docstring inherited</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span>
            <span class="s1">z </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s4">1 </span><span class="s2">- (</span><span class="s1">x </span><span class="s2">/ </span><span class="s4">4</span><span class="s2">) ** </span><span class="s4">2 </span><span class="s2">- (</span><span class="s1">y </span><span class="s2">/ </span><span class="s4">2</span><span class="s2">) ** </span><span class="s4">2</span><span class="s2">)</span>
            <span class="s1">longitude </span><span class="s2">= </span><span class="s4">2 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arctan</span><span class="s2">((</span><span class="s1">z </span><span class="s2">* </span><span class="s1">x</span><span class="s2">) / (</span><span class="s4">2 </span><span class="s2">* (</span><span class="s4">2 </span><span class="s2">* </span><span class="s1">z </span><span class="s2">** </span><span class="s4">2 </span><span class="s2">- </span><span class="s4">1</span><span class="s2">)))</span>
            <span class="s1">latitude </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arcsin</span><span class="s2">(</span><span class="s1">y</span><span class="s2">*</span><span class="s1">z</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">column_stack</span><span class="s2">([</span><span class="s1">longitude</span><span class="s2">, </span><span class="s1">latitude</span><span class="s2">])</span>

        <span class="s0">def </span><span class="s1">inverted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s6"># docstring inherited</span>
            <span class="s0">return </span><span class="s1">HammerAxes</span><span class="s2">.</span><span class="s1">HammerTransform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_resolution</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_longitude_cap </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">/ </span><span class="s4">2.0</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">set_aspect</span><span class="s2">(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">adjustable</span><span class="s2">=</span><span class="s5">'box'</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">=</span><span class="s5">'C'</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">_get_core_transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">resolution</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">HammerTransform</span><span class="s2">(</span><span class="s1">resolution</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">MollweideAxes</span><span class="s2">(</span><span class="s1">GeoAxes</span><span class="s2">):</span>
    <span class="s1">name </span><span class="s2">= </span><span class="s5">'mollweide'</span>

    <span class="s0">class </span><span class="s1">MollweideTransform</span><span class="s2">(</span><span class="s1">_GeoTransform</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;The base Mollweide transform.&quot;&quot;&quot;</span>

        <span class="s2">@</span><span class="s1">_api</span><span class="s2">.</span><span class="s1">rename_parameter</span><span class="s2">(</span><span class="s5">&quot;3.8&quot;</span><span class="s2">, </span><span class="s5">&quot;ll&quot;</span><span class="s2">, </span><span class="s5">&quot;values&quot;</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">transform_non_affine</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">):</span>
            <span class="s6"># docstring inherited</span>
            <span class="s0">def </span><span class="s1">d</span><span class="s2">(</span><span class="s1">theta</span><span class="s2">):</span>
                <span class="s1">delta </span><span class="s2">= (-(</span><span class="s1">theta </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">theta</span><span class="s2">) - </span><span class="s1">pi_sin_l</span><span class="s2">)</span>
                         <span class="s2">/ (</span><span class="s4">1 </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">theta</span><span class="s2">)))</span>
                <span class="s0">return </span><span class="s1">delta</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">delta</span><span class="s2">) &gt; </span><span class="s4">0.001</span>

            <span class="s1">longitude</span><span class="s2">, </span><span class="s1">latitude </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span>

            <span class="s1">clat </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi</span><span class="s2">/</span><span class="s4">2 </span><span class="s2">- </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">latitude</span><span class="s2">)</span>
            <span class="s1">ihigh </span><span class="s2">= </span><span class="s1">clat </span><span class="s2">&lt; </span><span class="s4">0.087  </span><span class="s6"># within 5 degrees of the poles</span>
            <span class="s1">ilow </span><span class="s2">= ~</span><span class="s1">ihigh</span>
            <span class="s1">aux </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">latitude</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">ilow</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():  </span><span class="s6"># Newton-Raphson iteration</span>
                <span class="s1">pi_sin_l </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">latitude</span><span class="s2">[</span><span class="s1">ilow</span><span class="s2">])</span>
                <span class="s1">theta </span><span class="s2">= </span><span class="s4">2.0 </span><span class="s2">* </span><span class="s1">latitude</span><span class="s2">[</span><span class="s1">ilow</span><span class="s2">]</span>
                <span class="s1">delta</span><span class="s2">, </span><span class="s1">large_delta </span><span class="s2">= </span><span class="s1">d</span><span class="s2">(</span><span class="s1">theta</span><span class="s2">)</span>
                <span class="s0">while </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">large_delta</span><span class="s2">):</span>
                    <span class="s1">theta</span><span class="s2">[</span><span class="s1">large_delta</span><span class="s2">] += </span><span class="s1">delta</span><span class="s2">[</span><span class="s1">large_delta</span><span class="s2">]</span>
                    <span class="s1">delta</span><span class="s2">, </span><span class="s1">large_delta </span><span class="s2">= </span><span class="s1">d</span><span class="s2">(</span><span class="s1">theta</span><span class="s2">)</span>
                <span class="s1">aux</span><span class="s2">[</span><span class="s1">ilow</span><span class="s2">] = </span><span class="s1">theta </span><span class="s2">/ </span><span class="s4">2</span>

            <span class="s0">if </span><span class="s1">ihigh</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():  </span><span class="s6"># Taylor series-based approx. solution</span>
                <span class="s1">e </span><span class="s2">= </span><span class="s1">clat</span><span class="s2">[</span><span class="s1">ihigh</span><span class="s2">]</span>
                <span class="s1">d </span><span class="s2">= </span><span class="s4">0.5 </span><span class="s2">* (</span><span class="s4">3 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">* </span><span class="s1">e</span><span class="s2">**</span><span class="s4">2</span><span class="s2">) ** (</span><span class="s4">1.0</span><span class="s2">/</span><span class="s4">3</span><span class="s2">)</span>
                <span class="s1">aux</span><span class="s2">[</span><span class="s1">ihigh</span><span class="s2">] = (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi</span><span class="s2">/</span><span class="s4">2 </span><span class="s2">- </span><span class="s1">d</span><span class="s2">) * </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sign</span><span class="s2">(</span><span class="s1">latitude</span><span class="s2">[</span><span class="s1">ihigh</span><span class="s2">])</span>

            <span class="s1">xy </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">values</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">)</span>
            <span class="s1">xy</span><span class="s2">[:, </span><span class="s4">0</span><span class="s2">] = (</span><span class="s4">2.0 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s4">2.0</span><span class="s2">) / </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi</span><span class="s2">) * </span><span class="s1">longitude </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">aux</span><span class="s2">)</span>
            <span class="s1">xy</span><span class="s2">[:, </span><span class="s4">1</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s4">2.0</span><span class="s2">) * </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">aux</span><span class="s2">)</span>

            <span class="s0">return </span><span class="s1">xy</span>

        <span class="s0">def </span><span class="s1">inverted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s6"># docstring inherited</span>
            <span class="s0">return </span><span class="s1">MollweideAxes</span><span class="s2">.</span><span class="s1">InvertedMollweideTransform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_resolution</span><span class="s2">)</span>

    <span class="s0">class </span><span class="s1">InvertedMollweideTransform</span><span class="s2">(</span><span class="s1">_GeoTransform</span><span class="s2">):</span>

        <span class="s2">@</span><span class="s1">_api</span><span class="s2">.</span><span class="s1">rename_parameter</span><span class="s2">(</span><span class="s5">&quot;3.8&quot;</span><span class="s2">, </span><span class="s5">&quot;xy&quot;</span><span class="s2">, </span><span class="s5">&quot;values&quot;</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">transform_non_affine</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">):</span>
            <span class="s6"># docstring inherited</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span>
            <span class="s6"># from Equations (7, 8) of</span>
            <span class="s6"># https://mathworld.wolfram.com/MollweideProjection.html</span>
            <span class="s1">theta </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arcsin</span><span class="s2">(</span><span class="s1">y </span><span class="s2">/ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s4">2</span><span class="s2">))</span>
            <span class="s1">longitude </span><span class="s2">= (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">/ (</span><span class="s4">2 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s4">2</span><span class="s2">))) * </span><span class="s1">x </span><span class="s2">/ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">theta</span><span class="s2">)</span>
            <span class="s1">latitude </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arcsin</span><span class="s2">((</span><span class="s4">2 </span><span class="s2">* </span><span class="s1">theta </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s4">2 </span><span class="s2">* </span><span class="s1">theta</span><span class="s2">)) / </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">column_stack</span><span class="s2">([</span><span class="s1">longitude</span><span class="s2">, </span><span class="s1">latitude</span><span class="s2">])</span>

        <span class="s0">def </span><span class="s1">inverted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s6"># docstring inherited</span>
            <span class="s0">return </span><span class="s1">MollweideAxes</span><span class="s2">.</span><span class="s1">MollweideTransform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_resolution</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_longitude_cap </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">/ </span><span class="s4">2.0</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">set_aspect</span><span class="s2">(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">adjustable</span><span class="s2">=</span><span class="s5">'box'</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">=</span><span class="s5">'C'</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">_get_core_transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">resolution</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">MollweideTransform</span><span class="s2">(</span><span class="s1">resolution</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">LambertAxes</span><span class="s2">(</span><span class="s1">GeoAxes</span><span class="s2">):</span>
    <span class="s1">name </span><span class="s2">= </span><span class="s5">'lambert'</span>

    <span class="s0">class </span><span class="s1">LambertTransform</span><span class="s2">(</span><span class="s1">_GeoTransform</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;The base Lambert transform.&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">center_longitude</span><span class="s2">, </span><span class="s1">center_latitude</span><span class="s2">, </span><span class="s1">resolution</span><span class="s2">):</span>
            <span class="s3">&quot;&quot;&quot; 
            Create a new Lambert transform.  Resolution is the number of steps 
            to interpolate between each input line segment to approximate its 
            path in curved Lambert space. 
            &quot;&quot;&quot;</span>
            <span class="s1">_GeoTransform</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">resolution</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_center_longitude </span><span class="s2">= </span><span class="s1">center_longitude</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_center_latitude </span><span class="s2">= </span><span class="s1">center_latitude</span>

        <span class="s2">@</span><span class="s1">_api</span><span class="s2">.</span><span class="s1">rename_parameter</span><span class="s2">(</span><span class="s5">&quot;3.8&quot;</span><span class="s2">, </span><span class="s5">&quot;ll&quot;</span><span class="s2">, </span><span class="s5">&quot;values&quot;</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">transform_non_affine</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">):</span>
            <span class="s6"># docstring inherited</span>
            <span class="s1">longitude</span><span class="s2">, </span><span class="s1">latitude </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span>
            <span class="s1">clong </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_center_longitude</span>
            <span class="s1">clat </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_center_latitude</span>
            <span class="s1">cos_lat </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">latitude</span><span class="s2">)</span>
            <span class="s1">sin_lat </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">latitude</span><span class="s2">)</span>
            <span class="s1">diff_long </span><span class="s2">= </span><span class="s1">longitude </span><span class="s2">- </span><span class="s1">clong</span>
            <span class="s1">cos_diff_long </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">diff_long</span><span class="s2">)</span>

            <span class="s1">inner_k </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(  </span><span class="s6"># Prevent divide-by-zero problems</span>
                <span class="s4">1 </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">clat</span><span class="s2">)*</span><span class="s1">sin_lat </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">clat</span><span class="s2">)*</span><span class="s1">cos_lat</span><span class="s2">*</span><span class="s1">cos_diff_long</span><span class="s2">,</span>
                <span class="s4">1e-15</span><span class="s2">)</span>
            <span class="s1">k </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s4">2 </span><span class="s2">/ </span><span class="s1">inner_k</span><span class="s2">)</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">k </span><span class="s2">* </span><span class="s1">cos_lat</span><span class="s2">*</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">diff_long</span><span class="s2">)</span>
            <span class="s1">y </span><span class="s2">= </span><span class="s1">k </span><span class="s2">* (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">clat</span><span class="s2">)*</span><span class="s1">sin_lat </span><span class="s2">- </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">clat</span><span class="s2">)*</span><span class="s1">cos_lat</span><span class="s2">*</span><span class="s1">cos_diff_long</span><span class="s2">)</span>

            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">column_stack</span><span class="s2">([</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">])</span>

        <span class="s0">def </span><span class="s1">inverted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s6"># docstring inherited</span>
            <span class="s0">return </span><span class="s1">LambertAxes</span><span class="s2">.</span><span class="s1">InvertedLambertTransform</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_center_longitude</span><span class="s2">,</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_center_latitude</span><span class="s2">,</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_resolution</span><span class="s2">)</span>

    <span class="s0">class </span><span class="s1">InvertedLambertTransform</span><span class="s2">(</span><span class="s1">_GeoTransform</span><span class="s2">):</span>

        <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">center_longitude</span><span class="s2">, </span><span class="s1">center_latitude</span><span class="s2">, </span><span class="s1">resolution</span><span class="s2">):</span>
            <span class="s1">_GeoTransform</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">resolution</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_center_longitude </span><span class="s2">= </span><span class="s1">center_longitude</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_center_latitude </span><span class="s2">= </span><span class="s1">center_latitude</span>

        <span class="s2">@</span><span class="s1">_api</span><span class="s2">.</span><span class="s1">rename_parameter</span><span class="s2">(</span><span class="s5">&quot;3.8&quot;</span><span class="s2">, </span><span class="s5">&quot;xy&quot;</span><span class="s2">, </span><span class="s5">&quot;values&quot;</span><span class="s2">)</span>
        <span class="s0">def </span><span class="s1">transform_non_affine</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">):</span>
            <span class="s6"># docstring inherited</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">= </span><span class="s1">values</span><span class="s2">.</span><span class="s1">T</span>
            <span class="s1">clong </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_center_longitude</span>
            <span class="s1">clat </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_center_latitude</span>
            <span class="s1">p </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">hypot</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">), </span><span class="s4">1e-9</span><span class="s2">)</span>
            <span class="s1">c </span><span class="s2">= </span><span class="s4">2 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arcsin</span><span class="s2">(</span><span class="s4">0.5 </span><span class="s2">* </span><span class="s1">p</span><span class="s2">)</span>
            <span class="s1">sin_c </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">c</span><span class="s2">)</span>
            <span class="s1">cos_c </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">c</span><span class="s2">)</span>

            <span class="s1">latitude </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arcsin</span><span class="s2">(</span><span class="s1">cos_c</span><span class="s2">*</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">clat</span><span class="s2">) +</span>
                                 <span class="s2">((</span><span class="s1">y</span><span class="s2">*</span><span class="s1">sin_c</span><span class="s2">*</span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">clat</span><span class="s2">)) / </span><span class="s1">p</span><span class="s2">))</span>
            <span class="s1">longitude </span><span class="s2">= </span><span class="s1">clong </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arctan</span><span class="s2">(</span>
                <span class="s2">(</span><span class="s1">x</span><span class="s2">*</span><span class="s1">sin_c</span><span class="s2">) / (</span><span class="s1">p</span><span class="s2">*</span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">(</span><span class="s1">clat</span><span class="s2">)*</span><span class="s1">cos_c </span><span class="s2">- </span><span class="s1">y</span><span class="s2">*</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">clat</span><span class="s2">)*</span><span class="s1">sin_c</span><span class="s2">))</span>

            <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">column_stack</span><span class="s2">([</span><span class="s1">longitude</span><span class="s2">, </span><span class="s1">latitude</span><span class="s2">])</span>

        <span class="s0">def </span><span class="s1">inverted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
            <span class="s6"># docstring inherited</span>
            <span class="s0">return </span><span class="s1">LambertAxes</span><span class="s2">.</span><span class="s1">LambertTransform</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_center_longitude</span><span class="s2">,</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_center_latitude</span><span class="s2">,</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_resolution</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, </span><span class="s1">center_longitude</span><span class="s2">=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">center_latitude</span><span class="s2">=</span><span class="s4">0</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_longitude_cap </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">pi </span><span class="s2">/ </span><span class="s4">2</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_center_longitude </span><span class="s2">= </span><span class="s1">center_longitude</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_center_latitude </span><span class="s2">= </span><span class="s1">center_latitude</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">set_aspect</span><span class="s2">(</span><span class="s5">'equal'</span><span class="s2">, </span><span class="s1">adjustable</span><span class="s2">=</span><span class="s5">'box'</span><span class="s2">, </span><span class="s1">anchor</span><span class="s2">=</span><span class="s5">'C'</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">clear</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">clear</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6"># docstring inherited</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">clear</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">yaxis</span><span class="s2">.</span><span class="s1">set_major_formatter</span><span class="s2">(</span><span class="s1">NullFormatter</span><span class="s2">())</span>

    <span class="s0">def </span><span class="s1">_get_core_transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">resolution</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">LambertTransform</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_center_longitude</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_center_latitude</span><span class="s2">,</span>
            <span class="s1">resolution</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_get_affine_transform</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">Affine2D</span><span class="s2">() </span><span class="s1">\</span>
            <span class="s2">.</span><span class="s1">scale</span><span class="s2">(</span><span class="s4">0.25</span><span class="s2">) </span><span class="s1">\</span>
            <span class="s2">.</span><span class="s1">translate</span><span class="s2">(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">)</span>
</pre>
</body>
</html>