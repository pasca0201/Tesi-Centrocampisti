<html>
<head>
<title>_solvers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_solvers.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Matrix equation solver routines&quot;&quot;&quot;</span>
<span class="s2"># Author: Jeffrey Armstrong &lt;jeff@approximatrix.com&gt;</span>
<span class="s2"># February 24, 2012</span>

<span class="s2"># Modified: Chad Fulton &lt;ChadFulton@gmail.com&gt;</span>
<span class="s2"># June 19, 2014</span>

<span class="s2"># Modified: Ilhan Polat &lt;ilhanpolat@gmail.com&gt;</span>
<span class="s2"># September 13, 2016</span>

<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">numpy</span><span class="s4">.</span><span class="s1">linalg </span><span class="s3">import </span><span class="s1">inv</span><span class="s4">, </span><span class="s1">LinAlgError</span><span class="s4">, </span><span class="s1">norm</span><span class="s4">, </span><span class="s1">cond</span><span class="s4">, </span><span class="s1">svd</span>

<span class="s3">from </span><span class="s4">.</span><span class="s1">_basic </span><span class="s3">import </span><span class="s1">solve</span><span class="s4">, </span><span class="s1">solve_triangular</span><span class="s4">, </span><span class="s1">matrix_balance</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">lapack </span><span class="s3">import </span><span class="s1">get_lapack_funcs</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_decomp_schur </span><span class="s3">import </span><span class="s1">schur</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_decomp_lu </span><span class="s3">import </span><span class="s1">lu</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_decomp_qr </span><span class="s3">import </span><span class="s1">qr</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_decomp_qz </span><span class="s3">import </span><span class="s1">ordqz</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_decomp </span><span class="s3">import </span><span class="s1">_asarray_validated</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_special_matrices </span><span class="s3">import </span><span class="s1">kron</span><span class="s4">, </span><span class="s1">block_diag</span>

<span class="s1">__all__ </span><span class="s4">= [</span><span class="s5">'solve_sylvester'</span><span class="s4">,</span>
           <span class="s5">'solve_continuous_lyapunov'</span><span class="s4">, </span><span class="s5">'solve_discrete_lyapunov'</span><span class="s4">,</span>
           <span class="s5">'solve_lyapunov'</span><span class="s4">,</span>
           <span class="s5">'solve_continuous_are'</span><span class="s4">, </span><span class="s5">'solve_discrete_are'</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">solve_sylvester</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">q</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Computes a solution (X) to the Sylvester equation :math:`AX + XB = Q`. 
 
    Parameters 
    ---------- 
    a : (M, M) array_like 
        Leading matrix of the Sylvester equation 
    b : (N, N) array_like 
        Trailing matrix of the Sylvester equation 
    q : (M, N) array_like 
        Right-hand side 
 
    Returns 
    ------- 
    x : (M, N) ndarray 
        The solution to the Sylvester equation. 
 
    Raises 
    ------ 
    LinAlgError 
        If solution was not found 
 
    Notes 
    ----- 
    Computes a solution to the Sylvester matrix equation via the Bartels- 
    Stewart algorithm. The A and B matrices first undergo Schur 
    decompositions. The resulting matrices are used to construct an 
    alternative Sylvester equation (``RY + YS^T = F``) where the R and S 
    matrices are in quasi-triangular form (or, when R, S or F are complex, 
    triangular form). The simplified equation is then solved using 
    ``*TRSYL`` from LAPACK directly. 
 
    .. versionadded:: 0.11.0 
 
    Examples 
    -------- 
    Given `a`, `b`, and `q` solve for `x`: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import linalg 
    &gt;&gt;&gt; a = np.array([[-3, -2, 0], [-1, -1, 3], [3, -5, -1]]) 
    &gt;&gt;&gt; b = np.array([[1]]) 
    &gt;&gt;&gt; q = np.array([[1],[2],[3]]) 
    &gt;&gt;&gt; x = linalg.solve_sylvester(a, b, q) 
    &gt;&gt;&gt; x 
    array([[ 0.0625], 
           [-0.5625], 
           [ 0.6875]]) 
    &gt;&gt;&gt; np.allclose(a.dot(x) + x.dot(b), q) 
    True 
 
    &quot;&quot;&quot;</span>

    <span class="s2"># Compute the Schur decomposition form of a</span>
    <span class="s1">r</span><span class="s4">, </span><span class="s1">u </span><span class="s4">= </span><span class="s1">schur</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">output</span><span class="s4">=</span><span class="s5">'real'</span><span class="s4">)</span>

    <span class="s2"># Compute the Schur decomposition of b</span>
    <span class="s1">s</span><span class="s4">, </span><span class="s1">v </span><span class="s4">= </span><span class="s1">schur</span><span class="s4">(</span><span class="s1">b</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">transpose</span><span class="s4">(), </span><span class="s1">output</span><span class="s4">=</span><span class="s5">'real'</span><span class="s4">)</span>

    <span class="s2"># Construct f = u'*q*v</span>
    <span class="s1">f </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">u</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">transpose</span><span class="s4">(), </span><span class="s1">q</span><span class="s4">), </span><span class="s1">v</span><span class="s4">)</span>

    <span class="s2"># Call the Sylvester equation solver</span>
    <span class="s1">trsyl</span><span class="s4">, = </span><span class="s1">get_lapack_funcs</span><span class="s4">((</span><span class="s5">'trsyl'</span><span class="s4">,), (</span><span class="s1">r</span><span class="s4">, </span><span class="s1">s</span><span class="s4">, </span><span class="s1">f</span><span class="s4">))</span>
    <span class="s3">if </span><span class="s1">trsyl </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">RuntimeError</span><span class="s4">(</span><span class="s5">'LAPACK implementation does not contain a proper '</span>
                           <span class="s5">'Sylvester equation solver (TRSYL)'</span><span class="s4">)</span>
    <span class="s1">y</span><span class="s4">, </span><span class="s1">scale</span><span class="s4">, </span><span class="s1">info </span><span class="s4">= </span><span class="s1">trsyl</span><span class="s4">(</span><span class="s1">r</span><span class="s4">, </span><span class="s1">s</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">tranb</span><span class="s4">=</span><span class="s5">'C'</span><span class="s4">)</span>

    <span class="s1">y </span><span class="s4">= </span><span class="s1">scale</span><span class="s4">*</span><span class="s1">y</span>

    <span class="s3">if </span><span class="s1">info </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">LinAlgError</span><span class="s4">(</span><span class="s5">&quot;Illegal value encountered in &quot;</span>
                          <span class="s5">&quot;the %d term&quot; </span><span class="s4">% (-</span><span class="s1">info</span><span class="s4">,))</span>

    <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">u</span><span class="s4">, </span><span class="s1">y</span><span class="s4">), </span><span class="s1">v</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">transpose</span><span class="s4">())</span>


<span class="s3">def </span><span class="s1">solve_continuous_lyapunov</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">q</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Solves the continuous Lyapunov equation :math:`AX + XA^H = Q`. 
 
    Uses the Bartels-Stewart algorithm to find :math:`X`. 
 
    Parameters 
    ---------- 
    a : array_like 
        A square matrix 
 
    q : array_like 
        Right-hand side square matrix 
 
    Returns 
    ------- 
    x : ndarray 
        Solution to the continuous Lyapunov equation 
 
    See Also 
    -------- 
    solve_discrete_lyapunov : computes the solution to the discrete-time 
        Lyapunov equation 
    solve_sylvester : computes the solution to the Sylvester equation 
 
    Notes 
    ----- 
    The continuous Lyapunov equation is a special form of the Sylvester 
    equation, hence this solver relies on LAPACK routine ?TRSYL. 
 
    .. versionadded:: 0.11.0 
 
    Examples 
    -------- 
    Given `a` and `q` solve for `x`: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import linalg 
    &gt;&gt;&gt; a = np.array([[-3, -2, 0], [-1, -1, 0], [0, -5, -1]]) 
    &gt;&gt;&gt; b = np.array([2, 4, -1]) 
    &gt;&gt;&gt; q = np.eye(3) 
    &gt;&gt;&gt; x = linalg.solve_continuous_lyapunov(a, q) 
    &gt;&gt;&gt; x 
    array([[ -0.75  ,   0.875 ,  -3.75  ], 
           [  0.875 ,  -1.375 ,   5.3125], 
           [ -3.75  ,   5.3125, -27.0625]]) 
    &gt;&gt;&gt; np.allclose(a.dot(x) + x.dot(a.T), q) 
    True 
    &quot;&quot;&quot;</span>

    <span class="s1">a </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_2d</span><span class="s4">(</span><span class="s1">_asarray_validated</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">check_finite</span><span class="s4">=</span><span class="s3">True</span><span class="s4">))</span>
    <span class="s1">q </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_2d</span><span class="s4">(</span><span class="s1">_asarray_validated</span><span class="s4">(</span><span class="s1">q</span><span class="s4">, </span><span class="s1">check_finite</span><span class="s4">=</span><span class="s3">True</span><span class="s4">))</span>

    <span class="s1">r_or_c </span><span class="s4">= </span><span class="s1">float</span>

    <span class="s3">for </span><span class="s1">ind</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">((</span><span class="s1">a</span><span class="s4">, </span><span class="s1">q</span><span class="s4">)):</span>
        <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">iscomplexobj</span><span class="s4">(</span><span class="s1">_</span><span class="s4">):</span>
            <span class="s1">r_or_c </span><span class="s4">= </span><span class="s1">complex</span>

        <span class="s3">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">equal</span><span class="s4">(*</span><span class="s1">_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Matrix {} should be square.&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s5">&quot;aq&quot;</span><span class="s4">[</span><span class="s1">ind</span><span class="s4">]))</span>

    <span class="s2"># Shape consistency check</span>
    <span class="s3">if </span><span class="s1">a</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">!= </span><span class="s1">q</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Matrix a and q should have the same shape.&quot;</span><span class="s4">)</span>

    <span class="s2"># Compute the Schur decomposition form of a</span>
    <span class="s1">r</span><span class="s4">, </span><span class="s1">u </span><span class="s4">= </span><span class="s1">schur</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">output</span><span class="s4">=</span><span class="s5">'real'</span><span class="s4">)</span>

    <span class="s2"># Construct f = u'*q*u</span>
    <span class="s1">f </span><span class="s4">= </span><span class="s1">u</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">q</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">u</span><span class="s4">))</span>

    <span class="s2"># Call the Sylvester equation solver</span>
    <span class="s1">trsyl </span><span class="s4">= </span><span class="s1">get_lapack_funcs</span><span class="s4">(</span><span class="s5">'trsyl'</span><span class="s4">, (</span><span class="s1">r</span><span class="s4">, </span><span class="s1">f</span><span class="s4">))</span>

    <span class="s1">dtype_string </span><span class="s4">= </span><span class="s5">'T' </span><span class="s3">if </span><span class="s1">r_or_c </span><span class="s4">== </span><span class="s1">float </span><span class="s3">else </span><span class="s5">'C'</span>
    <span class="s1">y</span><span class="s4">, </span><span class="s1">scale</span><span class="s4">, </span><span class="s1">info </span><span class="s4">= </span><span class="s1">trsyl</span><span class="s4">(</span><span class="s1">r</span><span class="s4">, </span><span class="s1">r</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">tranb</span><span class="s4">=</span><span class="s1">dtype_string</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">info </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'?TRSYL exited with the internal error '</span>
                         <span class="s5">f'&quot;illegal value in argument number </span><span class="s3">{</span><span class="s4">-</span><span class="s1">info</span><span class="s3">}</span><span class="s5">.&quot;. See '</span>
                         <span class="s5">'LAPACK documentation for the ?TRSYL error codes.'</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">info </span><span class="s4">== </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span><span class="s5">'Input &quot;a&quot; has an eigenvalue pair whose sum is '</span>
                      <span class="s5">'very close to or exactly zero. The solution is '</span>
                      <span class="s5">'obtained via perturbing the coefficients.'</span><span class="s4">,</span>
                      <span class="s1">RuntimeWarning</span><span class="s4">, </span><span class="s1">stacklevel</span><span class="s4">=</span><span class="s6">2</span><span class="s4">)</span>
    <span class="s1">y </span><span class="s4">*= </span><span class="s1">scale</span>

    <span class="s3">return </span><span class="s1">u</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">y</span><span class="s4">).</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">u</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">)</span>


<span class="s2"># For backwards compatibility, keep the old name</span>
<span class="s1">solve_lyapunov </span><span class="s4">= </span><span class="s1">solve_continuous_lyapunov</span>


<span class="s3">def </span><span class="s1">_solve_discrete_lyapunov_direct</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">q</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Solves the discrete Lyapunov equation directly. 
 
    This function is called by the `solve_discrete_lyapunov` function with 
    `method=direct`. It is not supposed to be called directly. 
    &quot;&quot;&quot;</span>

    <span class="s1">lhs </span><span class="s4">= </span><span class="s1">kron</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">a</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">())</span>
    <span class="s1">lhs </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">eye</span><span class="s4">(</span><span class="s1">lhs</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]) - </span><span class="s1">lhs</span>
    <span class="s1">x </span><span class="s4">= </span><span class="s1">solve</span><span class="s4">(</span><span class="s1">lhs</span><span class="s4">, </span><span class="s1">q</span><span class="s4">.</span><span class="s1">flatten</span><span class="s4">())</span>

    <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">q</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_solve_discrete_lyapunov_bilinear</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">q</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Solves the discrete Lyapunov equation using a bilinear transformation. 
 
    This function is called by the `solve_discrete_lyapunov` function with 
    `method=bilinear`. It is not supposed to be called directly. 
    &quot;&quot;&quot;</span>
    <span class="s1">eye </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">eye</span><span class="s4">(</span><span class="s1">a</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])</span>
    <span class="s1">aH </span><span class="s4">= </span><span class="s1">a</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">transpose</span><span class="s4">()</span>
    <span class="s1">aHI_inv </span><span class="s4">= </span><span class="s1">inv</span><span class="s4">(</span><span class="s1">aH </span><span class="s4">+ </span><span class="s1">eye</span><span class="s4">)</span>
    <span class="s1">b </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">aH </span><span class="s4">- </span><span class="s1">eye</span><span class="s4">, </span><span class="s1">aHI_inv</span><span class="s4">)</span>
    <span class="s1">c </span><span class="s4">= </span><span class="s6">2</span><span class="s4">*</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">inv</span><span class="s4">(</span><span class="s1">a </span><span class="s4">+ </span><span class="s1">eye</span><span class="s4">), </span><span class="s1">q</span><span class="s4">), </span><span class="s1">aHI_inv</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">solve_lyapunov</span><span class="s4">(</span><span class="s1">b</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">transpose</span><span class="s4">(), -</span><span class="s1">c</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">solve_discrete_lyapunov</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">q</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Solves the discrete Lyapunov equation :math:`AXA^H - X + Q = 0`. 
 
    Parameters 
    ---------- 
    a, q : (M, M) array_like 
        Square matrices corresponding to A and Q in the equation 
        above respectively. Must have the same shape. 
 
    method : {'direct', 'bilinear'}, optional 
        Type of solver. 
 
        If not given, chosen to be ``direct`` if ``M`` is less than 10 and 
        ``bilinear`` otherwise. 
 
    Returns 
    ------- 
    x : ndarray 
        Solution to the discrete Lyapunov equation 
 
    See Also 
    -------- 
    solve_continuous_lyapunov : computes the solution to the continuous-time 
        Lyapunov equation 
 
    Notes 
    ----- 
    This section describes the available solvers that can be selected by the 
    'method' parameter. The default method is *direct* if ``M`` is less than 10 
    and ``bilinear`` otherwise. 
 
    Method *direct* uses a direct analytical solution to the discrete Lyapunov 
    equation. The algorithm is given in, for example, [1]_. However, it requires 
    the linear solution of a system with dimension :math:`M^2` so that 
    performance degrades rapidly for even moderately sized matrices. 
 
    Method *bilinear* uses a bilinear transformation to convert the discrete 
    Lyapunov equation to a continuous Lyapunov equation :math:`(BX+XB'=-C)` 
    where :math:`B=(A-I)(A+I)^{-1}` and 
    :math:`C=2(A' + I)^{-1} Q (A + I)^{-1}`. The continuous equation can be 
    efficiently solved since it is a special case of a Sylvester equation. 
    The transformation algorithm is from Popov (1964) as described in [2]_. 
 
    .. versionadded:: 0.11.0 
 
    References 
    ---------- 
    .. [1] &quot;Lyapunov equation&quot;, Wikipedia, 
       https://en.wikipedia.org/wiki/Lyapunov_equation#Discrete_time 
    .. [2] Gajic, Z., and M.T.J. Qureshi. 2008. 
       Lyapunov Matrix Equation in System Stability and Control. 
       Dover Books on Engineering Series. Dover Publications. 
 
    Examples 
    -------- 
    Given `a` and `q` solve for `x`: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import linalg 
    &gt;&gt;&gt; a = np.array([[0.2, 0.5],[0.7, -0.9]]) 
    &gt;&gt;&gt; q = np.eye(2) 
    &gt;&gt;&gt; x = linalg.solve_discrete_lyapunov(a, q) 
    &gt;&gt;&gt; x 
    array([[ 0.70872893,  1.43518822], 
           [ 1.43518822, -2.4266315 ]]) 
    &gt;&gt;&gt; np.allclose(a.dot(x).dot(a.T)-x, -q) 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
    <span class="s1">q </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">q</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">method </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s2"># Select automatically based on size of matrices</span>
        <span class="s3">if </span><span class="s1">a</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] &gt;= </span><span class="s6">10</span><span class="s4">:</span>
            <span class="s1">method </span><span class="s4">= </span><span class="s5">'bilinear'</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">method </span><span class="s4">= </span><span class="s5">'direct'</span>

    <span class="s1">meth </span><span class="s4">= </span><span class="s1">method</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">()</span>

    <span class="s3">if </span><span class="s1">meth </span><span class="s4">== </span><span class="s5">'direct'</span><span class="s4">:</span>
        <span class="s1">x </span><span class="s4">= </span><span class="s1">_solve_discrete_lyapunov_direct</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">q</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">meth </span><span class="s4">== </span><span class="s5">'bilinear'</span><span class="s4">:</span>
        <span class="s1">x </span><span class="s4">= </span><span class="s1">_solve_discrete_lyapunov_bilinear</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">q</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Unknown solver %s' </span><span class="s4">% </span><span class="s1">method</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">x</span>


<span class="s3">def </span><span class="s1">solve_continuous_are</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">q</span><span class="s4">, </span><span class="s1">r</span><span class="s4">, </span><span class="s1">e</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">s</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">balanced</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Solves the continuous-time algebraic Riccati equation (CARE). 
 
    The CARE is defined as 
 
    .. math:: 
 
          X A + A^H X - X B R^{-1} B^H X + Q = 0 
 
    The limitations for a solution to exist are : 
 
        * All eigenvalues of :math:`A` on the right half plane, should be 
          controllable. 
 
        * The associated hamiltonian pencil (See Notes), should have 
          eigenvalues sufficiently away from the imaginary axis. 
 
    Moreover, if ``e`` or ``s`` is not precisely ``None``, then the 
    generalized version of CARE 
 
    .. math:: 
 
          E^HXA + A^HXE - (E^HXB + S) R^{-1} (B^HXE + S^H) + Q = 0 
 
    is solved. When omitted, ``e`` is assumed to be the identity and ``s`` 
    is assumed to be the zero matrix with sizes compatible with ``a`` and 
    ``b``, respectively. 
 
    Parameters 
    ---------- 
    a : (M, M) array_like 
        Square matrix 
    b : (M, N) array_like 
        Input 
    q : (M, M) array_like 
        Input 
    r : (N, N) array_like 
        Nonsingular square matrix 
    e : (M, M) array_like, optional 
        Nonsingular square matrix 
    s : (M, N) array_like, optional 
        Input 
    balanced : bool, optional 
        The boolean that indicates whether a balancing step is performed 
        on the data. The default is set to True. 
 
    Returns 
    ------- 
    x : (M, M) ndarray 
        Solution to the continuous-time algebraic Riccati equation. 
 
    Raises 
    ------ 
    LinAlgError 
        For cases where the stable subspace of the pencil could not be 
        isolated. See Notes section and the references for details. 
 
    See Also 
    -------- 
    solve_discrete_are : Solves the discrete-time algebraic Riccati equation 
 
    Notes 
    ----- 
    The equation is solved by forming the extended hamiltonian matrix pencil, 
    as described in [1]_, :math:`H - \lambda J` given by the block matrices :: 
 
        [ A    0    B ]             [ E   0    0 ] 
        [-Q  -A^H  -S ] - \lambda * [ 0  E^H   0 ] 
        [ S^H B^H   R ]             [ 0   0    0 ] 
 
    and using a QZ decomposition method. 
 
    In this algorithm, the fail conditions are linked to the symmetry 
    of the product :math:`U_2 U_1^{-1}` and condition number of 
    :math:`U_1`. Here, :math:`U` is the 2m-by-m matrix that holds the 
    eigenvectors spanning the stable subspace with 2-m rows and partitioned 
    into two m-row matrices. See [1]_ and [2]_ for more details. 
 
    In order to improve the QZ decomposition accuracy, the pencil goes 
    through a balancing step where the sum of absolute values of 
    :math:`H` and :math:`J` entries (after removing the diagonal entries of 
    the sum) is balanced following the recipe given in [3]_. 
 
    .. versionadded:: 0.11.0 
 
    References 
    ---------- 
    .. [1]  P. van Dooren , &quot;A Generalized Eigenvalue Approach For Solving 
       Riccati Equations.&quot;, SIAM Journal on Scientific and Statistical 
       Computing, Vol.2(2), :doi:`10.1137/0902010` 
 
    .. [2] A.J. Laub, &quot;A Schur Method for Solving Algebraic Riccati 
       Equations.&quot;, Massachusetts Institute of Technology. Laboratory for 
       Information and Decision Systems. LIDS-R ; 859. Available online : 
       http://hdl.handle.net/1721.1/1301 
 
    .. [3] P. Benner, &quot;Symplectic Balancing of Hamiltonian Matrices&quot;, 2001, 
       SIAM J. Sci. Comput., 2001, Vol.22(5), :doi:`10.1137/S1064827500367993` 
 
    Examples 
    -------- 
    Given `a`, `b`, `q`, and `r` solve for `x`: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import linalg 
    &gt;&gt;&gt; a = np.array([[4, 3], [-4.5, -3.5]]) 
    &gt;&gt;&gt; b = np.array([[1], [-1]]) 
    &gt;&gt;&gt; q = np.array([[9, 6], [6, 4.]]) 
    &gt;&gt;&gt; r = 1 
    &gt;&gt;&gt; x = linalg.solve_continuous_are(a, b, q, r) 
    &gt;&gt;&gt; x 
    array([[ 21.72792206,  14.48528137], 
           [ 14.48528137,   9.65685425]]) 
    &gt;&gt;&gt; np.allclose(a.T.dot(x) + x.dot(a)-x.dot(b).dot(b.T).dot(x), -q) 
    True 
 
    &quot;&quot;&quot;</span>

    <span class="s2"># Validate input arguments</span>
    <span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">q</span><span class="s4">, </span><span class="s1">r</span><span class="s4">, </span><span class="s1">e</span><span class="s4">, </span><span class="s1">s</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">r_or_c</span><span class="s4">, </span><span class="s1">gen_are </span><span class="s4">= </span><span class="s1">_are_validate_args</span><span class="s4">(</span>
                                                     <span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">q</span><span class="s4">, </span><span class="s1">r</span><span class="s4">, </span><span class="s1">e</span><span class="s4">, </span><span class="s1">s</span><span class="s4">, </span><span class="s5">'care'</span><span class="s4">)</span>

    <span class="s1">H </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">((</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">+</span><span class="s1">n</span><span class="s4">, </span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">+</span><span class="s1">n</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">r_or_c</span><span class="s4">)</span>
    <span class="s1">H</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">, :</span><span class="s1">m</span><span class="s4">] = </span><span class="s1">a</span>
    <span class="s1">H</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">, </span><span class="s1">m</span><span class="s4">:</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">] = </span><span class="s6">0.</span>
    <span class="s1">H</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">, </span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">:] = </span><span class="s1">b</span>
    <span class="s1">H</span><span class="s4">[</span><span class="s1">m</span><span class="s4">:</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">, :</span><span class="s1">m</span><span class="s4">] = -</span><span class="s1">q</span>
    <span class="s1">H</span><span class="s4">[</span><span class="s1">m</span><span class="s4">:</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">, </span><span class="s1">m</span><span class="s4">:</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">] = -</span><span class="s1">a</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span>
    <span class="s1">H</span><span class="s4">[</span><span class="s1">m</span><span class="s4">:</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">, </span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">:] = </span><span class="s6">0. </span><span class="s3">if </span><span class="s1">s </span><span class="s3">is None else </span><span class="s4">-</span><span class="s1">s</span>
    <span class="s1">H</span><span class="s4">[</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">:, :</span><span class="s1">m</span><span class="s4">] = </span><span class="s6">0. </span><span class="s3">if </span><span class="s1">s </span><span class="s3">is None else </span><span class="s1">s</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span>
    <span class="s1">H</span><span class="s4">[</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">:, </span><span class="s1">m</span><span class="s4">:</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">] = </span><span class="s1">b</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span>
    <span class="s1">H</span><span class="s4">[</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">:, </span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">:] = </span><span class="s1">r</span>

    <span class="s3">if </span><span class="s1">gen_are </span><span class="s3">and </span><span class="s1">e </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">J </span><span class="s4">= </span><span class="s1">block_diag</span><span class="s4">(</span><span class="s1">e</span><span class="s4">, </span><span class="s1">e</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros_like</span><span class="s4">(</span><span class="s1">r</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">r_or_c</span><span class="s4">))</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">J </span><span class="s4">= </span><span class="s1">block_diag</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">eye</span><span class="s4">(</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">), </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros_like</span><span class="s4">(</span><span class="s1">r</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">r_or_c</span><span class="s4">))</span>

    <span class="s3">if </span><span class="s1">balanced</span><span class="s4">:</span>
        <span class="s2"># xGEBAL does not remove the diagonals before scaling. Also</span>
        <span class="s2"># to avoid destroying the Symplectic structure, we follow Ref.3</span>
        <span class="s1">M </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">H</span><span class="s4">) + </span><span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">J</span><span class="s4">)</span>
        <span class="s1">np</span><span class="s4">.</span><span class="s1">fill_diagonal</span><span class="s4">(</span><span class="s1">M</span><span class="s4">, </span><span class="s6">0.</span><span class="s4">)</span>
        <span class="s1">_</span><span class="s4">, (</span><span class="s1">sca</span><span class="s4">, </span><span class="s1">_</span><span class="s4">) = </span><span class="s1">matrix_balance</span><span class="s4">(</span><span class="s1">M</span><span class="s4">, </span><span class="s1">separate</span><span class="s4">=</span><span class="s6">1</span><span class="s4">, </span><span class="s1">permute</span><span class="s4">=</span><span class="s6">0</span><span class="s4">)</span>
        <span class="s2"># do we need to bother?</span>
        <span class="s3">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">allclose</span><span class="s4">(</span><span class="s1">sca</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones_like</span><span class="s4">(</span><span class="s1">sca</span><span class="s4">)):</span>
            <span class="s2"># Now impose diag(D,inv(D)) from Benner where D is</span>
            <span class="s2"># square root of s_i/s_(n+i) for i=0,....</span>
            <span class="s1">sca </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">log2</span><span class="s4">(</span><span class="s1">sca</span><span class="s4">)</span>
            <span class="s2"># NOTE: Py3 uses &quot;Bankers Rounding: round to the nearest even&quot; !!</span>
            <span class="s1">s </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">round</span><span class="s4">((</span><span class="s1">sca</span><span class="s4">[</span><span class="s1">m</span><span class="s4">:</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">] - </span><span class="s1">sca</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">])/</span><span class="s6">2</span><span class="s4">)</span>
            <span class="s1">sca </span><span class="s4">= </span><span class="s6">2 </span><span class="s4">** </span><span class="s1">np</span><span class="s4">.</span><span class="s1">r_</span><span class="s4">[</span><span class="s1">s</span><span class="s4">, -</span><span class="s1">s</span><span class="s4">, </span><span class="s1">sca</span><span class="s4">[</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">:]]</span>
            <span class="s2"># Elementwise multiplication via broadcasting.</span>
            <span class="s1">elwisescale </span><span class="s4">= </span><span class="s1">sca</span><span class="s4">[:, </span><span class="s3">None</span><span class="s4">] * </span><span class="s1">np</span><span class="s4">.</span><span class="s1">reciprocal</span><span class="s4">(</span><span class="s1">sca</span><span class="s4">)</span>
            <span class="s1">H </span><span class="s4">*= </span><span class="s1">elwisescale</span>
            <span class="s1">J </span><span class="s4">*= </span><span class="s1">elwisescale</span>

    <span class="s2"># Deflate the pencil to 2m x 2m ala Ref.1, eq.(55)</span>
    <span class="s1">q</span><span class="s4">, </span><span class="s1">r </span><span class="s4">= </span><span class="s1">qr</span><span class="s4">(</span><span class="s1">H</span><span class="s4">[:, -</span><span class="s1">n</span><span class="s4">:])</span>
    <span class="s1">H </span><span class="s4">= </span><span class="s1">q</span><span class="s4">[:, </span><span class="s1">n</span><span class="s4">:].</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">H</span><span class="s4">[:, :</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">])</span>
    <span class="s1">J </span><span class="s4">= </span><span class="s1">q</span><span class="s4">[:</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">:].</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">J</span><span class="s4">[:</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">, :</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">])</span>

    <span class="s2"># Decide on which output type is needed for QZ</span>
    <span class="s1">out_str </span><span class="s4">= </span><span class="s5">'real' </span><span class="s3">if </span><span class="s1">r_or_c </span><span class="s4">== </span><span class="s1">float </span><span class="s3">else </span><span class="s5">'complex'</span>

    <span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">u </span><span class="s4">= </span><span class="s1">ordqz</span><span class="s4">(</span><span class="s1">H</span><span class="s4">, </span><span class="s1">J</span><span class="s4">, </span><span class="s1">sort</span><span class="s4">=</span><span class="s5">'lhp'</span><span class="s4">, </span><span class="s1">overwrite_a</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                             <span class="s1">overwrite_b</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">check_finite</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                             <span class="s1">output</span><span class="s4">=</span><span class="s1">out_str</span><span class="s4">)</span>

    <span class="s2"># Get the relevant parts of the stable subspace basis</span>
    <span class="s3">if </span><span class="s1">e </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">u</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">qr</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">vstack</span><span class="s4">((</span><span class="s1">e</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">u</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">, :</span><span class="s1">m</span><span class="s4">]), </span><span class="s1">u</span><span class="s4">[</span><span class="s1">m</span><span class="s4">:, :</span><span class="s1">m</span><span class="s4">])))</span>
    <span class="s1">u00 </span><span class="s4">= </span><span class="s1">u</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">, :</span><span class="s1">m</span><span class="s4">]</span>
    <span class="s1">u10 </span><span class="s4">= </span><span class="s1">u</span><span class="s4">[</span><span class="s1">m</span><span class="s4">:, :</span><span class="s1">m</span><span class="s4">]</span>

    <span class="s2"># Solve via back-substituion after checking the condition of u00</span>
    <span class="s1">up</span><span class="s4">, </span><span class="s1">ul</span><span class="s4">, </span><span class="s1">uu </span><span class="s4">= </span><span class="s1">lu</span><span class="s4">(</span><span class="s1">u00</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s6">1</span><span class="s4">/</span><span class="s1">cond</span><span class="s4">(</span><span class="s1">uu</span><span class="s4">) &lt; </span><span class="s1">np</span><span class="s4">.</span><span class="s1">spacing</span><span class="s4">(</span><span class="s6">1.</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">LinAlgError</span><span class="s4">(</span><span class="s5">'Failed to find a finite solution.'</span><span class="s4">)</span>

    <span class="s2"># Exploit the triangular structure</span>
    <span class="s1">x </span><span class="s4">= </span><span class="s1">solve_triangular</span><span class="s4">(</span><span class="s1">ul</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">,</span>
                         <span class="s1">solve_triangular</span><span class="s4">(</span><span class="s1">uu</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">,</span>
                                          <span class="s1">u10</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">,</span>
                                          <span class="s1">lower</span><span class="s4">=</span><span class="s3">True</span><span class="s4">),</span>
                         <span class="s1">unit_diagonal</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                         <span class="s4">).</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">up</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">balanced</span><span class="s4">:</span>
        <span class="s1">x </span><span class="s4">*= </span><span class="s1">sca</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">, </span><span class="s3">None</span><span class="s4">] * </span><span class="s1">sca</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">]</span>

    <span class="s2"># Check the deviation from symmetry for lack of success</span>
    <span class="s2"># See proof of Thm.5 item 3 in [2]</span>
    <span class="s1">u_sym </span><span class="s4">= </span><span class="s1">u00</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">u10</span><span class="s4">)</span>
    <span class="s1">n_u_sym </span><span class="s4">= </span><span class="s1">norm</span><span class="s4">(</span><span class="s1">u_sym</span><span class="s4">, </span><span class="s6">1</span><span class="s4">)</span>
    <span class="s1">u_sym </span><span class="s4">= </span><span class="s1">u_sym </span><span class="s4">- </span><span class="s1">u_sym</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span>
    <span class="s1">sym_threshold </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">max</span><span class="s4">([</span><span class="s1">np</span><span class="s4">.</span><span class="s1">spacing</span><span class="s4">(</span><span class="s6">1000.</span><span class="s4">), </span><span class="s6">0.1</span><span class="s4">*</span><span class="s1">n_u_sym</span><span class="s4">])</span>

    <span class="s3">if </span><span class="s1">norm</span><span class="s4">(</span><span class="s1">u_sym</span><span class="s4">, </span><span class="s6">1</span><span class="s4">) &gt; </span><span class="s1">sym_threshold</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">LinAlgError</span><span class="s4">(</span><span class="s5">'The associated Hamiltonian pencil has eigenvalues '</span>
                          <span class="s5">'too close to the imaginary axis'</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s4">(</span><span class="s1">x </span><span class="s4">+ </span><span class="s1">x</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">)/</span><span class="s6">2</span>


<span class="s3">def </span><span class="s1">solve_discrete_are</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">q</span><span class="s4">, </span><span class="s1">r</span><span class="s4">, </span><span class="s1">e</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">s</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">balanced</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Solves the discrete-time algebraic Riccati equation (DARE). 
 
    The DARE is defined as 
 
    .. math:: 
 
          A^HXA - X - (A^HXB) (R + B^HXB)^{-1} (B^HXA) + Q = 0 
 
    The limitations for a solution to exist are : 
 
        * All eigenvalues of :math:`A` outside the unit disc, should be 
          controllable. 
 
        * The associated symplectic pencil (See Notes), should have 
          eigenvalues sufficiently away from the unit circle. 
 
    Moreover, if ``e`` and ``s`` are not both precisely ``None``, then the 
    generalized version of DARE 
 
    .. math:: 
 
          A^HXA - E^HXE - (A^HXB+S) (R+B^HXB)^{-1} (B^HXA+S^H) + Q = 0 
 
    is solved. When omitted, ``e`` is assumed to be the identity and ``s`` 
    is assumed to be the zero matrix. 
 
    Parameters 
    ---------- 
    a : (M, M) array_like 
        Square matrix 
    b : (M, N) array_like 
        Input 
    q : (M, M) array_like 
        Input 
    r : (N, N) array_like 
        Square matrix 
    e : (M, M) array_like, optional 
        Nonsingular square matrix 
    s : (M, N) array_like, optional 
        Input 
    balanced : bool 
        The boolean that indicates whether a balancing step is performed 
        on the data. The default is set to True. 
 
    Returns 
    ------- 
    x : (M, M) ndarray 
        Solution to the discrete algebraic Riccati equation. 
 
    Raises 
    ------ 
    LinAlgError 
        For cases where the stable subspace of the pencil could not be 
        isolated. See Notes section and the references for details. 
 
    See Also 
    -------- 
    solve_continuous_are : Solves the continuous algebraic Riccati equation 
 
    Notes 
    ----- 
    The equation is solved by forming the extended symplectic matrix pencil, 
    as described in [1]_, :math:`H - \lambda J` given by the block matrices :: 
 
           [  A   0   B ]             [ E   0   B ] 
           [ -Q  E^H -S ] - \lambda * [ 0  A^H  0 ] 
           [ S^H  0   R ]             [ 0 -B^H  0 ] 
 
    and using a QZ decomposition method. 
 
    In this algorithm, the fail conditions are linked to the symmetry 
    of the product :math:`U_2 U_1^{-1}` and condition number of 
    :math:`U_1`. Here, :math:`U` is the 2m-by-m matrix that holds the 
    eigenvectors spanning the stable subspace with 2-m rows and partitioned 
    into two m-row matrices. See [1]_ and [2]_ for more details. 
 
    In order to improve the QZ decomposition accuracy, the pencil goes 
    through a balancing step where the sum of absolute values of 
    :math:`H` and :math:`J` rows/cols (after removing the diagonal entries) 
    is balanced following the recipe given in [3]_. If the data has small 
    numerical noise, balancing may amplify their effects and some clean up 
    is required. 
 
    .. versionadded:: 0.11.0 
 
    References 
    ---------- 
    .. [1]  P. van Dooren , &quot;A Generalized Eigenvalue Approach For Solving 
       Riccati Equations.&quot;, SIAM Journal on Scientific and Statistical 
       Computing, Vol.2(2), :doi:`10.1137/0902010` 
 
    .. [2] A.J. Laub, &quot;A Schur Method for Solving Algebraic Riccati 
       Equations.&quot;, Massachusetts Institute of Technology. Laboratory for 
       Information and Decision Systems. LIDS-R ; 859. Available online : 
       http://hdl.handle.net/1721.1/1301 
 
    .. [3] P. Benner, &quot;Symplectic Balancing of Hamiltonian Matrices&quot;, 2001, 
       SIAM J. Sci. Comput., 2001, Vol.22(5), :doi:`10.1137/S1064827500367993` 
 
    Examples 
    -------- 
    Given `a`, `b`, `q`, and `r` solve for `x`: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import linalg as la 
    &gt;&gt;&gt; a = np.array([[0, 1], [0, -1]]) 
    &gt;&gt;&gt; b = np.array([[1, 0], [2, 1]]) 
    &gt;&gt;&gt; q = np.array([[-4, -4], [-4, 7]]) 
    &gt;&gt;&gt; r = np.array([[9, 3], [3, 1]]) 
    &gt;&gt;&gt; x = la.solve_discrete_are(a, b, q, r) 
    &gt;&gt;&gt; x 
    array([[-4., -4.], 
           [-4.,  7.]]) 
    &gt;&gt;&gt; R = la.solve(r + b.T.dot(x).dot(b), b.T.dot(x).dot(a)) 
    &gt;&gt;&gt; np.allclose(a.T.dot(x).dot(a) - x - a.T.dot(x).dot(b).dot(R), -q) 
    True 
 
    &quot;&quot;&quot;</span>

    <span class="s2"># Validate input arguments</span>
    <span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">q</span><span class="s4">, </span><span class="s1">r</span><span class="s4">, </span><span class="s1">e</span><span class="s4">, </span><span class="s1">s</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">r_or_c</span><span class="s4">, </span><span class="s1">gen_are </span><span class="s4">= </span><span class="s1">_are_validate_args</span><span class="s4">(</span>
                                                     <span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">q</span><span class="s4">, </span><span class="s1">r</span><span class="s4">, </span><span class="s1">e</span><span class="s4">, </span><span class="s1">s</span><span class="s4">, </span><span class="s5">'dare'</span><span class="s4">)</span>

    <span class="s2"># Form the matrix pencil</span>
    <span class="s1">H </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">+</span><span class="s1">n</span><span class="s4">, </span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">+</span><span class="s1">n</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">r_or_c</span><span class="s4">)</span>
    <span class="s1">H</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">, :</span><span class="s1">m</span><span class="s4">] = </span><span class="s1">a</span>
    <span class="s1">H</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">, </span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">:] = </span><span class="s1">b</span>
    <span class="s1">H</span><span class="s4">[</span><span class="s1">m</span><span class="s4">:</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">, :</span><span class="s1">m</span><span class="s4">] = -</span><span class="s1">q</span>
    <span class="s1">H</span><span class="s4">[</span><span class="s1">m</span><span class="s4">:</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">, </span><span class="s1">m</span><span class="s4">:</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">] = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">eye</span><span class="s4">(</span><span class="s1">m</span><span class="s4">) </span><span class="s3">if </span><span class="s1">e </span><span class="s3">is None else </span><span class="s1">e</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span>
    <span class="s1">H</span><span class="s4">[</span><span class="s1">m</span><span class="s4">:</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">, </span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">:] = </span><span class="s6">0. </span><span class="s3">if </span><span class="s1">s </span><span class="s3">is None else </span><span class="s4">-</span><span class="s1">s</span>
    <span class="s1">H</span><span class="s4">[</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">:, :</span><span class="s1">m</span><span class="s4">] = </span><span class="s6">0. </span><span class="s3">if </span><span class="s1">s </span><span class="s3">is None else </span><span class="s1">s</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span>
    <span class="s1">H</span><span class="s4">[</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">:, </span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">:] = </span><span class="s1">r</span>

    <span class="s1">J </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros_like</span><span class="s4">(</span><span class="s1">H</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">r_or_c</span><span class="s4">)</span>
    <span class="s1">J</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">, :</span><span class="s1">m</span><span class="s4">] = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">eye</span><span class="s4">(</span><span class="s1">m</span><span class="s4">) </span><span class="s3">if </span><span class="s1">e </span><span class="s3">is None else </span><span class="s1">e</span>
    <span class="s1">J</span><span class="s4">[</span><span class="s1">m</span><span class="s4">:</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">, </span><span class="s1">m</span><span class="s4">:</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">] = </span><span class="s1">a</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span>
    <span class="s1">J</span><span class="s4">[</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">:, </span><span class="s1">m</span><span class="s4">:</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">] = -</span><span class="s1">b</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span>

    <span class="s3">if </span><span class="s1">balanced</span><span class="s4">:</span>
        <span class="s2"># xGEBAL does not remove the diagonals before scaling. Also</span>
        <span class="s2"># to avoid destroying the Symplectic structure, we follow Ref.3</span>
        <span class="s1">M </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">H</span><span class="s4">) + </span><span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">J</span><span class="s4">)</span>
        <span class="s1">np</span><span class="s4">.</span><span class="s1">fill_diagonal</span><span class="s4">(</span><span class="s1">M</span><span class="s4">, </span><span class="s6">0.</span><span class="s4">)</span>
        <span class="s1">_</span><span class="s4">, (</span><span class="s1">sca</span><span class="s4">, </span><span class="s1">_</span><span class="s4">) = </span><span class="s1">matrix_balance</span><span class="s4">(</span><span class="s1">M</span><span class="s4">, </span><span class="s1">separate</span><span class="s4">=</span><span class="s6">1</span><span class="s4">, </span><span class="s1">permute</span><span class="s4">=</span><span class="s6">0</span><span class="s4">)</span>
        <span class="s2"># do we need to bother?</span>
        <span class="s3">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">allclose</span><span class="s4">(</span><span class="s1">sca</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones_like</span><span class="s4">(</span><span class="s1">sca</span><span class="s4">)):</span>
            <span class="s2"># Now impose diag(D,inv(D)) from Benner where D is</span>
            <span class="s2"># square root of s_i/s_(n+i) for i=0,....</span>
            <span class="s1">sca </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">log2</span><span class="s4">(</span><span class="s1">sca</span><span class="s4">)</span>
            <span class="s2"># NOTE: Py3 uses &quot;Bankers Rounding: round to the nearest even&quot; !!</span>
            <span class="s1">s </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">round</span><span class="s4">((</span><span class="s1">sca</span><span class="s4">[</span><span class="s1">m</span><span class="s4">:</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">] - </span><span class="s1">sca</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">])/</span><span class="s6">2</span><span class="s4">)</span>
            <span class="s1">sca </span><span class="s4">= </span><span class="s6">2 </span><span class="s4">** </span><span class="s1">np</span><span class="s4">.</span><span class="s1">r_</span><span class="s4">[</span><span class="s1">s</span><span class="s4">, -</span><span class="s1">s</span><span class="s4">, </span><span class="s1">sca</span><span class="s4">[</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">:]]</span>
            <span class="s2"># Elementwise multiplication via broadcasting.</span>
            <span class="s1">elwisescale </span><span class="s4">= </span><span class="s1">sca</span><span class="s4">[:, </span><span class="s3">None</span><span class="s4">] * </span><span class="s1">np</span><span class="s4">.</span><span class="s1">reciprocal</span><span class="s4">(</span><span class="s1">sca</span><span class="s4">)</span>
            <span class="s1">H </span><span class="s4">*= </span><span class="s1">elwisescale</span>
            <span class="s1">J </span><span class="s4">*= </span><span class="s1">elwisescale</span>

    <span class="s2"># Deflate the pencil by the R column ala Ref.1</span>
    <span class="s1">q_of_qr</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">qr</span><span class="s4">(</span><span class="s1">H</span><span class="s4">[:, -</span><span class="s1">n</span><span class="s4">:])</span>
    <span class="s1">H </span><span class="s4">= </span><span class="s1">q_of_qr</span><span class="s4">[:, </span><span class="s1">n</span><span class="s4">:].</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">H</span><span class="s4">[:, :</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">])</span>
    <span class="s1">J </span><span class="s4">= </span><span class="s1">q_of_qr</span><span class="s4">[:, </span><span class="s1">n</span><span class="s4">:].</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">J</span><span class="s4">[:, :</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">])</span>

    <span class="s2"># Decide on which output type is needed for QZ</span>
    <span class="s1">out_str </span><span class="s4">= </span><span class="s5">'real' </span><span class="s3">if </span><span class="s1">r_or_c </span><span class="s4">== </span><span class="s1">float </span><span class="s3">else </span><span class="s5">'complex'</span>

    <span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">u </span><span class="s4">= </span><span class="s1">ordqz</span><span class="s4">(</span><span class="s1">H</span><span class="s4">, </span><span class="s1">J</span><span class="s4">, </span><span class="s1">sort</span><span class="s4">=</span><span class="s5">'iuc'</span><span class="s4">,</span>
                             <span class="s1">overwrite_a</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                             <span class="s1">overwrite_b</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                             <span class="s1">check_finite</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                             <span class="s1">output</span><span class="s4">=</span><span class="s1">out_str</span><span class="s4">)</span>

    <span class="s2"># Get the relevant parts of the stable subspace basis</span>
    <span class="s3">if </span><span class="s1">e </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">u</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">qr</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">vstack</span><span class="s4">((</span><span class="s1">e</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">u</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">, :</span><span class="s1">m</span><span class="s4">]), </span><span class="s1">u</span><span class="s4">[</span><span class="s1">m</span><span class="s4">:, :</span><span class="s1">m</span><span class="s4">])))</span>
    <span class="s1">u00 </span><span class="s4">= </span><span class="s1">u</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">, :</span><span class="s1">m</span><span class="s4">]</span>
    <span class="s1">u10 </span><span class="s4">= </span><span class="s1">u</span><span class="s4">[</span><span class="s1">m</span><span class="s4">:, :</span><span class="s1">m</span><span class="s4">]</span>

    <span class="s2"># Solve via back-substituion after checking the condition of u00</span>
    <span class="s1">up</span><span class="s4">, </span><span class="s1">ul</span><span class="s4">, </span><span class="s1">uu </span><span class="s4">= </span><span class="s1">lu</span><span class="s4">(</span><span class="s1">u00</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s6">1</span><span class="s4">/</span><span class="s1">cond</span><span class="s4">(</span><span class="s1">uu</span><span class="s4">) &lt; </span><span class="s1">np</span><span class="s4">.</span><span class="s1">spacing</span><span class="s4">(</span><span class="s6">1.</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">LinAlgError</span><span class="s4">(</span><span class="s5">'Failed to find a finite solution.'</span><span class="s4">)</span>

    <span class="s2"># Exploit the triangular structure</span>
    <span class="s1">x </span><span class="s4">= </span><span class="s1">solve_triangular</span><span class="s4">(</span><span class="s1">ul</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">,</span>
                         <span class="s1">solve_triangular</span><span class="s4">(</span><span class="s1">uu</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">,</span>
                                          <span class="s1">u10</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">,</span>
                                          <span class="s1">lower</span><span class="s4">=</span><span class="s3">True</span><span class="s4">),</span>
                         <span class="s1">unit_diagonal</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                         <span class="s4">).</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">up</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">balanced</span><span class="s4">:</span>
        <span class="s1">x </span><span class="s4">*= </span><span class="s1">sca</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">, </span><span class="s3">None</span><span class="s4">] * </span><span class="s1">sca</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">]</span>

    <span class="s2"># Check the deviation from symmetry for lack of success</span>
    <span class="s2"># See proof of Thm.5 item 3 in [2]</span>
    <span class="s1">u_sym </span><span class="s4">= </span><span class="s1">u00</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">u10</span><span class="s4">)</span>
    <span class="s1">n_u_sym </span><span class="s4">= </span><span class="s1">norm</span><span class="s4">(</span><span class="s1">u_sym</span><span class="s4">, </span><span class="s6">1</span><span class="s4">)</span>
    <span class="s1">u_sym </span><span class="s4">= </span><span class="s1">u_sym </span><span class="s4">- </span><span class="s1">u_sym</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span>
    <span class="s1">sym_threshold </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">max</span><span class="s4">([</span><span class="s1">np</span><span class="s4">.</span><span class="s1">spacing</span><span class="s4">(</span><span class="s6">1000.</span><span class="s4">), </span><span class="s6">0.1</span><span class="s4">*</span><span class="s1">n_u_sym</span><span class="s4">])</span>

    <span class="s3">if </span><span class="s1">norm</span><span class="s4">(</span><span class="s1">u_sym</span><span class="s4">, </span><span class="s6">1</span><span class="s4">) &gt; </span><span class="s1">sym_threshold</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">LinAlgError</span><span class="s4">(</span><span class="s5">'The associated symplectic pencil has eigenvalues '</span>
                          <span class="s5">'too close to the unit circle'</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s4">(</span><span class="s1">x </span><span class="s4">+ </span><span class="s1">x</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">)/</span><span class="s6">2</span>


<span class="s3">def </span><span class="s1">_are_validate_args</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">q</span><span class="s4">, </span><span class="s1">r</span><span class="s4">, </span><span class="s1">e</span><span class="s4">, </span><span class="s1">s</span><span class="s4">, </span><span class="s1">eq_type</span><span class="s4">=</span><span class="s5">'care'</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper function to validate the arguments supplied to the 
    Riccati equation solvers. Any discrepancy found in the input 
    matrices leads to a ``ValueError`` exception. 
 
    Essentially, it performs: 
 
        - a check whether the input is free of NaN and Infs 
        - a pass for the data through ``numpy.atleast_2d()`` 
        - squareness check of the relevant arrays 
        - shape consistency check of the arrays 
        - singularity check of the relevant arrays 
        - symmetricity check of the relevant matrices 
        - a check whether the regular or the generalized version is asked. 
 
    This function is used by ``solve_continuous_are`` and 
    ``solve_discrete_are``. 
 
    Parameters 
    ---------- 
    a, b, q, r, e, s : array_like 
        Input data 
    eq_type : str 
        Accepted arguments are 'care' and 'dare'. 
 
    Returns 
    ------- 
    a, b, q, r, e, s : ndarray 
        Regularized input data 
    m, n : int 
        shape of the problem 
    r_or_c : type 
        Data type of the problem, returns float or complex 
    gen_or_not : bool 
        Type of the equation, True for generalized and False for regular ARE. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">eq_type</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">() </span><span class="s3">not in </span><span class="s4">(</span><span class="s5">&quot;dare&quot;</span><span class="s4">, </span><span class="s5">&quot;care&quot;</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Equation type unknown. &quot;</span>
                         <span class="s5">&quot;Only 'care' and 'dare' is understood&quot;</span><span class="s4">)</span>

    <span class="s1">a </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_2d</span><span class="s4">(</span><span class="s1">_asarray_validated</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">check_finite</span><span class="s4">=</span><span class="s3">True</span><span class="s4">))</span>
    <span class="s1">b </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_2d</span><span class="s4">(</span><span class="s1">_asarray_validated</span><span class="s4">(</span><span class="s1">b</span><span class="s4">, </span><span class="s1">check_finite</span><span class="s4">=</span><span class="s3">True</span><span class="s4">))</span>
    <span class="s1">q </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_2d</span><span class="s4">(</span><span class="s1">_asarray_validated</span><span class="s4">(</span><span class="s1">q</span><span class="s4">, </span><span class="s1">check_finite</span><span class="s4">=</span><span class="s3">True</span><span class="s4">))</span>
    <span class="s1">r </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_2d</span><span class="s4">(</span><span class="s1">_asarray_validated</span><span class="s4">(</span><span class="s1">r</span><span class="s4">, </span><span class="s1">check_finite</span><span class="s4">=</span><span class="s3">True</span><span class="s4">))</span>

    <span class="s2"># Get the correct data types otherwise NumPy complains</span>
    <span class="s2"># about pushing complex numbers into real arrays.</span>
    <span class="s1">r_or_c </span><span class="s4">= </span><span class="s1">complex </span><span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">iscomplexobj</span><span class="s4">(</span><span class="s1">b</span><span class="s4">) </span><span class="s3">else </span><span class="s1">float</span>

    <span class="s3">for </span><span class="s1">ind</span><span class="s4">, </span><span class="s1">mat </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">((</span><span class="s1">a</span><span class="s4">, </span><span class="s1">q</span><span class="s4">, </span><span class="s1">r</span><span class="s4">)):</span>
        <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">iscomplexobj</span><span class="s4">(</span><span class="s1">mat</span><span class="s4">):</span>
            <span class="s1">r_or_c </span><span class="s4">= </span><span class="s1">complex</span>

        <span class="s3">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">equal</span><span class="s4">(*</span><span class="s1">mat</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Matrix {} should be square.&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s5">&quot;aqr&quot;</span><span class="s4">[</span><span class="s1">ind</span><span class="s4">]))</span>

    <span class="s2"># Shape consistency checks</span>
    <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">b</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s3">if </span><span class="s1">m </span><span class="s4">!= </span><span class="s1">a</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Matrix a and b should have the same number of rows.&quot;</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">m </span><span class="s4">!= </span><span class="s1">q</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Matrix a and q should have the same shape.&quot;</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">n </span><span class="s4">!= </span><span class="s1">r</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Matrix b and r should have the same number of cols.&quot;</span><span class="s4">)</span>

    <span class="s2"># Check if the data matrices q, r are (sufficiently) hermitian</span>
    <span class="s3">for </span><span class="s1">ind</span><span class="s4">, </span><span class="s1">mat </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">((</span><span class="s1">q</span><span class="s4">, </span><span class="s1">r</span><span class="s4">)):</span>
        <span class="s3">if </span><span class="s1">norm</span><span class="s4">(</span><span class="s1">mat </span><span class="s4">- </span><span class="s1">mat</span><span class="s4">.</span><span class="s1">conj</span><span class="s4">().</span><span class="s1">T</span><span class="s4">, </span><span class="s6">1</span><span class="s4">) &gt; </span><span class="s1">np</span><span class="s4">.</span><span class="s1">spacing</span><span class="s4">(</span><span class="s1">norm</span><span class="s4">(</span><span class="s1">mat</span><span class="s4">, </span><span class="s6">1</span><span class="s4">))*</span><span class="s6">100</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Matrix {} should be symmetric/hermitian.&quot;</span>
                             <span class="s5">&quot;&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s5">&quot;qr&quot;</span><span class="s4">[</span><span class="s1">ind</span><span class="s4">]))</span>

    <span class="s2"># Continuous time ARE should have a nonsingular r matrix.</span>
    <span class="s3">if </span><span class="s1">eq_type </span><span class="s4">== </span><span class="s5">'care'</span><span class="s4">:</span>
        <span class="s1">min_sv </span><span class="s4">= </span><span class="s1">svd</span><span class="s4">(</span><span class="s1">r</span><span class="s4">, </span><span class="s1">compute_uv</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)[-</span><span class="s6">1</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">min_sv </span><span class="s4">== </span><span class="s6">0. </span><span class="s3">or </span><span class="s1">min_sv </span><span class="s4">&lt; </span><span class="s1">np</span><span class="s4">.</span><span class="s1">spacing</span><span class="s4">(</span><span class="s6">1.</span><span class="s4">)*</span><span class="s1">norm</span><span class="s4">(</span><span class="s1">r</span><span class="s4">, </span><span class="s6">1</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Matrix r is numerically singular.'</span><span class="s4">)</span>

    <span class="s2"># Check if the generalized case is required with omitted arguments</span>
    <span class="s2"># perform late shape checking etc.</span>
    <span class="s1">generalized_case </span><span class="s4">= </span><span class="s1">e </span><span class="s3">is not None or </span><span class="s1">s </span><span class="s3">is not None</span>

    <span class="s3">if </span><span class="s1">generalized_case</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">e </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">e </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_2d</span><span class="s4">(</span><span class="s1">_asarray_validated</span><span class="s4">(</span><span class="s1">e</span><span class="s4">, </span><span class="s1">check_finite</span><span class="s4">=</span><span class="s3">True</span><span class="s4">))</span>
            <span class="s3">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">equal</span><span class="s4">(*</span><span class="s1">e</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Matrix e should be square.&quot;</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">m </span><span class="s4">!= </span><span class="s1">e</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Matrix a and e should have the same shape.&quot;</span><span class="s4">)</span>
            <span class="s2"># numpy.linalg.cond doesn't check for exact zeros and</span>
            <span class="s2"># emits a runtime warning. Hence the following manual check.</span>
            <span class="s1">min_sv </span><span class="s4">= </span><span class="s1">svd</span><span class="s4">(</span><span class="s1">e</span><span class="s4">, </span><span class="s1">compute_uv</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)[-</span><span class="s6">1</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">min_sv </span><span class="s4">== </span><span class="s6">0. </span><span class="s3">or </span><span class="s1">min_sv </span><span class="s4">&lt; </span><span class="s1">np</span><span class="s4">.</span><span class="s1">spacing</span><span class="s4">(</span><span class="s6">1.</span><span class="s4">) * </span><span class="s1">norm</span><span class="s4">(</span><span class="s1">e</span><span class="s4">, </span><span class="s6">1</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Matrix e is numerically singular.'</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">iscomplexobj</span><span class="s4">(</span><span class="s1">e</span><span class="s4">):</span>
                <span class="s1">r_or_c </span><span class="s4">= </span><span class="s1">complex</span>
        <span class="s3">if </span><span class="s1">s </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">s </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_2d</span><span class="s4">(</span><span class="s1">_asarray_validated</span><span class="s4">(</span><span class="s1">s</span><span class="s4">, </span><span class="s1">check_finite</span><span class="s4">=</span><span class="s3">True</span><span class="s4">))</span>
            <span class="s3">if </span><span class="s1">s</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">!= </span><span class="s1">b</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Matrix b and s should have the same shape.&quot;</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">iscomplexobj</span><span class="s4">(</span><span class="s1">s</span><span class="s4">):</span>
                <span class="s1">r_or_c </span><span class="s4">= </span><span class="s1">complex</span>

    <span class="s3">return </span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">q</span><span class="s4">, </span><span class="s1">r</span><span class="s4">, </span><span class="s1">e</span><span class="s4">, </span><span class="s1">s</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">r_or_c</span><span class="s4">, </span><span class="s1">generalized_case</span>
</pre>
</body>
</html>