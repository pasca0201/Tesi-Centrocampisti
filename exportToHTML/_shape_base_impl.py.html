<html>
<head>
<title>_shape_base_impl.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_shape_base_impl.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">numeric </span><span class="s0">as </span><span class="s1">_nx</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">numeric </span><span class="s0">import </span><span class="s1">asarray</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">, </span><span class="s1">zeros_like</span><span class="s2">, </span><span class="s1">array</span><span class="s2">, </span><span class="s1">asanyarray</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">fromnumeric </span><span class="s0">import </span><span class="s1">reshape</span><span class="s2">, </span><span class="s1">transpose</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">multiarray </span><span class="s0">import </span><span class="s1">normalize_axis_index</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">_multiarray_umath </span><span class="s0">import </span><span class="s1">_array_converter</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core </span><span class="s0">import </span><span class="s1">overrides</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core </span><span class="s0">import </span><span class="s1">vstack</span><span class="s2">, </span><span class="s1">atleast_3d</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">numeric </span><span class="s0">import </span><span class="s1">normalize_axis_tuple</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">overrides </span><span class="s0">import </span><span class="s1">set_module</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">_core</span><span class="s2">.</span><span class="s1">shape_base </span><span class="s0">import </span><span class="s1">_arrays_for_stack_dispatcher</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">lib</span><span class="s2">.</span><span class="s1">_index_tricks_impl </span><span class="s0">import </span><span class="s1">ndindex</span>
<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">matrixlib</span><span class="s2">.</span><span class="s1">defmatrix </span><span class="s0">import </span><span class="s1">matrix  </span><span class="s3"># this raises all the right alarm bells</span>


<span class="s1">__all__ </span><span class="s2">= [</span>
    <span class="s4">'column_stack'</span><span class="s2">, </span><span class="s4">'row_stack'</span><span class="s2">, </span><span class="s4">'dstack'</span><span class="s2">, </span><span class="s4">'array_split'</span><span class="s2">, </span><span class="s4">'split'</span><span class="s2">,</span>
    <span class="s4">'hsplit'</span><span class="s2">, </span><span class="s4">'vsplit'</span><span class="s2">, </span><span class="s4">'dsplit'</span><span class="s2">, </span><span class="s4">'apply_over_axes'</span><span class="s2">, </span><span class="s4">'expand_dims'</span><span class="s2">,</span>
    <span class="s4">'apply_along_axis'</span><span class="s2">, </span><span class="s4">'kron'</span><span class="s2">, </span><span class="s4">'tile'</span><span class="s2">, </span><span class="s4">'take_along_axis'</span><span class="s2">,</span>
    <span class="s4">'put_along_axis'</span>
    <span class="s2">]</span>


<span class="s1">array_function_dispatch </span><span class="s2">= </span><span class="s1">functools</span><span class="s2">.</span><span class="s1">partial</span><span class="s2">(</span>
    <span class="s1">overrides</span><span class="s2">.</span><span class="s1">array_function_dispatch</span><span class="s2">, </span><span class="s1">module</span><span class="s2">=</span><span class="s4">'numpy'</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_make_along_axis_idx</span><span class="s2">(</span><span class="s1">arr_shape</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s3"># compute dimensions to iterate over</span>
    <span class="s0">if not </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">integer</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s4">'`indices` must be an integer array'</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">arr_shape</span><span class="s2">) != </span><span class="s1">indices</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">&quot;`indices` and `arr` must have the same number of dimensions&quot;</span><span class="s2">)</span>
    <span class="s1">shape_ones </span><span class="s2">= (</span><span class="s5">1</span><span class="s2">,) * </span><span class="s1">indices</span><span class="s2">.</span><span class="s1">ndim</span>
    <span class="s1">dest_dims </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">)) + [</span><span class="s0">None</span><span class="s2">] + </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">+</span><span class="s5">1</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">))</span>

    <span class="s3"># build a fancy index, consisting of orthogonal aranges, with the</span>
    <span class="s3"># requested index inserted at the right location</span>
    <span class="s1">fancy_index </span><span class="s2">= []</span>
    <span class="s0">for </span><span class="s1">dim</span><span class="s2">, </span><span class="s1">n </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">dest_dims</span><span class="s2">, </span><span class="s1">arr_shape</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">dim </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">fancy_index</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">ind_shape </span><span class="s2">= </span><span class="s1">shape_ones</span><span class="s2">[:</span><span class="s1">dim</span><span class="s2">] + (-</span><span class="s5">1</span><span class="s2">,) + </span><span class="s1">shape_ones</span><span class="s2">[</span><span class="s1">dim</span><span class="s2">+</span><span class="s5">1</span><span class="s2">:]</span>
            <span class="s1">fancy_index</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">ind_shape</span><span class="s2">))</span>

    <span class="s0">return </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">fancy_index</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_take_along_axis_dispatcher</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_take_along_axis_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">take_along_axis</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Take values from the input array by matching 1d index and data slices. 
 
    This iterates over matching 1d slices oriented along the specified axis in 
    the index and data arrays, and uses the former to look up values in the 
    latter. These slices can be different lengths. 
 
    Functions returning an index along an axis, like `argsort` and 
    `argpartition`, produce suitable indices for this function. 
 
    .. versionadded:: 1.15.0 
 
    Parameters 
    ---------- 
    arr : ndarray (Ni..., M, Nk...) 
        Source array 
    indices : ndarray (Ni..., J, Nk...) 
        Indices to take along each 1d slice of `arr`. This must match the 
        dimension of arr, but dimensions Ni and Nj only need to broadcast 
        against `arr`. 
    axis : int 
        The axis to take 1d slices along. If axis is None, the input array is 
        treated as if it had first been flattened to 1d, for consistency with 
        `sort` and `argsort`. 
 
    Returns 
    ------- 
    out: ndarray (Ni..., J, Nk...) 
        The indexed result. 
 
    Notes 
    ----- 
    This is equivalent to (but faster than) the following use of `ndindex` and 
    `s_`, which sets each of ``ii`` and ``kk`` to a tuple of indices:: 
 
        Ni, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:] 
        J = indices.shape[axis]  # Need not equal M 
        out = np.empty(Ni + (J,) + Nk) 
 
        for ii in ndindex(Ni): 
            for kk in ndindex(Nk): 
                a_1d       = a      [ii + s_[:,] + kk] 
                indices_1d = indices[ii + s_[:,] + kk] 
                out_1d     = out    [ii + s_[:,] + kk] 
                for j in range(J): 
                    out_1d[j] = a_1d[indices_1d[j]] 
 
    Equivalently, eliminating the inner loop, the last two lines would be:: 
 
                out_1d[:] = a_1d[indices_1d] 
 
    See Also 
    -------- 
    take : Take along an axis, using the same indices for every 1d slice 
    put_along_axis : 
        Put values into the destination array by matching 1d index and data slices 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
 
    For this sample array 
 
    &gt;&gt;&gt; a = np.array([[10, 30, 20], [60, 40, 50]]) 
 
    We can sort either by using sort directly, or argsort and this function 
 
    &gt;&gt;&gt; np.sort(a, axis=1) 
    array([[10, 20, 30], 
           [40, 50, 60]]) 
    &gt;&gt;&gt; ai = np.argsort(a, axis=1) 
    &gt;&gt;&gt; ai 
    array([[0, 2, 1], 
           [1, 2, 0]]) 
    &gt;&gt;&gt; np.take_along_axis(a, ai, axis=1) 
    array([[10, 20, 30], 
           [40, 50, 60]]) 
 
    The same works for max and min, if you maintain the trivial dimension 
    with ``keepdims``: 
 
    &gt;&gt;&gt; np.max(a, axis=1, keepdims=True) 
    array([[30], 
           [60]]) 
    &gt;&gt;&gt; ai = np.argmax(a, axis=1, keepdims=True) 
    &gt;&gt;&gt; ai 
    array([[1], 
           [0]]) 
    &gt;&gt;&gt; np.take_along_axis(a, ai, axis=1) 
    array([[30], 
           [60]]) 
 
    If we want to get the max and min at the same time, we can stack the 
    indices first 
 
    &gt;&gt;&gt; ai_min = np.argmin(a, axis=1, keepdims=True) 
    &gt;&gt;&gt; ai_max = np.argmax(a, axis=1, keepdims=True) 
    &gt;&gt;&gt; ai = np.concatenate([ai_min, ai_max], axis=1) 
    &gt;&gt;&gt; ai 
    array([[0, 1], 
           [1, 0]]) 
    &gt;&gt;&gt; np.take_along_axis(a, ai, axis=1) 
    array([[10, 30], 
           [40, 60]]) 
    &quot;&quot;&quot;</span>
    <span class="s3"># normalize inputs</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">indices</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">'when axis=None, `indices` must have a single dimension.'</span><span class="s2">)</span>
        <span class="s1">arr </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">flat</span>
        <span class="s1">arr_shape </span><span class="s2">= (</span><span class="s1">len</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">),)  </span><span class="s3"># flatiter has no .shape</span>
        <span class="s1">axis </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">axis </span><span class="s2">= </span><span class="s1">normalize_axis_index</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>
        <span class="s1">arr_shape </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">shape</span>

    <span class="s3"># use the fancy index</span>
    <span class="s0">return </span><span class="s1">arr</span><span class="s2">[</span><span class="s1">_make_along_axis_idx</span><span class="s2">(</span><span class="s1">arr_shape</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)]</span>


<span class="s0">def </span><span class="s1">_put_along_axis_dispatcher</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">values</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_put_along_axis_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">put_along_axis</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Put values into the destination array by matching 1d index and data slices. 
 
    This iterates over matching 1d slices oriented along the specified axis in 
    the index and data arrays, and uses the former to place values into the 
    latter. These slices can be different lengths. 
 
    Functions returning an index along an axis, like `argsort` and 
    `argpartition`, produce suitable indices for this function. 
 
    .. versionadded:: 1.15.0 
 
    Parameters 
    ---------- 
    arr : ndarray (Ni..., M, Nk...) 
        Destination array. 
    indices : ndarray (Ni..., J, Nk...) 
        Indices to change along each 1d slice of `arr`. This must match the 
        dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast 
        against `arr`. 
    values : array_like (Ni..., J, Nk...) 
        values to insert at those indices. Its shape and dimension are 
        broadcast to match that of `indices`. 
    axis : int 
        The axis to take 1d slices along. If axis is None, the destination 
        array is treated as if a flattened 1d view had been created of it. 
 
    Notes 
    ----- 
    This is equivalent to (but faster than) the following use of `ndindex` and 
    `s_`, which sets each of ``ii`` and ``kk`` to a tuple of indices:: 
 
        Ni, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:] 
        J = indices.shape[axis]  # Need not equal M 
 
        for ii in ndindex(Ni): 
            for kk in ndindex(Nk): 
                a_1d       = a      [ii + s_[:,] + kk] 
                indices_1d = indices[ii + s_[:,] + kk] 
                values_1d  = values [ii + s_[:,] + kk] 
                for j in range(J): 
                    a_1d[indices_1d[j]] = values_1d[j] 
 
    Equivalently, eliminating the inner loop, the last two lines would be:: 
 
                a_1d[indices_1d] = values_1d 
 
    See Also 
    -------- 
    take_along_axis : 
        Take values from the input array by matching 1d index and data slices 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
 
    For this sample array 
 
    &gt;&gt;&gt; a = np.array([[10, 30, 20], [60, 40, 50]]) 
 
    We can replace the maximum values with: 
 
    &gt;&gt;&gt; ai = np.argmax(a, axis=1, keepdims=True) 
    &gt;&gt;&gt; ai 
    array([[1], 
           [0]]) 
    &gt;&gt;&gt; np.put_along_axis(a, ai, 99, axis=1) 
    &gt;&gt;&gt; a 
    array([[10, 99, 20], 
           [99, 40, 50]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># normalize inputs</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">indices</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">'when axis=None, `indices` must have a single dimension.'</span><span class="s2">)</span>
        <span class="s1">arr </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">flat</span>
        <span class="s1">axis </span><span class="s2">= </span><span class="s5">0</span>
        <span class="s1">arr_shape </span><span class="s2">= (</span><span class="s1">len</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">),)  </span><span class="s3"># flatiter has no .shape</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">axis </span><span class="s2">= </span><span class="s1">normalize_axis_index</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>
        <span class="s1">arr_shape </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">shape</span>

    <span class="s3"># use the fancy index</span>
    <span class="s1">arr</span><span class="s2">[</span><span class="s1">_make_along_axis_idx</span><span class="s2">(</span><span class="s1">arr_shape</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)] = </span><span class="s1">values</span>


<span class="s0">def </span><span class="s1">_apply_along_axis_dispatcher</span><span class="s2">(</span><span class="s1">func1d</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">arr</span><span class="s2">,)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_apply_along_axis_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">apply_along_axis</span><span class="s2">(</span><span class="s1">func1d</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Apply a function to 1-D slices along the given axis. 
 
    Execute `func1d(a, *args, **kwargs)` where `func1d` operates on 1-D arrays 
    and `a` is a 1-D slice of `arr` along `axis`. 
 
    This is equivalent to (but faster than) the following use of `ndindex` and 
    `s_`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of indices:: 
 
        Ni, Nk = a.shape[:axis], a.shape[axis+1:] 
        for ii in ndindex(Ni): 
            for kk in ndindex(Nk): 
                f = func1d(arr[ii + s_[:,] + kk]) 
                Nj = f.shape 
                for jj in ndindex(Nj): 
                    out[ii + jj + kk] = f[jj] 
 
    Equivalently, eliminating the inner loop, this can be expressed as:: 
 
        Ni, Nk = a.shape[:axis], a.shape[axis+1:] 
        for ii in ndindex(Ni): 
            for kk in ndindex(Nk): 
                out[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk]) 
 
    Parameters 
    ---------- 
    func1d : function (M,) -&gt; (Nj...) 
        This function should accept 1-D arrays. It is applied to 1-D 
        slices of `arr` along the specified axis. 
    axis : integer 
        Axis along which `arr` is sliced. 
    arr : ndarray (Ni..., M, Nk...) 
        Input array. 
    args : any 
        Additional arguments to `func1d`. 
    kwargs : any 
        Additional named arguments to `func1d`. 
 
        .. versionadded:: 1.9.0 
 
 
    Returns 
    ------- 
    out : ndarray  (Ni..., Nj..., Nk...) 
        The output array. The shape of `out` is identical to the shape of 
        `arr`, except along the `axis` dimension. This axis is removed, and 
        replaced with new dimensions equal to the shape of the return value 
        of `func1d`. So if `func1d` returns a scalar `out` will have one 
        fewer dimensions than `arr`. 
 
    See Also 
    -------- 
    apply_over_axes : Apply a function repeatedly over multiple axes. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; def my_func(a): 
    ...     \&quot;\&quot;\&quot;Average first and last element of a 1-D array\&quot;\&quot;\&quot; 
    ...     return (a[0] + a[-1]) * 0.5 
    &gt;&gt;&gt; b = np.array([[1,2,3], [4,5,6], [7,8,9]]) 
    &gt;&gt;&gt; np.apply_along_axis(my_func, 0, b) 
    array([4., 5., 6.]) 
    &gt;&gt;&gt; np.apply_along_axis(my_func, 1, b) 
    array([2.,  5.,  8.]) 
 
    For a function that returns a 1D array, the number of dimensions in 
    `outarr` is the same as `arr`. 
 
    &gt;&gt;&gt; b = np.array([[8,1,7], [4,3,9], [5,2,6]]) 
    &gt;&gt;&gt; np.apply_along_axis(sorted, 1, b) 
    array([[1, 7, 8], 
           [3, 4, 9], 
           [2, 5, 6]]) 
 
    For a function that returns a higher dimensional array, those dimensions 
    are inserted in place of the `axis` dimension. 
 
    &gt;&gt;&gt; b = np.array([[1,2,3], [4,5,6], [7,8,9]]) 
    &gt;&gt;&gt; np.apply_along_axis(np.diag, -1, b) 
    array([[[1, 0, 0], 
            [0, 2, 0], 
            [0, 0, 3]], 
           [[4, 0, 0], 
            [0, 5, 0], 
            [0, 0, 6]], 
           [[7, 0, 0], 
            [0, 8, 0], 
            [0, 0, 9]]]) 
    &quot;&quot;&quot;</span>
    <span class="s3"># handle negative axes</span>
    <span class="s1">conv </span><span class="s2">= </span><span class="s1">_array_converter</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">)</span>
    <span class="s1">arr </span><span class="s2">= </span><span class="s1">conv</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>

    <span class="s1">nd </span><span class="s2">= </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ndim</span>
    <span class="s1">axis </span><span class="s2">= </span><span class="s1">normalize_axis_index</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">nd</span><span class="s2">)</span>

    <span class="s3"># arr, with the iteration axis at the end</span>
    <span class="s1">in_dims </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">nd</span><span class="s2">))</span>
    <span class="s1">inarr_view </span><span class="s2">= </span><span class="s1">transpose</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">in_dims</span><span class="s2">[:</span><span class="s1">axis</span><span class="s2">] + </span><span class="s1">in_dims</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">+</span><span class="s5">1</span><span class="s2">:] + [</span><span class="s1">axis</span><span class="s2">])</span>

    <span class="s3"># compute indices for the iteration axes, and append a trailing ellipsis to</span>
    <span class="s3"># prevent 0d arrays decaying to scalars, which fixes gh-8642</span>
    <span class="s1">inds </span><span class="s2">= </span><span class="s1">ndindex</span><span class="s2">(</span><span class="s1">inarr_view</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">])</span>
    <span class="s1">inds </span><span class="s2">= (</span><span class="s1">ind </span><span class="s2">+ (</span><span class="s1">Ellipsis</span><span class="s2">,) </span><span class="s0">for </span><span class="s1">ind </span><span class="s0">in </span><span class="s1">inds</span><span class="s2">)</span>

    <span class="s3"># invoke the function on the first item</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">ind0 </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">inds</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">StopIteration</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">'Cannot apply_along_axis when any iteration dimensions are 0'</span>
        <span class="s2">) </span><span class="s0">from None</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">func1d</span><span class="s2">(</span><span class="s1">inarr_view</span><span class="s2">[</span><span class="s1">ind0</span><span class="s2">], *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">))</span>

    <span class="s3"># build a buffer for storing evaluations of func1d.</span>
    <span class="s3"># remove the requested axis, and add the new ones on the end.</span>
    <span class="s3"># laid out so that each write is contiguous.</span>
    <span class="s3"># for a tuple index inds, buff[inds] = func1d(inarr_view[inds])</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s1">matrix</span><span class="s2">):</span>
        <span class="s1">buff </span><span class="s2">= </span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">inarr_view</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">] + </span><span class="s1">res</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s3"># Matrices are nasty with reshaping, so do not preserve them here.</span>
        <span class="s1">buff </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">inarr_view</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">] + </span><span class="s1">res</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">res</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s3"># permutation of axes such that out = buff.transpose(buff_permute)</span>
    <span class="s1">buff_dims </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">buff</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">))</span>
    <span class="s1">buff_permute </span><span class="s2">= (</span>
        <span class="s1">buff_dims</span><span class="s2">[</span><span class="s5">0 </span><span class="s2">: </span><span class="s1">axis</span><span class="s2">] +</span>
        <span class="s1">buff_dims</span><span class="s2">[</span><span class="s1">buff</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">-</span><span class="s1">res</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">: </span><span class="s1">buff</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">] +</span>
        <span class="s1">buff_dims</span><span class="s2">[</span><span class="s1">axis </span><span class="s2">: </span><span class="s1">buff</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">-</span><span class="s1">res</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">]</span>
    <span class="s2">)</span>

    <span class="s3"># save the first result, then compute and save all remaining results</span>
    <span class="s1">buff</span><span class="s2">[</span><span class="s1">ind0</span><span class="s2">] = </span><span class="s1">res</span>
    <span class="s0">for </span><span class="s1">ind </span><span class="s0">in </span><span class="s1">inds</span><span class="s2">:</span>
        <span class="s1">buff</span><span class="s2">[</span><span class="s1">ind</span><span class="s2">] = </span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">func1d</span><span class="s2">(</span><span class="s1">inarr_view</span><span class="s2">[</span><span class="s1">ind</span><span class="s2">], *</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">))</span>

    <span class="s1">res </span><span class="s2">= </span><span class="s1">transpose</span><span class="s2">(</span><span class="s1">buff</span><span class="s2">, </span><span class="s1">buff_permute</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">conv</span><span class="s2">.</span><span class="s1">wrap</span><span class="s2">(</span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_apply_over_axes_dispatcher</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">a</span><span class="s2">,)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_apply_over_axes_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">apply_over_axes</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Apply a function repeatedly over multiple axes. 
 
    `func` is called as `res = func(a, axis)`, where `axis` is the first 
    element of `axes`.  The result `res` of the function call must have 
    either the same dimensions as `a` or one less dimension.  If `res` 
    has one less dimension than `a`, a dimension is inserted before 
    `axis`.  The call to `func` is then repeated for each axis in `axes`, 
    with `res` as the first argument. 
 
    Parameters 
    ---------- 
    func : function 
        This function must take two arguments, `func(a, axis)`. 
    a : array_like 
        Input array. 
    axes : array_like 
        Axes over which `func` is applied; the elements must be integers. 
 
    Returns 
    ------- 
    apply_over_axis : ndarray 
        The output array.  The number of dimensions is the same as `a`, 
        but the shape can be different.  This depends on whether `func` 
        changes the shape of its output with respect to its input. 
 
    See Also 
    -------- 
    apply_along_axis : 
        Apply a function to 1-D slices of an array along the given axis. 
 
    Notes 
    ----- 
    This function is equivalent to tuple axis arguments to reorderable ufuncs 
    with keepdims=True. Tuple axis arguments to ufuncs have been available since 
    version 1.7.0. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.arange(24).reshape(2,3,4) 
    &gt;&gt;&gt; a 
    array([[[ 0,  1,  2,  3], 
            [ 4,  5,  6,  7], 
            [ 8,  9, 10, 11]], 
           [[12, 13, 14, 15], 
            [16, 17, 18, 19], 
            [20, 21, 22, 23]]]) 
 
    Sum over axes 0 and 2. The result has same number of dimensions 
    as the original array: 
 
    &gt;&gt;&gt; np.apply_over_axes(np.sum, a, [0,2]) 
    array([[[ 60], 
            [ 92], 
            [124]]]) 
 
    Tuple axis arguments to ufuncs are equivalent: 
 
    &gt;&gt;&gt; np.sum(a, axis=(0,2), keepdims=True) 
    array([[[ 60], 
            [ 92], 
            [124]]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">val </span><span class="s2">= </span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
    <span class="s1">N </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim</span>
    <span class="s0">if </span><span class="s1">array</span><span class="s2">(</span><span class="s1">axes</span><span class="s2">).</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">axes </span><span class="s2">= (</span><span class="s1">axes</span><span class="s2">,)</span>
    <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">axes</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">axis </span><span class="s2">= </span><span class="s1">N </span><span class="s2">+ </span><span class="s1">axis</span>
        <span class="s1">args </span><span class="s2">= (</span><span class="s1">val</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">res</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s1">val</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
            <span class="s1">val </span><span class="s2">= </span><span class="s1">res</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">expand_dims</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">res</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s1">val</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">:</span>
                <span class="s1">val </span><span class="s2">= </span><span class="s1">res</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;function is not returning &quot;</span>
                                 <span class="s4">&quot;an array of the correct shape&quot;</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">val</span>


<span class="s0">def </span><span class="s1">_expand_dims_dispatcher</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">a</span><span class="s2">,)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_expand_dims_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">expand_dims</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Expand the shape of an array. 
 
    Insert a new axis that will appear at the `axis` position in the expanded 
    array shape. 
 
    Parameters 
    ---------- 
    a : array_like 
        Input array. 
    axis : int or tuple of ints 
        Position in the expanded axes where the new axis (or axes) is placed. 
 
        .. deprecated:: 1.13.0 
            Passing an axis where ``axis &gt; a.ndim`` will be treated as 
            ``axis == a.ndim``, and passing ``axis &lt; -a.ndim - 1`` will 
            be treated as ``axis == 0``. This behavior is deprecated. 
 
        .. versionchanged:: 1.18.0 
            A tuple of axes is now supported.  Out of range axes as 
            described above are now forbidden and raise an 
            `~exceptions.AxisError`. 
 
    Returns 
    ------- 
    result : ndarray 
        View of `a` with the number of dimensions increased. 
 
    See Also 
    -------- 
    squeeze : The inverse operation, removing singleton dimensions 
    reshape : Insert, remove, and combine dimensions, and resize existing ones 
    atleast_1d, atleast_2d, atleast_3d 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.array([1, 2]) 
    &gt;&gt;&gt; x.shape 
    (2,) 
 
    The following is equivalent to ``x[np.newaxis, :]`` or ``x[np.newaxis]``: 
 
    &gt;&gt;&gt; y = np.expand_dims(x, axis=0) 
    &gt;&gt;&gt; y 
    array([[1, 2]]) 
    &gt;&gt;&gt; y.shape 
    (1, 2) 
 
    The following is equivalent to ``x[:, np.newaxis]``: 
 
    &gt;&gt;&gt; y = np.expand_dims(x, axis=1) 
    &gt;&gt;&gt; y 
    array([[1], 
           [2]]) 
    &gt;&gt;&gt; y.shape 
    (2, 1) 
 
    ``axis`` may also be a tuple: 
 
    &gt;&gt;&gt; y = np.expand_dims(x, axis=(0, 1)) 
    &gt;&gt;&gt; y 
    array([[[1, 2]]]) 
 
    &gt;&gt;&gt; y = np.expand_dims(x, axis=(2, 0)) 
    &gt;&gt;&gt; y 
    array([[[1], 
            [2]]]) 
 
    Note that some examples may use ``None`` instead of ``np.newaxis``.  These 
    are the same objects: 
 
    &gt;&gt;&gt; np.newaxis is None 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">matrix</span><span class="s2">):</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">type</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">) </span><span class="s0">not in </span><span class="s2">(</span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">list</span><span class="s2">):</span>
        <span class="s1">axis </span><span class="s2">= (</span><span class="s1">axis</span><span class="s2">,)</span>

    <span class="s1">out_ndim </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">) + </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim</span>
    <span class="s1">axis </span><span class="s2">= </span><span class="s1">normalize_axis_tuple</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">out_ndim</span><span class="s2">)</span>

    <span class="s1">shape_it </span><span class="s2">= </span><span class="s1">iter</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
    <span class="s1">shape </span><span class="s2">= [</span><span class="s5">1 </span><span class="s0">if </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axis </span><span class="s0">else </span><span class="s1">next</span><span class="s2">(</span><span class="s1">shape_it</span><span class="s2">) </span><span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">out_ndim</span><span class="s2">)]</span>

    <span class="s0">return </span><span class="s1">a</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)</span>


<span class="s3"># NOTE: Remove once deprecation period passes</span>
<span class="s2">@</span><span class="s1">set_module</span><span class="s2">(</span><span class="s4">&quot;numpy&quot;</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">row_stack</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">, *, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">casting</span><span class="s2">=</span><span class="s4">&quot;same_kind&quot;</span><span class="s2">):</span>
    <span class="s3"># Deprecated in NumPy 2.0, 2023-08-18</span>
    <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
        <span class="s4">&quot;`row_stack` alias is deprecated. &quot;</span>
        <span class="s4">&quot;Use `np.vstack` directly.&quot;</span><span class="s2">,</span>
        <span class="s1">DeprecationWarning</span><span class="s2">,</span>
        <span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span>
    <span class="s2">)</span>
    <span class="s0">return </span><span class="s1">vstack</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">casting</span><span class="s2">=</span><span class="s1">casting</span><span class="s2">)</span>


<span class="s1">row_stack</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">vstack</span><span class="s2">.</span><span class="s1">__doc__</span>


<span class="s0">def </span><span class="s1">_column_stack_dispatcher</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">_arrays_for_stack_dispatcher</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_column_stack_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">column_stack</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Stack 1-D arrays as columns into a 2-D array. 
 
    Take a sequence of 1-D arrays and stack them as columns 
    to make a single 2-D array. 2-D arrays are stacked as-is, 
    just like with `hstack`.  1-D arrays are turned into 2-D columns 
    first. 
 
    Parameters 
    ---------- 
    tup : sequence of 1-D or 2-D arrays. 
        Arrays to stack. All of them must have the same first dimension. 
 
    Returns 
    ------- 
    stacked : 2-D array 
        The array formed by stacking the given arrays. 
 
    See Also 
    -------- 
    stack, hstack, vstack, concatenate 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array((1,2,3)) 
    &gt;&gt;&gt; b = np.array((2,3,4)) 
    &gt;&gt;&gt; np.column_stack((a,b)) 
    array([[1, 2], 
           [2, 3], 
           [3, 4]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">arrays </span><span class="s2">= []</span>
    <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">tup</span><span class="s2">:</span>
        <span class="s1">arr </span><span class="s2">= </span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">arr</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&lt; </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s1">arr </span><span class="s2">= </span><span class="s1">array</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">subok</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">ndmin</span><span class="s2">=</span><span class="s5">2</span><span class="s2">).</span><span class="s1">T</span>
        <span class="s1">arrays</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">arr</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">, </span><span class="s5">1</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_dstack_dispatcher</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">_arrays_for_stack_dispatcher</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_dstack_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">dstack</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Stack arrays in sequence depth wise (along third axis). 
 
    This is equivalent to concatenation along the third axis after 2-D arrays 
    of shape `(M,N)` have been reshaped to `(M,N,1)` and 1-D arrays of shape 
    `(N,)` have been reshaped to `(1,N,1)`. Rebuilds arrays divided by 
    `dsplit`. 
 
    This function makes most sense for arrays with up to 3 dimensions. For 
    instance, for pixel-data with a height (first axis), width (second axis), 
    and r/g/b channels (third axis). The functions `concatenate`, `stack` and 
    `block` provide more general stacking and concatenation operations. 
 
    Parameters 
    ---------- 
    tup : sequence of arrays 
        The arrays must have the same shape along all but the third axis. 
        1-D or 2-D arrays must have the same shape. 
 
    Returns 
    ------- 
    stacked : ndarray 
        The array formed by stacking the given arrays, will be at least 3-D. 
 
    See Also 
    -------- 
    concatenate : Join a sequence of arrays along an existing axis. 
    stack : Join a sequence of arrays along a new axis. 
    block : Assemble an nd-array from nested lists of blocks. 
    vstack : Stack arrays in sequence vertically (row wise). 
    hstack : Stack arrays in sequence horizontally (column wise). 
    column_stack : Stack 1-D arrays as columns into a 2-D array. 
    dsplit : Split array along third axis. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array((1,2,3)) 
    &gt;&gt;&gt; b = np.array((2,3,4)) 
    &gt;&gt;&gt; np.dstack((a,b)) 
    array([[[1, 2], 
            [2, 3], 
            [3, 4]]]) 
 
    &gt;&gt;&gt; a = np.array([[1],[2],[3]]) 
    &gt;&gt;&gt; b = np.array([[2],[3],[4]]) 
    &gt;&gt;&gt; np.dstack((a,b)) 
    array([[[1, 2]], 
           [[2, 3]], 
           [[3, 4]]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">arrs </span><span class="s2">= </span><span class="s1">atleast_3d</span><span class="s2">(*</span><span class="s1">tup</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arrs</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
        <span class="s1">arrs </span><span class="s2">= (</span><span class="s1">arrs</span><span class="s2">,)</span>
    <span class="s0">return </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">arrs</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_replace_zero_by_x_arrays</span><span class="s2">(</span><span class="s1">sub_arys</span><span class="s2">):</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">sub_arys</span><span class="s2">)):</span>
        <span class="s0">if </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">(</span><span class="s1">sub_arys</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]) == </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">sub_arys</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">sub_arys</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">sometrue</span><span class="s2">(</span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">equal</span><span class="s2">(</span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">sub_arys</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]), </span><span class="s5">0</span><span class="s2">)):</span>
            <span class="s1">sub_arys</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">sub_arys</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">sub_arys</span>


<span class="s0">def </span><span class="s1">_array_split_dispatcher</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">, </span><span class="s1">indices_or_sections</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">ary</span><span class="s2">, </span><span class="s1">indices_or_sections</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_array_split_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">array_split</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">, </span><span class="s1">indices_or_sections</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Split an array into multiple sub-arrays. 
 
    Please refer to the ``split`` documentation.  The only difference 
    between these functions is that ``array_split`` allows 
    `indices_or_sections` to be an integer that does *not* equally 
    divide the axis. For an array of length l that should be split 
    into n sections, it returns l % n sub-arrays of size l//n + 1 
    and the rest of size l//n. 
 
    See Also 
    -------- 
    split : Split array into multiple sub-arrays of equal size. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.arange(8.0) 
    &gt;&gt;&gt; np.array_split(x, 3) 
    [array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.])] 
 
    &gt;&gt;&gt; x = np.arange(9) 
    &gt;&gt;&gt; np.array_split(x, 4) 
    [array([0, 1, 2]), array([3, 4]), array([5, 6]), array([7, 8])] 
 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">Ntotal </span><span class="s2">= </span><span class="s1">ary</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
    <span class="s0">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
        <span class="s1">Ntotal </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">)</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s3"># handle array case.</span>
        <span class="s1">Nsections </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">indices_or_sections</span><span class="s2">) + </span><span class="s5">1</span>
        <span class="s1">div_points </span><span class="s2">= [</span><span class="s5">0</span><span class="s2">] + </span><span class="s1">list</span><span class="s2">(</span><span class="s1">indices_or_sections</span><span class="s2">) + [</span><span class="s1">Ntotal</span><span class="s2">]</span>
    <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
        <span class="s3"># indices_or_sections is a scalar, not an array.</span>
        <span class="s1">Nsections </span><span class="s2">= </span><span class="s1">int</span><span class="s2">(</span><span class="s1">indices_or_sections</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">Nsections </span><span class="s2">&lt;= </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">'number sections must be larger than 0.'</span><span class="s2">) </span><span class="s0">from None</span>
        <span class="s1">Neach_section</span><span class="s2">, </span><span class="s1">extras </span><span class="s2">= </span><span class="s1">divmod</span><span class="s2">(</span><span class="s1">Ntotal</span><span class="s2">, </span><span class="s1">Nsections</span><span class="s2">)</span>
        <span class="s1">section_sizes </span><span class="s2">= ([</span><span class="s5">0</span><span class="s2">] +</span>
                         <span class="s1">extras </span><span class="s2">* [</span><span class="s1">Neach_section</span><span class="s2">+</span><span class="s5">1</span><span class="s2">] +</span>
                         <span class="s2">(</span><span class="s1">Nsections</span><span class="s2">-</span><span class="s1">extras</span><span class="s2">) * [</span><span class="s1">Neach_section</span><span class="s2">])</span>
        <span class="s1">div_points </span><span class="s2">= </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">section_sizes</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">intp</span><span class="s2">).</span><span class="s1">cumsum</span><span class="s2">()</span>

    <span class="s1">sub_arys </span><span class="s2">= []</span>
    <span class="s1">sary </span><span class="s2">= </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">swapaxes</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">Nsections</span><span class="s2">):</span>
        <span class="s1">st </span><span class="s2">= </span><span class="s1">div_points</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
        <span class="s1">end </span><span class="s2">= </span><span class="s1">div_points</span><span class="s2">[</span><span class="s1">i </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">]</span>
        <span class="s1">sub_arys</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">swapaxes</span><span class="s2">(</span><span class="s1">sary</span><span class="s2">[</span><span class="s1">st</span><span class="s2">:</span><span class="s1">end</span><span class="s2">], </span><span class="s1">axis</span><span class="s2">, </span><span class="s5">0</span><span class="s2">))</span>

    <span class="s0">return </span><span class="s1">sub_arys</span>


<span class="s0">def </span><span class="s1">_split_dispatcher</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">, </span><span class="s1">indices_or_sections</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">ary</span><span class="s2">, </span><span class="s1">indices_or_sections</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_split_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">split</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">, </span><span class="s1">indices_or_sections</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Split an array into multiple sub-arrays as views into `ary`. 
 
    Parameters 
    ---------- 
    ary : ndarray 
        Array to be divided into sub-arrays. 
    indices_or_sections : int or 1-D array 
        If `indices_or_sections` is an integer, N, the array will be divided 
        into N equal arrays along `axis`.  If such a split is not possible, 
        an error is raised. 
 
        If `indices_or_sections` is a 1-D array of sorted integers, the entries 
        indicate where along `axis` the array is split.  For example, 
        ``[2, 3]`` would, for ``axis=0``, result in 
 
        - ary[:2] 
        - ary[2:3] 
        - ary[3:] 
 
        If an index exceeds the dimension of the array along `axis`, 
        an empty sub-array is returned correspondingly. 
    axis : int, optional 
        The axis along which to split, default is 0. 
 
    Returns 
    ------- 
    sub-arrays : list of ndarrays 
        A list of sub-arrays as views into `ary`. 
 
    Raises 
    ------ 
    ValueError 
        If `indices_or_sections` is given as an integer, but 
        a split does not result in equal division. 
 
    See Also 
    -------- 
    array_split : Split an array into multiple sub-arrays of equal or 
                  near-equal size.  Does not raise an exception if 
                  an equal division cannot be made. 
    hsplit : Split array into multiple sub-arrays horizontally (column-wise). 
    vsplit : Split array into multiple sub-arrays vertically (row wise). 
    dsplit : Split array into multiple sub-arrays along the 3rd axis (depth). 
    concatenate : Join a sequence of arrays along an existing axis. 
    stack : Join a sequence of arrays along a new axis. 
    hstack : Stack arrays in sequence horizontally (column wise). 
    vstack : Stack arrays in sequence vertically (row wise). 
    dstack : Stack arrays in sequence depth wise (along third dimension). 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.arange(9.0) 
    &gt;&gt;&gt; np.split(x, 3) 
    [array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.,  8.])] 
 
    &gt;&gt;&gt; x = np.arange(8.0) 
    &gt;&gt;&gt; np.split(x, [3, 5, 6, 10]) 
    [array([0.,  1.,  2.]), 
     array([3.,  4.]), 
     array([5.]), 
     array([6.,  7.]), 
     array([], dtype=float64)] 
 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">len</span><span class="s2">(</span><span class="s1">indices_or_sections</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
        <span class="s1">sections </span><span class="s2">= </span><span class="s1">indices_or_sections</span>
        <span class="s1">N </span><span class="s2">= </span><span class="s1">ary</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">N </span><span class="s2">% </span><span class="s1">sections</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">'array split does not result in an equal division'</span><span class="s2">) </span><span class="s0">from None</span>
    <span class="s0">return </span><span class="s1">array_split</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">, </span><span class="s1">indices_or_sections</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_hvdsplit_dispatcher</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">, </span><span class="s1">indices_or_sections</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">ary</span><span class="s2">, </span><span class="s1">indices_or_sections</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_hvdsplit_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">hsplit</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">, </span><span class="s1">indices_or_sections</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Split an array into multiple sub-arrays horizontally (column-wise). 
 
    Please refer to the `split` documentation.  `hsplit` is equivalent 
    to `split` with ``axis=1``, the array is always split along the second 
    axis except for 1-D arrays, where it is split at ``axis=0``. 
 
    See Also 
    -------- 
    split : Split an array into multiple sub-arrays of equal size. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.arange(16.0).reshape(4, 4) 
    &gt;&gt;&gt; x 
    array([[ 0.,   1.,   2.,   3.], 
           [ 4.,   5.,   6.,   7.], 
           [ 8.,   9.,  10.,  11.], 
           [12.,  13.,  14.,  15.]]) 
    &gt;&gt;&gt; np.hsplit(x, 2) 
    [array([[  0.,   1.], 
           [  4.,   5.], 
           [  8.,   9.], 
           [12.,  13.]]), 
     array([[  2.,   3.], 
           [  6.,   7.], 
           [10.,  11.], 
           [14.,  15.]])] 
    &gt;&gt;&gt; np.hsplit(x, np.array([3, 6])) 
    [array([[ 0.,   1.,   2.], 
           [ 4.,   5.,   6.], 
           [ 8.,   9.,  10.], 
           [12.,  13.,  14.]]), 
     array([[ 3.], 
           [ 7.], 
           [11.], 
           [15.]]), 
     array([], shape=(4, 0), dtype=float64)] 
 
    With a higher dimensional array the split is still along the second axis. 
 
    &gt;&gt;&gt; x = np.arange(8.0).reshape(2, 2, 2) 
    &gt;&gt;&gt; x 
    array([[[0.,  1.], 
            [2.,  3.]], 
           [[4.,  5.], 
            [6.,  7.]]]) 
    &gt;&gt;&gt; np.hsplit(x, 2) 
    [array([[[0.,  1.]], 
           [[4.,  5.]]]), 
     array([[[2.,  3.]], 
           [[6.,  7.]]])] 
 
    With a 1-D array, the split is along axis 0. 
 
    &gt;&gt;&gt; x = np.array([0, 1, 2, 3, 4, 5]) 
    &gt;&gt;&gt; np.hsplit(x, 2) 
    [array([0, 1, 2]), array([3, 4, 5])] 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">) == </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">'hsplit only works on arrays of 1 or more dimensions'</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">ary</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">split</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">, </span><span class="s1">indices_or_sections</span><span class="s2">, </span><span class="s5">1</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">split</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">, </span><span class="s1">indices_or_sections</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_hvdsplit_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">vsplit</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">, </span><span class="s1">indices_or_sections</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Split an array into multiple sub-arrays vertically (row-wise). 
 
    Please refer to the ``split`` documentation.  ``vsplit`` is equivalent 
    to ``split`` with `axis=0` (default), the array is always split along the 
    first axis regardless of the array dimension. 
 
    See Also 
    -------- 
    split : Split an array into multiple sub-arrays of equal size. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.arange(16.0).reshape(4, 4) 
    &gt;&gt;&gt; x 
    array([[ 0.,   1.,   2.,   3.], 
           [ 4.,   5.,   6.,   7.], 
           [ 8.,   9.,  10.,  11.], 
           [12.,  13.,  14.,  15.]]) 
    &gt;&gt;&gt; np.vsplit(x, 2) 
    [array([[0., 1., 2., 3.], 
            [4., 5., 6., 7.]]), 
     array([[ 8.,  9., 10., 11.], 
            [12., 13., 14., 15.]])] 
    &gt;&gt;&gt; np.vsplit(x, np.array([3, 6])) 
    [array([[ 0.,  1.,  2.,  3.], 
            [ 4.,  5.,  6.,  7.], 
            [ 8.,  9., 10., 11.]]), 
     array([[12., 13., 14., 15.]]), 
     array([], shape=(0, 4), dtype=float64)] 
 
    With a higher dimensional array the split is still along the first axis. 
 
    &gt;&gt;&gt; x = np.arange(8.0).reshape(2, 2, 2) 
    &gt;&gt;&gt; x 
    array([[[0.,  1.], 
            [2.,  3.]], 
           [[4.,  5.], 
            [6.,  7.]]]) 
    &gt;&gt;&gt; np.vsplit(x, 2) 
    [array([[[0., 1.], 
             [2., 3.]]]), 
     array([[[4., 5.], 
             [6., 7.]]])] 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">) &lt; </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">'vsplit only works on arrays of 2 or more dimensions'</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">split</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">, </span><span class="s1">indices_or_sections</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_hvdsplit_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">dsplit</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">, </span><span class="s1">indices_or_sections</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Split array into multiple sub-arrays along the 3rd axis (depth). 
 
    Please refer to the `split` documentation.  `dsplit` is equivalent 
    to `split` with ``axis=2``, the array is always split along the third 
    axis provided the array dimension is greater than or equal to 3. 
 
    See Also 
    -------- 
    split : Split an array into multiple sub-arrays of equal size. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.arange(16.0).reshape(2, 2, 4) 
    &gt;&gt;&gt; x 
    array([[[ 0.,   1.,   2.,   3.], 
            [ 4.,   5.,   6.,   7.]], 
           [[ 8.,   9.,  10.,  11.], 
            [12.,  13.,  14.,  15.]]]) 
    &gt;&gt;&gt; np.dsplit(x, 2) 
    [array([[[ 0.,  1.], 
            [ 4.,  5.]], 
           [[ 8.,  9.], 
            [12., 13.]]]), array([[[ 2.,  3.], 
            [ 6.,  7.]], 
           [[10., 11.], 
            [14., 15.]]])] 
    &gt;&gt;&gt; np.dsplit(x, np.array([3, 6])) 
    [array([[[ 0.,   1.,   2.], 
            [ 4.,   5.,   6.]], 
           [[ 8.,   9.,  10.], 
            [12.,  13.,  14.]]]), 
     array([[[ 3.], 
            [ 7.]], 
           [[11.], 
            [15.]]]), 
    array([], shape=(2, 2, 0), dtype=float64)] 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">) &lt; </span><span class="s5">3</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">'dsplit only works on arrays of 3 or more dimensions'</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">split</span><span class="s2">(</span><span class="s1">ary</span><span class="s2">, </span><span class="s1">indices_or_sections</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">get_array_wrap</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Find the wrapper for the array with the highest priority. 
 
    In case of ties, leftmost wins. If no wrapper is found, return None. 
 
    .. deprecated:: 2.0 
    &quot;&quot;&quot;</span>

    <span class="s3"># Deprecated in NumPy 2.0, 2023-07-11</span>
    <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span>
        <span class="s4">&quot;`get_array_wrap` is deprecated. &quot;</span>
        <span class="s4">&quot;(deprecated in NumPy 2.0)&quot;</span><span class="s2">,</span>
        <span class="s1">DeprecationWarning</span><span class="s2">,</span>
        <span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span>
    <span class="s2">)</span>

    <span class="s1">wrappers </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">((</span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s4">'__array_priority__'</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), -</span><span class="s1">i</span><span class="s2">,</span>
                 <span class="s1">x</span><span class="s2">.</span><span class="s1">__array_wrap__</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">args</span><span class="s2">)</span>
                                   <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s4">'__array_wrap__'</span><span class="s2">))</span>
    <span class="s0">if </span><span class="s1">wrappers</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">wrappers</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">][-</span><span class="s5">1</span><span class="s2">]</span>
    <span class="s0">return None</span>


<span class="s0">def </span><span class="s1">_kron_dispatcher</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_kron_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">kron</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Kronecker product of two arrays. 
 
    Computes the Kronecker product, a composite array made of blocks of the 
    second array scaled by the first. 
 
    Parameters 
    ---------- 
    a, b : array_like 
 
    Returns 
    ------- 
    out : ndarray 
 
    See Also 
    -------- 
    outer : The outer product 
 
    Notes 
    ----- 
    The function assumes that the number of dimensions of `a` and `b` 
    are the same, if necessary prepending the smallest with ones. 
    If ``a.shape = (r0,r1,..,rN)`` and ``b.shape = (s0,s1,...,sN)``, 
    the Kronecker product has shape ``(r0*s0, r1*s1, ..., rN*SN)``. 
    The elements are products of elements from `a` and `b`, organized 
    explicitly by:: 
 
        kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN] 
 
    where:: 
 
        kt = it * st + jt,  t = 0,...,N 
 
    In the common 2-D case (N=1), the block structure can be visualized:: 
 
        [[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ], 
         [  ...                              ...   ], 
         [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]] 
 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; np.kron([1,10,100], [5,6,7]) 
    array([  5,   6,   7, ..., 500, 600, 700]) 
    &gt;&gt;&gt; np.kron([5,6,7], [1,10,100]) 
    array([  5,  50, 500, ...,   7,  70, 700]) 
 
    &gt;&gt;&gt; np.kron(np.eye(2), np.ones((2,2))) 
    array([[1.,  1.,  0.,  0.], 
           [1.,  1.,  0.,  0.], 
           [0.,  0.,  1.,  1.], 
           [0.,  0.,  1.,  1.]]) 
 
    &gt;&gt;&gt; a = np.arange(100).reshape((2,5,2,5)) 
    &gt;&gt;&gt; b = np.arange(24).reshape((2,3,4)) 
    &gt;&gt;&gt; c = np.kron(a,b) 
    &gt;&gt;&gt; c.shape 
    (2, 10, 6, 20) 
    &gt;&gt;&gt; I = (1,3,0,2) 
    &gt;&gt;&gt; J = (0,2,1) 
    &gt;&gt;&gt; J1 = (0,) + J             # extend to ndim=4 
    &gt;&gt;&gt; S1 = (1,) + b.shape 
    &gt;&gt;&gt; K = tuple(np.array(I) * np.array(S1) + np.array(J1)) 
    &gt;&gt;&gt; c[K] == a[I]*b[J] 
    True 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># Working:</span>
    <span class="s3"># 1. Equalise the shapes by prepending smaller array with 1s</span>
    <span class="s3"># 2. Expand shapes of both the arrays by adding new axes at</span>
    <span class="s3">#    odd positions for 1st array and even positions for 2nd</span>
    <span class="s3"># 3. Compute the product of the modified array</span>
    <span class="s3"># 4. The inner most array elements now contain the rows of</span>
    <span class="s3">#    the Kronecker product</span>
    <span class="s3"># 5. Reshape the result to kron's shape, which is same as</span>
    <span class="s3">#    product of shapes of the two arrays.</span>
    <span class="s1">b </span><span class="s2">= </span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">array</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">subok</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">ndmin</span><span class="s2">=</span><span class="s1">b</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">)</span>
    <span class="s1">is_any_mat </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">matrix</span><span class="s2">) </span><span class="s0">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">matrix</span><span class="s2">)</span>
    <span class="s1">ndb</span><span class="s2">, </span><span class="s1">nda </span><span class="s2">= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">a</span><span class="s2">.</span><span class="s1">ndim</span>
    <span class="s1">nd </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">ndb</span><span class="s2">, </span><span class="s1">nda</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s2">(</span><span class="s1">nda </span><span class="s2">== </span><span class="s5">0 </span><span class="s0">or </span><span class="s1">ndb </span><span class="s2">== </span><span class="s5">0</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>

    <span class="s1">as_ </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">shape</span>
    <span class="s1">bs </span><span class="s2">= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">shape</span>
    <span class="s0">if not </span><span class="s1">a</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">contiguous</span><span class="s2">:</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">as_</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s1">b</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">contiguous</span><span class="s2">:</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">bs</span><span class="s2">)</span>

    <span class="s3"># Equalise the shapes by prepending smaller one with 1s</span>
    <span class="s1">as_ </span><span class="s2">= (</span><span class="s5">1</span><span class="s2">,)*</span><span class="s1">max</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">ndb</span><span class="s2">-</span><span class="s1">nda</span><span class="s2">) + </span><span class="s1">as_</span>
    <span class="s1">bs </span><span class="s2">= (</span><span class="s5">1</span><span class="s2">,)*</span><span class="s1">max</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">nda</span><span class="s2">-</span><span class="s1">ndb</span><span class="s2">) + </span><span class="s1">bs</span>

    <span class="s3"># Insert empty dimensions</span>
    <span class="s1">a_arr </span><span class="s2">= </span><span class="s1">expand_dims</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">ndb</span><span class="s2">-</span><span class="s1">nda</span><span class="s2">)))</span>
    <span class="s1">b_arr </span><span class="s2">= </span><span class="s1">expand_dims</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">nda</span><span class="s2">-</span><span class="s1">ndb</span><span class="s2">)))</span>

    <span class="s3"># Compute the product</span>
    <span class="s1">a_arr </span><span class="s2">= </span><span class="s1">expand_dims</span><span class="s2">(</span><span class="s1">a_arr</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">nd</span><span class="s2">*</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)))</span>
    <span class="s1">b_arr </span><span class="s2">= </span><span class="s1">expand_dims</span><span class="s2">(</span><span class="s1">b_arr</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">nd</span><span class="s2">*</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)))</span>
    <span class="s3"># In case of `mat`, convert result to `array`</span>
    <span class="s1">result </span><span class="s2">= </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">a_arr</span><span class="s2">, </span><span class="s1">b_arr</span><span class="s2">, </span><span class="s1">subok</span><span class="s2">=(</span><span class="s0">not </span><span class="s1">is_any_mat</span><span class="s2">))</span>

    <span class="s3"># Reshape back</span>
    <span class="s1">result </span><span class="s2">= </span><span class="s1">result</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">as_</span><span class="s2">, </span><span class="s1">bs</span><span class="s2">))</span>

    <span class="s0">return </span><span class="s1">result </span><span class="s0">if not </span><span class="s1">is_any_mat </span><span class="s0">else </span><span class="s1">matrix</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_tile_dispatcher</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">reps</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">reps</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">array_function_dispatch</span><span class="s2">(</span><span class="s1">_tile_dispatcher</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">tile</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">reps</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Construct an array by repeating A the number of times given by reps. 
 
    If `reps` has length ``d``, the result will have dimension of 
    ``max(d, A.ndim)``. 
 
    If ``A.ndim &lt; d``, `A` is promoted to be d-dimensional by prepending new 
    axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, 
    or shape (1, 1, 3) for 3-D replication. If this is not the desired 
    behavior, promote `A` to d-dimensions manually before calling this 
    function. 
 
    If ``A.ndim &gt; d``, `reps` is promoted to `A`.ndim by prepending 1's to it. 
    Thus for an `A` of shape (2, 3, 4, 5), a `reps` of (2, 2) is treated as 
    (1, 1, 2, 2). 
 
    Note : Although tile may be used for broadcasting, it is strongly 
    recommended to use numpy's broadcasting operations and functions. 
 
    Parameters 
    ---------- 
    A : array_like 
        The input array. 
    reps : array_like 
        The number of repetitions of `A` along each axis. 
 
    Returns 
    ------- 
    c : ndarray 
        The tiled output array. 
 
    See Also 
    -------- 
    repeat : Repeat elements of an array. 
    broadcast_to : Broadcast an array to a new shape 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.array([0, 1, 2]) 
    &gt;&gt;&gt; np.tile(a, 2) 
    array([0, 1, 2, 0, 1, 2]) 
    &gt;&gt;&gt; np.tile(a, (2, 2)) 
    array([[0, 1, 2, 0, 1, 2], 
           [0, 1, 2, 0, 1, 2]]) 
    &gt;&gt;&gt; np.tile(a, (2, 1, 2)) 
    array([[[0, 1, 2, 0, 1, 2]], 
           [[0, 1, 2, 0, 1, 2]]]) 
 
    &gt;&gt;&gt; b = np.array([[1, 2], [3, 4]]) 
    &gt;&gt;&gt; np.tile(b, 2) 
    array([[1, 2, 1, 2], 
           [3, 4, 3, 4]]) 
    &gt;&gt;&gt; np.tile(b, (2, 1)) 
    array([[1, 2], 
           [3, 4], 
           [1, 2], 
           [3, 4]]) 
 
    &gt;&gt;&gt; c = np.array([1,2,3,4]) 
    &gt;&gt;&gt; np.tile(c,(4,1)) 
    array([[1, 2, 3, 4], 
           [1, 2, 3, 4], 
           [1, 2, 3, 4], 
           [1, 2, 3, 4]]) 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">tup </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">reps</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
        <span class="s1">tup </span><span class="s2">= (</span><span class="s1">reps</span><span class="s2">,)</span>
    <span class="s1">d </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">tup</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">all</span><span class="s2">(</span><span class="s1">x </span><span class="s2">== </span><span class="s5">1 </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">tup</span><span class="s2">) </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">):</span>
        <span class="s3"># Fixes the problem that the function does not make a copy if A is a</span>
        <span class="s3"># numpy array and the repetitions are 1 in all dimensions</span>
        <span class="s0">return </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">subok</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">ndmin</span><span class="s2">=</span><span class="s1">d</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s3"># Note that no copy of zero-sized arrays is made. However since they</span>
        <span class="s3"># have no data there is no risk of an inadvertent overwrite.</span>
        <span class="s1">c </span><span class="s2">= </span><span class="s1">_nx</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">A</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">subok</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">ndmin</span><span class="s2">=</span><span class="s1">d</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s2">(</span><span class="s1">d </span><span class="s2">&lt; </span><span class="s1">c</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">):</span>
        <span class="s1">tup </span><span class="s2">= (</span><span class="s5">1</span><span class="s2">,)*(</span><span class="s1">c</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">-</span><span class="s1">d</span><span class="s2">) + </span><span class="s1">tup</span>
    <span class="s1">shape_out </span><span class="s2">= </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">s</span><span class="s2">*</span><span class="s1">t </span><span class="s0">for </span><span class="s1">s</span><span class="s2">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">c</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">tup</span><span class="s2">))</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">c</span><span class="s2">.</span><span class="s1">size</span>
    <span class="s0">if </span><span class="s1">n </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s0">for </span><span class="s1">dim_in</span><span class="s2">, </span><span class="s1">nrep </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">c</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">tup</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">nrep </span><span class="s2">!= </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s1">c </span><span class="s2">= </span><span class="s1">c</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">n</span><span class="s2">).</span><span class="s1">repeat</span><span class="s2">(</span><span class="s1">nrep</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)</span>
            <span class="s1">n </span><span class="s2">//= </span><span class="s1">dim_in</span>
    <span class="s0">return </span><span class="s1">c</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">shape_out</span><span class="s2">)</span>
</pre>
</body>
</html>