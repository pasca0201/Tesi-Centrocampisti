<html>
<head>
<title>pipeline.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pipeline.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Utilities to build a composite estimator as a chain of transforms and estimators.&quot;&quot;&quot;</span>

<span class="s2"># Author: Edouard Duchesnay</span>
<span class="s2">#         Gael Varoquaux</span>
<span class="s2">#         Virgile Fritsch</span>
<span class="s2">#         Alexandre Gramfort</span>
<span class="s2">#         Lars Buitinck</span>
<span class="s2"># License: BSD</span>

<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">Counter</span><span class="s4">, </span><span class="s1">defaultdict</span>
<span class="s3">from </span><span class="s1">itertools </span><span class="s3">import </span><span class="s1">chain</span><span class="s4">, </span><span class="s1">islice</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">sparse</span>

<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">TransformerMixin</span><span class="s4">, </span><span class="s1">_fit_context</span><span class="s4">, </span><span class="s1">clone</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">exceptions </span><span class="s3">import </span><span class="s1">NotFittedError</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">preprocessing </span><span class="s3">import </span><span class="s1">FunctionTransformer</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">utils </span><span class="s3">import </span><span class="s1">Bunch</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_estimator_html_repr </span><span class="s3">import </span><span class="s1">_VisualBlock</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_metadata_requests </span><span class="s3">import </span><span class="s1">METHODS</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_param_validation </span><span class="s3">import </span><span class="s1">HasMethods</span><span class="s4">, </span><span class="s1">Hidden</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_set_output </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">_get_container_adapter</span><span class="s4">,</span>
    <span class="s1">_safe_set_output</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_tags </span><span class="s3">import </span><span class="s1">_safe_tags</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_user_interface </span><span class="s3">import </span><span class="s1">_print_elapsed_time</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">deprecation </span><span class="s3">import </span><span class="s1">_deprecate_Xt_in_inverse_transform</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">metadata_routing </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">MetadataRouter</span><span class="s4">,</span>
    <span class="s1">MethodMapping</span><span class="s4">,</span>
    <span class="s1">_raise_for_params</span><span class="s4">,</span>
    <span class="s1">_routing_enabled</span><span class="s4">,</span>
    <span class="s1">process_routing</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">metaestimators </span><span class="s3">import </span><span class="s1">_BaseComposition</span><span class="s4">, </span><span class="s1">available_if</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">parallel </span><span class="s3">import </span><span class="s1">Parallel</span><span class="s4">, </span><span class="s1">delayed</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">validation </span><span class="s3">import </span><span class="s1">check_is_fitted</span><span class="s4">, </span><span class="s1">check_memory</span>

<span class="s1">__all__ </span><span class="s4">= [</span><span class="s5">&quot;Pipeline&quot;</span><span class="s4">, </span><span class="s5">&quot;FeatureUnion&quot;</span><span class="s4">, </span><span class="s5">&quot;make_pipeline&quot;</span><span class="s4">, </span><span class="s5">&quot;make_union&quot;</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">_final_estimator_has</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Check that final_estimator has `attr`. 
 
    Used together with `available_if` in `Pipeline`.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">check</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2"># raise original `AttributeError` if `attr` does not exist</span>
        <span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_final_estimator</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">)</span>
        <span class="s3">return True</span>

    <span class="s3">return </span><span class="s1">check</span>


<span class="s3">class </span><span class="s1">Pipeline</span><span class="s4">(</span><span class="s1">_BaseComposition</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A sequence of data transformers with an optional final predictor. 
 
    `Pipeline` allows you to sequentially apply a list of transformers to 
    preprocess the data and, if desired, conclude the sequence with a final 
    :term:`predictor` for predictive modeling. 
 
    Intermediate steps of the pipeline must be 'transforms', that is, they 
    must implement `fit` and `transform` methods. 
    The final :term:`estimator` only needs to implement `fit`. 
    The transformers in the pipeline can be cached using ``memory`` argument. 
 
    The purpose of the pipeline is to assemble several steps that can be 
    cross-validated together while setting different parameters. For this, it 
    enables setting parameters of the various steps using their names and the 
    parameter name separated by a `'__'`, as in the example below. A step's 
    estimator may be replaced entirely by setting the parameter with its name 
    to another estimator, or a transformer removed by setting it to 
    `'passthrough'` or `None`. 
 
    For an example use case of `Pipeline` combined with 
    :class:`~sklearn.model_selection.GridSearchCV`, refer to 
    :ref:`sphx_glr_auto_examples_compose_plot_compare_reduction.py`. The 
    example :ref:`sphx_glr_auto_examples_compose_plot_digits_pipe.py` shows how 
    to grid search on a pipeline using `'__'` as a separator in the parameter names. 
 
    Read more in the :ref:`User Guide &lt;pipeline&gt;`. 
 
    .. versionadded:: 0.5 
 
    Parameters 
    ---------- 
    steps : list of tuples 
        List of (name of step, estimator) tuples that are to be chained in 
        sequential order. To be compatible with the scikit-learn API, all steps 
        must define `fit`. All non-last steps must also define `transform`. See 
        :ref:`Combining Estimators &lt;combining_estimators&gt;` for more details. 
 
    memory : str or object with the joblib.Memory interface, default=None 
        Used to cache the fitted transformers of the pipeline. The last step 
        will never be cached, even if it is a transformer. By default, no 
        caching is performed. If a string is given, it is the path to the 
        caching directory. Enabling caching triggers a clone of the transformers 
        before fitting. Therefore, the transformer instance given to the 
        pipeline cannot be inspected directly. Use the attribute ``named_steps`` 
        or ``steps`` to inspect estimators within the pipeline. Caching the 
        transformers is advantageous when fitting is time consuming. 
 
    verbose : bool, default=False 
        If True, the time elapsed while fitting each step will be printed as it 
        is completed. 
 
    Attributes 
    ---------- 
    named_steps : :class:`~sklearn.utils.Bunch` 
        Dictionary-like object, with the following attributes. 
        Read-only attribute to access any step parameter by user given name. 
        Keys are step names and values are steps parameters. 
 
    classes_ : ndarray of shape (n_classes,) 
        The classes labels. Only exist if the last step of the pipeline is a 
        classifier. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. Only defined if the 
        underlying first estimator in `steps` exposes such an attribute 
        when fit. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Only defined if the 
        underlying estimator exposes such an attribute when fit. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    make_pipeline : Convenience function for simplified pipeline construction. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.svm import SVC 
    &gt;&gt;&gt; from sklearn.preprocessing import StandardScaler 
    &gt;&gt;&gt; from sklearn.datasets import make_classification 
    &gt;&gt;&gt; from sklearn.model_selection import train_test_split 
    &gt;&gt;&gt; from sklearn.pipeline import Pipeline 
    &gt;&gt;&gt; X, y = make_classification(random_state=0) 
    &gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split(X, y, 
    ...                                                     random_state=0) 
    &gt;&gt;&gt; pipe = Pipeline([('scaler', StandardScaler()), ('svc', SVC())]) 
    &gt;&gt;&gt; # The pipeline can be used as any other estimator 
    &gt;&gt;&gt; # and avoids leaking the test set into the train set 
    &gt;&gt;&gt; pipe.fit(X_train, y_train).score(X_test, y_test) 
    0.88 
    &gt;&gt;&gt; # An estimator's parameter can be set using '__' syntax 
    &gt;&gt;&gt; pipe.set_params(svc__C=10).fit(X_train, y_train).score(X_test, y_test) 
    0.76 
    &quot;&quot;&quot;</span>

    <span class="s2"># BaseEstimator interface</span>
    <span class="s1">_required_parameters </span><span class="s4">= [</span><span class="s5">&quot;steps&quot;</span><span class="s4">]</span>

    <span class="s1">_parameter_constraints</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
        <span class="s5">&quot;steps&quot;</span><span class="s4">: [</span><span class="s1">list</span><span class="s4">, </span><span class="s1">Hidden</span><span class="s4">(</span><span class="s1">tuple</span><span class="s4">)],</span>
        <span class="s5">&quot;memory&quot;</span><span class="s4">: [</span><span class="s3">None</span><span class="s4">, </span><span class="s1">str</span><span class="s4">, </span><span class="s1">HasMethods</span><span class="s4">([</span><span class="s5">&quot;cache&quot;</span><span class="s4">])],</span>
        <span class="s5">&quot;verbose&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
    <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">steps</span><span class="s4">, *, </span><span class="s1">memory</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">steps </span><span class="s4">= </span><span class="s1">steps</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">memory </span><span class="s4">= </span><span class="s1">memory</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">verbose </span><span class="s4">= </span><span class="s1">verbose</span>

    <span class="s3">def </span><span class="s1">set_output</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *, </span><span class="s1">transform</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Set the output container when `&quot;transform&quot;` and `&quot;fit_transform&quot;` are called. 
 
        Calling `set_output` will set the output of all estimators in `steps`. 
 
        Parameters 
        ---------- 
        transform : {&quot;default&quot;, &quot;pandas&quot;, &quot;polars&quot;}, default=None 
            Configure output of `transform` and `fit_transform`. 
 
            - `&quot;default&quot;`: Default output format of a transformer 
            - `&quot;pandas&quot;`: DataFrame output 
            - `&quot;polars&quot;`: Polars output 
            - `None`: Transform configuration is unchanged 
 
            .. versionadded:: 1.4 
                `&quot;polars&quot;` option was added. 
 
        Returns 
        ------- 
        self : estimator instance 
            Estimator instance. 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">step </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">():</span>
            <span class="s1">_safe_set_output</span><span class="s4">(</span><span class="s1">step</span><span class="s4">, </span><span class="s1">transform</span><span class="s4">=</span><span class="s1">transform</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">get_params</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">deep</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Get parameters for this estimator. 
 
        Returns the parameters given in the constructor as well as the 
        estimators contained within the `steps` of the `Pipeline`. 
 
        Parameters 
        ---------- 
        deep : bool, default=True 
            If True, will return the parameters for this estimator and 
            contained subobjects that are estimators. 
 
        Returns 
        ------- 
        params : mapping of string to any 
            Parameter names mapped to their values. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_params</span><span class="s4">(</span><span class="s5">&quot;steps&quot;</span><span class="s4">, </span><span class="s1">deep</span><span class="s4">=</span><span class="s1">deep</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">set_params</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Set the parameters of this estimator. 
 
        Valid parameter keys can be listed with ``get_params()``. Note that 
        you can directly set the parameters of the estimators contained in 
        `steps`. 
 
        Parameters 
        ---------- 
        **kwargs : dict 
            Parameters of this estimator or parameters of estimators contained 
            in `steps`. Parameters of the steps may be set using its name and 
            the parameter name separated by a '__'. 
 
        Returns 
        ------- 
        self : object 
            Pipeline class instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_set_params</span><span class="s4">(</span><span class="s5">&quot;steps&quot;</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_validate_steps</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">names</span><span class="s4">, </span><span class="s1">estimators </span><span class="s4">= </span><span class="s1">zip</span><span class="s4">(*</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">)</span>

        <span class="s2"># validate names</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_names</span><span class="s4">(</span><span class="s1">names</span><span class="s4">)</span>

        <span class="s2"># validate estimators</span>
        <span class="s1">transformers </span><span class="s4">= </span><span class="s1">estimators</span><span class="s4">[:-</span><span class="s6">1</span><span class="s4">]</span>
        <span class="s1">estimator </span><span class="s4">= </span><span class="s1">estimators</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]</span>

        <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">transformers</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">t </span><span class="s3">is None or </span><span class="s1">t </span><span class="s4">== </span><span class="s5">&quot;passthrough&quot;</span><span class="s4">:</span>
                <span class="s3">continue</span>
            <span class="s3">if not </span><span class="s4">(</span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">t</span><span class="s4">, </span><span class="s5">&quot;fit&quot;</span><span class="s4">) </span><span class="s3">or </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">t</span><span class="s4">, </span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">)) </span><span class="s3">or not </span><span class="s1">hasattr</span><span class="s4">(</span>
                <span class="s1">t</span><span class="s4">, </span><span class="s5">&quot;transform&quot;</span>
            <span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span>
                    <span class="s5">&quot;All intermediate steps should be &quot;</span>
                    <span class="s5">&quot;transformers and implement fit and transform &quot;</span>
                    <span class="s5">&quot;or be the string 'passthrough' &quot;</span>
                    <span class="s5">&quot;'%s' (type %s) doesn't&quot; </span><span class="s4">% (</span><span class="s1">t</span><span class="s4">, </span><span class="s1">type</span><span class="s4">(</span><span class="s1">t</span><span class="s4">))</span>
                <span class="s4">)</span>

        <span class="s2"># We allow last estimator to be None as an identity transformation</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">estimator </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">estimator </span><span class="s4">!= </span><span class="s5">&quot;passthrough&quot;</span>
            <span class="s3">and not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">, </span><span class="s5">&quot;fit&quot;</span><span class="s4">)</span>
        <span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span>
                <span class="s5">&quot;Last step of Pipeline should implement fit &quot;</span>
                <span class="s5">&quot;or be the string 'passthrough'. &quot;</span>
                <span class="s5">&quot;'%s' (type %s) doesn't&quot; </span><span class="s4">% (</span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">type</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">))</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_iter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">with_final</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">filter_passthrough</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Generate (idx, (name, trans)) tuples from self.steps 
 
        When filter_passthrough is True, 'passthrough' and None transformers 
        are filtered out. 
        &quot;&quot;&quot;</span>
        <span class="s1">stop </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">with_final</span><span class="s4">:</span>
            <span class="s1">stop </span><span class="s4">-= </span><span class="s6">1</span>

        <span class="s3">for </span><span class="s1">idx</span><span class="s4">, (</span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">) </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">islice</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s1">stop</span><span class="s4">)):</span>
            <span class="s3">if not </span><span class="s1">filter_passthrough</span><span class="s4">:</span>
                <span class="s3">yield </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span>
            <span class="s3">elif </span><span class="s1">trans </span><span class="s3">is not None and </span><span class="s1">trans </span><span class="s4">!= </span><span class="s5">&quot;passthrough&quot;</span><span class="s4">:</span>
                <span class="s3">yield </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span>

    <span class="s3">def </span><span class="s1">__len__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns the length of the Pipeline 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__getitem__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">ind</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Returns a sub-pipeline or a single estimator in the pipeline 
 
        Indexing with an integer will return an estimator; using a slice 
        returns another Pipeline instance which copies a slice of this 
        Pipeline. This copy is shallow: modifying (or fitting) estimators in 
        the sub-pipeline will affect the larger pipeline and vice-versa. 
        However, replacing a value in `step` will not affect a copy. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">ind</span><span class="s4">, </span><span class="s1">slice</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">ind</span><span class="s4">.</span><span class="s1">step </span><span class="s3">not in </span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s3">None</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Pipeline slicing only supports a step of 1&quot;</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[</span><span class="s1">ind</span><span class="s4">], </span><span class="s1">memory</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">memory</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose</span>
            <span class="s4">)</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">name</span><span class="s4">, </span><span class="s1">est </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[</span><span class="s1">ind</span><span class="s4">]</span>
        <span class="s3">except </span><span class="s1">TypeError</span><span class="s4">:</span>
            <span class="s2"># Not an int, try get step by name</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">named_steps</span><span class="s4">[</span><span class="s1">ind</span><span class="s4">]</span>
        <span class="s3">return </span><span class="s1">est</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_estimator_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">1</span><span class="s4">].</span><span class="s1">_estimator_type</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">named_steps</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Access the steps by name. 
 
        Read-only attribute to access any step by given name. 
        Keys are steps names and values are the steps objects.&quot;&quot;&quot;</span>
        <span class="s2"># Use Bunch object to improve autocomplete</span>
        <span class="s3">return </span><span class="s1">Bunch</span><span class="s4">(**</span><span class="s1">dict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">))</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_final_estimator</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">estimator </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">1</span><span class="s4">]</span>
            <span class="s3">return </span><span class="s5">&quot;passthrough&quot; </span><span class="s3">if </span><span class="s1">estimator </span><span class="s3">is None else </span><span class="s1">estimator</span>
        <span class="s3">except </span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">, </span><span class="s1">AttributeError</span><span class="s4">, </span><span class="s1">TypeError</span><span class="s4">):</span>
            <span class="s2"># This condition happens when a call to a method is first calling</span>
            <span class="s2"># `_available_if` and `fit` did not validate `steps` yet. We</span>
            <span class="s2"># return `None` and an `InvalidParameterError` will be raised</span>
            <span class="s2"># right after.</span>
            <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">_log_message</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">step_idx</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose</span><span class="s4">:</span>
            <span class="s3">return None</span>
        <span class="s1">name</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[</span><span class="s1">step_idx</span><span class="s4">]</span>

        <span class="s3">return </span><span class="s5">&quot;(step %d of %d) Processing %s&quot; </span><span class="s4">% (</span><span class="s1">step_idx </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">, </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">), </span><span class="s1">name</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_check_method_params</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">method</span><span class="s4">, </span><span class="s1">props</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">_routing_enabled</span><span class="s4">():</span>
            <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">process_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">method</span><span class="s4">, **</span><span class="s1">props</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">routed_params</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">fit_params_steps </span><span class="s4">= </span><span class="s1">Bunch</span><span class="s4">(</span>
                <span class="s4">**{</span>
                    <span class="s1">name</span><span class="s4">: </span><span class="s1">Bunch</span><span class="s4">(**{</span><span class="s1">method</span><span class="s4">: {} </span><span class="s3">for </span><span class="s1">method </span><span class="s3">in </span><span class="s1">METHODS</span><span class="s4">})</span>
                    <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">step </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span>
                    <span class="s3">if </span><span class="s1">step </span><span class="s3">is not None</span>
                <span class="s4">}</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">pname</span><span class="s4">, </span><span class="s1">pval </span><span class="s3">in </span><span class="s1">props</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
                <span class="s3">if </span><span class="s5">&quot;__&quot; </span><span class="s3">not in </span><span class="s1">pname</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                        <span class="s5">&quot;Pipeline.fit does not accept the {} parameter. &quot;</span>
                        <span class="s5">&quot;You can pass parameters to specific steps of your &quot;</span>
                        <span class="s5">&quot;pipeline using the stepname__parameter format, e.g. &quot;</span>
                        <span class="s5">&quot;`Pipeline.fit(X, y, logisticregression__sample_weight&quot;</span>
                        <span class="s5">&quot;=sample_weight)`.&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">pname</span><span class="s4">)</span>
                    <span class="s4">)</span>
                <span class="s1">step</span><span class="s4">, </span><span class="s1">param </span><span class="s4">= </span><span class="s1">pname</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s5">&quot;__&quot;</span><span class="s4">, </span><span class="s6">1</span><span class="s4">)</span>
                <span class="s1">fit_params_steps</span><span class="s4">[</span><span class="s1">step</span><span class="s4">][</span><span class="s5">&quot;fit&quot;</span><span class="s4">][</span><span class="s1">param</span><span class="s4">] = </span><span class="s1">pval</span>
                <span class="s2"># without metadata routing, fit_transform and fit_predict</span>
                <span class="s2"># get all the same params and pass it to the last fit.</span>
                <span class="s1">fit_params_steps</span><span class="s4">[</span><span class="s1">step</span><span class="s4">][</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">][</span><span class="s1">param</span><span class="s4">] = </span><span class="s1">pval</span>
                <span class="s1">fit_params_steps</span><span class="s4">[</span><span class="s1">step</span><span class="s4">][</span><span class="s5">&quot;fit_predict&quot;</span><span class="s4">][</span><span class="s1">param</span><span class="s4">] = </span><span class="s1">pval</span>
            <span class="s3">return </span><span class="s1">fit_params_steps</span>

    <span class="s2"># Estimator interface</span>

    <span class="s3">def </span><span class="s1">_fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">routed_params</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s2"># shallow copy of steps - this should really be steps_</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">steps </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_steps</span><span class="s4">()</span>
        <span class="s2"># Setup the memory</span>
        <span class="s1">memory </span><span class="s4">= </span><span class="s1">check_memory</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">memory</span><span class="s4">)</span>

        <span class="s1">fit_transform_one_cached </span><span class="s4">= </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">cache</span><span class="s4">(</span><span class="s1">_fit_transform_one</span><span class="s4">)</span>

        <span class="s3">for </span><span class="s1">step_idx</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">transformer </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span>
            <span class="s1">with_final</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">filter_passthrough</span><span class="s4">=</span><span class="s3">False</span>
        <span class="s4">):</span>
            <span class="s3">if </span><span class="s1">transformer </span><span class="s3">is None or </span><span class="s1">transformer </span><span class="s4">== </span><span class="s5">&quot;passthrough&quot;</span><span class="s4">:</span>
                <span class="s3">with </span><span class="s1">_print_elapsed_time</span><span class="s4">(</span><span class="s5">&quot;Pipeline&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_log_message</span><span class="s4">(</span><span class="s1">step_idx</span><span class="s4">)):</span>
                    <span class="s3">continue</span>

            <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">memory</span><span class="s4">, </span><span class="s5">&quot;location&quot;</span><span class="s4">) </span><span class="s3">and </span><span class="s1">memory</span><span class="s4">.</span><span class="s1">location </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s2"># we do not clone when caching is disabled to</span>
                <span class="s2"># preserve backward compatibility</span>
                <span class="s1">cloned_transformer </span><span class="s4">= </span><span class="s1">transformer</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">cloned_transformer </span><span class="s4">= </span><span class="s1">clone</span><span class="s4">(</span><span class="s1">transformer</span><span class="s4">)</span>
            <span class="s2"># Fit or load from cache the current transformer</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">fitted_transformer </span><span class="s4">= </span><span class="s1">fit_transform_one_cached</span><span class="s4">(</span>
                <span class="s1">cloned_transformer</span><span class="s4">,</span>
                <span class="s1">X</span><span class="s4">,</span>
                <span class="s1">y</span><span class="s4">,</span>
                <span class="s3">None</span><span class="s4">,</span>
                <span class="s1">message_clsname</span><span class="s4">=</span><span class="s5">&quot;Pipeline&quot;</span><span class="s4">,</span>
                <span class="s1">message</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_log_message</span><span class="s4">(</span><span class="s1">step_idx</span><span class="s4">),</span>
                <span class="s1">params</span><span class="s4">=</span><span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">],</span>
            <span class="s4">)</span>
            <span class="s2"># Replace the transformer of the step with the fitted</span>
            <span class="s2"># transformer. This is necessary when loading the transformer</span>
            <span class="s2"># from the cache.</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[</span><span class="s1">step_idx</span><span class="s4">] = (</span><span class="s1">name</span><span class="s4">, </span><span class="s1">fitted_transformer</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">X</span>

    <span class="s4">@</span><span class="s1">_fit_context</span><span class="s4">(</span>
        <span class="s2"># estimators in Pipeline.steps are not validated yet</span>
        <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">False</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Fit the model. 
 
        Fit all the transformers one after the other and sequentially transform the 
        data. Finally, fit the transformed data using the final estimator. 
 
        Parameters 
        ---------- 
        X : iterable 
            Training data. Must fulfill input requirements of first step of the 
            pipeline. 
 
        y : iterable, default=None 
            Training targets. Must fulfill label requirements for all steps of 
            the pipeline. 
 
        **params : dict of str -&gt; object 
            - If `enable_metadata_routing=False` (default): 
 
                Parameters passed to the ``fit`` method of each step, where 
                each parameter name is prefixed such that parameter ``p`` for step 
                ``s`` has key ``s__p``. 
 
            - If `enable_metadata_routing=True`: 
 
                Parameters requested and accepted by steps. Each step must have 
                requested certain metadata for these parameters to be forwarded to 
                them. 
 
            .. versionchanged:: 1.4 
                Parameters are now passed to the ``transform`` method of the 
                intermediate steps as well, if requested, and if 
                `enable_metadata_routing=True` is set via 
                :func:`~sklearn.set_config`. 
 
            See :ref:`Metadata Routing User Guide &lt;metadata_routing&gt;` for more 
            details. 
 
        Returns 
        ------- 
        self : object 
            Pipeline with fitted steps. 
        &quot;&quot;&quot;</span>
        <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_check_method_params</span><span class="s4">(</span><span class="s1">method</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">, </span><span class="s1">props</span><span class="s4">=</span><span class="s1">params</span><span class="s4">)</span>
        <span class="s1">Xt </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">routed_params</span><span class="s4">)</span>
        <span class="s3">with </span><span class="s1">_print_elapsed_time</span><span class="s4">(</span><span class="s5">&quot;Pipeline&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_log_message</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">) - </span><span class="s6">1</span><span class="s4">)):</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_final_estimator </span><span class="s4">!= </span><span class="s5">&quot;passthrough&quot;</span><span class="s4">:</span>
                <span class="s1">last_step_params </span><span class="s4">= </span><span class="s1">routed_params</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">0</span><span class="s4">]]</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_final_estimator</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, **</span><span class="s1">last_step_params</span><span class="s4">[</span><span class="s5">&quot;fit&quot;</span><span class="s4">])</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_can_fit_transform</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_final_estimator </span><span class="s4">== </span><span class="s5">&quot;passthrough&quot;</span>
            <span class="s3">or </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_final_estimator</span><span class="s4">, </span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>
            <span class="s3">or </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_final_estimator</span><span class="s4">, </span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">)</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">available_if</span><span class="s4">(</span><span class="s1">_can_fit_transform</span><span class="s4">)</span>
    <span class="s4">@</span><span class="s1">_fit_context</span><span class="s4">(</span>
        <span class="s2"># estimators in Pipeline.steps are not validated yet</span>
        <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">False</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">fit_transform</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Fit the model and transform with the final estimator. 
 
        Fit all the transformers one after the other and sequentially transform 
        the data. Only valid if the final estimator either implements 
        `fit_transform` or `fit` and `transform`. 
 
        Parameters 
        ---------- 
        X : iterable 
            Training data. Must fulfill input requirements of first step of the 
            pipeline. 
 
        y : iterable, default=None 
            Training targets. Must fulfill label requirements for all steps of 
            the pipeline. 
 
        **params : dict of str -&gt; object 
            - If `enable_metadata_routing=False` (default): 
 
                Parameters passed to the ``fit`` method of each step, where 
                each parameter name is prefixed such that parameter ``p`` for step 
                ``s`` has key ``s__p``. 
 
            - If `enable_metadata_routing=True`: 
 
                Parameters requested and accepted by steps. Each step must have 
                requested certain metadata for these parameters to be forwarded to 
                them. 
 
            .. versionchanged:: 1.4 
                Parameters are now passed to the ``transform`` method of the 
                intermediate steps as well, if requested, and if 
                `enable_metadata_routing=True`. 
 
            See :ref:`Metadata Routing User Guide &lt;metadata_routing&gt;` for more 
            details. 
 
        Returns 
        ------- 
        Xt : ndarray of shape (n_samples, n_transformed_features) 
            Transformed samples. 
        &quot;&quot;&quot;</span>
        <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_check_method_params</span><span class="s4">(</span><span class="s1">method</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">, </span><span class="s1">props</span><span class="s4">=</span><span class="s1">params</span><span class="s4">)</span>
        <span class="s1">Xt </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">routed_params</span><span class="s4">)</span>

        <span class="s1">last_step </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_final_estimator</span>
        <span class="s3">with </span><span class="s1">_print_elapsed_time</span><span class="s4">(</span><span class="s5">&quot;Pipeline&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_log_message</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">) - </span><span class="s6">1</span><span class="s4">)):</span>
            <span class="s3">if </span><span class="s1">last_step </span><span class="s4">== </span><span class="s5">&quot;passthrough&quot;</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">Xt</span>
            <span class="s1">last_step_params </span><span class="s4">= </span><span class="s1">routed_params</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">0</span><span class="s4">]]</span>
            <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">last_step</span><span class="s4">, </span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">):</span>
                <span class="s3">return </span><span class="s1">last_step</span><span class="s4">.</span><span class="s1">fit_transform</span><span class="s4">(</span>
                    <span class="s1">Xt</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, **</span><span class="s1">last_step_params</span><span class="s4">[</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">]</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">last_step</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, **</span><span class="s1">last_step_params</span><span class="s4">[</span><span class="s5">&quot;fit&quot;</span><span class="s4">]).</span><span class="s1">transform</span><span class="s4">(</span>
                    <span class="s1">Xt</span><span class="s4">, **</span><span class="s1">last_step_params</span><span class="s4">[</span><span class="s5">&quot;transform&quot;</span><span class="s4">]</span>
                <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">available_if</span><span class="s4">(</span><span class="s1">_final_estimator_has</span><span class="s4">(</span><span class="s5">&quot;predict&quot;</span><span class="s4">))</span>
    <span class="s3">def </span><span class="s1">predict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Transform the data, and apply `predict` with the final estimator. 
 
        Call `transform` of each transformer in the pipeline. The transformed 
        data are finally passed to the final estimator that calls `predict` 
        method. Only valid if the final estimator implements `predict`. 
 
        Parameters 
        ---------- 
        X : iterable 
            Data to predict on. Must fulfill input requirements of first step 
            of the pipeline. 
 
        **params : dict of str -&gt; object 
            - If `enable_metadata_routing=False` (default): 
 
                Parameters to the ``predict`` called at the end of all 
                transformations in the pipeline. 
 
            - If `enable_metadata_routing=True`: 
 
                Parameters requested and accepted by steps. Each step must have 
                requested certain metadata for these parameters to be forwarded to 
                them. 
 
            .. versionadded:: 0.20 
 
            .. versionchanged:: 1.4 
                Parameters are now passed to the ``transform`` method of the 
                intermediate steps as well, if requested, and if 
                `enable_metadata_routing=True` is set via 
                :func:`~sklearn.set_config`. 
 
            See :ref:`Metadata Routing User Guide &lt;metadata_routing&gt;` for more 
            details. 
 
            Note that while this may be used to return uncertainties from some 
            models with ``return_std`` or ``return_cov``, uncertainties that are 
            generated by the transformations in the pipeline are not propagated 
            to the final estimator. 
 
        Returns 
        ------- 
        y_pred : ndarray 
            Result of calling `predict` on the final estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">Xt </span><span class="s4">= </span><span class="s1">X</span>

        <span class="s3">if not </span><span class="s1">_routing_enabled</span><span class="s4">():</span>
            <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">transform </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span><span class="s1">with_final</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
                <span class="s1">Xt </span><span class="s4">= </span><span class="s1">transform</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">1</span><span class="s4">].</span><span class="s1">predict</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">)</span>

        <span class="s2"># metadata routing enabled</span>
        <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">process_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;predict&quot;</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">transform </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span><span class="s1">with_final</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
            <span class="s1">Xt </span><span class="s4">= </span><span class="s1">transform</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">, **</span><span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">].</span><span class="s1">transform</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">1</span><span class="s4">].</span><span class="s1">predict</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">, **</span><span class="s1">routed_params</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">0</span><span class="s4">]].</span><span class="s1">predict</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">available_if</span><span class="s4">(</span><span class="s1">_final_estimator_has</span><span class="s4">(</span><span class="s5">&quot;fit_predict&quot;</span><span class="s4">))</span>
    <span class="s4">@</span><span class="s1">_fit_context</span><span class="s4">(</span>
        <span class="s2"># estimators in Pipeline.steps are not validated yet</span>
        <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">False</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">fit_predict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Transform the data, and apply `fit_predict` with the final estimator. 
 
        Call `fit_transform` of each transformer in the pipeline. The 
        transformed data are finally passed to the final estimator that calls 
        `fit_predict` method. Only valid if the final estimator implements 
        `fit_predict`. 
 
        Parameters 
        ---------- 
        X : iterable 
            Training data. Must fulfill input requirements of first step of 
            the pipeline. 
 
        y : iterable, default=None 
            Training targets. Must fulfill label requirements for all steps 
            of the pipeline. 
 
        **params : dict of str -&gt; object 
            - If `enable_metadata_routing=False` (default): 
 
                Parameters to the ``predict`` called at the end of all 
                transformations in the pipeline. 
 
            - If `enable_metadata_routing=True`: 
 
                Parameters requested and accepted by steps. Each step must have 
                requested certain metadata for these parameters to be forwarded to 
                them. 
 
            .. versionadded:: 0.20 
 
            .. versionchanged:: 1.4 
                Parameters are now passed to the ``transform`` method of the 
                intermediate steps as well, if requested, and if 
                `enable_metadata_routing=True`. 
 
            See :ref:`Metadata Routing User Guide &lt;metadata_routing&gt;` for more 
            details. 
 
            Note that while this may be used to return uncertainties from some 
            models with ``return_std`` or ``return_cov``, uncertainties that are 
            generated by the transformations in the pipeline are not propagated 
            to the final estimator. 
 
        Returns 
        ------- 
        y_pred : ndarray 
            Result of calling `fit_predict` on the final estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_check_method_params</span><span class="s4">(</span><span class="s1">method</span><span class="s4">=</span><span class="s5">&quot;fit_predict&quot;</span><span class="s4">, </span><span class="s1">props</span><span class="s4">=</span><span class="s1">params</span><span class="s4">)</span>
        <span class="s1">Xt </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">routed_params</span><span class="s4">)</span>

        <span class="s1">params_last_step </span><span class="s4">= </span><span class="s1">routed_params</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">0</span><span class="s4">]]</span>
        <span class="s3">with </span><span class="s1">_print_elapsed_time</span><span class="s4">(</span><span class="s5">&quot;Pipeline&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_log_message</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">) - </span><span class="s6">1</span><span class="s4">)):</span>
            <span class="s1">y_pred </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">1</span><span class="s4">].</span><span class="s1">fit_predict</span><span class="s4">(</span>
                <span class="s1">Xt</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, **</span><span class="s1">params_last_step</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;fit_predict&quot;</span><span class="s4">, {})</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">y_pred</span>

    <span class="s4">@</span><span class="s1">available_if</span><span class="s4">(</span><span class="s1">_final_estimator_has</span><span class="s4">(</span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">))</span>
    <span class="s3">def </span><span class="s1">predict_proba</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Transform the data, and apply `predict_proba` with the final estimator. 
 
        Call `transform` of each transformer in the pipeline. The transformed 
        data are finally passed to the final estimator that calls 
        `predict_proba` method. Only valid if the final estimator implements 
        `predict_proba`. 
 
        Parameters 
        ---------- 
        X : iterable 
            Data to predict on. Must fulfill input requirements of first step 
            of the pipeline. 
 
        **params : dict of str -&gt; object 
            - If `enable_metadata_routing=False` (default): 
 
                Parameters to the `predict_proba` called at the end of all 
                transformations in the pipeline. 
 
            - If `enable_metadata_routing=True`: 
 
                Parameters requested and accepted by steps. Each step must have 
                requested certain metadata for these parameters to be forwarded to 
                them. 
 
            .. versionadded:: 0.20 
 
            .. versionchanged:: 1.4 
                Parameters are now passed to the ``transform`` method of the 
                intermediate steps as well, if requested, and if 
                `enable_metadata_routing=True`. 
 
            See :ref:`Metadata Routing User Guide &lt;metadata_routing&gt;` for more 
            details. 
 
        Returns 
        ------- 
        y_proba : ndarray of shape (n_samples, n_classes) 
            Result of calling `predict_proba` on the final estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">Xt </span><span class="s4">= </span><span class="s1">X</span>

        <span class="s3">if not </span><span class="s1">_routing_enabled</span><span class="s4">():</span>
            <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">transform </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span><span class="s1">with_final</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
                <span class="s1">Xt </span><span class="s4">= </span><span class="s1">transform</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">1</span><span class="s4">].</span><span class="s1">predict_proba</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">)</span>

        <span class="s2"># metadata routing enabled</span>
        <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">process_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">transform </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span><span class="s1">with_final</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
            <span class="s1">Xt </span><span class="s4">= </span><span class="s1">transform</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">, **</span><span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">].</span><span class="s1">transform</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">1</span><span class="s4">].</span><span class="s1">predict_proba</span><span class="s4">(</span>
            <span class="s1">Xt</span><span class="s4">, **</span><span class="s1">routed_params</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">0</span><span class="s4">]].</span><span class="s1">predict_proba</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">available_if</span><span class="s4">(</span><span class="s1">_final_estimator_has</span><span class="s4">(</span><span class="s5">&quot;decision_function&quot;</span><span class="s4">))</span>
    <span class="s3">def </span><span class="s1">decision_function</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Transform the data, and apply `decision_function` with the final estimator. 
 
        Call `transform` of each transformer in the pipeline. The transformed 
        data are finally passed to the final estimator that calls 
        `decision_function` method. Only valid if the final estimator 
        implements `decision_function`. 
 
        Parameters 
        ---------- 
        X : iterable 
            Data to predict on. Must fulfill input requirements of first step 
            of the pipeline. 
 
        **params : dict of string -&gt; object 
            Parameters requested and accepted by steps. Each step must have 
            requested certain metadata for these parameters to be forwarded to 
            them. 
 
            .. versionadded:: 1.4 
                Only available if `enable_metadata_routing=True`. See 
                :ref:`Metadata Routing User Guide &lt;metadata_routing&gt;` for more 
                details. 
 
        Returns 
        ------- 
        y_score : ndarray of shape (n_samples, n_classes) 
            Result of calling `decision_function` on the final estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">_raise_for_params</span><span class="s4">(</span><span class="s1">params</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;decision_function&quot;</span><span class="s4">)</span>

        <span class="s2"># not branching here since params is only available if</span>
        <span class="s2"># enable_metadata_routing=True</span>
        <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">process_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;decision_function&quot;</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">)</span>

        <span class="s1">Xt </span><span class="s4">= </span><span class="s1">X</span>
        <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">transform </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span><span class="s1">with_final</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
            <span class="s1">Xt </span><span class="s4">= </span><span class="s1">transform</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span>
                <span class="s1">Xt</span><span class="s4">, **</span><span class="s1">routed_params</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, {}).</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;transform&quot;</span><span class="s4">, {})</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">1</span><span class="s4">].</span><span class="s1">decision_function</span><span class="s4">(</span>
            <span class="s1">Xt</span><span class="s4">, **</span><span class="s1">routed_params</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">0</span><span class="s4">], {}).</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;decision_function&quot;</span><span class="s4">, {})</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">available_if</span><span class="s4">(</span><span class="s1">_final_estimator_has</span><span class="s4">(</span><span class="s5">&quot;score_samples&quot;</span><span class="s4">))</span>
    <span class="s3">def </span><span class="s1">score_samples</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Transform the data, and apply `score_samples` with the final estimator. 
 
        Call `transform` of each transformer in the pipeline. The transformed 
        data are finally passed to the final estimator that calls 
        `score_samples` method. Only valid if the final estimator implements 
        `score_samples`. 
 
        Parameters 
        ---------- 
        X : iterable 
            Data to predict on. Must fulfill input requirements of first step 
            of the pipeline. 
 
        Returns 
        ------- 
        y_score : ndarray of shape (n_samples,) 
            Result of calling `score_samples` on the final estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">Xt </span><span class="s4">= </span><span class="s1">X</span>
        <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">transformer </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span><span class="s1">with_final</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
            <span class="s1">Xt </span><span class="s4">= </span><span class="s1">transformer</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">1</span><span class="s4">].</span><span class="s1">score_samples</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">available_if</span><span class="s4">(</span><span class="s1">_final_estimator_has</span><span class="s4">(</span><span class="s5">&quot;predict_log_proba&quot;</span><span class="s4">))</span>
    <span class="s3">def </span><span class="s1">predict_log_proba</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Transform the data, and apply `predict_log_proba` with the final estimator. 
 
        Call `transform` of each transformer in the pipeline. The transformed 
        data are finally passed to the final estimator that calls 
        `predict_log_proba` method. Only valid if the final estimator 
        implements `predict_log_proba`. 
 
        Parameters 
        ---------- 
        X : iterable 
            Data to predict on. Must fulfill input requirements of first step 
            of the pipeline. 
 
        **params : dict of str -&gt; object 
            - If `enable_metadata_routing=False` (default): 
 
                Parameters to the `predict_log_proba` called at the end of all 
                transformations in the pipeline. 
 
            - If `enable_metadata_routing=True`: 
 
                Parameters requested and accepted by steps. Each step must have 
                requested certain metadata for these parameters to be forwarded to 
                them. 
 
            .. versionadded:: 0.20 
 
            .. versionchanged:: 1.4 
                Parameters are now passed to the ``transform`` method of the 
                intermediate steps as well, if requested, and if 
                `enable_metadata_routing=True`. 
 
            See :ref:`Metadata Routing User Guide &lt;metadata_routing&gt;` for more 
            details. 
 
        Returns 
        ------- 
        y_log_proba : ndarray of shape (n_samples, n_classes) 
            Result of calling `predict_log_proba` on the final estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">Xt </span><span class="s4">= </span><span class="s1">X</span>

        <span class="s3">if not </span><span class="s1">_routing_enabled</span><span class="s4">():</span>
            <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">transform </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span><span class="s1">with_final</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
                <span class="s1">Xt </span><span class="s4">= </span><span class="s1">transform</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">1</span><span class="s4">].</span><span class="s1">predict_log_proba</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">)</span>

        <span class="s2"># metadata routing enabled</span>
        <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">process_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;predict_log_proba&quot;</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">transform </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span><span class="s1">with_final</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
            <span class="s1">Xt </span><span class="s4">= </span><span class="s1">transform</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">, **</span><span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">].</span><span class="s1">transform</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">1</span><span class="s4">].</span><span class="s1">predict_log_proba</span><span class="s4">(</span>
            <span class="s1">Xt</span><span class="s4">, **</span><span class="s1">routed_params</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">0</span><span class="s4">]].</span><span class="s1">predict_log_proba</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_can_transform</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_final_estimator </span><span class="s4">== </span><span class="s5">&quot;passthrough&quot; </span><span class="s3">or </span><span class="s1">hasattr</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_final_estimator</span><span class="s4">, </span><span class="s5">&quot;transform&quot;</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">available_if</span><span class="s4">(</span><span class="s1">_can_transform</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">transform</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Transform the data, and apply `transform` with the final estimator. 
 
        Call `transform` of each transformer in the pipeline. The transformed 
        data are finally passed to the final estimator that calls 
        `transform` method. Only valid if the final estimator 
        implements `transform`. 
 
        This also works where final estimator is `None` in which case all prior 
        transformations are applied. 
 
        Parameters 
        ---------- 
        X : iterable 
            Data to transform. Must fulfill input requirements of first step 
            of the pipeline. 
 
        **params : dict of str -&gt; object 
            Parameters requested and accepted by steps. Each step must have 
            requested certain metadata for these parameters to be forwarded to 
            them. 
 
            .. versionadded:: 1.4 
                Only available if `enable_metadata_routing=True`. See 
                :ref:`Metadata Routing User Guide &lt;metadata_routing&gt;` for more 
                details. 
 
        Returns 
        ------- 
        Xt : ndarray of shape (n_samples, n_transformed_features) 
            Transformed data. 
        &quot;&quot;&quot;</span>
        <span class="s1">_raise_for_params</span><span class="s4">(</span><span class="s1">params</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>

        <span class="s2"># not branching here since params is only available if</span>
        <span class="s2"># enable_metadata_routing=True</span>
        <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">process_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;transform&quot;</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">)</span>
        <span class="s1">Xt </span><span class="s4">= </span><span class="s1">X</span>
        <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">transform </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">():</span>
            <span class="s1">Xt </span><span class="s4">= </span><span class="s1">transform</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">, **</span><span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">].</span><span class="s1">transform</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">Xt</span>

    <span class="s3">def </span><span class="s1">_can_inverse_transform</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">all</span><span class="s4">(</span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">t</span><span class="s4">, </span><span class="s5">&quot;inverse_transform&quot;</span><span class="s4">) </span><span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">t </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">())</span>

    <span class="s4">@</span><span class="s1">available_if</span><span class="s4">(</span><span class="s1">_can_inverse_transform</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">inverse_transform</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, *, </span><span class="s1">Xt</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Apply `inverse_transform` for each step in a reverse order. 
 
        All estimators in the pipeline must support `inverse_transform`. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_transformed_features) 
            Data samples, where ``n_samples`` is the number of samples and 
            ``n_features`` is the number of features. Must fulfill 
            input requirements of last step of pipeline's 
            ``inverse_transform`` method. 
 
        Xt : array-like of shape (n_samples, n_transformed_features) 
            Data samples, where ``n_samples`` is the number of samples and 
            ``n_features`` is the number of features. Must fulfill 
            input requirements of last step of pipeline's 
            ``inverse_transform`` method. 
 
            .. deprecated:: 1.5 
                `Xt` was deprecated in 1.5 and will be removed in 1.7. Use `X` instead. 
 
        **params : dict of str -&gt; object 
            Parameters requested and accepted by steps. Each step must have 
            requested certain metadata for these parameters to be forwarded to 
            them. 
 
            .. versionadded:: 1.4 
                Only available if `enable_metadata_routing=True`. See 
                :ref:`Metadata Routing User Guide &lt;metadata_routing&gt;` for more 
                details. 
 
        Returns 
        ------- 
        Xt : ndarray of shape (n_samples, n_features) 
            Inverse transformed data, that is, data in the original feature 
            space. 
        &quot;&quot;&quot;</span>
        <span class="s1">_raise_for_params</span><span class="s4">(</span><span class="s1">params</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;inverse_transform&quot;</span><span class="s4">)</span>

        <span class="s1">X </span><span class="s4">= </span><span class="s1">_deprecate_Xt_in_inverse_transform</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Xt</span><span class="s4">)</span>

        <span class="s2"># we don't have to branch here, since params is only non-empty if</span>
        <span class="s2"># enable_metadata_routing=True.</span>
        <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">process_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;inverse_transform&quot;</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">)</span>
        <span class="s1">reverse_iter </span><span class="s4">= </span><span class="s1">reversed</span><span class="s4">(</span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">()))</span>
        <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">transform </span><span class="s3">in </span><span class="s1">reverse_iter</span><span class="s4">:</span>
            <span class="s1">X </span><span class="s4">= </span><span class="s1">transform</span><span class="s4">.</span><span class="s1">inverse_transform</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, **</span><span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">].</span><span class="s1">inverse_transform</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">X</span>

    <span class="s4">@</span><span class="s1">available_if</span><span class="s4">(</span><span class="s1">_final_estimator_has</span><span class="s4">(</span><span class="s5">&quot;score&quot;</span><span class="s4">))</span>
    <span class="s3">def </span><span class="s1">score</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Transform the data, and apply `score` with the final estimator. 
 
        Call `transform` of each transformer in the pipeline. The transformed 
        data are finally passed to the final estimator that calls 
        `score` method. Only valid if the final estimator implements `score`. 
 
        Parameters 
        ---------- 
        X : iterable 
            Data to predict on. Must fulfill input requirements of first step 
            of the pipeline. 
 
        y : iterable, default=None 
            Targets used for scoring. Must fulfill label requirements for all 
            steps of the pipeline. 
 
        sample_weight : array-like, default=None 
            If not None, this argument is passed as ``sample_weight`` keyword 
            argument to the ``score`` method of the final estimator. 
 
        **params : dict of str -&gt; object 
            Parameters requested and accepted by steps. Each step must have 
            requested certain metadata for these parameters to be forwarded to 
            them. 
 
            .. versionadded:: 1.4 
                Only available if `enable_metadata_routing=True`. See 
                :ref:`Metadata Routing User Guide &lt;metadata_routing&gt;` for more 
                details. 
 
        Returns 
        ------- 
        score : float 
            Result of calling `score` on the final estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">Xt </span><span class="s4">= </span><span class="s1">X</span>
        <span class="s3">if not </span><span class="s1">_routing_enabled</span><span class="s4">():</span>
            <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">transform </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span><span class="s1">with_final</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
                <span class="s1">Xt </span><span class="s4">= </span><span class="s1">transform</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">)</span>
            <span class="s1">score_params </span><span class="s4">= {}</span>
            <span class="s3">if </span><span class="s1">sample_weight </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">score_params</span><span class="s4">[</span><span class="s5">&quot;sample_weight&quot;</span><span class="s4">] = </span><span class="s1">sample_weight</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">1</span><span class="s4">].</span><span class="s1">score</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, **</span><span class="s1">score_params</span><span class="s4">)</span>

        <span class="s2"># metadata routing is enabled.</span>
        <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">process_routing</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;score&quot;</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">, **</span><span class="s1">params</span>
        <span class="s4">)</span>

        <span class="s1">Xt </span><span class="s4">= </span><span class="s1">X</span>
        <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">transform </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span><span class="s1">with_final</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
            <span class="s1">Xt </span><span class="s4">= </span><span class="s1">transform</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">, **</span><span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">].</span><span class="s1">transform</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">1</span><span class="s4">].</span><span class="s1">score</span><span class="s4">(</span><span class="s1">Xt</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, **</span><span class="s1">routed_params</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">0</span><span class="s4">]].</span><span class="s1">score</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">classes_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;The classes labels. Only exist if the last step is a classifier.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">1</span><span class="s4">].</span><span class="s1">classes_</span>

    <span class="s3">def </span><span class="s1">_more_tags</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">tags </span><span class="s4">= {</span>
            <span class="s5">&quot;_xfail_checks&quot;</span><span class="s4">: {</span>
                <span class="s5">&quot;check_dont_overwrite_parameters&quot;</span><span class="s4">: (</span>
                    <span class="s5">&quot;Pipeline changes the `steps` parameter, which it shouldn't.&quot;</span>
                    <span class="s5">&quot;Therefore this test is x-fail until we fix this.&quot;</span>
                <span class="s4">),</span>
                <span class="s5">&quot;check_estimators_overwrite_params&quot;</span><span class="s4">: (</span>
                    <span class="s5">&quot;Pipeline changes the `steps` parameter, which it shouldn't.&quot;</span>
                    <span class="s5">&quot;Therefore this test is x-fail until we fix this.&quot;</span>
                <span class="s4">),</span>
            <span class="s4">}</span>
        <span class="s4">}</span>

        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">tags</span><span class="s4">[</span><span class="s5">&quot;pairwise&quot;</span><span class="s4">] = </span><span class="s1">_safe_tags</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[</span><span class="s6">0</span><span class="s4">][</span><span class="s6">1</span><span class="s4">], </span><span class="s5">&quot;pairwise&quot;</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">, </span><span class="s1">AttributeError</span><span class="s4">, </span><span class="s1">TypeError</span><span class="s4">):</span>
            <span class="s2"># This happens when the `steps` is not a list of (name, estimator)</span>
            <span class="s2"># tuples and `fit` is not called yet to validate the steps.</span>
            <span class="s3">pass</span>

        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">tags</span><span class="s4">[</span><span class="s5">&quot;multioutput&quot;</span><span class="s4">] = </span><span class="s1">_safe_tags</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">1</span><span class="s4">], </span><span class="s5">&quot;multioutput&quot;</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">, </span><span class="s1">AttributeError</span><span class="s4">, </span><span class="s1">TypeError</span><span class="s4">):</span>
            <span class="s2"># This happens when the `steps` is not a list of (name, estimator)</span>
            <span class="s2"># tuples and `fit` is not called yet to validate the steps.</span>
            <span class="s3">pass</span>

        <span class="s3">return </span><span class="s1">tags</span>

    <span class="s3">def </span><span class="s1">get_feature_names_out</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">input_features</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Get output feature names for transformation. 
 
        Transform input features using the pipeline. 
 
        Parameters 
        ---------- 
        input_features : array-like of str or None, default=None 
            Input features. 
 
        Returns 
        ------- 
        feature_names_out : ndarray of str objects 
            Transformed feature names. 
        &quot;&quot;&quot;</span>
        <span class="s1">feature_names_out </span><span class="s4">= </span><span class="s1">input_features</span>
        <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">transform </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">():</span>
            <span class="s3">if not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">transform</span><span class="s4">, </span><span class="s5">&quot;get_feature_names_out&quot;</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span>
                    <span class="s5">&quot;Estimator {} does not provide get_feature_names_out. &quot;</span>
                    <span class="s5">&quot;Did you mean to call pipeline[:-1].get_feature_names_out&quot;</span>
                    <span class="s5">&quot;()?&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
                <span class="s4">)</span>
            <span class="s1">feature_names_out </span><span class="s4">= </span><span class="s1">transform</span><span class="s4">.</span><span class="s1">get_feature_names_out</span><span class="s4">(</span><span class="s1">feature_names_out</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">feature_names_out</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">n_features_in_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Number of features seen during first step `fit` method.&quot;&quot;&quot;</span>
        <span class="s2"># delegate to first step (which will call _check_is_fitted)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[</span><span class="s6">0</span><span class="s4">][</span><span class="s6">1</span><span class="s4">].</span><span class="s1">n_features_in_</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">feature_names_in_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Names of features seen during first step `fit` method.&quot;&quot;&quot;</span>
        <span class="s2"># delegate to first step (which will call _check_is_fitted)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[</span><span class="s6">0</span><span class="s4">][</span><span class="s6">1</span><span class="s4">].</span><span class="s1">feature_names_in_</span>

    <span class="s3">def </span><span class="s1">__sklearn_is_fitted__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Indicate whether pipeline has been fit.&quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s2"># check if the last step of the pipeline is fitted</span>
            <span class="s2"># we only check the last step since if the last step is fit, it</span>
            <span class="s2"># means the previous steps should also be fit. This is faster than</span>
            <span class="s2"># checking if every step of the pipeline is fit.</span>
            <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">][</span><span class="s6">1</span><span class="s4">])</span>
            <span class="s3">return True</span>
        <span class="s3">except </span><span class="s1">NotFittedError</span><span class="s4">:</span>
            <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_sk_visual_block_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">_</span><span class="s4">, </span><span class="s1">estimators </span><span class="s4">= </span><span class="s1">zip</span><span class="s4">(*</span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">_get_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">est</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">est </span><span class="s3">is None or </span><span class="s1">est </span><span class="s4">== </span><span class="s5">&quot;passthrough&quot;</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s5">: passthrough&quot;</span>
            <span class="s2"># Is an estimator</span>
            <span class="s3">return </span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s5">: </span><span class="s3">{</span><span class="s1">est</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s3">}</span><span class="s5">&quot;</span>

        <span class="s1">names </span><span class="s4">= [</span><span class="s1">_get_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">est</span><span class="s4">) </span><span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">est </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">]</span>
        <span class="s1">name_details </span><span class="s4">= [</span><span class="s1">str</span><span class="s4">(</span><span class="s1">est</span><span class="s4">) </span><span class="s3">for </span><span class="s1">est </span><span class="s3">in </span><span class="s1">estimators</span><span class="s4">]</span>
        <span class="s3">return </span><span class="s1">_VisualBlock</span><span class="s4">(</span>
            <span class="s5">&quot;serial&quot;</span><span class="s4">,</span>
            <span class="s1">estimators</span><span class="s4">,</span>
            <span class="s1">names</span><span class="s4">=</span><span class="s1">names</span><span class="s4">,</span>
            <span class="s1">name_details</span><span class="s4">=</span><span class="s1">name_details</span><span class="s4">,</span>
            <span class="s1">dash_wrapped</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_metadata_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Get metadata routing of this object. 
 
        Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing 
        mechanism works. 
 
        Returns 
        ------- 
        routing : MetadataRouter 
            A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating 
            routing information. 
        &quot;&quot;&quot;</span>
        <span class="s1">router </span><span class="s4">= </span><span class="s1">MetadataRouter</span><span class="s4">(</span><span class="s1">owner</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">)</span>

        <span class="s2"># first we add all steps except the last one</span>
        <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">(</span><span class="s1">with_final</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">filter_passthrough</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
            <span class="s1">method_mapping </span><span class="s4">= </span><span class="s1">MethodMapping</span><span class="s4">()</span>
            <span class="s2"># fit, fit_predict, and fit_transform call fit_transform if it</span>
            <span class="s2"># exists, or else fit and transform</span>
            <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">trans</span><span class="s4">, </span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">):</span>
                <span class="s4">(</span>
                    <span class="s1">method_mapping</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">)</span>
                    <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">)</span>
                    <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit_predict&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">)</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s4">(</span>
                    <span class="s1">method_mapping</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">)</span>
                    <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>
                    <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">)</span>
                    <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>
                    <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit_predict&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">)</span>
                    <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit_predict&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>
                <span class="s4">)</span>

            <span class="s4">(</span>
                <span class="s1">method_mapping</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;predict&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>
                <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;predict&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>
                <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>
                <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;decision_function&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>
                <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;predict_log_proba&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>
                <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>
                <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;inverse_transform&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;inverse_transform&quot;</span><span class="s4">)</span>
                <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;score&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>
            <span class="s4">)</span>

            <span class="s1">router</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">method_mapping</span><span class="s4">=</span><span class="s1">method_mapping</span><span class="s4">, **{</span><span class="s1">name</span><span class="s4">: </span><span class="s1">trans</span><span class="s4">})</span>

        <span class="s1">final_name</span><span class="s4">, </span><span class="s1">final_est </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">steps</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">final_est </span><span class="s3">is None or </span><span class="s1">final_est </span><span class="s4">== </span><span class="s5">&quot;passthrough&quot;</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">router</span>

        <span class="s2"># then we add the last step</span>
        <span class="s1">method_mapping </span><span class="s4">= </span><span class="s1">MethodMapping</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">final_est</span><span class="s4">, </span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">):</span>
            <span class="s1">method_mapping</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">method_mapping</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">).</span><span class="s1">add</span><span class="s4">(</span>
                <span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span>
            <span class="s4">)</span>
        <span class="s4">(</span>
            <span class="s1">method_mapping</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;predict&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;predict&quot;</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit_predict&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;fit_predict&quot;</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;decision_function&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;decision_function&quot;</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;predict_log_proba&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;predict_log_proba&quot;</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;inverse_transform&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;inverse_transform&quot;</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;score&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;score&quot;</span><span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s1">router</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">method_mapping</span><span class="s4">=</span><span class="s1">method_mapping</span><span class="s4">, **{</span><span class="s1">final_name</span><span class="s4">: </span><span class="s1">final_est</span><span class="s4">})</span>
        <span class="s3">return </span><span class="s1">router</span>


<span class="s3">def </span><span class="s1">_name_estimators</span><span class="s4">(</span><span class="s1">estimators</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Generate names for estimators.&quot;&quot;&quot;</span>

    <span class="s1">names </span><span class="s4">= [</span>
        <span class="s1">estimator </span><span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">str</span><span class="s4">) </span><span class="s3">else </span><span class="s1">type</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">).</span><span class="s1">__name__</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">()</span>
        <span class="s3">for </span><span class="s1">estimator </span><span class="s3">in </span><span class="s1">estimators</span>
    <span class="s4">]</span>
    <span class="s1">namecount </span><span class="s4">= </span><span class="s1">defaultdict</span><span class="s4">(</span><span class="s1">int</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">est</span><span class="s4">, </span><span class="s1">name </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">estimators</span><span class="s4">, </span><span class="s1">names</span><span class="s4">):</span>
        <span class="s1">namecount</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] += </span><span class="s6">1</span>

    <span class="s3">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">namecount</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()):</span>
        <span class="s3">if </span><span class="s1">v </span><span class="s4">== </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s3">del </span><span class="s1">namecount</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>

    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">reversed</span><span class="s4">(</span><span class="s1">range</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">estimators</span><span class="s4">))):</span>
        <span class="s1">name </span><span class="s4">= </span><span class="s1">names</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">namecount</span><span class="s4">:</span>
            <span class="s1">names</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] += </span><span class="s5">&quot;-%d&quot; </span><span class="s4">% </span><span class="s1">namecount</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]</span>
            <span class="s1">namecount</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] -= </span><span class="s6">1</span>

    <span class="s3">return </span><span class="s1">list</span><span class="s4">(</span><span class="s1">zip</span><span class="s4">(</span><span class="s1">names</span><span class="s4">, </span><span class="s1">estimators</span><span class="s4">))</span>


<span class="s3">def </span><span class="s1">make_pipeline</span><span class="s4">(*</span><span class="s1">steps</span><span class="s4">, </span><span class="s1">memory</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Construct a :class:`Pipeline` from the given estimators. 
 
    This is a shorthand for the :class:`Pipeline` constructor; it does not 
    require, and does not permit, naming the estimators. Instead, their names 
    will be set to the lowercase of their types automatically. 
 
    Parameters 
    ---------- 
    *steps : list of Estimator objects 
        List of the scikit-learn estimators that are chained together. 
 
    memory : str or object with the joblib.Memory interface, default=None 
        Used to cache the fitted transformers of the pipeline. The last step 
        will never be cached, even if it is a transformer. By default, no 
        caching is performed. If a string is given, it is the path to the 
        caching directory. Enabling caching triggers a clone of the transformers 
        before fitting. Therefore, the transformer instance given to the 
        pipeline cannot be inspected directly. Use the attribute ``named_steps`` 
        or ``steps`` to inspect estimators within the pipeline. Caching the 
        transformers is advantageous when fitting is time consuming. 
 
    verbose : bool, default=False 
        If True, the time elapsed while fitting each step will be printed as it 
        is completed. 
 
    Returns 
    ------- 
    p : Pipeline 
        Returns a scikit-learn :class:`Pipeline` object. 
 
    See Also 
    -------- 
    Pipeline : Class for creating a pipeline of transforms with a final 
        estimator. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.naive_bayes import GaussianNB 
    &gt;&gt;&gt; from sklearn.preprocessing import StandardScaler 
    &gt;&gt;&gt; from sklearn.pipeline import make_pipeline 
    &gt;&gt;&gt; make_pipeline(StandardScaler(), GaussianNB(priors=None)) 
    Pipeline(steps=[('standardscaler', StandardScaler()), 
                    ('gaussiannb', GaussianNB())]) 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">Pipeline</span><span class="s4">(</span><span class="s1">_name_estimators</span><span class="s4">(</span><span class="s1">steps</span><span class="s4">), </span><span class="s1">memory</span><span class="s4">=</span><span class="s1">memory</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_transform_one</span><span class="s4">(</span><span class="s1">transformer</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">weight</span><span class="s4">, </span><span class="s1">params</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Call transform and apply weight to output. 
 
    Parameters 
    ---------- 
    transformer : estimator 
        Estimator to be used for transformation. 
 
    X : {array-like, sparse matrix} of shape (n_samples, n_features) 
        Input data to be transformed. 
 
    y : ndarray of shape (n_samples,) 
        Ignored. 
 
    weight : float 
        Weight to be applied to the output of the transformation. 
 
    params : dict 
        Parameters to be passed to the transformer's ``transform`` method. 
 
        This should be of the form ``process_routing()[&quot;step_name&quot;]``. 
    &quot;&quot;&quot;</span>
    <span class="s1">res </span><span class="s4">= </span><span class="s1">transformer</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">.</span><span class="s1">transform</span><span class="s4">)</span>
    <span class="s2"># if we have a weight for this transformer, multiply output</span>
    <span class="s3">if </span><span class="s1">weight </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">res</span>
    <span class="s3">return </span><span class="s1">res </span><span class="s4">* </span><span class="s1">weight</span>


<span class="s3">def </span><span class="s1">_fit_transform_one</span><span class="s4">(</span>
    <span class="s1">transformer</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">weight</span><span class="s4">, </span><span class="s1">message_clsname</span><span class="s4">=</span><span class="s5">&quot;&quot;</span><span class="s4">, </span><span class="s1">message</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">params</span><span class="s4">=</span><span class="s3">None</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Fits ``transformer`` to ``X`` and ``y``. The transformed result is returned 
    with the fitted transformer. If ``weight`` is not ``None``, the result will 
    be multiplied by ``weight``. 
 
    ``params`` needs to be of the form ``process_routing()[&quot;step_name&quot;]``. 
    &quot;&quot;&quot;</span>
    <span class="s1">params </span><span class="s4">= </span><span class="s1">params </span><span class="s3">or </span><span class="s4">{}</span>
    <span class="s3">with </span><span class="s1">_print_elapsed_time</span><span class="s4">(</span><span class="s1">message_clsname</span><span class="s4">, </span><span class="s1">message</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">transformer</span><span class="s4">, </span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">):</span>
            <span class="s1">res </span><span class="s4">= </span><span class="s1">transformer</span><span class="s4">.</span><span class="s1">fit_transform</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">, {}))</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">res </span><span class="s4">= </span><span class="s1">transformer</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;fit&quot;</span><span class="s4">, {})).</span><span class="s1">transform</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;transform&quot;</span><span class="s4">, {})</span>
            <span class="s4">)</span>

    <span class="s3">if </span><span class="s1">weight </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">res</span><span class="s4">, </span><span class="s1">transformer</span>
    <span class="s3">return </span><span class="s1">res </span><span class="s4">* </span><span class="s1">weight</span><span class="s4">, </span><span class="s1">transformer</span>


<span class="s3">def </span><span class="s1">_fit_one</span><span class="s4">(</span><span class="s1">transformer</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">weight</span><span class="s4">, </span><span class="s1">message_clsname</span><span class="s4">=</span><span class="s5">&quot;&quot;</span><span class="s4">, </span><span class="s1">message</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">params</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Fits ``transformer`` to ``X`` and ``y``. 
    &quot;&quot;&quot;</span>
    <span class="s3">with </span><span class="s1">_print_elapsed_time</span><span class="s4">(</span><span class="s1">message_clsname</span><span class="s4">, </span><span class="s1">message</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">transformer</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">[</span><span class="s5">&quot;fit&quot;</span><span class="s4">])</span>


<span class="s3">class </span><span class="s1">FeatureUnion</span><span class="s4">(</span><span class="s1">TransformerMixin</span><span class="s4">, </span><span class="s1">_BaseComposition</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Concatenates results of multiple transformer objects. 
 
    This estimator applies a list of transformer objects in parallel to the 
    input data, then concatenates the results. This is useful to combine 
    several feature extraction mechanisms into a single transformer. 
 
    Parameters of the transformers may be set using its name and the parameter 
    name separated by a '__'. A transformer may be replaced entirely by 
    setting the parameter with its name to another transformer, removed by 
    setting to 'drop' or disabled by setting to 'passthrough' (features are 
    passed without transformation). 
 
    Read more in the :ref:`User Guide &lt;feature_union&gt;`. 
 
    .. versionadded:: 0.13 
 
    Parameters 
    ---------- 
    transformer_list : list of (str, transformer) tuples 
        List of transformer objects to be applied to the data. The first 
        half of each tuple is the name of the transformer. The transformer can 
        be 'drop' for it to be ignored or can be 'passthrough' for features to 
        be passed unchanged. 
 
        .. versionadded:: 1.1 
           Added the option `&quot;passthrough&quot;`. 
 
        .. versionchanged:: 0.22 
           Deprecated `None` as a transformer in favor of 'drop'. 
 
    n_jobs : int, default=None 
        Number of jobs to run in parallel. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
        .. versionchanged:: v0.20 
           `n_jobs` default changed from 1 to None 
 
    transformer_weights : dict, default=None 
        Multiplicative weights for features per transformer. 
        Keys are transformer names, values the weights. 
        Raises ValueError if key not present in ``transformer_list``. 
 
    verbose : bool, default=False 
        If True, the time elapsed while fitting each transformer will be 
        printed as it is completed. 
 
    verbose_feature_names_out : bool, default=True 
        If True, :meth:`get_feature_names_out` will prefix all feature names 
        with the name of the transformer that generated that feature. 
        If False, :meth:`get_feature_names_out` will not prefix any feature 
        names and will error if feature names are not unique. 
 
        .. versionadded:: 1.5 
 
    Attributes 
    ---------- 
    named_transformers : :class:`~sklearn.utils.Bunch` 
        Dictionary-like object, with the following attributes. 
        Read-only attribute to access any transformer parameter by user 
        given name. Keys are transformer names and values are 
        transformer parameters. 
 
        .. versionadded:: 1.2 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. Only defined if the 
        underlying first transformer in `transformer_list` exposes such an 
        attribute when fit. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when 
        `X` has feature names that are all strings. 
 
        .. versionadded:: 1.3 
 
    See Also 
    -------- 
    make_union : Convenience function for simplified feature union 
        construction. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.pipeline import FeatureUnion 
    &gt;&gt;&gt; from sklearn.decomposition import PCA, TruncatedSVD 
    &gt;&gt;&gt; union = FeatureUnion([(&quot;pca&quot;, PCA(n_components=1)), 
    ...                       (&quot;svd&quot;, TruncatedSVD(n_components=2))]) 
    &gt;&gt;&gt; X = [[0., 1., 3], [2., 2., 5]] 
    &gt;&gt;&gt; union.fit_transform(X) 
    array([[-1.5       ,  3.0..., -0.8...], 
           [ 1.5       ,  5.7...,  0.4...]]) 
    &gt;&gt;&gt; # An estimator's parameter can be set using '__' syntax 
    &gt;&gt;&gt; union.set_params(svd__n_components=1).fit_transform(X) 
    array([[-1.5       ,  3.0...], 
           [ 1.5       ,  5.7...]]) 
 
    For a more detailed example of usage, see 
    :ref:`sphx_glr_auto_examples_compose_plot_feature_union.py`. 
    &quot;&quot;&quot;</span>

    <span class="s1">_required_parameters </span><span class="s4">= [</span><span class="s5">&quot;transformer_list&quot;</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">transformer_list</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">n_jobs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">transformer_weights</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">verbose_feature_names_out</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_list </span><span class="s4">= </span><span class="s1">transformer_list</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs </span><span class="s4">= </span><span class="s1">n_jobs</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_weights </span><span class="s4">= </span><span class="s1">transformer_weights</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">verbose </span><span class="s4">= </span><span class="s1">verbose</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">verbose_feature_names_out </span><span class="s4">= </span><span class="s1">verbose_feature_names_out</span>

    <span class="s3">def </span><span class="s1">set_output</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *, </span><span class="s1">transform</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Set the output container when `&quot;transform&quot;` and `&quot;fit_transform&quot;` are called. 
 
        `set_output` will set the output of all estimators in `transformer_list`. 
 
        Parameters 
        ---------- 
        transform : {&quot;default&quot;, &quot;pandas&quot;, &quot;polars&quot;}, default=None 
            Configure output of `transform` and `fit_transform`. 
 
            - `&quot;default&quot;`: Default output format of a transformer 
            - `&quot;pandas&quot;`: DataFrame output 
            - `&quot;polars&quot;`: Polars output 
            - `None`: Transform configuration is unchanged 
 
        Returns 
        ------- 
        self : estimator instance 
            Estimator instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">set_output</span><span class="s4">(</span><span class="s1">transform</span><span class="s4">=</span><span class="s1">transform</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">step</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">():</span>
            <span class="s1">_safe_set_output</span><span class="s4">(</span><span class="s1">step</span><span class="s4">, </span><span class="s1">transform</span><span class="s4">=</span><span class="s1">transform</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">named_transformers</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2"># Use Bunch object to improve autocomplete</span>
        <span class="s3">return </span><span class="s1">Bunch</span><span class="s4">(**</span><span class="s1">dict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_list</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">get_params</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">deep</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Get parameters for this estimator. 
 
        Returns the parameters given in the constructor as well as the 
        estimators contained within the `transformer_list` of the 
        `FeatureUnion`. 
 
        Parameters 
        ---------- 
        deep : bool, default=True 
            If True, will return the parameters for this estimator and 
            contained subobjects that are estimators. 
 
        Returns 
        ------- 
        params : mapping of string to any 
            Parameter names mapped to their values. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_params</span><span class="s4">(</span><span class="s5">&quot;transformer_list&quot;</span><span class="s4">, </span><span class="s1">deep</span><span class="s4">=</span><span class="s1">deep</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">set_params</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Set the parameters of this estimator. 
 
        Valid parameter keys can be listed with ``get_params()``. Note that 
        you can directly set the parameters of the estimators contained in 
        `transformer_list`. 
 
        Parameters 
        ---------- 
        **kwargs : dict 
            Parameters of this estimator or parameters of estimators contained 
            in `transform_list`. Parameters of the transformers may be set 
            using its name and the parameter name separated by a '__'. 
 
        Returns 
        ------- 
        self : object 
            FeatureUnion class instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_set_params</span><span class="s4">(</span><span class="s5">&quot;transformer_list&quot;</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_validate_transformers</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">names</span><span class="s4">, </span><span class="s1">transformers </span><span class="s4">= </span><span class="s1">zip</span><span class="s4">(*</span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_list</span><span class="s4">)</span>

        <span class="s2"># validate names</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_names</span><span class="s4">(</span><span class="s1">names</span><span class="s4">)</span>

        <span class="s2"># validate estimators</span>
        <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">transformers</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">t </span><span class="s3">in </span><span class="s4">(</span><span class="s5">&quot;drop&quot;</span><span class="s4">, </span><span class="s5">&quot;passthrough&quot;</span><span class="s4">):</span>
                <span class="s3">continue</span>
            <span class="s3">if not </span><span class="s4">(</span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">t</span><span class="s4">, </span><span class="s5">&quot;fit&quot;</span><span class="s4">) </span><span class="s3">or </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">t</span><span class="s4">, </span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">)) </span><span class="s3">or not </span><span class="s1">hasattr</span><span class="s4">(</span>
                <span class="s1">t</span><span class="s4">, </span><span class="s5">&quot;transform&quot;</span>
            <span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span>
                    <span class="s5">&quot;All estimators should implement fit and &quot;</span>
                    <span class="s5">&quot;transform. '%s' (type %s) doesn't&quot; </span><span class="s4">% (</span><span class="s1">t</span><span class="s4">, </span><span class="s1">type</span><span class="s4">(</span><span class="s1">t</span><span class="s4">))</span>
                <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_validate_transformer_weights</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_weights</span><span class="s4">:</span>
            <span class="s3">return</span>

        <span class="s1">transformer_names </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">name </span><span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_list</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_weights</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">transformer_names</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                    <span class="s5">f'Attempting to weight transformer &quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s5">&quot;, '</span>
                    <span class="s5">&quot;but it is not present in transformer_list.&quot;</span>
                <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_iter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Generate (name, trans, weight) tuples excluding None and 
        'drop' transformers. 
        &quot;&quot;&quot;</span>

        <span class="s1">get_weight </span><span class="s4">= (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_weights </span><span class="s3">or </span><span class="s4">{}).</span><span class="s1">get</span>

        <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_list</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">trans </span><span class="s4">== </span><span class="s5">&quot;drop&quot;</span><span class="s4">:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">trans </span><span class="s4">== </span><span class="s5">&quot;passthrough&quot;</span><span class="s4">:</span>
                <span class="s1">trans </span><span class="s4">= </span><span class="s1">FunctionTransformer</span><span class="s4">(</span><span class="s1">feature_names_out</span><span class="s4">=</span><span class="s5">&quot;one-to-one&quot;</span><span class="s4">)</span>
            <span class="s3">yield </span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">get_weight</span><span class="s4">(</span><span class="s1">name</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">get_feature_names_out</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">input_features</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Get output feature names for transformation. 
 
        Parameters 
        ---------- 
        input_features : array-like of str or None, default=None 
            Input features. 
 
        Returns 
        ------- 
        feature_names_out : ndarray of str objects 
            Transformed feature names. 
        &quot;&quot;&quot;</span>
        <span class="s2"># List of tuples (name, feature_names_out)</span>
        <span class="s1">transformer_with_feature_names_out </span><span class="s4">= []</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">():</span>
            <span class="s3">if not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">trans</span><span class="s4">, </span><span class="s5">&quot;get_feature_names_out&quot;</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span>
                    <span class="s5">&quot;Transformer %s (type %s) does not provide get_feature_names_out.&quot;</span>
                    <span class="s4">% (</span><span class="s1">str</span><span class="s4">(</span><span class="s1">name</span><span class="s4">), </span><span class="s1">type</span><span class="s4">(</span><span class="s1">trans</span><span class="s4">).</span><span class="s1">__name__</span><span class="s4">)</span>
                <span class="s4">)</span>
            <span class="s1">feature_names_out </span><span class="s4">= </span><span class="s1">trans</span><span class="s4">.</span><span class="s1">get_feature_names_out</span><span class="s4">(</span><span class="s1">input_features</span><span class="s4">)</span>
            <span class="s1">transformer_with_feature_names_out</span><span class="s4">.</span><span class="s1">append</span><span class="s4">((</span><span class="s1">name</span><span class="s4">, </span><span class="s1">feature_names_out</span><span class="s4">))</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_add_prefix_for_feature_names_out</span><span class="s4">(</span>
            <span class="s1">transformer_with_feature_names_out</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_add_prefix_for_feature_names_out</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">transformer_with_feature_names_out</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Add prefix for feature names out that includes the transformer names. 
 
        Parameters 
        ---------- 
        transformer_with_feature_names_out : list of tuples of (str, array-like of str) 
            The tuple consistent of the transformer's name and its feature names out. 
 
        Returns 
        ------- 
        feature_names_out : ndarray of shape (n_features,), dtype=str 
            Transformed feature names. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose_feature_names_out</span><span class="s4">:</span>
            <span class="s2"># Prefix the feature names out with the transformers name</span>
            <span class="s1">names </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span>
                <span class="s1">chain</span><span class="s4">.</span><span class="s1">from_iterable</span><span class="s4">(</span>
                    <span class="s4">(</span><span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s5">__</span><span class="s3">{</span><span class="s1">i</span><span class="s3">}</span><span class="s5">&quot; </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">feature_names_out</span><span class="s4">)</span>
                    <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">feature_names_out </span><span class="s3">in </span><span class="s1">transformer_with_feature_names_out</span>
                <span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">names</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">object</span><span class="s4">)</span>

        <span class="s2"># verbose_feature_names_out is False</span>
        <span class="s2"># Check that names are all unique without a prefix</span>
        <span class="s1">feature_names_count </span><span class="s4">= </span><span class="s1">Counter</span><span class="s4">(</span>
            <span class="s1">chain</span><span class="s4">.</span><span class="s1">from_iterable</span><span class="s4">(</span><span class="s1">s </span><span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">s </span><span class="s3">in </span><span class="s1">transformer_with_feature_names_out</span><span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s1">top_6_overlap </span><span class="s4">= [</span>
            <span class="s1">name </span><span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">count </span><span class="s3">in </span><span class="s1">feature_names_count</span><span class="s4">.</span><span class="s1">most_common</span><span class="s4">(</span><span class="s6">6</span><span class="s4">) </span><span class="s3">if </span><span class="s1">count </span><span class="s4">&gt; </span><span class="s6">1</span>
        <span class="s4">]</span>
        <span class="s1">top_6_overlap</span><span class="s4">.</span><span class="s1">sort</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">top_6_overlap</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">top_6_overlap</span><span class="s4">) == </span><span class="s6">6</span><span class="s4">:</span>
                <span class="s2"># There are more than 5 overlapping names, we only show the 5</span>
                <span class="s2"># of the feature names</span>
                <span class="s1">names_repr </span><span class="s4">= </span><span class="s1">str</span><span class="s4">(</span><span class="s1">top_6_overlap</span><span class="s4">[:</span><span class="s6">5</span><span class="s4">])[:-</span><span class="s6">1</span><span class="s4">] + </span><span class="s5">&quot;, ...]&quot;</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">names_repr </span><span class="s4">= </span><span class="s1">str</span><span class="s4">(</span><span class="s1">top_6_overlap</span><span class="s4">)</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">f&quot;Output feature names: </span><span class="s3">{</span><span class="s1">names_repr</span><span class="s3">} </span><span class="s5">are not unique. Please set &quot;</span>
                <span class="s5">&quot;verbose_feature_names_out=True to add prefixes to feature names&quot;</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">concatenate</span><span class="s4">(</span>
            <span class="s4">[</span><span class="s1">name </span><span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">name </span><span class="s3">in </span><span class="s1">transformer_with_feature_names_out</span><span class="s4">],</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">fit_params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Fit all transformers using X. 
 
        Parameters 
        ---------- 
        X : iterable or array-like, depending on transformers 
            Input data, used to fit transformers. 
 
        y : array-like of shape (n_samples, n_outputs), default=None 
            Targets for supervised learning. 
 
        **fit_params : dict, default=None 
            - If `enable_metadata_routing=False` (default): 
              Parameters directly passed to the `fit` methods of the 
              sub-transformers. 
 
            - If `enable_metadata_routing=True`: 
              Parameters safely routed to the `fit` methods of the 
              sub-transformers. See :ref:`Metadata Routing User Guide 
              &lt;metadata_routing&gt;` for more details. 
 
            .. versionchanged:: 1.5 
                `**fit_params` can be routed via metadata routing API. 
 
        Returns 
        ------- 
        self : object 
            FeatureUnion class instance. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">_routing_enabled</span><span class="s4">():</span>
            <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">process_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;fit&quot;</span><span class="s4">, **</span><span class="s1">fit_params</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># TODO(SLEP6): remove when metadata routing cannot be disabled.</span>
            <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">Bunch</span><span class="s4">()</span>
            <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_list</span><span class="s4">:</span>
                <span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">Bunch</span><span class="s4">(</span><span class="s1">fit</span><span class="s4">={})</span>
                <span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">].</span><span class="s1">fit </span><span class="s4">= </span><span class="s1">fit_params</span>

        <span class="s1">transformers </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parallel_func</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">_fit_one</span><span class="s4">, </span><span class="s1">routed_params</span><span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">transformers</span><span class="s4">:</span>
            <span class="s2"># All transformers are None</span>
            <span class="s3">return </span><span class="s1">self</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_update_transformer_list</span><span class="s4">(</span><span class="s1">transformers</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">fit_transform</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Fit all transformers, transform the data and concatenate results. 
 
        Parameters 
        ---------- 
        X : iterable or array-like, depending on transformers 
            Input data to be transformed. 
 
        y : array-like of shape (n_samples, n_outputs), default=None 
            Targets for supervised learning. 
 
        **params : dict, default=None 
            - If `enable_metadata_routing=False` (default): 
              Parameters directly passed to the `fit` methods of the 
              sub-transformers. 
 
            - If `enable_metadata_routing=True`: 
              Parameters safely routed to the `fit` methods of the 
              sub-transformers. See :ref:`Metadata Routing User Guide 
              &lt;metadata_routing&gt;` for more details. 
 
            .. versionchanged:: 1.5 
                `**params` can now be routed via metadata routing API. 
 
        Returns 
        ------- 
        X_t : array-like or sparse matrix of \ 
                shape (n_samples, sum_n_components) 
            The `hstack` of results of transformers. `sum_n_components` is the 
            sum of `n_components` (output dimension) over transformers. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">_routing_enabled</span><span class="s4">():</span>
            <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">process_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># TODO(SLEP6): remove when metadata routing cannot be disabled.</span>
            <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">Bunch</span><span class="s4">()</span>
            <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">obj </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_list</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">):</span>
                    <span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">Bunch</span><span class="s4">(</span><span class="s1">fit_transform</span><span class="s4">={})</span>
                    <span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">].</span><span class="s1">fit_transform </span><span class="s4">= </span><span class="s1">params</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">Bunch</span><span class="s4">(</span><span class="s1">fit</span><span class="s4">={})</span>
                    <span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">Bunch</span><span class="s4">(</span><span class="s1">transform</span><span class="s4">={})</span>
                    <span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">].</span><span class="s1">fit </span><span class="s4">= </span><span class="s1">params</span>

        <span class="s1">results </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parallel_func</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">_fit_transform_one</span><span class="s4">, </span><span class="s1">routed_params</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">results</span><span class="s4">:</span>
            <span class="s2"># All transformers are None</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s6">0</span><span class="s4">))</span>

        <span class="s1">Xs</span><span class="s4">, </span><span class="s1">transformers </span><span class="s4">= </span><span class="s1">zip</span><span class="s4">(*</span><span class="s1">results</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_update_transformer_list</span><span class="s4">(</span><span class="s1">transformers</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_hstack</span><span class="s4">(</span><span class="s1">Xs</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_log_message</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">total</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose</span><span class="s4">:</span>
            <span class="s3">return None</span>
        <span class="s3">return </span><span class="s5">&quot;(step %d of %d) Processing %s&quot; </span><span class="s4">% (</span><span class="s1">idx</span><span class="s4">, </span><span class="s1">total</span><span class="s4">, </span><span class="s1">name</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_parallel_func</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">func</span><span class="s4">, </span><span class="s1">routed_params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Runs func in parallel on X and y&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_list </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_list</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_transformers</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_transformer_weights</span><span class="s4">()</span>
        <span class="s1">transformers </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">())</span>

        <span class="s3">return </span><span class="s1">Parallel</span><span class="s4">(</span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs</span><span class="s4">)(</span>
            <span class="s1">delayed</span><span class="s4">(</span><span class="s1">func</span><span class="s4">)(</span>
                <span class="s1">transformer</span><span class="s4">,</span>
                <span class="s1">X</span><span class="s4">,</span>
                <span class="s1">y</span><span class="s4">,</span>
                <span class="s1">weight</span><span class="s4">,</span>
                <span class="s1">message_clsname</span><span class="s4">=</span><span class="s5">&quot;FeatureUnion&quot;</span><span class="s4">,</span>
                <span class="s1">message</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_log_message</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">len</span><span class="s4">(</span><span class="s1">transformers</span><span class="s4">)),</span>
                <span class="s1">params</span><span class="s4">=</span><span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">],</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">idx</span><span class="s4">, (</span><span class="s1">name</span><span class="s4">, </span><span class="s1">transformer</span><span class="s4">, </span><span class="s1">weight</span><span class="s4">) </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">transformers</span><span class="s4">, </span><span class="s6">1</span><span class="s4">)</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">transform</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Transform X separately by each transformer, concatenate results. 
 
        Parameters 
        ---------- 
        X : iterable or array-like, depending on transformers 
            Input data to be transformed. 
 
        **params : dict, default=None 
 
            Parameters routed to the `transform` method of the sub-transformers via the 
            metadata routing API. See :ref:`Metadata Routing User Guide 
            &lt;metadata_routing&gt;` for more details. 
 
            .. versionadded:: 1.5 
 
        Returns 
        ------- 
        X_t : array-like or sparse matrix of shape (n_samples, sum_n_components) 
            The `hstack` of results of transformers. `sum_n_components` is the 
            sum of `n_components` (output dimension) over transformers. 
        &quot;&quot;&quot;</span>
        <span class="s1">_raise_for_params</span><span class="s4">(</span><span class="s1">params</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">_routing_enabled</span><span class="s4">():</span>
            <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">process_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;transform&quot;</span><span class="s4">, **</span><span class="s1">params</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># TODO(SLEP6): remove when metadata routing cannot be disabled.</span>
            <span class="s1">routed_params </span><span class="s4">= </span><span class="s1">Bunch</span><span class="s4">()</span>
            <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_list</span><span class="s4">:</span>
                <span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">Bunch</span><span class="s4">(</span><span class="s1">transform</span><span class="s4">={})</span>

        <span class="s1">Xs </span><span class="s4">= </span><span class="s1">Parallel</span><span class="s4">(</span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs</span><span class="s4">)(</span>
            <span class="s1">delayed</span><span class="s4">(</span><span class="s1">_transform_one</span><span class="s4">)(</span><span class="s1">trans</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">weight</span><span class="s4">, </span><span class="s1">params</span><span class="s4">=</span><span class="s1">routed_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">])</span>
            <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">trans</span><span class="s4">, </span><span class="s1">weight </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">()</span>
        <span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">Xs</span><span class="s4">:</span>
            <span class="s2"># All transformers are None</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s6">0</span><span class="s4">))</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_hstack</span><span class="s4">(</span><span class="s1">Xs</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_hstack</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">Xs</span><span class="s4">):</span>
        <span class="s1">adapter </span><span class="s4">= </span><span class="s1">_get_container_adapter</span><span class="s4">(</span><span class="s5">&quot;transform&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">adapter </span><span class="s3">and </span><span class="s1">all</span><span class="s4">(</span><span class="s1">adapter</span><span class="s4">.</span><span class="s1">is_supported_container</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">for </span><span class="s1">X </span><span class="s3">in </span><span class="s1">Xs</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">adapter</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">(</span><span class="s1">Xs</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">any</span><span class="s4">(</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">f</span><span class="s4">) </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">Xs</span><span class="s4">):</span>
            <span class="s1">Xs </span><span class="s4">= </span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">(</span><span class="s1">Xs</span><span class="s4">).</span><span class="s1">tocsr</span><span class="s4">()</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">Xs </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">(</span><span class="s1">Xs</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">Xs</span>

    <span class="s3">def </span><span class="s1">_update_transformer_list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">transformers</span><span class="s4">):</span>
        <span class="s1">transformers </span><span class="s4">= </span><span class="s1">iter</span><span class="s4">(</span><span class="s1">transformers</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_list</span><span class="s4">[:] = [</span>
            <span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">old </span><span class="s3">if </span><span class="s1">old </span><span class="s4">== </span><span class="s5">&quot;drop&quot; </span><span class="s3">else </span><span class="s1">next</span><span class="s4">(</span><span class="s1">transformers</span><span class="s4">))</span>
            <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">old </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_list</span>
        <span class="s4">]</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">n_features_in_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Number of features seen during :term:`fit`.&quot;&quot;&quot;</span>

        <span class="s2"># X is passed to all transformers so we just delegate to the first one</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_list</span><span class="s4">[</span><span class="s6">0</span><span class="s4">][</span><span class="s6">1</span><span class="s4">].</span><span class="s1">n_features_in_</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">feature_names_in_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Names of features seen during :term:`fit`.&quot;&quot;&quot;</span>
        <span class="s2"># X is passed to all transformers -- delegate to the first one</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_list</span><span class="s4">[</span><span class="s6">0</span><span class="s4">][</span><span class="s6">1</span><span class="s4">].</span><span class="s1">feature_names_in_</span>

    <span class="s3">def </span><span class="s1">__sklearn_is_fitted__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2"># Delegate whether feature union was fitted</span>
        <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">transformer</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">():</span>
            <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">transformer</span><span class="s4">)</span>
        <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">_sk_visual_block_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">names</span><span class="s4">, </span><span class="s1">transformers </span><span class="s4">= </span><span class="s1">zip</span><span class="s4">(*</span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_list</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">_VisualBlock</span><span class="s4">(</span><span class="s5">&quot;parallel&quot;</span><span class="s4">, </span><span class="s1">transformers</span><span class="s4">, </span><span class="s1">names</span><span class="s4">=</span><span class="s1">names</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__getitem__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return transformer with name.&quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">KeyError</span><span class="s4">(</span><span class="s5">&quot;Only string keys are supported&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">named_transformers</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">get_metadata_routing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Get metadata routing of this object. 
 
        Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing 
        mechanism works. 
 
        .. versionadded:: 1.5 
 
        Returns 
        ------- 
        routing : MetadataRouter 
            A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating 
            routing information. 
        &quot;&quot;&quot;</span>
        <span class="s1">router </span><span class="s4">= </span><span class="s1">MetadataRouter</span><span class="s4">(</span><span class="s1">owner</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">)</span>

        <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">transformer </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">transformer_list</span><span class="s4">:</span>
            <span class="s1">router</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span>
                <span class="s4">**{</span><span class="s1">name</span><span class="s4">: </span><span class="s1">transformer</span><span class="s4">},</span>
                <span class="s1">method_mapping</span><span class="s4">=</span><span class="s1">MethodMapping</span><span class="s4">()</span>
                <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">)</span>
                <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">)</span>
                <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;fit&quot;</span><span class="s4">)</span>
                <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;fit_transform&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">)</span>
                <span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">caller</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">, </span><span class="s1">callee</span><span class="s4">=</span><span class="s5">&quot;transform&quot;</span><span class="s4">),</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">router</span>


<span class="s3">def </span><span class="s1">make_union</span><span class="s4">(*</span><span class="s1">transformers</span><span class="s4">, </span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Construct a :class:`FeatureUnion` from the given transformers. 
 
    This is a shorthand for the :class:`FeatureUnion` constructor; it does not 
    require, and does not permit, naming the transformers. Instead, they will 
    be given names automatically based on their types. It also does not allow 
    weighting. 
 
    Parameters 
    ---------- 
    *transformers : list of estimators 
        One or more estimators. 
 
    n_jobs : int, default=None 
        Number of jobs to run in parallel. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
        .. versionchanged:: v0.20 
           `n_jobs` default changed from 1 to None. 
 
    verbose : bool, default=False 
        If True, the time elapsed while fitting each transformer will be 
        printed as it is completed. 
 
    Returns 
    ------- 
    f : FeatureUnion 
        A :class:`FeatureUnion` object for concatenating the results of multiple 
        transformer objects. 
 
    See Also 
    -------- 
    FeatureUnion : Class for concatenating the results of multiple transformer 
        objects. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.decomposition import PCA, TruncatedSVD 
    &gt;&gt;&gt; from sklearn.pipeline import make_union 
    &gt;&gt;&gt; make_union(PCA(), TruncatedSVD()) 
     FeatureUnion(transformer_list=[('pca', PCA()), 
                                   ('truncatedsvd', TruncatedSVD())]) 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">FeatureUnion</span><span class="s4">(</span><span class="s1">_name_estimators</span><span class="s4">(</span><span class="s1">transformers</span><span class="s4">), </span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">n_jobs</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">)</span>
</pre>
</body>
</html>