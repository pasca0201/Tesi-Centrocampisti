<html>
<head>
<title>automap.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #6aab73;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
automap.py</font>
</center></td></tr></table>
<pre><span class="s0"># ext/automap.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">r&quot;&quot;&quot;Define an extension to the :mod:`sqlalchemy.ext.declarative` system 
which automatically generates mapped classes and relationships from a database 
schema, typically though not necessarily one which is reflected. 
 
It is hoped that the :class:`.AutomapBase` system provides a quick 
and modernized solution to the problem that the very famous 
`SQLSoup &lt;https://pypi.org/project/sqlsoup/&gt;`_ 
also tries to solve, that of generating a quick and rudimentary object 
model from an existing database on the fly.  By addressing the issue strictly 
at the mapper configuration level, and integrating fully with existing 
Declarative class techniques, :class:`.AutomapBase` seeks to provide 
a well-integrated approach to the issue of expediently auto-generating ad-hoc 
mappings. 
 
.. tip:: The :ref:`automap_toplevel` extension is geared towards a 
   &quot;zero declaration&quot; approach, where a complete ORM model including classes 
   and pre-named relationships can be generated on the fly from a database 
   schema. For applications that still want to use explicit class declarations 
   including explicit relationship definitions in conjunction with reflection 
   of tables, the :class:`.DeferredReflection` class, described at 
   :ref:`orm_declarative_reflected_deferred_reflection`, is a better choice. 
 
.. _automap_basic_use: 
 
Basic Use 
========= 
 
The simplest usage is to reflect an existing database into a new model. 
We create a new :class:`.AutomapBase` class in a similar manner as to how 
we create a declarative base class, using :func:`.automap_base`. 
We then call :meth:`.AutomapBase.prepare` on the resulting base class, 
asking it to reflect the schema and produce mappings:: 
 
    from sqlalchemy.ext.automap import automap_base 
    from sqlalchemy.orm import Session 
    from sqlalchemy import create_engine 
 
    Base = automap_base() 
 
    # engine, suppose it has two tables 'user' and 'address' set up 
    engine = create_engine(&quot;sqlite:///mydatabase.db&quot;) 
 
    # reflect the tables 
    Base.prepare(autoload_with=engine) 
 
    # mapped classes are now created with names by default 
    # matching that of the table name. 
    User = Base.classes.user 
    Address = Base.classes.address 
 
    session = Session(engine) 
 
    # rudimentary relationships are produced 
    session.add(Address(email_address=&quot;foo@bar.com&quot;, user=User(name=&quot;foo&quot;))) 
    session.commit() 
 
    # collection-based relationships are by default named 
    # &quot;&lt;classname&gt;_collection&quot; 
    u1 = session.query(User).first() 
    print(u1.address_collection) 
 
Above, calling :meth:`.AutomapBase.prepare` while passing along the 
:paramref:`.AutomapBase.prepare.reflect` parameter indicates that the 
:meth:`_schema.MetaData.reflect` 
method will be called on this declarative base 
classes' :class:`_schema.MetaData` collection; then, each **viable** 
:class:`_schema.Table` within the :class:`_schema.MetaData` 
will get a new mapped class 
generated automatically.  The :class:`_schema.ForeignKeyConstraint` 
objects which 
link the various tables together will be used to produce new, bidirectional 
:func:`_orm.relationship` objects between classes. 
The classes and relationships 
follow along a default naming scheme that we can customize.  At this point, 
our basic mapping consisting of related ``User`` and ``Address`` classes is 
ready to use in the traditional way. 
 
.. note:: By **viable**, we mean that for a table to be mapped, it must 
   specify a primary key.  Additionally, if the table is detected as being 
   a pure association table between two other tables, it will not be directly 
   mapped and will instead be configured as a many-to-many table between 
   the mappings for the two referring tables. 
 
Generating Mappings from an Existing MetaData 
============================================= 
 
We can pass a pre-declared :class:`_schema.MetaData` object to 
:func:`.automap_base`. 
This object can be constructed in any way, including programmatically, from 
a serialized file, or from itself being reflected using 
:meth:`_schema.MetaData.reflect`. 
Below we illustrate a combination of reflection and 
explicit table declaration:: 
 
    from sqlalchemy import create_engine, MetaData, Table, Column, ForeignKey 
    from sqlalchemy.ext.automap import automap_base 
 
    engine = create_engine(&quot;sqlite:///mydatabase.db&quot;) 
 
    # produce our own MetaData object 
    metadata = MetaData() 
 
    # we can reflect it ourselves from a database, using options 
    # such as 'only' to limit what tables we look at... 
    metadata.reflect(engine, only=[&quot;user&quot;, &quot;address&quot;]) 
 
    # ... or just define our own Table objects with it (or combine both) 
    Table( 
        &quot;user_order&quot;, 
        metadata, 
        Column(&quot;id&quot;, Integer, primary_key=True), 
        Column(&quot;user_id&quot;, ForeignKey(&quot;user.id&quot;)), 
    ) 
 
    # we can then produce a set of mappings from this MetaData. 
    Base = automap_base(metadata=metadata) 
 
    # calling prepare() just sets up mapped classes and relationships. 
    Base.prepare() 
 
    # mapped classes are ready 
    User = Base.classes.user 
    Address = Base.classes.address 
    Order = Base.classes.user_order 
 
.. _automap_by_module: 
 
Generating Mappings from Multiple Schemas 
========================================= 
 
The :meth:`.AutomapBase.prepare` method when used with reflection may reflect 
tables from one schema at a time at most, using the 
:paramref:`.AutomapBase.prepare.schema` parameter to indicate the name of a 
schema to be reflected from. In order to populate the :class:`.AutomapBase` 
with tables from multiple schemas, :meth:`.AutomapBase.prepare` may be invoked 
multiple times, each time passing a different name to the 
:paramref:`.AutomapBase.prepare.schema` parameter. The 
:meth:`.AutomapBase.prepare` method keeps an internal list of 
:class:`_schema.Table` objects that have already been mapped, and will add new 
mappings only for those :class:`_schema.Table` objects that are new since the 
last time :meth:`.AutomapBase.prepare` was run:: 
 
    e = create_engine(&quot;postgresql://scott:tiger@localhost/test&quot;) 
 
    Base.metadata.create_all(e) 
 
    Base = automap_base() 
 
    Base.prepare(e) 
    Base.prepare(e, schema=&quot;test_schema&quot;) 
    Base.prepare(e, schema=&quot;test_schema_2&quot;) 
 
.. versionadded:: 2.0  The :meth:`.AutomapBase.prepare` method may be called 
   any number of times; only newly added tables will be mapped 
   on each run.   Previously in version 1.4 and earlier, multiple calls would 
   cause errors as it would attempt to re-map an already mapped class. 
   The previous workaround approach of invoking 
   :meth:`_schema.MetaData.reflect` directly remains available as well. 
 
Automapping same-named tables across multiple schemas 
----------------------------------------------------- 
 
For the common case where multiple schemas may have same-named tables and 
therefore would generate same-named classes, conflicts can be resolved either 
through use of the :paramref:`.AutomapBase.prepare.classname_for_table` hook to 
apply different classnames on a per-schema basis, or by using the 
:paramref:`.AutomapBase.prepare.modulename_for_table` hook, which allows 
disambiguation of same-named classes by changing their effective ``__module__`` 
attribute. In the example below, this hook is used to create a ``__module__`` 
attribute for all classes that is of the form ``mymodule.&lt;schemaname&gt;``, where 
the schema name ``default`` is used if no schema is present:: 
 
    e = create_engine(&quot;postgresql://scott:tiger@localhost/test&quot;) 
 
    Base.metadata.create_all(e) 
 
 
    def module_name_for_table(cls, tablename, table): 
        if table.schema is not None: 
            return f&quot;mymodule.{table.schema}&quot; 
        else: 
            return f&quot;mymodule.default&quot; 
 
 
    Base = automap_base() 
 
    Base.prepare(e, modulename_for_table=module_name_for_table) 
    Base.prepare(e, schema=&quot;test_schema&quot;, modulename_for_table=module_name_for_table) 
    Base.prepare(e, schema=&quot;test_schema_2&quot;, modulename_for_table=module_name_for_table) 
 
The same named-classes are organized into a hierarchical collection available 
at :attr:`.AutomapBase.by_module`.  This collection is traversed using the 
dot-separated name of a particular package/module down into the desired 
class name. 
 
.. note:: When using the :paramref:`.AutomapBase.prepare.modulename_for_table` 
   hook to return a new ``__module__`` that is not ``None``, the class is 
   **not** placed into the :attr:`.AutomapBase.classes` collection; only 
   classes that were not given an explicit modulename are placed here, as the 
   collection cannot represent same-named classes individually. 
 
In the example above, if the database contained a table named ``accounts`` in 
all three of the default schema, the ``test_schema`` schema, and the 
``test_schema_2`` schema, three separate classes will be available as:: 
 
    Base.by_module.mymodule.default.accounts 
    Base.by_module.mymodule.test_schema.accounts 
    Base.by_module.mymodule.test_schema_2.accounts 
 
The default module namespace generated for all :class:`.AutomapBase` classes is 
``sqlalchemy.ext.automap``. If no 
:paramref:`.AutomapBase.prepare.modulename_for_table` hook is used, the 
contents of :attr:`.AutomapBase.by_module` will be entirely within the 
``sqlalchemy.ext.automap`` namespace (e.g. 
``MyBase.by_module.sqlalchemy.ext.automap.&lt;classname&gt;``), which would contain 
the same series of classes as what would be seen in 
:attr:`.AutomapBase.classes`. Therefore it's generally only necessary to use 
:attr:`.AutomapBase.by_module` when explicit ``__module__`` conventions are 
present. 
 
.. versionadded: 2.0 
 
    Added the :attr:`.AutomapBase.by_module` collection, which stores 
    classes within a named hierarchy based on dot-separated module names, 
    as well as the :paramref:`.Automap.prepare.modulename_for_table` parameter 
    which allows for custom ``__module__`` schemes for automapped 
    classes. 
 
 
 
Specifying Classes Explicitly 
============================= 
 
.. tip:: If explicit classes are expected to be prominent in an application, 
   consider using :class:`.DeferredReflection` instead. 
 
The :mod:`.sqlalchemy.ext.automap` extension allows classes to be defined 
explicitly, in a way similar to that of the :class:`.DeferredReflection` class. 
Classes that extend from :class:`.AutomapBase` act like regular declarative 
classes, but are not immediately mapped after their construction, and are 
instead mapped when we call :meth:`.AutomapBase.prepare`.  The 
:meth:`.AutomapBase.prepare` method will make use of the classes we've 
established based on the table name we use.  If our schema contains tables 
``user`` and ``address``, we can define one or both of the classes to be used:: 
 
    from sqlalchemy.ext.automap import automap_base 
    from sqlalchemy import create_engine 
 
    # automap base 
    Base = automap_base() 
 
 
    # pre-declare User for the 'user' table 
    class User(Base): 
        __tablename__ = &quot;user&quot; 
 
        # override schema elements like Columns 
        user_name = Column(&quot;name&quot;, String) 
 
        # override relationships too, if desired. 
        # we must use the same name that automap would use for the 
        # relationship, and also must refer to the class name that automap will 
        # generate for &quot;address&quot; 
        address_collection = relationship(&quot;address&quot;, collection_class=set) 
 
 
    # reflect 
    engine = create_engine(&quot;sqlite:///mydatabase.db&quot;) 
    Base.prepare(autoload_with=engine) 
 
    # we still have Address generated from the tablename &quot;address&quot;, 
    # but User is the same as Base.classes.User now 
 
    Address = Base.classes.address 
 
    u1 = session.query(User).first() 
    print(u1.address_collection) 
 
    # the backref is still there: 
    a1 = session.query(Address).first() 
    print(a1.user) 
 
Above, one of the more intricate details is that we illustrated overriding 
one of the :func:`_orm.relationship` objects that automap would have created. 
To do this, we needed to make sure the names match up with what automap 
would normally generate, in that the relationship name would be 
``User.address_collection`` and the name of the class referred to, from 
automap's perspective, is called ``address``, even though we are referring to 
it as ``Address`` within our usage of this class. 
 
Overriding Naming Schemes 
========================= 
 
:mod:`.sqlalchemy.ext.automap` is tasked with producing mapped classes and 
relationship names based on a schema, which means it has decision points in how 
these names are determined.  These three decision points are provided using 
functions which can be passed to the :meth:`.AutomapBase.prepare` method, and 
are known as :func:`.classname_for_table`, 
:func:`.name_for_scalar_relationship`, 
and :func:`.name_for_collection_relationship`.  Any or all of these 
functions are provided as in the example below, where we use a &quot;camel case&quot; 
scheme for class names and a &quot;pluralizer&quot; for collection names using the 
`Inflect &lt;https://pypi.org/project/inflect&gt;`_ package:: 
 
    import re 
    import inflect 
 
 
    def camelize_classname(base, tablename, table): 
        &quot;Produce a 'camelized' class name, e.g.&quot; 
        &quot;'words_and_underscores' -&gt; 'WordsAndUnderscores'&quot; 
 
        return str( 
            tablename[0].upper() 
            + re.sub( 
                r&quot;_([a-z])&quot;, 
                lambda m: m.group(1).upper(), 
                tablename[1:], 
            ) 
        ) 
 
 
    _pluralizer = inflect.engine() 
 
 
    def pluralize_collection(base, local_cls, referred_cls, constraint): 
        &quot;Produce an 'uncamelized', 'pluralized' class name, e.g.&quot; 
        &quot;'SomeTerm' -&gt; 'some_terms'&quot; 
 
        referred_name = referred_cls.__name__ 
        uncamelized = re.sub( 
            r&quot;[A-Z]&quot;, 
            lambda m: &quot;_%s&quot; % m.group(0).lower(), 
            referred_name, 
        )[1:] 
        pluralized = _pluralizer.plural(uncamelized) 
        return pluralized 
 
 
    from sqlalchemy.ext.automap import automap_base 
 
    Base = automap_base() 
 
    engine = create_engine(&quot;sqlite:///mydatabase.db&quot;) 
 
    Base.prepare( 
        autoload_with=engine, 
        classname_for_table=camelize_classname, 
        name_for_collection_relationship=pluralize_collection, 
    ) 
 
From the above mapping, we would now have classes ``User`` and ``Address``, 
where the collection from ``User`` to ``Address`` is called 
``User.addresses``:: 
 
    User, Address = Base.classes.User, Base.classes.Address 
 
    u1 = User(addresses=[Address(email=&quot;foo@bar.com&quot;)]) 
 
Relationship Detection 
====================== 
 
The vast majority of what automap accomplishes is the generation of 
:func:`_orm.relationship` structures based on foreign keys.  The mechanism 
by which this works for many-to-one and one-to-many relationships is as 
follows: 
 
1. A given :class:`_schema.Table`, known to be mapped to a particular class, 
   is examined for :class:`_schema.ForeignKeyConstraint` objects. 
 
2. From each :class:`_schema.ForeignKeyConstraint`, the remote 
   :class:`_schema.Table` 
   object present is matched up to the class to which it is to be mapped, 
   if any, else it is skipped. 
 
3. As the :class:`_schema.ForeignKeyConstraint` 
   we are examining corresponds to a 
   reference from the immediate mapped class,  the relationship will be set up 
   as a many-to-one referring to the referred class; a corresponding 
   one-to-many backref will be created on the referred class referring 
   to this class. 
 
4. If any of the columns that are part of the 
   :class:`_schema.ForeignKeyConstraint` 
   are not nullable (e.g. ``nullable=False``), a 
   :paramref:`_orm.relationship.cascade` keyword argument 
   of ``all, delete-orphan`` will be added to the keyword arguments to 
   be passed to the relationship or backref.  If the 
   :class:`_schema.ForeignKeyConstraint` reports that 
   :paramref:`_schema.ForeignKeyConstraint.ondelete` 
   is set to ``CASCADE`` for a not null or ``SET NULL`` for a nullable 
   set of columns, the option :paramref:`_orm.relationship.passive_deletes` 
   flag is set to ``True`` in the set of relationship keyword arguments. 
   Note that not all backends support reflection of ON DELETE. 
 
5. The names of the relationships are determined using the 
   :paramref:`.AutomapBase.prepare.name_for_scalar_relationship` and 
   :paramref:`.AutomapBase.prepare.name_for_collection_relationship` 
   callable functions.  It is important to note that the default relationship 
   naming derives the name from the **the actual class name**.  If you've 
   given a particular class an explicit name by declaring it, or specified an 
   alternate class naming scheme, that's the name from which the relationship 
   name will be derived. 
 
6. The classes are inspected for an existing mapped property matching these 
   names.  If one is detected on one side, but none on the other side, 
   :class:`.AutomapBase` attempts to create a relationship on the missing side, 
   then uses the :paramref:`_orm.relationship.back_populates` 
   parameter in order to 
   point the new relationship to the other side. 
 
7. In the usual case where no relationship is on either side, 
   :meth:`.AutomapBase.prepare` produces a :func:`_orm.relationship` on the 
   &quot;many-to-one&quot; side and matches it to the other using the 
   :paramref:`_orm.relationship.backref` parameter. 
 
8. Production of the :func:`_orm.relationship` and optionally the 
   :func:`.backref` 
   is handed off to the :paramref:`.AutomapBase.prepare.generate_relationship` 
   function, which can be supplied by the end-user in order to augment 
   the arguments passed to :func:`_orm.relationship` or :func:`.backref` or to 
   make use of custom implementations of these functions. 
 
Custom Relationship Arguments 
----------------------------- 
 
The :paramref:`.AutomapBase.prepare.generate_relationship` hook can be used 
to add parameters to relationships.  For most cases, we can make use of the 
existing :func:`.automap.generate_relationship` function to return 
the object, after augmenting the given keyword dictionary with our own 
arguments. 
 
Below is an illustration of how to send 
:paramref:`_orm.relationship.cascade` and 
:paramref:`_orm.relationship.passive_deletes` 
options along to all one-to-many relationships:: 
 
    from sqlalchemy.ext.automap import generate_relationship 
    from sqlalchemy.orm import interfaces 
 
 
    def _gen_relationship( 
        base, direction, return_fn, attrname, local_cls, referred_cls, **kw 
    ): 
        if direction is interfaces.ONETOMANY: 
            kw[&quot;cascade&quot;] = &quot;all, delete-orphan&quot; 
            kw[&quot;passive_deletes&quot;] = True 
        # make use of the built-in function to actually return 
        # the result. 
        return generate_relationship( 
            base, direction, return_fn, attrname, local_cls, referred_cls, **kw 
        ) 
 
 
    from sqlalchemy.ext.automap import automap_base 
    from sqlalchemy import create_engine 
 
    # automap base 
    Base = automap_base() 
 
    engine = create_engine(&quot;sqlite:///mydatabase.db&quot;) 
    Base.prepare(autoload_with=engine, generate_relationship=_gen_relationship) 
 
Many-to-Many relationships 
-------------------------- 
 
:mod:`.sqlalchemy.ext.automap` will generate many-to-many relationships, e.g. 
those which contain a ``secondary`` argument.  The process for producing these 
is as follows: 
 
1. A given :class:`_schema.Table` is examined for 
   :class:`_schema.ForeignKeyConstraint` 
   objects, before any mapped class has been assigned to it. 
 
2. If the table contains two and exactly two 
   :class:`_schema.ForeignKeyConstraint` 
   objects, and all columns within this table are members of these two 
   :class:`_schema.ForeignKeyConstraint` objects, the table is assumed to be a 
   &quot;secondary&quot; table, and will **not be mapped directly**. 
 
3. The two (or one, for self-referential) external tables to which the 
   :class:`_schema.Table` 
   refers to are matched to the classes to which they will be 
   mapped, if any. 
 
4. If mapped classes for both sides are located, a many-to-many bi-directional 
   :func:`_orm.relationship` / :func:`.backref` 
   pair is created between the two 
   classes. 
 
5. The override logic for many-to-many works the same as that of one-to-many/ 
   many-to-one; the :func:`.generate_relationship` function is called upon 
   to generate the structures and existing attributes will be maintained. 
 
Relationships with Inheritance 
------------------------------ 
 
:mod:`.sqlalchemy.ext.automap` will not generate any relationships between 
two classes that are in an inheritance relationship.   That is, with two 
classes given as follows:: 
 
    class Employee(Base): 
        __tablename__ = &quot;employee&quot; 
        id = Column(Integer, primary_key=True) 
        type = Column(String(50)) 
        __mapper_args__ = { 
            &quot;polymorphic_identity&quot;: &quot;employee&quot;, 
            &quot;polymorphic_on&quot;: type, 
        } 
 
 
    class Engineer(Employee): 
        __tablename__ = &quot;engineer&quot; 
        id = Column(Integer, ForeignKey(&quot;employee.id&quot;), primary_key=True) 
        __mapper_args__ = { 
            &quot;polymorphic_identity&quot;: &quot;engineer&quot;, 
        } 
 
The foreign key from ``Engineer`` to ``Employee`` is used not for a 
relationship, but to establish joined inheritance between the two classes. 
 
Note that this means automap will not generate *any* relationships 
for foreign keys that link from a subclass to a superclass.  If a mapping 
has actual relationships from subclass to superclass as well, those 
need to be explicit.  Below, as we have two separate foreign keys 
from ``Engineer`` to ``Employee``, we need to set up both the relationship 
we want as well as the ``inherit_condition``, as these are not things 
SQLAlchemy can guess:: 
 
    class Employee(Base): 
        __tablename__ = &quot;employee&quot; 
        id = Column(Integer, primary_key=True) 
        type = Column(String(50)) 
 
        __mapper_args__ = { 
            &quot;polymorphic_identity&quot;: &quot;employee&quot;, 
            &quot;polymorphic_on&quot;: type, 
        } 
 
 
    class Engineer(Employee): 
        __tablename__ = &quot;engineer&quot; 
        id = Column(Integer, ForeignKey(&quot;employee.id&quot;), primary_key=True) 
        favorite_employee_id = Column(Integer, ForeignKey(&quot;employee.id&quot;)) 
 
        favorite_employee = relationship(Employee, foreign_keys=favorite_employee_id) 
 
        __mapper_args__ = { 
            &quot;polymorphic_identity&quot;: &quot;engineer&quot;, 
            &quot;inherit_condition&quot;: id == Employee.id, 
        } 
 
Handling Simple Naming Conflicts 
-------------------------------- 
 
In the case of naming conflicts during mapping, override any of 
:func:`.classname_for_table`, :func:`.name_for_scalar_relationship`, 
and :func:`.name_for_collection_relationship` as needed.  For example, if 
automap is attempting to name a many-to-one relationship the same as an 
existing column, an alternate convention can be conditionally selected.  Given 
a schema: 
 
.. sourcecode:: sql 
 
    CREATE TABLE table_a ( 
        id INTEGER PRIMARY KEY 
    ); 
 
    CREATE TABLE table_b ( 
        id INTEGER PRIMARY KEY, 
        table_a INTEGER, 
        FOREIGN KEY(table_a) REFERENCES table_a(id) 
    ); 
 
The above schema will first automap the ``table_a`` table as a class named 
``table_a``; it will then automap a relationship onto the class for ``table_b`` 
with the same name as this related class, e.g. ``table_a``.  This 
relationship name conflicts with the mapping column ``table_b.table_a``, 
and will emit an error on mapping. 
 
We can resolve this conflict by using an underscore as follows:: 
 
    def name_for_scalar_relationship(base, local_cls, referred_cls, constraint): 
        name = referred_cls.__name__.lower() 
        local_table = local_cls.__table__ 
        if name in local_table.columns: 
            newname = name + &quot;_&quot; 
            warnings.warn(&quot;Already detected name %s present.  using %s&quot; % (name, newname)) 
            return newname 
        return name 
 
 
    Base.prepare( 
        autoload_with=engine, 
        name_for_scalar_relationship=name_for_scalar_relationship, 
    ) 
 
Alternatively, we can change the name on the column side.   The columns 
that are mapped can be modified using the technique described at 
:ref:`mapper_column_distinct_names`, by assigning the column explicitly 
to a new name:: 
 
    Base = automap_base() 
 
 
    class TableB(Base): 
        __tablename__ = &quot;table_b&quot; 
        _table_a = Column(&quot;table_a&quot;, ForeignKey(&quot;table_a.id&quot;)) 
 
 
    Base.prepare(autoload_with=engine) 
 
Using Automap with Explicit Declarations 
======================================== 
 
As noted previously, automap has no dependency on reflection, and can make 
use of any collection of :class:`_schema.Table` objects within a 
:class:`_schema.MetaData` 
collection.  From this, it follows that automap can also be used 
generate missing relationships given an otherwise complete model that fully 
defines table metadata:: 
 
    from sqlalchemy.ext.automap import automap_base 
    from sqlalchemy import Column, Integer, String, ForeignKey 
 
    Base = automap_base() 
 
 
    class User(Base): 
        __tablename__ = &quot;user&quot; 
 
        id = Column(Integer, primary_key=True) 
        name = Column(String) 
 
 
    class Address(Base): 
        __tablename__ = &quot;address&quot; 
 
        id = Column(Integer, primary_key=True) 
        email = Column(String) 
        user_id = Column(ForeignKey(&quot;user.id&quot;)) 
 
 
    # produce relationships 
    Base.prepare() 
 
    # mapping is complete, with &quot;address_collection&quot; and 
    # &quot;user&quot; relationships 
    a1 = Address(email=&quot;u1&quot;) 
    a2 = Address(email=&quot;u2&quot;) 
    u1 = User(address_collection=[a1, a2]) 
    assert a1.user is u1 
 
Above, given mostly complete ``User`` and ``Address`` mappings, the 
:class:`_schema.ForeignKey` which we defined on ``Address.user_id`` allowed a 
bidirectional relationship pair ``Address.user`` and 
``User.address_collection`` to be generated on the mapped classes. 
 
Note that when subclassing :class:`.AutomapBase`, 
the :meth:`.AutomapBase.prepare` method is required; if not called, the classes 
we've declared are in an un-mapped state. 
 
 
.. _automap_intercepting_columns: 
 
Intercepting Column Definitions 
=============================== 
 
The :class:`_schema.MetaData` and :class:`_schema.Table` objects support an 
event hook :meth:`_events.DDLEvents.column_reflect` that may be used to intercept 
the information reflected about a database column before the :class:`_schema.Column` 
object is constructed.   For example if we wanted to map columns using a 
naming convention such as ``&quot;attr_&lt;columnname&gt;&quot;``, the event could 
be applied as:: 
 
    @event.listens_for(Base.metadata, &quot;column_reflect&quot;) 
    def column_reflect(inspector, table, column_info): 
        # set column.key = &quot;attr_&lt;lower_case_name&gt;&quot; 
        column_info[&quot;key&quot;] = &quot;attr_%s&quot; % column_info[&quot;name&quot;].lower() 
 
 
    # run reflection 
    Base.prepare(autoload_with=engine) 
 
.. versionadded:: 1.4.0b2 the :meth:`_events.DDLEvents.column_reflect` event 
   may be applied to a :class:`_schema.MetaData` object. 
 
.. seealso:: 
 
      :meth:`_events.DDLEvents.column_reflect` 
 
      :ref:`mapper_automated_reflection_schemes` - in the ORM mapping documentation 
 
 
&quot;&quot;&quot;  </span><span class="s0"># noqa</span>
<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">import </span><span class="s1">dataclasses</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">ClassVar</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Dict</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">NoReturn</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">overload</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Set</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Tuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Type</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TypeVar</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>

<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">orm </span><span class="s3">import </span><span class="s1">backref</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">orm </span><span class="s3">import </span><span class="s1">declarative_base </span><span class="s3">as </span><span class="s1">_declarative_base</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">orm </span><span class="s3">import </span><span class="s1">exc </span><span class="s3">as </span><span class="s1">orm_exc</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">orm </span><span class="s3">import </span><span class="s1">interfaces</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">orm </span><span class="s3">import </span><span class="s1">relationship</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">orm</span><span class="s4">.</span><span class="s1">decl_base </span><span class="s3">import </span><span class="s1">_DeferredMapperConfig</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">orm</span><span class="s4">.</span><span class="s1">mapper </span><span class="s3">import </span><span class="s1">_CONFIGURE_MUTEX</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">ForeignKeyConstraint</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">and_</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util </span><span class="s3">import </span><span class="s1">Properties</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Protocol</span>

<span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">Engine</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">orm</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">RelationshipDirection</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">orm</span><span class="s4">.</span><span class="s1">relationships </span><span class="s3">import </span><span class="s1">ORMBackrefArgument</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">orm</span><span class="s4">.</span><span class="s1">relationships </span><span class="s3">import </span><span class="s1">Relationship</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">Column</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">MetaData</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">Table</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">util </span><span class="s3">import </span><span class="s1">immutabledict</span>


<span class="s1">_KT </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s2">&quot;_KT&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s1">Any</span><span class="s4">)</span>
<span class="s1">_VT </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s2">&quot;_VT&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s1">Any</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">PythonNameForTableType</span><span class="s4">(</span><span class="s1">Protocol</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">base</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">tablename</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">table</span><span class="s4">: </span><span class="s1">Table</span>
    <span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">: ...</span>


<span class="s3">def </span><span class="s1">classname_for_table</span><span class="s4">(</span>
    <span class="s1">base</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">tablename</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
    <span class="s1">table</span><span class="s4">: </span><span class="s1">Table</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
    <span class="s5">&quot;&quot;&quot;Return the class name that should be used, given the name 
    of a table. 
 
    The default implementation is:: 
 
        return str(tablename) 
 
    Alternate implementations can be specified using the 
    :paramref:`.AutomapBase.prepare.classname_for_table` 
    parameter. 
 
    :param base: the :class:`.AutomapBase` class doing the prepare. 
 
    :param tablename: string name of the :class:`_schema.Table`. 
 
    :param table: the :class:`_schema.Table` object itself. 
 
    :return: a string class name. 
 
     .. note:: 
 
        In Python 2, the string used for the class name **must** be a 
        non-Unicode object, e.g. a ``str()`` object.  The ``.name`` attribute 
        of :class:`_schema.Table` is typically a Python unicode subclass, 
        so the 
        ``str()`` function should be applied to this name, after accounting for 
        any non-ASCII characters. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">str</span><span class="s4">(</span><span class="s1">tablename</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">NameForScalarRelationshipType</span><span class="s4">(</span><span class="s1">Protocol</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">base</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">local_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">referred_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">constraint</span><span class="s4">: </span><span class="s1">ForeignKeyConstraint</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">: ...</span>


<span class="s3">def </span><span class="s1">name_for_scalar_relationship</span><span class="s4">(</span>
    <span class="s1">base</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">local_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">referred_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">constraint</span><span class="s4">: </span><span class="s1">ForeignKeyConstraint</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
    <span class="s5">&quot;&quot;&quot;Return the attribute name that should be used to refer from one 
    class to another, for a scalar object reference. 
 
    The default implementation is:: 
 
        return referred_cls.__name__.lower() 
 
    Alternate implementations can be specified using the 
    :paramref:`.AutomapBase.prepare.name_for_scalar_relationship` 
    parameter. 
 
    :param base: the :class:`.AutomapBase` class doing the prepare. 
 
    :param local_cls: the class to be mapped on the local side. 
 
    :param referred_cls: the class to be mapped on the referring side. 
 
    :param constraint: the :class:`_schema.ForeignKeyConstraint` that is being 
     inspected to produce this relationship. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">referred_cls</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">()</span>


<span class="s3">class </span><span class="s1">NameForCollectionRelationshipType</span><span class="s4">(</span><span class="s1">Protocol</span><span class="s4">):</span>
    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">base</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">local_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">referred_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">constraint</span><span class="s4">: </span><span class="s1">ForeignKeyConstraint</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">: ...</span>


<span class="s3">def </span><span class="s1">name_for_collection_relationship</span><span class="s4">(</span>
    <span class="s1">base</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">local_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">referred_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">constraint</span><span class="s4">: </span><span class="s1">ForeignKeyConstraint</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
    <span class="s5">&quot;&quot;&quot;Return the attribute name that should be used to refer from one 
    class to another, for a collection reference. 
 
    The default implementation is:: 
 
        return referred_cls.__name__.lower() + &quot;_collection&quot; 
 
    Alternate implementations 
    can be specified using the 
    :paramref:`.AutomapBase.prepare.name_for_collection_relationship` 
    parameter. 
 
    :param base: the :class:`.AutomapBase` class doing the prepare. 
 
    :param local_cls: the class to be mapped on the local side. 
 
    :param referred_cls: the class to be mapped on the referring side. 
 
    :param constraint: the :class:`_schema.ForeignKeyConstraint` that is being 
     inspected to produce this relationship. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">referred_cls</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">() + </span><span class="s2">&quot;_collection&quot;</span>


<span class="s3">class </span><span class="s1">GenerateRelationshipType</span><span class="s4">(</span><span class="s1">Protocol</span><span class="s4">):</span>
    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">base</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">direction</span><span class="s4">: </span><span class="s1">RelationshipDirection</span><span class="s4">,</span>
        <span class="s1">return_fn</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Relationship</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
        <span class="s1">attrname</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">local_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">referred_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Relationship</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">base</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">direction</span><span class="s4">: </span><span class="s1">RelationshipDirection</span><span class="s4">,</span>
        <span class="s1">return_fn</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">ORMBackrefArgument</span><span class="s4">],</span>
        <span class="s1">attrname</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">local_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">referred_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ORMBackrefArgument</span><span class="s4">: ...</span>

    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">base</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">direction</span><span class="s4">: </span><span class="s1">RelationshipDirection</span><span class="s4">,</span>
        <span class="s1">return_fn</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
            <span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Relationship</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]], </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">ORMBackrefArgument</span><span class="s4">]</span>
        <span class="s4">],</span>
        <span class="s1">attrname</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">local_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">referred_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">ORMBackrefArgument</span><span class="s4">, </span><span class="s1">Relationship</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]: ...</span>


<span class="s4">@</span><span class="s1">overload</span>
<span class="s3">def </span><span class="s1">generate_relationship</span><span class="s4">(</span>
    <span class="s1">base</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">direction</span><span class="s4">: </span><span class="s1">RelationshipDirection</span><span class="s4">,</span>
    <span class="s1">return_fn</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Relationship</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
    <span class="s1">attrname</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
    <span class="s1">local_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">referred_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; Relationship</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>


<span class="s4">@</span><span class="s1">overload</span>
<span class="s3">def </span><span class="s1">generate_relationship</span><span class="s4">(</span>
    <span class="s1">base</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">direction</span><span class="s4">: </span><span class="s1">RelationshipDirection</span><span class="s4">,</span>
    <span class="s1">return_fn</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">ORMBackrefArgument</span><span class="s4">],</span>
    <span class="s1">attrname</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
    <span class="s1">local_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">referred_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; ORMBackrefArgument</span><span class="s4">: ...</span>


<span class="s3">def </span><span class="s1">generate_relationship</span><span class="s4">(</span>
    <span class="s1">base</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">direction</span><span class="s4">: </span><span class="s1">RelationshipDirection</span><span class="s4">,</span>
    <span class="s1">return_fn</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
        <span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Relationship</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]], </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">ORMBackrefArgument</span><span class="s4">]</span>
    <span class="s4">],</span>
    <span class="s1">attrname</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
    <span class="s1">local_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">referred_cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">Relationship</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">ORMBackrefArgument</span><span class="s4">]:</span>
    <span class="s5">r&quot;&quot;&quot;Generate a :func:`_orm.relationship` or :func:`.backref` 
    on behalf of two 
    mapped classes. 
 
    An alternate implementation of this function can be specified using the 
    :paramref:`.AutomapBase.prepare.generate_relationship` parameter. 
 
    The default implementation of this function is as follows:: 
 
        if return_fn is backref: 
            return return_fn(attrname, **kw) 
        elif return_fn is relationship: 
            return return_fn(referred_cls, **kw) 
        else: 
            raise TypeError(&quot;Unknown relationship function: %s&quot; % return_fn) 
 
    :param base: the :class:`.AutomapBase` class doing the prepare. 
 
    :param direction: indicate the &quot;direction&quot; of the relationship; this will 
     be one of :data:`.ONETOMANY`, :data:`.MANYTOONE`, :data:`.MANYTOMANY`. 
 
    :param return_fn: the function that is used by default to create the 
     relationship.  This will be either :func:`_orm.relationship` or 
     :func:`.backref`.  The :func:`.backref` function's result will be used to 
     produce a new :func:`_orm.relationship` in a second step, 
     so it is critical 
     that user-defined implementations correctly differentiate between the two 
     functions, if a custom relationship function is being used. 
 
    :param attrname: the attribute name to which this relationship is being 
     assigned. If the value of :paramref:`.generate_relationship.return_fn` is 
     the :func:`.backref` function, then this name is the name that is being 
     assigned to the backref. 
 
    :param local_cls: the &quot;local&quot; class to which this relationship or backref 
     will be locally present. 
 
    :param referred_cls: the &quot;referred&quot; class to which the relationship or 
     backref refers to. 
 
    :param \**kw: all additional keyword arguments are passed along to the 
     function. 
 
    :return: a :func:`_orm.relationship` or :func:`.backref` construct, 
     as dictated 
     by the :paramref:`.generate_relationship.return_fn` parameter. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">return_fn </span><span class="s3">is </span><span class="s1">backref</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">return_fn</span><span class="s4">(</span><span class="s1">attrname</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">return_fn </span><span class="s3">is </span><span class="s1">relationship</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">return_fn</span><span class="s4">(</span><span class="s1">referred_cls</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s2">&quot;Unknown relationship function: %s&quot; </span><span class="s4">% </span><span class="s1">return_fn</span><span class="s4">)</span>


<span class="s1">ByModuleProperties </span><span class="s4">= </span><span class="s1">Properties</span><span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s2">&quot;ByModuleProperties&quot;</span><span class="s4">, </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]]</span>


<span class="s3">class </span><span class="s1">AutomapBase</span><span class="s4">:</span>
    <span class="s5">&quot;&quot;&quot;Base class for an &quot;automap&quot; schema. 
 
    The :class:`.AutomapBase` class can be compared to the &quot;declarative base&quot; 
    class that is produced by the :func:`.declarative.declarative_base` 
    function.  In practice, the :class:`.AutomapBase` class is always used 
    as a mixin along with an actual declarative base. 
 
    A new subclassable :class:`.AutomapBase` is typically instantiated 
    using the :func:`.automap_base` function. 
 
    .. seealso:: 
 
        :ref:`automap_toplevel` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__abstract__ </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">classes</span><span class="s4">: </span><span class="s1">ClassVar</span><span class="s4">[</span><span class="s1">Properties</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]]</span>
    <span class="s2">&quot;&quot;&quot;An instance of :class:`.util.Properties` containing classes. 
 
    This object behaves much like the ``.c`` collection on a table.  Classes 
    are present under the name they were given, e.g.:: 
 
        Base = automap_base() 
        Base.prepare(autoload_with=some_engine) 
 
        User, Address = Base.classes.User, Base.classes.Address 
 
    For class names that overlap with a method name of 
    :class:`.util.Properties`, such as ``items()``, the getitem form 
    is also supported:: 
 
        Item = Base.classes[&quot;items&quot;] 
 
    &quot;&quot;&quot;</span>

    <span class="s1">by_module</span><span class="s4">: </span><span class="s1">ClassVar</span><span class="s4">[</span><span class="s1">ByModuleProperties</span><span class="s4">]</span>
    <span class="s2">&quot;&quot;&quot;An instance of :class:`.util.Properties` containing a hierarchal 
    structure of dot-separated module names linked to classes. 
 
    This collection is an alternative to the :attr:`.AutomapBase.classes` 
    collection that is useful when making use of the 
    :paramref:`.AutomapBase.prepare.modulename_for_table` parameter, which will 
    apply distinct ``__module__`` attributes to generated classes. 
 
    The default ``__module__`` an automap-generated class is 
    ``sqlalchemy.ext.automap``; to access this namespace using 
    :attr:`.AutomapBase.by_module` looks like:: 
 
        User = Base.by_module.sqlalchemy.ext.automap.User 
 
    If a class had a ``__module__`` of ``mymodule.account``, accessing 
    this namespace looks like:: 
 
        MyClass = Base.by_module.mymodule.account.MyClass 
 
    .. versionadded:: 2.0 
 
    .. seealso:: 
 
        :ref:`automap_by_module` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">metadata</span><span class="s4">: </span><span class="s1">ClassVar</span><span class="s4">[</span><span class="s1">MetaData</span><span class="s4">]</span>
    <span class="s2">&quot;&quot;&quot;Refers to the :class:`_schema.MetaData` collection that will be used 
    for new :class:`_schema.Table` objects. 
 
    .. seealso:: 
 
        :ref:`orm_declarative_metadata` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_sa_automapbase_bookkeeping</span><span class="s4">: </span><span class="s1">ClassVar</span><span class="s4">[</span><span class="s1">_Bookkeeping</span><span class="s4">]</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">deprecated_params</span><span class="s4">(</span>
        <span class="s1">engine</span><span class="s4">=(</span>
            <span class="s2">&quot;2.0&quot;</span><span class="s4">,</span>
            <span class="s2">&quot;The :paramref:`_automap.AutomapBase.prepare.engine` parameter &quot;</span>
            <span class="s2">&quot;is deprecated and will be removed in a future release.  &quot;</span>
            <span class="s2">&quot;Please use the &quot;</span>
            <span class="s2">&quot;:paramref:`_automap.AutomapBase.prepare.autoload_with` &quot;</span>
            <span class="s2">&quot;parameter.&quot;</span><span class="s4">,</span>
        <span class="s4">),</span>
        <span class="s1">reflect</span><span class="s4">=(</span>
            <span class="s2">&quot;2.0&quot;</span><span class="s4">,</span>
            <span class="s2">&quot;The :paramref:`_automap.AutomapBase.prepare.reflect` &quot;</span>
            <span class="s2">&quot;parameter is deprecated and will be removed in a future &quot;</span>
            <span class="s2">&quot;release.  Reflection is enabled when &quot;</span>
            <span class="s2">&quot;:paramref:`_automap.AutomapBase.prepare.autoload_with` &quot;</span>
            <span class="s2">&quot;is passed.&quot;</span><span class="s4">,</span>
        <span class="s4">),</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">prepare</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">AutomapBase</span><span class="s4">],</span>
        <span class="s1">autoload_with</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Engine</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">engine</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">reflect</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">classname_for_table</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">PythonNameForTableType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">modulename_for_table</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">PythonNameForTableType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">collection_class</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">name_for_scalar_relationship</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span>
            <span class="s1">NameForScalarRelationshipType</span>
        <span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">name_for_collection_relationship</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span>
            <span class="s1">NameForCollectionRelationshipType</span>
        <span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">generate_relationship</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">GenerateRelationshipType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">reflection_options</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
            <span class="s1">Dict</span><span class="s4">[</span><span class="s1">_KT</span><span class="s4">, </span><span class="s1">_VT</span><span class="s4">], </span><span class="s1">immutabledict</span><span class="s4">[</span><span class="s1">_KT</span><span class="s4">, </span><span class="s1">_VT</span><span class="s4">]</span>
        <span class="s4">] = </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s5">&quot;&quot;&quot;Extract mapped classes and relationships from the 
        :class:`_schema.MetaData` and perform mappings. 
 
        For full documentation and examples see 
        :ref:`automap_basic_use`. 
 
        :param autoload_with: an :class:`_engine.Engine` or 
         :class:`_engine.Connection` with which 
         to perform schema reflection; when specified, the 
         :meth:`_schema.MetaData.reflect` method will be invoked within 
         the scope of this method. 
 
        :param engine: legacy; use :paramref:`.AutomapBase.autoload_with`. 
         Used to indicate the :class:`_engine.Engine` or 
         :class:`_engine.Connection` with which to reflect tables with, 
         if :paramref:`.AutomapBase.reflect` is True. 
 
        :param reflect: legacy; use :paramref:`.AutomapBase.autoload_with`. 
         Indicates that :meth:`_schema.MetaData.reflect` should be invoked. 
 
        :param classname_for_table: callable function which will be used to 
         produce new class names, given a table name.  Defaults to 
         :func:`.classname_for_table`. 
 
        :param modulename_for_table: callable function which will be used to 
         produce the effective ``__module__`` for an internally generated 
         class, to allow for multiple classes of the same name in a single 
         automap base which would be in different &quot;modules&quot;. 
 
         Defaults to ``None``, which will indicate that ``__module__`` will not 
         be set explicitly; the Python runtime will use the value 
         ``sqlalchemy.ext.automap`` for these classes. 
 
         When assigning ``__module__`` to generated classes, they can be 
         accessed based on dot-separated module names using the 
         :attr:`.AutomapBase.by_module` collection.   Classes that have 
         an explicit ``__module_`` assigned using this hook do **not** get 
         placed into the :attr:`.AutomapBase.classes` collection, only 
         into :attr:`.AutomapBase.by_module`. 
 
         .. versionadded:: 2.0 
 
         .. seealso:: 
 
            :ref:`automap_by_module` 
 
        :param name_for_scalar_relationship: callable function which will be 
         used to produce relationship names for scalar relationships.  Defaults 
         to :func:`.name_for_scalar_relationship`. 
 
        :param name_for_collection_relationship: callable function which will 
         be used to produce relationship names for collection-oriented 
         relationships.  Defaults to :func:`.name_for_collection_relationship`. 
 
        :param generate_relationship: callable function which will be used to 
         actually generate :func:`_orm.relationship` and :func:`.backref` 
         constructs.  Defaults to :func:`.generate_relationship`. 
 
        :param collection_class: the Python collection class that will be used 
         when a new :func:`_orm.relationship` 
         object is created that represents a 
         collection.  Defaults to ``list``. 
 
        :param schema: Schema name to reflect when reflecting tables using 
         the :paramref:`.AutomapBase.prepare.autoload_with` parameter. The name 
         is passed to the :paramref:`_schema.MetaData.reflect.schema` parameter 
         of :meth:`_schema.MetaData.reflect`. When omitted, the default schema 
         in use by the database connection is used. 
 
         .. note:: The :paramref:`.AutomapBase.prepare.schema` 
            parameter supports reflection of a single schema at a time. 
            In order to include tables from many schemas, use 
            multiple calls to :meth:`.AutomapBase.prepare`. 
 
            For an overview of multiple-schema automap including the use 
            of additional naming conventions to resolve table name 
            conflicts, see the section :ref:`automap_by_module`. 
 
            .. versionadded:: 2.0 :meth:`.AutomapBase.prepare` supports being 
               directly invoked any number of times, keeping track of tables 
               that have already been processed to avoid processing them 
               a second time. 
 
        :param reflection_options: When present, this dictionary of options 
         will be passed to :meth:`_schema.MetaData.reflect` 
         to supply general reflection-specific options like ``only`` and/or 
         dialect-specific options like ``oracle_resolve_synonyms``. 
 
         .. versionadded:: 1.4 
 
        &quot;&quot;&quot;</span>

        <span class="s3">for </span><span class="s1">mr </span><span class="s3">in </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__mro__</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s2">&quot;_sa_automapbase_bookkeeping&quot; </span><span class="s3">in </span><span class="s1">mr</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">:</span>
                <span class="s1">automap_base </span><span class="s4">= </span><span class="s1">cast</span><span class="s4">(</span><span class="s2">&quot;Type[AutomapBase]&quot;</span><span class="s4">, </span><span class="s1">mr</span><span class="s4">)</span>
                <span class="s3">break</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">assert False</span><span class="s4">, </span><span class="s2">&quot;Can't locate automap base in class hierarchy&quot;</span>

        <span class="s1">glbls </span><span class="s4">= </span><span class="s1">globals</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">classname_for_table </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">classname_for_table </span><span class="s4">= </span><span class="s1">glbls</span><span class="s4">[</span><span class="s2">&quot;classname_for_table&quot;</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">name_for_scalar_relationship </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">name_for_scalar_relationship </span><span class="s4">= </span><span class="s1">glbls</span><span class="s4">[</span>
                <span class="s2">&quot;name_for_scalar_relationship&quot;</span>
            <span class="s4">]</span>
        <span class="s3">if </span><span class="s1">name_for_collection_relationship </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">name_for_collection_relationship </span><span class="s4">= </span><span class="s1">glbls</span><span class="s4">[</span>
                <span class="s2">&quot;name_for_collection_relationship&quot;</span>
            <span class="s4">]</span>
        <span class="s3">if </span><span class="s1">generate_relationship </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">generate_relationship </span><span class="s4">= </span><span class="s1">glbls</span><span class="s4">[</span><span class="s2">&quot;generate_relationship&quot;</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">collection_class </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">collection_class </span><span class="s4">= </span><span class="s1">list</span>

        <span class="s3">if </span><span class="s1">autoload_with</span><span class="s4">:</span>
            <span class="s1">reflect </span><span class="s4">= </span><span class="s3">True</span>

        <span class="s3">if </span><span class="s1">engine</span><span class="s4">:</span>
            <span class="s1">autoload_with </span><span class="s4">= </span><span class="s1">engine</span>

        <span class="s3">if </span><span class="s1">reflect</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">autoload_with</span>
            <span class="s1">opts </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span>
                <span class="s1">schema</span><span class="s4">=</span><span class="s1">schema</span><span class="s4">,</span>
                <span class="s1">extend_existing</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                <span class="s1">autoload_replace</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s3">if </span><span class="s1">reflection_options</span><span class="s4">:</span>
                <span class="s1">opts</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">reflection_options</span><span class="s4">)</span>
            <span class="s1">cls</span><span class="s4">.</span><span class="s1">metadata</span><span class="s4">.</span><span class="s1">reflect</span><span class="s4">(</span><span class="s1">autoload_with</span><span class="s4">, **</span><span class="s1">opts</span><span class="s4">)  </span><span class="s0"># type: ignore[arg-type]  # noqa: E501</span>

        <span class="s3">with </span><span class="s1">_CONFIGURE_MUTEX</span><span class="s4">:</span>
            <span class="s1">table_to_map_config</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
                <span class="s1">Dict</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Table</span><span class="s4">], </span><span class="s1">_DeferredMapperConfig</span><span class="s4">],</span>
                <span class="s1">Dict</span><span class="s4">[</span><span class="s1">Table</span><span class="s4">, </span><span class="s1">_DeferredMapperConfig</span><span class="s4">],</span>
            <span class="s4">] = {</span>
                <span class="s1">cast</span><span class="s4">(</span><span class="s2">&quot;Table&quot;</span><span class="s4">, </span><span class="s1">m</span><span class="s4">.</span><span class="s1">local_table</span><span class="s4">): </span><span class="s1">m</span>
                <span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">_DeferredMapperConfig</span><span class="s4">.</span><span class="s1">classes_for_base</span><span class="s4">(</span>
                    <span class="s1">cls</span><span class="s4">, </span><span class="s1">sort</span><span class="s4">=</span><span class="s3">False</span>
                <span class="s4">)</span>
            <span class="s4">}</span>

            <span class="s1">many_to_many</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span>
                <span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Table</span><span class="s4">, </span><span class="s1">Table</span><span class="s4">, </span><span class="s1">List</span><span class="s4">[</span><span class="s1">ForeignKeyConstraint</span><span class="s4">], </span><span class="s1">Table</span><span class="s4">]</span>
            <span class="s4">]</span>
            <span class="s1">many_to_many </span><span class="s4">= []</span>

            <span class="s1">bookkeeping </span><span class="s4">= </span><span class="s1">automap_base</span><span class="s4">.</span><span class="s1">_sa_automapbase_bookkeeping</span>
            <span class="s1">metadata_tables </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">metadata</span><span class="s4">.</span><span class="s1">tables</span>

            <span class="s3">for </span><span class="s1">table_key </span><span class="s3">in </span><span class="s1">set</span><span class="s4">(</span><span class="s1">metadata_tables</span><span class="s4">).</span><span class="s1">difference</span><span class="s4">(</span>
                <span class="s1">bookkeeping</span><span class="s4">.</span><span class="s1">table_keys</span>
            <span class="s4">):</span>
                <span class="s1">table </span><span class="s4">= </span><span class="s1">metadata_tables</span><span class="s4">[</span><span class="s1">table_key</span><span class="s4">]</span>
                <span class="s1">bookkeeping</span><span class="s4">.</span><span class="s1">table_keys</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">table_key</span><span class="s4">)</span>

                <span class="s1">lcl_m2m</span><span class="s4">, </span><span class="s1">rem_m2m</span><span class="s4">, </span><span class="s1">m2m_const </span><span class="s4">= </span><span class="s1">_is_many_to_many</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">table</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">lcl_m2m </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s3">assert </span><span class="s1">rem_m2m </span><span class="s3">is not None</span>
                    <span class="s3">assert </span><span class="s1">m2m_const </span><span class="s3">is not None</span>
                    <span class="s1">many_to_many</span><span class="s4">.</span><span class="s1">append</span><span class="s4">((</span><span class="s1">lcl_m2m</span><span class="s4">, </span><span class="s1">rem_m2m</span><span class="s4">, </span><span class="s1">m2m_const</span><span class="s4">, </span><span class="s1">table</span><span class="s4">))</span>
                <span class="s3">elif not </span><span class="s1">table</span><span class="s4">.</span><span class="s1">primary_key</span><span class="s4">:</span>
                    <span class="s3">continue</span>
                <span class="s3">elif </span><span class="s1">table </span><span class="s3">not in </span><span class="s1">table_to_map_config</span><span class="s4">:</span>
                    <span class="s1">clsdict</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">] = {</span><span class="s2">&quot;__table__&quot;</span><span class="s4">: </span><span class="s1">table</span><span class="s4">}</span>
                    <span class="s3">if </span><span class="s1">modulename_for_table </span><span class="s3">is not None</span><span class="s4">:</span>
                        <span class="s1">new_module </span><span class="s4">= </span><span class="s1">modulename_for_table</span><span class="s4">(</span>
                            <span class="s1">cls</span><span class="s4">, </span><span class="s1">table</span><span class="s4">.</span><span class="s1">name</span><span class="s4">, </span><span class="s1">table</span>
                        <span class="s4">)</span>
                        <span class="s3">if </span><span class="s1">new_module </span><span class="s3">is not None</span><span class="s4">:</span>
                            <span class="s1">clsdict</span><span class="s4">[</span><span class="s2">&quot;__module__&quot;</span><span class="s4">] = </span><span class="s1">new_module</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">new_module </span><span class="s4">= </span><span class="s3">None</span>

                    <span class="s1">newname </span><span class="s4">= </span><span class="s1">classname_for_table</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">table</span><span class="s4">.</span><span class="s1">name</span><span class="s4">, </span><span class="s1">table</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">new_module </span><span class="s3">is None and </span><span class="s1">newname </span><span class="s3">in </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">classes</span><span class="s4">:</span>
                        <span class="s1">util</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                            <span class="s2">&quot;Ignoring duplicate class name &quot;</span>
                            <span class="s2">f&quot;'</span><span class="s3">{</span><span class="s1">newname</span><span class="s3">}</span><span class="s2">' &quot;</span>
                            <span class="s2">&quot;received in automap base for table &quot;</span>
                            <span class="s2">f&quot;</span><span class="s3">{</span><span class="s1">table</span><span class="s4">.</span><span class="s1">key</span><span class="s3">} </span><span class="s2">without &quot;</span>
                            <span class="s2">&quot;``__module__`` being set; consider using the &quot;</span>
                            <span class="s2">&quot;``modulename_for_table`` hook&quot;</span>
                        <span class="s4">)</span>
                        <span class="s3">continue</span>

                    <span class="s1">mapped_cls </span><span class="s4">= </span><span class="s1">type</span><span class="s4">(</span>
                        <span class="s1">newname</span><span class="s4">,</span>
                        <span class="s4">(</span><span class="s1">automap_base</span><span class="s4">,),</span>
                        <span class="s1">clsdict</span><span class="s4">,</span>
                    <span class="s4">)</span>
                    <span class="s1">map_config </span><span class="s4">= </span><span class="s1">_DeferredMapperConfig</span><span class="s4">.</span><span class="s1">config_for_cls</span><span class="s4">(</span>
                        <span class="s1">mapped_cls</span>
                    <span class="s4">)</span>
                    <span class="s3">assert </span><span class="s1">map_config</span><span class="s4">.</span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__name__ </span><span class="s4">== </span><span class="s1">newname</span>
                    <span class="s3">if </span><span class="s1">new_module </span><span class="s3">is None</span><span class="s4">:</span>
                        <span class="s1">cls</span><span class="s4">.</span><span class="s1">classes</span><span class="s4">[</span><span class="s1">newname</span><span class="s4">] = </span><span class="s1">mapped_cls</span>

                    <span class="s1">by_module_properties</span><span class="s4">: </span><span class="s1">ByModuleProperties </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">by_module</span>
                    <span class="s3">for </span><span class="s1">token </span><span class="s3">in </span><span class="s1">map_config</span><span class="s4">.</span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__module__</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s2">&quot;.&quot;</span><span class="s4">):</span>
                        <span class="s3">if </span><span class="s1">token </span><span class="s3">not in </span><span class="s1">by_module_properties</span><span class="s4">:</span>
                            <span class="s1">by_module_properties</span><span class="s4">[</span><span class="s1">token</span><span class="s4">] = </span><span class="s1">util</span><span class="s4">.</span><span class="s1">Properties</span><span class="s4">({})</span>

                        <span class="s1">props </span><span class="s4">= </span><span class="s1">by_module_properties</span><span class="s4">[</span><span class="s1">token</span><span class="s4">]</span>

                        <span class="s0"># we can assert this because the clsregistry</span>
                        <span class="s0"># module would have raised if there was a mismatch</span>
                        <span class="s0"># between modules/classes already.</span>
                        <span class="s0"># see test_cls_schema_name_conflict</span>
                        <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">props</span><span class="s4">, </span><span class="s1">Properties</span><span class="s4">)</span>
                        <span class="s1">by_module_properties </span><span class="s4">= </span><span class="s1">props</span>

                    <span class="s1">by_module_properties</span><span class="s4">[</span><span class="s1">map_config</span><span class="s4">.</span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">] = </span><span class="s1">mapped_cls</span>

                    <span class="s1">table_to_map_config</span><span class="s4">[</span><span class="s1">table</span><span class="s4">] = </span><span class="s1">map_config</span>

            <span class="s3">for </span><span class="s1">map_config </span><span class="s3">in </span><span class="s1">table_to_map_config</span><span class="s4">.</span><span class="s1">values</span><span class="s4">():</span>
                <span class="s1">_relationships_for_fks</span><span class="s4">(</span>
                    <span class="s1">automap_base</span><span class="s4">,</span>
                    <span class="s1">map_config</span><span class="s4">,</span>
                    <span class="s1">table_to_map_config</span><span class="s4">,</span>
                    <span class="s1">collection_class</span><span class="s4">,</span>
                    <span class="s1">name_for_scalar_relationship</span><span class="s4">,</span>
                    <span class="s1">name_for_collection_relationship</span><span class="s4">,</span>
                    <span class="s1">generate_relationship</span><span class="s4">,</span>
                <span class="s4">)</span>

            <span class="s3">for </span><span class="s1">lcl_m2m</span><span class="s4">, </span><span class="s1">rem_m2m</span><span class="s4">, </span><span class="s1">m2m_const</span><span class="s4">, </span><span class="s1">table </span><span class="s3">in </span><span class="s1">many_to_many</span><span class="s4">:</span>
                <span class="s1">_m2m_relationship</span><span class="s4">(</span>
                    <span class="s1">automap_base</span><span class="s4">,</span>
                    <span class="s1">lcl_m2m</span><span class="s4">,</span>
                    <span class="s1">rem_m2m</span><span class="s4">,</span>
                    <span class="s1">m2m_const</span><span class="s4">,</span>
                    <span class="s1">table</span><span class="s4">,</span>
                    <span class="s1">table_to_map_config</span><span class="s4">,</span>
                    <span class="s1">collection_class</span><span class="s4">,</span>
                    <span class="s1">name_for_scalar_relationship</span><span class="s4">,</span>
                    <span class="s1">name_for_collection_relationship</span><span class="s4">,</span>
                    <span class="s1">generate_relationship</span><span class="s4">,</span>
                <span class="s4">)</span>

            <span class="s3">for </span><span class="s1">map_config </span><span class="s3">in </span><span class="s1">_DeferredMapperConfig</span><span class="s4">.</span><span class="s1">classes_for_base</span><span class="s4">(</span>
                <span class="s1">automap_base</span>
            <span class="s4">):</span>
                <span class="s1">map_config</span><span class="s4">.</span><span class="s1">map</span><span class="s4">()</span>

    <span class="s1">_sa_decl_prepare </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s2">&quot;&quot;&quot;Indicate that the mapping of classes should be deferred. 
 
    The presence of this attribute name indicates to declarative 
    that the call to mapper() should not occur immediately; instead, 
    information about the table and attributes to be mapped are gathered 
    into an internal structure called _DeferredMapperConfig.  These 
    objects can be collected later using classes_for_base(), additional 
    mapping decisions can be made, and then the map() method will actually 
    apply the mapping. 
 
    The only real reason this deferral of the whole 
    thing is needed is to support primary key columns that aren't reflected 
    yet when the class is declared; everything else can theoretically be 
    added to the mapper later.  However, the _DeferredMapperConfig is a 
    nice interface in any case which exists at that not usually exposed point 
    at which declarative has the class and the Table but hasn't called 
    mapper() yet. 
 
    &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_sa_raise_deferred_config</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">) </span><span class="s1">-&gt; NoReturn</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">orm_exc</span><span class="s4">.</span><span class="s1">UnmappedClassError</span><span class="s4">(</span>
            <span class="s1">cls</span><span class="s4">,</span>
            <span class="s1">msg</span><span class="s4">=</span><span class="s2">&quot;Class %s is a subclass of AutomapBase.  &quot;</span>
            <span class="s2">&quot;Mappings are not produced until the .prepare() &quot;</span>
            <span class="s2">&quot;method is called on the class hierarchy.&quot;</span>
            <span class="s4">% </span><span class="s1">orm_exc</span><span class="s4">.</span><span class="s1">_safe_cls_name</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">),</span>
        <span class="s4">)</span>


<span class="s4">@</span><span class="s1">dataclasses</span><span class="s4">.</span><span class="s1">dataclass</span>
<span class="s3">class </span><span class="s1">_Bookkeeping</span><span class="s4">:</span>
    <span class="s1">__slots__ </span><span class="s4">= (</span><span class="s2">&quot;table_keys&quot;</span><span class="s4">,)</span>

    <span class="s1">table_keys</span><span class="s4">: </span><span class="s1">Set</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">automap_base</span><span class="s4">(</span>
    <span class="s1">declarative_base</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
<span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
    <span class="s5">r&quot;&quot;&quot;Produce a declarative automap base. 
 
    This function produces a new base class that is a product of the 
    :class:`.AutomapBase` class as well a declarative base produced by 
    :func:`.declarative.declarative_base`. 
 
    All parameters other than ``declarative_base`` are keyword arguments 
    that are passed directly to the :func:`.declarative.declarative_base` 
    function. 
 
    :param declarative_base: an existing class produced by 
     :func:`.declarative.declarative_base`.  When this is passed, the function 
     no longer invokes :func:`.declarative.declarative_base` itself, and all 
     other keyword arguments are ignored. 
 
    :param \**kw: keyword arguments are passed along to 
     :func:`.declarative.declarative_base`. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">declarative_base </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">Base </span><span class="s4">= </span><span class="s1">_declarative_base</span><span class="s4">(**</span><span class="s1">kw</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">Base </span><span class="s4">= </span><span class="s1">declarative_base</span>

    <span class="s3">return </span><span class="s1">type</span><span class="s4">(</span>
        <span class="s1">Base</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">,</span>
        <span class="s4">(</span><span class="s1">AutomapBase</span><span class="s4">, </span><span class="s1">Base</span><span class="s4">),</span>
        <span class="s4">{</span>
            <span class="s2">&quot;__abstract__&quot;</span><span class="s4">: </span><span class="s3">True</span><span class="s4">,</span>
            <span class="s2">&quot;classes&quot;</span><span class="s4">: </span><span class="s1">util</span><span class="s4">.</span><span class="s1">Properties</span><span class="s4">({}),</span>
            <span class="s2">&quot;by_module&quot;</span><span class="s4">: </span><span class="s1">util</span><span class="s4">.</span><span class="s1">Properties</span><span class="s4">({}),</span>
            <span class="s2">&quot;_sa_automapbase_bookkeeping&quot;</span><span class="s4">: </span><span class="s1">_Bookkeeping</span><span class="s4">(</span><span class="s1">set</span><span class="s4">()),</span>
        <span class="s4">},</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">_is_many_to_many</span><span class="s4">(</span>
    <span class="s1">automap_base</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">table</span><span class="s4">: </span><span class="s1">Table</span>
<span class="s4">) </span><span class="s1">-&gt; Tuple</span><span class="s4">[</span>
    <span class="s1">Optional</span><span class="s4">[</span><span class="s1">Table</span><span class="s4">], </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Table</span><span class="s4">], </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">list</span><span class="s4">[</span><span class="s1">ForeignKeyConstraint</span><span class="s4">]]</span>
<span class="s4">]:</span>
    <span class="s1">fk_constraints </span><span class="s4">= [</span>
        <span class="s1">const</span>
        <span class="s3">for </span><span class="s1">const </span><span class="s3">in </span><span class="s1">table</span><span class="s4">.</span><span class="s1">constraints</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">const</span><span class="s4">, </span><span class="s1">ForeignKeyConstraint</span><span class="s4">)</span>
    <span class="s4">]</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">fk_constraints</span><span class="s4">) != </span><span class="s6">2</span><span class="s4">:</span>
        <span class="s3">return None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span>

    <span class="s1">cols</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">Column</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s1">sum</span><span class="s4">(</span>
        <span class="s4">[</span>
            <span class="s4">[</span><span class="s1">fk</span><span class="s4">.</span><span class="s1">parent </span><span class="s3">for </span><span class="s1">fk </span><span class="s3">in </span><span class="s1">fk_constraint</span><span class="s4">.</span><span class="s1">elements</span><span class="s4">]</span>
            <span class="s3">for </span><span class="s1">fk_constraint </span><span class="s3">in </span><span class="s1">fk_constraints</span>
        <span class="s4">],</span>
        <span class="s4">[],</span>
    <span class="s4">)</span>

    <span class="s3">if </span><span class="s1">set</span><span class="s4">(</span><span class="s1">cols</span><span class="s4">) != </span><span class="s1">set</span><span class="s4">(</span><span class="s1">table</span><span class="s4">.</span><span class="s1">c</span><span class="s4">):</span>
        <span class="s3">return None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span>

    <span class="s3">return </span><span class="s4">(</span>
        <span class="s1">fk_constraints</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">elements</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">column</span><span class="s4">.</span><span class="s1">table</span><span class="s4">,</span>
        <span class="s1">fk_constraints</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">elements</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">column</span><span class="s4">.</span><span class="s1">table</span><span class="s4">,</span>
        <span class="s1">fk_constraints</span><span class="s4">,</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">_relationships_for_fks</span><span class="s4">(</span>
    <span class="s1">automap_base</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">map_config</span><span class="s4">: </span><span class="s1">_DeferredMapperConfig</span><span class="s4">,</span>
    <span class="s1">table_to_map_config</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
        <span class="s1">Dict</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Table</span><span class="s4">], </span><span class="s1">_DeferredMapperConfig</span><span class="s4">],</span>
        <span class="s1">Dict</span><span class="s4">[</span><span class="s1">Table</span><span class="s4">, </span><span class="s1">_DeferredMapperConfig</span><span class="s4">],</span>
    <span class="s4">],</span>
    <span class="s1">collection_class</span><span class="s4">: </span><span class="s1">type</span><span class="s4">,</span>
    <span class="s1">name_for_scalar_relationship</span><span class="s4">: </span><span class="s1">NameForScalarRelationshipType</span><span class="s4">,</span>
    <span class="s1">name_for_collection_relationship</span><span class="s4">: </span><span class="s1">NameForCollectionRelationshipType</span><span class="s4">,</span>
    <span class="s1">generate_relationship</span><span class="s4">: </span><span class="s1">GenerateRelationshipType</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
    <span class="s1">local_table </span><span class="s4">= </span><span class="s1">cast</span><span class="s4">(</span><span class="s2">&quot;Optional[Table]&quot;</span><span class="s4">, </span><span class="s1">map_config</span><span class="s4">.</span><span class="s1">local_table</span><span class="s4">)</span>
    <span class="s1">local_cls </span><span class="s4">= </span><span class="s1">cast</span><span class="s4">(</span>
        <span class="s2">&quot;Optional[Type[Any]]&quot;</span><span class="s4">, </span><span class="s1">map_config</span><span class="s4">.</span><span class="s1">cls</span>
    <span class="s4">)  </span><span class="s0"># derived from a weakref, may be None</span>

    <span class="s3">if </span><span class="s1">local_table </span><span class="s3">is None or </span><span class="s1">local_cls </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">return</span>
    <span class="s3">for </span><span class="s1">constraint </span><span class="s3">in </span><span class="s1">local_table</span><span class="s4">.</span><span class="s1">constraints</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">constraint</span><span class="s4">, </span><span class="s1">ForeignKeyConstraint</span><span class="s4">):</span>
            <span class="s1">fks </span><span class="s4">= </span><span class="s1">constraint</span><span class="s4">.</span><span class="s1">elements</span>
            <span class="s1">referred_table </span><span class="s4">= </span><span class="s1">fks</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">column</span><span class="s4">.</span><span class="s1">table</span>
            <span class="s1">referred_cfg </span><span class="s4">= </span><span class="s1">table_to_map_config</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">referred_table</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">referred_cfg </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s3">continue</span>
            <span class="s1">referred_cls </span><span class="s4">= </span><span class="s1">referred_cfg</span><span class="s4">.</span><span class="s1">cls</span>

            <span class="s3">if </span><span class="s1">local_cls </span><span class="s3">is not </span><span class="s1">referred_cls </span><span class="s3">and </span><span class="s1">issubclass</span><span class="s4">(</span>
                <span class="s1">local_cls</span><span class="s4">, </span><span class="s1">referred_cls</span>
            <span class="s4">):</span>
                <span class="s3">continue</span>

            <span class="s1">relationship_name </span><span class="s4">= </span><span class="s1">name_for_scalar_relationship</span><span class="s4">(</span>
                <span class="s1">automap_base</span><span class="s4">, </span><span class="s1">local_cls</span><span class="s4">, </span><span class="s1">referred_cls</span><span class="s4">, </span><span class="s1">constraint</span>
            <span class="s4">)</span>
            <span class="s1">backref_name </span><span class="s4">= </span><span class="s1">name_for_collection_relationship</span><span class="s4">(</span>
                <span class="s1">automap_base</span><span class="s4">, </span><span class="s1">referred_cls</span><span class="s4">, </span><span class="s1">local_cls</span><span class="s4">, </span><span class="s1">constraint</span>
            <span class="s4">)</span>

            <span class="s1">o2m_kws</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">bool</span><span class="s4">]] = {}</span>
            <span class="s1">nullable </span><span class="s4">= </span><span class="s3">False not in </span><span class="s4">{</span><span class="s1">fk</span><span class="s4">.</span><span class="s1">parent</span><span class="s4">.</span><span class="s1">nullable </span><span class="s3">for </span><span class="s1">fk </span><span class="s3">in </span><span class="s1">fks</span><span class="s4">}</span>
            <span class="s3">if not </span><span class="s1">nullable</span><span class="s4">:</span>
                <span class="s1">o2m_kws</span><span class="s4">[</span><span class="s2">&quot;cascade&quot;</span><span class="s4">] = </span><span class="s2">&quot;all, delete-orphan&quot;</span>

                <span class="s3">if </span><span class="s4">(</span>
                    <span class="s1">constraint</span><span class="s4">.</span><span class="s1">ondelete</span>
                    <span class="s3">and </span><span class="s1">constraint</span><span class="s4">.</span><span class="s1">ondelete</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">() == </span><span class="s2">&quot;cascade&quot;</span>
                <span class="s4">):</span>
                    <span class="s1">o2m_kws</span><span class="s4">[</span><span class="s2">&quot;passive_deletes&quot;</span><span class="s4">] = </span><span class="s3">True</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s4">(</span>
                    <span class="s1">constraint</span><span class="s4">.</span><span class="s1">ondelete</span>
                    <span class="s3">and </span><span class="s1">constraint</span><span class="s4">.</span><span class="s1">ondelete</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">() == </span><span class="s2">&quot;set null&quot;</span>
                <span class="s4">):</span>
                    <span class="s1">o2m_kws</span><span class="s4">[</span><span class="s2">&quot;passive_deletes&quot;</span><span class="s4">] = </span><span class="s3">True</span>

            <span class="s1">create_backref </span><span class="s4">= </span><span class="s1">backref_name </span><span class="s3">not in </span><span class="s1">referred_cfg</span><span class="s4">.</span><span class="s1">properties</span>

            <span class="s3">if </span><span class="s1">relationship_name </span><span class="s3">not in </span><span class="s1">map_config</span><span class="s4">.</span><span class="s1">properties</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">create_backref</span><span class="s4">:</span>
                    <span class="s1">backref_obj </span><span class="s4">= </span><span class="s1">generate_relationship</span><span class="s4">(</span>
                        <span class="s1">automap_base</span><span class="s4">,</span>
                        <span class="s1">interfaces</span><span class="s4">.</span><span class="s1">ONETOMANY</span><span class="s4">,</span>
                        <span class="s1">backref</span><span class="s4">,</span>
                        <span class="s1">backref_name</span><span class="s4">,</span>
                        <span class="s1">referred_cls</span><span class="s4">,</span>
                        <span class="s1">local_cls</span><span class="s4">,</span>
                        <span class="s1">collection_class</span><span class="s4">=</span><span class="s1">collection_class</span><span class="s4">,</span>
                        <span class="s4">**</span><span class="s1">o2m_kws</span><span class="s4">,</span>
                    <span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">backref_obj </span><span class="s4">= </span><span class="s3">None</span>
                <span class="s1">rel </span><span class="s4">= </span><span class="s1">generate_relationship</span><span class="s4">(</span>
                    <span class="s1">automap_base</span><span class="s4">,</span>
                    <span class="s1">interfaces</span><span class="s4">.</span><span class="s1">MANYTOONE</span><span class="s4">,</span>
                    <span class="s1">relationship</span><span class="s4">,</span>
                    <span class="s1">relationship_name</span><span class="s4">,</span>
                    <span class="s1">local_cls</span><span class="s4">,</span>
                    <span class="s1">referred_cls</span><span class="s4">,</span>
                    <span class="s1">foreign_keys</span><span class="s4">=[</span><span class="s1">fk</span><span class="s4">.</span><span class="s1">parent </span><span class="s3">for </span><span class="s1">fk </span><span class="s3">in </span><span class="s1">constraint</span><span class="s4">.</span><span class="s1">elements</span><span class="s4">],</span>
                    <span class="s1">backref</span><span class="s4">=</span><span class="s1">backref_obj</span><span class="s4">,</span>
                    <span class="s1">remote_side</span><span class="s4">=[</span><span class="s1">fk</span><span class="s4">.</span><span class="s1">column </span><span class="s3">for </span><span class="s1">fk </span><span class="s3">in </span><span class="s1">constraint</span><span class="s4">.</span><span class="s1">elements</span><span class="s4">],</span>
                <span class="s4">)</span>
                <span class="s3">if </span><span class="s1">rel </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s1">map_config</span><span class="s4">.</span><span class="s1">properties</span><span class="s4">[</span><span class="s1">relationship_name</span><span class="s4">] = </span><span class="s1">rel</span>
                    <span class="s3">if not </span><span class="s1">create_backref</span><span class="s4">:</span>
                        <span class="s1">referred_cfg</span><span class="s4">.</span><span class="s1">properties</span><span class="s4">[</span>
                            <span class="s1">backref_name</span>
                        <span class="s4">].</span><span class="s1">back_populates </span><span class="s4">= </span><span class="s1">relationship_name  </span><span class="s0"># type: ignore[union-attr] # noqa: E501</span>
            <span class="s3">elif </span><span class="s1">create_backref</span><span class="s4">:</span>
                <span class="s1">rel </span><span class="s4">= </span><span class="s1">generate_relationship</span><span class="s4">(</span>
                    <span class="s1">automap_base</span><span class="s4">,</span>
                    <span class="s1">interfaces</span><span class="s4">.</span><span class="s1">ONETOMANY</span><span class="s4">,</span>
                    <span class="s1">relationship</span><span class="s4">,</span>
                    <span class="s1">backref_name</span><span class="s4">,</span>
                    <span class="s1">referred_cls</span><span class="s4">,</span>
                    <span class="s1">local_cls</span><span class="s4">,</span>
                    <span class="s1">foreign_keys</span><span class="s4">=[</span><span class="s1">fk</span><span class="s4">.</span><span class="s1">parent </span><span class="s3">for </span><span class="s1">fk </span><span class="s3">in </span><span class="s1">constraint</span><span class="s4">.</span><span class="s1">elements</span><span class="s4">],</span>
                    <span class="s1">back_populates</span><span class="s4">=</span><span class="s1">relationship_name</span><span class="s4">,</span>
                    <span class="s1">collection_class</span><span class="s4">=</span><span class="s1">collection_class</span><span class="s4">,</span>
                    <span class="s4">**</span><span class="s1">o2m_kws</span><span class="s4">,</span>
                <span class="s4">)</span>
                <span class="s3">if </span><span class="s1">rel </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s1">referred_cfg</span><span class="s4">.</span><span class="s1">properties</span><span class="s4">[</span><span class="s1">backref_name</span><span class="s4">] = </span><span class="s1">rel</span>
                    <span class="s1">map_config</span><span class="s4">.</span><span class="s1">properties</span><span class="s4">[</span>
                        <span class="s1">relationship_name</span>
                    <span class="s4">].</span><span class="s1">back_populates </span><span class="s4">= </span><span class="s1">backref_name  </span><span class="s0"># type: ignore[union-attr]</span>


<span class="s3">def </span><span class="s1">_m2m_relationship</span><span class="s4">(</span>
    <span class="s1">automap_base</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">lcl_m2m</span><span class="s4">: </span><span class="s1">Table</span><span class="s4">,</span>
    <span class="s1">rem_m2m</span><span class="s4">: </span><span class="s1">Table</span><span class="s4">,</span>
    <span class="s1">m2m_const</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">ForeignKeyConstraint</span><span class="s4">],</span>
    <span class="s1">table</span><span class="s4">: </span><span class="s1">Table</span><span class="s4">,</span>
    <span class="s1">table_to_map_config</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
        <span class="s1">Dict</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Table</span><span class="s4">], </span><span class="s1">_DeferredMapperConfig</span><span class="s4">],</span>
        <span class="s1">Dict</span><span class="s4">[</span><span class="s1">Table</span><span class="s4">, </span><span class="s1">_DeferredMapperConfig</span><span class="s4">],</span>
    <span class="s4">],</span>
    <span class="s1">collection_class</span><span class="s4">: </span><span class="s1">type</span><span class="s4">,</span>
    <span class="s1">name_for_scalar_relationship</span><span class="s4">: </span><span class="s1">NameForCollectionRelationshipType</span><span class="s4">,</span>
    <span class="s1">name_for_collection_relationship</span><span class="s4">: </span><span class="s1">NameForCollectionRelationshipType</span><span class="s4">,</span>
    <span class="s1">generate_relationship</span><span class="s4">: </span><span class="s1">GenerateRelationshipType</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
    <span class="s1">map_config </span><span class="s4">= </span><span class="s1">table_to_map_config</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">lcl_m2m</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
    <span class="s1">referred_cfg </span><span class="s4">= </span><span class="s1">table_to_map_config</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">rem_m2m</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">map_config </span><span class="s3">is None or </span><span class="s1">referred_cfg </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">return</span>

    <span class="s1">local_cls </span><span class="s4">= </span><span class="s1">map_config</span><span class="s4">.</span><span class="s1">cls</span>
    <span class="s1">referred_cls </span><span class="s4">= </span><span class="s1">referred_cfg</span><span class="s4">.</span><span class="s1">cls</span>

    <span class="s1">relationship_name </span><span class="s4">= </span><span class="s1">name_for_collection_relationship</span><span class="s4">(</span>
        <span class="s1">automap_base</span><span class="s4">, </span><span class="s1">local_cls</span><span class="s4">, </span><span class="s1">referred_cls</span><span class="s4">, </span><span class="s1">m2m_const</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
    <span class="s4">)</span>
    <span class="s1">backref_name </span><span class="s4">= </span><span class="s1">name_for_collection_relationship</span><span class="s4">(</span>
        <span class="s1">automap_base</span><span class="s4">, </span><span class="s1">referred_cls</span><span class="s4">, </span><span class="s1">local_cls</span><span class="s4">, </span><span class="s1">m2m_const</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>
    <span class="s4">)</span>

    <span class="s1">create_backref </span><span class="s4">= </span><span class="s1">backref_name </span><span class="s3">not in </span><span class="s1">referred_cfg</span><span class="s4">.</span><span class="s1">properties</span>

    <span class="s3">if </span><span class="s1">table </span><span class="s3">in </span><span class="s1">table_to_map_config</span><span class="s4">:</span>
        <span class="s1">overlaps </span><span class="s4">= </span><span class="s2">&quot;__*&quot;</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">overlaps </span><span class="s4">= </span><span class="s3">None</span>

    <span class="s3">if </span><span class="s1">relationship_name </span><span class="s3">not in </span><span class="s1">map_config</span><span class="s4">.</span><span class="s1">properties</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">create_backref</span><span class="s4">:</span>
            <span class="s1">backref_obj </span><span class="s4">= </span><span class="s1">generate_relationship</span><span class="s4">(</span>
                <span class="s1">automap_base</span><span class="s4">,</span>
                <span class="s1">interfaces</span><span class="s4">.</span><span class="s1">MANYTOMANY</span><span class="s4">,</span>
                <span class="s1">backref</span><span class="s4">,</span>
                <span class="s1">backref_name</span><span class="s4">,</span>
                <span class="s1">referred_cls</span><span class="s4">,</span>
                <span class="s1">local_cls</span><span class="s4">,</span>
                <span class="s1">collection_class</span><span class="s4">=</span><span class="s1">collection_class</span><span class="s4">,</span>
                <span class="s1">overlaps</span><span class="s4">=</span><span class="s1">overlaps</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">backref_obj </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s1">rel </span><span class="s4">= </span><span class="s1">generate_relationship</span><span class="s4">(</span>
            <span class="s1">automap_base</span><span class="s4">,</span>
            <span class="s1">interfaces</span><span class="s4">.</span><span class="s1">MANYTOMANY</span><span class="s4">,</span>
            <span class="s1">relationship</span><span class="s4">,</span>
            <span class="s1">relationship_name</span><span class="s4">,</span>
            <span class="s1">local_cls</span><span class="s4">,</span>
            <span class="s1">referred_cls</span><span class="s4">,</span>
            <span class="s1">overlaps</span><span class="s4">=</span><span class="s1">overlaps</span><span class="s4">,</span>
            <span class="s1">secondary</span><span class="s4">=</span><span class="s1">table</span><span class="s4">,</span>
            <span class="s1">primaryjoin</span><span class="s4">=</span><span class="s1">and_</span><span class="s4">(</span>
                <span class="s1">fk</span><span class="s4">.</span><span class="s1">column </span><span class="s4">== </span><span class="s1">fk</span><span class="s4">.</span><span class="s1">parent </span><span class="s3">for </span><span class="s1">fk </span><span class="s3">in </span><span class="s1">m2m_const</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">elements</span>
            <span class="s4">),  </span><span class="s0"># type: ignore [arg-type]</span>
            <span class="s1">secondaryjoin</span><span class="s4">=</span><span class="s1">and_</span><span class="s4">(</span>
                <span class="s1">fk</span><span class="s4">.</span><span class="s1">column </span><span class="s4">== </span><span class="s1">fk</span><span class="s4">.</span><span class="s1">parent </span><span class="s3">for </span><span class="s1">fk </span><span class="s3">in </span><span class="s1">m2m_const</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">elements</span>
            <span class="s4">),  </span><span class="s0"># type: ignore [arg-type]</span>
            <span class="s1">backref</span><span class="s4">=</span><span class="s1">backref_obj</span><span class="s4">,</span>
            <span class="s1">collection_class</span><span class="s4">=</span><span class="s1">collection_class</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">rel </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">map_config</span><span class="s4">.</span><span class="s1">properties</span><span class="s4">[</span><span class="s1">relationship_name</span><span class="s4">] = </span><span class="s1">rel</span>

            <span class="s3">if not </span><span class="s1">create_backref</span><span class="s4">:</span>
                <span class="s1">referred_cfg</span><span class="s4">.</span><span class="s1">properties</span><span class="s4">[</span>
                    <span class="s1">backref_name</span>
                <span class="s4">].</span><span class="s1">back_populates </span><span class="s4">= </span><span class="s1">relationship_name  </span><span class="s0"># type: ignore[union-attr] # noqa: E501</span>
    <span class="s3">elif </span><span class="s1">create_backref</span><span class="s4">:</span>
        <span class="s1">rel </span><span class="s4">= </span><span class="s1">generate_relationship</span><span class="s4">(</span>
            <span class="s1">automap_base</span><span class="s4">,</span>
            <span class="s1">interfaces</span><span class="s4">.</span><span class="s1">MANYTOMANY</span><span class="s4">,</span>
            <span class="s1">relationship</span><span class="s4">,</span>
            <span class="s1">backref_name</span><span class="s4">,</span>
            <span class="s1">referred_cls</span><span class="s4">,</span>
            <span class="s1">local_cls</span><span class="s4">,</span>
            <span class="s1">overlaps</span><span class="s4">=</span><span class="s1">overlaps</span><span class="s4">,</span>
            <span class="s1">secondary</span><span class="s4">=</span><span class="s1">table</span><span class="s4">,</span>
            <span class="s1">primaryjoin</span><span class="s4">=</span><span class="s1">and_</span><span class="s4">(</span>
                <span class="s1">fk</span><span class="s4">.</span><span class="s1">column </span><span class="s4">== </span><span class="s1">fk</span><span class="s4">.</span><span class="s1">parent </span><span class="s3">for </span><span class="s1">fk </span><span class="s3">in </span><span class="s1">m2m_const</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">elements</span>
            <span class="s4">),  </span><span class="s0"># type: ignore [arg-type]</span>
            <span class="s1">secondaryjoin</span><span class="s4">=</span><span class="s1">and_</span><span class="s4">(</span>
                <span class="s1">fk</span><span class="s4">.</span><span class="s1">column </span><span class="s4">== </span><span class="s1">fk</span><span class="s4">.</span><span class="s1">parent </span><span class="s3">for </span><span class="s1">fk </span><span class="s3">in </span><span class="s1">m2m_const</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">elements</span>
            <span class="s4">),  </span><span class="s0"># type: ignore [arg-type]</span>
            <span class="s1">back_populates</span><span class="s4">=</span><span class="s1">relationship_name</span><span class="s4">,</span>
            <span class="s1">collection_class</span><span class="s4">=</span><span class="s1">collection_class</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">rel </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">referred_cfg</span><span class="s4">.</span><span class="s1">properties</span><span class="s4">[</span><span class="s1">backref_name</span><span class="s4">] = </span><span class="s1">rel</span>
            <span class="s1">map_config</span><span class="s4">.</span><span class="s1">properties</span><span class="s4">[</span>
                <span class="s1">relationship_name</span>
            <span class="s4">].</span><span class="s1">back_populates </span><span class="s4">= </span><span class="s1">backref_name  </span><span class="s0"># type: ignore[union-attr]</span>
</pre>
</body>
</html>