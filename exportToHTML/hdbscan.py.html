<html>
<head>
<title>hdbscan.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
hdbscan.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
HDBSCAN: Hierarchical Density-Based Spatial Clustering 
         of Applications with Noise 
&quot;&quot;&quot;</span>

<span class="s2"># Authors: Leland McInnes &lt;leland.mcinnes@gmail.com&gt;</span>
<span class="s2">#          Steve Astels &lt;sastels@gmail.com&gt;</span>
<span class="s2">#          John Healy &lt;jchealy@gmail.com&gt;</span>
<span class="s2">#          Meekail Zain &lt;zainmeekail@gmail.com&gt;</span>
<span class="s2"># Copyright (c) 2015, Leland McInnes</span>
<span class="s2"># All rights reserved.</span>

<span class="s2"># Redistribution and use in source and binary forms, with or without</span>
<span class="s2"># modification, are permitted provided that the following conditions are met:</span>

<span class="s2"># 1. Redistributions of source code must retain the above copyright notice,</span>
<span class="s2"># this list of conditions and the following disclaimer.</span>

<span class="s2"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="s2"># this list of conditions and the following disclaimer in the documentation</span>
<span class="s2"># and/or other materials provided with the distribution.</span>

<span class="s2"># 3. Neither the name of the copyright holder nor the names of its contributors</span>
<span class="s2"># may be used to endorse or promote products derived from this software without</span>
<span class="s2"># specific prior written permission.</span>

<span class="s2"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="s2"># AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="s2"># IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="s2"># ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span class="s2"># LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="s2"># CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="s2"># SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="s2"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="s2"># CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="s2"># ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="s2"># POSSIBILITY OF SUCH DAMAGE.</span>

<span class="s3">from </span><span class="s1">numbers </span><span class="s3">import </span><span class="s1">Integral</span><span class="s4">, </span><span class="s1">Real</span>
<span class="s3">from </span><span class="s1">warnings </span><span class="s3">import </span><span class="s1">warn</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse </span><span class="s3">import </span><span class="s1">csgraph</span><span class="s4">, </span><span class="s1">issparse</span>

<span class="s3">from </span><span class="s4">...</span><span class="s1">base </span><span class="s3">import </span><span class="s1">BaseEstimator</span><span class="s4">, </span><span class="s1">ClusterMixin</span><span class="s4">, </span><span class="s1">_fit_context</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">metrics </span><span class="s3">import </span><span class="s1">pairwise_distances</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">metrics</span><span class="s4">.</span><span class="s1">_dist_metrics </span><span class="s3">import </span><span class="s1">DistanceMetric</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">metrics</span><span class="s4">.</span><span class="s1">pairwise </span><span class="s3">import </span><span class="s1">_VALID_METRICS</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">neighbors </span><span class="s3">import </span><span class="s1">BallTree</span><span class="s4">, </span><span class="s1">KDTree</span><span class="s4">, </span><span class="s1">NearestNeighbors</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_param_validation </span><span class="s3">import </span><span class="s1">Interval</span><span class="s4">, </span><span class="s1">StrOptions</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">validation </span><span class="s3">import </span><span class="s1">_allclose_dense_sparse</span><span class="s4">, </span><span class="s1">_assert_all_finite</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_linkage </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">MST_edge_dtype</span><span class="s4">,</span>
    <span class="s1">make_single_linkage</span><span class="s4">,</span>
    <span class="s1">mst_from_data_matrix</span><span class="s4">,</span>
    <span class="s1">mst_from_mutual_reachability</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_reachability </span><span class="s3">import </span><span class="s1">mutual_reachability_graph</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_tree </span><span class="s3">import </span><span class="s1">HIERARCHY_dtype</span><span class="s4">, </span><span class="s1">labelling_at_cut</span><span class="s4">, </span><span class="s1">tree_to_labels</span>

<span class="s1">FAST_METRICS </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">KDTree</span><span class="s4">.</span><span class="s1">valid_metrics </span><span class="s4">+ </span><span class="s1">BallTree</span><span class="s4">.</span><span class="s1">valid_metrics</span><span class="s4">)</span>

<span class="s2"># Encodings are arbitrary but must be strictly negative.</span>
<span class="s2"># The current encodings are chosen as extensions to the -1 noise label.</span>
<span class="s2"># Avoided enums so that the end user only deals with simple labels.</span>
<span class="s1">_OUTLIER_ENCODING</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
    <span class="s5">&quot;infinite&quot;</span><span class="s4">: {</span>
        <span class="s5">&quot;label&quot;</span><span class="s4">: -</span><span class="s6">2</span><span class="s4">,</span>
        <span class="s2"># The probability could also be 1, since infinite points are certainly</span>
        <span class="s2"># infinite outliers, however 0 is convention from the HDBSCAN library</span>
        <span class="s2"># implementation.</span>
        <span class="s5">&quot;prob&quot;</span><span class="s4">: </span><span class="s6">0</span><span class="s4">,</span>
    <span class="s4">},</span>
    <span class="s5">&quot;missing&quot;</span><span class="s4">: {</span>
        <span class="s5">&quot;label&quot;</span><span class="s4">: -</span><span class="s6">3</span><span class="s4">,</span>
        <span class="s2"># A nan probability is chosen to emphasize the fact that the</span>
        <span class="s2"># corresponding data was not considered in the clustering problem.</span>
        <span class="s5">&quot;prob&quot;</span><span class="s4">: </span><span class="s1">np</span><span class="s4">.</span><span class="s1">nan</span><span class="s4">,</span>
    <span class="s4">},</span>
<span class="s4">}</span>


<span class="s3">def </span><span class="s1">_brute_mst</span><span class="s4">(</span><span class="s1">mutual_reachability</span><span class="s4">, </span><span class="s1">min_samples</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Builds a minimum spanning tree (MST) from the provided mutual-reachability 
    values. This function dispatches to a custom Cython implementation for 
    dense arrays, and `scipy.sparse.csgraph.minimum_spanning_tree` for sparse 
    arrays/matrices. 
 
    Parameters 
    ---------- 
    mututal_reachability_graph: {ndarray, sparse matrix} of shape \ 
            (n_samples, n_samples) 
        Weighted adjacency matrix of the mutual reachability graph. 
 
    min_samples : int, default=None 
        The number of samples in a neighborhood for a point 
        to be considered as a core point. This includes the point itself. 
 
    Returns 
    ------- 
    mst : ndarray of shape (n_samples - 1,), dtype=MST_edge_dtype 
        The MST representation of the mutual-reachability graph. The MST is 
        represented as a collection of edges. 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">mutual_reachability</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">mst_from_mutual_reachability</span><span class="s4">(</span><span class="s1">mutual_reachability</span><span class="s4">)</span>

    <span class="s2"># Check if the mutual reachability matrix has any rows which have</span>
    <span class="s2"># less than `min_samples` non-zero elements.</span>
    <span class="s1">indptr </span><span class="s4">= </span><span class="s1">mutual_reachability</span><span class="s4">.</span><span class="s1">indptr</span>
    <span class="s1">num_points </span><span class="s4">= </span><span class="s1">mutual_reachability</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
    <span class="s3">if </span><span class="s1">any</span><span class="s4">((</span><span class="s1">indptr</span><span class="s4">[</span><span class="s1">i </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">] - </span><span class="s1">indptr</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]) &lt; </span><span class="s1">min_samples </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">num_points</span><span class="s4">)):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
            <span class="s5">f&quot;There exists points with fewer than </span><span class="s3">{</span><span class="s1">min_samples</span><span class="s3">} </span><span class="s5">neighbors. Ensure&quot;</span>
            <span class="s5">&quot; your distance matrix has non-zero values for at least&quot;</span>
            <span class="s5">f&quot; `min_sample`=</span><span class="s3">{</span><span class="s1">min_samples</span><span class="s3">} </span><span class="s5">neighbors for each points (i.e. K-nn&quot;</span>
            <span class="s5">&quot; graph), or specify a `max_distance` in `metric_params` to use when&quot;</span>
            <span class="s5">&quot; distances are missing.&quot;</span>
        <span class="s4">)</span>
    <span class="s2"># Check connected component on mutual reachability.</span>
    <span class="s2"># If more than one connected component is present,</span>
    <span class="s2"># it means that the graph is disconnected.</span>
    <span class="s1">n_components </span><span class="s4">= </span><span class="s1">csgraph</span><span class="s4">.</span><span class="s1">connected_components</span><span class="s4">(</span>
        <span class="s1">mutual_reachability</span><span class="s4">, </span><span class="s1">directed</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">return_labels</span><span class="s4">=</span><span class="s3">False</span>
    <span class="s4">)</span>
    <span class="s3">if </span><span class="s1">n_components </span><span class="s4">&gt; </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
            <span class="s5">f&quot;Sparse mutual reachability matrix has </span><span class="s3">{</span><span class="s1">n_components</span><span class="s3">} </span><span class="s5">connected&quot;</span>
            <span class="s5">&quot; components. HDBSCAN cannot be perfomed on a disconnected graph. Ensure&quot;</span>
            <span class="s5">&quot; that the sparse distance matrix has only one connected component.&quot;</span>
        <span class="s4">)</span>

    <span class="s2"># Compute the minimum spanning tree for the sparse graph</span>
    <span class="s1">sparse_min_spanning_tree </span><span class="s4">= </span><span class="s1">csgraph</span><span class="s4">.</span><span class="s1">minimum_spanning_tree</span><span class="s4">(</span><span class="s1">mutual_reachability</span><span class="s4">)</span>
    <span class="s1">rows</span><span class="s4">, </span><span class="s1">cols </span><span class="s4">= </span><span class="s1">sparse_min_spanning_tree</span><span class="s4">.</span><span class="s1">nonzero</span><span class="s4">()</span>
    <span class="s1">mst </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">rec</span><span class="s4">.</span><span class="s1">fromarrays</span><span class="s4">(</span>
        <span class="s4">[</span><span class="s1">rows</span><span class="s4">, </span><span class="s1">cols</span><span class="s4">, </span><span class="s1">sparse_min_spanning_tree</span><span class="s4">.</span><span class="s1">data</span><span class="s4">],</span>
        <span class="s1">dtype</span><span class="s4">=</span><span class="s1">MST_edge_dtype</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">return </span><span class="s1">mst</span>


<span class="s3">def </span><span class="s1">_process_mst</span><span class="s4">(</span><span class="s1">min_spanning_tree</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Builds a single-linkage tree (SLT) from the provided minimum spanning tree 
    (MST). The MST is first sorted then processed by a custom Cython routine. 
 
    Parameters 
    ---------- 
    min_spanning_tree : ndarray of shape (n_samples - 1,), dtype=MST_edge_dtype 
        The MST representation of the mutual-reachability graph. The MST is 
        represented as a collection of edges. 
 
    Returns 
    ------- 
    single_linkage : ndarray of shape (n_samples - 1,), dtype=HIERARCHY_dtype 
        The single-linkage tree tree (dendrogram) built from the MST. 
    &quot;&quot;&quot;</span>
    <span class="s2"># Sort edges of the min_spanning_tree by weight</span>
    <span class="s1">row_order </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">argsort</span><span class="s4">(</span><span class="s1">min_spanning_tree</span><span class="s4">[</span><span class="s5">&quot;distance&quot;</span><span class="s4">])</span>
    <span class="s1">min_spanning_tree </span><span class="s4">= </span><span class="s1">min_spanning_tree</span><span class="s4">[</span><span class="s1">row_order</span><span class="s4">]</span>
    <span class="s2"># Convert edge list into standard hierarchical clustering format</span>
    <span class="s3">return </span><span class="s1">make_single_linkage</span><span class="s4">(</span><span class="s1">min_spanning_tree</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_hdbscan_brute</span><span class="s4">(</span>
    <span class="s1">X</span><span class="s4">,</span>
    <span class="s1">min_samples</span><span class="s4">=</span><span class="s6">5</span><span class="s4">,</span>
    <span class="s1">alpha</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">metric</span><span class="s4">=</span><span class="s5">&quot;euclidean&quot;</span><span class="s4">,</span>
    <span class="s1">n_jobs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">copy</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">**</span><span class="s1">metric_params</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Builds a single-linkage tree (SLT) from the input data `X`. If 
    `metric=&quot;precomputed&quot;` then `X` must be a symmetric array of distances. 
    Otherwise, the pairwise distances are calculated directly and passed to 
    `mutual_reachability_graph`. 
 
    Parameters 
    ---------- 
    X : ndarray of shape (n_samples, n_features) or (n_samples, n_samples) 
        Either the raw data from which to compute the pairwise distances, 
        or the precomputed distances. 
 
    min_samples : int, default=None 
        The number of samples in a neighborhood for a point 
        to be considered as a core point. This includes the point itself. 
 
    alpha : float, default=1.0 
        A distance scaling parameter as used in robust single linkage. 
 
    metric : str or callable, default='euclidean' 
        The metric to use when calculating distance between instances in a 
        feature array. 
 
        - If metric is a string or callable, it must be one of 
          the options allowed by :func:`~sklearn.metrics.pairwise_distances` 
          for its metric parameter. 
 
        - If metric is &quot;precomputed&quot;, X is assumed to be a distance matrix and 
          must be square. 
 
    n_jobs : int, default=None 
        The number of jobs to use for computing the pairwise distances. This 
        works by breaking down the pairwise matrix into n_jobs even slices and 
        computing them in parallel. This parameter is passed directly to 
        :func:`~sklearn.metrics.pairwise_distances`. 
 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    copy : bool, default=False 
        If `copy=True` then any time an in-place modifications would be made 
        that would overwrite `X`, a copy will first be made, guaranteeing that 
        the original data will be unchanged. Currently, it only applies when 
        `metric=&quot;precomputed&quot;`, when passing a dense array or a CSR sparse 
        array/matrix. 
 
    metric_params : dict, default=None 
        Arguments passed to the distance metric. 
 
    Returns 
    ------- 
    single_linkage : ndarray of shape (n_samples - 1,), dtype=HIERARCHY_dtype 
        The single-linkage tree tree (dendrogram) built from the MST. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">metric </span><span class="s4">== </span><span class="s5">&quot;precomputed&quot;</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] != </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;The precomputed distance matrix is expected to be symmetric, however&quot;</span>
                <span class="s5">f&quot; it has shape </span><span class="s3">{</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s3">}</span><span class="s5">. Please verify that the&quot;</span>
                <span class="s5">&quot; distance matrix was constructed correctly.&quot;</span>
            <span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">_allclose_dense_sparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">X</span><span class="s4">.</span><span class="s1">T</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;The precomputed distance matrix is expected to be symmetric, however&quot;</span>
                <span class="s5">&quot; its values appear to be asymmetric. Please verify that the distance&quot;</span>
                <span class="s5">&quot; matrix was constructed correctly.&quot;</span>
            <span class="s4">)</span>

        <span class="s1">distance_matrix </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">() </span><span class="s3">if </span><span class="s1">copy </span><span class="s3">else </span><span class="s1">X</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">distance_matrix </span><span class="s4">= </span><span class="s1">pairwise_distances</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s1">metric</span><span class="s4">, </span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">n_jobs</span><span class="s4">, **</span><span class="s1">metric_params</span>
        <span class="s4">)</span>
    <span class="s1">distance_matrix </span><span class="s4">/= </span><span class="s1">alpha</span>

    <span class="s1">max_distance </span><span class="s4">= </span><span class="s1">metric_params</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;max_distance&quot;</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">distance_matrix</span><span class="s4">) </span><span class="s3">and </span><span class="s1">distance_matrix</span><span class="s4">.</span><span class="s1">format </span><span class="s4">!= </span><span class="s5">&quot;csr&quot;</span><span class="s4">:</span>
        <span class="s2"># we need CSR format to avoid a conversion in `_brute_mst` when calling</span>
        <span class="s2"># `csgraph.connected_components`</span>
        <span class="s1">distance_matrix </span><span class="s4">= </span><span class="s1">distance_matrix</span><span class="s4">.</span><span class="s1">tocsr</span><span class="s4">()</span>

    <span class="s2"># Note that `distance_matrix` is manipulated in-place, however we do not</span>
    <span class="s2"># need it for anything else past this point, hence the operation is safe.</span>
    <span class="s1">mutual_reachability_ </span><span class="s4">= </span><span class="s1">mutual_reachability_graph</span><span class="s4">(</span>
        <span class="s1">distance_matrix</span><span class="s4">, </span><span class="s1">min_samples</span><span class="s4">=</span><span class="s1">min_samples</span><span class="s4">, </span><span class="s1">max_distance</span><span class="s4">=</span><span class="s1">max_distance</span>
    <span class="s4">)</span>
    <span class="s1">min_spanning_tree </span><span class="s4">= </span><span class="s1">_brute_mst</span><span class="s4">(</span><span class="s1">mutual_reachability_</span><span class="s4">, </span><span class="s1">min_samples</span><span class="s4">=</span><span class="s1">min_samples</span><span class="s4">)</span>
    <span class="s2"># Warn if the MST couldn't be constructed around the missing distances</span>
    <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isinf</span><span class="s4">(</span><span class="s1">min_spanning_tree</span><span class="s4">[</span><span class="s5">&quot;distance&quot;</span><span class="s4">]).</span><span class="s1">any</span><span class="s4">():</span>
        <span class="s1">warn</span><span class="s4">(</span>
            <span class="s4">(</span>
                <span class="s5">&quot;The minimum spanning tree contains edge weights with value &quot;</span>
                <span class="s5">&quot;infinity. Potentially, you are missing too many distances &quot;</span>
                <span class="s5">&quot;in the initial distance matrix for the given neighborhood &quot;</span>
                <span class="s5">&quot;size.&quot;</span>
            <span class="s4">),</span>
            <span class="s1">UserWarning</span><span class="s4">,</span>
        <span class="s4">)</span>
    <span class="s3">return </span><span class="s1">_process_mst</span><span class="s4">(</span><span class="s1">min_spanning_tree</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_hdbscan_prims</span><span class="s4">(</span>
    <span class="s1">X</span><span class="s4">,</span>
    <span class="s1">algo</span><span class="s4">,</span>
    <span class="s1">min_samples</span><span class="s4">=</span><span class="s6">5</span><span class="s4">,</span>
    <span class="s1">alpha</span><span class="s4">=</span><span class="s6">1.0</span><span class="s4">,</span>
    <span class="s1">metric</span><span class="s4">=</span><span class="s5">&quot;euclidean&quot;</span><span class="s4">,</span>
    <span class="s1">leaf_size</span><span class="s4">=</span><span class="s6">40</span><span class="s4">,</span>
    <span class="s1">n_jobs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">**</span><span class="s1">metric_params</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Builds a single-linkage tree (SLT) from the input data `X`. If 
    `metric=&quot;precomputed&quot;` then `X` must be a symmetric array of distances. 
    Otherwise, the pairwise distances are calculated directly and passed to 
    `mutual_reachability_graph`. 
 
    Parameters 
    ---------- 
    X : ndarray of shape (n_samples, n_features) 
        The raw data. 
 
    min_samples : int, default=None 
        The number of samples in a neighborhood for a point 
        to be considered as a core point. This includes the point itself. 
 
    alpha : float, default=1.0 
        A distance scaling parameter as used in robust single linkage. 
 
    metric : str or callable, default='euclidean' 
        The metric to use when calculating distance between instances in a 
        feature array. `metric` must be one of the options allowed by 
        :func:`~sklearn.metrics.pairwise_distances` for its metric 
        parameter. 
 
    n_jobs : int, default=None 
        The number of jobs to use for computing the pairwise distances. This 
        works by breaking down the pairwise matrix into n_jobs even slices and 
        computing them in parallel. This parameter is passed directly to 
        :func:`~sklearn.metrics.pairwise_distances`. 
 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    copy : bool, default=False 
        If `copy=True` then any time an in-place modifications would be made 
        that would overwrite `X`, a copy will first be made, guaranteeing that 
        the original data will be unchanged. Currently, it only applies when 
        `metric=&quot;precomputed&quot;`, when passing a dense array or a CSR sparse 
        array/matrix. 
 
    metric_params : dict, default=None 
        Arguments passed to the distance metric. 
 
    Returns 
    ------- 
    single_linkage : ndarray of shape (n_samples - 1,), dtype=HIERARCHY_dtype 
        The single-linkage tree tree (dendrogram) built from the MST. 
    &quot;&quot;&quot;</span>
    <span class="s2"># The Cython routines used require contiguous arrays</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">)</span>

    <span class="s2"># Get distance to kth nearest neighbour</span>
    <span class="s1">nbrs </span><span class="s4">= </span><span class="s1">NearestNeighbors</span><span class="s4">(</span>
        <span class="s1">n_neighbors</span><span class="s4">=</span><span class="s1">min_samples</span><span class="s4">,</span>
        <span class="s1">algorithm</span><span class="s4">=</span><span class="s1">algo</span><span class="s4">,</span>
        <span class="s1">leaf_size</span><span class="s4">=</span><span class="s1">leaf_size</span><span class="s4">,</span>
        <span class="s1">metric</span><span class="s4">=</span><span class="s1">metric</span><span class="s4">,</span>
        <span class="s1">metric_params</span><span class="s4">=</span><span class="s1">metric_params</span><span class="s4">,</span>
        <span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">n_jobs</span><span class="s4">,</span>
        <span class="s1">p</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">).</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s1">neighbors_distances</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">nbrs</span><span class="s4">.</span><span class="s1">kneighbors</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">min_samples</span><span class="s4">, </span><span class="s1">return_distance</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s1">core_distances </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ascontiguousarray</span><span class="s4">(</span><span class="s1">neighbors_distances</span><span class="s4">[:, -</span><span class="s6">1</span><span class="s4">])</span>
    <span class="s1">dist_metric </span><span class="s4">= </span><span class="s1">DistanceMetric</span><span class="s4">.</span><span class="s1">get_metric</span><span class="s4">(</span><span class="s1">metric</span><span class="s4">, **</span><span class="s1">metric_params</span><span class="s4">)</span>

    <span class="s2"># Mutual reachability distance is implicit in mst_from_data_matrix</span>
    <span class="s1">min_spanning_tree </span><span class="s4">= </span><span class="s1">mst_from_data_matrix</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">core_distances</span><span class="s4">, </span><span class="s1">dist_metric</span><span class="s4">, </span><span class="s1">alpha</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">_process_mst</span><span class="s4">(</span><span class="s1">min_spanning_tree</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">remap_single_linkage_tree</span><span class="s4">(</span><span class="s1">tree</span><span class="s4">, </span><span class="s1">internal_to_raw</span><span class="s4">, </span><span class="s1">non_finite</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Takes an internal single_linkage_tree structure and adds back in a set of points 
    that were initially detected as non-finite and returns that new tree. 
    These points will all be merged into the final node at np.inf distance and 
    considered noise points. 
 
    Parameters 
    ---------- 
    tree : ndarray of shape (n_samples - 1,), dtype=HIERARCHY_dtype 
        The single-linkage tree tree (dendrogram) built from the MST. 
    internal_to_raw: dict 
        A mapping from internal integer index to the raw integer index 
    non_finite : ndarray 
        Boolean array of which entries in the raw data are non-finite 
    &quot;&quot;&quot;</span>
    <span class="s1">finite_count </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">internal_to_raw</span><span class="s4">)</span>

    <span class="s1">outlier_count </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">non_finite</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">tree</span><span class="s4">):</span>
        <span class="s1">left </span><span class="s4">= </span><span class="s1">tree</span><span class="s4">[</span><span class="s1">i</span><span class="s4">][</span><span class="s5">&quot;left_node&quot;</span><span class="s4">]</span>
        <span class="s1">right </span><span class="s4">= </span><span class="s1">tree</span><span class="s4">[</span><span class="s1">i</span><span class="s4">][</span><span class="s5">&quot;right_node&quot;</span><span class="s4">]</span>

        <span class="s3">if </span><span class="s1">left </span><span class="s4">&lt; </span><span class="s1">finite_count</span><span class="s4">:</span>
            <span class="s1">tree</span><span class="s4">[</span><span class="s1">i</span><span class="s4">][</span><span class="s5">&quot;left_node&quot;</span><span class="s4">] = </span><span class="s1">internal_to_raw</span><span class="s4">[</span><span class="s1">left</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">tree</span><span class="s4">[</span><span class="s1">i</span><span class="s4">][</span><span class="s5">&quot;left_node&quot;</span><span class="s4">] = </span><span class="s1">left </span><span class="s4">+ </span><span class="s1">outlier_count</span>
        <span class="s3">if </span><span class="s1">right </span><span class="s4">&lt; </span><span class="s1">finite_count</span><span class="s4">:</span>
            <span class="s1">tree</span><span class="s4">[</span><span class="s1">i</span><span class="s4">][</span><span class="s5">&quot;right_node&quot;</span><span class="s4">] = </span><span class="s1">internal_to_raw</span><span class="s4">[</span><span class="s1">right</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">tree</span><span class="s4">[</span><span class="s1">i</span><span class="s4">][</span><span class="s5">&quot;right_node&quot;</span><span class="s4">] = </span><span class="s1">right </span><span class="s4">+ </span><span class="s1">outlier_count</span>

    <span class="s1">outlier_tree </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">non_finite</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">HIERARCHY_dtype</span><span class="s4">)</span>
    <span class="s1">last_cluster_id </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span>
        <span class="s1">tree</span><span class="s4">[</span><span class="s1">tree</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] - </span><span class="s6">1</span><span class="s4">][</span><span class="s5">&quot;left_node&quot;</span><span class="s4">], </span><span class="s1">tree</span><span class="s4">[</span><span class="s1">tree</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] - </span><span class="s6">1</span><span class="s4">][</span><span class="s5">&quot;right_node&quot;</span><span class="s4">]</span>
    <span class="s4">)</span>
    <span class="s1">last_cluster_size </span><span class="s4">= </span><span class="s1">tree</span><span class="s4">[</span><span class="s1">tree</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] - </span><span class="s6">1</span><span class="s4">][</span><span class="s5">&quot;cluster_size&quot;</span><span class="s4">]</span>
    <span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">outlier </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">non_finite</span><span class="s4">):</span>
        <span class="s1">outlier_tree</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = (</span><span class="s1">outlier</span><span class="s4">, </span><span class="s1">last_cluster_id </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span><span class="s4">, </span><span class="s1">last_cluster_size </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">)</span>
        <span class="s1">last_cluster_id </span><span class="s4">+= </span><span class="s6">1</span>
        <span class="s1">last_cluster_size </span><span class="s4">+= </span><span class="s6">1</span>
    <span class="s1">tree </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">concatenate</span><span class="s4">([</span><span class="s1">tree</span><span class="s4">, </span><span class="s1">outlier_tree</span><span class="s4">])</span>
    <span class="s3">return </span><span class="s1">tree</span>


<span class="s3">def </span><span class="s1">_get_finite_row_indices</span><span class="s4">(</span><span class="s1">matrix</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns the indices of the purely finite rows of a 
    sparse matrix or dense ndarray 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">matrix</span><span class="s4">):</span>
        <span class="s1">row_indices </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span>
            <span class="s4">[</span><span class="s1">i </span><span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">row </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">matrix</span><span class="s4">.</span><span class="s1">tolil</span><span class="s4">().</span><span class="s1">data</span><span class="s4">) </span><span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">all</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">isfinite</span><span class="s4">(</span><span class="s1">row</span><span class="s4">))]</span>
        <span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s4">(</span><span class="s1">row_indices</span><span class="s4">,) = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isfinite</span><span class="s4">(</span><span class="s1">matrix</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)).</span><span class="s1">nonzero</span><span class="s4">()</span>
    <span class="s3">return </span><span class="s1">row_indices</span>


<span class="s3">class </span><span class="s1">HDBSCAN</span><span class="s4">(</span><span class="s1">ClusterMixin</span><span class="s4">, </span><span class="s1">BaseEstimator</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Cluster data using hierarchical density-based clustering. 
 
    HDBSCAN - Hierarchical Density-Based Spatial Clustering of Applications 
    with Noise. Performs :class:`~sklearn.cluster.DBSCAN` over varying epsilon 
    values and integrates the result to find a clustering that gives the best 
    stability over epsilon. 
    This allows HDBSCAN to find clusters of varying densities (unlike 
    :class:`~sklearn.cluster.DBSCAN`), and be more robust to parameter selection. 
    Read more in the :ref:`User Guide &lt;hdbscan&gt;`. 
 
    For an example of how to use HDBSCAN, as well as a comparison to 
    :class:`~sklearn.cluster.DBSCAN`, please see the :ref:`plotting demo 
    &lt;sphx_glr_auto_examples_cluster_plot_hdbscan.py&gt;`. 
 
    .. versionadded:: 1.3 
 
    Parameters 
    ---------- 
    min_cluster_size : int, default=5 
        The minimum number of samples in a group for that group to be 
        considered a cluster; groupings smaller than this size will be left 
        as noise. 
 
    min_samples : int, default=None 
        The parameter `k` used to calculate the distance between a point 
        `x_p` and its k-th nearest neighbor. 
        When `None`, defaults to `min_cluster_size`. 
 
    cluster_selection_epsilon : float, default=0.0 
        A distance threshold. Clusters below this value will be merged. 
        See [5]_ for more information. 
 
    max_cluster_size : int, default=None 
        A limit to the size of clusters returned by the `&quot;eom&quot;` cluster 
        selection algorithm. There is no limit when `max_cluster_size=None`. 
        Has no effect if `cluster_selection_method=&quot;leaf&quot;`. 
 
    metric : str or callable, default='euclidean' 
        The metric to use when calculating distance between instances in a 
        feature array. 
 
        - If metric is a string or callable, it must be one of 
          the options allowed by :func:`~sklearn.metrics.pairwise_distances` 
          for its metric parameter. 
 
        - If metric is &quot;precomputed&quot;, X is assumed to be a distance matrix and 
          must be square. 
 
    metric_params : dict, default=None 
        Arguments passed to the distance metric. 
 
    alpha : float, default=1.0 
        A distance scaling parameter as used in robust single linkage. 
        See [3]_ for more information. 
 
    algorithm : {&quot;auto&quot;, &quot;brute&quot;, &quot;kd_tree&quot;, &quot;ball_tree&quot;}, default=&quot;auto&quot; 
        Exactly which algorithm to use for computing core distances; By default 
        this is set to `&quot;auto&quot;` which attempts to use a 
        :class:`~sklearn.neighbors.KDTree` tree if possible, otherwise it uses 
        a :class:`~sklearn.neighbors.BallTree` tree. Both `&quot;kd_tree&quot;` and 
        `&quot;ball_tree&quot;` algorithms use the 
        :class:`~sklearn.neighbors.NearestNeighbors` estimator. 
 
        If the `X` passed during `fit` is sparse or `metric` is invalid for 
        both :class:`~sklearn.neighbors.KDTree` and 
        :class:`~sklearn.neighbors.BallTree`, then it resolves to use the 
        `&quot;brute&quot;` algorithm. 
 
        .. deprecated:: 1.4 
           The `'kdtree'` option was deprecated in version 1.4, 
           and will be renamed to `'kd_tree'` in 1.6. 
 
        .. deprecated:: 1.4 
           The `'balltree'` option was deprecated in version 1.4, 
           and will be renamed to `'ball_tree'` in 1.6. 
 
    leaf_size : int, default=40 
        Leaf size for trees responsible for fast nearest neighbour queries when 
        a KDTree or a BallTree are used as core-distance algorithms. A large 
        dataset size and small `leaf_size` may induce excessive memory usage. 
        If you are running out of memory consider increasing the `leaf_size` 
        parameter. Ignored for `algorithm=&quot;brute&quot;`. 
 
    n_jobs : int, default=None 
        Number of jobs to run in parallel to calculate distances. 
        `None` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        `-1` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    cluster_selection_method : {&quot;eom&quot;, &quot;leaf&quot;}, default=&quot;eom&quot; 
        The method used to select clusters from the condensed tree. The 
        standard approach for HDBSCAN* is to use an Excess of Mass (`&quot;eom&quot;`) 
        algorithm to find the most persistent clusters. Alternatively you can 
        instead select the clusters at the leaves of the tree -- this provides 
        the most fine grained and homogeneous clusters. 
 
    allow_single_cluster : bool, default=False 
        By default HDBSCAN* will not produce a single cluster, setting this 
        to True will override this and allow single cluster results in 
        the case that you feel this is a valid result for your dataset. 
 
    store_centers : str, default=None 
        Which, if any, cluster centers to compute and store. The options are: 
 
        - `None` which does not compute nor store any centers. 
        - `&quot;centroid&quot;` which calculates the center by taking the weighted 
          average of their positions. Note that the algorithm uses the 
          euclidean metric and does not guarantee that the output will be 
          an observed data point. 
        - `&quot;medoid&quot;` which calculates the center by taking the point in the 
          fitted data which minimizes the distance to all other points in 
          the cluster. This is slower than &quot;centroid&quot; since it requires 
          computing additional pairwise distances between points of the 
          same cluster but guarantees the output is an observed data point. 
          The medoid is also well-defined for arbitrary metrics, and does not 
          depend on a euclidean metric. 
        - `&quot;both&quot;` which computes and stores both forms of centers. 
 
    copy : bool, default=False 
        If `copy=True` then any time an in-place modifications would be made 
        that would overwrite data passed to :term:`fit`, a copy will first be 
        made, guaranteeing that the original data will be unchanged. 
        Currently, it only applies when `metric=&quot;precomputed&quot;`, when passing 
        a dense array or a CSR sparse matrix and when `algorithm=&quot;brute&quot;`. 
 
    Attributes 
    ---------- 
    labels_ : ndarray of shape (n_samples,) 
        Cluster labels for each point in the dataset given to :term:`fit`. 
        Outliers are labeled as follows: 
 
        - Noisy samples are given the label -1. 
        - Samples with infinite elements (+/- np.inf) are given the label -2. 
        - Samples with missing data are given the label -3, even if they 
          also have infinite elements. 
 
    probabilities_ : ndarray of shape (n_samples,) 
        The strength with which each sample is a member of its assigned 
        cluster. 
 
        - Clustered samples have probabilities proportional to the degree that 
          they persist as part of the cluster. 
        - Noisy samples have probability zero. 
        - Samples with infinite elements (+/- np.inf) have probability 0. 
        - Samples with missing data have probability `np.nan`. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
    centroids_ : ndarray of shape (n_clusters, n_features) 
        A collection containing the centroid of each cluster calculated under 
        the standard euclidean metric. The centroids may fall &quot;outside&quot; their 
        respective clusters if the clusters themselves are non-convex. 
 
        Note that `n_clusters` only counts non-outlier clusters. That is to 
        say, the `-1, -2, -3` labels for the outlier clusters are excluded. 
 
    medoids_ : ndarray of shape (n_clusters, n_features) 
        A collection containing the medoid of each cluster calculated under 
        the whichever metric was passed to the `metric` parameter. The 
        medoids are points in the original cluster which minimize the average 
        distance to all other points in that cluster under the chosen metric. 
        These can be thought of as the result of projecting the `metric`-based 
        centroid back onto the cluster. 
 
        Note that `n_clusters` only counts non-outlier clusters. That is to 
        say, the `-1, -2, -3` labels for the outlier clusters are excluded. 
 
    See Also 
    -------- 
    DBSCAN : Density-Based Spatial Clustering of Applications 
        with Noise. 
    OPTICS : Ordering Points To Identify the Clustering Structure. 
    Birch : Memory-efficient, online-learning algorithm. 
 
    Notes 
    ----- 
    The `min_samples` parameter includes the point itself, whereas the implementation in 
    `scikit-learn-contrib/hdbscan &lt;https://github.com/scikit-learn-contrib/hdbscan&gt;`_ 
    does not. To get the same results in both versions, the value of `min_samples` here 
    must be 1 greater than the value used in `scikit-learn-contrib/hdbscan 
    &lt;https://github.com/scikit-learn-contrib/hdbscan&gt;`_. 
 
    References 
    ---------- 
 
    .. [1] :doi:`Campello, R. J., Moulavi, D., &amp; Sander, J. Density-based clustering 
      based on hierarchical density estimates. 
      &lt;10.1007/978-3-642-37456-2_14&gt;` 
    .. [2] :doi:`Campello, R. J., Moulavi, D., Zimek, A., &amp; Sander, J. 
       Hierarchical density estimates for data clustering, visualization, 
       and outlier detection.&lt;10.1145/2733381&gt;` 
 
    .. [3] `Chaudhuri, K., &amp; Dasgupta, S. Rates of convergence for the 
       cluster tree. 
       &lt;https://papers.nips.cc/paper/2010/hash/ 
       b534ba68236ba543ae44b22bd110a1d6-Abstract.html&gt;`_ 
 
    .. [4] `Moulavi, D., Jaskowiak, P.A., Campello, R.J., Zimek, A. and 
       Sander, J. Density-Based Clustering Validation. 
       &lt;https://www.dbs.ifi.lmu.de/~zimek/publications/SDM2014/DBCV.pdf&gt;`_ 
 
    .. [5] :arxiv:`Malzer, C., &amp; Baum, M. &quot;A Hybrid Approach To Hierarchical 
       Density-based Cluster Selection.&quot;&lt;1911.02282&gt;`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.cluster import HDBSCAN 
    &gt;&gt;&gt; from sklearn.datasets import load_digits 
    &gt;&gt;&gt; X, _ = load_digits(return_X_y=True) 
    &gt;&gt;&gt; hdb = HDBSCAN(min_cluster_size=20) 
    &gt;&gt;&gt; hdb.fit(X) 
    HDBSCAN(min_cluster_size=20) 
    &gt;&gt;&gt; hdb.labels_ 
    array([ 2,  6, -1, ..., -1, -1, -1]) 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints </span><span class="s4">= {</span>
        <span class="s5">&quot;min_cluster_size&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s1">left</span><span class="s4">=</span><span class="s6">2</span><span class="s4">, </span><span class="s1">right</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;min_samples&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s1">left</span><span class="s4">=</span><span class="s6">1</span><span class="s4">, </span><span class="s1">right</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">), </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;cluster_selection_epsilon&quot;</span><span class="s4">: [</span>
            <span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s1">left</span><span class="s4">=</span><span class="s6">0</span><span class="s4">, </span><span class="s1">right</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)</span>
        <span class="s4">],</span>
        <span class="s5">&quot;max_cluster_size&quot;</span><span class="s4">: [</span>
            <span class="s3">None</span><span class="s4">,</span>
            <span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s1">left</span><span class="s4">=</span><span class="s6">1</span><span class="s4">, </span><span class="s1">right</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">),</span>
        <span class="s4">],</span>
        <span class="s5">&quot;metric&quot;</span><span class="s4">: [</span>
            <span class="s1">StrOptions</span><span class="s4">(</span><span class="s1">FAST_METRICS </span><span class="s4">| </span><span class="s1">set</span><span class="s4">(</span><span class="s1">_VALID_METRICS</span><span class="s4">) | {</span><span class="s5">&quot;precomputed&quot;</span><span class="s4">}),</span>
            <span class="s1">callable</span><span class="s4">,</span>
        <span class="s4">],</span>
        <span class="s5">&quot;metric_params&quot;</span><span class="s4">: [</span><span class="s1">dict</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;alpha&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s1">left</span><span class="s4">=</span><span class="s6">0</span><span class="s4">, </span><span class="s1">right</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;neither&quot;</span><span class="s4">)],</span>
        <span class="s2"># TODO(1.6): Remove &quot;kdtree&quot; and &quot;balltree&quot;  option</span>
        <span class="s5">&quot;algorithm&quot;</span><span class="s4">: [</span>
            <span class="s1">StrOptions</span><span class="s4">(</span>
                <span class="s4">{</span><span class="s5">&quot;auto&quot;</span><span class="s4">, </span><span class="s5">&quot;brute&quot;</span><span class="s4">, </span><span class="s5">&quot;kd_tree&quot;</span><span class="s4">, </span><span class="s5">&quot;ball_tree&quot;</span><span class="s4">, </span><span class="s5">&quot;kdtree&quot;</span><span class="s4">, </span><span class="s5">&quot;balltree&quot;</span><span class="s4">},</span>
                <span class="s1">deprecated</span><span class="s4">={</span><span class="s5">&quot;kdtree&quot;</span><span class="s4">, </span><span class="s5">&quot;balltree&quot;</span><span class="s4">},</span>
            <span class="s4">),</span>
        <span class="s4">],</span>
        <span class="s5">&quot;leaf_size&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s1">left</span><span class="s4">=</span><span class="s6">1</span><span class="s4">, </span><span class="s1">right</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;n_jobs&quot;</span><span class="s4">: [</span><span class="s1">Integral</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;cluster_selection_method&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;eom&quot;</span><span class="s4">, </span><span class="s5">&quot;leaf&quot;</span><span class="s4">})],</span>
        <span class="s5">&quot;allow_single_cluster&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;store_centers&quot;</span><span class="s4">: [</span><span class="s3">None</span><span class="s4">, </span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;centroid&quot;</span><span class="s4">, </span><span class="s5">&quot;medoid&quot;</span><span class="s4">, </span><span class="s5">&quot;both&quot;</span><span class="s4">})],</span>
        <span class="s5">&quot;copy&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
    <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">min_cluster_size</span><span class="s4">=</span><span class="s6">5</span><span class="s4">,</span>
        <span class="s1">min_samples</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">cluster_selection_epsilon</span><span class="s4">=</span><span class="s6">0.0</span><span class="s4">,</span>
        <span class="s1">max_cluster_size</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">metric</span><span class="s4">=</span><span class="s5">&quot;euclidean&quot;</span><span class="s4">,</span>
        <span class="s1">metric_params</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">alpha</span><span class="s4">=</span><span class="s6">1.0</span><span class="s4">,</span>
        <span class="s1">algorithm</span><span class="s4">=</span><span class="s5">&quot;auto&quot;</span><span class="s4">,</span>
        <span class="s1">leaf_size</span><span class="s4">=</span><span class="s6">40</span><span class="s4">,</span>
        <span class="s1">n_jobs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">cluster_selection_method</span><span class="s4">=</span><span class="s5">&quot;eom&quot;</span><span class="s4">,</span>
        <span class="s1">allow_single_cluster</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">store_centers</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">copy</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">min_cluster_size </span><span class="s4">= </span><span class="s1">min_cluster_size</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">min_samples </span><span class="s4">= </span><span class="s1">min_samples</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">alpha </span><span class="s4">= </span><span class="s1">alpha</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">max_cluster_size </span><span class="s4">= </span><span class="s1">max_cluster_size</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">cluster_selection_epsilon </span><span class="s4">= </span><span class="s1">cluster_selection_epsilon</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">metric </span><span class="s4">= </span><span class="s1">metric</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">metric_params </span><span class="s4">= </span><span class="s1">metric_params</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">algorithm </span><span class="s4">= </span><span class="s1">algorithm</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">leaf_size </span><span class="s4">= </span><span class="s1">leaf_size</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs </span><span class="s4">= </span><span class="s1">n_jobs</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">cluster_selection_method </span><span class="s4">= </span><span class="s1">cluster_selection_method</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">allow_single_cluster </span><span class="s4">= </span><span class="s1">allow_single_cluster</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">store_centers </span><span class="s4">= </span><span class="s1">store_centers</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">copy </span><span class="s4">= </span><span class="s1">copy</span>

    <span class="s4">@</span><span class="s1">_fit_context</span><span class="s4">(</span>
        <span class="s2"># HDBSCAN.metric is not validated yet</span>
        <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">False</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Find clusters based on hierarchical density-based clustering. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features), or \ 
                ndarray of shape (n_samples, n_samples) 
            A feature array, or array of distances between samples if 
            `metric='precomputed'`. 
 
        y : None 
            Ignored. 
 
        Returns 
        ------- 
        self : object 
            Returns self. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">metric </span><span class="s4">== </span><span class="s5">&quot;precomputed&quot; </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">store_centers </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;Cannot store centers when using a precomputed distance matrix.&quot;</span>
            <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_metric_params </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">metric_params </span><span class="s3">or </span><span class="s4">{}</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">metric </span><span class="s4">!= </span><span class="s5">&quot;precomputed&quot;</span><span class="s4">:</span>
            <span class="s2"># Non-precomputed matrices may contain non-finite values.</span>
            <span class="s1">X </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">,</span>
                <span class="s1">accept_sparse</span><span class="s4">=[</span><span class="s5">&quot;csr&quot;</span><span class="s4">, </span><span class="s5">&quot;lil&quot;</span><span class="s4">],</span>
                <span class="s1">force_all_finite</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                <span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_data </span><span class="s4">= </span><span class="s1">X</span>
            <span class="s1">all_finite </span><span class="s4">= </span><span class="s3">True</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">_assert_all_finite</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">data </span><span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">else </span><span class="s1">X</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s1">ValueError</span><span class="s4">:</span>
                <span class="s1">all_finite </span><span class="s4">= </span><span class="s3">False</span>

            <span class="s3">if not </span><span class="s1">all_finite</span><span class="s4">:</span>
                <span class="s2"># Pass only the purely finite indices into hdbscan</span>
                <span class="s2"># We will later assign all non-finite points their</span>
                <span class="s2"># corresponding labels, as specified in `_OUTLIER_ENCODING`</span>

                <span class="s2"># Reduce X to make the checks for missing/outlier samples more</span>
                <span class="s2"># convenient.</span>
                <span class="s1">reduced_X </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>

                <span class="s2"># Samples with missing data are denoted by the presence of</span>
                <span class="s2"># `np.nan`</span>
                <span class="s1">missing_index </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isnan</span><span class="s4">(</span><span class="s1">reduced_X</span><span class="s4">).</span><span class="s1">nonzero</span><span class="s4">()[</span><span class="s6">0</span><span class="s4">]</span>

                <span class="s2"># Outlier samples are denoted by the presence of `np.inf`</span>
                <span class="s1">infinite_index </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isinf</span><span class="s4">(</span><span class="s1">reduced_X</span><span class="s4">).</span><span class="s1">nonzero</span><span class="s4">()[</span><span class="s6">0</span><span class="s4">]</span>

                <span class="s2"># Continue with only finite samples</span>
                <span class="s1">finite_index </span><span class="s4">= </span><span class="s1">_get_finite_row_indices</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
                <span class="s1">internal_to_raw </span><span class="s4">= {</span><span class="s1">x</span><span class="s4">: </span><span class="s1">y </span><span class="s3">for </span><span class="s1">x</span><span class="s4">, </span><span class="s1">y </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">finite_index</span><span class="s4">)}</span>
                <span class="s1">X </span><span class="s4">= </span><span class="s1">X</span><span class="s4">[</span><span class="s1">finite_index</span><span class="s4">]</span>
        <span class="s3">elif </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">):</span>
            <span class="s2"># Handle sparse precomputed distance matrices separately</span>
            <span class="s1">X </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">,</span>
                <span class="s1">accept_sparse</span><span class="s4">=[</span><span class="s5">&quot;csr&quot;</span><span class="s4">, </span><span class="s5">&quot;lil&quot;</span><span class="s4">],</span>
                <span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">,</span>
                <span class="s1">force_writeable</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># Only non-sparse, precomputed distance matrices are handled here</span>
            <span class="s2"># and thereby allowed to contain numpy.inf for missing distances</span>

            <span class="s2"># Perform data validation after removing infinite values (numpy.inf)</span>
            <span class="s2"># from the given distance matrix.</span>
            <span class="s1">X </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">, </span><span class="s1">force_all_finite</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">force_writeable</span><span class="s4">=</span><span class="s3">True</span>
            <span class="s4">)</span>
            <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isnan</span><span class="s4">(</span><span class="s1">X</span><span class="s4">).</span><span class="s1">any</span><span class="s4">():</span>
                <span class="s2"># TODO: Support np.nan in Cython implementation for precomputed</span>
                <span class="s2"># dense HDBSCAN</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;np.nan values found in precomputed-dense&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;n_samples=1 while HDBSCAN requires more than one sample&quot;</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_min_samples </span><span class="s4">= (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">min_cluster_size </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">min_samples </span><span class="s3">is None else </span><span class="s1">self</span><span class="s4">.</span><span class="s1">min_samples</span>
        <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_min_samples </span><span class="s4">&gt; </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">f&quot;min_samples (</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_min_samples</span><span class="s3">}</span><span class="s5">) must be at most the number of&quot;</span>
                <span class="s5">f&quot; samples in X (</span><span class="s3">{</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span><span class="s3">}</span><span class="s5">)&quot;</span>
            <span class="s4">)</span>

        <span class="s2"># TODO(1.6): Remove</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">algorithm </span><span class="s4">== </span><span class="s5">&quot;kdtree&quot;</span><span class="s4">:</span>
            <span class="s1">warn</span><span class="s4">(</span>
                <span class="s4">(</span>
                    <span class="s5">&quot;`algorithm='kdtree'`has been deprecated in 1.4 and will be renamed&quot;</span>
                    <span class="s5">&quot; to'kd_tree'`in 1.6. To keep the past behaviour, set&quot;</span>
                    <span class="s5">&quot; `algorithm='kd_tree'`.&quot;</span>
                <span class="s4">),</span>
                <span class="s1">FutureWarning</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">algorithm </span><span class="s4">= </span><span class="s5">&quot;kd_tree&quot;</span>

        <span class="s2"># TODO(1.6): Remove</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">algorithm </span><span class="s4">== </span><span class="s5">&quot;balltree&quot;</span><span class="s4">:</span>
            <span class="s1">warn</span><span class="s4">(</span>
                <span class="s4">(</span>
                    <span class="s5">&quot;`algorithm='balltree'`has been deprecated in 1.4 and will be&quot;</span>
                    <span class="s5">&quot; renamed to'ball_tree'`in 1.6. To keep the past behaviour, set&quot;</span>
                    <span class="s5">&quot; `algorithm='ball_tree'`.&quot;</span>
                <span class="s4">),</span>
                <span class="s1">FutureWarning</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">algorithm </span><span class="s4">= </span><span class="s5">&quot;ball_tree&quot;</span>

        <span class="s1">mst_func </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">kwargs </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">=</span><span class="s1">X</span><span class="s4">,</span>
            <span class="s1">min_samples</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_min_samples</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">metric</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">metric</span><span class="s4">,</span>
            <span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs</span><span class="s4">,</span>
            <span class="s4">**</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_metric_params</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">algorithm </span><span class="s4">== </span><span class="s5">&quot;kd_tree&quot; </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">metric </span><span class="s3">not in </span><span class="s1">KDTree</span><span class="s4">.</span><span class="s1">valid_metrics</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">metric</span><span class="s3">} </span><span class="s5">is not a valid metric for a KDTree-based algorithm.&quot;</span>
                <span class="s5">&quot; Please select a different metric.&quot;</span>
            <span class="s4">)</span>
        <span class="s3">elif </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">algorithm </span><span class="s4">== </span><span class="s5">&quot;ball_tree&quot; </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">metric </span><span class="s3">not in </span><span class="s1">BallTree</span><span class="s4">.</span><span class="s1">valid_metrics</span>
        <span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">metric</span><span class="s3">} </span><span class="s5">is not a valid metric for a BallTree-based algorithm.&quot;</span>
                <span class="s5">&quot; Please select a different metric.&quot;</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">algorithm </span><span class="s4">!= </span><span class="s5">&quot;auto&quot;</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">metric </span><span class="s4">!= </span><span class="s5">&quot;precomputed&quot;</span>
                <span class="s3">and </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
                <span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">algorithm </span><span class="s4">!= </span><span class="s5">&quot;brute&quot;</span>
            <span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Sparse data matrices only support algorithm `brute`.&quot;</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">algorithm </span><span class="s4">== </span><span class="s5">&quot;brute&quot;</span><span class="s4">:</span>
                <span class="s1">mst_func </span><span class="s4">= </span><span class="s1">_hdbscan_brute</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s5">&quot;copy&quot;</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">copy</span>
            <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">algorithm </span><span class="s4">== </span><span class="s5">&quot;kd_tree&quot;</span><span class="s4">:</span>
                <span class="s1">mst_func </span><span class="s4">= </span><span class="s1">_hdbscan_prims</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s5">&quot;algo&quot;</span><span class="s4">] = </span><span class="s5">&quot;kd_tree&quot;</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s5">&quot;leaf_size&quot;</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">leaf_size</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">mst_func </span><span class="s4">= </span><span class="s1">_hdbscan_prims</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s5">&quot;algo&quot;</span><span class="s4">] = </span><span class="s5">&quot;ball_tree&quot;</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s5">&quot;leaf_size&quot;</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">leaf_size</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">metric </span><span class="s3">not in </span><span class="s1">FAST_METRICS</span><span class="s4">:</span>
                <span class="s2"># We can't do much with sparse matrices ...</span>
                <span class="s1">mst_func </span><span class="s4">= </span><span class="s1">_hdbscan_brute</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s5">&quot;copy&quot;</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">copy</span>
            <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">metric </span><span class="s3">in </span><span class="s1">KDTree</span><span class="s4">.</span><span class="s1">valid_metrics</span><span class="s4">:</span>
                <span class="s2"># TODO: Benchmark KD vs Ball Tree efficiency</span>
                <span class="s1">mst_func </span><span class="s4">= </span><span class="s1">_hdbscan_prims</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s5">&quot;algo&quot;</span><span class="s4">] = </span><span class="s5">&quot;kd_tree&quot;</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s5">&quot;leaf_size&quot;</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">leaf_size</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s2"># Metric is a valid BallTree metric</span>
                <span class="s1">mst_func </span><span class="s4">= </span><span class="s1">_hdbscan_prims</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s5">&quot;algo&quot;</span><span class="s4">] = </span><span class="s5">&quot;ball_tree&quot;</span>
                <span class="s1">kwargs</span><span class="s4">[</span><span class="s5">&quot;leaf_size&quot;</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">leaf_size</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_single_linkage_tree_ </span><span class="s4">= </span><span class="s1">mst_func</span><span class="s4">(**</span><span class="s1">kwargs</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">probabilities_ </span><span class="s4">= </span><span class="s1">tree_to_labels</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_single_linkage_tree_</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">min_cluster_size</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">cluster_selection_method</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">allow_single_cluster</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">cluster_selection_epsilon</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">max_cluster_size</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">metric </span><span class="s4">!= </span><span class="s5">&quot;precomputed&quot; </span><span class="s3">and not </span><span class="s1">all_finite</span><span class="s4">:</span>
            <span class="s2"># Remap indices to align with original data in the case of</span>
            <span class="s2"># non-finite entries. Samples with np.inf are mapped to -1 and</span>
            <span class="s2"># those with np.nan are mapped to -2.</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_single_linkage_tree_ </span><span class="s4">= </span><span class="s1">remap_single_linkage_tree</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_single_linkage_tree_</span><span class="s4">,</span>
                <span class="s1">internal_to_raw</span><span class="s4">,</span>
                <span class="s2"># There may be overlap for points w/ both `np.inf` and `np.nan`</span>
                <span class="s1">non_finite</span><span class="s4">=</span><span class="s1">set</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">([</span><span class="s1">infinite_index</span><span class="s4">, </span><span class="s1">missing_index</span><span class="s4">])),</span>
            <span class="s4">)</span>
            <span class="s1">new_labels </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_data</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">int32</span><span class="s4">)</span>
            <span class="s1">new_labels</span><span class="s4">[</span><span class="s1">finite_index</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels_</span>
            <span class="s1">new_labels</span><span class="s4">[</span><span class="s1">infinite_index</span><span class="s4">] = </span><span class="s1">_OUTLIER_ENCODING</span><span class="s4">[</span><span class="s5">&quot;infinite&quot;</span><span class="s4">][</span><span class="s5">&quot;label&quot;</span><span class="s4">]</span>
            <span class="s1">new_labels</span><span class="s4">[</span><span class="s1">missing_index</span><span class="s4">] = </span><span class="s1">_OUTLIER_ENCODING</span><span class="s4">[</span><span class="s5">&quot;missing&quot;</span><span class="s4">][</span><span class="s5">&quot;label&quot;</span><span class="s4">]</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">labels_ </span><span class="s4">= </span><span class="s1">new_labels</span>

            <span class="s1">new_probabilities </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_data</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>
            <span class="s1">new_probabilities</span><span class="s4">[</span><span class="s1">finite_index</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">probabilities_</span>
            <span class="s2"># Infinite outliers have probability 0 by convention, though this</span>
            <span class="s2"># is arbitrary.</span>
            <span class="s1">new_probabilities</span><span class="s4">[</span><span class="s1">infinite_index</span><span class="s4">] = </span><span class="s1">_OUTLIER_ENCODING</span><span class="s4">[</span><span class="s5">&quot;infinite&quot;</span><span class="s4">][</span><span class="s5">&quot;prob&quot;</span><span class="s4">]</span>
            <span class="s1">new_probabilities</span><span class="s4">[</span><span class="s1">missing_index</span><span class="s4">] = </span><span class="s1">_OUTLIER_ENCODING</span><span class="s4">[</span><span class="s5">&quot;missing&quot;</span><span class="s4">][</span><span class="s5">&quot;prob&quot;</span><span class="s4">]</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">probabilities_ </span><span class="s4">= </span><span class="s1">new_probabilities</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">store_centers</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_weighted_cluster_center</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">fit_predict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Cluster X and return the associated cluster labels. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features), or \ 
                ndarray of shape (n_samples, n_samples) 
            A feature array, or array of distances between samples if 
            `metric='precomputed'`. 
 
        y : None 
            Ignored. 
 
        Returns 
        ------- 
        y : ndarray of shape (n_samples,) 
            Cluster labels. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels_</span>

    <span class="s3">def </span><span class="s1">_weighted_cluster_center</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Calculate and store the centroids/medoids of each cluster. 
 
        This requires `X` to be a raw feature array, not precomputed 
        distances. Rather than return outputs directly, this helper method 
        instead stores them in the `self.{centroids, medoids}_` attributes. 
        The choice for which attributes are calculated and stored is mediated 
        by the value of `self.store_centers`. 
 
        Parameters 
        ---------- 
        X : ndarray of shape (n_samples, n_features) 
            The feature array that the estimator was fit with. 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># Number of non-noise clusters</span>
        <span class="s1">n_clusters </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels_</span><span class="s4">) - {-</span><span class="s6">1</span><span class="s4">, -</span><span class="s6">2</span><span class="s4">})</span>
        <span class="s1">mask </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">((</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">],), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">bool_</span><span class="s4">)</span>
        <span class="s1">make_centroids </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">store_centers </span><span class="s3">in </span><span class="s4">(</span><span class="s5">&quot;centroid&quot;</span><span class="s4">, </span><span class="s5">&quot;both&quot;</span><span class="s4">)</span>
        <span class="s1">make_medoids </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">store_centers </span><span class="s3">in </span><span class="s4">(</span><span class="s5">&quot;medoid&quot;</span><span class="s4">, </span><span class="s5">&quot;both&quot;</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">make_centroids</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">centroids_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">((</span><span class="s1">n_clusters</span><span class="s4">, </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">make_medoids</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">medoids_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">((</span><span class="s1">n_clusters</span><span class="s4">, </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>

        <span class="s2"># Need to handle iteratively seen each cluster may have a different</span>
        <span class="s2"># number of samples, hence we can't create a homogeneous 3D array.</span>
        <span class="s3">for </span><span class="s1">idx </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">n_clusters</span><span class="s4">):</span>
            <span class="s1">mask </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels_ </span><span class="s4">== </span><span class="s1">idx</span>
            <span class="s1">data </span><span class="s4">= </span><span class="s1">X</span><span class="s4">[</span><span class="s1">mask</span><span class="s4">]</span>
            <span class="s1">strength </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">probabilities_</span><span class="s4">[</span><span class="s1">mask</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">make_centroids</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">centroids_</span><span class="s4">[</span><span class="s1">idx</span><span class="s4">] = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">average</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">weights</span><span class="s4">=</span><span class="s1">strength</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">0</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">make_medoids</span><span class="s4">:</span>
                <span class="s2"># TODO: Implement weighted argmin PWD backend</span>
                <span class="s1">dist_mat </span><span class="s4">= </span><span class="s1">pairwise_distances</span><span class="s4">(</span>
                    <span class="s1">data</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">metric</span><span class="s4">, **</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_metric_params</span>
                <span class="s4">)</span>
                <span class="s1">dist_mat </span><span class="s4">= </span><span class="s1">dist_mat </span><span class="s4">* </span><span class="s1">strength</span>
                <span class="s1">medoid_index </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">argmin</span><span class="s4">(</span><span class="s1">dist_mat</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s6">1</span><span class="s4">))</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">medoids_</span><span class="s4">[</span><span class="s1">idx</span><span class="s4">] = </span><span class="s1">data</span><span class="s4">[</span><span class="s1">medoid_index</span><span class="s4">]</span>
        <span class="s3">return</span>

    <span class="s3">def </span><span class="s1">dbscan_clustering</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">cut_distance</span><span class="s4">, </span><span class="s1">min_cluster_size</span><span class="s4">=</span><span class="s6">5</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return clustering given by DBSCAN without border points. 
 
        Return clustering that would be equivalent to running DBSCAN* for a 
        particular cut_distance (or epsilon) DBSCAN* can be thought of as 
        DBSCAN without the border points.  As such these results may differ 
        slightly from `cluster.DBSCAN` due to the difference in implementation 
        over the non-core points. 
 
        This can also be thought of as a flat clustering derived from constant 
        height cut through the single linkage tree. 
 
        This represents the result of selecting a cut value for robust single linkage 
        clustering. The `min_cluster_size` allows the flat clustering to declare noise 
        points (and cluster smaller than `min_cluster_size`). 
 
        Parameters 
        ---------- 
        cut_distance : float 
            The mutual reachability distance cut value to use to generate a 
            flat clustering. 
 
        min_cluster_size : int, default=5 
            Clusters smaller than this value with be called 'noise' and remain 
            unclustered in the resulting flat clustering. 
 
        Returns 
        ------- 
        labels : ndarray of shape (n_samples,) 
            An array of cluster labels, one per datapoint. 
            Outliers are labeled as follows: 
 
            - Noisy samples are given the label -1. 
            - Samples with infinite elements (+/- np.inf) are given the label -2. 
            - Samples with missing data are given the label -3, even if they 
              also have infinite elements. 
        &quot;&quot;&quot;</span>
        <span class="s1">labels </span><span class="s4">= </span><span class="s1">labelling_at_cut</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_single_linkage_tree_</span><span class="s4">, </span><span class="s1">cut_distance</span><span class="s4">, </span><span class="s1">min_cluster_size</span>
        <span class="s4">)</span>
        <span class="s2"># Infer indices from labels generated during `fit`</span>
        <span class="s1">infinite_index </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels_ </span><span class="s4">== </span><span class="s1">_OUTLIER_ENCODING</span><span class="s4">[</span><span class="s5">&quot;infinite&quot;</span><span class="s4">][</span><span class="s5">&quot;label&quot;</span><span class="s4">]</span>
        <span class="s1">missing_index </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">labels_ </span><span class="s4">== </span><span class="s1">_OUTLIER_ENCODING</span><span class="s4">[</span><span class="s5">&quot;missing&quot;</span><span class="s4">][</span><span class="s5">&quot;label&quot;</span><span class="s4">]</span>

        <span class="s2"># Overwrite infinite/missing outlier samples (otherwise simple noise)</span>
        <span class="s1">labels</span><span class="s4">[</span><span class="s1">infinite_index</span><span class="s4">] = </span><span class="s1">_OUTLIER_ENCODING</span><span class="s4">[</span><span class="s5">&quot;infinite&quot;</span><span class="s4">][</span><span class="s5">&quot;label&quot;</span><span class="s4">]</span>
        <span class="s1">labels</span><span class="s4">[</span><span class="s1">missing_index</span><span class="s4">] = </span><span class="s1">_OUTLIER_ENCODING</span><span class="s4">[</span><span class="s5">&quot;missing&quot;</span><span class="s4">][</span><span class="s5">&quot;label&quot;</span><span class="s4">]</span>
        <span class="s3">return </span><span class="s1">labels</span>

    <span class="s3">def </span><span class="s1">_more_tags</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">{</span><span class="s5">&quot;allow_nan&quot;</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">metric </span><span class="s4">!= </span><span class="s5">&quot;precomputed&quot;</span><span class="s4">}</span>
</pre>
</body>
</html>