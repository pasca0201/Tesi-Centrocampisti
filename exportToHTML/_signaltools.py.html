<html>
<head>
<title>_signaltools.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_signaltools.py</font>
</center></td></tr></table>
<pre><span class="s0"># Author: Travis Oliphant</span>
<span class="s0"># 1999 -- 2002</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations </span><span class="s0"># Provides typing union operator `|` in Python 3.9</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">from </span><span class="s1">math </span><span class="s2">import </span><span class="s1">prod </span><span class="s2">as </span><span class="s1">_prod</span>
<span class="s2">import </span><span class="s1">timeit</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Literal</span>

<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">ArrayLike</span>

<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">spatial </span><span class="s2">import </span><span class="s1">cKDTree</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_sigtools</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_ltisys </span><span class="s2">import </span><span class="s1">dlti</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_upfirdn </span><span class="s2">import </span><span class="s1">upfirdn</span><span class="s3">, </span><span class="s1">_output_len</span><span class="s3">, </span><span class="s1">_upfirdn_modes</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">linalg</span><span class="s3">, </span><span class="s1">fft </span><span class="s2">as </span><span class="s1">sp_fft</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">ndimage</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">fft</span><span class="s3">.</span><span class="s1">_helper </span><span class="s2">import </span><span class="s1">_init_nd_shape_and_axes</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special </span><span class="s2">import </span><span class="s1">lambertw</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">windows </span><span class="s2">import </span><span class="s1">get_window</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_arraytools </span><span class="s2">import </span><span class="s1">axis_slice</span><span class="s3">, </span><span class="s1">axis_reverse</span><span class="s3">, </span><span class="s1">odd_ext</span><span class="s3">, </span><span class="s1">even_ext</span><span class="s3">, </span><span class="s1">const_ext</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_filter_design </span><span class="s2">import </span><span class="s1">cheby1</span><span class="s3">, </span><span class="s1">_validate_sos</span><span class="s3">, </span><span class="s1">zpk2sos</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_fir_filter_design </span><span class="s2">import </span><span class="s1">firwin</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_sosfilt </span><span class="s2">import </span><span class="s1">_sosfilt</span>


<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">'correlate'</span><span class="s3">, </span><span class="s4">'correlation_lags'</span><span class="s3">, </span><span class="s4">'correlate2d'</span><span class="s3">,</span>
           <span class="s4">'convolve'</span><span class="s3">, </span><span class="s4">'convolve2d'</span><span class="s3">, </span><span class="s4">'fftconvolve'</span><span class="s3">, </span><span class="s4">'oaconvolve'</span><span class="s3">,</span>
           <span class="s4">'order_filter'</span><span class="s3">, </span><span class="s4">'medfilt'</span><span class="s3">, </span><span class="s4">'medfilt2d'</span><span class="s3">, </span><span class="s4">'wiener'</span><span class="s3">, </span><span class="s4">'lfilter'</span><span class="s3">,</span>
           <span class="s4">'lfiltic'</span><span class="s3">, </span><span class="s4">'sosfilt'</span><span class="s3">, </span><span class="s4">'deconvolve'</span><span class="s3">, </span><span class="s4">'hilbert'</span><span class="s3">, </span><span class="s4">'hilbert2'</span><span class="s3">,</span>
           <span class="s4">'cmplx_sort'</span><span class="s3">, </span><span class="s4">'unique_roots'</span><span class="s3">, </span><span class="s4">'invres'</span><span class="s3">, </span><span class="s4">'invresz'</span><span class="s3">, </span><span class="s4">'residue'</span><span class="s3">,</span>
           <span class="s4">'residuez'</span><span class="s3">, </span><span class="s4">'resample'</span><span class="s3">, </span><span class="s4">'resample_poly'</span><span class="s3">, </span><span class="s4">'detrend'</span><span class="s3">,</span>
           <span class="s4">'lfilter_zi'</span><span class="s3">, </span><span class="s4">'sosfilt_zi'</span><span class="s3">, </span><span class="s4">'sosfiltfilt'</span><span class="s3">, </span><span class="s4">'choose_conv_method'</span><span class="s3">,</span>
           <span class="s4">'filtfilt'</span><span class="s3">, </span><span class="s4">'decimate'</span><span class="s3">, </span><span class="s4">'vectorstrength'</span><span class="s3">]</span>


<span class="s1">_modedict </span><span class="s3">= {</span><span class="s4">'valid'</span><span class="s3">: </span><span class="s5">0</span><span class="s3">, </span><span class="s4">'same'</span><span class="s3">: </span><span class="s5">1</span><span class="s3">, </span><span class="s4">'full'</span><span class="s3">: </span><span class="s5">2</span><span class="s3">}</span>

<span class="s1">_boundarydict </span><span class="s3">= {</span><span class="s4">'fill'</span><span class="s3">: </span><span class="s5">0</span><span class="s3">, </span><span class="s4">'pad'</span><span class="s3">: </span><span class="s5">0</span><span class="s3">, </span><span class="s4">'wrap'</span><span class="s3">: </span><span class="s5">2</span><span class="s3">, </span><span class="s4">'circular'</span><span class="s3">: </span><span class="s5">2</span><span class="s3">, </span><span class="s4">'symm'</span><span class="s3">: </span><span class="s5">1</span><span class="s3">,</span>
                 <span class="s4">'symmetric'</span><span class="s3">: </span><span class="s5">1</span><span class="s3">, </span><span class="s4">'reflect'</span><span class="s3">: </span><span class="s5">4</span><span class="s3">}</span>


<span class="s2">def </span><span class="s1">_valfrommode</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">):</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_modedict</span><span class="s3">[</span><span class="s1">mode</span><span class="s3">]</span>
    <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Acceptable mode flags are 'valid',&quot;</span>
                         <span class="s4">&quot; 'same', or 'full'.&quot;</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>


<span class="s2">def </span><span class="s1">_bvalfromboundary</span><span class="s3">(</span><span class="s1">boundary</span><span class="s3">):</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_boundarydict</span><span class="s3">[</span><span class="s1">boundary</span><span class="s3">] &lt;&lt; </span><span class="s5">2</span>
    <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Acceptable boundary flags are 'fill', 'circular' &quot;</span>
                         <span class="s4">&quot;(or 'wrap'), and 'symmetric' (or 'symm').&quot;</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>


<span class="s2">def </span><span class="s1">_inputs_swap_needed</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">shape1</span><span class="s3">, </span><span class="s1">shape2</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Determine if inputs arrays need to be swapped in `&quot;valid&quot;` mode. 
 
    If in `&quot;valid&quot;` mode, returns whether or not the input arrays need to be 
    swapped depending on whether `shape1` is at least as large as `shape2` in 
    every calculated dimension. 
 
    This is important for some of the correlation and convolution 
    implementations in this module, where the larger array input needs to come 
    before the smaller array input when operating in this mode. 
 
    Note that if the mode provided is not 'valid', False is immediately 
    returned. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">mode </span><span class="s3">!= </span><span class="s4">'valid'</span><span class="s3">:</span>
        <span class="s2">return False</span>

    <span class="s2">if not </span><span class="s1">shape1</span><span class="s3">:</span>
        <span class="s2">return False</span>

    <span class="s2">if </span><span class="s1">axes </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">axes </span><span class="s3">= </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">shape1</span><span class="s3">))</span>

    <span class="s1">ok1 </span><span class="s3">= </span><span class="s1">all</span><span class="s3">(</span><span class="s1">shape1</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &gt;= </span><span class="s1">shape2</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">axes</span><span class="s3">)</span>
    <span class="s1">ok2 </span><span class="s3">= </span><span class="s1">all</span><span class="s3">(</span><span class="s1">shape2</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &gt;= </span><span class="s1">shape1</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">axes</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s3">(</span><span class="s1">ok1 </span><span class="s2">or </span><span class="s1">ok2</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;For 'valid' mode, one must be at least &quot;</span>
                         <span class="s4">&quot;as large as the other in every dimension&quot;</span><span class="s3">)</span>

    <span class="s2">return not </span><span class="s1">ok1</span>


<span class="s2">def </span><span class="s1">correlate</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'full'</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">'auto'</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot; 
    Cross-correlate two N-dimensional arrays. 
 
    Cross-correlate `in1` and `in2`, with the output size determined by the 
    `mode` argument. 
 
    Parameters 
    ---------- 
    in1 : array_like 
        First input. 
    in2 : array_like 
        Second input. Should have the same number of dimensions as `in1`. 
    mode : str {'full', 'valid', 'same'}, optional 
        A string indicating the size of the output: 
 
        ``full`` 
           The output is the full discrete linear cross-correlation 
           of the inputs. (Default) 
        ``valid`` 
           The output consists only of those elements that do not 
           rely on the zero-padding. In 'valid' mode, either `in1` or `in2` 
           must be at least as large as the other in every dimension. 
        ``same`` 
           The output is the same size as `in1`, centered 
           with respect to the 'full' output. 
    method : str {'auto', 'direct', 'fft'}, optional 
        A string indicating which method to use to calculate the correlation. 
 
        ``direct`` 
           The correlation is determined directly from sums, the definition of 
           correlation. 
        ``fft`` 
           The Fast Fourier Transform is used to perform the correlation more 
           quickly (only available for numerical arrays.) 
        ``auto`` 
           Automatically chooses direct or Fourier method based on an estimate 
           of which is faster (default).  See `convolve` Notes for more detail. 
 
           .. versionadded:: 0.19.0 
 
    Returns 
    ------- 
    correlate : array 
        An N-dimensional array containing a subset of the discrete linear 
        cross-correlation of `in1` with `in2`. 
 
    See Also 
    -------- 
    choose_conv_method : contains more documentation on `method`. 
    correlation_lags : calculates the lag / displacement indices array for 1D 
        cross-correlation. 
 
    Notes 
    ----- 
    The correlation z of two d-dimensional arrays x and y is defined as:: 
 
        z[...,k,...] = sum[..., i_l, ...] x[..., i_l,...] * conj(y[..., i_l - k,...]) 
 
    This way, if x and y are 1-D arrays and ``z = correlate(x, y, 'full')`` 
    then 
 
    .. math:: 
 
          z[k] = (x * y)(k - N + 1) 
               = \sum_{l=0}^{||x||-1}x_l y_{l-k+N-1}^{*} 
 
    for :math:`k = 0, 1, ..., ||x|| + ||y|| - 2` 
 
    where :math:`||x||` is the length of ``x``, :math:`N = \max(||x||,||y||)`, 
    and :math:`y_m` is 0 when m is outside the range of y. 
 
    ``method='fft'`` only works for numerical arrays as it relies on 
    `fftconvolve`. In certain cases (i.e., arrays of objects or when 
    rounding integers can lose precision), ``method='direct'`` is always used. 
 
    When using &quot;same&quot; mode with even-length inputs, the outputs of `correlate` 
    and `correlate2d` differ: There is a 1-index offset between them. 
 
    Examples 
    -------- 
    Implement a matched filter using cross-correlation, to recover a signal 
    that has passed through a noisy channel. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; rng = np.random.default_rng() 
 
    &gt;&gt;&gt; sig = np.repeat([0., 1., 1., 0., 1., 0., 0., 1.], 128) 
    &gt;&gt;&gt; sig_noise = sig + rng.standard_normal(len(sig)) 
    &gt;&gt;&gt; corr = signal.correlate(sig_noise, np.ones(128), mode='same') / 128 
 
    &gt;&gt;&gt; clock = np.arange(64, len(sig), 128) 
    &gt;&gt;&gt; fig, (ax_orig, ax_noise, ax_corr) = plt.subplots(3, 1, sharex=True) 
    &gt;&gt;&gt; ax_orig.plot(sig) 
    &gt;&gt;&gt; ax_orig.plot(clock, sig[clock], 'ro') 
    &gt;&gt;&gt; ax_orig.set_title('Original signal') 
    &gt;&gt;&gt; ax_noise.plot(sig_noise) 
    &gt;&gt;&gt; ax_noise.set_title('Signal with noise') 
    &gt;&gt;&gt; ax_corr.plot(corr) 
    &gt;&gt;&gt; ax_corr.plot(clock, corr[clock], 'ro') 
    &gt;&gt;&gt; ax_corr.axhline(0.5, ls=':') 
    &gt;&gt;&gt; ax_corr.set_title('Cross-correlated with rectangular pulse') 
    &gt;&gt;&gt; ax_orig.margins(0, 0.1) 
    &gt;&gt;&gt; fig.tight_layout() 
    &gt;&gt;&gt; plt.show() 
 
    Compute the cross-correlation of a noisy signal with the original signal. 
 
    &gt;&gt;&gt; x = np.arange(128) / 128 
    &gt;&gt;&gt; sig = np.sin(2 * np.pi * x) 
    &gt;&gt;&gt; sig_noise = sig + rng.standard_normal(len(sig)) 
    &gt;&gt;&gt; corr = signal.correlate(sig_noise, sig) 
    &gt;&gt;&gt; lags = signal.correlation_lags(len(sig), len(sig_noise)) 
    &gt;&gt;&gt; corr /= np.max(corr) 
 
    &gt;&gt;&gt; fig, (ax_orig, ax_noise, ax_corr) = plt.subplots(3, 1, figsize=(4.8, 4.8)) 
    &gt;&gt;&gt; ax_orig.plot(sig) 
    &gt;&gt;&gt; ax_orig.set_title('Original signal') 
    &gt;&gt;&gt; ax_orig.set_xlabel('Sample Number') 
    &gt;&gt;&gt; ax_noise.plot(sig_noise) 
    &gt;&gt;&gt; ax_noise.set_title('Signal with noise') 
    &gt;&gt;&gt; ax_noise.set_xlabel('Sample Number') 
    &gt;&gt;&gt; ax_corr.plot(lags, corr) 
    &gt;&gt;&gt; ax_corr.set_title('Cross-correlated signal') 
    &gt;&gt;&gt; ax_corr.set_xlabel('Lag') 
    &gt;&gt;&gt; ax_orig.margins(0, 0.1) 
    &gt;&gt;&gt; ax_noise.margins(0, 0.1) 
    &gt;&gt;&gt; ax_corr.margins(0, 0.1) 
    &gt;&gt;&gt; fig.tight_layout() 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">in1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">)</span>
    <span class="s1">in2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">in2</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">in1 </span><span class="s3">* </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">()</span>
    <span class="s2">elif </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;in1 and in2 should have the same dimensionality&quot;</span><span class="s3">)</span>

    <span class="s0"># Don't use _valfrommode, since correlate should not accept numeric modes</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">val </span><span class="s3">= </span><span class="s1">_modedict</span><span class="s3">[</span><span class="s1">mode</span><span class="s3">]</span>
    <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Acceptable mode flags are 'valid',&quot;</span>
                         <span class="s4">&quot; 'same', or 'full'.&quot;</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s0"># this either calls fftconvolve or this function with method=='direct'</span>
    <span class="s2">if </span><span class="s1">method </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'fft'</span><span class="s3">, </span><span class="s4">'auto'</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">convolve</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">_reverse_and_conj</span><span class="s3">(</span><span class="s1">in2</span><span class="s3">), </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">method</span><span class="s3">)</span>

    <span class="s2">elif </span><span class="s1">method </span><span class="s3">== </span><span class="s4">'direct'</span><span class="s3">:</span>
        <span class="s0"># fastpath to faster numpy.correlate for 1d inputs when possible</span>
        <span class="s2">if </span><span class="s1">_np_conv_ok</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">correlate</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">)</span>

        <span class="s0"># _correlateND is far slower when in2.size &gt; in1.size, so swap them</span>
        <span class="s0"># and then undo the effect afterward if mode == 'full'.  Also, it fails</span>
        <span class="s0"># with 'valid' mode if in2 is larger than in1, so swap those, too.</span>
        <span class="s0"># Don't swap inputs for 'same' mode, since shape of in1 matters.</span>
        <span class="s1">swapped_inputs </span><span class="s3">= ((</span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'full'</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s1">in2</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">size</span><span class="s3">) </span><span class="s2">or</span>
                          <span class="s1">_inputs_swap_needed</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">))</span>

        <span class="s2">if </span><span class="s1">swapped_inputs</span><span class="s3">:</span>
            <span class="s1">in1</span><span class="s3">, </span><span class="s1">in2 </span><span class="s3">= </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">in1</span>

        <span class="s2">if </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'valid'</span><span class="s3">:</span>
            <span class="s1">ps </span><span class="s3">= [</span><span class="s1">i </span><span class="s3">- </span><span class="s1">j </span><span class="s3">+ </span><span class="s5">1 </span><span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)]</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">ps</span><span class="s3">, </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

            <span class="s1">z </span><span class="s3">= </span><span class="s1">_sigtools</span><span class="s3">.</span><span class="s1">_correlateND</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>

        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">ps </span><span class="s3">= [</span><span class="s1">i </span><span class="s3">+ </span><span class="s1">j </span><span class="s3">- </span><span class="s5">1 </span><span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)]</span>

            <span class="s0"># zero pad input</span>
            <span class="s1">in1zpadded </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">ps</span><span class="s3">, </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">sc </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">slice</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">i</span><span class="s3">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
            <span class="s1">in1zpadded</span><span class="s3">[</span><span class="s1">sc</span><span class="s3">] = </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

            <span class="s2">if </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'full'</span><span class="s3">:</span>
                <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">ps</span><span class="s3">, </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'same'</span><span class="s3">:</span>
                <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

            <span class="s1">z </span><span class="s3">= </span><span class="s1">_sigtools</span><span class="s3">.</span><span class="s1">_correlateND</span><span class="s3">(</span><span class="s1">in1zpadded</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">val</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">swapped_inputs</span><span class="s3">:</span>
            <span class="s0"># Reverse and conjugate to undo the effect of swapping inputs</span>
            <span class="s1">z </span><span class="s3">= </span><span class="s1">_reverse_and_conj</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">z</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Acceptable method flags are 'auto',&quot;</span>
                         <span class="s4">&quot; 'direct', or 'fft'.&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">correlation_lags</span><span class="s3">(</span><span class="s1">in1_len</span><span class="s3">, </span><span class="s1">in2_len</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'full'</span><span class="s3">):</span>
    <span class="s6">r&quot;&quot;&quot; 
    Calculates the lag / displacement indices array for 1D cross-correlation. 
 
    Parameters 
    ---------- 
    in1_len : int 
        First input size. 
    in2_len : int 
        Second input size. 
    mode : str {'full', 'valid', 'same'}, optional 
        A string indicating the size of the output. 
        See the documentation `correlate` for more information. 
 
    Returns 
    ------- 
    lags : array 
        Returns an array containing cross-correlation lag/displacement indices. 
        Indices can be indexed with the np.argmax of the correlation to return 
        the lag/displacement. 
 
    See Also 
    -------- 
    correlate : Compute the N-dimensional cross-correlation. 
 
    Notes 
    ----- 
    Cross-correlation for continuous functions :math:`f` and :math:`g` is 
    defined as: 
 
    .. math:: 
 
        \left ( f\star g \right )\left ( \tau \right ) 
        \triangleq \int_{t_0}^{t_0 +T} 
        \overline{f\left ( t \right )}g\left ( t+\tau \right )dt 
 
    Where :math:`\tau` is defined as the displacement, also known as the lag. 
 
    Cross correlation for discrete functions :math:`f` and :math:`g` is 
    defined as: 
 
    .. math:: 
        \left ( f\star g \right )\left [ n \right ] 
        \triangleq \sum_{-\infty}^{\infty} 
        \overline{f\left [ m \right ]}g\left [ m+n \right ] 
 
    Where :math:`n` is the lag. 
 
    Examples 
    -------- 
    Cross-correlation of a signal with its time-delayed self. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; x = rng.standard_normal(1000) 
    &gt;&gt;&gt; y = np.concatenate([rng.standard_normal(100), x]) 
    &gt;&gt;&gt; correlation = signal.correlate(x, y, mode=&quot;full&quot;) 
    &gt;&gt;&gt; lags = signal.correlation_lags(x.size, y.size, mode=&quot;full&quot;) 
    &gt;&gt;&gt; lag = lags[np.argmax(correlation)] 
    &quot;&quot;&quot;</span>

    <span class="s0"># calculate lag ranges in different modes of operation</span>
    <span class="s2">if </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">&quot;full&quot;</span><span class="s3">:</span>
        <span class="s0"># the output is the full discrete linear convolution</span>
        <span class="s0"># of the inputs. (Default)</span>
        <span class="s1">lags </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(-</span><span class="s1">in2_len </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">in1_len</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">&quot;same&quot;</span><span class="s3">:</span>
        <span class="s0"># the output is the same size as `in1`, centered</span>
        <span class="s0"># with respect to the 'full' output.</span>
        <span class="s0"># calculate the full output</span>
        <span class="s1">lags </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(-</span><span class="s1">in2_len </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">in1_len</span><span class="s3">)</span>
        <span class="s0"># determine the midpoint in the full output</span>
        <span class="s1">mid </span><span class="s3">= </span><span class="s1">lags</span><span class="s3">.</span><span class="s1">size </span><span class="s3">// </span><span class="s5">2</span>
        <span class="s0"># determine lag_bound to be used with respect</span>
        <span class="s0"># to the midpoint</span>
        <span class="s1">lag_bound </span><span class="s3">= </span><span class="s1">in1_len </span><span class="s3">// </span><span class="s5">2</span>
        <span class="s0"># calculate lag ranges for even and odd scenarios</span>
        <span class="s2">if </span><span class="s1">in1_len </span><span class="s3">% </span><span class="s5">2 </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">lags </span><span class="s3">= </span><span class="s1">lags</span><span class="s3">[(</span><span class="s1">mid</span><span class="s3">-</span><span class="s1">lag_bound</span><span class="s3">):(</span><span class="s1">mid</span><span class="s3">+</span><span class="s1">lag_bound</span><span class="s3">)]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">lags </span><span class="s3">= </span><span class="s1">lags</span><span class="s3">[(</span><span class="s1">mid</span><span class="s3">-</span><span class="s1">lag_bound</span><span class="s3">):(</span><span class="s1">mid</span><span class="s3">+</span><span class="s1">lag_bound</span><span class="s3">)+</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s2">elif </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">&quot;valid&quot;</span><span class="s3">:</span>
        <span class="s0"># the output consists only of those elements that do not</span>
        <span class="s0"># rely on the zero-padding. In 'valid' mode, either `in1` or `in2`</span>
        <span class="s0"># must be at least as large as the other in every dimension.</span>

        <span class="s0"># the lag_bound will be either negative or positive</span>
        <span class="s0"># this let's us infer how to present the lag range</span>
        <span class="s1">lag_bound </span><span class="s3">= </span><span class="s1">in1_len </span><span class="s3">- </span><span class="s1">in2_len</span>
        <span class="s2">if </span><span class="s1">lag_bound </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">lags </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">lag_bound </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">lags </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">lag_bound</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">lags</span>


<span class="s2">def </span><span class="s1">_centered</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">newshape</span><span class="s3">):</span>
    <span class="s0"># Return the center newshape portion of the array.</span>
    <span class="s1">newshape </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">newshape</span><span class="s3">)</span>
    <span class="s1">currshape </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">startind </span><span class="s3">= (</span><span class="s1">currshape </span><span class="s3">- </span><span class="s1">newshape</span><span class="s3">) // </span><span class="s5">2</span>
    <span class="s1">endind </span><span class="s3">= </span><span class="s1">startind </span><span class="s3">+ </span><span class="s1">newshape</span>
    <span class="s1">myslice </span><span class="s3">= [</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">startind</span><span class="s3">[</span><span class="s1">k</span><span class="s3">], </span><span class="s1">endind</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">endind</span><span class="s3">))]</span>
    <span class="s2">return </span><span class="s1">arr</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">myslice</span><span class="s3">)]</span>


<span class="s2">def </span><span class="s1">_init_freq_conv_axes</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">, </span><span class="s1">sorted_axes</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Handle the axes argument for frequency-domain convolution. 
 
    Returns the inputs and axes in a standard form, eliminating redundant axes, 
    swapping the inputs if necessary, and checking for various potential 
    errors. 
 
    Parameters 
    ---------- 
    in1 : array 
        First input. 
    in2 : array 
        Second input. 
    mode : str {'full', 'valid', 'same'}, optional 
        A string indicating the size of the output. 
        See the documentation `fftconvolve` for more information. 
    axes : list of ints 
        Axes over which to compute the FFTs. 
    sorted_axes : bool, optional 
        If `True`, sort the axes. 
        Default is `False`, do not sort. 
 
    Returns 
    ------- 
    in1 : array 
        The first input, possible swapped with the second input. 
    in2 : array 
        The second input, possible swapped with the first input. 
    axes : list of ints 
        Axes over which to compute the FFTs. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">s1 </span><span class="s3">= </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s1">s2 </span><span class="s3">= </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s1">noaxes </span><span class="s3">= </span><span class="s1">axes </span><span class="s2">is None</span>

    <span class="s1">_</span><span class="s3">, </span><span class="s1">axes </span><span class="s3">= </span><span class="s1">_init_nd_shape_and_axes</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">axes</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">noaxes </span><span class="s2">and not </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;when provided, axes cannot be empty&quot;</span><span class="s3">)</span>

    <span class="s0"># Axes of length 1 can rely on broadcasting rules for multiply,</span>
    <span class="s0"># no fft needed.</span>
    <span class="s1">axes </span><span class="s3">= [</span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">axes </span><span class="s2">if </span><span class="s1">s1</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] != </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">s2</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] != </span><span class="s5">1</span><span class="s3">]</span>

    <span class="s2">if </span><span class="s1">sorted_axes</span><span class="s3">:</span>
        <span class="s1">axes</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">()</span>

    <span class="s2">if not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">s1</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] == </span><span class="s1">s2</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] </span><span class="s2">or </span><span class="s1">s1</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] == </span><span class="s5">1 </span><span class="s2">or </span><span class="s1">s2</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] == </span><span class="s5">1</span>
               <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">) </span><span class="s2">if </span><span class="s1">a </span><span class="s2">not in </span><span class="s1">axes</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;incompatible shapes for in1 and in2:&quot;</span>
                         <span class="s4">f&quot; </span><span class="s2">{</span><span class="s1">s1</span><span class="s2">} </span><span class="s4">and </span><span class="s2">{</span><span class="s1">s2</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>

    <span class="s0"># Check that input sizes are compatible with 'valid' mode.</span>
    <span class="s2">if </span><span class="s1">_inputs_swap_needed</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">s1</span><span class="s3">, </span><span class="s1">s2</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">axes</span><span class="s3">):</span>
        <span class="s0"># Convolution is commutative; order doesn't have any effect on output.</span>
        <span class="s1">in1</span><span class="s3">, </span><span class="s1">in2 </span><span class="s3">= </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">in1</span>

    <span class="s2">return </span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">axes</span>


<span class="s2">def </span><span class="s1">_freq_domain_conv</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">calc_fast_len</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Convolve two arrays in the frequency domain. 
 
    This function implements only base the FFT-related operations. 
    Specifically, it converts the signals to the frequency domain, multiplies 
    them, then converts them back to the time domain.  Calculations of axes, 
    shapes, convolution mode, etc. are implemented in higher level-functions, 
    such as `fftconvolve` and `oaconvolve`.  Those functions should be used 
    instead of this one. 
 
    Parameters 
    ---------- 
    in1 : array_like 
        First input. 
    in2 : array_like 
        Second input. Should have the same number of dimensions as `in1`. 
    axes : array_like of ints 
        Axes over which to compute the FFTs. 
    shape : array_like of ints 
        The sizes of the FFTs. 
    calc_fast_len : bool, optional 
        If `True`, set each value of `shape` to the next fast FFT length. 
        Default is `False`, use `axes` as-is. 
 
    Returns 
    ------- 
    out : array 
        An N-dimensional array containing the discrete linear convolution of 
        `in1` with `in2`. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">len</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">in1 </span><span class="s3">* </span><span class="s1">in2</span>

    <span class="s1">complex_result </span><span class="s3">= (</span><span class="s1">in1</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'c' </span><span class="s2">or </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s4">'c'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">calc_fast_len</span><span class="s3">:</span>
        <span class="s0"># Speed up FFT by padding to optimal size.</span>
        <span class="s1">fshape </span><span class="s3">= [</span>
            <span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">next_fast_len</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">a</span><span class="s3">], </span><span class="s2">not </span><span class="s1">complex_result</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">axes</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">fshape </span><span class="s3">= </span><span class="s1">shape</span>

    <span class="s2">if not </span><span class="s1">complex_result</span><span class="s3">:</span>
        <span class="s1">fft</span><span class="s3">, </span><span class="s1">ifft </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">rfftn</span><span class="s3">, </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">irfftn</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">fft</span><span class="s3">, </span><span class="s1">ifft </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">fftn</span><span class="s3">, </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">ifftn</span>

    <span class="s1">sp1 </span><span class="s3">= </span><span class="s1">fft</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">fshape</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">axes</span><span class="s3">)</span>
    <span class="s1">sp2 </span><span class="s3">= </span><span class="s1">fft</span><span class="s3">(</span><span class="s1">in2</span><span class="s3">, </span><span class="s1">fshape</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">axes</span><span class="s3">)</span>

    <span class="s1">ret </span><span class="s3">= </span><span class="s1">ifft</span><span class="s3">(</span><span class="s1">sp1 </span><span class="s3">* </span><span class="s1">sp2</span><span class="s3">, </span><span class="s1">fshape</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">axes</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">calc_fast_len</span><span class="s3">:</span>
        <span class="s1">fslice </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">sz</span><span class="s3">) </span><span class="s2">for </span><span class="s1">sz </span><span class="s2">in </span><span class="s1">shape</span><span class="s3">])</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">[</span><span class="s1">fslice</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">def </span><span class="s1">_apply_conv_mode</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s1">s1</span><span class="s3">, </span><span class="s1">s2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Calculate the convolution result shape based on the `mode` argument. 
 
    Returns the result sliced to the correct size for the given mode. 
 
    Parameters 
    ---------- 
    ret : array 
        The result array, with the appropriate shape for the 'full' mode. 
    s1 : list of int 
        The shape of the first input. 
    s2 : list of int 
        The shape of the second input. 
    mode : str {'full', 'valid', 'same'} 
        A string indicating the size of the output. 
        See the documentation `fftconvolve` for more information. 
    axes : list of ints 
        Axes over which to compute the convolution. 
 
    Returns 
    ------- 
    ret : array 
        A copy of `res`, sliced to the correct size for the given `mode`. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">&quot;full&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s2">elif </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">&quot;same&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_centered</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s1">s1</span><span class="s3">).</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s2">elif </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">&quot;valid&quot;</span><span class="s3">:</span>
        <span class="s1">shape_valid </span><span class="s3">= [</span><span class="s1">ret</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] </span><span class="s2">if </span><span class="s1">a </span><span class="s2">not in </span><span class="s1">axes </span><span class="s2">else </span><span class="s1">s1</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] - </span><span class="s1">s2</span><span class="s3">[</span><span class="s1">a</span><span class="s3">] + </span><span class="s5">1</span>
                       <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)]</span>
        <span class="s2">return </span><span class="s1">_centered</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s1">shape_valid</span><span class="s3">).</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;acceptable mode flags are 'valid',&quot;</span>
                         <span class="s4">&quot; 'same', or 'full'&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">fftconvolve</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;full&quot;</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Convolve two N-dimensional arrays using FFT. 
 
    Convolve `in1` and `in2` using the fast Fourier transform method, with 
    the output size determined by the `mode` argument. 
 
    This is generally much faster than `convolve` for large arrays (n &gt; ~500), 
    but can be slower when only a few output values are needed, and can only 
    output float arrays (int or object array inputs will be cast to float). 
 
    As of v0.19, `convolve` automatically chooses this method or the direct 
    method based on an estimation of which is faster. 
 
    Parameters 
    ---------- 
    in1 : array_like 
        First input. 
    in2 : array_like 
        Second input. Should have the same number of dimensions as `in1`. 
    mode : str {'full', 'valid', 'same'}, optional 
        A string indicating the size of the output: 
 
        ``full`` 
           The output is the full discrete linear convolution 
           of the inputs. (Default) 
        ``valid`` 
           The output consists only of those elements that do not 
           rely on the zero-padding. In 'valid' mode, either `in1` or `in2` 
           must be at least as large as the other in every dimension. 
        ``same`` 
           The output is the same size as `in1`, centered 
           with respect to the 'full' output. 
    axes : int or array_like of ints or None, optional 
        Axes over which to compute the convolution. 
        The default is over all axes. 
 
    Returns 
    ------- 
    out : array 
        An N-dimensional array containing a subset of the discrete linear 
        convolution of `in1` with `in2`. 
 
    See Also 
    -------- 
    convolve : Uses the direct convolution or FFT convolution algorithm 
               depending on which is faster. 
    oaconvolve : Uses the overlap-add method to do convolution, which is 
                 generally faster when the input arrays are large and 
                 significantly different in size. 
 
    Examples 
    -------- 
    Autocorrelation of white noise is an impulse. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; sig = rng.standard_normal(1000) 
    &gt;&gt;&gt; autocorr = signal.fftconvolve(sig, sig[::-1], mode='full') 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, (ax_orig, ax_mag) = plt.subplots(2, 1) 
    &gt;&gt;&gt; ax_orig.plot(sig) 
    &gt;&gt;&gt; ax_orig.set_title('White noise') 
    &gt;&gt;&gt; ax_mag.plot(np.arange(-len(sig)+1,len(sig)), autocorr) 
    &gt;&gt;&gt; ax_mag.set_title('Autocorrelation') 
    &gt;&gt;&gt; fig.tight_layout() 
    &gt;&gt;&gt; fig.show() 
 
    Gaussian blur implemented using FFT convolution.  Notice the dark borders 
    around the image, due to the zero-padding beyond its boundaries. 
    The `convolve2d` function allows for other types of image boundaries, 
    but is far slower. 
 
    &gt;&gt;&gt; from scipy import datasets 
    &gt;&gt;&gt; face = datasets.face(gray=True) 
    &gt;&gt;&gt; kernel = np.outer(signal.windows.gaussian(70, 8), 
    ...                   signal.windows.gaussian(70, 8)) 
    &gt;&gt;&gt; blurred = signal.fftconvolve(face, kernel, mode='same') 
 
    &gt;&gt;&gt; fig, (ax_orig, ax_kernel, ax_blurred) = plt.subplots(3, 1, 
    ...                                                      figsize=(6, 15)) 
    &gt;&gt;&gt; ax_orig.imshow(face, cmap='gray') 
    &gt;&gt;&gt; ax_orig.set_title('Original') 
    &gt;&gt;&gt; ax_orig.set_axis_off() 
    &gt;&gt;&gt; ax_kernel.imshow(kernel, cmap='gray') 
    &gt;&gt;&gt; ax_kernel.set_title('Gaussian kernel') 
    &gt;&gt;&gt; ax_kernel.set_axis_off() 
    &gt;&gt;&gt; ax_blurred.imshow(blurred, cmap='gray') 
    &gt;&gt;&gt; ax_blurred.set_title('Blurred') 
    &gt;&gt;&gt; ax_blurred.set_axis_off() 
    &gt;&gt;&gt; fig.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">in1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">)</span>
    <span class="s1">in2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">in2</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:  </span><span class="s0"># scalar inputs</span>
        <span class="s2">return </span><span class="s1">in1 </span><span class="s3">* </span><span class="s1">in2</span>
    <span class="s2">elif </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;in1 and in2 should have the same dimensionality&quot;</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:  </span><span class="s0"># empty arrays</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([])</span>

    <span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">axes </span><span class="s3">= </span><span class="s1">_init_freq_conv_axes</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">,</span>
                                          <span class="s1">sorted_axes</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s1">s1 </span><span class="s3">= </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s1">s2 </span><span class="s3">= </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">shape</span>

    <span class="s1">shape </span><span class="s3">= [</span><span class="s1">max</span><span class="s3">((</span><span class="s1">s1</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">s2</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])) </span><span class="s2">if </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">axes </span><span class="s2">else </span><span class="s1">s1</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + </span><span class="s1">s2</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s5">1</span>
             <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)]</span>

    <span class="s1">ret </span><span class="s3">= </span><span class="s1">_freq_domain_conv</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">calc_fast_len</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">_apply_conv_mode</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s1">s1</span><span class="s3">, </span><span class="s1">s2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_calc_oa_lens</span><span class="s3">(</span><span class="s1">s1</span><span class="s3">, </span><span class="s1">s2</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Calculate the optimal FFT lengths for overlapp-add convolution. 
 
    The calculation is done for a single dimension. 
 
    Parameters 
    ---------- 
    s1 : int 
        Size of the dimension for the first array. 
    s2 : int 
        Size of the dimension for the second array. 
 
    Returns 
    ------- 
    block_size : int 
        The size of the FFT blocks. 
    overlap : int 
        The amount of overlap between two blocks. 
    in1_step : int 
        The size of each step for the first array. 
    in2_step : int 
        The size of each step for the first array. 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># Set up the arguments for the conventional FFT approach.</span>
    <span class="s1">fallback </span><span class="s3">= (</span><span class="s1">s1</span><span class="s3">+</span><span class="s1">s2</span><span class="s3">-</span><span class="s5">1</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">s1</span><span class="s3">, </span><span class="s1">s2</span><span class="s3">)</span>

    <span class="s0"># Use conventional FFT convolve if sizes are same.</span>
    <span class="s2">if </span><span class="s1">s1 </span><span class="s3">== </span><span class="s1">s2 </span><span class="s2">or </span><span class="s1">s1 </span><span class="s3">== </span><span class="s5">1 </span><span class="s2">or </span><span class="s1">s2 </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">fallback</span>

    <span class="s2">if </span><span class="s1">s2 </span><span class="s3">&gt; </span><span class="s1">s1</span><span class="s3">:</span>
        <span class="s1">s1</span><span class="s3">, </span><span class="s1">s2 </span><span class="s3">= </span><span class="s1">s2</span><span class="s3">, </span><span class="s1">s1</span>
        <span class="s1">swapped </span><span class="s3">= </span><span class="s2">True</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">swapped </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s0"># There cannot be a useful block size if s2 is more than half of s1.</span>
    <span class="s2">if </span><span class="s1">s2 </span><span class="s3">&gt;= </span><span class="s1">s1</span><span class="s3">/</span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">fallback</span>

    <span class="s0"># Derivation of optimal block length</span>
    <span class="s0"># For original formula see:</span>
    <span class="s0"># https://en.wikipedia.org/wiki/Overlap-add_method</span>
    <span class="s0">#</span>
    <span class="s0"># Formula:</span>
    <span class="s0"># K = overlap = s2-1</span>
    <span class="s0"># N = block_size</span>
    <span class="s0"># C = complexity</span>
    <span class="s0"># e = exponential, exp(1)</span>
    <span class="s0">#</span>
    <span class="s0"># C = (N*(log2(N)+1))/(N-K)</span>
    <span class="s0"># C = (N*log2(2N))/(N-K)</span>
    <span class="s0"># C = N/(N-K) * log2(2N)</span>
    <span class="s0"># C1 = N/(N-K)</span>
    <span class="s0"># C2 = log2(2N) = ln(2N)/ln(2)</span>
    <span class="s0">#</span>
    <span class="s0"># dC1/dN = (1*(N-K)-N)/(N-K)^2 = -K/(N-K)^2</span>
    <span class="s0"># dC2/dN = 2/(2*N*ln(2)) = 1/(N*ln(2))</span>
    <span class="s0">#</span>
    <span class="s0"># dC/dN = dC1/dN*C2 + dC2/dN*C1</span>
    <span class="s0"># dC/dN = -K*ln(2N)/(ln(2)*(N-K)^2) + N/(N*ln(2)*(N-K))</span>
    <span class="s0"># dC/dN = -K*ln(2N)/(ln(2)*(N-K)^2) + 1/(ln(2)*(N-K))</span>
    <span class="s0"># dC/dN = -K*ln(2N)/(ln(2)*(N-K)^2) + (N-K)/(ln(2)*(N-K)^2)</span>
    <span class="s0"># dC/dN = (-K*ln(2N) + (N-K)/(ln(2)*(N-K)^2)</span>
    <span class="s0"># dC/dN = (N - K*ln(2N) - K)/(ln(2)*(N-K)^2)</span>
    <span class="s0">#</span>
    <span class="s0"># Solve for minimum, where dC/dN = 0</span>
    <span class="s0"># 0 = (N - K*ln(2N) - K)/(ln(2)*(N-K)^2)</span>
    <span class="s0"># 0 * ln(2)*(N-K)^2 = N - K*ln(2N) - K</span>
    <span class="s0"># 0 = N - K*ln(2N) - K</span>
    <span class="s0"># 0 = N - K*(ln(2N) + 1)</span>
    <span class="s0"># 0 = N - K*ln(2Ne)</span>
    <span class="s0"># N = K*ln(2Ne)</span>
    <span class="s0"># N/K = ln(2Ne)</span>
    <span class="s0">#</span>
    <span class="s0"># e^(N/K) = e^ln(2Ne)</span>
    <span class="s0"># e^(N/K) = 2Ne</span>
    <span class="s0"># 1/e^(N/K) = 1/(2*N*e)</span>
    <span class="s0"># e^(N/-K) = 1/(2*N*e)</span>
    <span class="s0"># e^(N/-K) = K/N*1/(2*K*e)</span>
    <span class="s0"># N/K*e^(N/-K) = 1/(2*e*K)</span>
    <span class="s0"># N/-K*e^(N/-K) = -1/(2*e*K)</span>
    <span class="s0">#</span>
    <span class="s0"># Using Lambert W function</span>
    <span class="s0"># https://en.wikipedia.org/wiki/Lambert_W_function</span>
    <span class="s0"># x = W(y) It is the solution to y = x*e^x</span>
    <span class="s0"># x = N/-K</span>
    <span class="s0"># y = -1/(2*e*K)</span>
    <span class="s0">#</span>
    <span class="s0"># N/-K = W(-1/(2*e*K))</span>
    <span class="s0">#</span>
    <span class="s0"># N = -K*W(-1/(2*e*K))</span>
    <span class="s1">overlap </span><span class="s3">= </span><span class="s1">s2</span><span class="s3">-</span><span class="s5">1</span>
    <span class="s1">opt_size </span><span class="s3">= -</span><span class="s1">overlap</span><span class="s3">*</span><span class="s1">lambertw</span><span class="s3">(-</span><span class="s5">1</span><span class="s3">/(</span><span class="s5">2</span><span class="s3">*</span><span class="s1">math</span><span class="s3">.</span><span class="s1">e</span><span class="s3">*</span><span class="s1">overlap</span><span class="s3">), </span><span class="s1">k</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">).</span><span class="s1">real</span>
    <span class="s1">block_size </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">next_fast_len</span><span class="s3">(</span><span class="s1">math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">opt_size</span><span class="s3">))</span>

    <span class="s0"># Use conventional FFT convolve if there is only going to be one block.</span>
    <span class="s2">if </span><span class="s1">block_size </span><span class="s3">&gt;= </span><span class="s1">s1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">fallback</span>

    <span class="s2">if not </span><span class="s1">swapped</span><span class="s3">:</span>
        <span class="s1">in1_step </span><span class="s3">= </span><span class="s1">block_size</span><span class="s3">-</span><span class="s1">s2</span><span class="s3">+</span><span class="s5">1</span>
        <span class="s1">in2_step </span><span class="s3">= </span><span class="s1">s2</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">in1_step </span><span class="s3">= </span><span class="s1">s2</span>
        <span class="s1">in2_step </span><span class="s3">= </span><span class="s1">block_size</span><span class="s3">-</span><span class="s1">s2</span><span class="s3">+</span><span class="s5">1</span>

    <span class="s2">return </span><span class="s1">block_size</span><span class="s3">, </span><span class="s1">overlap</span><span class="s3">, </span><span class="s1">in1_step</span><span class="s3">, </span><span class="s1">in2_step</span>


<span class="s2">def </span><span class="s1">oaconvolve</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">&quot;full&quot;</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Convolve two N-dimensional arrays using the overlap-add method. 
 
    Convolve `in1` and `in2` using the overlap-add method, with 
    the output size determined by the `mode` argument. 
 
    This is generally much faster than `convolve` for large arrays (n &gt; ~500), 
    and generally much faster than `fftconvolve` when one array is much 
    larger than the other, but can be slower when only a few output values are 
    needed or when the arrays are very similar in shape, and can only 
    output float arrays (int or object array inputs will be cast to float). 
 
    Parameters 
    ---------- 
    in1 : array_like 
        First input. 
    in2 : array_like 
        Second input. Should have the same number of dimensions as `in1`. 
    mode : str {'full', 'valid', 'same'}, optional 
        A string indicating the size of the output: 
 
        ``full`` 
           The output is the full discrete linear convolution 
           of the inputs. (Default) 
        ``valid`` 
           The output consists only of those elements that do not 
           rely on the zero-padding. In 'valid' mode, either `in1` or `in2` 
           must be at least as large as the other in every dimension. 
        ``same`` 
           The output is the same size as `in1`, centered 
           with respect to the 'full' output. 
    axes : int or array_like of ints or None, optional 
        Axes over which to compute the convolution. 
        The default is over all axes. 
 
    Returns 
    ------- 
    out : array 
        An N-dimensional array containing a subset of the discrete linear 
        convolution of `in1` with `in2`. 
 
    See Also 
    -------- 
    convolve : Uses the direct convolution or FFT convolution algorithm 
               depending on which is faster. 
    fftconvolve : An implementation of convolution using FFT. 
 
    Notes 
    ----- 
    .. versionadded:: 1.4.0 
 
    References 
    ---------- 
    .. [1] Wikipedia, &quot;Overlap-add_method&quot;. 
           https://en.wikipedia.org/wiki/Overlap-add_method 
    .. [2] Richard G. Lyons. Understanding Digital Signal Processing, 
           Third Edition, 2011. Chapter 13.10. 
           ISBN 13: 978-0137-02741-5 
 
    Examples 
    -------- 
    Convolve a 100,000 sample signal with a 512-sample filter. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; sig = rng.standard_normal(100000) 
    &gt;&gt;&gt; filt = signal.firwin(512, 0.01) 
    &gt;&gt;&gt; fsig = signal.oaconvolve(sig, filt) 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, (ax_orig, ax_mag) = plt.subplots(2, 1) 
    &gt;&gt;&gt; ax_orig.plot(sig) 
    &gt;&gt;&gt; ax_orig.set_title('White noise') 
    &gt;&gt;&gt; ax_mag.plot(fsig) 
    &gt;&gt;&gt; ax_mag.set_title('Filtered noise') 
    &gt;&gt;&gt; fig.tight_layout() 
    &gt;&gt;&gt; fig.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">in1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">)</span>
    <span class="s1">in2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">in2</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:  </span><span class="s0"># scalar inputs</span>
        <span class="s2">return </span><span class="s1">in1 </span><span class="s3">* </span><span class="s1">in2</span>
    <span class="s2">elif </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;in1 and in2 should have the same dimensionality&quot;</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:  </span><span class="s0"># empty arrays</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([])</span>
    <span class="s2">elif </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:  </span><span class="s0"># Equivalent to fftconvolve</span>
        <span class="s2">return </span><span class="s1">fftconvolve</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">axes</span><span class="s3">)</span>

    <span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">axes </span><span class="s3">= </span><span class="s1">_init_freq_conv_axes</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">,</span>
                                          <span class="s1">sorted_axes</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s1">s1 </span><span class="s3">= </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s1">s2 </span><span class="s3">= </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">shape</span>

    <span class="s2">if not </span><span class="s1">axes</span><span class="s3">:</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s1">in1 </span><span class="s3">* </span><span class="s1">in2</span>
        <span class="s2">return </span><span class="s1">_apply_conv_mode</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s1">s1</span><span class="s3">, </span><span class="s1">s2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">)</span>

    <span class="s0"># Calculate this now since in1 is changed later</span>
    <span class="s1">shape_final </span><span class="s3">= [</span><span class="s2">None if </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">axes </span><span class="s2">else</span>
                   <span class="s1">s1</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + </span><span class="s1">s2</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s5">1 </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)]</span>

    <span class="s0"># Calculate the block sizes for the output, steps, first and second inputs.</span>
    <span class="s0"># It is simpler to calculate them all together than doing them in separate</span>
    <span class="s0"># loops due to all the special cases that need to be handled.</span>
    <span class="s1">optimal_sizes </span><span class="s3">= ((-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s1">s1</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">s2</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]) </span><span class="s2">if </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">axes </span><span class="s2">else</span>
                     <span class="s1">_calc_oa_lens</span><span class="s3">(</span><span class="s1">s1</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">s2</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">))</span>
    <span class="s1">block_size</span><span class="s3">, </span><span class="s1">overlaps</span><span class="s3">, </span><span class="s1">\</span>
        <span class="s1">in1_step</span><span class="s3">, </span><span class="s1">in2_step </span><span class="s3">= </span><span class="s1">zip</span><span class="s3">(*</span><span class="s1">optimal_sizes</span><span class="s3">)</span>

    <span class="s0"># Fall back to fftconvolve if there is only one block in every dimension.</span>
    <span class="s2">if </span><span class="s1">in1_step </span><span class="s3">== </span><span class="s1">s1 </span><span class="s2">and </span><span class="s1">in2_step </span><span class="s3">== </span><span class="s1">s2</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">fftconvolve</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">axes</span><span class="s3">)</span>

    <span class="s0"># Figure out the number of steps and padding.</span>
    <span class="s0"># This would get too complicated in a list comprehension.</span>
    <span class="s1">nsteps1 </span><span class="s3">= []</span>
    <span class="s1">nsteps2 </span><span class="s3">= []</span>
    <span class="s1">pad_size1 </span><span class="s3">= []</span>
    <span class="s1">pad_size2 </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">axes</span><span class="s3">:</span>
            <span class="s1">pad_size1 </span><span class="s3">+= [(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)]</span>
            <span class="s1">pad_size2 </span><span class="s3">+= [(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)]</span>
            <span class="s2">continue</span>

        <span class="s2">if </span><span class="s1">s1</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &gt; </span><span class="s1">in1_step</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]:</span>
            <span class="s1">curnstep1 </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">((</span><span class="s1">s1</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]+</span><span class="s5">1</span><span class="s3">)/</span><span class="s1">in1_step</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">block_size</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">overlaps</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])*</span><span class="s1">curnstep1 </span><span class="s3">&lt; </span><span class="s1">shape_final</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]:</span>
                <span class="s1">curnstep1 </span><span class="s3">+= </span><span class="s5">1</span>

            <span class="s1">curpad1 </span><span class="s3">= </span><span class="s1">curnstep1</span><span class="s3">*</span><span class="s1">in1_step</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">s1</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">curnstep1 </span><span class="s3">= </span><span class="s5">1</span>
            <span class="s1">curpad1 </span><span class="s3">= </span><span class="s5">0</span>

        <span class="s2">if </span><span class="s1">s2</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &gt; </span><span class="s1">in2_step</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]:</span>
            <span class="s1">curnstep2 </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">((</span><span class="s1">s2</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]+</span><span class="s5">1</span><span class="s3">)/</span><span class="s1">in2_step</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">block_size</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">overlaps</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])*</span><span class="s1">curnstep2 </span><span class="s3">&lt; </span><span class="s1">shape_final</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]:</span>
                <span class="s1">curnstep2 </span><span class="s3">+= </span><span class="s5">1</span>

            <span class="s1">curpad2 </span><span class="s3">= </span><span class="s1">curnstep2</span><span class="s3">*</span><span class="s1">in2_step</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">s2</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">curnstep2 </span><span class="s3">= </span><span class="s5">1</span>
            <span class="s1">curpad2 </span><span class="s3">= </span><span class="s5">0</span>

        <span class="s1">nsteps1 </span><span class="s3">+= [</span><span class="s1">curnstep1</span><span class="s3">]</span>
        <span class="s1">nsteps2 </span><span class="s3">+= [</span><span class="s1">curnstep2</span><span class="s3">]</span>
        <span class="s1">pad_size1 </span><span class="s3">+= [(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">curpad1</span><span class="s3">)]</span>
        <span class="s1">pad_size2 </span><span class="s3">+= [(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">curpad2</span><span class="s3">)]</span>

    <span class="s0"># Pad the array to a size that can be reshaped to the desired shape</span>
    <span class="s0"># if necessary.</span>
    <span class="s2">if not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">curpad </span><span class="s3">== (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">) </span><span class="s2">for </span><span class="s1">curpad </span><span class="s2">in </span><span class="s1">pad_size1</span><span class="s3">):</span>
        <span class="s1">in1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pad</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">pad_size1</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'constant'</span><span class="s3">, </span><span class="s1">constant_values</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">all</span><span class="s3">(</span><span class="s1">curpad </span><span class="s3">== (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">) </span><span class="s2">for </span><span class="s1">curpad </span><span class="s2">in </span><span class="s1">pad_size2</span><span class="s3">):</span>
        <span class="s1">in2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pad</span><span class="s3">(</span><span class="s1">in2</span><span class="s3">, </span><span class="s1">pad_size2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'constant'</span><span class="s3">, </span><span class="s1">constant_values</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s0"># Reshape the overlap-add parts to input block sizes.</span>
    <span class="s1">split_axes </span><span class="s3">= [</span><span class="s1">iax</span><span class="s3">+</span><span class="s1">i </span><span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">iax </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">)]</span>
    <span class="s1">fft_axes </span><span class="s3">= [</span><span class="s1">iax</span><span class="s3">+</span><span class="s5">1 </span><span class="s2">for </span><span class="s1">iax </span><span class="s2">in </span><span class="s1">split_axes</span><span class="s3">]</span>

    <span class="s0"># We need to put each new dimension before the corresponding dimension</span>
    <span class="s0"># being reshaped in order to get the data in the right layout at the end.</span>
    <span class="s1">reshape_size1 </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">in1_step</span><span class="s3">)</span>
    <span class="s1">reshape_size2 </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">in2_step</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">iax </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">split_axes</span><span class="s3">):</span>
        <span class="s1">reshape_size1</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s1">iax</span><span class="s3">, </span><span class="s1">nsteps1</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>
        <span class="s1">reshape_size2</span><span class="s3">.</span><span class="s1">insert</span><span class="s3">(</span><span class="s1">iax</span><span class="s3">, </span><span class="s1">nsteps2</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>

    <span class="s1">in1 </span><span class="s3">= </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(*</span><span class="s1">reshape_size1</span><span class="s3">)</span>
    <span class="s1">in2 </span><span class="s3">= </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(*</span><span class="s1">reshape_size2</span><span class="s3">)</span>

    <span class="s0"># Do the convolution.</span>
    <span class="s1">fft_shape </span><span class="s3">= [</span><span class="s1">block_size</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">axes</span><span class="s3">]</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">_freq_domain_conv</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">fft_axes</span><span class="s3">, </span><span class="s1">fft_shape</span><span class="s3">, </span><span class="s1">calc_fast_len</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s0"># Do the overlap-add.</span>
    <span class="s2">for </span><span class="s1">ax</span><span class="s3">, </span><span class="s1">ax_fft</span><span class="s3">, </span><span class="s1">ax_split </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">axes</span><span class="s3">, </span><span class="s1">fft_axes</span><span class="s3">, </span><span class="s1">split_axes</span><span class="s3">):</span>
        <span class="s1">overlap </span><span class="s3">= </span><span class="s1">overlaps</span><span class="s3">[</span><span class="s1">ax</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">overlap </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">continue</span>

        <span class="s1">ret</span><span class="s3">, </span><span class="s1">overpart </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, [-</span><span class="s1">overlap</span><span class="s3">], </span><span class="s1">ax_fft</span><span class="s3">)</span>
        <span class="s1">overpart </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">overpart</span><span class="s3">, [-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">ax_split</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>

        <span class="s1">ret_overpart </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, [</span><span class="s1">overlap</span><span class="s3">], </span><span class="s1">ax_fft</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">ret_overpart </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">ret_overpart</span><span class="s3">, [</span><span class="s5">1</span><span class="s3">], </span><span class="s1">ax_split</span><span class="s3">)[</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s1">ret_overpart </span><span class="s3">+= </span><span class="s1">overpart</span>

    <span class="s0"># Reshape back to the correct dimensionality.</span>
    <span class="s1">shape_ret </span><span class="s3">= [</span><span class="s1">ret</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] </span><span class="s2">if </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">fft_axes </span><span class="s2">else</span>
                 <span class="s1">ret</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]*</span><span class="s1">ret</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">i</span><span class="s3">-</span><span class="s5">1</span><span class="s3">]</span>
                 <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">) </span><span class="s2">if </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">split_axes</span><span class="s3">]</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(*</span><span class="s1">shape_ret</span><span class="s3">)</span>

    <span class="s0"># Slice to the correct size.</span>
    <span class="s1">slice_final </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">islice</span><span class="s3">) </span><span class="s2">for </span><span class="s1">islice </span><span class="s2">in </span><span class="s1">shape_final</span><span class="s3">])</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">[</span><span class="s1">slice_final</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">_apply_conv_mode</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s1">s1</span><span class="s3">, </span><span class="s1">s2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_numeric_arrays</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">kinds</span><span class="s3">=</span><span class="s4">'buifc'</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    See if a list of arrays are all numeric. 
 
    Parameters 
    ---------- 
    arrays : array or list of arrays 
        arrays to check if numeric. 
    kinds : string-like 
        The dtypes of the arrays to be checked. If the dtype.kind of 
        the ndarrays are not in this string the function returns False and 
        otherwise returns True. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">) == </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">arrays</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s2">in </span><span class="s1">kinds</span>
    <span class="s2">for </span><span class="s1">array_ </span><span class="s2">in </span><span class="s1">arrays</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">array_</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s2">not in </span><span class="s1">kinds</span><span class="s3">:</span>
            <span class="s2">return False</span>
    <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">_conv_ops</span><span class="s3">(</span><span class="s1">x_shape</span><span class="s3">, </span><span class="s1">h_shape</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Find the number of operations required for direct/fft methods of 
    convolution. The direct operations were recorded by making a dummy class to 
    record the number of operations by overriding ``__mul__`` and ``__add__``. 
    The FFT operations rely on the (well-known) computational complexity of the 
    FFT (and the implementation of ``_freq_domain_conv``). 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">&quot;full&quot;</span><span class="s3">:</span>
        <span class="s1">out_shape </span><span class="s3">= [</span><span class="s1">n </span><span class="s3">+ </span><span class="s1">k </span><span class="s3">- </span><span class="s5">1 </span><span class="s2">for </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">x_shape</span><span class="s3">, </span><span class="s1">h_shape</span><span class="s3">)]</span>
    <span class="s2">elif </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">&quot;valid&quot;</span><span class="s3">:</span>
        <span class="s1">out_shape </span><span class="s3">= [</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">n </span><span class="s3">- </span><span class="s1">k</span><span class="s3">) + </span><span class="s5">1 </span><span class="s2">for </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">x_shape</span><span class="s3">, </span><span class="s1">h_shape</span><span class="s3">)]</span>
    <span class="s2">elif </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">&quot;same&quot;</span><span class="s3">:</span>
        <span class="s1">out_shape </span><span class="s3">= </span><span class="s1">x_shape</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Acceptable mode flags are 'valid',&quot;</span>
                         <span class="s4">f&quot; 'same', or 'full', not mode=</span><span class="s2">{</span><span class="s1">mode</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>

    <span class="s1">s1</span><span class="s3">, </span><span class="s1">s2 </span><span class="s3">= </span><span class="s1">x_shape</span><span class="s3">, </span><span class="s1">h_shape</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">x_shape</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">s1</span><span class="s3">, </span><span class="s1">s2 </span><span class="s3">= </span><span class="s1">s1</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">s2</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">&quot;full&quot;</span><span class="s3">:</span>
            <span class="s1">direct_ops </span><span class="s3">= </span><span class="s1">s1 </span><span class="s3">* </span><span class="s1">s2</span>
        <span class="s2">elif </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">&quot;valid&quot;</span><span class="s3">:</span>
            <span class="s1">direct_ops </span><span class="s3">= (</span><span class="s1">s2 </span><span class="s3">- </span><span class="s1">s1 </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">) * </span><span class="s1">s1 </span><span class="s2">if </span><span class="s1">s2 </span><span class="s3">&gt;= </span><span class="s1">s1 </span><span class="s2">else </span><span class="s3">(</span><span class="s1">s1 </span><span class="s3">- </span><span class="s1">s2 </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">) * </span><span class="s1">s2</span>
        <span class="s2">elif </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">&quot;same&quot;</span><span class="s3">:</span>
            <span class="s1">direct_ops </span><span class="s3">= (</span><span class="s1">s1 </span><span class="s3">* </span><span class="s1">s2 </span><span class="s2">if </span><span class="s1">s1 </span><span class="s3">&lt; </span><span class="s1">s2 </span><span class="s2">else</span>
                          <span class="s1">s1 </span><span class="s3">* </span><span class="s1">s2 </span><span class="s3">- (</span><span class="s1">s2 </span><span class="s3">// </span><span class="s5">2</span><span class="s3">) * ((</span><span class="s1">s2 </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">) // </span><span class="s5">2</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">&quot;full&quot;</span><span class="s3">:</span>
            <span class="s1">direct_ops </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">_prod</span><span class="s3">(</span><span class="s1">s1</span><span class="s3">), </span><span class="s1">_prod</span><span class="s3">(</span><span class="s1">s2</span><span class="s3">)) * </span><span class="s1">_prod</span><span class="s3">(</span><span class="s1">out_shape</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">&quot;valid&quot;</span><span class="s3">:</span>
            <span class="s1">direct_ops </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">_prod</span><span class="s3">(</span><span class="s1">s1</span><span class="s3">), </span><span class="s1">_prod</span><span class="s3">(</span><span class="s1">s2</span><span class="s3">)) * </span><span class="s1">_prod</span><span class="s3">(</span><span class="s1">out_shape</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">&quot;same&quot;</span><span class="s3">:</span>
            <span class="s1">direct_ops </span><span class="s3">= </span><span class="s1">_prod</span><span class="s3">(</span><span class="s1">s1</span><span class="s3">) * </span><span class="s1">_prod</span><span class="s3">(</span><span class="s1">s2</span><span class="s3">)</span>

    <span class="s1">full_out_shape </span><span class="s3">= [</span><span class="s1">n </span><span class="s3">+ </span><span class="s1">k </span><span class="s3">- </span><span class="s5">1 </span><span class="s2">for </span><span class="s1">n</span><span class="s3">, </span><span class="s1">k </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">x_shape</span><span class="s3">, </span><span class="s1">h_shape</span><span class="s3">)]</span>
    <span class="s1">N </span><span class="s3">= </span><span class="s1">_prod</span><span class="s3">(</span><span class="s1">full_out_shape</span><span class="s3">)</span>
    <span class="s1">fft_ops </span><span class="s3">= </span><span class="s5">3 </span><span class="s3">* </span><span class="s1">N </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">N</span><span class="s3">)  </span><span class="s0"># 3 separate FFTs of size full_out_shape</span>
    <span class="s2">return </span><span class="s1">fft_ops</span><span class="s3">, </span><span class="s1">direct_ops</span>


<span class="s2">def </span><span class="s1">_fftconv_faster</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">h</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    See if using fftconvolve or convolve is faster. 
 
    Parameters 
    ---------- 
    x : np.ndarray 
        Signal 
    h : np.ndarray 
        Kernel 
    mode : str 
        Mode passed to convolve 
 
    Returns 
    ------- 
    fft_faster : bool 
 
    Notes 
    ----- 
    See docstring of `choose_conv_method` for details on tuning hardware. 
 
    See pull request 11031 for more detail: 
    https://github.com/scipy/scipy/pull/11031. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">fft_ops</span><span class="s3">, </span><span class="s1">direct_ops </span><span class="s3">= </span><span class="s1">_conv_ops</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">h</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">)</span>
    <span class="s1">offset </span><span class="s3">= -</span><span class="s5">1e-3 </span><span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1 </span><span class="s2">else </span><span class="s3">-</span><span class="s5">1e-4</span>
    <span class="s1">constants </span><span class="s3">= {</span>
            <span class="s4">&quot;valid&quot;</span><span class="s3">: (</span><span class="s5">1.89095737e-9</span><span class="s3">, </span><span class="s5">2.1364985e-10</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">),</span>
            <span class="s4">&quot;full&quot;</span><span class="s3">: (</span><span class="s5">1.7649070e-9</span><span class="s3">, </span><span class="s5">2.1414831e-10</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">),</span>
            <span class="s4">&quot;same&quot;</span><span class="s3">: (</span><span class="s5">3.2646654e-9</span><span class="s3">, </span><span class="s5">2.8478277e-10</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">h</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&lt;= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">size</span>
            <span class="s2">else </span><span class="s3">(</span><span class="s5">3.21635404e-9</span><span class="s3">, </span><span class="s5">1.1773253e-8</span><span class="s3">, -</span><span class="s5">1e-5</span><span class="s3">),</span>
    <span class="s3">} </span><span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1 </span><span class="s2">else </span><span class="s3">{</span>
            <span class="s4">&quot;valid&quot;</span><span class="s3">: (</span><span class="s5">1.85927e-9</span><span class="s3">, </span><span class="s5">2.11242e-8</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">),</span>
            <span class="s4">&quot;full&quot;</span><span class="s3">: (</span><span class="s5">1.99817e-9</span><span class="s3">, </span><span class="s5">1.66174e-8</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">),</span>
            <span class="s4">&quot;same&quot;</span><span class="s3">: (</span><span class="s5">2.04735e-9</span><span class="s3">, </span><span class="s5">1.55367e-8</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">),</span>
    <span class="s3">}</span>
    <span class="s1">O_fft</span><span class="s3">, </span><span class="s1">O_direct</span><span class="s3">, </span><span class="s1">O_offset </span><span class="s3">= </span><span class="s1">constants</span><span class="s3">[</span><span class="s1">mode</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">O_fft </span><span class="s3">* </span><span class="s1">fft_ops </span><span class="s3">&lt; </span><span class="s1">O_direct </span><span class="s3">* </span><span class="s1">direct_ops </span><span class="s3">+ </span><span class="s1">O_offset</span>


<span class="s2">def </span><span class="s1">_reverse_and_conj</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Reverse array `x` in all dimensions and perform the complex conjugate 
    &quot;&quot;&quot;</span>
    <span class="s1">reverse </span><span class="s3">= (</span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">),) * </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s2">return </span><span class="s1">x</span><span class="s3">[</span><span class="s1">reverse</span><span class="s3">].</span><span class="s1">conj</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">_np_conv_ok</span><span class="s3">(</span><span class="s1">volume</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    See if numpy supports convolution of `volume` and `kernel` (i.e. both are 
    1D ndarrays and of the appropriate shape).  NumPy's 'same' mode uses the 
    size of the larger input, while SciPy's uses the size of the first input. 
 
    Invalid mode strings will return False and be caught by the calling func. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">volume</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s1">kernel</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">mode </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'full'</span><span class="s3">, </span><span class="s4">'valid'</span><span class="s3">):</span>
            <span class="s2">return True</span>
        <span class="s2">elif </span><span class="s1">mode </span><span class="s3">== </span><span class="s4">'same'</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">volume</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt;= </span><span class="s1">kernel</span><span class="s3">.</span><span class="s1">size</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">_timeit_fast</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">=</span><span class="s4">&quot;pass&quot;</span><span class="s3">, </span><span class="s1">setup</span><span class="s3">=</span><span class="s4">&quot;pass&quot;</span><span class="s3">, </span><span class="s1">repeat</span><span class="s3">=</span><span class="s5">3</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Returns the time the statement/function took, in seconds. 
 
    Faster, less precise version of IPython's timeit. `stmt` can be a statement 
    written as a string or a callable. 
 
    Will do only 1 loop (like IPython's timeit) with no repetitions 
    (unlike IPython) for very slow functions.  For fast functions, only does 
    enough loops to take 5 ms, which seems to produce similar results (on 
    Windows at least), and avoids doing an extraneous cycle that isn't 
    measured. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">timer </span><span class="s3">= </span><span class="s1">timeit</span><span class="s3">.</span><span class="s1">Timer</span><span class="s3">(</span><span class="s1">stmt</span><span class="s3">, </span><span class="s1">setup</span><span class="s3">)</span>

    <span class="s0"># determine number of calls per rep so total time for 1 rep &gt;= 5 ms</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">10</span><span class="s3">):</span>
        <span class="s1">number </span><span class="s3">= </span><span class="s5">10</span><span class="s3">**</span><span class="s1">p</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">timer</span><span class="s3">.</span><span class="s1">timeit</span><span class="s3">(</span><span class="s1">number</span><span class="s3">)  </span><span class="s0"># seconds</span>
        <span class="s2">if </span><span class="s1">x </span><span class="s3">&gt;= </span><span class="s5">5e-3 </span><span class="s3">/ </span><span class="s5">10</span><span class="s3">:  </span><span class="s0"># 5 ms for final test, 1/10th that for this one</span>
            <span class="s2">break</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:  </span><span class="s0"># second</span>
        <span class="s0"># If it's macroscopic, don't bother with repetitions</span>
        <span class="s1">best </span><span class="s3">= </span><span class="s1">x</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">number </span><span class="s3">*= </span><span class="s5">10</span>
        <span class="s1">r </span><span class="s3">= </span><span class="s1">timer</span><span class="s3">.</span><span class="s1">repeat</span><span class="s3">(</span><span class="s1">repeat</span><span class="s3">, </span><span class="s1">number</span><span class="s3">)</span>
        <span class="s1">best </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

    <span class="s1">sec </span><span class="s3">= </span><span class="s1">best </span><span class="s3">/ </span><span class="s1">number</span>
    <span class="s2">return </span><span class="s1">sec</span>


<span class="s2">def </span><span class="s1">choose_conv_method</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'full'</span><span class="s3">, </span><span class="s1">measure</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Find the fastest convolution/correlation method. 
 
    This primarily exists to be called during the ``method='auto'`` option in 
    `convolve` and `correlate`. It can also be used to determine the value of 
    ``method`` for many different convolutions of the same dtype/shape. 
    In addition, it supports timing the convolution to adapt the value of 
    ``method`` to a particular set of inputs and/or hardware. 
 
    Parameters 
    ---------- 
    in1 : array_like 
        The first argument passed into the convolution function. 
    in2 : array_like 
        The second argument passed into the convolution function. 
    mode : str {'full', 'valid', 'same'}, optional 
        A string indicating the size of the output: 
 
        ``full`` 
           The output is the full discrete linear convolution 
           of the inputs. (Default) 
        ``valid`` 
           The output consists only of those elements that do not 
           rely on the zero-padding. 
        ``same`` 
           The output is the same size as `in1`, centered 
           with respect to the 'full' output. 
    measure : bool, optional 
        If True, run and time the convolution of `in1` and `in2` with both 
        methods and return the fastest. If False (default), predict the fastest 
        method using precomputed values. 
 
    Returns 
    ------- 
    method : str 
        A string indicating which convolution method is fastest, either 
        'direct' or 'fft' 
    times : dict, optional 
        A dictionary containing the times (in seconds) needed for each method. 
        This value is only returned if ``measure=True``. 
 
    See Also 
    -------- 
    convolve 
    correlate 
 
    Notes 
    ----- 
    Generally, this method is 99% accurate for 2D signals and 85% accurate 
    for 1D signals for randomly chosen input sizes. For precision, use 
    ``measure=True`` to find the fastest method by timing the convolution. 
    This can be used to avoid the minimal overhead of finding the fastest 
    ``method`` later, or to adapt the value of ``method`` to a particular set 
    of inputs. 
 
    Experiments were run on an Amazon EC2 r5a.2xlarge machine to test this 
    function. These experiments measured the ratio between the time required 
    when using ``method='auto'`` and the time required for the fastest method 
    (i.e., ``ratio = time_auto / min(time_fft, time_direct)``). In these 
    experiments, we found: 
 
    * There is a 95% chance of this ratio being less than 1.5 for 1D signals 
      and a 99% chance of being less than 2.5 for 2D signals. 
    * The ratio was always less than 2.5/5 for 1D/2D signals respectively. 
    * This function is most inaccurate for 1D convolutions that take between 1 
      and 10 milliseconds with ``method='direct'``. A good proxy for this 
      (at least in our experiments) is ``1e6 &lt;= in1.size * in2.size &lt;= 1e7``. 
 
    The 2D results almost certainly generalize to 3D/4D/etc because the 
    implementation is the same (the 1D implementation is different). 
 
    All the numbers above are specific to the EC2 machine. However, we did find 
    that this function generalizes fairly decently across hardware. The speed 
    tests were of similar quality (and even slightly better) than the same 
    tests performed on the machine to tune this function's numbers (a mid-2014 
    15-inch MacBook Pro with 16GB RAM and a 2.5GHz Intel i7 processor). 
 
    There are cases when `fftconvolve` supports the inputs but this function 
    returns `direct` (e.g., to protect against floating point integer 
    precision). 
 
    .. versionadded:: 0.19 
 
    Examples 
    -------- 
    Estimate the fastest method for a given input: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; img = rng.random((32, 32)) 
    &gt;&gt;&gt; filter = rng.random((8, 8)) 
    &gt;&gt;&gt; method = signal.choose_conv_method(img, filter, mode='same') 
    &gt;&gt;&gt; method 
    'fft' 
 
    This can then be applied to other arrays of the same dtype and shape: 
 
    &gt;&gt;&gt; img2 = rng.random((32, 32)) 
    &gt;&gt;&gt; filter2 = rng.random((8, 8)) 
    &gt;&gt;&gt; corr2 = signal.correlate(img2, filter2, mode='same', method=method) 
    &gt;&gt;&gt; conv2 = signal.convolve(img2, filter2, mode='same', method=method) 
 
    The output of this function (``method``) works with `correlate` and 
    `convolve`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">volume </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">)</span>
    <span class="s1">kernel </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">in2</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">measure</span><span class="s3">:</span>
        <span class="s1">times </span><span class="s3">= {}</span>
        <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'fft'</span><span class="s3">, </span><span class="s4">'direct'</span><span class="s3">]:</span>
            <span class="s1">times</span><span class="s3">[</span><span class="s1">method</span><span class="s3">] = </span><span class="s1">_timeit_fast</span><span class="s3">(</span><span class="s2">lambda</span><span class="s3">: </span><span class="s1">convolve</span><span class="s3">(</span><span class="s1">volume</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">,</span>
                                         <span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s1">method</span><span class="s3">))</span>

        <span class="s1">chosen_method </span><span class="s3">= </span><span class="s4">'fft' </span><span class="s2">if </span><span class="s1">times</span><span class="s3">[</span><span class="s4">'fft'</span><span class="s3">] &lt; </span><span class="s1">times</span><span class="s3">[</span><span class="s4">'direct'</span><span class="s3">] </span><span class="s2">else </span><span class="s4">'direct'</span>
        <span class="s2">return </span><span class="s1">chosen_method</span><span class="s3">, </span><span class="s1">times</span>

    <span class="s0"># for integer input,</span>
    <span class="s0"># catch when more precision required than float provides (representing an</span>
    <span class="s0"># integer as float can lose precision in fftconvolve if larger than 2**52)</span>
    <span class="s2">if </span><span class="s1">any</span><span class="s3">([</span><span class="s1">_numeric_arrays</span><span class="s3">([</span><span class="s1">x</span><span class="s3">], </span><span class="s1">kinds</span><span class="s3">=</span><span class="s4">'ui'</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s3">[</span><span class="s1">volume</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">]]):</span>
        <span class="s1">max_value </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">volume</span><span class="s3">).</span><span class="s1">max</span><span class="s3">()) * </span><span class="s1">int</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">kernel</span><span class="s3">).</span><span class="s1">max</span><span class="s3">())</span>
        <span class="s1">max_value </span><span class="s3">*= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">min</span><span class="s3">(</span><span class="s1">volume</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">.</span><span class="s1">size</span><span class="s3">))</span>
        <span class="s2">if </span><span class="s1">max_value </span><span class="s3">&gt; </span><span class="s5">2</span><span class="s3">**</span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s4">'float'</span><span class="s3">).</span><span class="s1">nmant </span><span class="s3">- </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s4">'direct'</span>

    <span class="s2">if </span><span class="s1">_numeric_arrays</span><span class="s3">([</span><span class="s1">volume</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">], </span><span class="s1">kinds</span><span class="s3">=</span><span class="s4">'b'</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s4">'direct'</span>

    <span class="s2">if </span><span class="s1">_numeric_arrays</span><span class="s3">([</span><span class="s1">volume</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">]):</span>
        <span class="s2">if </span><span class="s1">_fftconv_faster</span><span class="s3">(</span><span class="s1">volume</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s4">'fft'</span>

    <span class="s2">return </span><span class="s4">'direct'</span>


<span class="s2">def </span><span class="s1">convolve</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'full'</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">'auto'</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Convolve two N-dimensional arrays. 
 
    Convolve `in1` and `in2`, with the output size determined by the 
    `mode` argument. 
 
    Parameters 
    ---------- 
    in1 : array_like 
        First input. 
    in2 : array_like 
        Second input. Should have the same number of dimensions as `in1`. 
    mode : str {'full', 'valid', 'same'}, optional 
        A string indicating the size of the output: 
 
        ``full`` 
           The output is the full discrete linear convolution 
           of the inputs. (Default) 
        ``valid`` 
           The output consists only of those elements that do not 
           rely on the zero-padding. In 'valid' mode, either `in1` or `in2` 
           must be at least as large as the other in every dimension. 
        ``same`` 
           The output is the same size as `in1`, centered 
           with respect to the 'full' output. 
    method : str {'auto', 'direct', 'fft'}, optional 
        A string indicating which method to use to calculate the convolution. 
 
        ``direct`` 
           The convolution is determined directly from sums, the definition of 
           convolution. 
        ``fft`` 
           The Fourier Transform is used to perform the convolution by calling 
           `fftconvolve`. 
        ``auto`` 
           Automatically chooses direct or Fourier method based on an estimate 
           of which is faster (default).  See Notes for more detail. 
 
           .. versionadded:: 0.19.0 
 
    Returns 
    ------- 
    convolve : array 
        An N-dimensional array containing a subset of the discrete linear 
        convolution of `in1` with `in2`. 
 
    Warns 
    ----- 
    RuntimeWarning 
        Use of the FFT convolution on input containing NAN or INF will lead 
        to the entire output being NAN or INF. Use method='direct' when your 
        input contains NAN or INF values. 
 
    See Also 
    -------- 
    numpy.polymul : performs polynomial multiplication (same operation, but 
                    also accepts poly1d objects) 
    choose_conv_method : chooses the fastest appropriate convolution method 
    fftconvolve : Always uses the FFT method. 
    oaconvolve : Uses the overlap-add method to do convolution, which is 
                 generally faster when the input arrays are large and 
                 significantly different in size. 
 
    Notes 
    ----- 
    By default, `convolve` and `correlate` use ``method='auto'``, which calls 
    `choose_conv_method` to choose the fastest method using pre-computed 
    values (`choose_conv_method` can also measure real-world timing with a 
    keyword argument). Because `fftconvolve` relies on floating point numbers, 
    there are certain constraints that may force `method=direct` (more detail 
    in `choose_conv_method` docstring). 
 
    Examples 
    -------- 
    Smooth a square pulse using a Hann window: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; sig = np.repeat([0., 1., 0.], 100) 
    &gt;&gt;&gt; win = signal.windows.hann(50) 
    &gt;&gt;&gt; filtered = signal.convolve(sig, win, mode='same') / sum(win) 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, (ax_orig, ax_win, ax_filt) = plt.subplots(3, 1, sharex=True) 
    &gt;&gt;&gt; ax_orig.plot(sig) 
    &gt;&gt;&gt; ax_orig.set_title('Original pulse') 
    &gt;&gt;&gt; ax_orig.margins(0, 0.1) 
    &gt;&gt;&gt; ax_win.plot(win) 
    &gt;&gt;&gt; ax_win.set_title('Filter impulse response') 
    &gt;&gt;&gt; ax_win.margins(0, 0.1) 
    &gt;&gt;&gt; ax_filt.plot(filtered) 
    &gt;&gt;&gt; ax_filt.set_title('Filtered signal') 
    &gt;&gt;&gt; ax_filt.margins(0, 0.1) 
    &gt;&gt;&gt; fig.tight_layout() 
    &gt;&gt;&gt; fig.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">volume </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">)</span>
    <span class="s1">kernel </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">in2</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">volume</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s1">kernel</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">volume </span><span class="s3">* </span><span class="s1">kernel</span>
    <span class="s2">elif </span><span class="s1">volume</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s1">kernel</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;volume and kernel should have the same &quot;</span>
                         <span class="s4">&quot;dimensionality&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">_inputs_swap_needed</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">volume</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">):</span>
        <span class="s0"># Convolution is commutative; order doesn't have any effect on output</span>
        <span class="s1">volume</span><span class="s3">, </span><span class="s1">kernel </span><span class="s3">= </span><span class="s1">kernel</span><span class="s3">, </span><span class="s1">volume</span>

    <span class="s2">if </span><span class="s1">method </span><span class="s3">== </span><span class="s4">'auto'</span><span class="s3">:</span>
        <span class="s1">method </span><span class="s3">= </span><span class="s1">choose_conv_method</span><span class="s3">(</span><span class="s1">volume</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">method </span><span class="s3">== </span><span class="s4">'fft'</span><span class="s3">:</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">fftconvolve</span><span class="s3">(</span><span class="s1">volume</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s1">mode</span><span class="s3">)</span>
        <span class="s1">result_type </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">result_type</span><span class="s3">(</span><span class="s1">volume</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">result_type</span><span class="s3">.</span><span class="s1">kind </span><span class="s2">in </span><span class="s3">{</span><span class="s4">'u'</span><span class="s3">, </span><span class="s4">'i'</span><span class="s3">}:</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">around</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">out</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) </span><span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isinf</span><span class="s3">(</span><span class="s1">out</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]):</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">&quot;Use of fft convolution on input with NAN or inf&quot;</span>
                          <span class="s4">&quot; results in NAN or inf output. Consider using&quot;</span>
                          <span class="s4">&quot; method='direct' instead.&quot;</span><span class="s3">,</span>
                          <span class="s1">category</span><span class="s3">=</span><span class="s1">RuntimeWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">out</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">result_type</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">method </span><span class="s3">== </span><span class="s4">'direct'</span><span class="s3">:</span>
        <span class="s0"># fastpath to faster numpy.convolve for 1d inputs when possible</span>
        <span class="s2">if </span><span class="s1">_np_conv_ok</span><span class="s3">(</span><span class="s1">volume</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">convolve</span><span class="s3">(</span><span class="s1">volume</span><span class="s3">, </span><span class="s1">kernel</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">correlate</span><span class="s3">(</span><span class="s1">volume</span><span class="s3">, </span><span class="s1">_reverse_and_conj</span><span class="s3">(</span><span class="s1">kernel</span><span class="s3">), </span><span class="s1">mode</span><span class="s3">, </span><span class="s4">'direct'</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Acceptable method flags are 'auto',&quot;</span>
                         <span class="s4">&quot; 'direct', or 'fft'.&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">order_filter</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">domain</span><span class="s3">, </span><span class="s1">rank</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Perform an order filter on an N-D array. 
 
    Perform an order filter on the array in. The domain argument acts as a 
    mask centered over each pixel. The non-zero elements of domain are 
    used to select elements surrounding each input pixel which are placed 
    in a list. The list is sorted, and the output for that pixel is the 
    element corresponding to rank in the sorted list. 
 
    Parameters 
    ---------- 
    a : ndarray 
        The N-dimensional input array. 
    domain : array_like 
        A mask array with the same number of dimensions as `a`. 
        Each dimension should have an odd number of elements. 
    rank : int 
        A non-negative integer which selects the element from the 
        sorted list (0 corresponds to the smallest element, 1 is the 
        next smallest element, etc.). 
 
    Returns 
    ------- 
    out : ndarray 
        The results of the order filter in an array with the same 
        shape as `a`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; x = np.arange(25).reshape(5, 5) 
    &gt;&gt;&gt; domain = np.identity(3) 
    &gt;&gt;&gt; x 
    array([[ 0,  1,  2,  3,  4], 
           [ 5,  6,  7,  8,  9], 
           [10, 11, 12, 13, 14], 
           [15, 16, 17, 18, 19], 
           [20, 21, 22, 23, 24]]) 
    &gt;&gt;&gt; signal.order_filter(x, domain, 0) 
    array([[  0.,   0.,   0.,   0.,   0.], 
           [  0.,   0.,   1.,   2.,   0.], 
           [  0.,   5.,   6.,   7.,   0.], 
           [  0.,  10.,  11.,  12.,   0.], 
           [  0.,   0.,   0.,   0.,   0.]]) 
    &gt;&gt;&gt; signal.order_filter(x, domain, 2) 
    array([[  6.,   7.,   8.,   9.,   4.], 
           [ 11.,  12.,  13.,  14.,   9.], 
           [ 16.,  17.,  18.,  19.,  14.], 
           [ 21.,  22.,  23.,  24.,  19.], 
           [ 20.,  21.,  22.,  23.,  24.]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">domain </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">domain</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">dimsize </span><span class="s2">in </span><span class="s1">domain</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">dimsize </span><span class="s3">% </span><span class="s5">2</span><span class="s3">) != </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Each dimension of domain argument &quot;</span>
                             <span class="s4">&quot;should have an odd number of elements.&quot;</span><span class="s3">)</span>

    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">) </span>
            <span class="s2">or </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">in </span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">]):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;dtype=</span><span class="s2">{</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s2">} </span><span class="s4">is not supported by order_filter&quot;</span><span class="s3">)</span>

    <span class="s1">result </span><span class="s3">= </span><span class="s1">ndimage</span><span class="s3">.</span><span class="s1">rank_filter</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">rank</span><span class="s3">, </span><span class="s1">footprint</span><span class="s3">=</span><span class="s1">domain</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'constant'</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">medfilt</span><span class="s3">(</span><span class="s1">volume</span><span class="s3">, </span><span class="s1">kernel_size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Perform a median filter on an N-dimensional array. 
 
    Apply a median filter to the input array using a local window-size 
    given by `kernel_size`. The array will automatically be zero-padded. 
 
    Parameters 
    ---------- 
    volume : array_like 
        An N-dimensional input array. 
    kernel_size : array_like, optional 
        A scalar or an N-length list giving the size of the median filter 
        window in each dimension.  Elements of `kernel_size` should be odd. 
        If `kernel_size` is a scalar, then this scalar is used as the size in 
        each dimension. Default size is 3 for each dimension. 
 
    Returns 
    ------- 
    out : ndarray 
        An array the same size as input containing the median filtered 
        result. 
 
    Warns 
    ----- 
    UserWarning 
        If array size is smaller than kernel size along any dimension 
 
    See Also 
    -------- 
    scipy.ndimage.median_filter 
    scipy.signal.medfilt2d 
 
    Notes 
    ----- 
    The more general function `scipy.ndimage.median_filter` has a more 
    efficient implementation of a median filter and therefore runs much faster. 
 
    For 2-dimensional images with ``uint8``, ``float32`` or ``float64`` dtypes, 
    the specialised function `scipy.signal.medfilt2d` may be faster. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">volume </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">volume</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">volume</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">) </span>
            <span class="s2">or </span><span class="s1">volume</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">in </span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">]):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;dtype=</span><span class="s2">{</span><span class="s1">volume</span><span class="s3">.</span><span class="s1">dtype</span><span class="s2">} </span><span class="s4">is not supported by medfilt&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">kernel_size </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">kernel_size </span><span class="s3">= [</span><span class="s5">3</span><span class="s3">] * </span><span class="s1">volume</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s1">kernel_size </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">kernel_size</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">kernel_size</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== ():</span>
        <span class="s1">kernel_size </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">repeat</span><span class="s3">(</span><span class="s1">kernel_size</span><span class="s3">.</span><span class="s1">item</span><span class="s3">(), </span><span class="s1">volume</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">volume</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">kernel_size</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] % </span><span class="s5">2</span><span class="s3">) != </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Each element of kernel_size should be odd.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">any</span><span class="s3">(</span><span class="s1">k </span><span class="s3">&gt; </span><span class="s1">s </span><span class="s2">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">s </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">kernel_size</span><span class="s3">, </span><span class="s1">volume</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)):</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">'kernel_size exceeds volume extent: the volume will be '</span>
                      <span class="s4">'zero-padded.'</span><span class="s3">,</span>
                      <span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>

    <span class="s1">size </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">kernel_size</span><span class="s3">)</span>
    <span class="s1">result </span><span class="s3">= </span><span class="s1">ndimage</span><span class="s3">.</span><span class="s1">rank_filter</span><span class="s3">(</span><span class="s1">volume</span><span class="s3">, </span><span class="s1">size </span><span class="s3">// </span><span class="s5">2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">kernel_size</span><span class="s3">,</span>
                                 <span class="s1">mode</span><span class="s3">=</span><span class="s4">'constant'</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">wiener</span><span class="s3">(</span><span class="s1">im</span><span class="s3">, </span><span class="s1">mysize</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">noise</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Perform a Wiener filter on an N-dimensional array. 
 
    Apply a Wiener filter to the N-dimensional array `im`. 
 
    Parameters 
    ---------- 
    im : ndarray 
        An N-dimensional array. 
    mysize : int or array_like, optional 
        A scalar or an N-length list giving the size of the Wiener filter 
        window in each dimension.  Elements of mysize should be odd. 
        If mysize is a scalar, then this scalar is used as the size 
        in each dimension. 
    noise : float, optional 
        The noise-power to use. If None, then noise is estimated as the 
        average of the local variance of the input. 
 
    Returns 
    ------- 
    out : ndarray 
        Wiener filtered result with the same shape as `im`. 
 
    Notes 
    ----- 
    This implementation is similar to wiener2 in Matlab/Octave. 
    For more details see [1]_ 
 
    References 
    ---------- 
    .. [1] Lim, Jae S., Two-Dimensional Signal and Image Processing, 
           Englewood Cliffs, NJ, Prentice Hall, 1990, p. 548. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.datasets import face 
    &gt;&gt;&gt; from scipy.signal import wiener 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; img = rng.random((40, 40))    #Create a random image 
    &gt;&gt;&gt; filtered_img = wiener(img, (5, 5))  #Filter the image 
    &gt;&gt;&gt; f, (plot1, plot2) = plt.subplots(1, 2) 
    &gt;&gt;&gt; plot1.imshow(img) 
    &gt;&gt;&gt; plot2.imshow(filtered_img) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">im </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">im</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">mysize </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">mysize </span><span class="s3">= [</span><span class="s5">3</span><span class="s3">] * </span><span class="s1">im</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s1">mysize </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">mysize</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">mysize</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== ():</span>
        <span class="s1">mysize </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">repeat</span><span class="s3">(</span><span class="s1">mysize</span><span class="s3">.</span><span class="s1">item</span><span class="s3">(), </span><span class="s1">im</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)</span>

    <span class="s0"># Estimate the local mean</span>
    <span class="s1">size </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">mysize</span><span class="s3">)</span>
    <span class="s1">lMean </span><span class="s3">= </span><span class="s1">correlate</span><span class="s3">(</span><span class="s1">im</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">mysize</span><span class="s3">), </span><span class="s4">'same'</span><span class="s3">) / </span><span class="s1">size</span>

    <span class="s0"># Estimate the local variance</span>
    <span class="s1">lVar </span><span class="s3">= (</span><span class="s1">correlate</span><span class="s3">(</span><span class="s1">im </span><span class="s3">** </span><span class="s5">2</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">mysize</span><span class="s3">), </span><span class="s4">'same'</span><span class="s3">) / </span><span class="s1">size </span><span class="s3">- </span><span class="s1">lMean </span><span class="s3">** </span><span class="s5">2</span><span class="s3">)</span>

    <span class="s0"># Estimate the noise power if needed.</span>
    <span class="s2">if </span><span class="s1">noise </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">noise </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">lVar</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= (</span><span class="s1">im </span><span class="s3">- </span><span class="s1">lMean</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">*= (</span><span class="s5">1 </span><span class="s3">- </span><span class="s1">noise </span><span class="s3">/ </span><span class="s1">lVar</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">+= </span><span class="s1">lMean</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">lVar </span><span class="s3">&lt; </span><span class="s1">noise</span><span class="s3">, </span><span class="s1">lMean</span><span class="s3">, </span><span class="s1">res</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">convolve2d</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'full'</span><span class="s3">, </span><span class="s1">boundary</span><span class="s3">=</span><span class="s4">'fill'</span><span class="s3">, </span><span class="s1">fillvalue</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Convolve two 2-dimensional arrays. 
 
    Convolve `in1` and `in2` with output size determined by `mode`, and 
    boundary conditions determined by `boundary` and `fillvalue`. 
 
    Parameters 
    ---------- 
    in1 : array_like 
        First input. 
    in2 : array_like 
        Second input. Should have the same number of dimensions as `in1`. 
    mode : str {'full', 'valid', 'same'}, optional 
        A string indicating the size of the output: 
 
        ``full`` 
           The output is the full discrete linear convolution 
           of the inputs. (Default) 
        ``valid`` 
           The output consists only of those elements that do not 
           rely on the zero-padding. In 'valid' mode, either `in1` or `in2` 
           must be at least as large as the other in every dimension. 
        ``same`` 
           The output is the same size as `in1`, centered 
           with respect to the 'full' output. 
    boundary : str {'fill', 'wrap', 'symm'}, optional 
        A flag indicating how to handle boundaries: 
 
        ``fill`` 
           pad input arrays with fillvalue. (default) 
        ``wrap`` 
           circular boundary conditions. 
        ``symm`` 
           symmetrical boundary conditions. 
 
    fillvalue : scalar, optional 
        Value to fill pad input arrays with. Default is 0. 
 
    Returns 
    ------- 
    out : ndarray 
        A 2-dimensional array containing a subset of the discrete linear 
        convolution of `in1` with `in2`. 
 
    Examples 
    -------- 
    Compute the gradient of an image by 2D convolution with a complex Scharr 
    operator.  (Horizontal operator is real, vertical is imaginary.)  Use 
    symmetric boundary condition to avoid creating edges at the image 
    boundaries. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; from scipy import datasets 
    &gt;&gt;&gt; ascent = datasets.ascent() 
    &gt;&gt;&gt; scharr = np.array([[ -3-3j, 0-10j,  +3 -3j], 
    ...                    [-10+0j, 0+ 0j, +10 +0j], 
    ...                    [ -3+3j, 0+10j,  +3 +3j]]) # Gx + j*Gy 
    &gt;&gt;&gt; grad = signal.convolve2d(ascent, scharr, boundary='symm', mode='same') 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, (ax_orig, ax_mag, ax_ang) = plt.subplots(3, 1, figsize=(6, 15)) 
    &gt;&gt;&gt; ax_orig.imshow(ascent, cmap='gray') 
    &gt;&gt;&gt; ax_orig.set_title('Original') 
    &gt;&gt;&gt; ax_orig.set_axis_off() 
    &gt;&gt;&gt; ax_mag.imshow(np.absolute(grad), cmap='gray') 
    &gt;&gt;&gt; ax_mag.set_title('Gradient magnitude') 
    &gt;&gt;&gt; ax_mag.set_axis_off() 
    &gt;&gt;&gt; ax_ang.imshow(np.angle(grad), cmap='hsv') # hsv is cyclic, like angles 
    &gt;&gt;&gt; ax_ang.set_title('Gradient orientation') 
    &gt;&gt;&gt; ax_ang.set_axis_off() 
    &gt;&gt;&gt; fig.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">in1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">)</span>
    <span class="s1">in2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">in2</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'convolve2d inputs must both be 2-D arrays'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">_inputs_swap_needed</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">):</span>
        <span class="s1">in1</span><span class="s3">, </span><span class="s1">in2 </span><span class="s3">= </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">in1</span>

    <span class="s1">val </span><span class="s3">= </span><span class="s1">_valfrommode</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">)</span>
    <span class="s1">bval </span><span class="s3">= </span><span class="s1">_bvalfromboundary</span><span class="s3">(</span><span class="s1">boundary</span><span class="s3">)</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">_sigtools</span><span class="s3">.</span><span class="s1">_convolve2d</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">bval</span><span class="s3">, </span><span class="s1">fillvalue</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">correlate2d</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'full'</span><span class="s3">, </span><span class="s1">boundary</span><span class="s3">=</span><span class="s4">'fill'</span><span class="s3">, </span><span class="s1">fillvalue</span><span class="s3">=</span><span class="s5">0</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Cross-correlate two 2-dimensional arrays. 
 
    Cross correlate `in1` and `in2` with output size determined by `mode`, and 
    boundary conditions determined by `boundary` and `fillvalue`. 
 
    Parameters 
    ---------- 
    in1 : array_like 
        First input. 
    in2 : array_like 
        Second input. Should have the same number of dimensions as `in1`. 
    mode : str {'full', 'valid', 'same'}, optional 
        A string indicating the size of the output: 
 
        ``full`` 
           The output is the full discrete linear cross-correlation 
           of the inputs. (Default) 
        ``valid`` 
           The output consists only of those elements that do not 
           rely on the zero-padding. In 'valid' mode, either `in1` or `in2` 
           must be at least as large as the other in every dimension. 
        ``same`` 
           The output is the same size as `in1`, centered 
           with respect to the 'full' output. 
    boundary : str {'fill', 'wrap', 'symm'}, optional 
        A flag indicating how to handle boundaries: 
 
        ``fill`` 
           pad input arrays with fillvalue. (default) 
        ``wrap`` 
           circular boundary conditions. 
        ``symm`` 
           symmetrical boundary conditions. 
 
    fillvalue : scalar, optional 
        Value to fill pad input arrays with. Default is 0. 
 
    Returns 
    ------- 
    correlate2d : ndarray 
        A 2-dimensional array containing a subset of the discrete linear 
        cross-correlation of `in1` with `in2`. 
 
    Notes 
    ----- 
    When using &quot;same&quot; mode with even-length inputs, the outputs of `correlate` 
    and `correlate2d` differ: There is a 1-index offset between them. 
 
    Examples 
    -------- 
    Use 2D cross-correlation to find the location of a template in a noisy 
    image: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal, datasets, ndimage 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; face = datasets.face(gray=True) - datasets.face(gray=True).mean() 
    &gt;&gt;&gt; face = ndimage.zoom(face[30:500, 400:950], 0.5)  # extract the face 
    &gt;&gt;&gt; template = np.copy(face[135:165, 140:175])  # right eye 
    &gt;&gt;&gt; template -= template.mean() 
    &gt;&gt;&gt; face = face + rng.standard_normal(face.shape) * 50  # add noise 
    &gt;&gt;&gt; corr = signal.correlate2d(face, template, boundary='symm', mode='same') 
    &gt;&gt;&gt; y, x = np.unravel_index(np.argmax(corr), corr.shape)  # find the match 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, (ax_orig, ax_template, ax_corr) = plt.subplots(3, 1, 
    ...                                                     figsize=(6, 15)) 
    &gt;&gt;&gt; ax_orig.imshow(face, cmap='gray') 
    &gt;&gt;&gt; ax_orig.set_title('Original') 
    &gt;&gt;&gt; ax_orig.set_axis_off() 
    &gt;&gt;&gt; ax_template.imshow(template, cmap='gray') 
    &gt;&gt;&gt; ax_template.set_title('Template') 
    &gt;&gt;&gt; ax_template.set_axis_off() 
    &gt;&gt;&gt; ax_corr.imshow(corr, cmap='gray') 
    &gt;&gt;&gt; ax_corr.set_title('Cross-correlation') 
    &gt;&gt;&gt; ax_corr.set_axis_off() 
    &gt;&gt;&gt; ax_orig.plot(x, y, 'ro') 
    &gt;&gt;&gt; fig.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">in1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">)</span>
    <span class="s1">in2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">in2</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'correlate2d inputs must both be 2-D arrays'</span><span class="s3">)</span>

    <span class="s1">swapped_inputs </span><span class="s3">= </span><span class="s1">_inputs_swap_needed</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">, </span><span class="s1">in1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">swapped_inputs</span><span class="s3">:</span>
        <span class="s1">in1</span><span class="s3">, </span><span class="s1">in2 </span><span class="s3">= </span><span class="s1">in2</span><span class="s3">, </span><span class="s1">in1</span>

    <span class="s1">val </span><span class="s3">= </span><span class="s1">_valfrommode</span><span class="s3">(</span><span class="s1">mode</span><span class="s3">)</span>
    <span class="s1">bval </span><span class="s3">= </span><span class="s1">_bvalfromboundary</span><span class="s3">(</span><span class="s1">boundary</span><span class="s3">)</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">_sigtools</span><span class="s3">.</span><span class="s1">_convolve2d</span><span class="s3">(</span><span class="s1">in1</span><span class="s3">, </span><span class="s1">in2</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">(), </span><span class="s5">0</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">bval</span><span class="s3">, </span><span class="s1">fillvalue</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">swapped_inputs</span><span class="s3">:</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">out</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">, ::-</span><span class="s5">1</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">medfilt2d</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">kernel_size</span><span class="s3">=</span><span class="s5">3</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Median filter a 2-dimensional array. 
 
    Apply a median filter to the `input` array using a local window-size 
    given by `kernel_size` (must be odd). The array is zero-padded 
    automatically. 
 
    Parameters 
    ---------- 
    input : array_like 
        A 2-dimensional input array. 
    kernel_size : array_like, optional 
        A scalar or a list of length 2, giving the size of the 
        median filter window in each dimension.  Elements of 
        `kernel_size` should be odd.  If `kernel_size` is a scalar, 
        then this scalar is used as the size in each dimension. 
        Default is a kernel of size (3, 3). 
 
    Returns 
    ------- 
    out : ndarray 
        An array the same size as input containing the median filtered 
        result. 
 
    See Also 
    -------- 
    scipy.ndimage.median_filter 
 
    Notes 
    ----- 
    This is faster than `medfilt` when the input dtype is ``uint8``, 
    ``float32``, or ``float64``; for other types, this falls back to 
    `medfilt`. In some situations, `scipy.ndimage.median_filter` may be 
    faster than this function. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; x = np.arange(25).reshape(5, 5) 
    &gt;&gt;&gt; x 
    array([[ 0,  1,  2,  3,  4], 
           [ 5,  6,  7,  8,  9], 
           [10, 11, 12, 13, 14], 
           [15, 16, 17, 18, 19], 
           [20, 21, 22, 23, 24]]) 
 
    # Replaces i,j with the median out of 5*5 window 
 
    &gt;&gt;&gt; signal.medfilt2d(x, kernel_size=5) 
    array([[ 0,  0,  2,  0,  0], 
           [ 0,  3,  7,  4,  0], 
           [ 2,  8, 12,  9,  4], 
           [ 0,  8, 12,  9,  0], 
           [ 0,  0, 12,  0,  0]]) 
 
    # Replaces i,j with the median out of default 3*3 window 
 
    &gt;&gt;&gt; signal.medfilt2d(x) 
    array([[ 0,  1,  2,  3,  0], 
           [ 1,  6,  7,  8,  4], 
           [ 6, 11, 12, 13,  9], 
           [11, 16, 17, 18, 14], 
           [ 0, 16, 17, 18,  0]]) 
 
    # Replaces i,j with the median out of default 5*3 window 
 
    &gt;&gt;&gt; signal.medfilt2d(x, kernel_size=[5,3]) 
    array([[ 0,  1,  2,  3,  0], 
           [ 0,  6,  7,  8,  3], 
           [ 5, 11, 12, 13,  8], 
           [ 5, 11, 12, 13,  8], 
           [ 0, 11, 12, 13,  0]]) 
 
    # Replaces i,j with the median out of default 3*5 window 
 
    &gt;&gt;&gt; signal.medfilt2d(x, kernel_size=[3,5]) 
    array([[ 0,  0,  2,  1,  0], 
           [ 1,  5,  7,  6,  3], 
           [ 6, 10, 12, 11,  8], 
           [11, 15, 17, 16, 13], 
           [ 0, 15, 17, 16,  0]]) 
 
    # As seen in the examples, 
    # kernel numbers must be odd and not exceed original array dim 
 
    &quot;&quot;&quot;</span>
    <span class="s1">image </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">input</span><span class="s3">)</span>

    <span class="s0"># checking dtype.type, rather than just dtype, is necessary for</span>
    <span class="s0"># excluding np.longdouble with MS Visual C.</span>
    <span class="s2">if </span><span class="s1">image</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type </span><span class="s2">not in </span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ubyte</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">medfilt</span><span class="s3">(</span><span class="s1">image</span><span class="s3">, </span><span class="s1">kernel_size</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">kernel_size </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">kernel_size </span><span class="s3">= [</span><span class="s5">3</span><span class="s3">] * </span><span class="s5">2</span>
    <span class="s1">kernel_size </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">kernel_size</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">kernel_size</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== ():</span>
        <span class="s1">kernel_size </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">repeat</span><span class="s3">(</span><span class="s1">kernel_size</span><span class="s3">.</span><span class="s1">item</span><span class="s3">(), </span><span class="s5">2</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">size </span><span class="s2">in </span><span class="s1">kernel_size</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">size </span><span class="s3">% </span><span class="s5">2</span><span class="s3">) != </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Each element of kernel_size should be odd.&quot;</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">_sigtools</span><span class="s3">.</span><span class="s1">_medfilt2d</span><span class="s3">(</span><span class="s1">image</span><span class="s3">, </span><span class="s1">kernel_size</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">lfilter</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">zi</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Filter data along one-dimension with an IIR or FIR filter. 
 
    Filter a data sequence, `x`, using a digital filter.  This works for many 
    fundamental data types (including Object type).  The filter is a direct 
    form II transposed implementation of the standard difference equation 
    (see Notes). 
 
    The function `sosfilt` (and filter design using ``output='sos'``) should be 
    preferred over `lfilter` for most filtering tasks, as second-order sections 
    have fewer numerical problems. 
 
    Parameters 
    ---------- 
    b : array_like 
        The numerator coefficient vector in a 1-D sequence. 
    a : array_like 
        The denominator coefficient vector in a 1-D sequence.  If ``a[0]`` 
        is not 1, then both `a` and `b` are normalized by ``a[0]``. 
    x : array_like 
        An N-dimensional input array. 
    axis : int, optional 
        The axis of the input data array along which to apply the 
        linear filter. The filter is applied to each subarray along 
        this axis.  Default is -1. 
    zi : array_like, optional 
        Initial conditions for the filter delays.  It is a vector 
        (or array of vectors for an N-dimensional input) of length 
        ``max(len(a), len(b)) - 1``.  If `zi` is None or is not given then 
        initial rest is assumed.  See `lfiltic` for more information. 
 
    Returns 
    ------- 
    y : array 
        The output of the digital filter. 
    zf : array, optional 
        If `zi` is None, this is not returned, otherwise, `zf` holds the 
        final filter delay values. 
 
    See Also 
    -------- 
    lfiltic : Construct initial conditions for `lfilter`. 
    lfilter_zi : Compute initial state (steady state of step response) for 
                 `lfilter`. 
    filtfilt : A forward-backward filter, to obtain a filter with zero phase. 
    savgol_filter : A Savitzky-Golay filter. 
    sosfilt: Filter data using cascaded second-order sections. 
    sosfiltfilt: A forward-backward filter using second-order sections. 
 
    Notes 
    ----- 
    The filter function is implemented as a direct II transposed structure. 
    This means that the filter implements:: 
 
       a[0]*y[n] = b[0]*x[n] + b[1]*x[n-1] + ... + b[M]*x[n-M] 
                             - a[1]*y[n-1] - ... - a[N]*y[n-N] 
 
    where `M` is the degree of the numerator, `N` is the degree of the 
    denominator, and `n` is the sample number.  It is implemented using 
    the following difference equations (assuming M = N):: 
 
         a[0]*y[n] = b[0] * x[n]               + d[0][n-1] 
           d[0][n] = b[1] * x[n] - a[1] * y[n] + d[1][n-1] 
           d[1][n] = b[2] * x[n] - a[2] * y[n] + d[2][n-1] 
         ... 
         d[N-2][n] = b[N-1]*x[n] - a[N-1]*y[n] + d[N-1][n-1] 
         d[N-1][n] = b[N] * x[n] - a[N] * y[n] 
 
    where `d` are the state variables. 
 
    The rational transfer function describing this filter in the 
    z-transform domain is:: 
 
                             -1              -M 
                 b[0] + b[1]z  + ... + b[M] z 
         Y(z) = -------------------------------- X(z) 
                             -1              -N 
                 a[0] + a[1]z  + ... + a[N] z 
 
    Examples 
    -------- 
    Generate a noisy signal to be filtered: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; t = np.linspace(-1, 1, 201) 
    &gt;&gt;&gt; x = (np.sin(2*np.pi*0.75*t*(1-t) + 2.1) + 
    ...      0.1*np.sin(2*np.pi*1.25*t + 1) + 
    ...      0.18*np.cos(2*np.pi*3.85*t)) 
    &gt;&gt;&gt; xn = x + rng.standard_normal(len(t)) * 0.08 
 
    Create an order 3 lowpass butterworth filter: 
 
    &gt;&gt;&gt; b, a = signal.butter(3, 0.05) 
 
    Apply the filter to xn.  Use lfilter_zi to choose the initial condition of 
    the filter: 
 
    &gt;&gt;&gt; zi = signal.lfilter_zi(b, a) 
    &gt;&gt;&gt; z, _ = signal.lfilter(b, a, xn, zi=zi*xn[0]) 
 
    Apply the filter again, to have a result filtered at an order the same as 
    filtfilt: 
 
    &gt;&gt;&gt; z2, _ = signal.lfilter(b, a, z, zi=zi*z[0]) 
 
    Use filtfilt to apply the filter: 
 
    &gt;&gt;&gt; y = signal.filtfilt(b, a, xn) 
 
    Plot the original signal and the various filtered versions: 
 
    &gt;&gt;&gt; plt.figure 
    &gt;&gt;&gt; plt.plot(t, xn, 'b', alpha=0.75) 
    &gt;&gt;&gt; plt.plot(t, z, 'r--', t, z2, 'r', t, y, 'k') 
    &gt;&gt;&gt; plt.legend(('noisy signal', 'lfilter, once', 'lfilter, twice', 
    ...             'filtfilt'), loc='best') 
    &gt;&gt;&gt; plt.grid(True) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) == </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s0"># This path only supports types fdgFDGO to mirror _linear_filter below.</span>
        <span class="s0"># Any of b, a, x, or zi can set the dtype, but there is no default</span>
        <span class="s0"># casting of other types; instead a NotImplementedError is raised.</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">b</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'object of too small depth for desired array'</span><span class="s3">)</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">_validate_x</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">inputs </span><span class="s3">= [</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">x</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">zi </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s0"># _linear_filter does not broadcast zi, but does do expansion of</span>
            <span class="s0"># singleton dims.</span>
            <span class="s1">zi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">zi</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">zi</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'object of too small depth for desired array'</span><span class="s3">)</span>
            <span class="s1">expected_shape </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
            <span class="s1">expected_shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">b</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] - </span><span class="s5">1</span>
            <span class="s1">expected_shape </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">expected_shape</span><span class="s3">)</span>
            <span class="s0"># check the trivial case where zi is the right shape first</span>
            <span class="s2">if </span><span class="s1">zi</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= </span><span class="s1">expected_shape</span><span class="s3">:</span>
                <span class="s1">strides </span><span class="s3">= </span><span class="s1">zi</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">* [</span><span class="s2">None</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">axis </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
                    <span class="s1">axis </span><span class="s3">+= </span><span class="s1">zi</span><span class="s3">.</span><span class="s1">ndim</span>
                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">zi</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">):</span>
                    <span class="s2">if </span><span class="s1">k </span><span class="s3">== </span><span class="s1">axis </span><span class="s2">and </span><span class="s1">zi</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] == </span><span class="s1">expected_shape</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]:</span>
                        <span class="s1">strides</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">zi</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
                    <span class="s2">elif </span><span class="s1">k </span><span class="s3">!= </span><span class="s1">axis </span><span class="s2">and </span><span class="s1">zi</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] == </span><span class="s1">expected_shape</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]:</span>
                        <span class="s1">strides</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">zi</span><span class="s3">.</span><span class="s1">strides</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
                    <span class="s2">elif </span><span class="s1">k </span><span class="s3">!= </span><span class="s1">axis </span><span class="s2">and </span><span class="s1">zi</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] == </span><span class="s5">1</span><span class="s3">:</span>
                        <span class="s1">strides</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s5">0</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Unexpected shape for zi: expected '</span>
                                         <span class="s4">f'</span><span class="s2">{</span><span class="s1">expected_shape</span><span class="s2">}</span><span class="s4">, found </span><span class="s2">{</span><span class="s1">zi</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">.'</span><span class="s3">)</span>
                <span class="s1">zi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">lib</span><span class="s3">.</span><span class="s1">stride_tricks</span><span class="s3">.</span><span class="s1">as_strided</span><span class="s3">(</span><span class="s1">zi</span><span class="s3">, </span><span class="s1">expected_shape</span><span class="s3">,</span>
                                                     <span class="s1">strides</span><span class="s3">)</span>
            <span class="s1">inputs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">zi</span><span class="s3">)</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">result_type</span><span class="s3">(*</span><span class="s1">inputs</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char </span><span class="s2">not in </span><span class="s4">'fdgFDGO'</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">&quot;input type '%s' not supported&quot; </span><span class="s3">% </span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">b </span><span class="s3">/= </span><span class="s1">a</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s1">out_full </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">apply_along_axis</span><span class="s3">(</span><span class="s2">lambda </span><span class="s1">y</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">convolve</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">y</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">ind </span><span class="s3">= </span><span class="s1">out_full</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">* [</span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)]</span>
        <span class="s2">if </span><span class="s1">zi </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">ind</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">slice</span><span class="s3">(</span><span class="s1">zi</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">])</span>
            <span class="s1">out_full</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">ind</span><span class="s3">)] += </span><span class="s1">zi</span>

        <span class="s1">ind</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">slice</span><span class="s3">(</span><span class="s1">out_full</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] - </span><span class="s1">len</span><span class="s3">(</span><span class="s1">b</span><span class="s3">) + </span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">out_full</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">ind</span><span class="s3">)]</span>

        <span class="s2">if </span><span class="s1">zi </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">out</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">ind</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">slice</span><span class="s3">(</span><span class="s1">out_full</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] - </span><span class="s1">len</span><span class="s3">(</span><span class="s1">b</span><span class="s3">) + </span><span class="s5">1</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s1">zf </span><span class="s3">= </span><span class="s1">out_full</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">ind</span><span class="s3">)]</span>
            <span class="s2">return </span><span class="s1">out</span><span class="s3">, </span><span class="s1">zf</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">zi </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_sigtools</span><span class="s3">.</span><span class="s1">_linear_filter</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_sigtools</span><span class="s3">.</span><span class="s1">_linear_filter</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">zi</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">lfiltic</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Construct initial conditions for lfilter given input and output vectors. 
 
    Given a linear filter (b, a) and initial conditions on the output `y` 
    and the input `x`, return the initial conditions on the state vector zi 
    which is used by `lfilter` to generate the output given the input. 
 
    Parameters 
    ---------- 
    b : array_like 
        Linear filter term. 
    a : array_like 
        Linear filter term. 
    y : array_like 
        Initial conditions. 
 
        If ``N = len(a) - 1``, then ``y = {y[-1], y[-2], ..., y[-N]}``. 
 
        If `y` is too short, it is padded with zeros. 
    x : array_like, optional 
        Initial conditions. 
 
        If ``M = len(b) - 1``, then ``x = {x[-1], x[-2], ..., x[-M]}``. 
 
        If `x` is not given, its initial conditions are assumed zero. 
 
        If `x` is too short, it is padded with zeros. 
 
    Returns 
    ------- 
    zi : ndarray 
        The state vector ``zi = {z_0[-1], z_1[-1], ..., z_K-1[-1]}``, 
        where ``K = max(M, N)``. 
 
    See Also 
    -------- 
    lfilter, lfilter_zi 
 
    &quot;&quot;&quot;</span>
    <span class="s1">N </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">size</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) - </span><span class="s5">1</span>
    <span class="s1">M </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">size</span><span class="s3">(</span><span class="s1">b</span><span class="s3">) - </span><span class="s5">1</span>
    <span class="s1">K </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">N</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">x </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">result_type </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">result_type</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">result_type</span><span class="s3">.</span><span class="s1">kind </span><span class="s2">in </span><span class="s4">'bui'</span><span class="s3">:</span>
            <span class="s1">result_type </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">result_type</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

        <span class="s1">result_type </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">result_type</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">result_type</span><span class="s3">.</span><span class="s1">kind </span><span class="s2">in </span><span class="s4">'bui'</span><span class="s3">:</span>
            <span class="s1">result_type </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">result_type</span><span class="s3">)</span>

        <span class="s1">L </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">size</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">L </span><span class="s3">&lt; </span><span class="s1">M</span><span class="s3">:</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">r_</span><span class="s3">[</span><span class="s1">x</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">M </span><span class="s3">- </span><span class="s1">L</span><span class="s3">)]</span>

    <span class="s1">y </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">result_type</span><span class="s3">)</span>
    <span class="s1">zi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">K</span><span class="s3">, </span><span class="s1">result_type</span><span class="s3">)</span>

    <span class="s1">L </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">size</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">L </span><span class="s3">&lt; </span><span class="s1">N</span><span class="s3">:</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">r_</span><span class="s3">[</span><span class="s1">y</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">N </span><span class="s3">- </span><span class="s1">L</span><span class="s3">)]</span>

    <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">M</span><span class="s3">):</span>
        <span class="s1">zi</span><span class="s3">[</span><span class="s1">m</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">b</span><span class="s3">[</span><span class="s1">m </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">:] * </span><span class="s1">x</span><span class="s3">[:</span><span class="s1">M </span><span class="s3">- </span><span class="s1">m</span><span class="s3">], </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">N</span><span class="s3">):</span>
        <span class="s1">zi</span><span class="s3">[</span><span class="s1">m</span><span class="s3">] -= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">a</span><span class="s3">[</span><span class="s1">m </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">:] * </span><span class="s1">y</span><span class="s3">[:</span><span class="s1">N </span><span class="s3">- </span><span class="s1">m</span><span class="s3">], </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">zi</span>


<span class="s2">def </span><span class="s1">deconvolve</span><span class="s3">(</span><span class="s1">signal</span><span class="s3">, </span><span class="s1">divisor</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Deconvolves ``divisor`` out of ``signal`` using inverse filtering. 
 
    Returns the quotient and remainder such that 
    ``signal = convolve(divisor, quotient) + remainder`` 
 
    Parameters 
    ---------- 
    signal : (N,) array_like 
        Signal data, typically a recorded signal 
    divisor : (N,) array_like 
        Divisor data, typically an impulse response or filter that was 
        applied to the original signal 
 
    Returns 
    ------- 
    quotient : ndarray 
        Quotient, typically the recovered original signal 
    remainder : ndarray 
        Remainder 
 
    See Also 
    -------- 
    numpy.polydiv : performs polynomial division (same operation, but 
                    also accepts poly1d objects) 
 
    Examples 
    -------- 
    Deconvolve a signal that's been filtered: 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; original = [0, 1, 0, 0, 1, 1, 0, 0] 
    &gt;&gt;&gt; impulse_response = [2, 1] 
    &gt;&gt;&gt; recorded = signal.convolve(impulse_response, original) 
    &gt;&gt;&gt; recorded 
    array([0, 2, 1, 0, 2, 3, 1, 0, 0]) 
    &gt;&gt;&gt; recovered, remainder = signal.deconvolve(recorded, impulse_response) 
    &gt;&gt;&gt; recovered 
    array([ 0.,  1.,  0.,  0.,  1.,  1.,  0.,  0.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">num </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">signal</span><span class="s3">)</span>
    <span class="s1">den </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">divisor</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">num</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;signal must be 1-D.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">den</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;divisor must be 1-D.&quot;</span><span class="s3">)</span>
    <span class="s1">N </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">num</span><span class="s3">)</span>
    <span class="s1">D </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">den</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">D </span><span class="s3">&gt; </span><span class="s1">N</span><span class="s3">:</span>
        <span class="s1">quot </span><span class="s3">= []</span>
        <span class="s1">rem </span><span class="s3">= </span><span class="s1">num</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">N </span><span class="s3">- </span><span class="s1">D </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">float</span><span class="s3">)</span>
        <span class="s1">input</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s5">1</span>
        <span class="s1">quot </span><span class="s3">= </span><span class="s1">lfilter</span><span class="s3">(</span><span class="s1">num</span><span class="s3">, </span><span class="s1">den</span><span class="s3">, </span><span class="s1">input</span><span class="s3">)</span>
        <span class="s1">rem </span><span class="s3">= </span><span class="s1">num </span><span class="s3">- </span><span class="s1">convolve</span><span class="s3">(</span><span class="s1">den</span><span class="s3">, </span><span class="s1">quot</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">=</span><span class="s4">'full'</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">quot</span><span class="s3">, </span><span class="s1">rem</span>


<span class="s2">def </span><span class="s1">hilbert</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">N</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Compute the analytic signal, using the Hilbert transform. 
 
    The transformation is done along the last axis by default. 
 
    Parameters 
    ---------- 
    x : array_like 
        Signal data.  Must be real. 
    N : int, optional 
        Number of Fourier components.  Default: ``x.shape[axis]`` 
    axis : int, optional 
        Axis along which to do the transformation.  Default: -1. 
 
    Returns 
    ------- 
    xa : ndarray 
        Analytic signal of `x`, of each 1-D array along `axis` 
 
    Notes 
    ----- 
    The analytic signal ``x_a(t)`` of signal ``x(t)`` is: 
 
    .. math:: x_a = F^{-1}(F(x) 2U) = x + i y 
 
    where `F` is the Fourier transform, `U` the unit step function, 
    and `y` the Hilbert transform of `x`. [1]_ 
 
    In other words, the negative half of the frequency spectrum is zeroed 
    out, turning the real-valued signal into a complex signal.  The Hilbert 
    transformed signal can be obtained from ``np.imag(hilbert(x))``, and the 
    original signal from ``np.real(hilbert(x))``. 
 
    References 
    ---------- 
    .. [1] Wikipedia, &quot;Analytic signal&quot;. 
           https://en.wikipedia.org/wiki/Analytic_signal 
    .. [2] Leon Cohen, &quot;Time-Frequency Analysis&quot;, 1995. Chapter 2. 
    .. [3] Alan V. Oppenheim, Ronald W. Schafer. Discrete-Time Signal 
           Processing, Third Edition, 2009. Chapter 12. 
           ISBN 13: 978-1292-02572-8 
 
    Examples 
    -------- 
    In this example we use the Hilbert transform to determine the amplitude 
    envelope and instantaneous frequency of an amplitude-modulated signal. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.signal import hilbert, chirp 
 
    &gt;&gt;&gt; duration = 1.0 
    &gt;&gt;&gt; fs = 400.0 
    &gt;&gt;&gt; samples = int(fs*duration) 
    &gt;&gt;&gt; t = np.arange(samples) / fs 
 
    We create a chirp of which the frequency increases from 20 Hz to 100 Hz and 
    apply an amplitude modulation. 
 
    &gt;&gt;&gt; signal = chirp(t, 20.0, t[-1], 100.0) 
    &gt;&gt;&gt; signal *= (1.0 + 0.5 * np.sin(2.0*np.pi*3.0*t) ) 
 
    The amplitude envelope is given by magnitude of the analytic signal. The 
    instantaneous frequency can be obtained by differentiating the 
    instantaneous phase in respect to time. The instantaneous phase corresponds 
    to the phase angle of the analytic signal. 
 
    &gt;&gt;&gt; analytic_signal = hilbert(signal) 
    &gt;&gt;&gt; amplitude_envelope = np.abs(analytic_signal) 
    &gt;&gt;&gt; instantaneous_phase = np.unwrap(np.angle(analytic_signal)) 
    &gt;&gt;&gt; instantaneous_frequency = (np.diff(instantaneous_phase) / 
    ...                            (2.0*np.pi) * fs) 
 
    &gt;&gt;&gt; fig, (ax0, ax1) = plt.subplots(nrows=2) 
    &gt;&gt;&gt; ax0.plot(t, signal, label='signal') 
    &gt;&gt;&gt; ax0.plot(t, amplitude_envelope, label='envelope') 
    &gt;&gt;&gt; ax0.set_xlabel(&quot;time in seconds&quot;) 
    &gt;&gt;&gt; ax0.legend() 
    &gt;&gt;&gt; ax1.plot(t[1:], instantaneous_frequency) 
    &gt;&gt;&gt; ax1.set_xlabel(&quot;time in seconds&quot;) 
    &gt;&gt;&gt; ax1.set_ylim(0.0, 120.0) 
    &gt;&gt;&gt; fig.tight_layout() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;x must be real.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">N </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">N </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">N </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;N must be positive.&quot;</span><span class="s3">)</span>

    <span class="s1">Xf </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">fft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s1">h </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">Xf</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">N </span><span class="s3">% </span><span class="s5">2 </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">h</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">h</span><span class="s3">[</span><span class="s1">N </span><span class="s3">// </span><span class="s5">2</span><span class="s3">] = </span><span class="s5">1</span>
        <span class="s1">h</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:</span><span class="s1">N </span><span class="s3">// </span><span class="s5">2</span><span class="s3">] = </span><span class="s5">2</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">h</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s5">1</span>
        <span class="s1">h</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:(</span><span class="s1">N </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">) // </span><span class="s5">2</span><span class="s3">] = </span><span class="s5">2</span>

    <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">ind </span><span class="s3">= [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">newaxis</span><span class="s3">] * </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim</span>
        <span class="s1">ind</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">h </span><span class="s3">= </span><span class="s1">h</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">ind</span><span class="s3">)]</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">ifft</span><span class="s3">(</span><span class="s1">Xf </span><span class="s3">* </span><span class="s1">h</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">x</span>


<span class="s2">def </span><span class="s1">hilbert2</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">N</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Compute the '2-D' analytic signal of `x` 
 
    Parameters 
    ---------- 
    x : array_like 
        2-D signal data. 
    N : int or tuple of two ints, optional 
        Number of Fourier components. Default is ``x.shape`` 
 
    Returns 
    ------- 
    xa : ndarray 
        Analytic signal of `x` taken along axes (0,1). 
 
    References 
    ---------- 
    .. [1] Wikipedia, &quot;Analytic signal&quot;, 
        https://en.wikipedia.org/wiki/Analytic_signal 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_2d</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;x must be 2-D.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;x must be real.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">N </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">N </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">N </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;N must be positive.&quot;</span><span class="s3">)</span>
        <span class="s1">N </span><span class="s3">= (</span><span class="s1">N</span><span class="s3">, </span><span class="s1">N</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">N</span><span class="s3">) != </span><span class="s5">2 </span><span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">N</span><span class="s3">) &lt;= </span><span class="s5">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;When given as a tuple, N must hold exactly &quot;</span>
                         <span class="s4">&quot;two positive integers&quot;</span><span class="s3">)</span>

    <span class="s1">Xf </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">fft2</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">))</span>
    <span class="s1">h1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">N</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">Xf</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">h2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">N</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">Xf</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">h </span><span class="s2">in </span><span class="s3">(</span><span class="s1">h1</span><span class="s3">, </span><span class="s1">h2</span><span class="s3">):</span>
        <span class="s1">N1 </span><span class="s3">= </span><span class="s1">h</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">N1 </span><span class="s3">% </span><span class="s5">2 </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">h</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s1">h</span><span class="s3">[</span><span class="s1">N1 </span><span class="s3">// </span><span class="s5">2</span><span class="s3">] = </span><span class="s5">1</span>
            <span class="s1">h</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:</span><span class="s1">N1 </span><span class="s3">// </span><span class="s5">2</span><span class="s3">] = </span><span class="s5">2</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">h</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s5">1</span>
            <span class="s1">h</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:(</span><span class="s1">N1 </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">) // </span><span class="s5">2</span><span class="s3">] = </span><span class="s5">2</span>

    <span class="s1">h </span><span class="s3">= </span><span class="s1">h1</span><span class="s3">[:, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">newaxis</span><span class="s3">] * </span><span class="s1">h2</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">newaxis</span><span class="s3">, :]</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s2">while </span><span class="s1">k </span><span class="s3">&gt; </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s1">h </span><span class="s3">= </span><span class="s1">h</span><span class="s3">[:, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">newaxis</span><span class="s3">]</span>
        <span class="s1">k </span><span class="s3">-= </span><span class="s5">1</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">ifft2</span><span class="s3">(</span><span class="s1">Xf </span><span class="s3">* </span><span class="s1">h</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">x</span>


<span class="s1">_msg_cplx_sort</span><span class="s3">=</span><span class="s4">&quot;&quot;&quot;cmplx_sort was deprecated in SciPy 1.12 and will be removed 
in SciPy 1.15. The exact equivalent for a numpy array argument is 
&gt;&gt;&gt; def cmplx_sort(p): 
...    idx = np.argsort(abs(p)) 
...    return np.take(p, idx, 0), idx 
&quot;&quot;&quot;</span>

<span class="s2">def </span><span class="s1">cmplx_sort</span><span class="s3">(</span><span class="s1">p</span><span class="s3">):</span>
    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">_msg_cplx_sort</span><span class="s3">, </span><span class="s1">DeprecationWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_cmplx_sort</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_cmplx_sort</span><span class="s3">(</span><span class="s1">p</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Sort roots based on magnitude. 
 
    Parameters 
    ---------- 
    p : array_like 
        The roots to sort, as a 1-D array. 
 
    Returns 
    ------- 
    p_sorted : ndarray 
        Sorted roots. 
    indx : ndarray 
        Array of indices needed to sort the input `p`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; vals = [1, 4, 1+1.j, 3] 
    &gt;&gt;&gt; p_sorted, indx = signal.cmplx_sort(vals) 
    &gt;&gt;&gt; p_sorted 
    array([1.+0.j, 1.+1.j, 3.+0.j, 4.+0.j]) 
    &gt;&gt;&gt; indx 
    array([0, 2, 3, 1]) 
    &quot;&quot;&quot;</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
    <span class="s1">indx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">p</span><span class="s3">))</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">indx</span><span class="s3">, </span><span class="s5">0</span><span class="s3">), </span><span class="s1">indx</span>


<span class="s2">def </span><span class="s1">unique_roots</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s5">1e-3</span><span class="s3">, </span><span class="s1">rtype</span><span class="s3">=</span><span class="s4">'min'</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Determine unique roots and their multiplicities from a list of roots. 
 
    Parameters 
    ---------- 
    p : array_like 
        The list of roots. 
    tol : float, optional 
        The tolerance for two roots to be considered equal in terms of 
        the distance between them. Default is 1e-3. Refer to Notes about 
        the details on roots grouping. 
    rtype : {'max', 'maximum', 'min', 'minimum', 'avg', 'mean'}, optional 
        How to determine the returned root if multiple roots are within 
        `tol` of each other. 
 
          - 'max', 'maximum': pick the maximum of those roots 
          - 'min', 'minimum': pick the minimum of those roots 
          - 'avg', 'mean': take the average of those roots 
 
        When finding minimum or maximum among complex roots they are compared 
        first by the real part and then by the imaginary part. 
 
    Returns 
    ------- 
    unique : ndarray 
        The list of unique roots. 
    multiplicity : ndarray 
        The multiplicity of each root. 
 
    Notes 
    ----- 
    If we have 3 roots ``a``, ``b`` and ``c``, such that ``a`` is close to 
    ``b`` and ``b`` is close to ``c`` (distance is less than `tol`), then it 
    doesn't necessarily mean that ``a`` is close to ``c``. It means that roots 
    grouping is not unique. In this function we use &quot;greedy&quot; grouping going 
    through the roots in the order they are given in the input `p`. 
 
    This utility function is not specific to roots but can be used for any 
    sequence of values for which uniqueness and multiplicity has to be 
    determined. For a more general routine, see `numpy.unique`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; vals = [0, 1.3, 1.31, 2.8, 1.25, 2.2, 10.3] 
    &gt;&gt;&gt; uniq, mult = signal.unique_roots(vals, tol=2e-2, rtype='avg') 
 
    Check which roots have multiplicity larger than 1: 
 
    &gt;&gt;&gt; uniq[mult &gt; 1] 
    array([ 1.305]) 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">rtype </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'max'</span><span class="s3">, </span><span class="s4">'maximum'</span><span class="s3">]:</span>
        <span class="s1">reduce </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span>
    <span class="s2">elif </span><span class="s1">rtype </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'min'</span><span class="s3">, </span><span class="s4">'minimum'</span><span class="s3">]:</span>
        <span class="s1">reduce </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span>
    <span class="s2">elif </span><span class="s1">rtype </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'avg'</span><span class="s3">, </span><span class="s4">'mean'</span><span class="s3">]:</span>
        <span class="s1">reduce </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;`rtype` must be one of &quot;</span>
                         <span class="s4">&quot;{'max', 'maximum', 'min', 'minimum', 'avg', 'mean'}&quot;</span><span class="s3">)</span>

    <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>

    <span class="s1">points </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">), </span><span class="s5">2</span><span class="s3">))</span>
    <span class="s1">points</span><span class="s3">[:, </span><span class="s5">0</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">real</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
    <span class="s1">points</span><span class="s3">[:, </span><span class="s5">1</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
    <span class="s1">tree </span><span class="s3">= </span><span class="s1">cKDTree</span><span class="s3">(</span><span class="s1">points</span><span class="s3">)</span>

    <span class="s1">p_unique </span><span class="s3">= []</span>
    <span class="s1">p_multiplicity </span><span class="s3">= []</span>
    <span class="s1">used </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)):</span>
        <span class="s2">if </span><span class="s1">used</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]:</span>
            <span class="s2">continue</span>

        <span class="s1">group </span><span class="s3">= </span><span class="s1">tree</span><span class="s3">.</span><span class="s1">query_ball_point</span><span class="s3">(</span><span class="s1">points</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">tol</span><span class="s3">)</span>
        <span class="s1">group </span><span class="s3">= [</span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">group </span><span class="s2">if not </span><span class="s1">used</span><span class="s3">[</span><span class="s1">x</span><span class="s3">]]</span>

        <span class="s1">p_unique</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">p</span><span class="s3">[</span><span class="s1">group</span><span class="s3">]))</span>
        <span class="s1">p_multiplicity</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">group</span><span class="s3">))</span>

        <span class="s1">used</span><span class="s3">[</span><span class="s1">group</span><span class="s3">] = </span><span class="s2">True</span>

    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">p_unique</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">p_multiplicity</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">invres</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s5">1e-3</span><span class="s3">, </span><span class="s1">rtype</span><span class="s3">=</span><span class="s4">'avg'</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute b(s) and a(s) from partial fraction expansion. 
 
    If `M` is the degree of numerator `b` and `N` the degree of denominator 
    `a`:: 
 
              b(s)     b[0] s**(M) + b[1] s**(M-1) + ... + b[M] 
      H(s) = ------ = ------------------------------------------ 
              a(s)     a[0] s**(N) + a[1] s**(N-1) + ... + a[N] 
 
    then the partial-fraction expansion H(s) is defined as:: 
 
               r[0]       r[1]             r[-1] 
           = -------- + -------- + ... + --------- + k(s) 
             (s-p[0])   (s-p[1])         (s-p[-1]) 
 
    If there are any repeated roots (closer together than `tol`), then H(s) 
    has terms like:: 
 
          r[i]      r[i+1]              r[i+n-1] 
        -------- + ----------- + ... + ----------- 
        (s-p[i])  (s-p[i])**2          (s-p[i])**n 
 
    This function is used for polynomials in positive powers of s or z, 
    such as analog filters or digital filters in controls engineering.  For 
    negative powers of z (typical for digital filters in DSP), use `invresz`. 
 
    Parameters 
    ---------- 
    r : array_like 
        Residues corresponding to the poles. For repeated poles, the residues 
        must be ordered to correspond to ascending by power fractions. 
    p : array_like 
        Poles. Equal poles must be adjacent. 
    k : array_like 
        Coefficients of the direct polynomial term. 
    tol : float, optional 
        The tolerance for two roots to be considered equal in terms of 
        the distance between them. Default is 1e-3. See `unique_roots` 
        for further details. 
    rtype : {'avg', 'min', 'max'}, optional 
        Method for computing a root to represent a group of identical roots. 
        Default is 'avg'. See `unique_roots` for further details. 
 
    Returns 
    ------- 
    b : ndarray 
        Numerator polynomial coefficients. 
    a : ndarray 
        Denominator polynomial coefficients. 
 
    See Also 
    -------- 
    residue, invresz, unique_roots 
 
    &quot;&quot;&quot;</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">trim_zeros</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">k</span><span class="s3">), </span><span class="s4">'f'</span><span class="s3">)</span>

    <span class="s1">unique_poles</span><span class="s3">, </span><span class="s1">multiplicity </span><span class="s3">= </span><span class="s1">_group_poles</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">, </span><span class="s1">rtype</span><span class="s3">)</span>
    <span class="s1">factors</span><span class="s3">, </span><span class="s1">denominator </span><span class="s3">= </span><span class="s1">_compute_factors</span><span class="s3">(</span><span class="s1">unique_poles</span><span class="s3">, </span><span class="s1">multiplicity</span><span class="s3">,</span>
                                            <span class="s1">include_powers</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">k</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">numerator </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">numerator </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">polymul</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">denominator</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">residue</span><span class="s3">, </span><span class="s1">factor </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">factors</span><span class="s3">):</span>
        <span class="s1">numerator </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">polyadd</span><span class="s3">(</span><span class="s1">numerator</span><span class="s3">, </span><span class="s1">residue </span><span class="s3">* </span><span class="s1">factor</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">numerator</span><span class="s3">, </span><span class="s1">denominator</span>


<span class="s2">def </span><span class="s1">_compute_factors</span><span class="s3">(</span><span class="s1">roots</span><span class="s3">, </span><span class="s1">multiplicity</span><span class="s3">, </span><span class="s1">include_powers</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute the total polynomial divided by factors for each root.&quot;&quot;&quot;</span>
    <span class="s1">current </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">1</span><span class="s3">])</span>
    <span class="s1">suffixes </span><span class="s3">= [</span><span class="s1">current</span><span class="s3">]</span>
    <span class="s2">for </span><span class="s1">pole</span><span class="s3">, </span><span class="s1">mult </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">roots</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">:</span><span class="s5">0</span><span class="s3">:-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">multiplicity</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">:</span><span class="s5">0</span><span class="s3">:-</span><span class="s5">1</span><span class="s3">]):</span>
        <span class="s1">monomial </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">1</span><span class="s3">, -</span><span class="s1">pole</span><span class="s3">])</span>
        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">mult</span><span class="s3">):</span>
            <span class="s1">current </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">polymul</span><span class="s3">(</span><span class="s1">current</span><span class="s3">, </span><span class="s1">monomial</span><span class="s3">)</span>
        <span class="s1">suffixes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">current</span><span class="s3">)</span>
    <span class="s1">suffixes </span><span class="s3">= </span><span class="s1">suffixes</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]</span>

    <span class="s1">factors </span><span class="s3">= []</span>
    <span class="s1">current </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">1</span><span class="s3">])</span>
    <span class="s2">for </span><span class="s1">pole</span><span class="s3">, </span><span class="s1">mult</span><span class="s3">, </span><span class="s1">suffix </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">roots</span><span class="s3">, </span><span class="s1">multiplicity</span><span class="s3">, </span><span class="s1">suffixes</span><span class="s3">):</span>
        <span class="s1">monomial </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">1</span><span class="s3">, -</span><span class="s1">pole</span><span class="s3">])</span>
        <span class="s1">block </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">mult</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">i </span><span class="s3">== </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">include_powers</span><span class="s3">:</span>
                <span class="s1">block</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">polymul</span><span class="s3">(</span><span class="s1">current</span><span class="s3">, </span><span class="s1">suffix</span><span class="s3">))</span>
            <span class="s1">current </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">polymul</span><span class="s3">(</span><span class="s1">current</span><span class="s3">, </span><span class="s1">monomial</span><span class="s3">)</span>
        <span class="s1">factors</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">block</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">factors</span><span class="s3">, </span><span class="s1">current</span>


<span class="s2">def </span><span class="s1">_compute_residues</span><span class="s3">(</span><span class="s1">poles</span><span class="s3">, </span><span class="s1">multiplicity</span><span class="s3">, </span><span class="s1">numerator</span><span class="s3">):</span>
    <span class="s1">denominator_factors</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">_compute_factors</span><span class="s3">(</span><span class="s1">poles</span><span class="s3">, </span><span class="s1">multiplicity</span><span class="s3">)</span>
    <span class="s1">numerator </span><span class="s3">= </span><span class="s1">numerator</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">poles</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s1">residues </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">pole</span><span class="s3">, </span><span class="s1">mult</span><span class="s3">, </span><span class="s1">factor </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">poles</span><span class="s3">, </span><span class="s1">multiplicity</span><span class="s3">,</span>
                                  <span class="s1">denominator_factors</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">mult </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s1">residues</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">polyval</span><span class="s3">(</span><span class="s1">numerator</span><span class="s3">, </span><span class="s1">pole</span><span class="s3">) /</span>
                            <span class="s1">np</span><span class="s3">.</span><span class="s1">polyval</span><span class="s3">(</span><span class="s1">factor</span><span class="s3">, </span><span class="s1">pole</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">numer </span><span class="s3">= </span><span class="s1">numerator</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">monomial </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">1</span><span class="s3">, -</span><span class="s1">pole</span><span class="s3">])</span>
            <span class="s1">factor</span><span class="s3">, </span><span class="s1">d </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">polydiv</span><span class="s3">(</span><span class="s1">factor</span><span class="s3">, </span><span class="s1">monomial</span><span class="s3">)</span>

            <span class="s1">block </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">mult</span><span class="s3">):</span>
                <span class="s1">numer</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">polydiv</span><span class="s3">(</span><span class="s1">numer</span><span class="s3">, </span><span class="s1">monomial</span><span class="s3">)</span>
                <span class="s1">r </span><span class="s3">= </span><span class="s1">n</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] / </span><span class="s1">d</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
                <span class="s1">numer </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">polysub</span><span class="s3">(</span><span class="s1">numer</span><span class="s3">, </span><span class="s1">r </span><span class="s3">* </span><span class="s1">factor</span><span class="s3">)</span>
                <span class="s1">block</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

            <span class="s1">residues</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">reversed</span><span class="s3">(</span><span class="s1">block</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">residues</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">residue</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s5">1e-3</span><span class="s3">, </span><span class="s1">rtype</span><span class="s3">=</span><span class="s4">'avg'</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute partial-fraction expansion of b(s) / a(s). 
 
    If `M` is the degree of numerator `b` and `N` the degree of denominator 
    `a`:: 
 
              b(s)     b[0] s**(M) + b[1] s**(M-1) + ... + b[M] 
      H(s) = ------ = ------------------------------------------ 
              a(s)     a[0] s**(N) + a[1] s**(N-1) + ... + a[N] 
 
    then the partial-fraction expansion H(s) is defined as:: 
 
               r[0]       r[1]             r[-1] 
           = -------- + -------- + ... + --------- + k(s) 
             (s-p[0])   (s-p[1])         (s-p[-1]) 
 
    If there are any repeated roots (closer together than `tol`), then H(s) 
    has terms like:: 
 
          r[i]      r[i+1]              r[i+n-1] 
        -------- + ----------- + ... + ----------- 
        (s-p[i])  (s-p[i])**2          (s-p[i])**n 
 
    This function is used for polynomials in positive powers of s or z, 
    such as analog filters or digital filters in controls engineering.  For 
    negative powers of z (typical for digital filters in DSP), use `residuez`. 
 
    See Notes for details about the algorithm. 
 
    Parameters 
    ---------- 
    b : array_like 
        Numerator polynomial coefficients. 
    a : array_like 
        Denominator polynomial coefficients. 
    tol : float, optional 
        The tolerance for two roots to be considered equal in terms of 
        the distance between them. Default is 1e-3. See `unique_roots` 
        for further details. 
    rtype : {'avg', 'min', 'max'}, optional 
        Method for computing a root to represent a group of identical roots. 
        Default is 'avg'. See `unique_roots` for further details. 
 
    Returns 
    ------- 
    r : ndarray 
        Residues corresponding to the poles. For repeated poles, the residues 
        are ordered to correspond to ascending by power fractions. 
    p : ndarray 
        Poles ordered by magnitude in ascending order. 
    k : ndarray 
        Coefficients of the direct polynomial term. 
 
    See Also 
    -------- 
    invres, residuez, numpy.poly, unique_roots 
 
    Notes 
    ----- 
    The &quot;deflation through subtraction&quot; algorithm is used for 
    computations --- method 6 in [1]_. 
 
    The form of partial fraction expansion depends on poles multiplicity in 
    the exact mathematical sense. However there is no way to exactly 
    determine multiplicity of roots of a polynomial in numerical computing. 
    Thus you should think of the result of `residue` with given `tol` as 
    partial fraction expansion computed for the denominator composed of the 
    computed poles with empirically determined multiplicity. The choice of 
    `tol` can drastically change the result if there are close poles. 
 
    References 
    ---------- 
    .. [1] J. F. Mahoney, B. D. Sivazlian, &quot;Partial fractions expansion: a 
           review of computational methodology and efficiency&quot;, Journal of 
           Computational and Applied Mathematics, Vol. 9, 1983. 
    &quot;&quot;&quot;</span>
    <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">)</span>
            <span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">)):</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">complex</span><span class="s3">)</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">complex</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">)</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">)</span>

    <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">trim_zeros</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">b</span><span class="s3">), </span><span class="s4">'f'</span><span class="s3">)</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">trim_zeros</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s4">'f'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Denominator `a` is zero.&quot;</span><span class="s3">)</span>

    <span class="s1">poles </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">roots</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">b</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">poles</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">), </span><span class="s1">_cmplx_sort</span><span class="s3">(</span><span class="s1">poles</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([])</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">b</span><span class="s3">) &lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">k</span><span class="s3">, </span><span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">polydiv</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>

    <span class="s1">unique_poles</span><span class="s3">, </span><span class="s1">multiplicity </span><span class="s3">= </span><span class="s1">unique_roots</span><span class="s3">(</span><span class="s1">poles</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s1">tol</span><span class="s3">, </span><span class="s1">rtype</span><span class="s3">=</span><span class="s1">rtype</span><span class="s3">)</span>
    <span class="s1">unique_poles</span><span class="s3">, </span><span class="s1">order </span><span class="s3">= </span><span class="s1">_cmplx_sort</span><span class="s3">(</span><span class="s1">unique_poles</span><span class="s3">)</span>
    <span class="s1">multiplicity </span><span class="s3">= </span><span class="s1">multiplicity</span><span class="s3">[</span><span class="s1">order</span><span class="s3">]</span>

    <span class="s1">residues </span><span class="s3">= </span><span class="s1">_compute_residues</span><span class="s3">(</span><span class="s1">unique_poles</span><span class="s3">, </span><span class="s1">multiplicity</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)</span>

    <span class="s1">index </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">for </span><span class="s1">pole</span><span class="s3">, </span><span class="s1">mult </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">unique_poles</span><span class="s3">, </span><span class="s1">multiplicity</span><span class="s3">):</span>
        <span class="s1">poles</span><span class="s3">[</span><span class="s1">index</span><span class="s3">:</span><span class="s1">index </span><span class="s3">+ </span><span class="s1">mult</span><span class="s3">] = </span><span class="s1">pole</span>
        <span class="s1">index </span><span class="s3">+= </span><span class="s1">mult</span>

    <span class="s2">return </span><span class="s1">residues </span><span class="s3">/ </span><span class="s1">a</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">poles</span><span class="s3">, </span><span class="s1">k</span>


<span class="s2">def </span><span class="s1">residuez</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s5">1e-3</span><span class="s3">, </span><span class="s1">rtype</span><span class="s3">=</span><span class="s4">'avg'</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute partial-fraction expansion of b(z) / a(z). 
 
    If `M` is the degree of numerator `b` and `N` the degree of denominator 
    `a`:: 
 
                b(z)     b[0] + b[1] z**(-1) + ... + b[M] z**(-M) 
        H(z) = ------ = ------------------------------------------ 
                a(z)     a[0] + a[1] z**(-1) + ... + a[N] z**(-N) 
 
    then the partial-fraction expansion H(z) is defined as:: 
 
                 r[0]                   r[-1] 
         = --------------- + ... + ---------------- + k[0] + k[1]z**(-1) ... 
           (1-p[0]z**(-1))         (1-p[-1]z**(-1)) 
 
    If there are any repeated roots (closer than `tol`), then the partial 
    fraction expansion has terms like:: 
 
             r[i]              r[i+1]                    r[i+n-1] 
        -------------- + ------------------ + ... + ------------------ 
        (1-p[i]z**(-1))  (1-p[i]z**(-1))**2         (1-p[i]z**(-1))**n 
 
    This function is used for polynomials in negative powers of z, 
    such as digital filters in DSP.  For positive powers, use `residue`. 
 
    See Notes of `residue` for details about the algorithm. 
 
    Parameters 
    ---------- 
    b : array_like 
        Numerator polynomial coefficients. 
    a : array_like 
        Denominator polynomial coefficients. 
    tol : float, optional 
        The tolerance for two roots to be considered equal in terms of 
        the distance between them. Default is 1e-3. See `unique_roots` 
        for further details. 
    rtype : {'avg', 'min', 'max'}, optional 
        Method for computing a root to represent a group of identical roots. 
        Default is 'avg'. See `unique_roots` for further details. 
 
    Returns 
    ------- 
    r : ndarray 
        Residues corresponding to the poles. For repeated poles, the residues 
        are ordered to correspond to ascending by power fractions. 
    p : ndarray 
        Poles ordered by magnitude in ascending order. 
    k : ndarray 
        Coefficients of the direct polynomial term. 
 
    See Also 
    -------- 
    invresz, residue, unique_roots 
    &quot;&quot;&quot;</span>
    <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">b</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">)</span>
            <span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">)):</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">complex</span><span class="s3">)</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">complex</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">)</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">float</span><span class="s3">)</span>

    <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">trim_zeros</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">b</span><span class="s3">), </span><span class="s4">'b'</span><span class="s3">)</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">trim_zeros</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s4">'b'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Denominator `a` is zero.&quot;</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">a</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;First coefficient of determinant `a` must be &quot;</span>
                         <span class="s4">&quot;non-zero.&quot;</span><span class="s3">)</span>

    <span class="s1">poles </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">roots</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">b</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">poles</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">), </span><span class="s1">_cmplx_sort</span><span class="s3">(</span><span class="s1">poles</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([])</span>

    <span class="s1">b_rev </span><span class="s3">= </span><span class="s1">b</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s1">a_rev </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">b_rev</span><span class="s3">) &lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a_rev</span><span class="s3">):</span>
        <span class="s1">k_rev </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">k_rev</span><span class="s3">, </span><span class="s1">b_rev </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">polydiv</span><span class="s3">(</span><span class="s1">b_rev</span><span class="s3">, </span><span class="s1">a_rev</span><span class="s3">)</span>

    <span class="s1">unique_poles</span><span class="s3">, </span><span class="s1">multiplicity </span><span class="s3">= </span><span class="s1">unique_roots</span><span class="s3">(</span><span class="s1">poles</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s1">tol</span><span class="s3">, </span><span class="s1">rtype</span><span class="s3">=</span><span class="s1">rtype</span><span class="s3">)</span>
    <span class="s1">unique_poles</span><span class="s3">, </span><span class="s1">order </span><span class="s3">= </span><span class="s1">_cmplx_sort</span><span class="s3">(</span><span class="s1">unique_poles</span><span class="s3">)</span>
    <span class="s1">multiplicity </span><span class="s3">= </span><span class="s1">multiplicity</span><span class="s3">[</span><span class="s1">order</span><span class="s3">]</span>

    <span class="s1">residues </span><span class="s3">= </span><span class="s1">_compute_residues</span><span class="s3">(</span><span class="s5">1 </span><span class="s3">/ </span><span class="s1">unique_poles</span><span class="s3">, </span><span class="s1">multiplicity</span><span class="s3">, </span><span class="s1">b_rev</span><span class="s3">)</span>

    <span class="s1">index </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s1">powers </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">residues</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">int</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">pole</span><span class="s3">, </span><span class="s1">mult </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">unique_poles</span><span class="s3">, </span><span class="s1">multiplicity</span><span class="s3">):</span>
        <span class="s1">poles</span><span class="s3">[</span><span class="s1">index</span><span class="s3">:</span><span class="s1">index </span><span class="s3">+ </span><span class="s1">mult</span><span class="s3">] = </span><span class="s1">pole</span>
        <span class="s1">powers</span><span class="s3">[</span><span class="s1">index</span><span class="s3">:</span><span class="s1">index </span><span class="s3">+ </span><span class="s1">mult</span><span class="s3">] = </span><span class="s5">1 </span><span class="s3">+ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">mult</span><span class="s3">)</span>
        <span class="s1">index </span><span class="s3">+= </span><span class="s1">mult</span>

    <span class="s1">residues </span><span class="s3">*= (-</span><span class="s1">poles</span><span class="s3">) ** </span><span class="s1">powers </span><span class="s3">/ </span><span class="s1">a_rev</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s2">return </span><span class="s1">residues</span><span class="s3">, </span><span class="s1">poles</span><span class="s3">, </span><span class="s1">k_rev</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">_group_poles</span><span class="s3">(</span><span class="s1">poles</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">, </span><span class="s1">rtype</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">rtype </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'max'</span><span class="s3">, </span><span class="s4">'maximum'</span><span class="s3">]:</span>
        <span class="s1">reduce </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span>
    <span class="s2">elif </span><span class="s1">rtype </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'min'</span><span class="s3">, </span><span class="s4">'minimum'</span><span class="s3">]:</span>
        <span class="s1">reduce </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span>
    <span class="s2">elif </span><span class="s1">rtype </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'avg'</span><span class="s3">, </span><span class="s4">'mean'</span><span class="s3">]:</span>
        <span class="s1">reduce </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;`rtype` must be one of &quot;</span>
                         <span class="s4">&quot;{'max', 'maximum', 'min', 'minimum', 'avg', 'mean'}&quot;</span><span class="s3">)</span>

    <span class="s1">unique </span><span class="s3">= []</span>
    <span class="s1">multiplicity </span><span class="s3">= []</span>

    <span class="s1">pole </span><span class="s3">= </span><span class="s1">poles</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">block </span><span class="s3">= [</span><span class="s1">pole</span><span class="s3">]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">poles</span><span class="s3">)):</span>
        <span class="s2">if </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">poles</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">pole</span><span class="s3">) &lt;= </span><span class="s1">tol</span><span class="s3">:</span>
            <span class="s1">block</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">pole</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">unique</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">block</span><span class="s3">))</span>
            <span class="s1">multiplicity</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">block</span><span class="s3">))</span>
            <span class="s1">pole </span><span class="s3">= </span><span class="s1">poles</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s1">block </span><span class="s3">= [</span><span class="s1">pole</span><span class="s3">]</span>

    <span class="s1">unique</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">reduce</span><span class="s3">(</span><span class="s1">block</span><span class="s3">))</span>
    <span class="s1">multiplicity</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">block</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">unique</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">multiplicity</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">invresz</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">=</span><span class="s5">1e-3</span><span class="s3">, </span><span class="s1">rtype</span><span class="s3">=</span><span class="s4">'avg'</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Compute b(z) and a(z) from partial fraction expansion. 
 
    If `M` is the degree of numerator `b` and `N` the degree of denominator 
    `a`:: 
 
                b(z)     b[0] + b[1] z**(-1) + ... + b[M] z**(-M) 
        H(z) = ------ = ------------------------------------------ 
                a(z)     a[0] + a[1] z**(-1) + ... + a[N] z**(-N) 
 
    then the partial-fraction expansion H(z) is defined as:: 
 
                 r[0]                   r[-1] 
         = --------------- + ... + ---------------- + k[0] + k[1]z**(-1) ... 
           (1-p[0]z**(-1))         (1-p[-1]z**(-1)) 
 
    If there are any repeated roots (closer than `tol`), then the partial 
    fraction expansion has terms like:: 
 
             r[i]              r[i+1]                    r[i+n-1] 
        -------------- + ------------------ + ... + ------------------ 
        (1-p[i]z**(-1))  (1-p[i]z**(-1))**2         (1-p[i]z**(-1))**n 
 
    This function is used for polynomials in negative powers of z, 
    such as digital filters in DSP.  For positive powers, use `invres`. 
 
    Parameters 
    ---------- 
    r : array_like 
        Residues corresponding to the poles. For repeated poles, the residues 
        must be ordered to correspond to ascending by power fractions. 
    p : array_like 
        Poles. Equal poles must be adjacent. 
    k : array_like 
        Coefficients of the direct polynomial term. 
    tol : float, optional 
        The tolerance for two roots to be considered equal in terms of 
        the distance between them. Default is 1e-3. See `unique_roots` 
        for further details. 
    rtype : {'avg', 'min', 'max'}, optional 
        Method for computing a root to represent a group of identical roots. 
        Default is 'avg'. See `unique_roots` for further details. 
 
    Returns 
    ------- 
    b : ndarray 
        Numerator polynomial coefficients. 
    a : ndarray 
        Denominator polynomial coefficients. 
 
    See Also 
    -------- 
    residuez, unique_roots, invres 
 
    &quot;&quot;&quot;</span>
    <span class="s1">r </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">trim_zeros</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">k</span><span class="s3">), </span><span class="s4">'b'</span><span class="s3">)</span>

    <span class="s1">unique_poles</span><span class="s3">, </span><span class="s1">multiplicity </span><span class="s3">= </span><span class="s1">_group_poles</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">, </span><span class="s1">rtype</span><span class="s3">)</span>
    <span class="s1">factors</span><span class="s3">, </span><span class="s1">denominator </span><span class="s3">= </span><span class="s1">_compute_factors</span><span class="s3">(</span><span class="s1">unique_poles</span><span class="s3">, </span><span class="s1">multiplicity</span><span class="s3">,</span>
                                            <span class="s1">include_powers</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">k</span><span class="s3">) == </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">numerator </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">numerator </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">polymul</span><span class="s3">(</span><span class="s1">k</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">denominator</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">])</span>

    <span class="s2">for </span><span class="s1">residue</span><span class="s3">, </span><span class="s1">factor </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">r</span><span class="s3">, </span><span class="s1">factors</span><span class="s3">):</span>
        <span class="s1">numerator </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">polyadd</span><span class="s3">(</span><span class="s1">numerator</span><span class="s3">, </span><span class="s1">residue </span><span class="s3">* </span><span class="s1">factor</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">])</span>

    <span class="s2">return </span><span class="s1">numerator</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">denominator</span>


<span class="s2">def </span><span class="s1">resample</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">num</span><span class="s3">, </span><span class="s1">t</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">window</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">domain</span><span class="s3">=</span><span class="s4">'time'</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Resample `x` to `num` samples using Fourier method along the given axis. 
 
    The resampled signal starts at the same value as `x` but is sampled 
    with a spacing of ``len(x) / num * (spacing of x)``.  Because a 
    Fourier method is used, the signal is assumed to be periodic. 
 
    Parameters 
    ---------- 
    x : array_like 
        The data to be resampled. 
    num : int 
        The number of samples in the resampled signal. 
    t : array_like, optional 
        If `t` is given, it is assumed to be the equally spaced sample 
        positions associated with the signal data in `x`. 
    axis : int, optional 
        The axis of `x` that is resampled.  Default is 0. 
    window : array_like, callable, string, float, or tuple, optional 
        Specifies the window applied to the signal in the Fourier 
        domain.  See below for details. 
    domain : string, optional 
        A string indicating the domain of the input `x`: 
        ``time`` Consider the input `x` as time-domain (Default), 
        ``freq`` Consider the input `x` as frequency-domain. 
 
    Returns 
    ------- 
    resampled_x or (resampled_x, resampled_t) 
        Either the resampled array, or, if `t` was given, a tuple 
        containing the resampled array and the corresponding resampled 
        positions. 
 
    See Also 
    -------- 
    decimate : Downsample the signal after applying an FIR or IIR filter. 
    resample_poly : Resample using polyphase filtering and an FIR filter. 
 
    Notes 
    ----- 
    The argument `window` controls a Fourier-domain window that tapers 
    the Fourier spectrum before zero-padding to alleviate ringing in 
    the resampled values for sampled signals you didn't intend to be 
    interpreted as band-limited. 
 
    If `window` is a function, then it is called with a vector of inputs 
    indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ). 
 
    If `window` is an array of the same length as `x.shape[axis]` it is 
    assumed to be the window to be applied directly in the Fourier 
    domain (with dc and low-frequency first). 
 
    For any other type of `window`, the function `scipy.signal.get_window` 
    is called to generate the window. 
 
    The first sample of the returned vector is the same as the first 
    sample of the input vector.  The spacing between samples is changed 
    from ``dx`` to ``dx * len(x) / num``. 
 
    If `t` is not None, then it is used solely to calculate the resampled 
    positions `resampled_t` 
 
    As noted, `resample` uses FFT transformations, which can be very 
    slow if the number of input or output samples is large and prime; 
    see `scipy.fft.fft`. 
 
    Examples 
    -------- 
    Note that the end of the resampled data rises to meet the first 
    sample of the next cycle: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
 
    &gt;&gt;&gt; x = np.linspace(0, 10, 20, endpoint=False) 
    &gt;&gt;&gt; y = np.cos(-x**2/6.0) 
    &gt;&gt;&gt; f = signal.resample(y, 100) 
    &gt;&gt;&gt; xnew = np.linspace(0, 10, 100, endpoint=False) 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.plot(x, y, 'go-', xnew, f, '.-', 10, y[0], 'ro') 
    &gt;&gt;&gt; plt.legend(['data', 'resampled'], loc='best') 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">domain </span><span class="s2">not in </span><span class="s3">(</span><span class="s4">'time'</span><span class="s3">, </span><span class="s4">'freq'</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Acceptable domain flags are 'time' or&quot;</span>
                         <span class="s4">f&quot; 'freq', not domain=</span><span class="s2">{</span><span class="s1">domain</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s3">)</span>

    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">Nx </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]</span>

    <span class="s0"># Check if we can use faster real FFT</span>
    <span class="s1">real_input </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isrealobj</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">domain </span><span class="s3">== </span><span class="s4">'time'</span><span class="s3">:</span>
        <span class="s0"># Forward transform</span>
        <span class="s2">if </span><span class="s1">real_input</span><span class="s3">:</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">rfft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:  </span><span class="s0"># Full complex FFT</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">fft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:  </span><span class="s0"># domain == 'freq'</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">x</span>

    <span class="s0"># Apply window to spectrum</span>
    <span class="s2">if </span><span class="s1">window </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">window</span><span class="s3">):</span>
            <span class="s1">W </span><span class="s3">= </span><span class="s1">window</span><span class="s3">(</span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">fftfreq</span><span class="s3">(</span><span class="s1">Nx</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">window</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">window</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= (</span><span class="s1">Nx</span><span class="s3">,):</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'window must have the same length as data'</span><span class="s3">)</span>
            <span class="s1">W </span><span class="s3">= </span><span class="s1">window</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">W </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">ifftshift</span><span class="s3">(</span><span class="s1">get_window</span><span class="s3">(</span><span class="s1">window</span><span class="s3">, </span><span class="s1">Nx</span><span class="s3">))</span>

        <span class="s1">newshape_W </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim</span>
        <span class="s1">newshape_W</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">real_input</span><span class="s3">:</span>
            <span class="s0"># Fold the window back on itself to mimic complex behavior</span>
            <span class="s1">W_real </span><span class="s3">= </span><span class="s1">W</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">W_real</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] += </span><span class="s1">W_real</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">:</span><span class="s5">0</span><span class="s3">:-</span><span class="s5">1</span><span class="s3">]</span>
            <span class="s1">W_real</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] *= </span><span class="s5">0.5</span>
            <span class="s1">X </span><span class="s3">*= </span><span class="s1">W_real</span><span class="s3">[:</span><span class="s1">newshape_W</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]].</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">newshape_W</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">X </span><span class="s3">*= </span><span class="s1">W</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">newshape_W</span><span class="s3">)</span>

    <span class="s0"># Copy each half of the original spectrum to the output spectrum, either</span>
    <span class="s0"># truncating high frequencies (downsampling) or zero-padding them</span>
    <span class="s0"># (upsampling)</span>

    <span class="s0"># Placeholder array for output spectrum</span>
    <span class="s1">newshape </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">real_input</span><span class="s3">:</span>
        <span class="s1">newshape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">num </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s5">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">newshape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">num</span>
    <span class="s1">Y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">newshape</span><span class="s3">, </span><span class="s1">X</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s0"># Copy positive frequency components (and Nyquist, if present)</span>
    <span class="s1">N </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">num</span><span class="s3">, </span><span class="s1">Nx</span><span class="s3">)</span>
    <span class="s1">nyq </span><span class="s3">= </span><span class="s1">N </span><span class="s3">// </span><span class="s5">2 </span><span class="s3">+ </span><span class="s5">1  </span><span class="s0"># Slice index that includes Nyquist if present</span>
    <span class="s1">sl </span><span class="s3">= [</span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)] * </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s1">sl</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">slice</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">nyq</span><span class="s3">)</span>
    <span class="s1">Y</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">sl</span><span class="s3">)] = </span><span class="s1">X</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">sl</span><span class="s3">)]</span>
    <span class="s2">if not </span><span class="s1">real_input</span><span class="s3">:</span>
        <span class="s0"># Copy negative frequency components</span>
        <span class="s2">if </span><span class="s1">N </span><span class="s3">&gt; </span><span class="s5">2</span><span class="s3">:  </span><span class="s0"># (slice expression doesn't collapse to empty array)</span>
            <span class="s1">sl</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">slice</span><span class="s3">(</span><span class="s1">nyq </span><span class="s3">- </span><span class="s1">N</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s1">Y</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">sl</span><span class="s3">)] = </span><span class="s1">X</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">sl</span><span class="s3">)]</span>

    <span class="s0"># Split/join Nyquist component(s) if present</span>
    <span class="s0"># So far we have set Y[+N/2]=X[+N/2]</span>
    <span class="s2">if </span><span class="s1">N </span><span class="s3">% </span><span class="s5">2 </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">num </span><span class="s3">&lt; </span><span class="s1">Nx</span><span class="s3">:  </span><span class="s0"># downsampling</span>
            <span class="s2">if </span><span class="s1">real_input</span><span class="s3">:</span>
                <span class="s1">sl</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">slice</span><span class="s3">(</span><span class="s1">N</span><span class="s3">//</span><span class="s5">2</span><span class="s3">, </span><span class="s1">N</span><span class="s3">//</span><span class="s5">2 </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
                <span class="s1">Y</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">sl</span><span class="s3">)] *= </span><span class="s5">2.</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s0"># select the component of Y at frequency +N/2,</span>
                <span class="s0"># add the component of X at -N/2</span>
                <span class="s1">sl</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">slice</span><span class="s3">(-</span><span class="s1">N</span><span class="s3">//</span><span class="s5">2</span><span class="s3">, -</span><span class="s1">N</span><span class="s3">//</span><span class="s5">2 </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
                <span class="s1">Y</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">sl</span><span class="s3">)] += </span><span class="s1">X</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">sl</span><span class="s3">)]</span>
        <span class="s2">elif </span><span class="s1">Nx </span><span class="s3">&lt; </span><span class="s1">num</span><span class="s3">:  </span><span class="s0"># upsampling</span>
            <span class="s0"># select the component at frequency +N/2 and halve it</span>
            <span class="s1">sl</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">slice</span><span class="s3">(</span><span class="s1">N</span><span class="s3">//</span><span class="s5">2</span><span class="s3">, </span><span class="s1">N</span><span class="s3">//</span><span class="s5">2 </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
            <span class="s1">Y</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">sl</span><span class="s3">)] *= </span><span class="s5">0.5</span>
            <span class="s2">if not </span><span class="s1">real_input</span><span class="s3">:</span>
                <span class="s1">temp </span><span class="s3">= </span><span class="s1">Y</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">sl</span><span class="s3">)]</span>
                <span class="s0"># set the component at -N/2 equal to the component at +N/2</span>
                <span class="s1">sl</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">slice</span><span class="s3">(</span><span class="s1">num</span><span class="s3">-</span><span class="s1">N</span><span class="s3">//</span><span class="s5">2</span><span class="s3">, </span><span class="s1">num</span><span class="s3">-</span><span class="s1">N</span><span class="s3">//</span><span class="s5">2 </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
                <span class="s1">Y</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">sl</span><span class="s3">)] = </span><span class="s1">temp</span>

    <span class="s0"># Inverse transform</span>
    <span class="s2">if </span><span class="s1">real_input</span><span class="s3">:</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">irfft</span><span class="s3">(</span><span class="s1">Y</span><span class="s3">, </span><span class="s1">num</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">sp_fft</span><span class="s3">.</span><span class="s1">ifft</span><span class="s3">(</span><span class="s1">Y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">overwrite_x</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s1">y </span><span class="s3">*= (</span><span class="s1">float</span><span class="s3">(</span><span class="s1">num</span><span class="s3">) / </span><span class="s1">float</span><span class="s3">(</span><span class="s1">Nx</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s1">t </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">y</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">new_t </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">num</span><span class="s3">) * (</span><span class="s1">t</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">t</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) * </span><span class="s1">Nx </span><span class="s3">/ </span><span class="s1">float</span><span class="s3">(</span><span class="s1">num</span><span class="s3">) + </span><span class="s1">t</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">y</span><span class="s3">, </span><span class="s1">new_t</span>


<span class="s2">def </span><span class="s1">resample_poly</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">up</span><span class="s3">, </span><span class="s1">down</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">window</span><span class="s3">=(</span><span class="s4">'kaiser'</span><span class="s3">, </span><span class="s5">5.0</span><span class="s3">),</span>
                  <span class="s1">padtype</span><span class="s3">=</span><span class="s4">'constant'</span><span class="s3">, </span><span class="s1">cval</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Resample `x` along the given axis using polyphase filtering. 
 
    The signal `x` is upsampled by the factor `up`, a zero-phase low-pass 
    FIR filter is applied, and then it is downsampled by the factor `down`. 
    The resulting sample rate is ``up / down`` times the original sample 
    rate. By default, values beyond the boundary of the signal are assumed 
    to be zero during the filtering step. 
 
    Parameters 
    ---------- 
    x : array_like 
        The data to be resampled. 
    up : int 
        The upsampling factor. 
    down : int 
        The downsampling factor. 
    axis : int, optional 
        The axis of `x` that is resampled. Default is 0. 
    window : string, tuple, or array_like, optional 
        Desired window to use to design the low-pass filter, or the FIR filter 
        coefficients to employ. See below for details. 
    padtype : string, optional 
        `constant`, `line`, `mean`, `median`, `maximum`, `minimum` or any of 
        the other signal extension modes supported by `scipy.signal.upfirdn`. 
        Changes assumptions on values beyond the boundary. If `constant`, 
        assumed to be `cval` (default zero). If `line` assumed to continue a 
        linear trend defined by the first and last points. `mean`, `median`, 
        `maximum` and `minimum` work as in `np.pad` and assume that the values 
        beyond the boundary are the mean, median, maximum or minimum 
        respectively of the array along the axis. 
 
        .. versionadded:: 1.4.0 
    cval : float, optional 
        Value to use if `padtype='constant'`. Default is zero. 
 
        .. versionadded:: 1.4.0 
 
    Returns 
    ------- 
    resampled_x : array 
        The resampled array. 
 
    See Also 
    -------- 
    decimate : Downsample the signal after applying an FIR or IIR filter. 
    resample : Resample up or down using the FFT method. 
 
    Notes 
    ----- 
    This polyphase method will likely be faster than the Fourier method 
    in `scipy.signal.resample` when the number of samples is large and 
    prime, or when the number of samples is large and `up` and `down` 
    share a large greatest common denominator. The length of the FIR 
    filter used will depend on ``max(up, down) // gcd(up, down)``, and 
    the number of operations during polyphase filtering will depend on 
    the filter length and `down` (see `scipy.signal.upfirdn` for details). 
 
    The argument `window` specifies the FIR low-pass filter design. 
 
    If `window` is an array_like it is assumed to be the FIR filter 
    coefficients. Note that the FIR filter is applied after the upsampling 
    step, so it should be designed to operate on a signal at a sampling 
    frequency higher than the original by a factor of `up//gcd(up, down)`. 
    This function's output will be centered with respect to this array, so it 
    is best to pass a symmetric filter with an odd number of samples if, as 
    is usually the case, a zero-phase filter is desired. 
 
    For any other type of `window`, the functions `scipy.signal.get_window` 
    and `scipy.signal.firwin` are called to generate the appropriate filter 
    coefficients. 
 
    The first sample of the returned vector is the same as the first 
    sample of the input vector. The spacing between samples is changed 
    from ``dx`` to ``dx * down / float(up)``. 
 
    Examples 
    -------- 
    By default, the end of the resampled data rises to meet the first 
    sample of the next cycle for the FFT method, and gets closer to zero 
    for the polyphase method: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; x = np.linspace(0, 10, 20, endpoint=False) 
    &gt;&gt;&gt; y = np.cos(-x**2/6.0) 
    &gt;&gt;&gt; f_fft = signal.resample(y, 100) 
    &gt;&gt;&gt; f_poly = signal.resample_poly(y, 100, 20) 
    &gt;&gt;&gt; xnew = np.linspace(0, 10, 100, endpoint=False) 
 
    &gt;&gt;&gt; plt.plot(xnew, f_fft, 'b.-', xnew, f_poly, 'r.-') 
    &gt;&gt;&gt; plt.plot(x, y, 'ko-') 
    &gt;&gt;&gt; plt.plot(10, y[0], 'bo', 10, 0., 'ro')  # boundaries 
    &gt;&gt;&gt; plt.legend(['resample', 'resamp_poly', 'data'], loc='best') 
    &gt;&gt;&gt; plt.show() 
 
    This default behaviour can be changed by using the padtype option: 
 
    &gt;&gt;&gt; N = 5 
    &gt;&gt;&gt; x = np.linspace(0, 1, N, endpoint=False) 
    &gt;&gt;&gt; y = 2 + x**2 - 1.7*np.sin(x) + .2*np.cos(11*x) 
    &gt;&gt;&gt; y2 = 1 + x**3 + 0.1*np.sin(x) + .1*np.cos(11*x) 
    &gt;&gt;&gt; Y = np.stack([y, y2], axis=-1) 
    &gt;&gt;&gt; up = 4 
    &gt;&gt;&gt; xr = np.linspace(0, 1, N*up, endpoint=False) 
 
    &gt;&gt;&gt; y2 = signal.resample_poly(Y, up, 1, padtype='constant') 
    &gt;&gt;&gt; y3 = signal.resample_poly(Y, up, 1, padtype='mean') 
    &gt;&gt;&gt; y4 = signal.resample_poly(Y, up, 1, padtype='line') 
 
    &gt;&gt;&gt; for i in [0,1]: 
    ...     plt.figure() 
    ...     plt.plot(xr, y4[:,i], 'g.', label='line') 
    ...     plt.plot(xr, y3[:,i], 'y.', label='mean') 
    ...     plt.plot(xr, y2[:,i], 'r.', label='constant') 
    ...     plt.plot(x, Y[:,i], 'k-') 
    ...     plt.legend() 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">up </span><span class="s3">!= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">up</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;up must be an integer&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">down </span><span class="s3">!= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">down</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;down must be an integer&quot;</span><span class="s3">)</span>
    <span class="s1">up </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">up</span><span class="s3">)</span>
    <span class="s1">down </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">down</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">up </span><span class="s3">&lt; </span><span class="s5">1 </span><span class="s2">or </span><span class="s1">down </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'up and down must be &gt;= 1'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">cval </span><span class="s2">is not None and </span><span class="s1">padtype </span><span class="s3">!= </span><span class="s4">'constant'</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'cval has no effect when padtype is '</span><span class="s3">, </span><span class="s1">padtype</span><span class="s3">)</span>

    <span class="s0"># Determine our up and down factors</span>
    <span class="s0"># Use a rational approximation to save computation time on really long</span>
    <span class="s0"># signals</span>
    <span class="s1">g_ </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">gcd</span><span class="s3">(</span><span class="s1">up</span><span class="s3">, </span><span class="s1">down</span><span class="s3">)</span>
    <span class="s1">up </span><span class="s3">//= </span><span class="s1">g_</span>
    <span class="s1">down </span><span class="s3">//= </span><span class="s1">g_</span>
    <span class="s2">if </span><span class="s1">up </span><span class="s3">== </span><span class="s1">down </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">n_in </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]</span>
    <span class="s1">n_out </span><span class="s3">= </span><span class="s1">n_in </span><span class="s3">* </span><span class="s1">up</span>
    <span class="s1">n_out </span><span class="s3">= </span><span class="s1">n_out </span><span class="s3">// </span><span class="s1">down </span><span class="s3">+ </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">n_out </span><span class="s3">% </span><span class="s1">down</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">window</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)):</span>
        <span class="s1">window </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">window</span><span class="s3">)  </span><span class="s0"># use array to force a copy (we modify it)</span>
        <span class="s2">if </span><span class="s1">window</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'window must be 1-D'</span><span class="s3">)</span>
        <span class="s1">half_len </span><span class="s3">= (</span><span class="s1">window</span><span class="s3">.</span><span class="s1">size </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) // </span><span class="s5">2</span>
        <span class="s1">h </span><span class="s3">= </span><span class="s1">window</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s0"># Design a linear-phase low-pass FIR filter</span>
        <span class="s1">max_rate </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">up</span><span class="s3">, </span><span class="s1">down</span><span class="s3">)</span>
        <span class="s1">f_c </span><span class="s3">= </span><span class="s5">1. </span><span class="s3">/ </span><span class="s1">max_rate  </span><span class="s0"># cutoff of FIR filter (rel. to Nyquist)</span>
        <span class="s1">half_len </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">* </span><span class="s1">max_rate  </span><span class="s0"># reasonable cutoff for sinc-like function</span>
        <span class="s1">h </span><span class="s3">= </span><span class="s1">firwin</span><span class="s3">(</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">half_len </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">f_c</span><span class="s3">,</span>
                   <span class="s1">window</span><span class="s3">=</span><span class="s1">window</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)  </span><span class="s0"># match dtype of x</span>
    <span class="s1">h </span><span class="s3">*= </span><span class="s1">up</span>

    <span class="s0"># Zero-pad our filter to put the output samples at the center</span>
    <span class="s1">n_pre_pad </span><span class="s3">= (</span><span class="s1">down </span><span class="s3">- </span><span class="s1">half_len </span><span class="s3">% </span><span class="s1">down</span><span class="s3">)</span>
    <span class="s1">n_post_pad </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s1">n_pre_remove </span><span class="s3">= (</span><span class="s1">half_len </span><span class="s3">+ </span><span class="s1">n_pre_pad</span><span class="s3">) // </span><span class="s1">down</span>
    <span class="s0"># We should rarely need to do this given our filter lengths...</span>
    <span class="s2">while </span><span class="s1">_output_len</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">h</span><span class="s3">) + </span><span class="s1">n_pre_pad </span><span class="s3">+ </span><span class="s1">n_post_pad</span><span class="s3">, </span><span class="s1">n_in</span><span class="s3">,</span>
                      <span class="s1">up</span><span class="s3">, </span><span class="s1">down</span><span class="s3">) &lt; </span><span class="s1">n_out </span><span class="s3">+ </span><span class="s1">n_pre_remove</span><span class="s3">:</span>
        <span class="s1">n_post_pad </span><span class="s3">+= </span><span class="s5">1</span>
    <span class="s1">h </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_pre_pad</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">h</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">), </span><span class="s1">h</span><span class="s3">,</span>
                        <span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_post_pad</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">h</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)))</span>
    <span class="s1">n_pre_remove_end </span><span class="s3">= </span><span class="s1">n_pre_remove </span><span class="s3">+ </span><span class="s1">n_out</span>

    <span class="s0"># Remove background depending on the padtype option</span>
    <span class="s1">funcs </span><span class="s3">= {</span><span class="s4">'mean'</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">, </span><span class="s4">'median'</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">median</span><span class="s3">,</span>
             <span class="s4">'minimum'</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">amin</span><span class="s3">, </span><span class="s4">'maximum'</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">amax</span><span class="s3">}</span>
    <span class="s1">upfirdn_kwargs </span><span class="s3">= {</span><span class="s4">'mode'</span><span class="s3">: </span><span class="s4">'constant'</span><span class="s3">, </span><span class="s4">'cval'</span><span class="s3">: </span><span class="s5">0</span><span class="s3">}</span>
    <span class="s2">if </span><span class="s1">padtype </span><span class="s2">in </span><span class="s1">funcs</span><span class="s3">:</span>
        <span class="s1">background_values </span><span class="s3">= </span><span class="s1">funcs</span><span class="s3">[</span><span class="s1">padtype</span><span class="s3">](</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">padtype </span><span class="s2">in </span><span class="s1">_upfirdn_modes</span><span class="s3">:</span>
        <span class="s1">upfirdn_kwargs </span><span class="s3">= {</span><span class="s4">'mode'</span><span class="s3">: </span><span class="s1">padtype</span><span class="s3">}</span>
        <span class="s2">if </span><span class="s1">padtype </span><span class="s3">== </span><span class="s4">'constant'</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">cval </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">cval </span><span class="s3">= </span><span class="s5">0</span>
            <span class="s1">upfirdn_kwargs</span><span class="s3">[</span><span class="s4">'cval'</span><span class="s3">] = </span><span class="s1">cval</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
            <span class="s4">'padtype must be one of: maximum, mean, median, minimum, ' </span><span class="s3">+</span>
            <span class="s4">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">_upfirdn_modes</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s1">padtype </span><span class="s2">in </span><span class="s1">funcs</span><span class="s3">:</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">x </span><span class="s3">- </span><span class="s1">background_values</span>

    <span class="s0"># filter then remove excess</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">upfirdn</span><span class="s3">(</span><span class="s1">h</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">up</span><span class="s3">, </span><span class="s1">down</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, **</span><span class="s1">upfirdn_kwargs</span><span class="s3">)</span>
    <span class="s1">keep </span><span class="s3">= [</span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">), ]*</span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s1">keep</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">slice</span><span class="s3">(</span><span class="s1">n_pre_remove</span><span class="s3">, </span><span class="s1">n_pre_remove_end</span><span class="s3">)</span>
    <span class="s1">y_keep </span><span class="s3">= </span><span class="s1">y</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">keep</span><span class="s3">)]</span>

    <span class="s0"># Add background back</span>
    <span class="s2">if </span><span class="s1">padtype </span><span class="s2">in </span><span class="s1">funcs</span><span class="s3">:</span>
        <span class="s1">y_keep </span><span class="s3">+= </span><span class="s1">background_values</span>

    <span class="s2">return </span><span class="s1">y_keep</span>


<span class="s2">def </span><span class="s1">vectorstrength</span><span class="s3">(</span><span class="s1">events</span><span class="s3">, </span><span class="s1">period</span><span class="s3">):</span>
    <span class="s6">''' 
    Determine the vector strength of the events corresponding to the given 
    period. 
 
    The vector strength is a measure of phase synchrony, how well the 
    timing of the events is synchronized to a single period of a periodic 
    signal. 
 
    If multiple periods are used, calculate the vector strength of each. 
    This is called the &quot;resonating vector strength&quot;. 
 
    Parameters 
    ---------- 
    events : 1D array_like 
        An array of time points containing the timing of the events. 
    period : float or array_like 
        The period of the signal that the events should synchronize to. 
        The period is in the same units as `events`.  It can also be an array 
        of periods, in which case the outputs are arrays of the same length. 
 
    Returns 
    ------- 
    strength : float or 1D array 
        The strength of the synchronization.  1.0 is perfect synchronization 
        and 0.0 is no synchronization.  If `period` is an array, this is also 
        an array with each element containing the vector strength at the 
        corresponding period. 
    phase : float or array 
        The phase that the events are most strongly synchronized to in radians. 
        If `period` is an array, this is also an array with each element 
        containing the phase for the corresponding period. 
 
    References 
    ---------- 
    van Hemmen, JL, Longtin, A, and Vollmayr, AN. Testing resonating vector 
        strength: Auditory system, electric fish, and noise. 
        Chaos 21, 047508 (2011); 
        :doi:`10.1063/1.3670512`. 
    van Hemmen, JL.  Vector strength after Goldberg, Brown, and von Mises: 
        biological and mathematical perspectives.  Biol Cybern. 
        2013 Aug;107(4):385-96. :doi:`10.1007/s00422-013-0561-7`. 
    van Hemmen, JL and Vollmayr, AN.  Resonating vector strength: what happens 
        when we vary the &quot;probing&quot; frequency while keeping the spike times 
        fixed.  Biol Cybern. 2013 Aug;107(4):491-94. 
        :doi:`10.1007/s00422-013-0560-8`. 
    '''</span>
    <span class="s1">events </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">events</span><span class="s3">)</span>
    <span class="s1">period </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">period</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">events</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'events cannot have dimensions more than 1'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">period</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'period cannot have dimensions more than 1'</span><span class="s3">)</span>

    <span class="s0"># we need to know later if period was originally a scalar</span>
    <span class="s1">scalarperiod </span><span class="s3">= </span><span class="s2">not </span><span class="s1">period</span><span class="s3">.</span><span class="s1">ndim</span>

    <span class="s1">events </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_2d</span><span class="s3">(</span><span class="s1">events</span><span class="s3">)</span>
    <span class="s1">period </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_2d</span><span class="s3">(</span><span class="s1">period</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">period </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">).</span><span class="s1">any</span><span class="s3">():</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'periods must be positive'</span><span class="s3">)</span>

    <span class="s0"># this converts the times to vectors</span>
    <span class="s1">vectors </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s5">2j</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">/</span><span class="s1">period</span><span class="s3">.</span><span class="s1">T</span><span class="s3">, </span><span class="s1">events</span><span class="s3">))</span>

    <span class="s0"># the vector strength is just the magnitude of the mean of the vectors</span>
    <span class="s0"># the vector phase is the angle of the mean of the vectors</span>
    <span class="s1">vectormean </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">vectors</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">strength </span><span class="s3">= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">vectormean</span><span class="s3">)</span>
    <span class="s1">phase </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">angle</span><span class="s3">(</span><span class="s1">vectormean</span><span class="s3">)</span>

    <span class="s0"># if the original period was a scalar, return scalars</span>
    <span class="s2">if </span><span class="s1">scalarperiod</span><span class="s3">:</span>
        <span class="s1">strength </span><span class="s3">= </span><span class="s1">strength</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">phase </span><span class="s3">= </span><span class="s1">phase</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">strength</span><span class="s3">, </span><span class="s1">phase</span>


<span class="s2">def </span><span class="s1">detrend</span><span class="s3">(</span><span class="s1">data</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= -</span><span class="s5">1</span><span class="s3">,</span>
            <span class="s1">type</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">'linear'</span><span class="s3">, </span><span class="s4">'constant'</span><span class="s3">] = </span><span class="s4">'linear'</span><span class="s3">,</span>
            <span class="s1">bp</span><span class="s3">: </span><span class="s1">ArrayLike </span><span class="s3">| </span><span class="s1">int </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">overwrite_data</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">) </span><span class="s1">-&gt; np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">:</span>
    <span class="s6">r&quot;&quot;&quot;Remove linear or constant trend along axis from data. 
 
    Parameters 
    ---------- 
    data : array_like 
        The input data. 
    axis : int, optional 
        The axis along which to detrend the data. By default this is the 
        last axis (-1). 
    type : {'linear', 'constant'}, optional 
        The type of detrending. If ``type == 'linear'`` (default), 
        the result of a linear least-squares fit to `data` is subtracted 
        from `data`. 
        If ``type == 'constant'``, only the mean of `data` is subtracted. 
    bp : array_like of ints, optional 
        A sequence of break points. If given, an individual linear fit is 
        performed for each part of `data` between two break points. 
        Break points are specified as indices into `data`. This parameter 
        only has an effect when ``type == 'linear'``. 
    overwrite_data : bool, optional 
        If True, perform in place detrending and avoid a copy. Default is False 
 
    Returns 
    ------- 
    ret : ndarray 
        The detrended input data. 
 
    Notes 
    ----- 
    Detrending can be interpreted as substracting a least squares fit polyonimial: 
    Setting the parameter `type` to 'constant' corresponds to fitting a zeroth degree 
    polynomial, 'linear' to a first degree polynomial. Consult the example below. 
 
    See Also 
    -------- 
    numpy.polynomial.polynomial.Polynomial.fit: Create least squares fit polynomial. 
 
 
    Examples 
    -------- 
    The following example detrends the function :math:`x(t) = \sin(\pi t) + 1/4`: 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal import detrend 
    ... 
    &gt;&gt;&gt; t = np.linspace(-0.5, 0.5, 21) 
    &gt;&gt;&gt; x = np.sin(np.pi*t) + 1/4 
    ... 
    &gt;&gt;&gt; x_d_const = detrend(x, type='constant') 
    &gt;&gt;&gt; x_d_linear = detrend(x, type='linear') 
    ... 
    &gt;&gt;&gt; fig1, ax1 = plt.subplots() 
    &gt;&gt;&gt; ax1.set_title(r&quot;Detrending $x(t)=\sin(\pi t) + 1/4$&quot;) 
    &gt;&gt;&gt; ax1.set(xlabel=&quot;t&quot;, ylabel=&quot;$x(t)$&quot;, xlim=(t[0], t[-1])) 
    &gt;&gt;&gt; ax1.axhline(y=0, color='black', linewidth=.5) 
    &gt;&gt;&gt; ax1.axvline(x=0, color='black', linewidth=.5) 
    &gt;&gt;&gt; ax1.plot(t, x, 'C0.-',  label=&quot;No detrending&quot;) 
    &gt;&gt;&gt; ax1.plot(t, x_d_const, 'C1x-', label=&quot;type='constant'&quot;) 
    &gt;&gt;&gt; ax1.plot(t, x_d_linear, 'C2+-', label=&quot;type='linear'&quot;) 
    &gt;&gt;&gt; ax1.legend() 
    &gt;&gt;&gt; plt.show() 
 
    Alternatively, NumPy's `~numpy.polynomial.polynomial.Polynomial` can be used for 
    detrending as well: 
 
    &gt;&gt;&gt; pp0 = np.polynomial.Polynomial.fit(t, x, deg=0)  # fit degree 0 polynomial 
    &gt;&gt;&gt; np.allclose(x_d_const, x - pp0(t))  # compare with constant detrend 
    True 
    &gt;&gt;&gt; pp1 = np.polynomial.Polynomial.fit(t, x, deg=1)  # fit degree 1 polynomial 
    &gt;&gt;&gt; np.allclose(x_d_linear, x - pp1(t))  # compare with linear detrend 
    True 
 
    Note that `~numpy.polynomial.polynomial.Polynomial` also allows fitting higher 
    degree polynomials. Consult its documentation on how to extract the polynomial 
    coefficients. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">type </span><span class="s2">not in </span><span class="s3">[</span><span class="s4">'linear'</span><span class="s3">, </span><span class="s4">'l'</span><span class="s3">, </span><span class="s4">'constant'</span><span class="s3">, </span><span class="s4">'c'</span><span class="s3">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Trend type must be 'linear' or 'constant'.&quot;</span><span class="s3">)</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
    <span class="s1">dtype </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">not in </span><span class="s4">'dfDF'</span><span class="s3">:</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s4">'d'</span>
    <span class="s2">if </span><span class="s1">type </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'constant'</span><span class="s3">, </span><span class="s4">'c'</span><span class="s3">]:</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s1">data </span><span class="s3">- </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">ret</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">dshape </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s1">N </span><span class="s3">= </span><span class="s1">dshape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]</span>
        <span class="s1">bp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">bp</span><span class="s3">, </span><span class="s1">N</span><span class="s3">))))</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">bp </span><span class="s3">&gt; </span><span class="s1">N</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Breakpoints must be less than length &quot;</span>
                             <span class="s4">&quot;of data along given axis.&quot;</span><span class="s3">)</span>

        <span class="s0"># Restructure data so that axis is along first dimension and</span>
        <span class="s0">#  all other dimensions are collapsed into second dimension</span>
        <span class="s1">rnk </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">dshape</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s1">axis </span><span class="s3">= </span><span class="s1">axis </span><span class="s3">+ </span><span class="s1">rnk</span>
        <span class="s1">newdata </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">newdata_shape </span><span class="s3">= </span><span class="s1">newdata</span><span class="s3">.</span><span class="s1">shape</span>
        <span class="s1">newdata </span><span class="s3">= </span><span class="s1">newdata</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)</span>

        <span class="s2">if not </span><span class="s1">overwrite_data</span><span class="s3">:</span>
            <span class="s1">newdata </span><span class="s3">= </span><span class="s1">newdata</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()  </span><span class="s0"># make sure we have a copy</span>
        <span class="s2">if </span><span class="s1">newdata</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char </span><span class="s2">not in </span><span class="s4">'dfDF'</span><span class="s3">:</span>
            <span class="s1">newdata </span><span class="s3">= </span><span class="s1">newdata</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">)</span>

<span class="s0">#        Nreg = len(bp) - 1</span>
        <span class="s0"># Find leastsq fit and remove it for each piece</span>
        <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">bp</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">):</span>
            <span class="s1">Npts </span><span class="s3">= </span><span class="s1">bp</span><span class="s3">[</span><span class="s1">m </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">] - </span><span class="s1">bp</span><span class="s3">[</span><span class="s1">m</span><span class="s3">]</span>
            <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s1">Npts</span><span class="s3">, </span><span class="s5">2</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">A</span><span class="s3">[:, </span><span class="s5">0</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">Npts </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">) / </span><span class="s1">Npts</span>
            <span class="s1">sl </span><span class="s3">= </span><span class="s1">slice</span><span class="s3">(</span><span class="s1">bp</span><span class="s3">[</span><span class="s1">m</span><span class="s3">], </span><span class="s1">bp</span><span class="s3">[</span><span class="s1">m </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">])</span>
            <span class="s1">coef</span><span class="s3">, </span><span class="s1">resids</span><span class="s3">, </span><span class="s1">rank</span><span class="s3">, </span><span class="s1">s </span><span class="s3">= </span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">lstsq</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">newdata</span><span class="s3">[</span><span class="s1">sl</span><span class="s3">])</span>
            <span class="s1">newdata</span><span class="s3">[</span><span class="s1">sl</span><span class="s3">] = </span><span class="s1">newdata</span><span class="s3">[</span><span class="s1">sl</span><span class="s3">] - </span><span class="s1">A </span><span class="s3">@ </span><span class="s1">coef</span>

        <span class="s0"># Put data back in original shape.</span>
        <span class="s1">newdata </span><span class="s3">= </span><span class="s1">newdata</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">newdata_shape</span><span class="s3">)</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">newdata</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">def </span><span class="s1">lfilter_zi</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Construct initial conditions for lfilter for step response steady-state. 
 
    Compute an initial state `zi` for the `lfilter` function that corresponds 
    to the steady state of the step response. 
 
    A typical use of this function is to set the initial state so that the 
    output of the filter starts at the same value as the first element of 
    the signal to be filtered. 
 
    Parameters 
    ---------- 
    b, a : array_like (1-D) 
        The IIR filter coefficients. See `lfilter` for more 
        information. 
 
    Returns 
    ------- 
    zi : 1-D ndarray 
        The initial state for the filter. 
 
    See Also 
    -------- 
    lfilter, lfiltic, filtfilt 
 
    Notes 
    ----- 
    A linear filter with order m has a state space representation (A, B, C, D), 
    for which the output y of the filter can be expressed as:: 
 
        z(n+1) = A*z(n) + B*x(n) 
        y(n)   = C*z(n) + D*x(n) 
 
    where z(n) is a vector of length m, A has shape (m, m), B has shape 
    (m, 1), C has shape (1, m) and D has shape (1, 1) (assuming x(n) is 
    a scalar).  lfilter_zi solves:: 
 
        zi = A*zi + B 
 
    In other words, it finds the initial condition for which the response 
    to an input of all ones is a constant. 
 
    Given the filter coefficients `a` and `b`, the state space matrices 
    for the transposed direct form II implementation of the linear filter, 
    which is the implementation used by scipy.signal.lfilter, are:: 
 
        A = scipy.linalg.companion(a).T 
        B = b[1:] - a[1:]*b[0] 
 
    assuming `a[0]` is 1.0; if `a[0]` is not 1, `a` and `b` are first 
    divided by a[0]. 
 
    Examples 
    -------- 
    The following code creates a lowpass Butterworth filter. Then it 
    applies that filter to an array whose values are all 1.0; the 
    output is also all 1.0, as expected for a lowpass filter.  If the 
    `zi` argument of `lfilter` had not been given, the output would have 
    shown the transient signal. 
 
    &gt;&gt;&gt; from numpy import array, ones 
    &gt;&gt;&gt; from scipy.signal import lfilter, lfilter_zi, butter 
    &gt;&gt;&gt; b, a = butter(5, 0.25) 
    &gt;&gt;&gt; zi = lfilter_zi(b, a) 
    &gt;&gt;&gt; y, zo = lfilter(b, a, ones(10), zi=zi) 
    &gt;&gt;&gt; y 
    array([1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.]) 
 
    Another example: 
 
    &gt;&gt;&gt; x = array([0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0]) 
    &gt;&gt;&gt; y, zf = lfilter(b, a, x, zi=zi*x[0]) 
    &gt;&gt;&gt; y 
    array([ 0.5       ,  0.5       ,  0.5       ,  0.49836039,  0.48610528, 
        0.44399389,  0.35505241]) 
 
    Note that the `zi` argument to `lfilter` was computed using 
    `lfilter_zi` and scaled by `x[0]`.  Then the output `y` has no 
    transient until the input drops from 0.5 to 0.0. 
 
    &quot;&quot;&quot;</span>

    <span class="s0"># FIXME: Can this function be replaced with an appropriate</span>
    <span class="s0"># use of lfiltic?  For example, when b,a = butter(N,Wn),</span>
    <span class="s0">#    lfiltic(b, a, y=numpy.ones_like(a), x=numpy.ones_like(b)).</span>
    <span class="s0">#</span>

    <span class="s0"># We could use scipy.signal.normalize, but it uses warnings in</span>
    <span class="s0"># cases where a ValueError is more appropriate, and it allows</span>
    <span class="s0"># b to be 2D.</span>
    <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">b</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Numerator b must be 1-D.&quot;</span><span class="s3">)</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Denominator a must be 1-D.&quot;</span><span class="s3">)</span>

    <span class="s2">while </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) &gt; </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">a</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s5">0.0</span><span class="s3">:</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]</span>
    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;There must be at least one nonzero `a` coefficient.&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">a</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] != </span><span class="s5">1.0</span><span class="s3">:</span>
        <span class="s0"># Normalize the coefficients so a[0] == 1.</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">b </span><span class="s3">/ </span><span class="s1">a</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">a </span><span class="s3">/ </span><span class="s1">a</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s1">n </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s1">len</span><span class="s3">(</span><span class="s1">b</span><span class="s3">))</span>

    <span class="s0"># Pad a or b with zeros so they are the same length.</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) &lt; </span><span class="s1">n</span><span class="s3">:</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">r_</span><span class="s3">[</span><span class="s1">a</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n </span><span class="s3">- </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)]</span>
    <span class="s2">elif </span><span class="s1">len</span><span class="s3">(</span><span class="s1">b</span><span class="s3">) &lt; </span><span class="s1">n</span><span class="s3">:</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">r_</span><span class="s3">[</span><span class="s1">b</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n </span><span class="s3">- </span><span class="s1">len</span><span class="s3">(</span><span class="s1">b</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">b</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)]</span>

    <span class="s1">IminusA </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">eye</span><span class="s3">(</span><span class="s1">n </span><span class="s3">- </span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">result_type</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">)) - </span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">companion</span><span class="s3">(</span><span class="s1">a</span><span class="s3">).</span><span class="s1">T</span>
    <span class="s1">B </span><span class="s3">= </span><span class="s1">b</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] - </span><span class="s1">a</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:] * </span><span class="s1">b</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s0"># Solve zi = A*zi + B</span>
    <span class="s1">zi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">solve</span><span class="s3">(</span><span class="s1">IminusA</span><span class="s3">, </span><span class="s1">B</span><span class="s3">)</span>

    <span class="s0"># For future reference: we could also use the following</span>
    <span class="s0"># explicit formulas to solve the linear system:</span>
    <span class="s0">#</span>
    <span class="s0"># zi = np.zeros(n - 1)</span>
    <span class="s0"># zi[0] = B.sum() / IminusA[:,0].sum()</span>
    <span class="s0"># asum = 1.0</span>
    <span class="s0"># csum = 0.0</span>
    <span class="s0"># for k in range(1,n-1):</span>
    <span class="s0">#     asum += a[k]</span>
    <span class="s0">#     csum += b[k] - a[k]*b[0]</span>
    <span class="s0">#     zi[k] = asum*zi[0] - csum</span>

    <span class="s2">return </span><span class="s1">zi</span>


<span class="s2">def </span><span class="s1">sosfilt_zi</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Construct initial conditions for sosfilt for step response steady-state. 
 
    Compute an initial state `zi` for the `sosfilt` function that corresponds 
    to the steady state of the step response. 
 
    A typical use of this function is to set the initial state so that the 
    output of the filter starts at the same value as the first element of 
    the signal to be filtered. 
 
    Parameters 
    ---------- 
    sos : array_like 
        Array of second-order filter coefficients, must have shape 
        ``(n_sections, 6)``. See `sosfilt` for the SOS filter format 
        specification. 
 
    Returns 
    ------- 
    zi : ndarray 
        Initial conditions suitable for use with ``sosfilt``, shape 
        ``(n_sections, 2)``. 
 
    See Also 
    -------- 
    sosfilt, zpk2sos 
 
    Notes 
    ----- 
    .. versionadded:: 0.16.0 
 
    Examples 
    -------- 
    Filter a rectangular pulse that begins at time 0, with and without 
    the use of the `zi` argument of `scipy.signal.sosfilt`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; sos = signal.butter(9, 0.125, output='sos') 
    &gt;&gt;&gt; zi = signal.sosfilt_zi(sos) 
    &gt;&gt;&gt; x = (np.arange(250) &lt; 100).astype(int) 
    &gt;&gt;&gt; f1 = signal.sosfilt(sos, x) 
    &gt;&gt;&gt; f2, zo = signal.sosfilt(sos, x, zi=zi) 
 
    &gt;&gt;&gt; plt.plot(x, 'k--', label='x') 
    &gt;&gt;&gt; plt.plot(f1, 'b', alpha=0.5, linewidth=2, label='filtered') 
    &gt;&gt;&gt; plt.plot(f2, 'g', alpha=0.25, linewidth=4, label='filtered with zi') 
    &gt;&gt;&gt; plt.legend(loc='best') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">sos </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">sos</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s5">2 </span><span class="s2">or </span><span class="s1">sos</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] != </span><span class="s5">6</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'sos must be shape (n_sections, 6)'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">sos</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s2">in </span><span class="s4">'bui'</span><span class="s3">:</span>
        <span class="s1">sos </span><span class="s3">= </span><span class="s1">sos</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>

    <span class="s1">n_sections </span><span class="s3">= </span><span class="s1">sos</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">zi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">((</span><span class="s1">n_sections</span><span class="s3">, </span><span class="s5">2</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">sos</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s1">scale </span><span class="s3">= </span><span class="s5">1.0</span>
    <span class="s2">for </span><span class="s1">section </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_sections</span><span class="s3">):</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">sos</span><span class="s3">[</span><span class="s1">section</span><span class="s3">, :</span><span class="s5">3</span><span class="s3">]</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">sos</span><span class="s3">[</span><span class="s1">section</span><span class="s3">, </span><span class="s5">3</span><span class="s3">:]</span>
        <span class="s1">zi</span><span class="s3">[</span><span class="s1">section</span><span class="s3">] = </span><span class="s1">scale </span><span class="s3">* </span><span class="s1">lfilter_zi</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>
        <span class="s0"># If H(z) = B(z)/A(z) is this section's transfer function, then</span>
        <span class="s0"># b.sum()/a.sum() is H(1), the gain at omega=0.  That's the steady</span>
        <span class="s0"># state value of this section's step response.</span>
        <span class="s1">scale </span><span class="s3">*= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">() / </span><span class="s1">a</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">()</span>

    <span class="s2">return </span><span class="s1">zi</span>


<span class="s2">def </span><span class="s1">_filtfilt_gust</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">irlen</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Forward-backward IIR filter that uses Gustafsson's method. 
 
    Apply the IIR filter defined by `(b,a)` to `x` twice, first forward 
    then backward, using Gustafsson's initial conditions [1]_. 
 
    Let ``y_fb`` be the result of filtering first forward and then backward, 
    and let ``y_bf`` be the result of filtering first backward then forward. 
    Gustafsson's method is to compute initial conditions for the forward 
    pass and the backward pass such that ``y_fb == y_bf``. 
 
    Parameters 
    ---------- 
    b : scalar or 1-D ndarray 
        Numerator coefficients of the filter. 
    a : scalar or 1-D ndarray 
        Denominator coefficients of the filter. 
    x : ndarray 
        Data to be filtered. 
    axis : int, optional 
        Axis of `x` to be filtered.  Default is -1. 
    irlen : int or None, optional 
        The length of the nonnegligible part of the impulse response. 
        If `irlen` is None, or if the length of the signal is less than 
        ``2 * irlen``, then no part of the impulse response is ignored. 
 
    Returns 
    ------- 
    y : ndarray 
        The filtered data. 
    x0 : ndarray 
        Initial condition for the forward filter. 
    x1 : ndarray 
        Initial condition for the backward filter. 
 
    Notes 
    ----- 
    Typically the return values `x0` and `x1` are not needed by the 
    caller.  The intended use of these return values is in unit tests. 
 
    References 
    ---------- 
    .. [1] F. Gustaffson. Determining the initial states in forward-backward 
           filtering. Transactions on Signal Processing, 46(4):988-992, 1996. 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># In the comments, &quot;Gustafsson's paper&quot; and [1] refer to the</span>
    <span class="s0"># paper referenced in the docstring.</span>

    <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

    <span class="s1">order </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">b</span><span class="s3">), </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)) - </span><span class="s5">1</span>
    <span class="s2">if </span><span class="s1">order </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s0"># The filter is just scalar multiplication, with no state.</span>
        <span class="s1">scale </span><span class="s3">= (</span><span class="s1">b</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] / </span><span class="s1">a</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])**</span><span class="s5">2</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">scale </span><span class="s3">* </span><span class="s1">x</span>
        <span class="s2">return </span><span class="s1">y</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([]), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([])</span>

    <span class="s2">if </span><span class="s1">axis </span><span class="s3">!= -</span><span class="s5">1 </span><span class="s2">or </span><span class="s1">axis </span><span class="s3">!= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s0"># Move the axis containing the data to the end.</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">swapaxes</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)</span>

    <span class="s0"># n is the number of samples in the data to be filtered.</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>

    <span class="s2">if </span><span class="s1">irlen </span><span class="s2">is None or </span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s5">2</span><span class="s3">*</span><span class="s1">irlen</span><span class="s3">:</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">n</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s1">irlen</span>

    <span class="s0"># Create Obs, the observability matrix (called O in the paper).</span>
    <span class="s0"># This matrix can be interpreted as the operator that propagates</span>
    <span class="s0"># an arbitrary initial state to the output, assuming the input is</span>
    <span class="s0"># zero.</span>
    <span class="s0"># In Gustafsson's paper, the forward and backward filters are not</span>
    <span class="s0"># necessarily the same, so he has both O_f and O_b.  We use the same</span>
    <span class="s0"># filter in both directions, so we only need O. The same comment</span>
    <span class="s0"># applies to S below.</span>
    <span class="s1">Obs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">m</span><span class="s3">, </span><span class="s1">order</span><span class="s3">))</span>
    <span class="s1">zi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">order</span><span class="s3">)</span>
    <span class="s1">zi</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] = </span><span class="s5">1</span>
    <span class="s1">Obs</span><span class="s3">[:, </span><span class="s5">0</span><span class="s3">] = </span><span class="s1">lfilter</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">m</span><span class="s3">), </span><span class="s1">zi</span><span class="s3">=</span><span class="s1">zi</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">order</span><span class="s3">):</span>
        <span class="s1">Obs</span><span class="s3">[</span><span class="s1">k</span><span class="s3">:, </span><span class="s1">k</span><span class="s3">] = </span><span class="s1">Obs</span><span class="s3">[:-</span><span class="s1">k</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>

    <span class="s0"># Obsr is O^R (Gustafsson's notation for row-reversed O)</span>
    <span class="s1">Obsr </span><span class="s3">= </span><span class="s1">Obs</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]</span>

    <span class="s0"># Create S.  S is the matrix that applies the filter to the reversed</span>
    <span class="s0"># propagated initial conditions.  That is,</span>
    <span class="s0">#     out = S.dot(zi)</span>
    <span class="s0"># is the same as</span>
    <span class="s0">#     tmp, _ = lfilter(b, a, zeros(), zi=zi)  # Propagate ICs.</span>
    <span class="s0">#     out = lfilter(b, a, tmp[::-1])          # Reverse and filter.</span>

    <span class="s0"># Equations (5) &amp; (6) of [1]</span>
    <span class="s1">S </span><span class="s3">= </span><span class="s1">lfilter</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">Obs</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s0"># Sr is S^R (row-reversed S)</span>
    <span class="s1">Sr </span><span class="s3">= </span><span class="s1">S</span><span class="s3">[::-</span><span class="s5">1</span><span class="s3">]</span>

    <span class="s0"># M is [(S^R - O), (O^R - S)]</span>
    <span class="s2">if </span><span class="s1">m </span><span class="s3">== </span><span class="s1">n</span><span class="s3">:</span>
        <span class="s1">M </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">((</span><span class="s1">Sr </span><span class="s3">- </span><span class="s1">Obs</span><span class="s3">, </span><span class="s1">Obsr </span><span class="s3">- </span><span class="s1">S</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s0"># Matrix described in section IV of [1].</span>
        <span class="s1">M </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s5">2</span><span class="s3">*</span><span class="s1">m</span><span class="s3">, </span><span class="s5">2</span><span class="s3">*</span><span class="s1">order</span><span class="s3">))</span>
        <span class="s1">M</span><span class="s3">[:</span><span class="s1">m</span><span class="s3">, :</span><span class="s1">order</span><span class="s3">] = </span><span class="s1">Sr </span><span class="s3">- </span><span class="s1">Obs</span>
        <span class="s1">M</span><span class="s3">[</span><span class="s1">m</span><span class="s3">:, </span><span class="s1">order</span><span class="s3">:] = </span><span class="s1">Obsr </span><span class="s3">- </span><span class="s1">S</span>

    <span class="s0"># Naive forward-backward and backward-forward filters.</span>
    <span class="s0"># These have large transients because the filters use zero initial</span>
    <span class="s0"># conditions.</span>
    <span class="s1">y_f </span><span class="s3">= </span><span class="s1">lfilter</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">y_fb </span><span class="s3">= </span><span class="s1">lfilter</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">y_f</span><span class="s3">[..., ::-</span><span class="s5">1</span><span class="s3">])[..., ::-</span><span class="s5">1</span><span class="s3">]</span>

    <span class="s1">y_b </span><span class="s3">= </span><span class="s1">lfilter</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">x</span><span class="s3">[..., ::-</span><span class="s5">1</span><span class="s3">])[..., ::-</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s1">y_bf </span><span class="s3">= </span><span class="s1">lfilter</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">y_b</span><span class="s3">)</span>

    <span class="s1">delta_y_bf_fb </span><span class="s3">= </span><span class="s1">y_bf </span><span class="s3">- </span><span class="s1">y_fb</span>
    <span class="s2">if </span><span class="s1">m </span><span class="s3">== </span><span class="s1">n</span><span class="s3">:</span>
        <span class="s1">delta </span><span class="s3">= </span><span class="s1">delta_y_bf_fb</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">start_m </span><span class="s3">= </span><span class="s1">delta_y_bf_fb</span><span class="s3">[..., :</span><span class="s1">m</span><span class="s3">]</span>
        <span class="s1">end_m </span><span class="s3">= </span><span class="s1">delta_y_bf_fb</span><span class="s3">[..., -</span><span class="s1">m</span><span class="s3">:]</span>
        <span class="s1">delta </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">((</span><span class="s1">start_m</span><span class="s3">, </span><span class="s1">end_m</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">)</span>

    <span class="s0"># ic_opt holds the &quot;optimal&quot; initial conditions.</span>
    <span class="s0"># The following code computes the result shown in the formula</span>
    <span class="s0"># of the paper between equations (6) and (7).</span>
    <span class="s2">if </span><span class="s1">delta</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s1">ic_opt </span><span class="s3">= </span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">lstsq</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">delta</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s0"># Reshape delta so it can be used as an array of multiple</span>
        <span class="s0"># right-hand-sides in linalg.lstsq.</span>
        <span class="s1">delta2d </span><span class="s3">= </span><span class="s1">delta</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">delta</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]).</span><span class="s1">T</span>
        <span class="s1">ic_opt0 </span><span class="s3">= </span><span class="s1">linalg</span><span class="s3">.</span><span class="s1">lstsq</span><span class="s3">(</span><span class="s1">M</span><span class="s3">, </span><span class="s1">delta2d</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">T</span>
        <span class="s1">ic_opt </span><span class="s3">= </span><span class="s1">ic_opt0</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">delta</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">] + (</span><span class="s1">M</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">],))</span>

    <span class="s0"># Now compute the filtered signal using equation (7) of [1].</span>
    <span class="s0"># First, form [S^R, O^R] and call it W.</span>
    <span class="s2">if </span><span class="s1">m </span><span class="s3">== </span><span class="s1">n</span><span class="s3">:</span>
        <span class="s1">W </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">((</span><span class="s1">Sr</span><span class="s3">, </span><span class="s1">Obsr</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">W </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s5">2</span><span class="s3">*</span><span class="s1">m</span><span class="s3">, </span><span class="s5">2</span><span class="s3">*</span><span class="s1">order</span><span class="s3">))</span>
        <span class="s1">W</span><span class="s3">[:</span><span class="s1">m</span><span class="s3">, :</span><span class="s1">order</span><span class="s3">] = </span><span class="s1">Sr</span>
        <span class="s1">W</span><span class="s3">[</span><span class="s1">m</span><span class="s3">:, </span><span class="s1">order</span><span class="s3">:] = </span><span class="s1">Obsr</span>

    <span class="s0"># Equation (7) of [1] says</span>
    <span class="s0">#     Y_fb^opt = Y_fb^0 + W * [x_0^opt; x_{N-1}^opt]</span>
    <span class="s0"># `wic` is (almost) the product on the right.</span>
    <span class="s0"># W has shape (m, 2*order), and ic_opt has shape (..., 2*order),</span>
    <span class="s0"># so we can't use W.dot(ic_opt).  Instead, we dot ic_opt with W.T,</span>
    <span class="s0"># so wic has shape (..., m).</span>
    <span class="s1">wic </span><span class="s3">= </span><span class="s1">ic_opt</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">W</span><span class="s3">.</span><span class="s1">T</span><span class="s3">)</span>

    <span class="s0"># `wic` is &quot;almost&quot; the product of W and the optimal ICs in equation</span>
    <span class="s0"># (7)--if we're using a truncated impulse response (m &lt; n), `wic`</span>
    <span class="s0"># contains only the adjustments required for the ends of the signal.</span>
    <span class="s0"># Here we form y_opt, taking this into account if necessary.</span>
    <span class="s1">y_opt </span><span class="s3">= </span><span class="s1">y_fb</span>
    <span class="s2">if </span><span class="s1">m </span><span class="s3">== </span><span class="s1">n</span><span class="s3">:</span>
        <span class="s1">y_opt </span><span class="s3">+= </span><span class="s1">wic</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">y_opt</span><span class="s3">[..., :</span><span class="s1">m</span><span class="s3">] += </span><span class="s1">wic</span><span class="s3">[..., :</span><span class="s1">m</span><span class="s3">]</span>
        <span class="s1">y_opt</span><span class="s3">[..., -</span><span class="s1">m</span><span class="s3">:] += </span><span class="s1">wic</span><span class="s3">[..., -</span><span class="s1">m</span><span class="s3">:]</span>

    <span class="s1">x0 </span><span class="s3">= </span><span class="s1">ic_opt</span><span class="s3">[..., :</span><span class="s1">order</span><span class="s3">]</span>
    <span class="s1">x1 </span><span class="s3">= </span><span class="s1">ic_opt</span><span class="s3">[..., -</span><span class="s1">order</span><span class="s3">:]</span>
    <span class="s2">if </span><span class="s1">axis </span><span class="s3">!= -</span><span class="s5">1 </span><span class="s2">or </span><span class="s1">axis </span><span class="s3">!= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">:</span>
        <span class="s0"># Restore the data axis to its original position.</span>
        <span class="s1">x0 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">swapaxes</span><span class="s3">(</span><span class="s1">x0</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">x1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">swapaxes</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">y_opt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">swapaxes</span><span class="s3">(</span><span class="s1">y_opt</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">y_opt</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">x1</span>


<span class="s2">def </span><span class="s1">filtfilt</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">padtype</span><span class="s3">=</span><span class="s4">'odd'</span><span class="s3">, </span><span class="s1">padlen</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">'pad'</span><span class="s3">,</span>
             <span class="s1">irlen</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Apply a digital filter forward and backward to a signal. 
 
    This function applies a linear digital filter twice, once forward and 
    once backwards.  The combined filter has zero phase and a filter order 
    twice that of the original. 
 
    The function provides options for handling the edges of the signal. 
 
    The function `sosfiltfilt` (and filter design using ``output='sos'``) 
    should be preferred over `filtfilt` for most filtering tasks, as 
    second-order sections have fewer numerical problems. 
 
    Parameters 
    ---------- 
    b : (N,) array_like 
        The numerator coefficient vector of the filter. 
    a : (N,) array_like 
        The denominator coefficient vector of the filter.  If ``a[0]`` 
        is not 1, then both `a` and `b` are normalized by ``a[0]``. 
    x : array_like 
        The array of data to be filtered. 
    axis : int, optional 
        The axis of `x` to which the filter is applied. 
        Default is -1. 
    padtype : str or None, optional 
        Must be 'odd', 'even', 'constant', or None.  This determines the 
        type of extension to use for the padded signal to which the filter 
        is applied.  If `padtype` is None, no padding is used.  The default 
        is 'odd'. 
    padlen : int or None, optional 
        The number of elements by which to extend `x` at both ends of 
        `axis` before applying the filter.  This value must be less than 
        ``x.shape[axis] - 1``.  ``padlen=0`` implies no padding. 
        The default value is ``3 * max(len(a), len(b))``. 
    method : str, optional 
        Determines the method for handling the edges of the signal, either 
        &quot;pad&quot; or &quot;gust&quot;.  When `method` is &quot;pad&quot;, the signal is padded; the 
        type of padding is determined by `padtype` and `padlen`, and `irlen` 
        is ignored.  When `method` is &quot;gust&quot;, Gustafsson's method is used, 
        and `padtype` and `padlen` are ignored. 
    irlen : int or None, optional 
        When `method` is &quot;gust&quot;, `irlen` specifies the length of the 
        impulse response of the filter.  If `irlen` is None, no part 
        of the impulse response is ignored.  For a long signal, specifying 
        `irlen` can significantly improve the performance of the filter. 
 
    Returns 
    ------- 
    y : ndarray 
        The filtered output with the same shape as `x`. 
 
    See Also 
    -------- 
    sosfiltfilt, lfilter_zi, lfilter, lfiltic, savgol_filter, sosfilt 
 
    Notes 
    ----- 
    When `method` is &quot;pad&quot;, the function pads the data along the given axis 
    in one of three ways: odd, even or constant.  The odd and even extensions 
    have the corresponding symmetry about the end point of the data.  The 
    constant extension extends the data with the values at the end points. On 
    both the forward and backward passes, the initial condition of the 
    filter is found by using `lfilter_zi` and scaling it by the end point of 
    the extended data. 
 
    When `method` is &quot;gust&quot;, Gustafsson's method [1]_ is used.  Initial 
    conditions are chosen for the forward and backward passes so that the 
    forward-backward filter gives the same result as the backward-forward 
    filter. 
 
    The option to use Gustaffson's method was added in scipy version 0.16.0. 
 
    References 
    ---------- 
    .. [1] F. Gustaffson, &quot;Determining the initial states in forward-backward 
           filtering&quot;, Transactions on Signal Processing, Vol. 46, pp. 988-992, 
           1996. 
 
    Examples 
    -------- 
    The examples will use several functions from `scipy.signal`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    First we create a one second signal that is the sum of two pure sine 
    waves, with frequencies 5 Hz and 250 Hz, sampled at 2000 Hz. 
 
    &gt;&gt;&gt; t = np.linspace(0, 1.0, 2001) 
    &gt;&gt;&gt; xlow = np.sin(2 * np.pi * 5 * t) 
    &gt;&gt;&gt; xhigh = np.sin(2 * np.pi * 250 * t) 
    &gt;&gt;&gt; x = xlow + xhigh 
 
    Now create a lowpass Butterworth filter with a cutoff of 0.125 times 
    the Nyquist frequency, or 125 Hz, and apply it to ``x`` with `filtfilt`. 
    The result should be approximately ``xlow``, with no phase shift. 
 
    &gt;&gt;&gt; b, a = signal.butter(8, 0.125) 
    &gt;&gt;&gt; y = signal.filtfilt(b, a, x, padlen=150) 
    &gt;&gt;&gt; np.abs(y - xlow).max() 
    9.1086182074789912e-06 
 
    We get a fairly clean result for this artificial example because 
    the odd extension is exact, and with the moderately long padding, 
    the filter's transients have dissipated by the time the actual data 
    is reached.  In general, transient effects at the edges are 
    unavoidable. 
 
    The following example demonstrates the option ``method=&quot;gust&quot;``. 
 
    First, create a filter. 
 
    &gt;&gt;&gt; b, a = signal.ellip(4, 0.01, 120, 0.125)  # Filter to be applied. 
 
    `sig` is a random input signal to be filtered. 
 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; n = 60 
    &gt;&gt;&gt; sig = rng.standard_normal(n)**3 + 3*rng.standard_normal(n).cumsum() 
 
    Apply `filtfilt` to `sig`, once using the Gustafsson method, and 
    once using padding, and plot the results for comparison. 
 
    &gt;&gt;&gt; fgust = signal.filtfilt(b, a, sig, method=&quot;gust&quot;) 
    &gt;&gt;&gt; fpad = signal.filtfilt(b, a, sig, padlen=50) 
    &gt;&gt;&gt; plt.plot(sig, 'k-', label='input') 
    &gt;&gt;&gt; plt.plot(fgust, 'b-', linewidth=4, label='gust') 
    &gt;&gt;&gt; plt.plot(fpad, 'c-', linewidth=1.5, label='pad') 
    &gt;&gt;&gt; plt.legend(loc='best') 
    &gt;&gt;&gt; plt.show() 
 
    The `irlen` argument can be used to improve the performance 
    of Gustafsson's method. 
 
    Estimate the impulse response length of the filter. 
 
    &gt;&gt;&gt; z, p, k = signal.tf2zpk(b, a) 
    &gt;&gt;&gt; eps = 1e-9 
    &gt;&gt;&gt; r = np.max(np.abs(p)) 
    &gt;&gt;&gt; approx_impulse_len = int(np.ceil(np.log(eps) / np.log(r))) 
    &gt;&gt;&gt; approx_impulse_len 
    137 
 
    Apply the filter to a longer signal, with and without the `irlen` 
    argument.  The difference between `y1` and `y2` is small.  For long 
    signals, using `irlen` gives a significant performance improvement. 
 
    &gt;&gt;&gt; x = rng.standard_normal(4000) 
    &gt;&gt;&gt; y1 = signal.filtfilt(b, a, x, method='gust') 
    &gt;&gt;&gt; y2 = signal.filtfilt(b, a, x, method='gust', irlen=approx_impulse_len) 
    &gt;&gt;&gt; print(np.max(np.abs(y1 - y2))) 
    2.875334415008979e-10 
 
    &quot;&quot;&quot;</span>
    <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">method </span><span class="s2">not in </span><span class="s3">[</span><span class="s4">&quot;pad&quot;</span><span class="s3">, </span><span class="s4">&quot;gust&quot;</span><span class="s3">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;method must be 'pad' or 'gust'.&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">method </span><span class="s3">== </span><span class="s4">&quot;gust&quot;</span><span class="s3">:</span>
        <span class="s1">y</span><span class="s3">, </span><span class="s1">z1</span><span class="s3">, </span><span class="s1">z2 </span><span class="s3">= </span><span class="s1">_filtfilt_gust</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">irlen</span><span class="s3">=</span><span class="s1">irlen</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">y</span>

    <span class="s0"># method == &quot;pad&quot;</span>
    <span class="s1">edge</span><span class="s3">, </span><span class="s1">ext </span><span class="s3">= </span><span class="s1">_validate_pad</span><span class="s3">(</span><span class="s1">padtype</span><span class="s3">, </span><span class="s1">padlen</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">,</span>
                              <span class="s1">ntaps</span><span class="s3">=</span><span class="s1">max</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s1">len</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)))</span>

    <span class="s0"># Get the steady state of the filter's step response.</span>
    <span class="s1">zi </span><span class="s3">= </span><span class="s1">lfilter_zi</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">)</span>

    <span class="s0"># Reshape zi and create x0 so that zi*x0 broadcasts</span>
    <span class="s0"># to the correct value for the 'zi' keyword argument</span>
    <span class="s0"># to lfilter.</span>
    <span class="s1">zi_shape </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s1">zi_shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">zi</span><span class="s3">.</span><span class="s1">size</span>
    <span class="s1">zi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">zi</span><span class="s3">, </span><span class="s1">zi_shape</span><span class="s3">)</span>
    <span class="s1">x0 </span><span class="s3">= </span><span class="s1">axis_slice</span><span class="s3">(</span><span class="s1">ext</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s0"># Forward filter.</span>
    <span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">zf</span><span class="s3">) = </span><span class="s1">lfilter</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">ext</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">zi</span><span class="s3">=</span><span class="s1">zi </span><span class="s3">* </span><span class="s1">x0</span><span class="s3">)</span>

    <span class="s0"># Backward filter.</span>
    <span class="s0"># Create y0 so zi*y0 broadcasts appropriately.</span>
    <span class="s1">y0 </span><span class="s3">= </span><span class="s1">axis_slice</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">zf</span><span class="s3">) = </span><span class="s1">lfilter</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis_reverse</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">zi</span><span class="s3">=</span><span class="s1">zi </span><span class="s3">* </span><span class="s1">y0</span><span class="s3">)</span>

    <span class="s0"># Reverse y.</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">axis_reverse</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">edge </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s0"># Slice the actual signal from the extended signal.</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">axis_slice</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s1">edge</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">=-</span><span class="s1">edge</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">y</span>


<span class="s2">def </span><span class="s1">_validate_pad</span><span class="s3">(</span><span class="s1">padtype</span><span class="s3">, </span><span class="s1">padlen</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ntaps</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot;Helper to validate padding for filtfilt&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">padtype </span><span class="s2">not in </span><span class="s3">[</span><span class="s4">'even'</span><span class="s3">, </span><span class="s4">'odd'</span><span class="s3">, </span><span class="s4">'constant'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">((</span><span class="s4">&quot;Unknown value '%s' given to padtype.  padtype &quot;</span>
                          <span class="s4">&quot;must be 'even', 'odd', 'constant', or None.&quot;</span><span class="s3">) %</span>
                         <span class="s1">padtype</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">padtype </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">padlen </span><span class="s3">= </span><span class="s5">0</span>

    <span class="s2">if </span><span class="s1">padlen </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s0"># Original padding; preserved for backwards compatibility.</span>
        <span class="s1">edge </span><span class="s3">= </span><span class="s1">ntaps </span><span class="s3">* </span><span class="s5">3</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">edge </span><span class="s3">= </span><span class="s1">padlen</span>

    <span class="s0"># x's 'axis' dimension must be bigger than edge.</span>
    <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] &lt;= </span><span class="s1">edge</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;The length of the input vector x must be greater &quot;</span>
                         <span class="s4">&quot;than padlen, which is %d.&quot; </span><span class="s3">% </span><span class="s1">edge</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">padtype </span><span class="s2">is not None and </span><span class="s1">edge </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s0"># Make an extension of length `edge` at each</span>
        <span class="s0"># end of the input array.</span>
        <span class="s2">if </span><span class="s1">padtype </span><span class="s3">== </span><span class="s4">'even'</span><span class="s3">:</span>
            <span class="s1">ext </span><span class="s3">= </span><span class="s1">even_ext</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">edge</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">padtype </span><span class="s3">== </span><span class="s4">'odd'</span><span class="s3">:</span>
            <span class="s1">ext </span><span class="s3">= </span><span class="s1">odd_ext</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">edge</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">ext </span><span class="s3">= </span><span class="s1">const_ext</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">edge</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">ext </span><span class="s3">= </span><span class="s1">x</span>
    <span class="s2">return </span><span class="s1">edge</span><span class="s3">, </span><span class="s1">ext</span>


<span class="s2">def </span><span class="s1">_validate_x</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'x must be at least 1-D'</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">x</span>


<span class="s2">def </span><span class="s1">sosfilt</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">zi</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Filter data along one dimension using cascaded second-order sections. 
 
    Filter a data sequence, `x`, using a digital IIR filter defined by 
    `sos`. 
 
    Parameters 
    ---------- 
    sos : array_like 
        Array of second-order filter coefficients, must have shape 
        ``(n_sections, 6)``. Each row corresponds to a second-order 
        section, with the first three columns providing the numerator 
        coefficients and the last three providing the denominator 
        coefficients. 
    x : array_like 
        An N-dimensional input array. 
    axis : int, optional 
        The axis of the input data array along which to apply the 
        linear filter. The filter is applied to each subarray along 
        this axis.  Default is -1. 
    zi : array_like, optional 
        Initial conditions for the cascaded filter delays.  It is a (at 
        least 2D) vector of shape ``(n_sections, ..., 2, ...)``, where 
        ``..., 2, ...`` denotes the shape of `x`, but with ``x.shape[axis]`` 
        replaced by 2.  If `zi` is None or is not given then initial rest 
        (i.e. all zeros) is assumed. 
        Note that these initial conditions are *not* the same as the initial 
        conditions given by `lfiltic` or `lfilter_zi`. 
 
    Returns 
    ------- 
    y : ndarray 
        The output of the digital filter. 
    zf : ndarray, optional 
        If `zi` is None, this is not returned, otherwise, `zf` holds the 
        final filter delay values. 
 
    See Also 
    -------- 
    zpk2sos, sos2zpk, sosfilt_zi, sosfiltfilt, sosfreqz 
 
    Notes 
    ----- 
    The filter function is implemented as a series of second-order filters 
    with direct-form II transposed structure. It is designed to minimize 
    numerical precision errors for high-order filters. 
 
    .. versionadded:: 0.16.0 
 
    Examples 
    -------- 
    Plot a 13th-order filter's impulse response using both `lfilter` and 
    `sosfilt`, showing the instability that results from trying to do a 
    13th-order filter in a single stage (the numerical error pushes some poles 
    outside of the unit circle): 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; b, a = signal.ellip(13, 0.009, 80, 0.05, output='ba') 
    &gt;&gt;&gt; sos = signal.ellip(13, 0.009, 80, 0.05, output='sos') 
    &gt;&gt;&gt; x = signal.unit_impulse(700) 
    &gt;&gt;&gt; y_tf = signal.lfilter(b, a, x) 
    &gt;&gt;&gt; y_sos = signal.sosfilt(sos, x) 
    &gt;&gt;&gt; plt.plot(y_tf, 'r', label='TF') 
    &gt;&gt;&gt; plt.plot(y_sos, 'k', label='SOS') 
    &gt;&gt;&gt; plt.legend(loc='best') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">_validate_x</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">sos</span><span class="s3">, </span><span class="s1">n_sections </span><span class="s3">= </span><span class="s1">_validate_sos</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">)</span>
    <span class="s1">x_zi_shape </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">x_zi_shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s5">2</span>
    <span class="s1">x_zi_shape </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">([</span><span class="s1">n_sections</span><span class="s3">] + </span><span class="s1">x_zi_shape</span><span class="s3">)</span>
    <span class="s1">inputs </span><span class="s3">= [</span><span class="s1">sos</span><span class="s3">, </span><span class="s1">x</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">zi </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">inputs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">zi</span><span class="s3">))</span>
    <span class="s1">dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">result_type</span><span class="s3">(*</span><span class="s1">inputs</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">char </span><span class="s2">not in </span><span class="s4">'fdgFDGO'</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">&quot;input type '%s' not supported&quot; </span><span class="s3">% </span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">zi </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">zi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">zi</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">)  </span><span class="s0"># make a copy so that we can operate in place</span>
        <span class="s2">if </span><span class="s1">zi</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= </span><span class="s1">x_zi_shape</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Invalid zi shape. With axis=%r, an input with '</span>
                             <span class="s4">'shape %r, and an sos array with %d sections, zi '</span>
                             <span class="s4">'must have shape %r, got %r.' </span><span class="s3">%</span>
                             <span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">n_sections</span><span class="s3">, </span><span class="s1">x_zi_shape</span><span class="s3">, </span><span class="s1">zi</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">))</span>
        <span class="s1">return_zi </span><span class="s3">= </span><span class="s2">True</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">zi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">x_zi_shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">return_zi </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s1">axis </span><span class="s3">= </span><span class="s1">axis </span><span class="s3">% </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim  </span><span class="s0"># make positive</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">zi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">zi</span><span class="s3">, [</span><span class="s5">0</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">], [-</span><span class="s5">2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">])</span>
    <span class="s1">x_shape</span><span class="s3">, </span><span class="s1">zi_shape </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">zi</span><span class="s3">.</span><span class="s1">shape</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, (-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]))</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s4">'C'</span><span class="s3">)  </span><span class="s0"># make a copy, can modify in place</span>
    <span class="s1">zi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ascontiguousarray</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">zi</span><span class="s3">, (-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n_sections</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)))</span>
    <span class="s1">sos </span><span class="s3">= </span><span class="s1">sos</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">_sosfilt</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">zi</span><span class="s3">)</span>
    <span class="s1">x</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">= </span><span class="s1">x_shape</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">return_zi</span><span class="s3">:</span>
        <span class="s1">zi</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">= </span><span class="s1">zi_shape</span>
        <span class="s1">zi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">zi</span><span class="s3">, [-</span><span class="s5">2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">], [</span><span class="s5">0</span><span class="s3">, </span><span class="s1">axis </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">])</span>
        <span class="s1">out </span><span class="s3">= (</span><span class="s1">x</span><span class="s3">, </span><span class="s1">zi</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">x</span>
    <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">sosfiltfilt</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">padtype</span><span class="s3">=</span><span class="s4">'odd'</span><span class="s3">, </span><span class="s1">padlen</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    A forward-backward digital filter using cascaded second-order sections. 
 
    See `filtfilt` for more complete information about this method. 
 
    Parameters 
    ---------- 
    sos : array_like 
        Array of second-order filter coefficients, must have shape 
        ``(n_sections, 6)``. Each row corresponds to a second-order 
        section, with the first three columns providing the numerator 
        coefficients and the last three providing the denominator 
        coefficients. 
    x : array_like 
        The array of data to be filtered. 
    axis : int, optional 
        The axis of `x` to which the filter is applied. 
        Default is -1. 
    padtype : str or None, optional 
        Must be 'odd', 'even', 'constant', or None.  This determines the 
        type of extension to use for the padded signal to which the filter 
        is applied.  If `padtype` is None, no padding is used.  The default 
        is 'odd'. 
    padlen : int or None, optional 
        The number of elements by which to extend `x` at both ends of 
        `axis` before applying the filter.  This value must be less than 
        ``x.shape[axis] - 1``.  ``padlen=0`` implies no padding. 
        The default value is:: 
 
            3 * (2 * len(sos) + 1 - min((sos[:, 2] == 0).sum(), 
                                        (sos[:, 5] == 0).sum())) 
 
        The extra subtraction at the end attempts to compensate for poles 
        and zeros at the origin (e.g. for odd-order filters) to yield 
        equivalent estimates of `padlen` to those of `filtfilt` for 
        second-order section filters built with `scipy.signal` functions. 
 
    Returns 
    ------- 
    y : ndarray 
        The filtered output with the same shape as `x`. 
 
    See Also 
    -------- 
    filtfilt, sosfilt, sosfilt_zi, sosfreqz 
 
    Notes 
    ----- 
    .. versionadded:: 0.18.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal import sosfiltfilt, butter 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; rng = np.random.default_rng() 
 
    Create an interesting signal to filter. 
 
    &gt;&gt;&gt; n = 201 
    &gt;&gt;&gt; t = np.linspace(0, 1, n) 
    &gt;&gt;&gt; x = 1 + (t &lt; 0.5) - 0.25*t**2 + 0.05*rng.standard_normal(n) 
 
    Create a lowpass Butterworth filter, and use it to filter `x`. 
 
    &gt;&gt;&gt; sos = butter(4, 0.125, output='sos') 
    &gt;&gt;&gt; y = sosfiltfilt(sos, x) 
 
    For comparison, apply an 8th order filter using `sosfilt`.  The filter 
    is initialized using the mean of the first four values of `x`. 
 
    &gt;&gt;&gt; from scipy.signal import sosfilt, sosfilt_zi 
    &gt;&gt;&gt; sos8 = butter(8, 0.125, output='sos') 
    &gt;&gt;&gt; zi = x[:4].mean() * sosfilt_zi(sos8) 
    &gt;&gt;&gt; y2, zo = sosfilt(sos8, x, zi=zi) 
 
    Plot the results.  Note that the phase of `y` matches the input, while 
    `y2` has a significant phase delay. 
 
    &gt;&gt;&gt; plt.plot(t, x, alpha=0.5, label='x(t)') 
    &gt;&gt;&gt; plt.plot(t, y, label='y(t)') 
    &gt;&gt;&gt; plt.plot(t, y2, label='y2(t)') 
    &gt;&gt;&gt; plt.legend(framealpha=1, shadow=True) 
    &gt;&gt;&gt; plt.grid(alpha=0.25) 
    &gt;&gt;&gt; plt.xlabel('t') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">sos</span><span class="s3">, </span><span class="s1">n_sections </span><span class="s3">= </span><span class="s1">_validate_sos</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">)</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">_validate_x</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

    <span class="s0"># `method` is &quot;pad&quot;...</span>
    <span class="s1">ntaps </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">n_sections </span><span class="s3">+ </span><span class="s5">1</span>
    <span class="s1">ntaps </span><span class="s3">-= </span><span class="s1">min</span><span class="s3">((</span><span class="s1">sos</span><span class="s3">[:, </span><span class="s5">2</span><span class="s3">] == </span><span class="s5">0</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">(), (</span><span class="s1">sos</span><span class="s3">[:, </span><span class="s5">5</span><span class="s3">] == </span><span class="s5">0</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">())</span>
    <span class="s1">edge</span><span class="s3">, </span><span class="s1">ext </span><span class="s3">= </span><span class="s1">_validate_pad</span><span class="s3">(</span><span class="s1">padtype</span><span class="s3">, </span><span class="s1">padlen</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">,</span>
                              <span class="s1">ntaps</span><span class="s3">=</span><span class="s1">ntaps</span><span class="s3">)</span>

    <span class="s0"># These steps follow the same form as filtfilt with modifications</span>
    <span class="s1">zi </span><span class="s3">= </span><span class="s1">sosfilt_zi</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">)  </span><span class="s0"># shape (n_sections, 2) --&gt; (n_sections, ..., 2, ...)</span>
    <span class="s1">zi_shape </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">] * </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim</span>
    <span class="s1">zi_shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s5">2</span>
    <span class="s1">zi</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">= [</span><span class="s1">n_sections</span><span class="s3">] + </span><span class="s1">zi_shape</span>
    <span class="s1">x_0 </span><span class="s3">= </span><span class="s1">axis_slice</span><span class="s3">(</span><span class="s1">ext</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">zf</span><span class="s3">) = </span><span class="s1">sosfilt</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">, </span><span class="s1">ext</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">zi</span><span class="s3">=</span><span class="s1">zi </span><span class="s3">* </span><span class="s1">x_0</span><span class="s3">)</span>
    <span class="s1">y_0 </span><span class="s3">= </span><span class="s1">axis_slice</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">zf</span><span class="s3">) = </span><span class="s1">sosfilt</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">, </span><span class="s1">axis_reverse</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">zi</span><span class="s3">=</span><span class="s1">zi </span><span class="s3">* </span><span class="s1">y_0</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">axis_reverse</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">edge </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">axis_slice</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">start</span><span class="s3">=</span><span class="s1">edge</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">=-</span><span class="s1">edge</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">y</span>


<span class="s2">def </span><span class="s1">decimate</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">ftype</span><span class="s3">=</span><span class="s4">'iir'</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">zero_phase</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Downsample the signal after applying an anti-aliasing filter. 
 
    By default, an order 8 Chebyshev type I filter is used. A 30 point FIR 
    filter with Hamming window is used if `ftype` is 'fir'. 
 
    Parameters 
    ---------- 
    x : array_like 
        The signal to be downsampled, as an N-dimensional array. 
    q : int 
        The downsampling factor. When using IIR downsampling, it is recommended 
        to call `decimate` multiple times for downsampling factors higher than 
        13. 
    n : int, optional 
        The order of the filter (1 less than the length for 'fir'). Defaults to 
        8 for 'iir' and 20 times the downsampling factor for 'fir'. 
    ftype : str {'iir', 'fir'} or ``dlti`` instance, optional 
        If 'iir' or 'fir', specifies the type of lowpass filter. If an instance 
        of an `dlti` object, uses that object to filter before downsampling. 
    axis : int, optional 
        The axis along which to decimate. 
    zero_phase : bool, optional 
        Prevent phase shift by filtering with `filtfilt` instead of `lfilter` 
        when using an IIR filter, and shifting the outputs back by the filter's 
        group delay when using an FIR filter. The default value of ``True`` is 
        recommended, since a phase shift is generally not desired. 
 
        .. versionadded:: 0.18.0 
 
    Returns 
    ------- 
    y : ndarray 
        The down-sampled signal. 
 
    See Also 
    -------- 
    resample : Resample up or down using the FFT method. 
    resample_poly : Resample using polyphase filtering and an FIR filter. 
 
    Notes 
    ----- 
    The ``zero_phase`` keyword was added in 0.18.0. 
    The possibility to use instances of ``dlti`` as ``ftype`` was added in 
    0.18.0. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    Define wave parameters. 
 
    &gt;&gt;&gt; wave_duration = 3 
    &gt;&gt;&gt; sample_rate = 100 
    &gt;&gt;&gt; freq = 2 
    &gt;&gt;&gt; q = 5 
 
    Calculate number of samples. 
 
    &gt;&gt;&gt; samples = wave_duration*sample_rate 
    &gt;&gt;&gt; samples_decimated = int(samples/q) 
 
    Create cosine wave. 
 
    &gt;&gt;&gt; x = np.linspace(0, wave_duration, samples, endpoint=False) 
    &gt;&gt;&gt; y = np.cos(x*np.pi*freq*2) 
 
    Decimate cosine wave. 
 
    &gt;&gt;&gt; ydem = signal.decimate(y, q) 
    &gt;&gt;&gt; xnew = np.linspace(0, wave_duration, samples_decimated, endpoint=False) 
 
    Plot original and decimated waves. 
 
    &gt;&gt;&gt; plt.plot(x, y, '.-', xnew, ydem, 'o-') 
    &gt;&gt;&gt; plt.xlabel('Time, Seconds') 
    &gt;&gt;&gt; plt.legend(['data', 'decimated'], loc='best') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>

    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">q </span><span class="s3">= </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">q</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">n </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">operator</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>

    <span class="s1">result_type </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">result_type</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inexact</span><span class="s3">) </span><span class="s1">\</span>
       <span class="s2">or </span><span class="s1">result_type</span><span class="s3">.</span><span class="s1">type </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float16</span><span class="s3">:</span>
        <span class="s0"># upcast integers and float16 to float64</span>
        <span class="s1">result_type </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span>

    <span class="s2">if </span><span class="s1">ftype </span><span class="s3">== </span><span class="s4">'fir'</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">half_len </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">* </span><span class="s1">q  </span><span class="s0"># reasonable cutoff for our sinc-like function</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">half_len</span>
        <span class="s1">b</span><span class="s3">, </span><span class="s1">a </span><span class="s3">= </span><span class="s1">firwin</span><span class="s3">(</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1. </span><span class="s3">/ </span><span class="s1">q</span><span class="s3">, </span><span class="s1">window</span><span class="s3">=</span><span class="s4">'hamming'</span><span class="s3">), </span><span class="s5">1.</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">result_type</span><span class="s3">)</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">result_type</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">ftype </span><span class="s3">== </span><span class="s4">'iir'</span><span class="s3">:</span>
        <span class="s1">iir_use_sos </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">n </span><span class="s3">= </span><span class="s5">8</span>
        <span class="s1">sos </span><span class="s3">= </span><span class="s1">cheby1</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s5">0.05</span><span class="s3">, </span><span class="s5">0.8 </span><span class="s3">/ </span><span class="s1">q</span><span class="s3">, </span><span class="s1">output</span><span class="s3">=</span><span class="s4">'sos'</span><span class="s3">)</span>
        <span class="s1">sos </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">result_type</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ftype</span><span class="s3">, </span><span class="s1">dlti</span><span class="s3">):</span>
        <span class="s1">system </span><span class="s3">= </span><span class="s1">ftype</span><span class="s3">.</span><span class="s1">_as_zpk</span><span class="s3">()</span>
        <span class="s2">if </span><span class="s1">system</span><span class="s3">.</span><span class="s1">poles</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s5">0</span><span class="s3">:</span>
            <span class="s0"># FIR</span>
            <span class="s1">system </span><span class="s3">= </span><span class="s1">ftype</span><span class="s3">.</span><span class="s1">_as_tf</span><span class="s3">()</span>
            <span class="s1">b</span><span class="s3">, </span><span class="s1">a </span><span class="s3">= </span><span class="s1">system</span><span class="s3">.</span><span class="s1">num</span><span class="s3">, </span><span class="s1">system</span><span class="s3">.</span><span class="s1">den</span>
            <span class="s1">ftype </span><span class="s3">= </span><span class="s4">'fir'</span>
        <span class="s2">elif </span><span class="s3">(</span><span class="s1">any</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplex</span><span class="s3">(</span><span class="s1">system</span><span class="s3">.</span><span class="s1">poles</span><span class="s3">))</span>
              <span class="s2">or </span><span class="s1">any</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplex</span><span class="s3">(</span><span class="s1">system</span><span class="s3">.</span><span class="s1">poles</span><span class="s3">))</span>
              <span class="s2">or </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplex</span><span class="s3">(</span><span class="s1">system</span><span class="s3">.</span><span class="s1">gain</span><span class="s3">)):</span>
            <span class="s0"># sosfilt &amp; sosfiltfilt don't handle complex coeffs</span>
            <span class="s1">iir_use_sos </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s1">system </span><span class="s3">= </span><span class="s1">ftype</span><span class="s3">.</span><span class="s1">_as_tf</span><span class="s3">()</span>
            <span class="s1">b</span><span class="s3">, </span><span class="s1">a </span><span class="s3">= </span><span class="s1">system</span><span class="s3">.</span><span class="s1">num</span><span class="s3">, </span><span class="s1">system</span><span class="s3">.</span><span class="s1">den</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">iir_use_sos </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s1">sos </span><span class="s3">= </span><span class="s1">zpk2sos</span><span class="s3">(</span><span class="s1">system</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">, </span><span class="s1">system</span><span class="s3">.</span><span class="s1">poles</span><span class="s3">, </span><span class="s1">system</span><span class="s3">.</span><span class="s1">gain</span><span class="s3">)</span>
            <span class="s1">sos </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">result_type</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'invalid ftype'</span><span class="s3">)</span>

    <span class="s1">sl </span><span class="s3">= [</span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)] * </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim</span>

    <span class="s2">if </span><span class="s1">ftype </span><span class="s3">== </span><span class="s4">'fir'</span><span class="s3">:</span>
        <span class="s1">b </span><span class="s3">= </span><span class="s1">b </span><span class="s3">/ </span><span class="s1">a</span>
        <span class="s2">if </span><span class="s1">zero_phase</span><span class="s3">:</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s1">resample_poly</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">window</span><span class="s3">=</span><span class="s1">b</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># upfirdn is generally faster than lfilter by a factor equal to the</span>
            <span class="s0"># downsampling factor, since it only calculates the needed outputs</span>
            <span class="s1">n_out </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] // </span><span class="s1">q </span><span class="s3">+ </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] % </span><span class="s1">q</span><span class="s3">)</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s1">upfirdn</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">up</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">down</span><span class="s3">=</span><span class="s1">q</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
            <span class="s1">sl</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">n_out</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>

    <span class="s2">else</span><span class="s3">:  </span><span class="s0"># IIR case</span>
        <span class="s2">if </span><span class="s1">zero_phase</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">iir_use_sos</span><span class="s3">:</span>
                <span class="s1">y </span><span class="s3">= </span><span class="s1">sosfiltfilt</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">y </span><span class="s3">= </span><span class="s1">filtfilt</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">iir_use_sos</span><span class="s3">:</span>
                <span class="s1">y </span><span class="s3">= </span><span class="s1">sosfilt</span><span class="s3">(</span><span class="s1">sos</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">y </span><span class="s3">= </span><span class="s1">lfilter</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>

        <span class="s1">sl</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">slice</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">q</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">y</span><span class="s3">[</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">sl</span><span class="s3">)]</span>
</pre>
</body>
</html>