<html>
<head>
<title>_memmapping_reducer.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_memmapping_reducer.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Reducer using memory mapping for numpy arrays 
&quot;&quot;&quot;</span>
<span class="s2"># Author: Thomas Moreau &lt;thomas.moreau.2010@gmail.com&gt;</span>
<span class="s2"># Copyright: 2017, Thomas Moreau</span>
<span class="s2"># License: BSD 3 clause</span>

<span class="s3">from </span><span class="s1">mmap </span><span class="s3">import </span><span class="s1">mmap</span>
<span class="s3">import </span><span class="s1">errno</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">stat</span>
<span class="s3">import </span><span class="s1">threading</span>
<span class="s3">import </span><span class="s1">atexit</span>
<span class="s3">import </span><span class="s1">tempfile</span>
<span class="s3">import </span><span class="s1">time</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">import </span><span class="s1">weakref</span>
<span class="s3">from </span><span class="s1">uuid </span><span class="s3">import </span><span class="s1">uuid4</span>
<span class="s3">from </span><span class="s1">multiprocessing </span><span class="s3">import </span><span class="s1">util</span>

<span class="s3">from </span><span class="s1">pickle </span><span class="s3">import </span><span class="s1">whichmodule</span><span class="s4">, </span><span class="s1">loads</span><span class="s4">, </span><span class="s1">dumps</span><span class="s4">, </span><span class="s1">HIGHEST_PROTOCOL</span><span class="s4">, </span><span class="s1">PicklingError</span>

<span class="s3">try</span><span class="s4">:</span>
    <span class="s1">WindowsError</span>
<span class="s3">except </span><span class="s1">NameError</span><span class="s4">:</span>
    <span class="s1">WindowsError </span><span class="s4">= </span><span class="s1">type</span><span class="s4">(</span><span class="s3">None</span><span class="s4">)</span>

<span class="s3">try</span><span class="s4">:</span>
    <span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
    <span class="s3">from </span><span class="s1">numpy</span><span class="s4">.</span><span class="s1">lib</span><span class="s4">.</span><span class="s1">stride_tricks </span><span class="s3">import </span><span class="s1">as_strided</span>
<span class="s3">except </span><span class="s1">ImportError</span><span class="s4">:</span>
    <span class="s1">np </span><span class="s4">= </span><span class="s3">None</span>

<span class="s3">from </span><span class="s4">.</span><span class="s1">numpy_pickle </span><span class="s3">import </span><span class="s1">dump</span><span class="s4">, </span><span class="s1">load</span><span class="s4">, </span><span class="s1">load_temporary_memmap</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">backports </span><span class="s3">import </span><span class="s1">make_memmap</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">disk </span><span class="s3">import </span><span class="s1">delete_folder</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">externals</span><span class="s4">.</span><span class="s1">loky</span><span class="s4">.</span><span class="s1">backend </span><span class="s3">import </span><span class="s1">resource_tracker</span>

<span class="s2"># Some system have a ramdisk mounted by default, we can use it instead of /tmp</span>
<span class="s2"># as the default folder to dump big arrays to share with subprocesses.</span>
<span class="s1">SYSTEM_SHARED_MEM_FS </span><span class="s4">= </span><span class="s5">'/dev/shm'</span>

<span class="s2"># Minimal number of bytes available on SYSTEM_SHARED_MEM_FS to consider using</span>
<span class="s2"># it as the default folder to dump big arrays to share with subprocesses.</span>
<span class="s1">SYSTEM_SHARED_MEM_FS_MIN_SIZE </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s6">2e9</span><span class="s4">)</span>

<span class="s2"># Folder and file permissions to chmod temporary files generated by the</span>
<span class="s2"># memmapping pool. Only the owner of the Python process can access the</span>
<span class="s2"># temporary files and folder.</span>
<span class="s1">FOLDER_PERMISSIONS </span><span class="s4">= </span><span class="s1">stat</span><span class="s4">.</span><span class="s1">S_IRUSR </span><span class="s4">| </span><span class="s1">stat</span><span class="s4">.</span><span class="s1">S_IWUSR </span><span class="s4">| </span><span class="s1">stat</span><span class="s4">.</span><span class="s1">S_IXUSR</span>
<span class="s1">FILE_PERMISSIONS </span><span class="s4">= </span><span class="s1">stat</span><span class="s4">.</span><span class="s1">S_IRUSR </span><span class="s4">| </span><span class="s1">stat</span><span class="s4">.</span><span class="s1">S_IWUSR</span>

<span class="s2"># Set used in joblib workers, referencing the filenames of temporary memmaps</span>
<span class="s2"># created by joblib to speed up data communication. In child processes, we add</span>
<span class="s2"># a finalizer to these memmaps that sends a maybe_unlink call to the</span>
<span class="s2"># resource_tracker, in order to free main memory as fast as possible.</span>
<span class="s1">JOBLIB_MMAPS </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()</span>


<span class="s3">def </span><span class="s1">_log_and_unlink</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">):</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">externals</span><span class="s4">.</span><span class="s1">loky</span><span class="s4">.</span><span class="s1">backend</span><span class="s4">.</span><span class="s1">resource_tracker </span><span class="s3">import </span><span class="s1">_resource_tracker</span>
    <span class="s1">util</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span>
        <span class="s5">&quot;[FINALIZER CALL] object mapping to {} about to be deleted,&quot;</span>
        <span class="s5">&quot; decrementing the refcount of the file (pid: {})&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span>
            <span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">basename</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">), </span><span class="s1">os</span><span class="s4">.</span><span class="s1">getpid</span><span class="s4">()))</span>
    <span class="s1">_resource_tracker</span><span class="s4">.</span><span class="s1">maybe_unlink</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">, </span><span class="s5">&quot;file&quot;</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">add_maybe_unlink_finalizer</span><span class="s4">(</span><span class="s1">memmap</span><span class="s4">):</span>
    <span class="s1">util</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span>
        <span class="s5">&quot;[FINALIZER ADD] adding finalizer to {} (id {}, filename {}, pid  {})&quot;</span>
        <span class="s5">&quot;&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">type</span><span class="s4">(</span><span class="s1">memmap</span><span class="s4">), </span><span class="s1">id</span><span class="s4">(</span><span class="s1">memmap</span><span class="s4">), </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">basename</span><span class="s4">(</span><span class="s1">memmap</span><span class="s4">.</span><span class="s1">filename</span><span class="s4">),</span>
                  <span class="s1">os</span><span class="s4">.</span><span class="s1">getpid</span><span class="s4">()))</span>
    <span class="s1">weakref</span><span class="s4">.</span><span class="s1">finalize</span><span class="s4">(</span><span class="s1">memmap</span><span class="s4">, </span><span class="s1">_log_and_unlink</span><span class="s4">, </span><span class="s1">memmap</span><span class="s4">.</span><span class="s1">filename</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">unlink_file</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Wrapper around os.unlink with a retry mechanism. 
 
    The retry mechanism has been implemented primarily to overcome a race 
    condition happening during the finalizer of a np.memmap: when a process 
    holding the last reference to a mmap-backed np.memmap/np.array is about to 
    delete this array (and close the reference), it sends a maybe_unlink 
    request to the resource_tracker. This request can be processed faster than 
    it takes for the last reference of the memmap to be closed, yielding (on 
    Windows) a PermissionError in the resource_tracker loop. 
    &quot;&quot;&quot;</span>
    <span class="s1">NUM_RETRIES </span><span class="s4">= </span><span class="s6">10</span>
    <span class="s3">for </span><span class="s1">retry_no </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">NUM_RETRIES </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">):</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">os</span><span class="s4">.</span><span class="s1">unlink</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">)</span>
            <span class="s3">break</span>
        <span class="s3">except </span><span class="s1">PermissionError</span><span class="s4">:</span>
            <span class="s1">util</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span>
                <span class="s5">'[ResourceTracker] tried to unlink {}, got '</span>
                <span class="s5">'PermissionError'</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s3">if </span><span class="s1">retry_no </span><span class="s4">== </span><span class="s1">NUM_RETRIES</span><span class="s4">:</span>
                <span class="s3">raise</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">time</span><span class="s4">.</span><span class="s1">sleep</span><span class="s4">(</span><span class="s6">.2</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">FileNotFoundError</span><span class="s4">:</span>
            <span class="s2"># In case of a race condition when deleting the temporary folder,</span>
            <span class="s2"># avoid noisy FileNotFoundError exception in the resource tracker.</span>
            <span class="s3">pass</span>


<span class="s1">resource_tracker</span><span class="s4">.</span><span class="s1">_CLEANUP_FUNCS</span><span class="s4">[</span><span class="s5">'file'</span><span class="s4">] = </span><span class="s1">unlink_file</span>


<span class="s3">class </span><span class="s1">_WeakArrayKeyMap</span><span class="s4">:</span>
    <span class="s0">&quot;&quot;&quot;A variant of weakref.WeakKeyDictionary for unhashable numpy arrays. 
 
    This datastructure will be used with numpy arrays as obj keys, therefore we 
    do not use the __get__ / __set__ methods to avoid any conflict with the 
    numpy fancy indexing syntax. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_data </span><span class="s4">= {}</span>

    <span class="s3">def </span><span class="s1">get</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">):</span>
        <span class="s1">ref</span><span class="s4">, </span><span class="s1">val </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_data</span><span class="s4">[</span><span class="s1">id</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)]</span>
        <span class="s3">if </span><span class="s1">ref</span><span class="s4">() </span><span class="s3">is not </span><span class="s1">obj</span><span class="s4">:</span>
            <span class="s2"># In case of race condition with on_destroy: could never be</span>
            <span class="s2"># triggered by the joblib tests with CPython.</span>
            <span class="s3">raise </span><span class="s1">KeyError</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">val</span>

    <span class="s3">def </span><span class="s1">set</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s1">key </span><span class="s4">= </span><span class="s1">id</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">ref</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_data</span><span class="s4">[</span><span class="s1">key</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">ref</span><span class="s4">() </span><span class="s3">is not </span><span class="s1">obj</span><span class="s4">:</span>
                <span class="s2"># In case of race condition with on_destroy: could never be</span>
                <span class="s2"># triggered by the joblib tests with CPython.</span>
                <span class="s3">raise </span><span class="s1">KeyError</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">KeyError</span><span class="s4">:</span>
            <span class="s2"># Insert the new entry in the mapping along with a weakref</span>
            <span class="s2"># callback to automatically delete the entry from the mapping</span>
            <span class="s2"># as soon as the object used as key is garbage collected.</span>
            <span class="s3">def </span><span class="s1">on_destroy</span><span class="s4">(</span><span class="s1">_</span><span class="s4">):</span>
                <span class="s3">del </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_data</span><span class="s4">[</span><span class="s1">key</span><span class="s4">]</span>
            <span class="s1">ref </span><span class="s4">= </span><span class="s1">weakref</span><span class="s4">.</span><span class="s1">ref</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">on_destroy</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_data</span><span class="s4">[</span><span class="s1">key</span><span class="s4">] = </span><span class="s1">ref</span><span class="s4">, </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">__getstate__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">PicklingError</span><span class="s4">(</span><span class="s5">&quot;_WeakArrayKeyMap is not pickleable&quot;</span><span class="s4">)</span>


<span class="s2">###############################################################################</span>
<span class="s2"># Support for efficient transient pickling of numpy data structures</span>


<span class="s3">def </span><span class="s1">_get_backing_memmap</span><span class="s4">(</span><span class="s1">a</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Recursively look up the original np.memmap instance base if any.&quot;&quot;&quot;</span>
    <span class="s1">b </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s5">'base'</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">b </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s2"># TODO: check scipy sparse datastructure if scipy is installed</span>
        <span class="s2"># a nor its descendants do not have a memmap base</span>
        <span class="s3">return None</span>

    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">b</span><span class="s4">, </span><span class="s1">mmap</span><span class="s4">):</span>
        <span class="s2"># a is already a real memmap instance.</span>
        <span class="s3">return </span><span class="s1">a</span>

    <span class="s3">else</span><span class="s4">:</span>
        <span class="s2"># Recursive exploration of the base ancestry</span>
        <span class="s3">return </span><span class="s1">_get_backing_memmap</span><span class="s4">(</span><span class="s1">b</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_get_temp_dir</span><span class="s4">(</span><span class="s1">pool_folder_name</span><span class="s4">, </span><span class="s1">temp_folder</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Get the full path to a subfolder inside the temporary folder. 
 
    Parameters 
    ---------- 
    pool_folder_name : str 
        Sub-folder name used for the serialization of a pool instance. 
 
    temp_folder: str, optional 
        Folder to be used by the pool for memmapping large arrays 
        for sharing memory with worker processes. If None, this will try in 
        order: 
 
        - a folder pointed by the JOBLIB_TEMP_FOLDER environment 
          variable, 
        - /dev/shm if the folder exists and is writable: this is a 
          RAMdisk filesystem available by default on modern Linux 
          distributions, 
        - the default system temporary folder that can be 
          overridden with TMP, TMPDIR or TEMP environment 
          variables, typically /tmp under Unix operating systems. 
 
    Returns 
    ------- 
    pool_folder : str 
       full path to the temporary folder 
    use_shared_mem : bool 
       whether the temporary folder is written to the system shared memory 
       folder or some other temporary folder. 
    &quot;&quot;&quot;</span>
    <span class="s1">use_shared_mem </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s3">if </span><span class="s1">temp_folder </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">temp_folder </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">environ</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">'JOBLIB_TEMP_FOLDER'</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">temp_folder </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">exists</span><span class="s4">(</span><span class="s1">SYSTEM_SHARED_MEM_FS</span><span class="s4">) </span><span class="s3">and </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">os</span><span class="s4">, </span><span class="s5">'statvfs'</span><span class="s4">):</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">shm_stats </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">statvfs</span><span class="s4">(</span><span class="s1">SYSTEM_SHARED_MEM_FS</span><span class="s4">)</span>
                <span class="s1">available_nbytes </span><span class="s4">= </span><span class="s1">shm_stats</span><span class="s4">.</span><span class="s1">f_bsize </span><span class="s4">* </span><span class="s1">shm_stats</span><span class="s4">.</span><span class="s1">f_bavail</span>
                <span class="s3">if </span><span class="s1">available_nbytes </span><span class="s4">&gt; </span><span class="s1">SYSTEM_SHARED_MEM_FS_MIN_SIZE</span><span class="s4">:</span>
                    <span class="s2"># Try to see if we have write access to the shared mem</span>
                    <span class="s2"># folder only if it is reasonably large (that is 2GB or</span>
                    <span class="s2"># more).</span>
                    <span class="s1">temp_folder </span><span class="s4">= </span><span class="s1">SYSTEM_SHARED_MEM_FS</span>
                    <span class="s1">pool_folder </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">temp_folder</span><span class="s4">, </span><span class="s1">pool_folder_name</span><span class="s4">)</span>
                    <span class="s3">if not </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">exists</span><span class="s4">(</span><span class="s1">pool_folder</span><span class="s4">):</span>
                        <span class="s1">os</span><span class="s4">.</span><span class="s1">makedirs</span><span class="s4">(</span><span class="s1">pool_folder</span><span class="s4">)</span>
                    <span class="s1">use_shared_mem </span><span class="s4">= </span><span class="s3">True</span>
            <span class="s3">except </span><span class="s4">(</span><span class="s1">IOError</span><span class="s4">, </span><span class="s1">OSError</span><span class="s4">):</span>
                <span class="s2"># Missing rights in the /dev/shm partition, fallback to regular</span>
                <span class="s2"># temp folder.</span>
                <span class="s1">temp_folder </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">temp_folder </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s2"># Fallback to the default tmp folder, typically /tmp</span>
        <span class="s1">temp_folder </span><span class="s4">= </span><span class="s1">tempfile</span><span class="s4">.</span><span class="s1">gettempdir</span><span class="s4">()</span>
    <span class="s1">temp_folder </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">abspath</span><span class="s4">(</span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">expanduser</span><span class="s4">(</span><span class="s1">temp_folder</span><span class="s4">))</span>
    <span class="s1">pool_folder </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">temp_folder</span><span class="s4">, </span><span class="s1">pool_folder_name</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">pool_folder</span><span class="s4">, </span><span class="s1">use_shared_mem</span>


<span class="s3">def </span><span class="s1">has_shareable_memory</span><span class="s4">(</span><span class="s1">a</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Return True if a is backed by some mmap buffer directly or not.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_get_backing_memmap</span><span class="s4">(</span><span class="s1">a</span><span class="s4">) </span><span class="s3">is not None</span>


<span class="s3">def </span><span class="s1">_strided_from_memmap</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">mode</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">, </span><span class="s1">order</span><span class="s4">, </span><span class="s1">shape</span><span class="s4">, </span><span class="s1">strides</span><span class="s4">,</span>
                         <span class="s1">total_buffer_len</span><span class="s4">, </span><span class="s1">unlink_on_gc_collect</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Reconstruct an array view on a memory mapped file.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">mode </span><span class="s4">== </span><span class="s5">'w+'</span><span class="s4">:</span>
        <span class="s2"># Do not zero the original data when unpickling</span>
        <span class="s1">mode </span><span class="s4">= </span><span class="s5">'r+'</span>

    <span class="s3">if </span><span class="s1">strides </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s2"># Simple, contiguous memmap</span>
        <span class="s3">return </span><span class="s1">make_memmap</span><span class="s4">(</span>
            <span class="s1">filename</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">shape</span><span class="s4">=</span><span class="s1">shape</span><span class="s4">, </span><span class="s1">mode</span><span class="s4">=</span><span class="s1">mode</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">=</span><span class="s1">offset</span><span class="s4">,</span>
            <span class="s1">order</span><span class="s4">=</span><span class="s1">order</span><span class="s4">, </span><span class="s1">unlink_on_gc_collect</span><span class="s4">=</span><span class="s1">unlink_on_gc_collect</span>
        <span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s2"># For non-contiguous data, memmap the total enclosing buffer and then</span>
        <span class="s2"># extract the non-contiguous view with the stride-tricks API</span>
        <span class="s1">base </span><span class="s4">= </span><span class="s1">make_memmap</span><span class="s4">(</span>
            <span class="s1">filename</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">shape</span><span class="s4">=</span><span class="s1">total_buffer_len</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">=</span><span class="s1">offset</span><span class="s4">,</span>
            <span class="s1">mode</span><span class="s4">=</span><span class="s1">mode</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s1">order</span><span class="s4">, </span><span class="s1">unlink_on_gc_collect</span><span class="s4">=</span><span class="s1">unlink_on_gc_collect</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">as_strided</span><span class="s4">(</span><span class="s1">base</span><span class="s4">, </span><span class="s1">shape</span><span class="s4">=</span><span class="s1">shape</span><span class="s4">, </span><span class="s1">strides</span><span class="s4">=</span><span class="s1">strides</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_reduce_memmap_backed</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">m</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Pickling reduction for memmap backed arrays. 
 
    a is expected to be an instance of np.ndarray (or np.memmap) 
    m is expected to be an instance of np.memmap on the top of the ``base`` 
    attribute ancestry of a. ``m.base`` should be the real python mmap object. 
    &quot;&quot;&quot;</span>
    <span class="s2"># offset that comes from the striding differences between a and m</span>
    <span class="s1">util</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span><span class="s5">'[MEMMAP REDUCE] reducing a memmap-backed array '</span>
               <span class="s5">'(shape, {}, pid: {})'</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">a</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">, </span><span class="s1">os</span><span class="s4">.</span><span class="s1">getpid</span><span class="s4">()))</span>
    <span class="s3">try</span><span class="s4">:</span>
        <span class="s3">from </span><span class="s1">numpy</span><span class="s4">.</span><span class="s1">lib</span><span class="s4">.</span><span class="s1">array_utils </span><span class="s3">import </span><span class="s1">byte_bounds</span>
    <span class="s3">except </span><span class="s4">(</span><span class="s1">ModuleNotFoundError</span><span class="s4">, </span><span class="s1">ImportError</span><span class="s4">):</span>
        <span class="s2"># Backward-compat for numpy &lt; 2.0</span>
        <span class="s3">from </span><span class="s1">numpy </span><span class="s3">import </span><span class="s1">byte_bounds</span>
    <span class="s1">a_start</span><span class="s4">, </span><span class="s1">a_end </span><span class="s4">= </span><span class="s1">byte_bounds</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
    <span class="s1">m_start </span><span class="s4">= </span><span class="s1">byte_bounds</span><span class="s4">(</span><span class="s1">m</span><span class="s4">)[</span><span class="s6">0</span><span class="s4">]</span>
    <span class="s1">offset </span><span class="s4">= </span><span class="s1">a_start </span><span class="s4">- </span><span class="s1">m_start</span>

    <span class="s2"># offset from the backing memmap</span>
    <span class="s1">offset </span><span class="s4">+= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">offset</span>

    <span class="s3">if </span><span class="s1">m</span><span class="s4">.</span><span class="s1">flags</span><span class="s4">[</span><span class="s5">'F_CONTIGUOUS'</span><span class="s4">]:</span>
        <span class="s1">order </span><span class="s4">= </span><span class="s5">'F'</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s2"># The backing memmap buffer is necessarily contiguous hence C if not</span>
        <span class="s2"># Fortran</span>
        <span class="s1">order </span><span class="s4">= </span><span class="s5">'C'</span>

    <span class="s3">if </span><span class="s1">a</span><span class="s4">.</span><span class="s1">flags</span><span class="s4">[</span><span class="s5">'F_CONTIGUOUS'</span><span class="s4">] </span><span class="s3">or </span><span class="s1">a</span><span class="s4">.</span><span class="s1">flags</span><span class="s4">[</span><span class="s5">'C_CONTIGUOUS'</span><span class="s4">]:</span>
        <span class="s2"># If the array is a contiguous view, no need to pass the strides</span>
        <span class="s1">strides </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">total_buffer_len </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s2"># Compute the total number of items to map from which the strided</span>
        <span class="s2"># view will be extracted.</span>
        <span class="s1">strides </span><span class="s4">= </span><span class="s1">a</span><span class="s4">.</span><span class="s1">strides</span>
        <span class="s1">total_buffer_len </span><span class="s4">= (</span><span class="s1">a_end </span><span class="s4">- </span><span class="s1">a_start</span><span class="s4">) // </span><span class="s1">a</span><span class="s4">.</span><span class="s1">itemsize</span>

    <span class="s3">return </span><span class="s4">(</span><span class="s1">_strided_from_memmap</span><span class="s4">,</span>
            <span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">filename</span><span class="s4">, </span><span class="s1">a</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">m</span><span class="s4">.</span><span class="s1">mode</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">, </span><span class="s1">order</span><span class="s4">, </span><span class="s1">a</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">, </span><span class="s1">strides</span><span class="s4">,</span>
             <span class="s1">total_buffer_len</span><span class="s4">, </span><span class="s3">False</span><span class="s4">))</span>


<span class="s3">def </span><span class="s1">reduce_array_memmap_backward</span><span class="s4">(</span><span class="s1">a</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;reduce a np.array or a np.memmap from a child process&quot;&quot;&quot;</span>
    <span class="s1">m </span><span class="s4">= </span><span class="s1">_get_backing_memmap</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">memmap</span><span class="s4">) </span><span class="s3">and </span><span class="s1">m</span><span class="s4">.</span><span class="s1">filename </span><span class="s3">not in </span><span class="s1">JOBLIB_MMAPS</span><span class="s4">:</span>
        <span class="s2"># if a is backed by a memmaped file, reconstruct a using the</span>
        <span class="s2"># memmaped file.</span>
        <span class="s3">return </span><span class="s1">_reduce_memmap_backed</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">m</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s2"># a is either a regular (not memmap-backed) numpy array, or an array</span>
        <span class="s2"># backed by a shared temporary file created by joblib. In the latter</span>
        <span class="s2"># case, in order to limit the lifespan of these temporary files, we</span>
        <span class="s2"># serialize the memmap as a regular numpy array, and decref the</span>
        <span class="s2"># file backing the memmap (done implicitly in a previously registered</span>
        <span class="s2"># finalizer, see ``unlink_on_gc_collect`` for more details)</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">loads</span><span class="s4">, (</span><span class="s1">dumps</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">a</span><span class="s4">), </span><span class="s1">protocol</span><span class="s4">=</span><span class="s1">HIGHEST_PROTOCOL</span><span class="s4">), )</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">ArrayMemmapForwardReducer</span><span class="s4">(</span><span class="s1">object</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Reducer callable to dump large arrays to memmap files. 
 
    Parameters 
    ---------- 
    max_nbytes: int 
        Threshold to trigger memmapping of large arrays to files created 
        a folder. 
    temp_folder_resolver: callable 
        An callable in charge of resolving a temporary folder name where files 
        for backing memmapped arrays are created. 
    mmap_mode: 'r', 'r+' or 'c' 
        Mode for the created memmap datastructure. See the documentation of 
        numpy.memmap for more details. Note: 'w+' is coerced to 'r+' 
        automatically to avoid zeroing the data on unpickling. 
    verbose: int, optional, 0 by default 
        If verbose &gt; 0, memmap creations are logged. 
        If verbose &gt; 1, both memmap creations, reuse and array pickling are 
        logged. 
    prewarm: bool, optional, False by default. 
        Force a read on newly memmapped array to make sure that OS pre-cache it 
        memory. This can be useful to avoid concurrent disk access when the 
        same data array is passed to different worker processes. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">max_nbytes</span><span class="s4">, </span><span class="s1">temp_folder_resolver</span><span class="s4">, </span><span class="s1">mmap_mode</span><span class="s4">,</span>
                 <span class="s1">unlink_on_gc_collect</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s6">0</span><span class="s4">, </span><span class="s1">prewarm</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_max_nbytes </span><span class="s4">= </span><span class="s1">max_nbytes</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_temp_folder_resolver </span><span class="s4">= </span><span class="s1">temp_folder_resolver</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_mmap_mode </span><span class="s4">= </span><span class="s1">mmap_mode</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">verbose </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">verbose</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">prewarm </span><span class="s4">== </span><span class="s5">&quot;auto&quot;</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_prewarm </span><span class="s4">= </span><span class="s3">not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_temp_folder</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span>
                <span class="s1">SYSTEM_SHARED_MEM_FS</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_prewarm </span><span class="s4">= </span><span class="s1">prewarm</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_prewarm </span><span class="s4">= </span><span class="s1">prewarm</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_memmaped_arrays </span><span class="s4">= </span><span class="s1">_WeakArrayKeyMap</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_temporary_memmaped_filenames </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_unlink_on_gc_collect </span><span class="s4">= </span><span class="s1">unlink_on_gc_collect</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_temp_folder</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_temp_folder_resolver</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">__reduce__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2"># The ArrayMemmapForwardReducer is passed to the children processes: it</span>
        <span class="s2"># needs to be pickled but the _WeakArrayKeyMap need to be skipped as</span>
        <span class="s2"># it's only guaranteed to be consistent with the parent process memory</span>
        <span class="s2"># garbage collection.</span>
        <span class="s2"># Although this reducer is pickled, it is not needed in its destination</span>
        <span class="s2"># process (child processes), as we only use this reducer to send</span>
        <span class="s2"># memmaps from the parent process to the children processes. For this</span>
        <span class="s2"># reason, we can afford skipping the resolver, (which would otherwise</span>
        <span class="s2"># be unpicklable), and pass it as None instead.</span>
        <span class="s1">args </span><span class="s4">= (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_max_nbytes</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_mmap_mode</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_unlink_on_gc_collect</span><span class="s4">)</span>
        <span class="s1">kwargs </span><span class="s4">= {</span>
            <span class="s5">'verbose'</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose</span><span class="s4">,</span>
            <span class="s5">'prewarm'</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prewarm</span><span class="s4">,</span>
        <span class="s4">}</span>
        <span class="s3">return </span><span class="s1">ArrayMemmapForwardReducer</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">kwargs</span>

    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">a</span><span class="s4">):</span>
        <span class="s1">m </span><span class="s4">= </span><span class="s1">_get_backing_memmap</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">m </span><span class="s3">is not None and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">memmap</span><span class="s4">):</span>
            <span class="s2"># a is already backed by a memmap file, let's reuse it directly</span>
            <span class="s3">return </span><span class="s1">_reduce_memmap_backed</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">m</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s4">(</span><span class="s3">not </span><span class="s1">a</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">.</span><span class="s1">hasobject </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_max_nbytes </span><span class="s3">is not None and</span>
                <span class="s1">a</span><span class="s4">.</span><span class="s1">nbytes </span><span class="s4">&gt; </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_max_nbytes</span><span class="s4">):</span>
            <span class="s2"># check that the folder exists (lazily create the pool temp folder</span>
            <span class="s2"># if required)</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">os</span><span class="s4">.</span><span class="s1">makedirs</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_temp_folder</span><span class="s4">)</span>
                <span class="s1">os</span><span class="s4">.</span><span class="s1">chmod</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_temp_folder</span><span class="s4">, </span><span class="s1">FOLDER_PERMISSIONS</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">e</span><span class="s4">.</span><span class="s1">errno </span><span class="s4">!= </span><span class="s1">errno</span><span class="s4">.</span><span class="s1">EEXIST</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">e</span>

            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">basename </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_memmaped_arrays</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s1">KeyError</span><span class="s4">:</span>
                <span class="s2"># Generate a new unique random filename. The process and thread</span>
                <span class="s2"># ids are only useful for debugging purpose and to make it</span>
                <span class="s2"># easier to cleanup orphaned files in case of hard process</span>
                <span class="s2"># kill (e.g. by &quot;kill -9&quot; or segfault).</span>
                <span class="s1">basename </span><span class="s4">= </span><span class="s5">&quot;{}-{}-{}.pkl&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span>
                    <span class="s1">os</span><span class="s4">.</span><span class="s1">getpid</span><span class="s4">(), </span><span class="s1">id</span><span class="s4">(</span><span class="s1">threading</span><span class="s4">.</span><span class="s1">current_thread</span><span class="s4">()), </span><span class="s1">uuid4</span><span class="s4">().</span><span class="s1">hex</span><span class="s4">)</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_memmaped_arrays</span><span class="s4">.</span><span class="s1">set</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">basename</span><span class="s4">)</span>
            <span class="s1">filename </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_temp_folder</span><span class="s4">, </span><span class="s1">basename</span><span class="s4">)</span>

            <span class="s2"># In case the same array with the same content is passed several</span>
            <span class="s2"># times to the pool subprocess children, serialize it only once</span>

            <span class="s1">is_new_memmap </span><span class="s4">= </span><span class="s1">filename </span><span class="s3">not in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_temporary_memmaped_filenames</span>

            <span class="s2"># add the memmap to the list of temporary memmaps created by joblib</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_temporary_memmaped_filenames</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_unlink_on_gc_collect</span><span class="s4">:</span>
                <span class="s2"># Bump reference count of the memmap by 1 to account for</span>
                <span class="s2"># shared usage of the memmap by a child process. The</span>
                <span class="s2"># corresponding decref call will be executed upon calling</span>
                <span class="s2"># resource_tracker.maybe_unlink, registered as a finalizer in</span>
                <span class="s2"># the child.</span>
                <span class="s2"># the incref/decref calls here are only possible when the child</span>
                <span class="s2"># and the parent share the same resource_tracker. It is not the</span>
                <span class="s2"># case for the multiprocessing backend, but it does not matter</span>
                <span class="s2"># because unlinking a memmap from a child process is only</span>
                <span class="s2"># useful to control the memory usage of long-lasting child</span>
                <span class="s2"># processes, while the multiprocessing-based pools terminate</span>
                <span class="s2"># their workers at the end of a map() call.</span>
                <span class="s1">resource_tracker</span><span class="s4">.</span><span class="s1">register</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">, </span><span class="s5">&quot;file&quot;</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">is_new_memmap</span><span class="s4">:</span>
                <span class="s2"># Incref each temporary memmap created by joblib one extra</span>
                <span class="s2"># time.  This means that these memmaps will only be deleted</span>
                <span class="s2"># once an extra maybe_unlink() is called, which is done once</span>
                <span class="s2"># all the jobs have completed (or been canceled) in the</span>
                <span class="s2"># Parallel._terminate_backend() method.</span>
                <span class="s1">resource_tracker</span><span class="s4">.</span><span class="s1">register</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">, </span><span class="s5">&quot;file&quot;</span><span class="s4">)</span>

            <span class="s3">if not </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">exists</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">):</span>
                <span class="s1">util</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span>
                    <span class="s5">&quot;[ARRAY DUMP] Pickling new array (shape={}, dtype={}) &quot;</span>
                    <span class="s5">&quot;creating a new memmap at {}&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span>
                        <span class="s1">a</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">, </span><span class="s1">a</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">filename</span><span class="s4">))</span>
                <span class="s3">for </span><span class="s1">dumped_filename </span><span class="s3">in </span><span class="s1">dump</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">filename</span><span class="s4">):</span>
                    <span class="s1">os</span><span class="s4">.</span><span class="s1">chmod</span><span class="s4">(</span><span class="s1">dumped_filename</span><span class="s4">, </span><span class="s1">FILE_PERMISSIONS</span><span class="s4">)</span>

                <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_prewarm</span><span class="s4">:</span>
                    <span class="s2"># Warm up the data by accessing it. This operation ensures</span>
                    <span class="s2"># that the disk access required to create the memmapping</span>
                    <span class="s2"># file are performed in the reducing process and avoids</span>
                    <span class="s2"># concurrent memmap creation in multiple children</span>
                    <span class="s2"># processes.</span>
                    <span class="s1">load</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">, </span><span class="s1">mmap_mode</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_mmap_mode</span><span class="s4">).</span><span class="s1">max</span><span class="s4">()</span>

            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">util</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span>
                    <span class="s5">&quot;[ARRAY DUMP] Pickling known array (shape={}, dtype={}) &quot;</span>
                    <span class="s5">&quot;reusing memmap file: {}&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span>
                        <span class="s1">a</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">, </span><span class="s1">a</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">basename</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">)))</span>

            <span class="s2"># The worker process will use joblib.load to memmap the data</span>
            <span class="s3">return </span><span class="s4">(</span>
                <span class="s4">(</span><span class="s1">load_temporary_memmap</span><span class="s4">, (</span><span class="s1">filename</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_mmap_mode</span><span class="s4">,</span>
                                         <span class="s1">self</span><span class="s4">.</span><span class="s1">_unlink_on_gc_collect</span><span class="s4">))</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># do not convert a into memmap, let pickler do its usual copy with</span>
            <span class="s2"># the default system pickler</span>
            <span class="s1">util</span><span class="s4">.</span><span class="s1">debug</span><span class="s4">(</span>
                <span class="s5">'[ARRAY DUMP] Pickling array (NO MEMMAPPING) (shape={}, '</span>
                <span class="s5">' dtype={}).'</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">a</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">, </span><span class="s1">a</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">))</span>
            <span class="s3">return </span><span class="s4">(</span><span class="s1">loads</span><span class="s4">, (</span><span class="s1">dumps</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">protocol</span><span class="s4">=</span><span class="s1">HIGHEST_PROTOCOL</span><span class="s4">),))</span>


<span class="s3">def </span><span class="s1">get_memmapping_reducers</span><span class="s4">(</span>
        <span class="s1">forward_reducers</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">backward_reducers</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">temp_folder_resolver</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">max_nbytes</span><span class="s4">=</span><span class="s6">1e6</span><span class="s4">, </span><span class="s1">mmap_mode</span><span class="s4">=</span><span class="s5">'r'</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
        <span class="s1">prewarm</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">unlink_on_gc_collect</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Construct a pair of memmapping reducer linked to a tmpdir. 
 
    This function manage the creation and the clean up of the temporary folders 
    underlying the memory maps and should be use to get the reducers necessary 
    to construct joblib pool or executor. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">forward_reducers </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">forward_reducers </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">()</span>
    <span class="s3">if </span><span class="s1">backward_reducers </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">backward_reducers </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">()</span>

    <span class="s3">if </span><span class="s1">np </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s2"># Register smart numpy.ndarray reducers that detects memmap backed</span>
        <span class="s2"># arrays and that is also able to dump to memmap large in-memory</span>
        <span class="s2"># arrays over the max_nbytes threshold</span>
        <span class="s1">forward_reduce_ndarray </span><span class="s4">= </span><span class="s1">ArrayMemmapForwardReducer</span><span class="s4">(</span>
            <span class="s1">max_nbytes</span><span class="s4">, </span><span class="s1">temp_folder_resolver</span><span class="s4">, </span><span class="s1">mmap_mode</span><span class="s4">, </span><span class="s1">unlink_on_gc_collect</span><span class="s4">,</span>
            <span class="s1">verbose</span><span class="s4">, </span><span class="s1">prewarm</span><span class="s4">=</span><span class="s1">prewarm</span><span class="s4">)</span>
        <span class="s1">forward_reducers</span><span class="s4">[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">] = </span><span class="s1">forward_reduce_ndarray</span>
        <span class="s1">forward_reducers</span><span class="s4">[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">memmap</span><span class="s4">] = </span><span class="s1">forward_reduce_ndarray</span>

        <span class="s2"># Communication from child process to the parent process always</span>
        <span class="s2"># pickles in-memory numpy.ndarray without dumping them as memmap</span>
        <span class="s2"># to avoid confusing the caller and make it tricky to collect the</span>
        <span class="s2"># temporary folder</span>
        <span class="s1">backward_reducers</span><span class="s4">[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">] = </span><span class="s1">reduce_array_memmap_backward</span>
        <span class="s1">backward_reducers</span><span class="s4">[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">memmap</span><span class="s4">] = </span><span class="s1">reduce_array_memmap_backward</span>

    <span class="s3">return </span><span class="s1">forward_reducers</span><span class="s4">, </span><span class="s1">backward_reducers</span>


<span class="s3">class </span><span class="s1">TemporaryResourcesManager</span><span class="s4">(</span><span class="s1">object</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Stateful object able to manage temporary folder and pickles 
 
    It exposes: 
    - a per-context folder name resolving API that memmap-based reducers will 
      rely on to know where to pickle the temporary memmaps 
    - a temporary file/folder management API that internally uses the 
      resource_tracker. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">temp_folder_root</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">context_id</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_current_temp_folder </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_temp_folder_root </span><span class="s4">= </span><span class="s1">temp_folder_root</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_use_shared_mem </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_cached_temp_folders </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_id </span><span class="s4">= </span><span class="s1">uuid4</span><span class="s4">().</span><span class="s1">hex</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_finalizers </span><span class="s4">= {}</span>
        <span class="s3">if </span><span class="s1">context_id </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s2"># It would be safer to not assign a default context id (less silent</span>
            <span class="s2"># bugs), but doing this while maintaining backward compatibility</span>
            <span class="s2"># with the previous, context-unaware version get_memmaping_executor</span>
            <span class="s2"># exposes too many low-level details.</span>
            <span class="s1">context_id </span><span class="s4">= </span><span class="s1">uuid4</span><span class="s4">().</span><span class="s1">hex</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">set_current_context</span><span class="s4">(</span><span class="s1">context_id</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">set_current_context</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">context_id</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_current_context_id </span><span class="s4">= </span><span class="s1">context_id</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">register_new_context</span><span class="s4">(</span><span class="s1">context_id</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">register_new_context</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">context_id</span><span class="s4">):</span>
        <span class="s2"># Prepare a sub-folder name specific to a context (usually a unique id</span>
        <span class="s2"># generated by each instance of the Parallel class). Do not create in</span>
        <span class="s2"># advance to spare FS write access if no array is to be dumped).</span>
        <span class="s3">if </span><span class="s1">context_id </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_cached_temp_folders</span><span class="s4">:</span>
            <span class="s3">return</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># During its lifecycle, one Parallel object can have several</span>
            <span class="s2"># executors associated to it (for instance, if a loky worker raises</span>
            <span class="s2"># an exception, joblib shutdowns the executor and instantly</span>
            <span class="s2"># recreates a new one before raising the error - see</span>
            <span class="s2"># ``ensure_ready``.  Because we don't want two executors tied to</span>
            <span class="s2"># the same Parallel object (and thus the same context id) to</span>
            <span class="s2"># register/use/delete the same folder, we also add an id specific</span>
            <span class="s2"># to the current Manager (and thus specific to its associated</span>
            <span class="s2"># executor) to the folder name.</span>
            <span class="s1">new_folder_name </span><span class="s4">= (</span>
                <span class="s5">&quot;joblib_memmapping_folder_{}_{}_{}&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span>
                    <span class="s1">os</span><span class="s4">.</span><span class="s1">getpid</span><span class="s4">(), </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_id</span><span class="s4">, </span><span class="s1">context_id</span><span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s1">new_folder_path</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">_get_temp_dir</span><span class="s4">(</span>
                <span class="s1">new_folder_name</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_temp_folder_root</span>
            <span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">register_folder_finalizer</span><span class="s4">(</span><span class="s1">new_folder_path</span><span class="s4">, </span><span class="s1">context_id</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_cached_temp_folders</span><span class="s4">[</span><span class="s1">context_id</span><span class="s4">] = </span><span class="s1">new_folder_path</span>

    <span class="s3">def </span><span class="s1">resolve_temp_folder_name</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return a folder name specific to the currently activated context&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_cached_temp_folders</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_current_context_id</span><span class="s4">]</span>

    <span class="s2"># resource management API</span>

    <span class="s3">def </span><span class="s1">register_folder_finalizer</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">pool_subfolder</span><span class="s4">, </span><span class="s1">context_id</span><span class="s4">):</span>
        <span class="s2"># Register the garbage collector at program exit in case caller forgets</span>
        <span class="s2"># to call terminate explicitly: note we do not pass any reference to</span>
        <span class="s2"># ensure that this callback won't prevent garbage collection of</span>
        <span class="s2"># parallel instance and related file handler resources such as POSIX</span>
        <span class="s2"># semaphores and pipes</span>
        <span class="s1">pool_module_name </span><span class="s4">= </span><span class="s1">whichmodule</span><span class="s4">(</span><span class="s1">delete_folder</span><span class="s4">, </span><span class="s5">'delete_folder'</span><span class="s4">)</span>
        <span class="s1">resource_tracker</span><span class="s4">.</span><span class="s1">register</span><span class="s4">(</span><span class="s1">pool_subfolder</span><span class="s4">, </span><span class="s5">&quot;folder&quot;</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">_cleanup</span><span class="s4">():</span>
            <span class="s2"># In some cases the Python runtime seems to set delete_folder to</span>
            <span class="s2"># None just before exiting when accessing the delete_folder</span>
            <span class="s2"># function from the closure namespace. So instead we reimport</span>
            <span class="s2"># the delete_folder function explicitly.</span>
            <span class="s2"># https://github.com/joblib/joblib/issues/328</span>
            <span class="s2"># We cannot just use from 'joblib.pool import delete_folder'</span>
            <span class="s2"># because joblib should only use relative imports to allow</span>
            <span class="s2"># easy vendoring.</span>
            <span class="s1">delete_folder </span><span class="s4">= </span><span class="s1">__import__</span><span class="s4">(</span>
                <span class="s1">pool_module_name</span><span class="s4">, </span><span class="s1">fromlist</span><span class="s4">=[</span><span class="s5">'delete_folder'</span><span class="s4">]</span>
            <span class="s4">).</span><span class="s1">delete_folder</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">delete_folder</span><span class="s4">(</span><span class="s1">pool_subfolder</span><span class="s4">, </span><span class="s1">allow_non_empty</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
                <span class="s1">resource_tracker</span><span class="s4">.</span><span class="s1">unregister</span><span class="s4">(</span><span class="s1">pool_subfolder</span><span class="s4">, </span><span class="s5">&quot;folder&quot;</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s1">OSError</span><span class="s4">:</span>
                <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span><span class="s5">&quot;Failed to delete temporary folder: {}&quot;</span>
                              <span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">pool_subfolder</span><span class="s4">))</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_finalizers</span><span class="s4">[</span><span class="s1">context_id</span><span class="s4">] = </span><span class="s1">atexit</span><span class="s4">.</span><span class="s1">register</span><span class="s4">(</span><span class="s1">_cleanup</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_clean_temporary_resources</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">context_id</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">force</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                                   <span class="s1">allow_non_empty</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Clean temporary resources created by a process-based pool&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">context_id </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s2"># Iterates over a copy of the cache keys to avoid Error due to</span>
            <span class="s2"># iterating over a changing size dictionary.</span>
            <span class="s3">for </span><span class="s1">context_id </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_cached_temp_folders</span><span class="s4">):</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_clean_temporary_resources</span><span class="s4">(</span>
                    <span class="s1">context_id</span><span class="s4">, </span><span class="s1">force</span><span class="s4">=</span><span class="s1">force</span><span class="s4">, </span><span class="s1">allow_non_empty</span><span class="s4">=</span><span class="s1">allow_non_empty</span>
                <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">temp_folder </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_cached_temp_folders</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">context_id</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">temp_folder </span><span class="s3">and </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">exists</span><span class="s4">(</span><span class="s1">temp_folder</span><span class="s4">):</span>
                <span class="s3">for </span><span class="s1">filename </span><span class="s3">in </span><span class="s1">os</span><span class="s4">.</span><span class="s1">listdir</span><span class="s4">(</span><span class="s1">temp_folder</span><span class="s4">):</span>
                    <span class="s3">if </span><span class="s1">force</span><span class="s4">:</span>
                        <span class="s2"># Some workers have failed and the ref counted might</span>
                        <span class="s2"># be off. The workers should have shut down by this</span>
                        <span class="s2"># time so forcefully clean up the files.</span>
                        <span class="s1">resource_tracker</span><span class="s4">.</span><span class="s1">unregister</span><span class="s4">(</span>
                            <span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">temp_folder</span><span class="s4">, </span><span class="s1">filename</span><span class="s4">), </span><span class="s5">&quot;file&quot;</span>
                        <span class="s4">)</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">resource_tracker</span><span class="s4">.</span><span class="s1">maybe_unlink</span><span class="s4">(</span>
                            <span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">temp_folder</span><span class="s4">, </span><span class="s1">filename</span><span class="s4">), </span><span class="s5">&quot;file&quot;</span>
                        <span class="s4">)</span>

                <span class="s2"># When forcing clean-up, try to delete the folder even if some</span>
                <span class="s2"># files are still in it. Otherwise, try to delete the folder</span>
                <span class="s1">allow_non_empty </span><span class="s4">|= </span><span class="s1">force</span>

                <span class="s2"># Clean up the folder if possible, either if it is empty or</span>
                <span class="s2"># if none of the files in it are in used and allow_non_empty.</span>
                <span class="s3">try</span><span class="s4">:</span>
                    <span class="s1">delete_folder</span><span class="s4">(</span>
                        <span class="s1">temp_folder</span><span class="s4">, </span><span class="s1">allow_non_empty</span><span class="s4">=</span><span class="s1">allow_non_empty</span>
                    <span class="s4">)</span>
                    <span class="s2"># Forget the folder once it has been deleted</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">_cached_temp_folders</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">context_id</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
                    <span class="s1">resource_tracker</span><span class="s4">.</span><span class="s1">unregister</span><span class="s4">(</span><span class="s1">temp_folder</span><span class="s4">, </span><span class="s5">&quot;folder&quot;</span><span class="s4">)</span>

                    <span class="s2"># Also cancel the finalizers  that gets triggered at gc.</span>
                    <span class="s1">finalizer </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_finalizers</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">context_id</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">finalizer </span><span class="s3">is not None</span><span class="s4">:</span>
                        <span class="s1">atexit</span><span class="s4">.</span><span class="s1">unregister</span><span class="s4">(</span><span class="s1">finalizer</span><span class="s4">)</span>

                <span class="s3">except </span><span class="s1">OSError</span><span class="s4">:</span>
                    <span class="s2"># Temporary folder cannot be deleted right now.</span>
                    <span class="s2"># This folder will be cleaned up by an atexit</span>
                    <span class="s2"># finalizer registered by the memmapping_reducer.</span>
                    <span class="s3">pass</span>
</pre>
</body>
</html>