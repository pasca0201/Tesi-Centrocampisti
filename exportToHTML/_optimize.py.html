<html>
<head>
<title>_optimize.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_optimize.py</font>
</center></td></tr></table>
<pre><span class="s0">#__docformat__ = &quot;restructuredtext en&quot;</span>
<span class="s0"># ******NOTICE***************</span>
<span class="s0"># optimize.py module by Travis E. Oliphant</span>
<span class="s0">#</span>
<span class="s0"># You may copy and use this module as you see fit with no</span>
<span class="s0"># guarantee implied provided you keep this notice in all copies.</span>
<span class="s0"># *****END NOTICE************</span>

<span class="s0"># A collection of optimization algorithms. Version 0.5</span>
<span class="s0"># CHANGES</span>
<span class="s0">#  Added fminbound (July 2001)</span>
<span class="s0">#  Added brute (Aug. 2002)</span>
<span class="s0">#  Finished line search satisfying strong Wolfe conditions (Mar. 2004)</span>
<span class="s0">#  Updated strong Wolfe conditions line search to use</span>
<span class="s0">#  cubic-interpolation (Mar. 2004)</span>


<span class="s0"># Minimization routines</span>

<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">'fmin'</span><span class="s2">, </span><span class="s3">'fmin_powell'</span><span class="s2">, </span><span class="s3">'fmin_bfgs'</span><span class="s2">, </span><span class="s3">'fmin_ncg'</span><span class="s2">, </span><span class="s3">'fmin_cg'</span><span class="s2">,</span>
           <span class="s3">'fminbound'</span><span class="s2">, </span><span class="s3">'brent'</span><span class="s2">, </span><span class="s3">'golden'</span><span class="s2">, </span><span class="s3">'bracket'</span><span class="s2">, </span><span class="s3">'rosen'</span><span class="s2">, </span><span class="s3">'rosen_der'</span><span class="s2">,</span>
           <span class="s3">'rosen_hess'</span><span class="s2">, </span><span class="s3">'rosen_hess_prod'</span><span class="s2">, </span><span class="s3">'brute'</span><span class="s2">, </span><span class="s3">'approx_fprime'</span><span class="s2">,</span>
           <span class="s3">'line_search'</span><span class="s2">, </span><span class="s3">'check_grad'</span><span class="s2">, </span><span class="s3">'OptimizeResult'</span><span class="s2">, </span><span class="s3">'show_options'</span><span class="s2">,</span>
           <span class="s3">'OptimizeWarning'</span><span class="s2">]</span>

<span class="s1">__docformat__ </span><span class="s2">= </span><span class="s3">&quot;restructuredtext en&quot;</span>

<span class="s4">import </span><span class="s1">math</span>
<span class="s4">import </span><span class="s1">warnings</span>
<span class="s4">import </span><span class="s1">sys</span>
<span class="s4">import </span><span class="s1">inspect</span>
<span class="s4">from </span><span class="s1">numpy </span><span class="s4">import </span><span class="s2">(</span><span class="s1">atleast_1d</span><span class="s2">, </span><span class="s1">eye</span><span class="s2">, </span><span class="s1">argmin</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">squeeze</span><span class="s2">,</span>
                   <span class="s1">asarray</span><span class="s2">, </span><span class="s1">sqrt</span><span class="s2">)</span>
<span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>
<span class="s4">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">linalg </span><span class="s4">import </span><span class="s1">cholesky</span><span class="s2">, </span><span class="s1">issymmetric</span><span class="s2">, </span><span class="s1">LinAlgError</span>
<span class="s4">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">linalg </span><span class="s4">import </span><span class="s1">LinearOperator</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_linesearch </span><span class="s4">import </span><span class="s2">(</span><span class="s1">line_search_wolfe1</span><span class="s2">, </span><span class="s1">line_search_wolfe2</span><span class="s2">,</span>
                          <span class="s1">line_search_wolfe2 </span><span class="s4">as </span><span class="s1">line_search</span><span class="s2">,</span>
                          <span class="s1">LineSearchWarning</span><span class="s2">)</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_numdiff </span><span class="s4">import </span><span class="s1">approx_derivative</span>
<span class="s4">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">_lib</span><span class="s2">.</span><span class="s1">_util </span><span class="s4">import </span><span class="s1">getfullargspec_no_self </span><span class="s4">as </span><span class="s1">_getfullargspec</span>
<span class="s4">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">_lib</span><span class="s2">.</span><span class="s1">_util </span><span class="s4">import </span><span class="s2">(</span><span class="s1">MapWrapper</span><span class="s2">, </span><span class="s1">check_random_state</span><span class="s2">, </span><span class="s1">_RichResult</span><span class="s2">,</span>
                              <span class="s1">_call_callback_maybe_halt</span><span class="s2">)</span>
<span class="s4">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">optimize</span><span class="s2">.</span><span class="s1">_differentiable_functions </span><span class="s4">import </span><span class="s1">ScalarFunction</span><span class="s2">, </span><span class="s1">FD_METHODS</span>


<span class="s0"># standard status messages of optimizers</span>
<span class="s1">_status_message </span><span class="s2">= {</span><span class="s3">'success'</span><span class="s2">: </span><span class="s3">'Optimization terminated successfully.'</span><span class="s2">,</span>
                   <span class="s3">'maxfev'</span><span class="s2">: </span><span class="s3">'Maximum number of function evaluations has '</span>
                              <span class="s3">'been exceeded.'</span><span class="s2">,</span>
                   <span class="s3">'maxiter'</span><span class="s2">: </span><span class="s3">'Maximum number of iterations has been '</span>
                              <span class="s3">'exceeded.'</span><span class="s2">,</span>
                   <span class="s3">'pr_loss'</span><span class="s2">: </span><span class="s3">'Desired error not necessarily achieved due '</span>
                              <span class="s3">'to precision loss.'</span><span class="s2">,</span>
                   <span class="s3">'nan'</span><span class="s2">: </span><span class="s3">'NaN result encountered.'</span><span class="s2">,</span>
                   <span class="s3">'out_of_bounds'</span><span class="s2">: </span><span class="s3">'The result is outside of the provided '</span>
                                    <span class="s3">'bounds.'</span><span class="s2">}</span>


<span class="s4">class </span><span class="s1">MemoizeJac</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot; Decorator that caches the return values of a function returning `(fun, grad)` 
        each time it is called. &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">fun </span><span class="s2">= </span><span class="s1">fun</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">jac </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">x </span><span class="s2">= </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">_compute_if_needed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">):</span>
        <span class="s4">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">x </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">x</span><span class="s2">) </span><span class="s4">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value </span><span class="s4">is None or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">jac </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">).</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s1">fg </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fun</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">jac </span><span class="s2">= </span><span class="s1">fg</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">= </span><span class="s1">fg</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>

    <span class="s4">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">):</span>
        <span class="s5">&quot;&quot;&quot; returns the function value &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_compute_if_needed</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_value</span>

    <span class="s4">def </span><span class="s1">derivative</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_compute_if_needed</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">jac</span>


<span class="s4">def </span><span class="s1">_wrap_callback</span><span class="s2">(</span><span class="s1">callback</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Wrap a user-provided callback so that attributes can be attached.&quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">callback </span><span class="s4">is None or </span><span class="s1">method </span><span class="s4">in </span><span class="s2">{</span><span class="s3">'tnc'</span><span class="s2">, </span><span class="s3">'slsqp'</span><span class="s2">, </span><span class="s3">'cobyla'</span><span class="s2">, </span><span class="s3">'cobyqa'</span><span class="s2">}:</span>
        <span class="s4">return </span><span class="s1">callback  </span><span class="s0"># don't wrap</span>

    <span class="s1">sig </span><span class="s2">= </span><span class="s1">inspect</span><span class="s2">.</span><span class="s1">signature</span><span class="s2">(</span><span class="s1">callback</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">set</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">parameters</span><span class="s2">) == {</span><span class="s3">'intermediate_result'</span><span class="s2">}:</span>
        <span class="s4">def </span><span class="s1">wrapped_callback</span><span class="s2">(</span><span class="s1">res</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">callback</span><span class="s2">(</span><span class="s1">intermediate_result</span><span class="s2">=</span><span class="s1">res</span><span class="s2">)</span>
    <span class="s4">elif </span><span class="s1">method </span><span class="s2">== </span><span class="s3">'trust-constr'</span><span class="s2">:</span>
        <span class="s4">def </span><span class="s1">wrapped_callback</span><span class="s2">(</span><span class="s1">res</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">callback</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">res</span><span class="s2">.</span><span class="s1">x</span><span class="s2">), </span><span class="s1">res</span><span class="s2">)</span>
    <span class="s4">elif </span><span class="s1">method </span><span class="s2">== </span><span class="s3">'differential_evolution'</span><span class="s2">:</span>
        <span class="s4">def </span><span class="s1">wrapped_callback</span><span class="s2">(</span><span class="s1">res</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">callback</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">res</span><span class="s2">.</span><span class="s1">x</span><span class="s2">), </span><span class="s1">res</span><span class="s2">.</span><span class="s1">convergence</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">def </span><span class="s1">wrapped_callback</span><span class="s2">(</span><span class="s1">res</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">callback</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">res</span><span class="s2">.</span><span class="s1">x</span><span class="s2">))</span>

    <span class="s1">wrapped_callback</span><span class="s2">.</span><span class="s1">stop_iteration </span><span class="s2">= </span><span class="s4">False</span>
    <span class="s4">return </span><span class="s1">wrapped_callback</span>


<span class="s4">class </span><span class="s1">OptimizeResult</span><span class="s2">(</span><span class="s1">_RichResult</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Represents the optimization result. 
 
    Attributes 
    ---------- 
    x : ndarray 
        The solution of the optimization. 
    success : bool 
        Whether or not the optimizer exited successfully. 
    status : int 
        Termination status of the optimizer. Its value depends on the 
        underlying solver. Refer to `message` for details. 
    message : str 
        Description of the cause of the termination. 
    fun, jac, hess: ndarray 
        Values of objective function, its Jacobian and its Hessian (if 
        available). The Hessians may be approximations, see the documentation 
        of the function in question. 
    hess_inv : object 
        Inverse of the objective function's Hessian; may be an approximation. 
        Not available for all solvers. The type of this attribute may be 
        either np.ndarray or scipy.sparse.linalg.LinearOperator. 
    nfev, njev, nhev : int 
        Number of evaluations of the objective functions and of its 
        Jacobian and Hessian. 
    nit : int 
        Number of iterations performed by the optimizer. 
    maxcv : float 
        The maximum constraint violation. 
 
    Notes 
    ----- 
    Depending on the specific solver being used, `OptimizeResult` may 
    not have all attributes listed here, and they may have additional 
    attributes not listed here. Since this class is essentially a 
    subclass of dict with attribute accessors, one can see which 
    attributes are available using the `OptimizeResult.keys` method. 
 
    &quot;&quot;&quot;</span>
    <span class="s4">pass</span>


<span class="s4">class </span><span class="s1">OptimizeWarning</span><span class="s2">(</span><span class="s1">UserWarning</span><span class="s2">):</span>
    <span class="s4">pass</span>

<span class="s4">def </span><span class="s1">_check_positive_definite</span><span class="s2">(</span><span class="s1">Hk</span><span class="s2">):</span>
    <span class="s4">def </span><span class="s1">is_pos_def</span><span class="s2">(</span><span class="s1">A</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">issymmetric</span><span class="s2">(</span><span class="s1">A</span><span class="s2">):</span>
            <span class="s4">try</span><span class="s2">:</span>
                <span class="s1">cholesky</span><span class="s2">(</span><span class="s1">A</span><span class="s2">)</span>
                <span class="s4">return True</span>
            <span class="s4">except </span><span class="s1">LinAlgError</span><span class="s2">:</span>
                <span class="s4">return False</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return False</span>
    <span class="s4">if </span><span class="s1">Hk </span><span class="s4">is not None</span><span class="s2">:</span>
        <span class="s4">if not </span><span class="s1">is_pos_def</span><span class="s2">(</span><span class="s1">Hk</span><span class="s2">):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;'hess_inv0' matrix isn't positive definite.&quot;</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">_check_unknown_options</span><span class="s2">(</span><span class="s1">unknown_options</span><span class="s2">):</span>
    <span class="s4">if </span><span class="s1">unknown_options</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s3">&quot;, &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">map</span><span class="s2">(</span><span class="s1">str</span><span class="s2">, </span><span class="s1">unknown_options</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">()))</span>
        <span class="s0"># Stack level 4: this is called from _minimize_*, which is</span>
        <span class="s0"># called from another function in SciPy. Level 4 is the first</span>
        <span class="s0"># level in user code.</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s3">&quot;Unknown solver options: %s&quot; </span><span class="s2">% </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">OptimizeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">4</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">is_finite_scalar</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Test whether `x` is either a finite scalar or a finite array scalar. 
 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">size</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) == </span><span class="s6">1 </span><span class="s4">and </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>


<span class="s1">_epsilon </span><span class="s2">= </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">float</span><span class="s2">).</span><span class="s1">eps</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">vecnorm</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">ord</span><span class="s2">=</span><span class="s6">2</span><span class="s2">):</span>
    <span class="s4">if </span><span class="s1">ord </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">amax</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">))</span>
    <span class="s4">elif </span><span class="s1">ord </span><span class="s2">== -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">amin</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">))</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)**</span><span class="s1">ord</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s6">0</span><span class="s2">)**(</span><span class="s6">1.0 </span><span class="s2">/ </span><span class="s1">ord</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">_prepare_scalar_function</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">jac</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">bounds</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                             <span class="s1">epsilon</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">finite_diff_rel_step</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                             <span class="s1">hess</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Creates a ScalarFunction object for use with scalar minimizers 
    (BFGS/LBFGSB/SLSQP/TNC/CG/etc). 
 
    Parameters 
    ---------- 
    fun : callable 
        The objective function to be minimized. 
 
            ``fun(x, *args) -&gt; float`` 
 
        where ``x`` is an 1-D array with shape (n,) and ``args`` 
        is a tuple of the fixed parameters needed to completely 
        specify the function. 
    x0 : ndarray, shape (n,) 
        Initial guess. Array of real elements of size (n,), 
        where 'n' is the number of independent variables. 
    jac : {callable,  '2-point', '3-point', 'cs', None}, optional 
        Method for computing the gradient vector. If it is a callable, it 
        should be a function that returns the gradient vector: 
 
            ``jac(x, *args) -&gt; array_like, shape (n,)`` 
 
        If one of `{'2-point', '3-point', 'cs'}` is selected then the gradient 
        is calculated with a relative step for finite differences. If `None`, 
        then two-point finite differences with an absolute step is used. 
    args : tuple, optional 
        Extra arguments passed to the objective function and its 
        derivatives (`fun`, `jac` functions). 
    bounds : sequence, optional 
        Bounds on variables. 'new-style' bounds are required. 
    eps : float or ndarray 
        If `jac is None` the absolute step size used for numerical 
        approximation of the jacobian via forward differences. 
    finite_diff_rel_step : None or array_like, optional 
        If `jac in ['2-point', '3-point', 'cs']` the relative step size to 
        use for numerical approximation of the jacobian. The absolute step 
        size is computed as ``h = rel_step * sign(x0) * max(1, abs(x0))``, 
        possibly adjusted to fit into the bounds. For ``jac='3-point'`` 
        the sign of `h` is ignored. If None (default) then step is selected 
        automatically. 
    hess : {callable,  '2-point', '3-point', 'cs', None} 
        Computes the Hessian matrix. If it is callable, it should return the 
        Hessian matrix: 
 
            ``hess(x, *args) -&gt; {LinearOperator, spmatrix, array}, (n, n)`` 
 
        Alternatively, the keywords {'2-point', '3-point', 'cs'} select a 
        finite difference scheme for numerical estimation. 
        Whenever the gradient is estimated via finite-differences, the Hessian 
        cannot be estimated with options {'2-point', '3-point', 'cs'} and needs 
        to be estimated using one of the quasi-Newton strategies. 
 
    Returns 
    ------- 
    sf : ScalarFunction 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">jac</span><span class="s2">):</span>
        <span class="s1">grad </span><span class="s2">= </span><span class="s1">jac</span>
    <span class="s4">elif </span><span class="s1">jac </span><span class="s4">in </span><span class="s1">FD_METHODS</span><span class="s2">:</span>
        <span class="s0"># epsilon is set to None so that ScalarFunction is made to use</span>
        <span class="s0"># rel_step</span>
        <span class="s1">epsilon </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s1">grad </span><span class="s2">= </span><span class="s1">jac</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s0"># default (jac is None) is to do 2-point finite differences with</span>
        <span class="s0"># absolute step size. ScalarFunction has to be provided an</span>
        <span class="s0"># epsilon value that is not None to use absolute steps. This is</span>
        <span class="s0"># normally the case from most _minimize* methods.</span>
        <span class="s1">grad </span><span class="s2">= </span><span class="s3">'2-point'</span>
        <span class="s1">epsilon </span><span class="s2">= </span><span class="s1">epsilon</span>

    <span class="s4">if </span><span class="s1">hess </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s0"># ScalarFunction requires something for hess, so we give a dummy</span>
        <span class="s0"># implementation here if nothing is provided, return a value of None</span>
        <span class="s0"># so that downstream minimisers halt. The results of `fun.hess`</span>
        <span class="s0"># should not be used.</span>
        <span class="s4">def </span><span class="s1">hess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">):</span>
            <span class="s4">return None</span>

    <span class="s4">if </span><span class="s1">bounds </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">bounds </span><span class="s2">= (-</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">)</span>

    <span class="s0"># ScalarFunction caches. Reuse of fun(x) during grad</span>
    <span class="s0"># calculation reduces overall function evaluations.</span>
    <span class="s1">sf </span><span class="s2">= </span><span class="s1">ScalarFunction</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">grad</span><span class="s2">, </span><span class="s1">hess</span><span class="s2">,</span>
                        <span class="s1">finite_diff_rel_step</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">epsilon</span><span class="s2">=</span><span class="s1">epsilon</span><span class="s2">)</span>

    <span class="s4">return </span><span class="s1">sf</span>


<span class="s4">def </span><span class="s1">_clip_x_for_func</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">):</span>
    <span class="s0"># ensures that x values sent to func are clipped to bounds</span>

    <span class="s0"># this is used as a mitigation for gh11403, slsqp/tnc sometimes</span>
    <span class="s0"># suggest a move that is outside the limits by 1 or 2 ULP. This</span>
    <span class="s0"># unclean fix makes sure x is strictly within bounds.</span>
    <span class="s4">def </span><span class="s1">eval</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">_check_clip_x</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s4">return </span><span class="s1">eval</span>


<span class="s4">def </span><span class="s1">_check_clip_x</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">):</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s1">x </span><span class="s2">&lt; </span><span class="s1">bounds</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]).</span><span class="s1">any</span><span class="s2">() </span><span class="s4">or </span><span class="s2">(</span><span class="s1">x </span><span class="s2">&gt; </span><span class="s1">bounds</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]).</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s3">&quot;Values in x were outside bounds during a &quot;</span>
                      <span class="s3">&quot;minimize step, clipping to bounds&quot;</span><span class="s2">,</span>
                      <span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">3</span><span class="s2">)</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">bounds</span><span class="s2">[</span><span class="s6">1</span><span class="s2">])</span>
        <span class="s4">return </span><span class="s1">x</span>

    <span class="s4">return </span><span class="s1">x</span>


<span class="s4">def </span><span class="s1">rosen</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    The Rosenbrock function. 
 
    The function computed is:: 
 
        sum(100.0*(x[1:] - x[:-1]**2.0)**2.0 + (1 - x[:-1])**2.0) 
 
    Parameters 
    ---------- 
    x : array_like 
        1-D array of points at which the Rosenbrock function is to be computed. 
 
    Returns 
    ------- 
    f : float 
        The value of the Rosenbrock function. 
 
    See Also 
    -------- 
    rosen_der, rosen_hess, rosen_hess_prod 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.optimize import rosen 
    &gt;&gt;&gt; X = 0.1 * np.arange(10) 
    &gt;&gt;&gt; rosen(X) 
    76.56 
 
    For higher-dimensional input ``rosen`` broadcasts. 
    In the following example, we use this to plot a 2D landscape. 
    Note that ``rosen_hess`` does not broadcast in this manner. 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from mpl_toolkits.mplot3d import Axes3D 
    &gt;&gt;&gt; x = np.linspace(-1, 1, 50) 
    &gt;&gt;&gt; X, Y = np.meshgrid(x, x) 
    &gt;&gt;&gt; ax = plt.subplot(111, projection='3d') 
    &gt;&gt;&gt; ax.plot_surface(X, Y, rosen([X, Y])) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s6">100.0 </span><span class="s2">* (</span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:] - </span><span class="s1">x</span><span class="s2">[:-</span><span class="s6">1</span><span class="s2">]**</span><span class="s6">2.0</span><span class="s2">)**</span><span class="s6">2.0 </span><span class="s2">+ (</span><span class="s6">1 </span><span class="s2">- </span><span class="s1">x</span><span class="s2">[:-</span><span class="s6">1</span><span class="s2">])**</span><span class="s6">2.0</span><span class="s2">,</span>
                  <span class="s1">axis</span><span class="s2">=</span><span class="s6">0</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">r</span>


<span class="s4">def </span><span class="s1">rosen_der</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    The derivative (i.e. gradient) of the Rosenbrock function. 
 
    Parameters 
    ---------- 
    x : array_like 
        1-D array of points at which the derivative is to be computed. 
 
    Returns 
    ------- 
    rosen_der : (N,) ndarray 
        The gradient of the Rosenbrock function at `x`. 
 
    See Also 
    -------- 
    rosen, rosen_hess, rosen_hess_prod 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.optimize import rosen_der 
    &gt;&gt;&gt; X = 0.1 * np.arange(9) 
    &gt;&gt;&gt; rosen_der(X) 
    array([ -2. ,  10.6,  15.6,  13.4,   6.4,  -3. , -12.4, -19.4,  62. ]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s1">xm </span><span class="s2">= </span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:-</span><span class="s6">1</span><span class="s2">]</span>
    <span class="s1">xm_m1 </span><span class="s2">= </span><span class="s1">x</span><span class="s2">[:-</span><span class="s6">2</span><span class="s2">]</span>
    <span class="s1">xm_p1 </span><span class="s2">= </span><span class="s1">x</span><span class="s2">[</span><span class="s6">2</span><span class="s2">:]</span>
    <span class="s1">der </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s1">der</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:-</span><span class="s6">1</span><span class="s2">] = (</span><span class="s6">200 </span><span class="s2">* (</span><span class="s1">xm </span><span class="s2">- </span><span class="s1">xm_m1</span><span class="s2">**</span><span class="s6">2</span><span class="s2">) -</span>
                 <span class="s6">400 </span><span class="s2">* (</span><span class="s1">xm_p1 </span><span class="s2">- </span><span class="s1">xm</span><span class="s2">**</span><span class="s6">2</span><span class="s2">) * </span><span class="s1">xm </span><span class="s2">- </span><span class="s6">2 </span><span class="s2">* (</span><span class="s6">1 </span><span class="s2">- </span><span class="s1">xm</span><span class="s2">))</span>
    <span class="s1">der</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] = -</span><span class="s6">400 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] * (</span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">] - </span><span class="s1">x</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]**</span><span class="s6">2</span><span class="s2">) - </span><span class="s6">2 </span><span class="s2">* (</span><span class="s6">1 </span><span class="s2">- </span><span class="s1">x</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>
    <span class="s1">der</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] = </span><span class="s6">200 </span><span class="s2">* (</span><span class="s1">x</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] - </span><span class="s1">x</span><span class="s2">[-</span><span class="s6">2</span><span class="s2">]**</span><span class="s6">2</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">der</span>


<span class="s4">def </span><span class="s1">rosen_hess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    The Hessian matrix of the Rosenbrock function. 
 
    Parameters 
    ---------- 
    x : array_like 
        1-D array of points at which the Hessian matrix is to be computed. 
 
    Returns 
    ------- 
    rosen_hess : ndarray 
        The Hessian matrix of the Rosenbrock function at `x`. 
 
    See Also 
    -------- 
    rosen, rosen_der, rosen_hess_prod 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.optimize import rosen_hess 
    &gt;&gt;&gt; X = 0.1 * np.arange(4) 
    &gt;&gt;&gt; rosen_hess(X) 
    array([[-38.,   0.,   0.,   0.], 
           [  0., 134., -40.,   0.], 
           [  0., -40., 130., -80.], 
           [  0.,   0., -80., 200.]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s1">H </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diag</span><span class="s2">(-</span><span class="s6">400 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[:-</span><span class="s6">1</span><span class="s2">], </span><span class="s6">1</span><span class="s2">) - </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diag</span><span class="s2">(</span><span class="s6">400 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[:-</span><span class="s6">1</span><span class="s2">], -</span><span class="s6">1</span><span class="s2">)</span>
    <span class="s1">diagonal </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">diagonal</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] = </span><span class="s6">1200 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]**</span><span class="s6">2 </span><span class="s2">- </span><span class="s6">400 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">] + </span><span class="s6">2</span>
    <span class="s1">diagonal</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] = </span><span class="s6">200</span>
    <span class="s1">diagonal</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:-</span><span class="s6">1</span><span class="s2">] = </span><span class="s6">202 </span><span class="s2">+ </span><span class="s6">1200 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:-</span><span class="s6">1</span><span class="s2">]**</span><span class="s6">2 </span><span class="s2">- </span><span class="s6">400 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[</span><span class="s6">2</span><span class="s2">:]</span>
    <span class="s1">H </span><span class="s2">= </span><span class="s1">H </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diag</span><span class="s2">(</span><span class="s1">diagonal</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">H</span>


<span class="s4">def </span><span class="s1">rosen_hess_prod</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">p</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Product of the Hessian matrix of the Rosenbrock function with a vector. 
 
    Parameters 
    ---------- 
    x : array_like 
        1-D array of points at which the Hessian matrix is to be computed. 
    p : array_like 
        1-D array, the vector to be multiplied by the Hessian matrix. 
 
    Returns 
    ------- 
    rosen_hess_prod : ndarray 
        The Hessian matrix of the Rosenbrock function at `x` multiplied 
        by the vector `p`. 
 
    See Also 
    -------- 
    rosen, rosen_der, rosen_hess 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.optimize import rosen_hess_prod 
    &gt;&gt;&gt; X = 0.1 * np.arange(9) 
    &gt;&gt;&gt; p = 0.5 * np.arange(9) 
    &gt;&gt;&gt; rosen_hess_prod(X, p) 
    array([  -0.,   27.,  -10.,  -95., -192., -265., -278., -195., -180.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s1">Hp </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">x</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">Hp</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] = (</span><span class="s6">1200 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]**</span><span class="s6">2 </span><span class="s2">- </span><span class="s6">400 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">] + </span><span class="s6">2</span><span class="s2">) * </span><span class="s1">p</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] - </span><span class="s6">400 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] * </span><span class="s1">p</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]</span>
    <span class="s1">Hp</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:-</span><span class="s6">1</span><span class="s2">] = (-</span><span class="s6">400 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[:-</span><span class="s6">2</span><span class="s2">] * </span><span class="s1">p</span><span class="s2">[:-</span><span class="s6">2</span><span class="s2">] +</span>
                <span class="s2">(</span><span class="s6">202 </span><span class="s2">+ </span><span class="s6">1200 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:-</span><span class="s6">1</span><span class="s2">]**</span><span class="s6">2 </span><span class="s2">- </span><span class="s6">400 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[</span><span class="s6">2</span><span class="s2">:]) * </span><span class="s1">p</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:-</span><span class="s6">1</span><span class="s2">] -</span>
                <span class="s6">400 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:-</span><span class="s6">1</span><span class="s2">] * </span><span class="s1">p</span><span class="s2">[</span><span class="s6">2</span><span class="s2">:])</span>
    <span class="s1">Hp</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] = -</span><span class="s6">400 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">[-</span><span class="s6">2</span><span class="s2">] * </span><span class="s1">p</span><span class="s2">[-</span><span class="s6">2</span><span class="s2">] + </span><span class="s6">200</span><span class="s2">*</span><span class="s1">p</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]</span>
    <span class="s4">return </span><span class="s1">Hp</span>


<span class="s4">def </span><span class="s1">_wrap_scalar_function</span><span class="s2">(</span><span class="s1">function</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
    <span class="s0"># wraps a minimizer function to count number of evaluations</span>
    <span class="s0"># and to easily provide an args kwd.</span>
    <span class="s1">ncalls </span><span class="s2">= [</span><span class="s6">0</span><span class="s2">]</span>
    <span class="s4">if </span><span class="s1">function </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">ncalls</span><span class="s2">, </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">function_wrapper</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">wrapper_args</span><span class="s2">):</span>
        <span class="s1">ncalls</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] += </span><span class="s6">1</span>
        <span class="s0"># A copy of x is sent to the user function (gh13740)</span>
        <span class="s1">fx </span><span class="s2">= </span><span class="s1">function</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), *(</span><span class="s1">wrapper_args </span><span class="s2">+ </span><span class="s1">args</span><span class="s2">))</span>
        <span class="s0"># Ideally, we'd like to a have a true scalar returned from f(x). For</span>
        <span class="s0"># backwards-compatibility, also allow np.array([1.3]), np.array([[1.3]]) etc.</span>
        <span class="s4">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isscalar</span><span class="s2">(</span><span class="s1">fx</span><span class="s2">):</span>
            <span class="s4">try</span><span class="s2">:</span>
                <span class="s1">fx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">fx</span><span class="s2">).</span><span class="s1">item</span><span class="s2">()</span>
            <span class="s4">except </span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">) </span><span class="s4">as </span><span class="s1">e</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;The user-provided objective function &quot;</span>
                                 <span class="s3">&quot;must return a scalar value.&quot;</span><span class="s2">) </span><span class="s4">from </span><span class="s1">e</span>
        <span class="s4">return </span><span class="s1">fx</span>

    <span class="s4">return </span><span class="s1">ncalls</span><span class="s2">, </span><span class="s1">function_wrapper</span>


<span class="s4">class </span><span class="s1">_MaxFuncCallError</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">):</span>
    <span class="s4">pass</span>


<span class="s4">def </span><span class="s1">_wrap_scalar_function_maxfun_validation</span><span class="s2">(</span><span class="s1">function</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">maxfun</span><span class="s2">):</span>
    <span class="s0"># wraps a minimizer function to count number of evaluations</span>
    <span class="s0"># and to easily provide an args kwd.</span>
    <span class="s1">ncalls </span><span class="s2">= [</span><span class="s6">0</span><span class="s2">]</span>
    <span class="s4">if </span><span class="s1">function </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">ncalls</span><span class="s2">, </span><span class="s4">None</span>

    <span class="s4">def </span><span class="s1">function_wrapper</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">wrapper_args</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">ncalls</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] &gt;= </span><span class="s1">maxfun</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">_MaxFuncCallError</span><span class="s2">(</span><span class="s3">&quot;Too many function calls&quot;</span><span class="s2">)</span>
        <span class="s1">ncalls</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] += </span><span class="s6">1</span>
        <span class="s0"># A copy of x is sent to the user function (gh13740)</span>
        <span class="s1">fx </span><span class="s2">= </span><span class="s1">function</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), *(</span><span class="s1">wrapper_args </span><span class="s2">+ </span><span class="s1">args</span><span class="s2">))</span>
        <span class="s0"># Ideally, we'd like to a have a true scalar returned from f(x). For</span>
        <span class="s0"># backwards-compatibility, also allow np.array([1.3]),</span>
        <span class="s0"># np.array([[1.3]]) etc.</span>
        <span class="s4">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isscalar</span><span class="s2">(</span><span class="s1">fx</span><span class="s2">):</span>
            <span class="s4">try</span><span class="s2">:</span>
                <span class="s1">fx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">fx</span><span class="s2">).</span><span class="s1">item</span><span class="s2">()</span>
            <span class="s4">except </span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">) </span><span class="s4">as </span><span class="s1">e</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;The user-provided objective function &quot;</span>
                                 <span class="s3">&quot;must return a scalar value.&quot;</span><span class="s2">) </span><span class="s4">from </span><span class="s1">e</span>
        <span class="s4">return </span><span class="s1">fx</span>

    <span class="s4">return </span><span class="s1">ncalls</span><span class="s2">, </span><span class="s1">function_wrapper</span>


<span class="s4">def </span><span class="s1">fmin</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">xtol</span><span class="s2">=</span><span class="s6">1e-4</span><span class="s2">, </span><span class="s1">ftol</span><span class="s2">=</span><span class="s6">1e-4</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">maxfun</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
         <span class="s1">full_output</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s6">1</span><span class="s2">, </span><span class="s1">retall</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">initial_simplex</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Minimize a function using the downhill simplex algorithm. 
 
    This algorithm only uses function values, not derivatives or second 
    derivatives. 
 
    Parameters 
    ---------- 
    func : callable func(x,*args) 
        The objective function to be minimized. 
    x0 : ndarray 
        Initial guess. 
    args : tuple, optional 
        Extra arguments passed to func, i.e., ``f(x,*args)``. 
    xtol : float, optional 
        Absolute error in xopt between iterations that is acceptable for 
        convergence. 
    ftol : number, optional 
        Absolute error in func(xopt) between iterations that is acceptable for 
        convergence. 
    maxiter : int, optional 
        Maximum number of iterations to perform. 
    maxfun : number, optional 
        Maximum number of function evaluations to make. 
    full_output : bool, optional 
        Set to True if fopt and warnflag outputs are desired. 
    disp : bool, optional 
        Set to True to print convergence messages. 
    retall : bool, optional 
        Set to True to return list of solutions at each iteration. 
    callback : callable, optional 
        Called after each iteration, as callback(xk), where xk is the 
        current parameter vector. 
    initial_simplex : array_like of shape (N + 1, N), optional 
        Initial simplex. If given, overrides `x0`. 
        ``initial_simplex[j,:]`` should contain the coordinates of 
        the jth vertex of the ``N+1`` vertices in the simplex, where 
        ``N`` is the dimension. 
 
    Returns 
    ------- 
    xopt : ndarray 
        Parameter that minimizes function. 
    fopt : float 
        Value of function at minimum: ``fopt = func(xopt)``. 
    iter : int 
        Number of iterations performed. 
    funcalls : int 
        Number of function calls made. 
    warnflag : int 
        1 : Maximum number of function evaluations made. 
        2 : Maximum number of iterations reached. 
    allvecs : list 
        Solution at each iteration. 
 
    See also 
    -------- 
    minimize: Interface to minimization algorithms for multivariate 
        functions. See the 'Nelder-Mead' `method` in particular. 
 
    Notes 
    ----- 
    Uses a Nelder-Mead simplex algorithm to find the minimum of function of 
    one or more variables. 
 
    This algorithm has a long history of successful use in applications. 
    But it will usually be slower than an algorithm that uses first or 
    second derivative information. In practice, it can have poor 
    performance in high-dimensional problems and is not robust to 
    minimizing complicated functions. Additionally, there currently is no 
    complete theory describing when the algorithm will successfully 
    converge to the minimum, or how fast it will if it does. Both the ftol and 
    xtol criteria must be met for convergence. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; def f(x): 
    ...     return x**2 
 
    &gt;&gt;&gt; from scipy import optimize 
 
    &gt;&gt;&gt; minimum = optimize.fmin(f, 1) 
    Optimization terminated successfully. 
             Current function value: 0.000000 
             Iterations: 17 
             Function evaluations: 34 
    &gt;&gt;&gt; minimum[0] 
    -8.8817841970012523e-16 
 
    References 
    ---------- 
    .. [1] Nelder, J.A. and Mead, R. (1965), &quot;A simplex method for function 
           minimization&quot;, The Computer Journal, 7, pp. 308-313 
 
    .. [2] Wright, M.H. (1996), &quot;Direct Search Methods: Once Scorned, Now 
           Respectable&quot;, in Numerical Analysis 1995, Proceedings of the 
           1995 Dundee Biennial Conference in Numerical Analysis, D.F. 
           Griffiths and G.A. Watson (Eds.), Addison Wesley Longman, 
           Harlow, UK, pp. 191-208. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">opts </span><span class="s2">= {</span><span class="s3">'xatol'</span><span class="s2">: </span><span class="s1">xtol</span><span class="s2">,</span>
            <span class="s3">'fatol'</span><span class="s2">: </span><span class="s1">ftol</span><span class="s2">,</span>
            <span class="s3">'maxiter'</span><span class="s2">: </span><span class="s1">maxiter</span><span class="s2">,</span>
            <span class="s3">'maxfev'</span><span class="s2">: </span><span class="s1">maxfun</span><span class="s2">,</span>
            <span class="s3">'disp'</span><span class="s2">: </span><span class="s1">disp</span><span class="s2">,</span>
            <span class="s3">'return_all'</span><span class="s2">: </span><span class="s1">retall</span><span class="s2">,</span>
            <span class="s3">'initial_simplex'</span><span class="s2">: </span><span class="s1">initial_simplex</span><span class="s2">}</span>

    <span class="s1">callback </span><span class="s2">= </span><span class="s1">_wrap_callback</span><span class="s2">(</span><span class="s1">callback</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">_minimize_neldermead</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">=</span><span class="s1">callback</span><span class="s2">, **</span><span class="s1">opts</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">full_output</span><span class="s2">:</span>
        <span class="s1">retlist </span><span class="s2">= </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'fun'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'nit'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'nfev'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'status'</span><span class="s2">]</span>
        <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
            <span class="s1">retlist </span><span class="s2">+= (</span><span class="s1">res</span><span class="s2">[</span><span class="s3">'allvecs'</span><span class="s2">], )</span>
        <span class="s4">return </span><span class="s1">retlist</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'allvecs'</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">]</span>


<span class="s4">def </span><span class="s1">_minimize_neldermead</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">callback</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                         <span class="s1">maxiter</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">maxfev</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s4">False</span><span class="s2">,</span>
                         <span class="s1">return_all</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">initial_simplex</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                         <span class="s1">xatol</span><span class="s2">=</span><span class="s6">1e-4</span><span class="s2">, </span><span class="s1">fatol</span><span class="s2">=</span><span class="s6">1e-4</span><span class="s2">, </span><span class="s1">adaptive</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                         <span class="s2">**</span><span class="s1">unknown_options</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Minimization of scalar function of one or more variables using the 
    Nelder-Mead algorithm. 
 
    Options 
    ------- 
    disp : bool 
        Set to True to print convergence messages. 
    maxiter, maxfev : int 
        Maximum allowed number of iterations and function evaluations. 
        Will default to ``N*200``, where ``N`` is the number of 
        variables, if neither `maxiter` or `maxfev` is set. If both 
        `maxiter` and `maxfev` are set, minimization will stop at the 
        first reached. 
    return_all : bool, optional 
        Set to True to return a list of the best solution at each of the 
        iterations. 
    initial_simplex : array_like of shape (N + 1, N) 
        Initial simplex. If given, overrides `x0`. 
        ``initial_simplex[j,:]`` should contain the coordinates of 
        the jth vertex of the ``N+1`` vertices in the simplex, where 
        ``N`` is the dimension. 
    xatol : float, optional 
        Absolute error in xopt between iterations that is acceptable for 
        convergence. 
    fatol : number, optional 
        Absolute error in func(xopt) between iterations that is acceptable for 
        convergence. 
    adaptive : bool, optional 
        Adapt algorithm parameters to dimensionality of problem. Useful for 
        high-dimensional minimization [1]_. 
    bounds : sequence or `Bounds`, optional 
        Bounds on variables. There are two ways to specify the bounds: 
 
            1. Instance of `Bounds` class. 
            2. Sequence of ``(min, max)`` pairs for each element in `x`. None 
               is used to specify no bound. 
 
        Note that this just clips all vertices in simplex based on 
        the bounds. 
 
    References 
    ---------- 
    .. [1] Gao, F. and Han, L. 
       Implementing the Nelder-Mead simplex algorithm with adaptive 
       parameters. 2012. Computational Optimization and Applications. 
       51:1, pp. 259-277 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_unknown_options</span><span class="s2">(</span><span class="s1">unknown_options</span><span class="s2">)</span>
    <span class="s1">maxfun </span><span class="s2">= </span><span class="s1">maxfev</span>
    <span class="s1">retall </span><span class="s2">= </span><span class="s1">return_all</span>

    <span class="s1">x0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">).</span><span class="s1">flatten</span><span class="s2">()</span>
    <span class="s1">dtype </span><span class="s2">= </span><span class="s1">x0</span><span class="s2">.</span><span class="s1">dtype </span><span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inexact</span><span class="s2">) </span><span class="s4">else </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span>
    <span class="s1">x0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">adaptive</span><span class="s2">:</span>
        <span class="s1">dim </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">))</span>
        <span class="s1">rho </span><span class="s2">= </span><span class="s6">1</span>
        <span class="s1">chi </span><span class="s2">= </span><span class="s6">1 </span><span class="s2">+ </span><span class="s6">2</span><span class="s2">/</span><span class="s1">dim</span>
        <span class="s1">psi </span><span class="s2">= </span><span class="s6">0.75 </span><span class="s2">- </span><span class="s6">1</span><span class="s2">/(</span><span class="s6">2</span><span class="s2">*</span><span class="s1">dim</span><span class="s2">)</span>
        <span class="s1">sigma </span><span class="s2">= </span><span class="s6">1 </span><span class="s2">- </span><span class="s6">1</span><span class="s2">/</span><span class="s1">dim</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">rho </span><span class="s2">= </span><span class="s6">1</span>
        <span class="s1">chi </span><span class="s2">= </span><span class="s6">2</span>
        <span class="s1">psi </span><span class="s2">= </span><span class="s6">0.5</span>
        <span class="s1">sigma </span><span class="s2">= </span><span class="s6">0.5</span>

    <span class="s1">nonzdelt </span><span class="s2">= </span><span class="s6">0.05</span>
    <span class="s1">zdelt </span><span class="s2">= </span><span class="s6">0.00025</span>

    <span class="s4">if </span><span class="s1">bounds </span><span class="s4">is not None</span><span class="s2">:</span>
        <span class="s1">lower_bound</span><span class="s2">, </span><span class="s1">upper_bound </span><span class="s2">= </span><span class="s1">bounds</span><span class="s2">.</span><span class="s1">lb</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">.</span><span class="s1">ub</span>
        <span class="s0"># check bounds</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s1">lower_bound </span><span class="s2">&gt; </span><span class="s1">upper_bound</span><span class="s2">).</span><span class="s1">any</span><span class="s2">():</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Nelder Mead - one of the lower bounds &quot;</span>
                             <span class="s3">&quot;is greater than an upper bound.&quot;</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">lower_bound </span><span class="s2">&gt; </span><span class="s1">x0</span><span class="s2">) </span><span class="s4">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">x0 </span><span class="s2">&gt; </span><span class="s1">upper_bound</span><span class="s2">):</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s3">&quot;Initial guess is not within the specified bounds&quot;</span><span class="s2">,</span>
                          <span class="s1">OptimizeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">3</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">bounds </span><span class="s4">is not None</span><span class="s2">:</span>
        <span class="s1">x0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">, </span><span class="s1">lower_bound</span><span class="s2">, </span><span class="s1">upper_bound</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">initial_simplex </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">N </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">)</span>

        <span class="s1">sim </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s1">N </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">, </span><span class="s1">N</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">x0</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">sim</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] = </span><span class="s1">x0</span>
        <span class="s4">for </span><span class="s1">k </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">N</span><span class="s2">):</span>
            <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">y</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] != </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s1">y</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = (</span><span class="s6">1 </span><span class="s2">+ </span><span class="s1">nonzdelt</span><span class="s2">)*</span><span class="s1">y</span><span class="s2">[</span><span class="s1">k</span><span class="s2">]</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">y</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">zdelt</span>
            <span class="s1">sim</span><span class="s2">[</span><span class="s1">k </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">] = </span><span class="s1">y</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">sim </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_2d</span><span class="s2">(</span><span class="s1">initial_simplex</span><span class="s2">).</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">sim</span><span class="s2">.</span><span class="s1">dtype </span><span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">sim</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inexact</span><span class="s2">) </span><span class="s4">else </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span>
        <span class="s1">sim </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">sim</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">sim</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s6">2 </span><span class="s4">or </span><span class="s1">sim</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] != </span><span class="s1">sim</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">] + </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;`initial_simplex` should be an array of shape (N+1,N)&quot;</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">) != </span><span class="s1">sim</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Size of `initial_simplex` is not consistent with `x0`&quot;</span><span class="s2">)</span>
        <span class="s1">N </span><span class="s2">= </span><span class="s1">sim</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]</span>

    <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
        <span class="s1">allvecs </span><span class="s2">= [</span><span class="s1">sim</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]]</span>

    <span class="s0"># If neither are set, then set both to default</span>
    <span class="s4">if </span><span class="s1">maxiter </span><span class="s4">is None and </span><span class="s1">maxfun </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">N </span><span class="s2">* </span><span class="s6">200</span>
        <span class="s1">maxfun </span><span class="s2">= </span><span class="s1">N </span><span class="s2">* </span><span class="s6">200</span>
    <span class="s4">elif </span><span class="s1">maxiter </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s0"># Convert remaining Nones, to np.inf, unless the other is np.inf, in</span>
        <span class="s0"># which case use the default to avoid unbounded iteration</span>
        <span class="s4">if </span><span class="s1">maxfun </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">:</span>
            <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">N </span><span class="s2">* </span><span class="s6">200</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>
    <span class="s4">elif </span><span class="s1">maxfun </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">maxiter </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">:</span>
            <span class="s1">maxfun </span><span class="s2">= </span><span class="s1">N </span><span class="s2">* </span><span class="s6">200</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">maxfun </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>

    <span class="s4">if </span><span class="s1">bounds </span><span class="s4">is not None</span><span class="s2">:</span>
        <span class="s0"># The default simplex construction may make all entries (for a given</span>
        <span class="s0"># parameter) greater than an upper bound if x0 is very close to the</span>
        <span class="s0"># upper bound. If one simply clips the simplex to the bounds this could</span>
        <span class="s0"># make the simplex entries degenerate. If that occurs reflect into the</span>
        <span class="s0"># interior.</span>
        <span class="s1">msk </span><span class="s2">= </span><span class="s1">sim </span><span class="s2">&gt; </span><span class="s1">upper_bound</span>
        <span class="s0"># reflect into the interior</span>
        <span class="s1">sim </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">msk</span><span class="s2">, </span><span class="s6">2</span><span class="s2">*</span><span class="s1">upper_bound </span><span class="s2">- </span><span class="s1">sim</span><span class="s2">, </span><span class="s1">sim</span><span class="s2">)</span>
        <span class="s0"># but make sure the reflection is no less than the lower_bound</span>
        <span class="s1">sim </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">sim</span><span class="s2">, </span><span class="s1">lower_bound</span><span class="s2">, </span><span class="s1">upper_bound</span><span class="s2">)</span>

    <span class="s1">one2np1 </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s1">N </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">))</span>
    <span class="s1">fsim </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full</span><span class="s2">((</span><span class="s1">N </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">,), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">)</span>

    <span class="s1">fcalls</span><span class="s2">, </span><span class="s1">func </span><span class="s2">= </span><span class="s1">_wrap_scalar_function_maxfun_validation</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">maxfun</span><span class="s2">)</span>

    <span class="s4">try</span><span class="s2">:</span>
        <span class="s4">for </span><span class="s1">k </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">N </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">):</span>
            <span class="s1">fsim</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">func</span><span class="s2">(</span><span class="s1">sim</span><span class="s2">[</span><span class="s1">k</span><span class="s2">])</span>
    <span class="s4">except </span><span class="s1">_MaxFuncCallError</span><span class="s2">:</span>
        <span class="s4">pass</span>
    <span class="s4">finally</span><span class="s2">:</span>
        <span class="s1">ind </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argsort</span><span class="s2">(</span><span class="s1">fsim</span><span class="s2">)</span>
        <span class="s1">sim </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span><span class="s1">sim</span><span class="s2">, </span><span class="s1">ind</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>
        <span class="s1">fsim </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span><span class="s1">fsim</span><span class="s2">, </span><span class="s1">ind</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>

    <span class="s1">ind </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argsort</span><span class="s2">(</span><span class="s1">fsim</span><span class="s2">)</span>
    <span class="s1">fsim </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span><span class="s1">fsim</span><span class="s2">, </span><span class="s1">ind</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>
    <span class="s0"># sort so sim[0,:] has the lowest function value</span>
    <span class="s1">sim </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span><span class="s1">sim</span><span class="s2">, </span><span class="s1">ind</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>

    <span class="s1">iterations </span><span class="s2">= </span><span class="s6">1</span>

    <span class="s4">while </span><span class="s2">(</span><span class="s1">fcalls</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] &lt; </span><span class="s1">maxfun </span><span class="s4">and </span><span class="s1">iterations </span><span class="s2">&lt; </span><span class="s1">maxiter</span><span class="s2">):</span>
        <span class="s4">try</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">sim</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:] - </span><span class="s1">sim</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]))) &lt;= </span><span class="s1">xatol </span><span class="s4">and</span>
                    <span class="s1">np</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">fsim</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] - </span><span class="s1">fsim</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:])) &lt;= </span><span class="s1">fatol</span><span class="s2">):</span>
                <span class="s4">break</span>

            <span class="s1">xbar </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">add</span><span class="s2">.</span><span class="s1">reduce</span><span class="s2">(</span><span class="s1">sim</span><span class="s2">[:-</span><span class="s6">1</span><span class="s2">], </span><span class="s6">0</span><span class="s2">) / </span><span class="s1">N</span>
            <span class="s1">xr </span><span class="s2">= (</span><span class="s6">1 </span><span class="s2">+ </span><span class="s1">rho</span><span class="s2">) * </span><span class="s1">xbar </span><span class="s2">- </span><span class="s1">rho </span><span class="s2">* </span><span class="s1">sim</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]</span>
            <span class="s4">if </span><span class="s1">bounds </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s1">xr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">xr</span><span class="s2">, </span><span class="s1">lower_bound</span><span class="s2">, </span><span class="s1">upper_bound</span><span class="s2">)</span>
            <span class="s1">fxr </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">xr</span><span class="s2">)</span>
            <span class="s1">doshrink </span><span class="s2">= </span><span class="s6">0</span>

            <span class="s4">if </span><span class="s1">fxr </span><span class="s2">&lt; </span><span class="s1">fsim</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]:</span>
                <span class="s1">xe </span><span class="s2">= (</span><span class="s6">1 </span><span class="s2">+ </span><span class="s1">rho </span><span class="s2">* </span><span class="s1">chi</span><span class="s2">) * </span><span class="s1">xbar </span><span class="s2">- </span><span class="s1">rho </span><span class="s2">* </span><span class="s1">chi </span><span class="s2">* </span><span class="s1">sim</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]</span>
                <span class="s4">if </span><span class="s1">bounds </span><span class="s4">is not None</span><span class="s2">:</span>
                    <span class="s1">xe </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">xe</span><span class="s2">, </span><span class="s1">lower_bound</span><span class="s2">, </span><span class="s1">upper_bound</span><span class="s2">)</span>
                <span class="s1">fxe </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">xe</span><span class="s2">)</span>

                <span class="s4">if </span><span class="s1">fxe </span><span class="s2">&lt; </span><span class="s1">fxr</span><span class="s2">:</span>
                    <span class="s1">sim</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] = </span><span class="s1">xe</span>
                    <span class="s1">fsim</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] = </span><span class="s1">fxe</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">sim</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] = </span><span class="s1">xr</span>
                    <span class="s1">fsim</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] = </span><span class="s1">fxr</span>
            <span class="s4">else</span><span class="s2">:  </span><span class="s0"># fsim[0] &lt;= fxr</span>
                <span class="s4">if </span><span class="s1">fxr </span><span class="s2">&lt; </span><span class="s1">fsim</span><span class="s2">[-</span><span class="s6">2</span><span class="s2">]:</span>
                    <span class="s1">sim</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] = </span><span class="s1">xr</span>
                    <span class="s1">fsim</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] = </span><span class="s1">fxr</span>
                <span class="s4">else</span><span class="s2">:  </span><span class="s0"># fxr &gt;= fsim[-2]</span>
                    <span class="s0"># Perform contraction</span>
                    <span class="s4">if </span><span class="s1">fxr </span><span class="s2">&lt; </span><span class="s1">fsim</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]:</span>
                        <span class="s1">xc </span><span class="s2">= (</span><span class="s6">1 </span><span class="s2">+ </span><span class="s1">psi </span><span class="s2">* </span><span class="s1">rho</span><span class="s2">) * </span><span class="s1">xbar </span><span class="s2">- </span><span class="s1">psi </span><span class="s2">* </span><span class="s1">rho </span><span class="s2">* </span><span class="s1">sim</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]</span>
                        <span class="s4">if </span><span class="s1">bounds </span><span class="s4">is not None</span><span class="s2">:</span>
                            <span class="s1">xc </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">xc</span><span class="s2">, </span><span class="s1">lower_bound</span><span class="s2">, </span><span class="s1">upper_bound</span><span class="s2">)</span>
                        <span class="s1">fxc </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">xc</span><span class="s2">)</span>

                        <span class="s4">if </span><span class="s1">fxc </span><span class="s2">&lt;= </span><span class="s1">fxr</span><span class="s2">:</span>
                            <span class="s1">sim</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] = </span><span class="s1">xc</span>
                            <span class="s1">fsim</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] = </span><span class="s1">fxc</span>
                        <span class="s4">else</span><span class="s2">:</span>
                            <span class="s1">doshrink </span><span class="s2">= </span><span class="s6">1</span>
                    <span class="s4">else</span><span class="s2">:</span>
                        <span class="s0"># Perform an inside contraction</span>
                        <span class="s1">xcc </span><span class="s2">= (</span><span class="s6">1 </span><span class="s2">- </span><span class="s1">psi</span><span class="s2">) * </span><span class="s1">xbar </span><span class="s2">+ </span><span class="s1">psi </span><span class="s2">* </span><span class="s1">sim</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]</span>
                        <span class="s4">if </span><span class="s1">bounds </span><span class="s4">is not None</span><span class="s2">:</span>
                            <span class="s1">xcc </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span><span class="s1">xcc</span><span class="s2">, </span><span class="s1">lower_bound</span><span class="s2">, </span><span class="s1">upper_bound</span><span class="s2">)</span>
                        <span class="s1">fxcc </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">xcc</span><span class="s2">)</span>

                        <span class="s4">if </span><span class="s1">fxcc </span><span class="s2">&lt; </span><span class="s1">fsim</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]:</span>
                            <span class="s1">sim</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] = </span><span class="s1">xcc</span>
                            <span class="s1">fsim</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] = </span><span class="s1">fxcc</span>
                        <span class="s4">else</span><span class="s2">:</span>
                            <span class="s1">doshrink </span><span class="s2">= </span><span class="s6">1</span>

                    <span class="s4">if </span><span class="s1">doshrink</span><span class="s2">:</span>
                        <span class="s4">for </span><span class="s1">j </span><span class="s4">in </span><span class="s1">one2np1</span><span class="s2">:</span>
                            <span class="s1">sim</span><span class="s2">[</span><span class="s1">j</span><span class="s2">] = </span><span class="s1">sim</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] + </span><span class="s1">sigma </span><span class="s2">* (</span><span class="s1">sim</span><span class="s2">[</span><span class="s1">j</span><span class="s2">] - </span><span class="s1">sim</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>
                            <span class="s4">if </span><span class="s1">bounds </span><span class="s4">is not None</span><span class="s2">:</span>
                                <span class="s1">sim</span><span class="s2">[</span><span class="s1">j</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">clip</span><span class="s2">(</span>
                                    <span class="s1">sim</span><span class="s2">[</span><span class="s1">j</span><span class="s2">], </span><span class="s1">lower_bound</span><span class="s2">, </span><span class="s1">upper_bound</span><span class="s2">)</span>
                            <span class="s1">fsim</span><span class="s2">[</span><span class="s1">j</span><span class="s2">] = </span><span class="s1">func</span><span class="s2">(</span><span class="s1">sim</span><span class="s2">[</span><span class="s1">j</span><span class="s2">])</span>
            <span class="s1">iterations </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s4">except </span><span class="s1">_MaxFuncCallError</span><span class="s2">:</span>
            <span class="s4">pass</span>
        <span class="s4">finally</span><span class="s2">:</span>
            <span class="s1">ind </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argsort</span><span class="s2">(</span><span class="s1">fsim</span><span class="s2">)</span>
            <span class="s1">sim </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span><span class="s1">sim</span><span class="s2">, </span><span class="s1">ind</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>
            <span class="s1">fsim </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span><span class="s1">fsim</span><span class="s2">, </span><span class="s1">ind</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
                <span class="s1">allvecs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">sim</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>
            <span class="s1">intermediate_result </span><span class="s2">= </span><span class="s1">OptimizeResult</span><span class="s2">(</span><span class="s1">x</span><span class="s2">=</span><span class="s1">sim</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">fun</span><span class="s2">=</span><span class="s1">fsim</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>
            <span class="s4">if </span><span class="s1">_call_callback_maybe_halt</span><span class="s2">(</span><span class="s1">callback</span><span class="s2">, </span><span class="s1">intermediate_result</span><span class="s2">):</span>
                <span class="s4">break</span>

    <span class="s1">x </span><span class="s2">= </span><span class="s1">sim</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
    <span class="s1">fval </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">fsim</span><span class="s2">)</span>
    <span class="s1">warnflag </span><span class="s2">= </span><span class="s6">0</span>

    <span class="s4">if </span><span class="s1">fcalls</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] &gt;= </span><span class="s1">maxfun</span><span class="s2">:</span>
        <span class="s1">warnflag </span><span class="s2">= </span><span class="s6">1</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'maxfev'</span><span class="s2">]</span>
        <span class="s4">if </span><span class="s1">disp</span><span class="s2">:</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">3</span><span class="s2">)</span>
    <span class="s4">elif </span><span class="s1">iterations </span><span class="s2">&gt;= </span><span class="s1">maxiter</span><span class="s2">:</span>
        <span class="s1">warnflag </span><span class="s2">= </span><span class="s6">2</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'maxiter'</span><span class="s2">]</span>
        <span class="s4">if </span><span class="s1">disp</span><span class="s2">:</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">3</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'success'</span><span class="s2">]</span>
        <span class="s4">if </span><span class="s1">disp</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Current function value: %f&quot; </span><span class="s2">% </span><span class="s1">fval</span><span class="s2">)</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Iterations: %d&quot; </span><span class="s2">% </span><span class="s1">iterations</span><span class="s2">)</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Function evaluations: %d&quot; </span><span class="s2">% </span><span class="s1">fcalls</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>

    <span class="s1">result </span><span class="s2">= </span><span class="s1">OptimizeResult</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">=</span><span class="s1">fval</span><span class="s2">, </span><span class="s1">nit</span><span class="s2">=</span><span class="s1">iterations</span><span class="s2">, </span><span class="s1">nfev</span><span class="s2">=</span><span class="s1">fcalls</span><span class="s2">[</span><span class="s6">0</span><span class="s2">],</span>
                            <span class="s1">status</span><span class="s2">=</span><span class="s1">warnflag</span><span class="s2">, </span><span class="s1">success</span><span class="s2">=(</span><span class="s1">warnflag </span><span class="s2">== </span><span class="s6">0</span><span class="s2">),</span>
                            <span class="s1">message</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">x</span><span class="s2">=</span><span class="s1">x</span><span class="s2">, </span><span class="s1">final_simplex</span><span class="s2">=(</span><span class="s1">sim</span><span class="s2">, </span><span class="s1">fsim</span><span class="s2">))</span>
    <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
        <span class="s1">result</span><span class="s2">[</span><span class="s3">'allvecs'</span><span class="s2">] = </span><span class="s1">allvecs</span>
    <span class="s4">return </span><span class="s1">result</span>


<span class="s4">def </span><span class="s1">approx_fprime</span><span class="s2">(</span><span class="s1">xk</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">epsilon</span><span class="s2">=</span><span class="s1">_epsilon</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Finite difference approximation of the derivatives of a 
    scalar or vector-valued function. 
 
    If a function maps from :math:`R^n` to :math:`R^m`, its derivatives form 
    an m-by-n matrix 
    called the Jacobian, where an element :math:`(i, j)` is a partial 
    derivative of f[i] with respect to ``xk[j]``. 
 
    Parameters 
    ---------- 
    xk : array_like 
        The coordinate vector at which to determine the gradient of `f`. 
    f : callable 
        Function of which to estimate the derivatives of. Has the signature 
        ``f(xk, *args)`` where `xk` is the argument in the form of a 1-D array 
        and `args` is a tuple of any additional fixed parameters needed to 
        completely specify the function. The argument `xk` passed to this 
        function is an ndarray of shape (n,) (never a scalar even if n=1). 
        It must return a 1-D array_like of shape (m,) or a scalar. 
 
        .. versionchanged:: 1.9.0 
            `f` is now able to return a 1-D array-like, with the :math:`(m, n)` 
            Jacobian being estimated. 
 
    epsilon : {float, array_like}, optional 
        Increment to `xk` to use for determining the function gradient. 
        If a scalar, uses the same finite difference delta for all partial 
        derivatives. If an array, should contain one value per element of 
        `xk`. Defaults to ``sqrt(np.finfo(float).eps)``, which is approximately 
        1.49e-08. 
    \\*args : args, optional 
        Any other arguments that are to be passed to `f`. 
 
    Returns 
    ------- 
    jac : ndarray 
        The partial derivatives of `f` to `xk`. 
 
    See Also 
    -------- 
    check_grad : Check correctness of gradient function against approx_fprime. 
 
    Notes 
    ----- 
    The function gradient is determined by the forward finite difference 
    formula:: 
 
                 f(xk[i] + epsilon[i]) - f(xk[i]) 
        f'[i] = --------------------------------- 
                            epsilon[i] 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import optimize 
    &gt;&gt;&gt; def func(x, c0, c1): 
    ...     &quot;Coordinate vector `x` should be an array of size two.&quot; 
    ...     return c0 * x[0]**2 + c1*x[1]**2 
 
    &gt;&gt;&gt; x = np.ones(2) 
    &gt;&gt;&gt; c0, c1 = (1, 200) 
    &gt;&gt;&gt; eps = np.sqrt(np.finfo(float).eps) 
    &gt;&gt;&gt; optimize.approx_fprime(x, func, [eps, np.sqrt(200) * eps], c0, c1) 
    array([   2.        ,  400.00004208]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xk </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">xk</span><span class="s2">, </span><span class="s1">float</span><span class="s2">)</span>
    <span class="s1">f0 </span><span class="s2">= </span><span class="s1">f</span><span class="s2">(</span><span class="s1">xk</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>

    <span class="s4">return </span><span class="s1">approx_derivative</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">xk</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s3">'2-point'</span><span class="s2">, </span><span class="s1">abs_step</span><span class="s2">=</span><span class="s1">epsilon</span><span class="s2">,</span>
                             <span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">, </span><span class="s1">f0</span><span class="s2">=</span><span class="s1">f0</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">check_grad</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">grad</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">, </span><span class="s1">epsilon</span><span class="s2">=</span><span class="s1">_epsilon</span><span class="s2">,</span>
                <span class="s1">direction</span><span class="s2">=</span><span class="s3">'all'</span><span class="s2">, </span><span class="s1">seed</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Check the correctness of a gradient function by comparing it against a 
    (forward) finite-difference approximation of the gradient. 
 
    Parameters 
    ---------- 
    func : callable ``func(x0, *args)`` 
        Function whose derivative is to be checked. 
    grad : callable ``grad(x0, *args)`` 
        Jacobian of `func`. 
    x0 : ndarray 
        Points to check `grad` against forward difference approximation of grad 
        using `func`. 
    args : \\*args, optional 
        Extra arguments passed to `func` and `grad`. 
    epsilon : float, optional 
        Step size used for the finite difference approximation. It defaults to 
        ``sqrt(np.finfo(float).eps)``, which is approximately 1.49e-08. 
    direction : str, optional 
        If set to ``'random'``, then gradients along a random vector 
        are used to check `grad` against forward difference approximation 
        using `func`. By default it is ``'all'``, in which case, all 
        the one hot direction vectors are considered to check `grad`. 
        If `func` is a vector valued function then only ``'all'`` can be used. 
    seed : {None, int, `numpy.random.Generator`, `numpy.random.RandomState`}, optional 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``RandomState`` instance is used, 
        seeded with `seed`. 
        If `seed` is already a ``Generator`` or ``RandomState`` instance then 
        that instance is used. 
        Specify `seed` for reproducing the return value from this function. 
        The random numbers generated with this seed affect the random vector 
        along which gradients are computed to check ``grad``. Note that `seed` 
        is only used when `direction` argument is set to `'random'`. 
 
    Returns 
    ------- 
    err : float 
        The square root of the sum of squares (i.e., the 2-norm) of the 
        difference between ``grad(x0, *args)`` and the finite difference 
        approximation of `grad` using func at the points `x0`. 
 
    See Also 
    -------- 
    approx_fprime 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; def func(x): 
    ...     return x[0]**2 - 0.5 * x[1]**3 
    &gt;&gt;&gt; def grad(x): 
    ...     return [2 * x[0], -1.5 * x[1]**2] 
    &gt;&gt;&gt; from scipy.optimize import check_grad 
    &gt;&gt;&gt; check_grad(func, grad, [1.5, -1.5]) 
    2.9802322387695312e-08  # may vary 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; check_grad(func, grad, [1.5, -1.5], 
    ...             direction='random', seed=rng) 
    2.9802322387695312e-08 
 
    &quot;&quot;&quot;</span>
    <span class="s1">step </span><span class="s2">= </span><span class="s1">epsilon</span>
    <span class="s1">x0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">)</span>

    <span class="s4">def </span><span class="s1">g</span><span class="s2">(</span><span class="s1">w</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x0 </span><span class="s2">+ </span><span class="s1">w</span><span class="s2">*</span><span class="s1">v</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">direction </span><span class="s2">== </span><span class="s3">'random'</span><span class="s2">:</span>
        <span class="s1">_grad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">grad</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">))</span>
        <span class="s4">if </span><span class="s1">_grad</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;'random' can only be used with scalar valued&quot;</span>
                             <span class="s3">&quot; func&quot;</span><span class="s2">)</span>
        <span class="s1">random_state </span><span class="s2">= </span><span class="s1">check_random_state</span><span class="s2">(</span><span class="s1">seed</span><span class="s2">)</span>
        <span class="s1">v </span><span class="s2">= </span><span class="s1">random_state</span><span class="s2">.</span><span class="s1">normal</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s6">1</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=(</span><span class="s1">x0</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">))</span>
        <span class="s1">_args </span><span class="s2">= (</span><span class="s1">func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">v</span><span class="s2">) + </span><span class="s1">args</span>
        <span class="s1">_func </span><span class="s2">= </span><span class="s1">g</span>
        <span class="s1">vars </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s6">1</span><span class="s2">,))</span>
        <span class="s1">analytical_grad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">_grad</span><span class="s2">, </span><span class="s1">v</span><span class="s2">)</span>
    <span class="s4">elif </span><span class="s1">direction </span><span class="s2">== </span><span class="s3">'all'</span><span class="s2">:</span>
        <span class="s1">_args </span><span class="s2">= </span><span class="s1">args</span>
        <span class="s1">_func </span><span class="s2">= </span><span class="s1">func</span>
        <span class="s1">vars </span><span class="s2">= </span><span class="s1">x0</span>
        <span class="s1">analytical_grad </span><span class="s2">= </span><span class="s1">grad</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f&quot;</span><span class="s4">{</span><span class="s1">direction</span><span class="s4">} </span><span class="s3">is not a valid string for &quot;</span>
                         <span class="s3">&quot;``direction`` argument&quot;</span><span class="s2">)</span>

    <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span>
        <span class="s2">(</span><span class="s1">analytical_grad </span><span class="s2">- </span><span class="s1">approx_fprime</span><span class="s2">(</span><span class="s1">vars</span><span class="s2">, </span><span class="s1">_func</span><span class="s2">, </span><span class="s1">step</span><span class="s2">, *</span><span class="s1">_args</span><span class="s2">))**</span><span class="s6">2</span>
    <span class="s2">)))</span>


<span class="s4">def </span><span class="s1">approx_fhess_p</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">, </span><span class="s1">epsilon</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">):</span>
    <span class="s0"># calculate fprime(x0) first, as this may be cached by ScalarFunction</span>
    <span class="s1">f1 </span><span class="s2">= </span><span class="s1">fprime</span><span class="s2">(*((</span><span class="s1">x0</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
    <span class="s1">f2 </span><span class="s2">= </span><span class="s1">fprime</span><span class="s2">(*((</span><span class="s1">x0 </span><span class="s2">+ </span><span class="s1">epsilon</span><span class="s2">*</span><span class="s1">p</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
    <span class="s4">return </span><span class="s2">(</span><span class="s1">f2 </span><span class="s2">- </span><span class="s1">f1</span><span class="s2">) / </span><span class="s1">epsilon</span>


<span class="s4">class </span><span class="s1">_LineSearchError</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">):</span>
    <span class="s4">pass</span>


<span class="s4">def </span><span class="s1">_line_search_wolfe12</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">, </span><span class="s1">xk</span><span class="s2">, </span><span class="s1">pk</span><span class="s2">, </span><span class="s1">gfk</span><span class="s2">, </span><span class="s1">old_fval</span><span class="s2">, </span><span class="s1">old_old_fval</span><span class="s2">,</span>
                         <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Same as line_search_wolfe1, but fall back to line_search_wolfe2 if 
    suitable step length is not found, and raise an exception if a 
    suitable step length is not found. 
 
    Raises 
    ------ 
    _LineSearchError 
        If no suitable step size is found 
 
    &quot;&quot;&quot;</span>

    <span class="s1">extra_condition </span><span class="s2">= </span><span class="s1">kwargs</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'extra_condition'</span><span class="s2">, </span><span class="s4">None</span><span class="s2">)</span>

    <span class="s1">ret </span><span class="s2">= </span><span class="s1">line_search_wolfe1</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">, </span><span class="s1">xk</span><span class="s2">, </span><span class="s1">pk</span><span class="s2">, </span><span class="s1">gfk</span><span class="s2">,</span>
                             <span class="s1">old_fval</span><span class="s2">, </span><span class="s1">old_old_fval</span><span class="s2">,</span>
                             <span class="s2">**</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">ret</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] </span><span class="s4">is not None and </span><span class="s1">extra_condition </span><span class="s4">is not None</span><span class="s2">:</span>
        <span class="s1">xp1 </span><span class="s2">= </span><span class="s1">xk </span><span class="s2">+ </span><span class="s1">ret</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] * </span><span class="s1">pk</span>
        <span class="s4">if not </span><span class="s1">extra_condition</span><span class="s2">(</span><span class="s1">ret</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">xp1</span><span class="s2">, </span><span class="s1">ret</span><span class="s2">[</span><span class="s6">3</span><span class="s2">], </span><span class="s1">ret</span><span class="s2">[</span><span class="s6">5</span><span class="s2">]):</span>
            <span class="s0"># Reject step if extra_condition fails</span>
            <span class="s1">ret </span><span class="s2">= (</span><span class="s4">None</span><span class="s2">,)</span>

    <span class="s4">if </span><span class="s1">ret</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s0"># line search failed: try different one.</span>
        <span class="s4">with </span><span class="s1">warnings</span><span class="s2">.</span><span class="s1">catch_warnings</span><span class="s2">():</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">simplefilter</span><span class="s2">(</span><span class="s3">'ignore'</span><span class="s2">, </span><span class="s1">LineSearchWarning</span><span class="s2">)</span>
            <span class="s1">kwargs2 </span><span class="s2">= {}</span>
            <span class="s4">for </span><span class="s1">key </span><span class="s4">in </span><span class="s2">(</span><span class="s3">'c1'</span><span class="s2">, </span><span class="s3">'c2'</span><span class="s2">, </span><span class="s3">'amax'</span><span class="s2">):</span>
                <span class="s4">if </span><span class="s1">key </span><span class="s4">in </span><span class="s1">kwargs</span><span class="s2">:</span>
                    <span class="s1">kwargs2</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s1">kwargs</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]</span>
            <span class="s1">ret </span><span class="s2">= </span><span class="s1">line_search_wolfe2</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">, </span><span class="s1">xk</span><span class="s2">, </span><span class="s1">pk</span><span class="s2">, </span><span class="s1">gfk</span><span class="s2">,</span>
                                     <span class="s1">old_fval</span><span class="s2">, </span><span class="s1">old_old_fval</span><span class="s2">,</span>
                                     <span class="s1">extra_condition</span><span class="s2">=</span><span class="s1">extra_condition</span><span class="s2">,</span>
                                     <span class="s2">**</span><span class="s1">kwargs2</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">ret</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">_LineSearchError</span><span class="s2">()</span>

    <span class="s4">return </span><span class="s1">ret</span>


<span class="s4">def </span><span class="s1">fmin_bfgs</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">gtol</span><span class="s2">=</span><span class="s6">1e-5</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">,</span>
              <span class="s1">epsilon</span><span class="s2">=</span><span class="s1">_epsilon</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s6">1</span><span class="s2">,</span>
              <span class="s1">retall</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">xrtol</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">c1</span><span class="s2">=</span><span class="s6">1e-4</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">=</span><span class="s6">0.9</span><span class="s2">,</span>
              <span class="s1">hess_inv0</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Minimize a function using the BFGS algorithm. 
 
    Parameters 
    ---------- 
    f : callable ``f(x,*args)`` 
        Objective function to be minimized. 
    x0 : ndarray 
        Initial guess, shape (n,) 
    fprime : callable ``f'(x,*args)``, optional 
        Gradient of f. 
    args : tuple, optional 
        Extra arguments passed to f and fprime. 
    gtol : float, optional 
        Terminate successfully if gradient norm is less than `gtol` 
    norm : float, optional 
        Order of norm (Inf is max, -Inf is min) 
    epsilon : int or ndarray, optional 
        If `fprime` is approximated, use this value for the step size. 
    callback : callable, optional 
        An optional user-supplied function to call after each 
        iteration. Called as ``callback(xk)``, where ``xk`` is the 
        current parameter vector. 
    maxiter : int, optional 
        Maximum number of iterations to perform. 
    full_output : bool, optional 
        If True, return ``fopt``, ``func_calls``, ``grad_calls``, and 
        ``warnflag`` in addition to ``xopt``. 
    disp : bool, optional 
        Print convergence message if True. 
    retall : bool, optional 
        Return a list of results at each iteration if True. 
    xrtol : float, default: 0 
        Relative tolerance for `x`. Terminate successfully if step 
        size is less than ``xk * xrtol`` where ``xk`` is the current 
        parameter vector. 
    c1 : float, default: 1e-4 
        Parameter for Armijo condition rule. 
    c2 : float, default: 0.9 
        Parameter for curvature condition rule. 
    hess_inv0 : None or ndarray, optional`` 
        Initial inverse hessian estimate, shape (n, n). If None (default) then 
        the identity matrix is used. 
 
    Returns 
    ------- 
    xopt : ndarray 
        Parameters which minimize f, i.e., ``f(xopt) == fopt``. 
    fopt : float 
        Minimum value. 
    gopt : ndarray 
        Value of gradient at minimum, f'(xopt), which should be near 0. 
    Bopt : ndarray 
        Value of 1/f''(xopt), i.e., the inverse Hessian matrix. 
    func_calls : int 
        Number of function_calls made. 
    grad_calls : int 
        Number of gradient calls made. 
    warnflag : integer 
        1 : Maximum number of iterations exceeded. 
        2 : Gradient and/or function calls not changing. 
        3 : NaN result encountered. 
    allvecs : list 
        The value of `xopt` at each iteration. Only returned if `retall` is 
        True. 
 
    Notes 
    ----- 
    Optimize the function, `f`, whose gradient is given by `fprime` 
    using the quasi-Newton method of Broyden, Fletcher, Goldfarb, 
    and Shanno (BFGS). 
 
    Parameters `c1` and `c2` must satisfy ``0 &lt; c1 &lt; c2 &lt; 1``. 
 
    See Also 
    -------- 
    minimize: Interface to minimization algorithms for multivariate 
        functions. See ``method='BFGS'`` in particular. 
 
    References 
    ---------- 
    Wright, and Nocedal 'Numerical Optimization', 1999, p. 198. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.optimize import fmin_bfgs 
    &gt;&gt;&gt; def quadratic_cost(x, Q): 
    ...     return x @ Q @ x 
    ... 
    &gt;&gt;&gt; x0 = np.array([-3, -4]) 
    &gt;&gt;&gt; cost_weight =  np.diag([1., 10.]) 
    &gt;&gt;&gt; # Note that a trailing comma is necessary for a tuple with single element 
    &gt;&gt;&gt; fmin_bfgs(quadratic_cost, x0, args=(cost_weight,)) 
    Optimization terminated successfully. 
            Current function value: 0.000000 
            Iterations: 7                   # may vary 
            Function evaluations: 24        # may vary 
            Gradient evaluations: 8         # may vary 
    array([ 2.85169950e-06, -4.61820139e-07]) 
 
    &gt;&gt;&gt; def quadratic_cost_grad(x, Q): 
    ...     return 2 * Q @ x 
    ... 
    &gt;&gt;&gt; fmin_bfgs(quadratic_cost, x0, quadratic_cost_grad, args=(cost_weight,)) 
    Optimization terminated successfully. 
            Current function value: 0.000000 
            Iterations: 7 
            Function evaluations: 8 
            Gradient evaluations: 8 
    array([ 2.85916637e-06, -4.54371951e-07]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">opts </span><span class="s2">= {</span><span class="s3">'gtol'</span><span class="s2">: </span><span class="s1">gtol</span><span class="s2">,</span>
            <span class="s3">'norm'</span><span class="s2">: </span><span class="s1">norm</span><span class="s2">,</span>
            <span class="s3">'eps'</span><span class="s2">: </span><span class="s1">epsilon</span><span class="s2">,</span>
            <span class="s3">'disp'</span><span class="s2">: </span><span class="s1">disp</span><span class="s2">,</span>
            <span class="s3">'maxiter'</span><span class="s2">: </span><span class="s1">maxiter</span><span class="s2">,</span>
            <span class="s3">'return_all'</span><span class="s2">: </span><span class="s1">retall</span><span class="s2">,</span>
            <span class="s3">'xrtol'</span><span class="s2">: </span><span class="s1">xrtol</span><span class="s2">,</span>
            <span class="s3">'c1'</span><span class="s2">: </span><span class="s1">c1</span><span class="s2">,</span>
            <span class="s3">'c2'</span><span class="s2">: </span><span class="s1">c2</span><span class="s2">,</span>
            <span class="s3">'hess_inv0'</span><span class="s2">: </span><span class="s1">hess_inv0</span><span class="s2">}</span>

    <span class="s1">callback </span><span class="s2">= </span><span class="s1">_wrap_callback</span><span class="s2">(</span><span class="s1">callback</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">_minimize_bfgs</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">=</span><span class="s1">callback</span><span class="s2">, **</span><span class="s1">opts</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">full_output</span><span class="s2">:</span>
        <span class="s1">retlist </span><span class="s2">= (</span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'fun'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'jac'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'hess_inv'</span><span class="s2">],</span>
                   <span class="s1">res</span><span class="s2">[</span><span class="s3">'nfev'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'njev'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'status'</span><span class="s2">])</span>
        <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
            <span class="s1">retlist </span><span class="s2">+= (</span><span class="s1">res</span><span class="s2">[</span><span class="s3">'allvecs'</span><span class="s2">], )</span>
        <span class="s4">return </span><span class="s1">retlist</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'allvecs'</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">]</span>


<span class="s4">def </span><span class="s1">_minimize_bfgs</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">jac</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                   <span class="s1">gtol</span><span class="s2">=</span><span class="s6">1e-5</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">eps</span><span class="s2">=</span><span class="s1">_epsilon</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                   <span class="s1">disp</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">return_all</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">finite_diff_rel_step</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                   <span class="s1">xrtol</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">c1</span><span class="s2">=</span><span class="s6">1e-4</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">=</span><span class="s6">0.9</span><span class="s2">,</span>
                   <span class="s1">hess_inv0</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, **</span><span class="s1">unknown_options</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Minimization of scalar function of one or more variables using the 
    BFGS algorithm. 
 
    Options 
    ------- 
    disp : bool 
        Set to True to print convergence messages. 
    maxiter : int 
        Maximum number of iterations to perform. 
    gtol : float 
        Terminate successfully if gradient norm is less than `gtol`. 
    norm : float 
        Order of norm (Inf is max, -Inf is min). 
    eps : float or ndarray 
        If `jac is None` the absolute step size used for numerical 
        approximation of the jacobian via forward differences. 
    return_all : bool, optional 
        Set to True to return a list of the best solution at each of the 
        iterations. 
    finite_diff_rel_step : None or array_like, optional 
        If `jac in ['2-point', '3-point', 'cs']` the relative step size to 
        use for numerical approximation of the jacobian. The absolute step 
        size is computed as ``h = rel_step * sign(x) * max(1, abs(x))``, 
        possibly adjusted to fit into the bounds. For ``jac='3-point'`` 
        the sign of `h` is ignored. If None (default) then step is selected 
        automatically. 
    xrtol : float, default: 0 
        Relative tolerance for `x`. Terminate successfully if step size is 
        less than ``xk * xrtol`` where ``xk`` is the current parameter vector. 
    c1 : float, default: 1e-4 
        Parameter for Armijo condition rule. 
    c2 : float, default: 0.9 
        Parameter for curvature condition rule. 
    hess_inv0 : None or ndarray, optional 
        Initial inverse hessian estimate, shape (n, n). If None (default) then 
        the identity matrix is used. 
 
    Notes 
    ----- 
    Parameters `c1` and `c2` must satisfy ``0 &lt; c1 &lt; c2 &lt; 1``. 
 
    If minimization doesn't complete successfully, with an error message of 
    ``Desired error not necessarily achieved due to precision loss``, then 
    consider setting `gtol` to a higher value. This precision loss typically 
    occurs when the (finite difference) numerical differentiation cannot provide 
    sufficient precision to satisfy the `gtol` termination criterion. 
    This can happen when working in single precision and a callable jac is not 
    provided. For single precision problems a `gtol` of 1e-3 seems to work. 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_unknown_options</span><span class="s2">(</span><span class="s1">unknown_options</span><span class="s2">)</span>
    <span class="s1">_check_positive_definite</span><span class="s2">(</span><span class="s1">hess_inv0</span><span class="s2">)</span>
    <span class="s1">retall </span><span class="s2">= </span><span class="s1">return_all</span>

    <span class="s1">x0 </span><span class="s2">= </span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">).</span><span class="s1">flatten</span><span class="s2">()</span>
    <span class="s4">if </span><span class="s1">x0</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
        <span class="s1">x0</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">= (</span><span class="s6">1</span><span class="s2">,)</span>
    <span class="s4">if </span><span class="s1">maxiter </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">) * </span><span class="s6">200</span>

    <span class="s1">sf </span><span class="s2">= </span><span class="s1">_prepare_scalar_function</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">jac</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">, </span><span class="s1">epsilon</span><span class="s2">=</span><span class="s1">eps</span><span class="s2">,</span>
                                  <span class="s1">finite_diff_rel_step</span><span class="s2">=</span><span class="s1">finite_diff_rel_step</span><span class="s2">)</span>

    <span class="s1">f </span><span class="s2">= </span><span class="s1">sf</span><span class="s2">.</span><span class="s1">fun</span>
    <span class="s1">myfprime </span><span class="s2">= </span><span class="s1">sf</span><span class="s2">.</span><span class="s1">grad</span>

    <span class="s1">old_fval </span><span class="s2">= </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">)</span>
    <span class="s1">gfk </span><span class="s2">= </span><span class="s1">myfprime</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">)</span>

    <span class="s1">k </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s1">N </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">)</span>
    <span class="s1">I </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">eye</span><span class="s2">(</span><span class="s1">N</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">int</span><span class="s2">)</span>
    <span class="s1">Hk </span><span class="s2">= </span><span class="s1">I </span><span class="s4">if </span><span class="s1">hess_inv0 </span><span class="s4">is None else </span><span class="s1">hess_inv0</span>

    <span class="s0"># Sets the initial step guess to dx ~ 1</span>
    <span class="s1">old_old_fval </span><span class="s2">= </span><span class="s1">old_fval </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">gfk</span><span class="s2">) / </span><span class="s6">2</span>

    <span class="s1">xk </span><span class="s2">= </span><span class="s1">x0</span>
    <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
        <span class="s1">allvecs </span><span class="s2">= [</span><span class="s1">x0</span><span class="s2">]</span>
    <span class="s1">warnflag </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s1">gnorm </span><span class="s2">= </span><span class="s1">vecnorm</span><span class="s2">(</span><span class="s1">gfk</span><span class="s2">, </span><span class="s1">ord</span><span class="s2">=</span><span class="s1">norm</span><span class="s2">)</span>
    <span class="s4">while </span><span class="s2">(</span><span class="s1">gnorm </span><span class="s2">&gt; </span><span class="s1">gtol</span><span class="s2">) </span><span class="s4">and </span><span class="s2">(</span><span class="s1">k </span><span class="s2">&lt; </span><span class="s1">maxiter</span><span class="s2">):</span>
        <span class="s1">pk </span><span class="s2">= -</span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">Hk</span><span class="s2">, </span><span class="s1">gfk</span><span class="s2">)</span>
        <span class="s4">try</span><span class="s2">:</span>
            <span class="s1">alpha_k</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">old_fval</span><span class="s2">, </span><span class="s1">old_old_fval</span><span class="s2">, </span><span class="s1">gfkp1 </span><span class="s2">= </span><span class="s1">\</span>
                     <span class="s1">_line_search_wolfe12</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">myfprime</span><span class="s2">, </span><span class="s1">xk</span><span class="s2">, </span><span class="s1">pk</span><span class="s2">, </span><span class="s1">gfk</span><span class="s2">,</span>
                                          <span class="s1">old_fval</span><span class="s2">, </span><span class="s1">old_old_fval</span><span class="s2">, </span><span class="s1">amin</span><span class="s2">=</span><span class="s6">1e-100</span><span class="s2">,</span>
                                          <span class="s1">amax</span><span class="s2">=</span><span class="s6">1e100</span><span class="s2">, </span><span class="s1">c1</span><span class="s2">=</span><span class="s1">c1</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">=</span><span class="s1">c2</span><span class="s2">)</span>
        <span class="s4">except </span><span class="s1">_LineSearchError</span><span class="s2">:</span>
            <span class="s0"># Line search failed to find a better solution.</span>
            <span class="s1">warnflag </span><span class="s2">= </span><span class="s6">2</span>
            <span class="s4">break</span>

        <span class="s1">sk </span><span class="s2">= </span><span class="s1">alpha_k </span><span class="s2">* </span><span class="s1">pk</span>
        <span class="s1">xkp1 </span><span class="s2">= </span><span class="s1">xk </span><span class="s2">+ </span><span class="s1">sk</span>

        <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
            <span class="s1">allvecs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">xkp1</span><span class="s2">)</span>
        <span class="s1">xk </span><span class="s2">= </span><span class="s1">xkp1</span>
        <span class="s4">if </span><span class="s1">gfkp1 </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">gfkp1 </span><span class="s2">= </span><span class="s1">myfprime</span><span class="s2">(</span><span class="s1">xkp1</span><span class="s2">)</span>

        <span class="s1">yk </span><span class="s2">= </span><span class="s1">gfkp1 </span><span class="s2">- </span><span class="s1">gfk</span>
        <span class="s1">gfk </span><span class="s2">= </span><span class="s1">gfkp1</span>
        <span class="s1">k </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s1">intermediate_result </span><span class="s2">= </span><span class="s1">OptimizeResult</span><span class="s2">(</span><span class="s1">x</span><span class="s2">=</span><span class="s1">xk</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">=</span><span class="s1">old_fval</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">_call_callback_maybe_halt</span><span class="s2">(</span><span class="s1">callback</span><span class="s2">, </span><span class="s1">intermediate_result</span><span class="s2">):</span>
            <span class="s4">break</span>
        <span class="s1">gnorm </span><span class="s2">= </span><span class="s1">vecnorm</span><span class="s2">(</span><span class="s1">gfk</span><span class="s2">, </span><span class="s1">ord</span><span class="s2">=</span><span class="s1">norm</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s1">gnorm </span><span class="s2">&lt;= </span><span class="s1">gtol</span><span class="s2">):</span>
            <span class="s4">break</span>

        <span class="s0">#  See Chapter 5 in  P.E. Frandsen, K. Jonasson, H.B. Nielsen,</span>
        <span class="s0">#  O. Tingleff: &quot;Unconstrained Optimization&quot;, IMM, DTU.  1999.</span>
        <span class="s0">#  These notes are available here:</span>
        <span class="s0">#  http://www2.imm.dtu.dk/documents/ftp/publlec.html</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s1">alpha_k</span><span class="s2">*</span><span class="s1">vecnorm</span><span class="s2">(</span><span class="s1">pk</span><span class="s2">) &lt;= </span><span class="s1">xrtol</span><span class="s2">*(</span><span class="s1">xrtol </span><span class="s2">+ </span><span class="s1">vecnorm</span><span class="s2">(</span><span class="s1">xk</span><span class="s2">))):</span>
            <span class="s4">break</span>

        <span class="s4">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">old_fval</span><span class="s2">):</span>
            <span class="s0"># We correctly found +-Inf as optimal value, or something went</span>
            <span class="s0"># wrong.</span>
            <span class="s1">warnflag </span><span class="s2">= </span><span class="s6">2</span>
            <span class="s4">break</span>

        <span class="s1">rhok_inv </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">yk</span><span class="s2">, </span><span class="s1">sk</span><span class="s2">)</span>
        <span class="s0"># this was handled in numeric, let it remains for more safety</span>
        <span class="s0"># Cryptic comment above is preserved for posterity. Future reader:</span>
        <span class="s0"># consider change to condition below proposed in gh-1261/gh-17345.</span>
        <span class="s4">if </span><span class="s1">rhok_inv </span><span class="s2">== </span><span class="s6">0.</span><span class="s2">:</span>
            <span class="s1">rhok </span><span class="s2">= </span><span class="s6">1000.0</span>
            <span class="s4">if </span><span class="s1">disp</span><span class="s2">:</span>
                <span class="s1">msg </span><span class="s2">= </span><span class="s3">&quot;Divide-by-zero encountered: rhok assumed large&quot;</span>
                <span class="s1">_print_success_message_or_warn</span><span class="s2">(</span><span class="s4">True</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">rhok </span><span class="s2">= </span><span class="s6">1. </span><span class="s2">/ </span><span class="s1">rhok_inv</span>

        <span class="s1">A1 </span><span class="s2">= </span><span class="s1">I </span><span class="s2">- </span><span class="s1">sk</span><span class="s2">[:, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">] * </span><span class="s1">yk</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">, :] * </span><span class="s1">rhok</span>
        <span class="s1">A2 </span><span class="s2">= </span><span class="s1">I </span><span class="s2">- </span><span class="s1">yk</span><span class="s2">[:, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">] * </span><span class="s1">sk</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">, :] * </span><span class="s1">rhok</span>
        <span class="s1">Hk </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">A1</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">Hk</span><span class="s2">, </span><span class="s1">A2</span><span class="s2">)) + (</span><span class="s1">rhok </span><span class="s2">* </span><span class="s1">sk</span><span class="s2">[:, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">] *</span>
                                                 <span class="s1">sk</span><span class="s2">[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">, :])</span>

    <span class="s1">fval </span><span class="s2">= </span><span class="s1">old_fval</span>

    <span class="s4">if </span><span class="s1">warnflag </span><span class="s2">== </span><span class="s6">2</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'pr_loss'</span><span class="s2">]</span>
    <span class="s4">elif </span><span class="s1">k </span><span class="s2">&gt;= </span><span class="s1">maxiter</span><span class="s2">:</span>
        <span class="s1">warnflag </span><span class="s2">= </span><span class="s6">1</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'maxiter'</span><span class="s2">]</span>
    <span class="s4">elif </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">gnorm</span><span class="s2">) </span><span class="s4">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">fval</span><span class="s2">) </span><span class="s4">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">xk</span><span class="s2">).</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s1">warnflag </span><span class="s2">= </span><span class="s6">3</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'nan'</span><span class="s2">]</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'success'</span><span class="s2">]</span>

    <span class="s4">if </span><span class="s1">disp</span><span class="s2">:</span>
        <span class="s1">_print_success_message_or_warn</span><span class="s2">(</span><span class="s1">warnflag</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Current function value: %f&quot; </span><span class="s2">% </span><span class="s1">fval</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Iterations: %d&quot; </span><span class="s2">% </span><span class="s1">k</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Function evaluations: %d&quot; </span><span class="s2">% </span><span class="s1">sf</span><span class="s2">.</span><span class="s1">nfev</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Gradient evaluations: %d&quot; </span><span class="s2">% </span><span class="s1">sf</span><span class="s2">.</span><span class="s1">ngev</span><span class="s2">)</span>

    <span class="s1">result </span><span class="s2">= </span><span class="s1">OptimizeResult</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">=</span><span class="s1">fval</span><span class="s2">, </span><span class="s1">jac</span><span class="s2">=</span><span class="s1">gfk</span><span class="s2">, </span><span class="s1">hess_inv</span><span class="s2">=</span><span class="s1">Hk</span><span class="s2">, </span><span class="s1">nfev</span><span class="s2">=</span><span class="s1">sf</span><span class="s2">.</span><span class="s1">nfev</span><span class="s2">,</span>
                            <span class="s1">njev</span><span class="s2">=</span><span class="s1">sf</span><span class="s2">.</span><span class="s1">ngev</span><span class="s2">, </span><span class="s1">status</span><span class="s2">=</span><span class="s1">warnflag</span><span class="s2">,</span>
                            <span class="s1">success</span><span class="s2">=(</span><span class="s1">warnflag </span><span class="s2">== </span><span class="s6">0</span><span class="s2">), </span><span class="s1">message</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">x</span><span class="s2">=</span><span class="s1">xk</span><span class="s2">,</span>
                            <span class="s1">nit</span><span class="s2">=</span><span class="s1">k</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
        <span class="s1">result</span><span class="s2">[</span><span class="s3">'allvecs'</span><span class="s2">] = </span><span class="s1">allvecs</span>
    <span class="s4">return </span><span class="s1">result</span>


<span class="s4">def </span><span class="s1">_print_success_message_or_warn</span><span class="s2">(</span><span class="s1">warnflag</span><span class="s2">, </span><span class="s1">message</span><span class="s2">, </span><span class="s1">warntype</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s4">if not </span><span class="s1">warnflag</span><span class="s2">:</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">message</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">message</span><span class="s2">, </span><span class="s1">warntype </span><span class="s4">or </span><span class="s1">OptimizeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">3</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">fmin_cg</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">gtol</span><span class="s2">=</span><span class="s6">1e-5</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">,</span>
            <span class="s1">epsilon</span><span class="s2">=</span><span class="s1">_epsilon</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s6">1</span><span class="s2">, </span><span class="s1">retall</span><span class="s2">=</span><span class="s6">0</span><span class="s2">,</span>
            <span class="s1">callback</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">c1</span><span class="s2">=</span><span class="s6">1e-4</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">=</span><span class="s6">0.4</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Minimize a function using a nonlinear conjugate gradient algorithm. 
 
    Parameters 
    ---------- 
    f : callable, ``f(x, *args)`` 
        Objective function to be minimized. Here `x` must be a 1-D array of 
        the variables that are to be changed in the search for a minimum, and 
        `args` are the other (fixed) parameters of `f`. 
    x0 : ndarray 
        A user-supplied initial estimate of `xopt`, the optimal value of `x`. 
        It must be a 1-D array of values. 
    fprime : callable, ``fprime(x, *args)``, optional 
        A function that returns the gradient of `f` at `x`. Here `x` and `args` 
        are as described above for `f`. The returned value must be a 1-D array. 
        Defaults to None, in which case the gradient is approximated 
        numerically (see `epsilon`, below). 
    args : tuple, optional 
        Parameter values passed to `f` and `fprime`. Must be supplied whenever 
        additional fixed parameters are needed to completely specify the 
        functions `f` and `fprime`. 
    gtol : float, optional 
        Stop when the norm of the gradient is less than `gtol`. 
    norm : float, optional 
        Order to use for the norm of the gradient 
        (``-np.inf`` is min, ``np.inf`` is max). 
    epsilon : float or ndarray, optional 
        Step size(s) to use when `fprime` is approximated numerically. Can be a 
        scalar or a 1-D array. Defaults to ``sqrt(eps)``, with eps the 
        floating point machine precision.  Usually ``sqrt(eps)`` is about 
        1.5e-8. 
    maxiter : int, optional 
        Maximum number of iterations to perform. Default is ``200 * len(x0)``. 
    full_output : bool, optional 
        If True, return `fopt`, `func_calls`, `grad_calls`, and `warnflag` in 
        addition to `xopt`.  See the Returns section below for additional 
        information on optional return values. 
    disp : bool, optional 
        If True, return a convergence message, followed by `xopt`. 
    retall : bool, optional 
        If True, add to the returned values the results of each iteration. 
    callback : callable, optional 
        An optional user-supplied function, called after each iteration. 
        Called as ``callback(xk)``, where ``xk`` is the current value of `x0`. 
    c1 : float, default: 1e-4 
        Parameter for Armijo condition rule. 
    c2 : float, default: 0.4 
        Parameter for curvature condition rule. 
 
    Returns 
    ------- 
    xopt : ndarray 
        Parameters which minimize f, i.e., ``f(xopt) == fopt``. 
    fopt : float, optional 
        Minimum value found, f(xopt). Only returned if `full_output` is True. 
    func_calls : int, optional 
        The number of function_calls made. Only returned if `full_output` 
        is True. 
    grad_calls : int, optional 
        The number of gradient calls made. Only returned if `full_output` is 
        True. 
    warnflag : int, optional 
        Integer value with warning status, only returned if `full_output` is 
        True. 
 
        0 : Success. 
 
        1 : The maximum number of iterations was exceeded. 
 
        2 : Gradient and/or function calls were not changing. May indicate 
            that precision was lost, i.e., the routine did not converge. 
 
        3 : NaN result encountered. 
 
    allvecs : list of ndarray, optional 
        List of arrays, containing the results at each iteration. 
        Only returned if `retall` is True. 
 
    See Also 
    -------- 
    minimize : common interface to all `scipy.optimize` algorithms for 
               unconstrained and constrained minimization of multivariate 
               functions. It provides an alternative way to call 
               ``fmin_cg``, by specifying ``method='CG'``. 
 
    Notes 
    ----- 
    This conjugate gradient algorithm is based on that of Polak and Ribiere 
    [1]_. 
 
    Conjugate gradient methods tend to work better when: 
 
    1. `f` has a unique global minimizing point, and no local minima or 
       other stationary points, 
    2. `f` is, at least locally, reasonably well approximated by a 
       quadratic function of the variables, 
    3. `f` is continuous and has a continuous gradient, 
    4. `fprime` is not too large, e.g., has a norm less than 1000, 
    5. The initial guess, `x0`, is reasonably close to `f` 's global 
       minimizing point, `xopt`. 
 
    Parameters `c1` and `c2` must satisfy ``0 &lt; c1 &lt; c2 &lt; 1``. 
 
    References 
    ---------- 
    .. [1] Wright &amp; Nocedal, &quot;Numerical Optimization&quot;, 1999, pp. 120-122. 
 
    Examples 
    -------- 
    Example 1: seek the minimum value of the expression 
    ``a*u**2 + b*u*v + c*v**2 + d*u + e*v + f`` for given values 
    of the parameters and an initial guess ``(u, v) = (0, 0)``. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; args = (2, 3, 7, 8, 9, 10)  # parameter values 
    &gt;&gt;&gt; def f(x, *args): 
    ...     u, v = x 
    ...     a, b, c, d, e, f = args 
    ...     return a*u**2 + b*u*v + c*v**2 + d*u + e*v + f 
    &gt;&gt;&gt; def gradf(x, *args): 
    ...     u, v = x 
    ...     a, b, c, d, e, f = args 
    ...     gu = 2*a*u + b*v + d     # u-component of the gradient 
    ...     gv = b*u + 2*c*v + e     # v-component of the gradient 
    ...     return np.asarray((gu, gv)) 
    &gt;&gt;&gt; x0 = np.asarray((0, 0))  # Initial guess. 
    &gt;&gt;&gt; from scipy import optimize 
    &gt;&gt;&gt; res1 = optimize.fmin_cg(f, x0, fprime=gradf, args=args) 
    Optimization terminated successfully. 
             Current function value: 1.617021 
             Iterations: 4 
             Function evaluations: 8 
             Gradient evaluations: 8 
    &gt;&gt;&gt; res1 
    array([-1.80851064, -0.25531915]) 
 
    Example 2: solve the same problem using the `minimize` function. 
    (This `myopts` dictionary shows all of the available options, 
    although in practice only non-default values would be needed. 
    The returned value will be a dictionary.) 
 
    &gt;&gt;&gt; opts = {'maxiter' : None,    # default value. 
    ...         'disp' : True,    # non-default value. 
    ...         'gtol' : 1e-5,    # default value. 
    ...         'norm' : np.inf,  # default value. 
    ...         'eps' : 1.4901161193847656e-08}  # default value. 
    &gt;&gt;&gt; res2 = optimize.minimize(f, x0, jac=gradf, args=args, 
    ...                          method='CG', options=opts) 
    Optimization terminated successfully. 
            Current function value: 1.617021 
            Iterations: 4 
            Function evaluations: 8 
            Gradient evaluations: 8 
    &gt;&gt;&gt; res2.x  # minimum found 
    array([-1.80851064, -0.25531915]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">opts </span><span class="s2">= {</span><span class="s3">'gtol'</span><span class="s2">: </span><span class="s1">gtol</span><span class="s2">,</span>
            <span class="s3">'norm'</span><span class="s2">: </span><span class="s1">norm</span><span class="s2">,</span>
            <span class="s3">'eps'</span><span class="s2">: </span><span class="s1">epsilon</span><span class="s2">,</span>
            <span class="s3">'disp'</span><span class="s2">: </span><span class="s1">disp</span><span class="s2">,</span>
            <span class="s3">'maxiter'</span><span class="s2">: </span><span class="s1">maxiter</span><span class="s2">,</span>
            <span class="s3">'return_all'</span><span class="s2">: </span><span class="s1">retall</span><span class="s2">}</span>

    <span class="s1">callback </span><span class="s2">= </span><span class="s1">_wrap_callback</span><span class="s2">(</span><span class="s1">callback</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">_minimize_cg</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">=</span><span class="s1">callback</span><span class="s2">, </span><span class="s1">c1</span><span class="s2">=</span><span class="s1">c1</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">=</span><span class="s1">c2</span><span class="s2">,</span>
                       <span class="s2">**</span><span class="s1">opts</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">full_output</span><span class="s2">:</span>
        <span class="s1">retlist </span><span class="s2">= </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'fun'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'nfev'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'njev'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'status'</span><span class="s2">]</span>
        <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
            <span class="s1">retlist </span><span class="s2">+= (</span><span class="s1">res</span><span class="s2">[</span><span class="s3">'allvecs'</span><span class="s2">], )</span>
        <span class="s4">return </span><span class="s1">retlist</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'allvecs'</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">]</span>


<span class="s4">def </span><span class="s1">_minimize_cg</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">jac</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">gtol</span><span class="s2">=</span><span class="s6">1e-5</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">, </span><span class="s1">eps</span><span class="s2">=</span><span class="s1">_epsilon</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">disp</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">return_all</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">finite_diff_rel_step</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                 <span class="s1">c1</span><span class="s2">=</span><span class="s6">1e-4</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">=</span><span class="s6">0.4</span><span class="s2">, **</span><span class="s1">unknown_options</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Minimization of scalar function of one or more variables using the 
    conjugate gradient algorithm. 
 
    Options 
    ------- 
    disp : bool 
        Set to True to print convergence messages. 
    maxiter : int 
        Maximum number of iterations to perform. 
    gtol : float 
        Gradient norm must be less than `gtol` before successful 
        termination. 
    norm : float 
        Order of norm (Inf is max, -Inf is min). 
    eps : float or ndarray 
        If `jac is None` the absolute step size used for numerical 
        approximation of the jacobian via forward differences. 
    return_all : bool, optional 
        Set to True to return a list of the best solution at each of the 
        iterations. 
    finite_diff_rel_step : None or array_like, optional 
        If `jac in ['2-point', '3-point', 'cs']` the relative step size to 
        use for numerical approximation of the jacobian. The absolute step 
        size is computed as ``h = rel_step * sign(x) * max(1, abs(x))``, 
        possibly adjusted to fit into the bounds. For ``jac='3-point'`` 
        the sign of `h` is ignored. If None (default) then step is selected 
        automatically. 
    c1 : float, default: 1e-4 
        Parameter for Armijo condition rule. 
    c2 : float, default: 0.4 
        Parameter for curvature condition rule. 
 
    Notes 
    ----- 
    Parameters `c1` and `c2` must satisfy ``0 &lt; c1 &lt; c2 &lt; 1``. 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_unknown_options</span><span class="s2">(</span><span class="s1">unknown_options</span><span class="s2">)</span>

    <span class="s1">retall </span><span class="s2">= </span><span class="s1">return_all</span>

    <span class="s1">x0 </span><span class="s2">= </span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">).</span><span class="s1">flatten</span><span class="s2">()</span>
    <span class="s4">if </span><span class="s1">maxiter </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">) * </span><span class="s6">200</span>

    <span class="s1">sf </span><span class="s2">= </span><span class="s1">_prepare_scalar_function</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">jac</span><span class="s2">=</span><span class="s1">jac</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">, </span><span class="s1">epsilon</span><span class="s2">=</span><span class="s1">eps</span><span class="s2">,</span>
                                  <span class="s1">finite_diff_rel_step</span><span class="s2">=</span><span class="s1">finite_diff_rel_step</span><span class="s2">)</span>

    <span class="s1">f </span><span class="s2">= </span><span class="s1">sf</span><span class="s2">.</span><span class="s1">fun</span>
    <span class="s1">myfprime </span><span class="s2">= </span><span class="s1">sf</span><span class="s2">.</span><span class="s1">grad</span>

    <span class="s1">old_fval </span><span class="s2">= </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">)</span>
    <span class="s1">gfk </span><span class="s2">= </span><span class="s1">myfprime</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">)</span>

    <span class="s1">k </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s1">xk </span><span class="s2">= </span><span class="s1">x0</span>
    <span class="s0"># Sets the initial step guess to dx ~ 1</span>
    <span class="s1">old_old_fval </span><span class="s2">= </span><span class="s1">old_fval </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">gfk</span><span class="s2">) / </span><span class="s6">2</span>

    <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
        <span class="s1">allvecs </span><span class="s2">= [</span><span class="s1">xk</span><span class="s2">]</span>
    <span class="s1">warnflag </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s1">pk </span><span class="s2">= -</span><span class="s1">gfk</span>
    <span class="s1">gnorm </span><span class="s2">= </span><span class="s1">vecnorm</span><span class="s2">(</span><span class="s1">gfk</span><span class="s2">, </span><span class="s1">ord</span><span class="s2">=</span><span class="s1">norm</span><span class="s2">)</span>

    <span class="s1">sigma_3 </span><span class="s2">= </span><span class="s6">0.01</span>

    <span class="s4">while </span><span class="s2">(</span><span class="s1">gnorm </span><span class="s2">&gt; </span><span class="s1">gtol</span><span class="s2">) </span><span class="s4">and </span><span class="s2">(</span><span class="s1">k </span><span class="s2">&lt; </span><span class="s1">maxiter</span><span class="s2">):</span>
        <span class="s1">deltak </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">gfk</span><span class="s2">, </span><span class="s1">gfk</span><span class="s2">)</span>

        <span class="s1">cached_step </span><span class="s2">= [</span><span class="s4">None</span><span class="s2">]</span>

        <span class="s4">def </span><span class="s1">polak_ribiere_powell_step</span><span class="s2">(</span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">gfkp1</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
            <span class="s1">xkp1 </span><span class="s2">= </span><span class="s1">xk </span><span class="s2">+ </span><span class="s1">alpha </span><span class="s2">* </span><span class="s1">pk</span>
            <span class="s4">if </span><span class="s1">gfkp1 </span><span class="s4">is None</span><span class="s2">:</span>
                <span class="s1">gfkp1 </span><span class="s2">= </span><span class="s1">myfprime</span><span class="s2">(</span><span class="s1">xkp1</span><span class="s2">)</span>
            <span class="s1">yk </span><span class="s2">= </span><span class="s1">gfkp1 </span><span class="s2">- </span><span class="s1">gfk</span>
            <span class="s1">beta_k </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">yk</span><span class="s2">, </span><span class="s1">gfkp1</span><span class="s2">) / </span><span class="s1">deltak</span><span class="s2">)</span>
            <span class="s1">pkp1 </span><span class="s2">= -</span><span class="s1">gfkp1 </span><span class="s2">+ </span><span class="s1">beta_k </span><span class="s2">* </span><span class="s1">pk</span>
            <span class="s1">gnorm </span><span class="s2">= </span><span class="s1">vecnorm</span><span class="s2">(</span><span class="s1">gfkp1</span><span class="s2">, </span><span class="s1">ord</span><span class="s2">=</span><span class="s1">norm</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s2">(</span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">xkp1</span><span class="s2">, </span><span class="s1">pkp1</span><span class="s2">, </span><span class="s1">gfkp1</span><span class="s2">, </span><span class="s1">gnorm</span><span class="s2">)</span>

        <span class="s4">def </span><span class="s1">descent_condition</span><span class="s2">(</span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">xkp1</span><span class="s2">, </span><span class="s1">fp1</span><span class="s2">, </span><span class="s1">gfkp1</span><span class="s2">):</span>
            <span class="s0"># Polak-Ribiere+ needs an explicit check of a sufficient</span>
            <span class="s0"># descent condition, which is not guaranteed by strong Wolfe.</span>
            <span class="s0">#</span>
            <span class="s0"># See Gilbert &amp; Nocedal, &quot;Global convergence properties of</span>
            <span class="s0"># conjugate gradient methods for optimization&quot;,</span>
            <span class="s0"># SIAM J. Optimization 2, 21 (1992).</span>
            <span class="s1">cached_step</span><span class="s2">[:] = </span><span class="s1">polak_ribiere_powell_step</span><span class="s2">(</span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">gfkp1</span><span class="s2">)</span>
            <span class="s1">alpha</span><span class="s2">, </span><span class="s1">xk</span><span class="s2">, </span><span class="s1">pk</span><span class="s2">, </span><span class="s1">gfk</span><span class="s2">, </span><span class="s1">gnorm </span><span class="s2">= </span><span class="s1">cached_step</span>

            <span class="s0"># Accept step if it leads to convergence.</span>
            <span class="s4">if </span><span class="s1">gnorm </span><span class="s2">&lt;= </span><span class="s1">gtol</span><span class="s2">:</span>
                <span class="s4">return True</span>

            <span class="s0"># Accept step if sufficient descent condition applies.</span>
            <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">pk</span><span class="s2">, </span><span class="s1">gfk</span><span class="s2">) &lt;= -</span><span class="s1">sigma_3 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">gfk</span><span class="s2">, </span><span class="s1">gfk</span><span class="s2">)</span>

        <span class="s4">try</span><span class="s2">:</span>
            <span class="s1">alpha_k</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">old_fval</span><span class="s2">, </span><span class="s1">old_old_fval</span><span class="s2">, </span><span class="s1">gfkp1 </span><span class="s2">= </span><span class="s1">\</span>
                     <span class="s1">_line_search_wolfe12</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">myfprime</span><span class="s2">, </span><span class="s1">xk</span><span class="s2">, </span><span class="s1">pk</span><span class="s2">, </span><span class="s1">gfk</span><span class="s2">, </span><span class="s1">old_fval</span><span class="s2">,</span>
                                          <span class="s1">old_old_fval</span><span class="s2">, </span><span class="s1">c1</span><span class="s2">=</span><span class="s1">c1</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">=</span><span class="s1">c2</span><span class="s2">, </span><span class="s1">amin</span><span class="s2">=</span><span class="s6">1e-100</span><span class="s2">,</span>
                                          <span class="s1">amax</span><span class="s2">=</span><span class="s6">1e100</span><span class="s2">, </span><span class="s1">extra_condition</span><span class="s2">=</span><span class="s1">descent_condition</span><span class="s2">)</span>
        <span class="s4">except </span><span class="s1">_LineSearchError</span><span class="s2">:</span>
            <span class="s0"># Line search failed to find a better solution.</span>
            <span class="s1">warnflag </span><span class="s2">= </span><span class="s6">2</span>
            <span class="s4">break</span>

        <span class="s0"># Reuse already computed results if possible</span>
        <span class="s4">if </span><span class="s1">alpha_k </span><span class="s2">== </span><span class="s1">cached_step</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]:</span>
            <span class="s1">alpha_k</span><span class="s2">, </span><span class="s1">xk</span><span class="s2">, </span><span class="s1">pk</span><span class="s2">, </span><span class="s1">gfk</span><span class="s2">, </span><span class="s1">gnorm </span><span class="s2">= </span><span class="s1">cached_step</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">alpha_k</span><span class="s2">, </span><span class="s1">xk</span><span class="s2">, </span><span class="s1">pk</span><span class="s2">, </span><span class="s1">gfk</span><span class="s2">, </span><span class="s1">gnorm </span><span class="s2">= </span><span class="s1">polak_ribiere_powell_step</span><span class="s2">(</span><span class="s1">alpha_k</span><span class="s2">, </span><span class="s1">gfkp1</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
            <span class="s1">allvecs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">xk</span><span class="s2">)</span>
        <span class="s1">k </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s1">intermediate_result </span><span class="s2">= </span><span class="s1">OptimizeResult</span><span class="s2">(</span><span class="s1">x</span><span class="s2">=</span><span class="s1">xk</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">=</span><span class="s1">old_fval</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">_call_callback_maybe_halt</span><span class="s2">(</span><span class="s1">callback</span><span class="s2">, </span><span class="s1">intermediate_result</span><span class="s2">):</span>
            <span class="s4">break</span>

    <span class="s1">fval </span><span class="s2">= </span><span class="s1">old_fval</span>
    <span class="s4">if </span><span class="s1">warnflag </span><span class="s2">== </span><span class="s6">2</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'pr_loss'</span><span class="s2">]</span>
    <span class="s4">elif </span><span class="s1">k </span><span class="s2">&gt;= </span><span class="s1">maxiter</span><span class="s2">:</span>
        <span class="s1">warnflag </span><span class="s2">= </span><span class="s6">1</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'maxiter'</span><span class="s2">]</span>
    <span class="s4">elif </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">gnorm</span><span class="s2">) </span><span class="s4">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">fval</span><span class="s2">) </span><span class="s4">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">xk</span><span class="s2">).</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s1">warnflag </span><span class="s2">= </span><span class="s6">3</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'nan'</span><span class="s2">]</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'success'</span><span class="s2">]</span>

    <span class="s4">if </span><span class="s1">disp</span><span class="s2">:</span>
        <span class="s1">_print_success_message_or_warn</span><span class="s2">(</span><span class="s1">warnflag</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Current function value: %f&quot; </span><span class="s2">% </span><span class="s1">fval</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Iterations: %d&quot; </span><span class="s2">% </span><span class="s1">k</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Function evaluations: %d&quot; </span><span class="s2">% </span><span class="s1">sf</span><span class="s2">.</span><span class="s1">nfev</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Gradient evaluations: %d&quot; </span><span class="s2">% </span><span class="s1">sf</span><span class="s2">.</span><span class="s1">ngev</span><span class="s2">)</span>

    <span class="s1">result </span><span class="s2">= </span><span class="s1">OptimizeResult</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">=</span><span class="s1">fval</span><span class="s2">, </span><span class="s1">jac</span><span class="s2">=</span><span class="s1">gfk</span><span class="s2">, </span><span class="s1">nfev</span><span class="s2">=</span><span class="s1">sf</span><span class="s2">.</span><span class="s1">nfev</span><span class="s2">,</span>
                            <span class="s1">njev</span><span class="s2">=</span><span class="s1">sf</span><span class="s2">.</span><span class="s1">ngev</span><span class="s2">, </span><span class="s1">status</span><span class="s2">=</span><span class="s1">warnflag</span><span class="s2">,</span>
                            <span class="s1">success</span><span class="s2">=(</span><span class="s1">warnflag </span><span class="s2">== </span><span class="s6">0</span><span class="s2">), </span><span class="s1">message</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">x</span><span class="s2">=</span><span class="s1">xk</span><span class="s2">,</span>
                            <span class="s1">nit</span><span class="s2">=</span><span class="s1">k</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
        <span class="s1">result</span><span class="s2">[</span><span class="s3">'allvecs'</span><span class="s2">] = </span><span class="s1">allvecs</span>
    <span class="s4">return </span><span class="s1">result</span>


<span class="s4">def </span><span class="s1">fmin_ncg</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">, </span><span class="s1">fhess_p</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">fhess</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">avextol</span><span class="s2">=</span><span class="s6">1e-5</span><span class="s2">,</span>
             <span class="s1">epsilon</span><span class="s2">=</span><span class="s1">_epsilon</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s6">1</span><span class="s2">, </span><span class="s1">retall</span><span class="s2">=</span><span class="s6">0</span><span class="s2">,</span>
             <span class="s1">callback</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">c1</span><span class="s2">=</span><span class="s6">1e-4</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">=</span><span class="s6">0.9</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Unconstrained minimization of a function using the Newton-CG method. 
 
    Parameters 
    ---------- 
    f : callable ``f(x, *args)`` 
        Objective function to be minimized. 
    x0 : ndarray 
        Initial guess. 
    fprime : callable ``f'(x, *args)`` 
        Gradient of f. 
    fhess_p : callable ``fhess_p(x, p, *args)``, optional 
        Function which computes the Hessian of f times an 
        arbitrary vector, p. 
    fhess : callable ``fhess(x, *args)``, optional 
        Function to compute the Hessian matrix of f. 
    args : tuple, optional 
        Extra arguments passed to f, fprime, fhess_p, and fhess 
        (the same set of extra arguments is supplied to all of 
        these functions). 
    epsilon : float or ndarray, optional 
        If fhess is approximated, use this value for the step size. 
    callback : callable, optional 
        An optional user-supplied function which is called after 
        each iteration. Called as callback(xk), where xk is the 
        current parameter vector. 
    avextol : float, optional 
        Convergence is assumed when the average relative error in 
        the minimizer falls below this amount. 
    maxiter : int, optional 
        Maximum number of iterations to perform. 
    full_output : bool, optional 
        If True, return the optional outputs. 
    disp : bool, optional 
        If True, print convergence message. 
    retall : bool, optional 
        If True, return a list of results at each iteration. 
    c1 : float, default: 1e-4 
        Parameter for Armijo condition rule. 
    c2 : float, default: 0.9 
        Parameter for curvature condition rule 
 
    Returns 
    ------- 
    xopt : ndarray 
        Parameters which minimize f, i.e., ``f(xopt) == fopt``. 
    fopt : float 
        Value of the function at xopt, i.e., ``fopt = f(xopt)``. 
    fcalls : int 
        Number of function calls made. 
    gcalls : int 
        Number of gradient calls made. 
    hcalls : int 
        Number of Hessian calls made. 
    warnflag : int 
        Warnings generated by the algorithm. 
        1 : Maximum number of iterations exceeded. 
        2 : Line search failure (precision loss). 
        3 : NaN result encountered. 
    allvecs : list 
        The result at each iteration, if retall is True (see below). 
 
    See also 
    -------- 
    minimize: Interface to minimization algorithms for multivariate 
        functions. See the 'Newton-CG' `method` in particular. 
 
    Notes 
    ----- 
    Only one of `fhess_p` or `fhess` need to be given.  If `fhess` 
    is provided, then `fhess_p` will be ignored. If neither `fhess` 
    nor `fhess_p` is provided, then the hessian product will be 
    approximated using finite differences on `fprime`. `fhess_p` 
    must compute the hessian times an arbitrary vector. If it is not 
    given, finite-differences on `fprime` are used to compute 
    it. 
 
    Newton-CG methods are also called truncated Newton methods. This 
    function differs from scipy.optimize.fmin_tnc because 
 
    1. scipy.optimize.fmin_ncg is written purely in Python using NumPy 
        and scipy while scipy.optimize.fmin_tnc calls a C function. 
    2. scipy.optimize.fmin_ncg is only for unconstrained minimization 
        while scipy.optimize.fmin_tnc is for unconstrained minimization 
        or box constrained minimization. (Box constraints give 
        lower and upper bounds for each variable separately.) 
 
    Parameters `c1` and `c2` must satisfy ``0 &lt; c1 &lt; c2 &lt; 1``. 
 
    References 
    ---------- 
    Wright &amp; Nocedal, 'Numerical Optimization', 1999, p. 140. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">opts </span><span class="s2">= {</span><span class="s3">'xtol'</span><span class="s2">: </span><span class="s1">avextol</span><span class="s2">,</span>
            <span class="s3">'eps'</span><span class="s2">: </span><span class="s1">epsilon</span><span class="s2">,</span>
            <span class="s3">'maxiter'</span><span class="s2">: </span><span class="s1">maxiter</span><span class="s2">,</span>
            <span class="s3">'disp'</span><span class="s2">: </span><span class="s1">disp</span><span class="s2">,</span>
            <span class="s3">'return_all'</span><span class="s2">: </span><span class="s1">retall</span><span class="s2">}</span>

    <span class="s1">callback </span><span class="s2">= </span><span class="s1">_wrap_callback</span><span class="s2">(</span><span class="s1">callback</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">_minimize_newtoncg</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">, </span><span class="s1">fhess</span><span class="s2">, </span><span class="s1">fhess_p</span><span class="s2">,</span>
                             <span class="s1">callback</span><span class="s2">=</span><span class="s1">callback</span><span class="s2">, </span><span class="s1">c1</span><span class="s2">=</span><span class="s1">c1</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">=</span><span class="s1">c2</span><span class="s2">, **</span><span class="s1">opts</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">full_output</span><span class="s2">:</span>
        <span class="s1">retlist </span><span class="s2">= (</span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'fun'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'nfev'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'njev'</span><span class="s2">],</span>
                   <span class="s1">res</span><span class="s2">[</span><span class="s3">'nhev'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'status'</span><span class="s2">])</span>
        <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
            <span class="s1">retlist </span><span class="s2">+= (</span><span class="s1">res</span><span class="s2">[</span><span class="s3">'allvecs'</span><span class="s2">], )</span>
        <span class="s4">return </span><span class="s1">retlist</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'allvecs'</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">]</span>


<span class="s4">def </span><span class="s1">_minimize_newtoncg</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">jac</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">hess</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">hessp</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                       <span class="s1">callback</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s6">1e-5</span><span class="s2">, </span><span class="s1">eps</span><span class="s2">=</span><span class="s1">_epsilon</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                       <span class="s1">disp</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">return_all</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">c1</span><span class="s2">=</span><span class="s6">1e-4</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">=</span><span class="s6">0.9</span><span class="s2">,</span>
                       <span class="s2">**</span><span class="s1">unknown_options</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Minimization of scalar function of one or more variables using the 
    Newton-CG algorithm. 
 
    Note that the `jac` parameter (Jacobian) is required. 
 
    Options 
    ------- 
    disp : bool 
        Set to True to print convergence messages. 
    xtol : float 
        Average relative error in solution `xopt` acceptable for 
        convergence. 
    maxiter : int 
        Maximum number of iterations to perform. 
    eps : float or ndarray 
        If `hessp` is approximated, use this value for the step size. 
    return_all : bool, optional 
        Set to True to return a list of the best solution at each of the 
        iterations. 
    c1 : float, default: 1e-4 
        Parameter for Armijo condition rule. 
    c2 : float, default: 0.9 
        Parameter for curvature condition rule. 
 
    Notes 
    ----- 
    Parameters `c1` and `c2` must satisfy ``0 &lt; c1 &lt; c2 &lt; 1``. 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_unknown_options</span><span class="s2">(</span><span class="s1">unknown_options</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">jac </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'Jacobian is required for Newton-CG method'</span><span class="s2">)</span>
    <span class="s1">fhess_p </span><span class="s2">= </span><span class="s1">hessp</span>
    <span class="s1">fhess </span><span class="s2">= </span><span class="s1">hess</span>
    <span class="s1">avextol </span><span class="s2">= </span><span class="s1">xtol</span>
    <span class="s1">epsilon </span><span class="s2">= </span><span class="s1">eps</span>
    <span class="s1">retall </span><span class="s2">= </span><span class="s1">return_all</span>

    <span class="s1">x0 </span><span class="s2">= </span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">).</span><span class="s1">flatten</span><span class="s2">()</span>
    <span class="s0"># TODO: add hessp (callable or FD) to ScalarFunction?</span>
    <span class="s1">sf </span><span class="s2">= </span><span class="s1">_prepare_scalar_function</span><span class="s2">(</span>
        <span class="s1">fun</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">jac</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">, </span><span class="s1">epsilon</span><span class="s2">=</span><span class="s1">eps</span><span class="s2">, </span><span class="s1">hess</span><span class="s2">=</span><span class="s1">hess</span>
    <span class="s2">)</span>
    <span class="s1">f </span><span class="s2">= </span><span class="s1">sf</span><span class="s2">.</span><span class="s1">fun</span>
    <span class="s1">fprime </span><span class="s2">= </span><span class="s1">sf</span><span class="s2">.</span><span class="s1">grad</span>
    <span class="s1">_h </span><span class="s2">= </span><span class="s1">sf</span><span class="s2">.</span><span class="s1">hess</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">)</span>

    <span class="s0"># Logic for hess/hessp</span>
    <span class="s0"># - If a callable(hess) is provided, then use that</span>
    <span class="s0"># - If hess is a FD_METHOD, or the output from hess(x) is a LinearOperator</span>
    <span class="s0">#   then create a hessp function using those.</span>
    <span class="s0"># - If hess is None but you have callable(hessp) then use the hessp.</span>
    <span class="s0"># - If hess and hessp are None then approximate hessp using the grad/jac.</span>

    <span class="s4">if </span><span class="s2">(</span><span class="s1">hess </span><span class="s4">in </span><span class="s1">FD_METHODS </span><span class="s4">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">_h</span><span class="s2">, </span><span class="s1">LinearOperator</span><span class="s2">)):</span>
        <span class="s1">fhess </span><span class="s2">= </span><span class="s4">None</span>

        <span class="s4">def </span><span class="s1">_hessp</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">sf</span><span class="s2">.</span><span class="s1">hess</span><span class="s2">(</span><span class="s1">x</span><span class="s2">).</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>

        <span class="s1">fhess_p </span><span class="s2">= </span><span class="s1">_hessp</span>

    <span class="s4">def </span><span class="s1">terminate</span><span class="s2">(</span><span class="s1">warnflag</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">disp</span><span class="s2">:</span>
            <span class="s1">_print_success_message_or_warn</span><span class="s2">(</span><span class="s1">warnflag</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">)</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Current function value: %f&quot; </span><span class="s2">% </span><span class="s1">old_fval</span><span class="s2">)</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Iterations: %d&quot; </span><span class="s2">% </span><span class="s1">k</span><span class="s2">)</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Function evaluations: %d&quot; </span><span class="s2">% </span><span class="s1">sf</span><span class="s2">.</span><span class="s1">nfev</span><span class="s2">)</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Gradient evaluations: %d&quot; </span><span class="s2">% </span><span class="s1">sf</span><span class="s2">.</span><span class="s1">ngev</span><span class="s2">)</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Hessian evaluations: %d&quot; </span><span class="s2">% </span><span class="s1">hcalls</span><span class="s2">)</span>
        <span class="s1">fval </span><span class="s2">= </span><span class="s1">old_fval</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">OptimizeResult</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">=</span><span class="s1">fval</span><span class="s2">, </span><span class="s1">jac</span><span class="s2">=</span><span class="s1">gfk</span><span class="s2">, </span><span class="s1">nfev</span><span class="s2">=</span><span class="s1">sf</span><span class="s2">.</span><span class="s1">nfev</span><span class="s2">,</span>
                                <span class="s1">njev</span><span class="s2">=</span><span class="s1">sf</span><span class="s2">.</span><span class="s1">ngev</span><span class="s2">, </span><span class="s1">nhev</span><span class="s2">=</span><span class="s1">hcalls</span><span class="s2">, </span><span class="s1">status</span><span class="s2">=</span><span class="s1">warnflag</span><span class="s2">,</span>
                                <span class="s1">success</span><span class="s2">=(</span><span class="s1">warnflag </span><span class="s2">== </span><span class="s6">0</span><span class="s2">), </span><span class="s1">message</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">x</span><span class="s2">=</span><span class="s1">xk</span><span class="s2">,</span>
                                <span class="s1">nit</span><span class="s2">=</span><span class="s1">k</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
            <span class="s1">result</span><span class="s2">[</span><span class="s3">'allvecs'</span><span class="s2">] = </span><span class="s1">allvecs</span>
        <span class="s4">return </span><span class="s1">result</span>

    <span class="s1">hcalls </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s4">if </span><span class="s1">maxiter </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">)*</span><span class="s6">200</span>
    <span class="s1">cg_maxiter </span><span class="s2">= </span><span class="s6">20</span><span class="s2">*</span><span class="s1">len</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">)</span>

    <span class="s1">xtol </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">) * </span><span class="s1">avextol</span>
    <span class="s0"># Make sure we enter the while loop.</span>
    <span class="s1">update_l1norm </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">float</span><span class="s2">).</span><span class="s1">max</span>
    <span class="s1">xk </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
        <span class="s1">allvecs </span><span class="s2">= [</span><span class="s1">xk</span><span class="s2">]</span>
    <span class="s1">k </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s1">gfk </span><span class="s2">= </span><span class="s4">None</span>
    <span class="s1">old_fval </span><span class="s2">= </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">)</span>
    <span class="s1">old_old_fval </span><span class="s2">= </span><span class="s4">None</span>
    <span class="s1">float64eps </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">).</span><span class="s1">eps</span>
    <span class="s4">while </span><span class="s1">update_l1norm </span><span class="s2">&gt; </span><span class="s1">xtol</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">k </span><span class="s2">&gt;= </span><span class="s1">maxiter</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s3">&quot;Warning: &quot; </span><span class="s2">+ </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'maxiter'</span><span class="s2">]</span>
            <span class="s4">return </span><span class="s1">terminate</span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">)</span>
        <span class="s0"># Compute a search direction pk by applying the CG method to</span>
        <span class="s0">#  del2 f(xk) p = - grad f(xk) starting from 0.</span>
        <span class="s1">b </span><span class="s2">= -</span><span class="s1">fprime</span><span class="s2">(</span><span class="s1">xk</span><span class="s2">)</span>
        <span class="s1">maggrad </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">ord</span><span class="s2">=</span><span class="s6">1</span><span class="s2">)</span>
        <span class="s1">eta </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s6">0.5</span><span class="s2">, </span><span class="s1">math</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">maggrad</span><span class="s2">))</span>
        <span class="s1">termcond </span><span class="s2">= </span><span class="s1">eta </span><span class="s2">* </span><span class="s1">maggrad</span>
        <span class="s1">xsupi </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">x0</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">ri </span><span class="s2">= -</span><span class="s1">b</span>
        <span class="s1">psupi </span><span class="s2">= -</span><span class="s1">ri</span>
        <span class="s1">i </span><span class="s2">= </span><span class="s6">0</span>
        <span class="s1">dri0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">ri</span><span class="s2">, </span><span class="s1">ri</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">fhess </span><span class="s4">is not None</span><span class="s2">:             </span><span class="s0"># you want to compute hessian once.</span>
            <span class="s1">A </span><span class="s2">= </span><span class="s1">sf</span><span class="s2">.</span><span class="s1">hess</span><span class="s2">(</span><span class="s1">xk</span><span class="s2">)</span>
            <span class="s1">hcalls </span><span class="s2">+= </span><span class="s6">1</span>

        <span class="s4">for </span><span class="s1">k2 </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">cg_maxiter</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">add</span><span class="s2">.</span><span class="s1">reduce</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">ri</span><span class="s2">)) &lt;= </span><span class="s1">termcond</span><span class="s2">:</span>
                <span class="s4">break</span>
            <span class="s4">if </span><span class="s1">fhess </span><span class="s4">is None</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s1">fhess_p </span><span class="s4">is None</span><span class="s2">:</span>
                    <span class="s1">Ap </span><span class="s2">= </span><span class="s1">approx_fhess_p</span><span class="s2">(</span><span class="s1">xk</span><span class="s2">, </span><span class="s1">psupi</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">, </span><span class="s1">epsilon</span><span class="s2">)</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">Ap </span><span class="s2">= </span><span class="s1">fhess_p</span><span class="s2">(</span><span class="s1">xk</span><span class="s2">, </span><span class="s1">psupi</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
                    <span class="s1">hcalls </span><span class="s2">+= </span><span class="s6">1</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s0"># hess was supplied as a callable or hessian update strategy, so</span>
                <span class="s0"># A is a dense numpy array or sparse matrix</span>
                <span class="s1">Ap </span><span class="s2">= </span><span class="s1">A</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">psupi</span><span class="s2">)</span>
            <span class="s0"># check curvature</span>
            <span class="s1">Ap </span><span class="s2">= </span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">Ap</span><span class="s2">).</span><span class="s1">squeeze</span><span class="s2">()  </span><span class="s0"># get rid of matrices...</span>
            <span class="s1">curv </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">psupi</span><span class="s2">, </span><span class="s1">Ap</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s6">0 </span><span class="s2">&lt;= </span><span class="s1">curv </span><span class="s2">&lt;= </span><span class="s6">3 </span><span class="s2">* </span><span class="s1">float64eps</span><span class="s2">:</span>
                <span class="s4">break</span>
            <span class="s4">elif </span><span class="s1">curv </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s2">(</span><span class="s1">i </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">):</span>
                    <span class="s4">break</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s0"># fall back to steepest descent direction</span>
                    <span class="s1">xsupi </span><span class="s2">= </span><span class="s1">dri0 </span><span class="s2">/ (-</span><span class="s1">curv</span><span class="s2">) * </span><span class="s1">b</span>
                    <span class="s4">break</span>
            <span class="s1">alphai </span><span class="s2">= </span><span class="s1">dri0 </span><span class="s2">/ </span><span class="s1">curv</span>
            <span class="s1">xsupi </span><span class="s2">+= </span><span class="s1">alphai </span><span class="s2">* </span><span class="s1">psupi</span>
            <span class="s1">ri </span><span class="s2">+= </span><span class="s1">alphai </span><span class="s2">* </span><span class="s1">Ap</span>
            <span class="s1">dri1 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">ri</span><span class="s2">, </span><span class="s1">ri</span><span class="s2">)</span>
            <span class="s1">betai </span><span class="s2">= </span><span class="s1">dri1 </span><span class="s2">/ </span><span class="s1">dri0</span>
            <span class="s1">psupi </span><span class="s2">= -</span><span class="s1">ri </span><span class="s2">+ </span><span class="s1">betai </span><span class="s2">* </span><span class="s1">psupi</span>
            <span class="s1">i </span><span class="s2">+= </span><span class="s6">1</span>
            <span class="s1">dri0 </span><span class="s2">= </span><span class="s1">dri1          </span><span class="s0"># update np.dot(ri,ri) for next time.</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s0"># curvature keeps increasing, bail out</span>
            <span class="s1">msg </span><span class="s2">= (</span><span class="s3">&quot;Warning: CG iterations didn't converge. The Hessian is not &quot;</span>
                   <span class="s3">&quot;positive definite.&quot;</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">terminate</span><span class="s2">(</span><span class="s6">3</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">)</span>

        <span class="s1">pk </span><span class="s2">= </span><span class="s1">xsupi  </span><span class="s0"># search direction is solution to system.</span>
        <span class="s1">gfk </span><span class="s2">= -</span><span class="s1">b    </span><span class="s0"># gradient at xk</span>

        <span class="s4">try</span><span class="s2">:</span>
            <span class="s1">alphak</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">old_fval</span><span class="s2">, </span><span class="s1">old_old_fval</span><span class="s2">, </span><span class="s1">gfkp1 </span><span class="s2">= </span><span class="s1">\</span>
                     <span class="s1">_line_search_wolfe12</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">, </span><span class="s1">xk</span><span class="s2">, </span><span class="s1">pk</span><span class="s2">, </span><span class="s1">gfk</span><span class="s2">,</span>
                                          <span class="s1">old_fval</span><span class="s2">, </span><span class="s1">old_old_fval</span><span class="s2">, </span><span class="s1">c1</span><span class="s2">=</span><span class="s1">c1</span><span class="s2">, </span><span class="s1">c2</span><span class="s2">=</span><span class="s1">c2</span><span class="s2">)</span>
        <span class="s4">except </span><span class="s1">_LineSearchError</span><span class="s2">:</span>
            <span class="s0"># Line search failed to find a better solution.</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s3">&quot;Warning: &quot; </span><span class="s2">+ </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'pr_loss'</span><span class="s2">]</span>
            <span class="s4">return </span><span class="s1">terminate</span><span class="s2">(</span><span class="s6">2</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">)</span>

        <span class="s1">update </span><span class="s2">= </span><span class="s1">alphak </span><span class="s2">* </span><span class="s1">pk</span>
        <span class="s1">xk </span><span class="s2">+= </span><span class="s1">update        </span><span class="s0"># upcast if necessary</span>
        <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
            <span class="s1">allvecs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">xk</span><span class="s2">)</span>
        <span class="s1">k </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s1">intermediate_result </span><span class="s2">= </span><span class="s1">OptimizeResult</span><span class="s2">(</span><span class="s1">x</span><span class="s2">=</span><span class="s1">xk</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">=</span><span class="s1">old_fval</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">_call_callback_maybe_halt</span><span class="s2">(</span><span class="s1">callback</span><span class="s2">, </span><span class="s1">intermediate_result</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">terminate</span><span class="s2">(</span><span class="s6">5</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s2">)</span>
        <span class="s1">update_l1norm </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">update</span><span class="s2">, </span><span class="s1">ord</span><span class="s2">=</span><span class="s6">1</span><span class="s2">)</span>

    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">old_fval</span><span class="s2">) </span><span class="s4">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">update_l1norm</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">terminate</span><span class="s2">(</span><span class="s6">3</span><span class="s2">, </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'nan'</span><span class="s2">])</span>

        <span class="s1">msg </span><span class="s2">= </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'success'</span><span class="s2">]</span>
        <span class="s4">return </span><span class="s1">terminate</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">fminbound</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">xtol</span><span class="s2">=</span><span class="s6">1e-5</span><span class="s2">, </span><span class="s1">maxfun</span><span class="s2">=</span><span class="s6">500</span><span class="s2">,</span>
              <span class="s1">full_output</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s6">1</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Bounded minimization for scalar functions. 
 
    Parameters 
    ---------- 
    func : callable f(x,*args) 
        Objective function to be minimized (must accept and return scalars). 
    x1, x2 : float or array scalar 
        Finite optimization bounds. 
    args : tuple, optional 
        Extra arguments passed to function. 
    xtol : float, optional 
        The convergence tolerance. 
    maxfun : int, optional 
        Maximum number of function evaluations allowed. 
    full_output : bool, optional 
        If True, return optional outputs. 
    disp : int, optional 
        If non-zero, print messages. 
            0 : no message printing. 
            1 : non-convergence notification messages only. 
            2 : print a message on convergence too. 
            3 : print iteration results. 
 
 
    Returns 
    ------- 
    xopt : ndarray 
        Parameters (over given interval) which minimize the 
        objective function. 
    fval : number 
        (Optional output) The function value evaluated at the minimizer. 
    ierr : int 
        (Optional output) An error flag (0 if converged, 1 if maximum number of 
        function calls reached). 
    numfunc : int 
        (Optional output) The number of function calls made. 
 
    See also 
    -------- 
    minimize_scalar: Interface to minimization algorithms for scalar 
        univariate functions. See the 'Bounded' `method` in particular. 
 
    Notes 
    ----- 
    Finds a local minimizer of the scalar function `func` in the 
    interval x1 &lt; xopt &lt; x2 using Brent's method. (See `brent` 
    for auto-bracketing.) 
 
    References 
    ---------- 
    .. [1] Forsythe, G.E., M. A. Malcolm, and C. B. Moler. &quot;Computer Methods 
           for Mathematical Computations.&quot; Prentice-Hall Series in Automatic 
           Computation 259 (1977). 
    .. [2] Brent, Richard P. Algorithms for Minimization Without Derivatives. 
           Courier Corporation, 2013. 
 
    Examples 
    -------- 
    `fminbound` finds the minimizer of the function in the given range. 
    The following examples illustrate this. 
 
    &gt;&gt;&gt; from scipy import optimize 
    &gt;&gt;&gt; def f(x): 
    ...     return (x-1)**2 
    &gt;&gt;&gt; minimizer = optimize.fminbound(f, -4, 4) 
    &gt;&gt;&gt; minimizer 
    1.0 
    &gt;&gt;&gt; minimum = f(minimizer) 
    &gt;&gt;&gt; minimum 
    0.0 
    &gt;&gt;&gt; res = optimize.fminbound(f, 3, 4, full_output=True) 
    &gt;&gt;&gt; minimizer, fval, ierr, numfunc = res 
    &gt;&gt;&gt; minimizer 
    3.000005960860986 
    &gt;&gt;&gt; minimum = f(minimizer) 
    &gt;&gt;&gt; minimum, fval 
    (4.000023843479476, 4.000023843479476) 
    &quot;&quot;&quot;</span>
    <span class="s1">options </span><span class="s2">= {</span><span class="s3">'xatol'</span><span class="s2">: </span><span class="s1">xtol</span><span class="s2">,</span>
               <span class="s3">'maxiter'</span><span class="s2">: </span><span class="s1">maxfun</span><span class="s2">,</span>
               <span class="s3">'disp'</span><span class="s2">: </span><span class="s1">disp</span><span class="s2">}</span>

    <span class="s1">res </span><span class="s2">= </span><span class="s1">_minimize_scalar_bounded</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, (</span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">), </span><span class="s1">args</span><span class="s2">, **</span><span class="s1">options</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">full_output</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'fun'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'status'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'nfev'</span><span class="s2">]</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">]</span>


<span class="s4">def </span><span class="s1">_minimize_scalar_bounded</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(),</span>
                             <span class="s1">xatol</span><span class="s2">=</span><span class="s6">1e-5</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s6">500</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s6">0</span><span class="s2">,</span>
                             <span class="s2">**</span><span class="s1">unknown_options</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Options 
    ------- 
    maxiter : int 
        Maximum number of iterations to perform. 
    disp: int, optional 
        If non-zero, print messages. 
            0 : no message printing. 
            1 : non-convergence notification messages only. 
            2 : print a message on convergence too. 
            3 : print iteration results. 
    xatol : float 
        Absolute error in solution `xopt` acceptable for convergence. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_unknown_options</span><span class="s2">(</span><span class="s1">unknown_options</span><span class="s2">)</span>
    <span class="s1">maxfun </span><span class="s2">= </span><span class="s1">maxiter</span>
    <span class="s0"># Test bounds are of correct form</span>
    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">bounds</span><span class="s2">) != </span><span class="s6">2</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'bounds must have two elements.'</span><span class="s2">)</span>
    <span class="s1">x1</span><span class="s2">, </span><span class="s1">x2 </span><span class="s2">= </span><span class="s1">bounds</span>

    <span class="s4">if not </span><span class="s2">(</span><span class="s1">is_finite_scalar</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">) </span><span class="s4">and </span><span class="s1">is_finite_scalar</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">)):</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Optimization bounds must be finite scalars.&quot;</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">x1 </span><span class="s2">&gt; </span><span class="s1">x2</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;The lower bound exceeds the upper bound.&quot;</span><span class="s2">)</span>

    <span class="s1">flag </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s1">header </span><span class="s2">= </span><span class="s3">' Func-count     x          f(x)          Procedure'</span>
    <span class="s1">step </span><span class="s2">= </span><span class="s3">'       initial'</span>

    <span class="s1">sqrt_eps </span><span class="s2">= </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s6">2.2e-16</span><span class="s2">)</span>
    <span class="s1">golden_mean </span><span class="s2">= </span><span class="s6">0.5 </span><span class="s2">* (</span><span class="s6">3.0 </span><span class="s2">- </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s6">5.0</span><span class="s2">))</span>
    <span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">= </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span>
    <span class="s1">fulc </span><span class="s2">= </span><span class="s1">a </span><span class="s2">+ </span><span class="s1">golden_mean </span><span class="s2">* (</span><span class="s1">b </span><span class="s2">- </span><span class="s1">a</span><span class="s2">)</span>
    <span class="s1">nfc</span><span class="s2">, </span><span class="s1">xf </span><span class="s2">= </span><span class="s1">fulc</span><span class="s2">, </span><span class="s1">fulc</span>
    <span class="s1">rat </span><span class="s2">= </span><span class="s1">e </span><span class="s2">= </span><span class="s6">0.0</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">xf</span>
    <span class="s1">fx </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s1">num </span><span class="s2">= </span><span class="s6">1</span>
    <span class="s1">fmin_data </span><span class="s2">= (</span><span class="s6">1</span><span class="s2">, </span><span class="s1">xf</span><span class="s2">, </span><span class="s1">fx</span><span class="s2">)</span>
    <span class="s1">fu </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>

    <span class="s1">ffulc </span><span class="s2">= </span><span class="s1">fnfc </span><span class="s2">= </span><span class="s1">fx</span>
    <span class="s1">xm </span><span class="s2">= </span><span class="s6">0.5 </span><span class="s2">* (</span><span class="s1">a </span><span class="s2">+ </span><span class="s1">b</span><span class="s2">)</span>
    <span class="s1">tol1 </span><span class="s2">= </span><span class="s1">sqrt_eps </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">xf</span><span class="s2">) + </span><span class="s1">xatol </span><span class="s2">/ </span><span class="s6">3.0</span>
    <span class="s1">tol2 </span><span class="s2">= </span><span class="s6">2.0 </span><span class="s2">* </span><span class="s1">tol1</span>

    <span class="s4">if </span><span class="s1">disp </span><span class="s2">&gt; </span><span class="s6">2</span><span class="s2">:</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot; &quot;</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">header</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;%5.0f   %12.6g %12.6g %s&quot; </span><span class="s2">% (</span><span class="s1">fmin_data </span><span class="s2">+ (</span><span class="s1">step</span><span class="s2">,)))</span>

    <span class="s4">while </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">xf </span><span class="s2">- </span><span class="s1">xm</span><span class="s2">) &gt; (</span><span class="s1">tol2 </span><span class="s2">- </span><span class="s6">0.5 </span><span class="s2">* (</span><span class="s1">b </span><span class="s2">- </span><span class="s1">a</span><span class="s2">))):</span>
        <span class="s1">golden </span><span class="s2">= </span><span class="s6">1</span>
        <span class="s0"># Check for parabolic fit</span>
        <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">e</span><span class="s2">) &gt; </span><span class="s1">tol1</span><span class="s2">:</span>
            <span class="s1">golden </span><span class="s2">= </span><span class="s6">0</span>
            <span class="s1">r </span><span class="s2">= (</span><span class="s1">xf </span><span class="s2">- </span><span class="s1">nfc</span><span class="s2">) * (</span><span class="s1">fx </span><span class="s2">- </span><span class="s1">ffulc</span><span class="s2">)</span>
            <span class="s1">q </span><span class="s2">= (</span><span class="s1">xf </span><span class="s2">- </span><span class="s1">fulc</span><span class="s2">) * (</span><span class="s1">fx </span><span class="s2">- </span><span class="s1">fnfc</span><span class="s2">)</span>
            <span class="s1">p </span><span class="s2">= (</span><span class="s1">xf </span><span class="s2">- </span><span class="s1">fulc</span><span class="s2">) * </span><span class="s1">q </span><span class="s2">- (</span><span class="s1">xf </span><span class="s2">- </span><span class="s1">nfc</span><span class="s2">) * </span><span class="s1">r</span>
            <span class="s1">q </span><span class="s2">= </span><span class="s6">2.0 </span><span class="s2">* (</span><span class="s1">q </span><span class="s2">- </span><span class="s1">r</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">q </span><span class="s2">&gt; </span><span class="s6">0.0</span><span class="s2">:</span>
                <span class="s1">p </span><span class="s2">= -</span><span class="s1">p</span>
            <span class="s1">q </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">q</span><span class="s2">)</span>
            <span class="s1">r </span><span class="s2">= </span><span class="s1">e</span>
            <span class="s1">e </span><span class="s2">= </span><span class="s1">rat</span>

            <span class="s0"># Check for acceptability of parabola</span>
            <span class="s4">if </span><span class="s2">((</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">p</span><span class="s2">) &lt; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s6">0.5</span><span class="s2">*</span><span class="s1">q</span><span class="s2">*</span><span class="s1">r</span><span class="s2">)) </span><span class="s4">and </span><span class="s2">(</span><span class="s1">p </span><span class="s2">&gt; </span><span class="s1">q</span><span class="s2">*(</span><span class="s1">a </span><span class="s2">- </span><span class="s1">xf</span><span class="s2">)) </span><span class="s4">and</span>
                    <span class="s2">(</span><span class="s1">p </span><span class="s2">&lt; </span><span class="s1">q </span><span class="s2">* (</span><span class="s1">b </span><span class="s2">- </span><span class="s1">xf</span><span class="s2">))):</span>
                <span class="s1">rat </span><span class="s2">= (</span><span class="s1">p </span><span class="s2">+ </span><span class="s6">0.0</span><span class="s2">) / </span><span class="s1">q</span>
                <span class="s1">x </span><span class="s2">= </span><span class="s1">xf </span><span class="s2">+ </span><span class="s1">rat</span>
                <span class="s1">step </span><span class="s2">= </span><span class="s3">'       parabolic'</span>

                <span class="s4">if </span><span class="s2">((</span><span class="s1">x </span><span class="s2">- </span><span class="s1">a</span><span class="s2">) &lt; </span><span class="s1">tol2</span><span class="s2">) </span><span class="s4">or </span><span class="s2">((</span><span class="s1">b </span><span class="s2">- </span><span class="s1">x</span><span class="s2">) &lt; </span><span class="s1">tol2</span><span class="s2">):</span>
                    <span class="s1">si </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sign</span><span class="s2">(</span><span class="s1">xm </span><span class="s2">- </span><span class="s1">xf</span><span class="s2">) + ((</span><span class="s1">xm </span><span class="s2">- </span><span class="s1">xf</span><span class="s2">) == </span><span class="s6">0</span><span class="s2">)</span>
                    <span class="s1">rat </span><span class="s2">= </span><span class="s1">tol1 </span><span class="s2">* </span><span class="s1">si</span>
            <span class="s4">else</span><span class="s2">:      </span><span class="s0"># do a golden-section step</span>
                <span class="s1">golden </span><span class="s2">= </span><span class="s6">1</span>

        <span class="s4">if </span><span class="s1">golden</span><span class="s2">:  </span><span class="s0"># do a golden-section step</span>
            <span class="s4">if </span><span class="s1">xf </span><span class="s2">&gt;= </span><span class="s1">xm</span><span class="s2">:</span>
                <span class="s1">e </span><span class="s2">= </span><span class="s1">a </span><span class="s2">- </span><span class="s1">xf</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">e </span><span class="s2">= </span><span class="s1">b </span><span class="s2">- </span><span class="s1">xf</span>
            <span class="s1">rat </span><span class="s2">= </span><span class="s1">golden_mean</span><span class="s2">*</span><span class="s1">e</span>
            <span class="s1">step </span><span class="s2">= </span><span class="s3">'       golden'</span>

        <span class="s1">si </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sign</span><span class="s2">(</span><span class="s1">rat</span><span class="s2">) + (</span><span class="s1">rat </span><span class="s2">== </span><span class="s6">0</span><span class="s2">)</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">xf </span><span class="s2">+ </span><span class="s1">si </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">rat</span><span class="s2">), </span><span class="s1">tol1</span><span class="s2">)</span>
        <span class="s1">fu </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s1">num </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s1">fmin_data </span><span class="s2">= (</span><span class="s1">num</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">fu</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">disp </span><span class="s2">&gt; </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;%5.0f   %12.6g %12.6g %s&quot; </span><span class="s2">% (</span><span class="s1">fmin_data </span><span class="s2">+ (</span><span class="s1">step</span><span class="s2">,)))</span>

        <span class="s4">if </span><span class="s1">fu </span><span class="s2">&lt;= </span><span class="s1">fx</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">x </span><span class="s2">&gt;= </span><span class="s1">xf</span><span class="s2">:</span>
                <span class="s1">a </span><span class="s2">= </span><span class="s1">xf</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">b </span><span class="s2">= </span><span class="s1">xf</span>
            <span class="s1">fulc</span><span class="s2">, </span><span class="s1">ffulc </span><span class="s2">= </span><span class="s1">nfc</span><span class="s2">, </span><span class="s1">fnfc</span>
            <span class="s1">nfc</span><span class="s2">, </span><span class="s1">fnfc </span><span class="s2">= </span><span class="s1">xf</span><span class="s2">, </span><span class="s1">fx</span>
            <span class="s1">xf</span><span class="s2">, </span><span class="s1">fx </span><span class="s2">= </span><span class="s1">x</span><span class="s2">, </span><span class="s1">fu</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">x </span><span class="s2">&lt; </span><span class="s1">xf</span><span class="s2">:</span>
                <span class="s1">a </span><span class="s2">= </span><span class="s1">x</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">b </span><span class="s2">= </span><span class="s1">x</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s1">fu </span><span class="s2">&lt;= </span><span class="s1">fnfc</span><span class="s2">) </span><span class="s4">or </span><span class="s2">(</span><span class="s1">nfc </span><span class="s2">== </span><span class="s1">xf</span><span class="s2">):</span>
                <span class="s1">fulc</span><span class="s2">, </span><span class="s1">ffulc </span><span class="s2">= </span><span class="s1">nfc</span><span class="s2">, </span><span class="s1">fnfc</span>
                <span class="s1">nfc</span><span class="s2">, </span><span class="s1">fnfc </span><span class="s2">= </span><span class="s1">x</span><span class="s2">, </span><span class="s1">fu</span>
            <span class="s4">elif </span><span class="s2">(</span><span class="s1">fu </span><span class="s2">&lt;= </span><span class="s1">ffulc</span><span class="s2">) </span><span class="s4">or </span><span class="s2">(</span><span class="s1">fulc </span><span class="s2">== </span><span class="s1">xf</span><span class="s2">) </span><span class="s4">or </span><span class="s2">(</span><span class="s1">fulc </span><span class="s2">== </span><span class="s1">nfc</span><span class="s2">):</span>
                <span class="s1">fulc</span><span class="s2">, </span><span class="s1">ffulc </span><span class="s2">= </span><span class="s1">x</span><span class="s2">, </span><span class="s1">fu</span>

        <span class="s1">xm </span><span class="s2">= </span><span class="s6">0.5 </span><span class="s2">* (</span><span class="s1">a </span><span class="s2">+ </span><span class="s1">b</span><span class="s2">)</span>
        <span class="s1">tol1 </span><span class="s2">= </span><span class="s1">sqrt_eps </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">xf</span><span class="s2">) + </span><span class="s1">xatol </span><span class="s2">/ </span><span class="s6">3.0</span>
        <span class="s1">tol2 </span><span class="s2">= </span><span class="s6">2.0 </span><span class="s2">* </span><span class="s1">tol1</span>

        <span class="s4">if </span><span class="s1">num </span><span class="s2">&gt;= </span><span class="s1">maxfun</span><span class="s2">:</span>
            <span class="s1">flag </span><span class="s2">= </span><span class="s6">1</span>
            <span class="s4">break</span>

    <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">xf</span><span class="s2">) </span><span class="s4">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">fx</span><span class="s2">) </span><span class="s4">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">fu</span><span class="s2">):</span>
        <span class="s1">flag </span><span class="s2">= </span><span class="s6">2</span>

    <span class="s1">fval </span><span class="s2">= </span><span class="s1">fx</span>
    <span class="s4">if </span><span class="s1">disp </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">:</span>
        <span class="s1">_endprint</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">flag</span><span class="s2">, </span><span class="s1">fval</span><span class="s2">, </span><span class="s1">maxfun</span><span class="s2">, </span><span class="s1">xatol</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">)</span>

    <span class="s1">result </span><span class="s2">= </span><span class="s1">OptimizeResult</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">=</span><span class="s1">fval</span><span class="s2">, </span><span class="s1">status</span><span class="s2">=</span><span class="s1">flag</span><span class="s2">, </span><span class="s1">success</span><span class="s2">=(</span><span class="s1">flag </span><span class="s2">== </span><span class="s6">0</span><span class="s2">),</span>
                            <span class="s1">message</span><span class="s2">={</span><span class="s6">0</span><span class="s2">: </span><span class="s3">'Solution found.'</span><span class="s2">,</span>
                                     <span class="s6">1</span><span class="s2">: </span><span class="s3">'Maximum number of function calls '</span>
                                        <span class="s3">'reached.'</span><span class="s2">,</span>
                                     <span class="s6">2</span><span class="s2">: </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'nan'</span><span class="s2">]}.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">flag</span><span class="s2">, </span><span class="s3">''</span><span class="s2">),</span>
                            <span class="s1">x</span><span class="s2">=</span><span class="s1">xf</span><span class="s2">, </span><span class="s1">nfev</span><span class="s2">=</span><span class="s1">num</span><span class="s2">, </span><span class="s1">nit</span><span class="s2">=</span><span class="s1">num</span><span class="s2">)</span>

    <span class="s4">return </span><span class="s1">result</span>


<span class="s4">class </span><span class="s1">Brent</span><span class="s2">:</span>
    <span class="s0">#need to rethink design of __init__</span>
    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">tol</span><span class="s2">=</span><span class="s6">1.48e-8</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s6">500</span><span class="s2">,</span>
                 <span class="s1">full_output</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s6">0</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">func </span><span class="s2">= </span><span class="s1">func</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">args </span><span class="s2">= </span><span class="s1">args</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">tol </span><span class="s2">= </span><span class="s1">tol</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">maxiter </span><span class="s2">= </span><span class="s1">maxiter</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_mintol </span><span class="s2">= </span><span class="s6">1.0e-11</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_cg </span><span class="s2">= </span><span class="s6">0.3819660</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">xmin </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">fval </span><span class="s2">= </span><span class="s4">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">iter </span><span class="s2">= </span><span class="s6">0</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">funcalls </span><span class="s2">= </span><span class="s6">0</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">disp </span><span class="s2">= </span><span class="s1">disp</span>

    <span class="s0"># need to rethink design of set_bracket (new options, etc.)</span>
    <span class="s4">def </span><span class="s1">set_bracket</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">brack</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">brack </span><span class="s2">= </span><span class="s1">brack</span>

    <span class="s4">def </span><span class="s1">get_bracket_info</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">#set up</span>
        <span class="s1">func </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span>
        <span class="s1">args </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span>
        <span class="s1">brack </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">brack</span>
        <span class="s0">### BEGIN core bracket_info code ###</span>
        <span class="s0">### carefully DOCUMENT any CHANGES in core ##</span>
        <span class="s4">if </span><span class="s1">brack </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">xa</span><span class="s2">, </span><span class="s1">xb</span><span class="s2">, </span><span class="s1">xc</span><span class="s2">, </span><span class="s1">fa</span><span class="s2">, </span><span class="s1">fb</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">, </span><span class="s1">funcalls </span><span class="s2">= </span><span class="s1">bracket</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">brack</span><span class="s2">) == </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s1">xa</span><span class="s2">, </span><span class="s1">xb</span><span class="s2">, </span><span class="s1">xc</span><span class="s2">, </span><span class="s1">fa</span><span class="s2">, </span><span class="s1">fb</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">, </span><span class="s1">funcalls </span><span class="s2">= </span><span class="s1">bracket</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">xa</span><span class="s2">=</span><span class="s1">brack</span><span class="s2">[</span><span class="s6">0</span><span class="s2">],</span>
                                                       <span class="s1">xb</span><span class="s2">=</span><span class="s1">brack</span><span class="s2">[</span><span class="s6">1</span><span class="s2">], </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">brack</span><span class="s2">) == </span><span class="s6">3</span><span class="s2">:</span>
            <span class="s1">xa</span><span class="s2">, </span><span class="s1">xb</span><span class="s2">, </span><span class="s1">xc </span><span class="s2">= </span><span class="s1">brack</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s1">xa </span><span class="s2">&gt; </span><span class="s1">xc</span><span class="s2">):  </span><span class="s0"># swap so xa &lt; xc can be assumed</span>
                <span class="s1">xc</span><span class="s2">, </span><span class="s1">xa </span><span class="s2">= </span><span class="s1">xa</span><span class="s2">, </span><span class="s1">xc</span>
            <span class="s4">if not </span><span class="s2">((</span><span class="s1">xa </span><span class="s2">&lt; </span><span class="s1">xb</span><span class="s2">) </span><span class="s4">and </span><span class="s2">(</span><span class="s1">xb </span><span class="s2">&lt; </span><span class="s1">xc</span><span class="s2">)):</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s3">&quot;Bracketing values (xa, xb, xc) do not&quot;</span>
                    <span class="s3">&quot; fulfill this requirement: (xa &lt; xb) and (xb &lt; xc)&quot;</span>
                <span class="s2">)</span>
            <span class="s1">fa </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">xa</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
            <span class="s1">fb </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">xb</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
            <span class="s1">fc </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">xc</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
            <span class="s4">if not </span><span class="s2">((</span><span class="s1">fb </span><span class="s2">&lt; </span><span class="s1">fa</span><span class="s2">) </span><span class="s4">and </span><span class="s2">(</span><span class="s1">fb </span><span class="s2">&lt; </span><span class="s1">fc</span><span class="s2">)):</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s3">&quot;Bracketing values (xa, xb, xc) do not fulfill&quot;</span>
                    <span class="s3">&quot; this requirement: (f(xb) &lt; f(xa)) and (f(xb) &lt; f(xc))&quot;</span>
                <span class="s2">)</span>

            <span class="s1">funcalls </span><span class="s2">= </span><span class="s6">3</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Bracketing interval must be &quot;</span>
                             <span class="s3">&quot;length 2 or 3 sequence.&quot;</span><span class="s2">)</span>
        <span class="s0">### END core bracket_info code ###</span>

        <span class="s4">return </span><span class="s1">xa</span><span class="s2">, </span><span class="s1">xb</span><span class="s2">, </span><span class="s1">xc</span><span class="s2">, </span><span class="s1">fa</span><span class="s2">, </span><span class="s1">fb</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">, </span><span class="s1">funcalls</span>

    <span class="s4">def </span><span class="s1">optimize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0"># set up for optimization</span>
        <span class="s1">func </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">func</span>
        <span class="s1">xa</span><span class="s2">, </span><span class="s1">xb</span><span class="s2">, </span><span class="s1">xc</span><span class="s2">, </span><span class="s1">fa</span><span class="s2">, </span><span class="s1">fb</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">, </span><span class="s1">funcalls </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_bracket_info</span><span class="s2">()</span>
        <span class="s1">_mintol </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mintol</span>
        <span class="s1">_cg </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_cg</span>
        <span class="s0">#################################</span>
        <span class="s0">#BEGIN CORE ALGORITHM</span>
        <span class="s0">#################################</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">w </span><span class="s2">= </span><span class="s1">v </span><span class="s2">= </span><span class="s1">xb</span>
        <span class="s1">fw </span><span class="s2">= </span><span class="s1">fv </span><span class="s2">= </span><span class="s1">fx </span><span class="s2">= </span><span class="s1">fb</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s1">xa </span><span class="s2">&lt; </span><span class="s1">xc</span><span class="s2">):</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">xa</span>
            <span class="s1">b </span><span class="s2">= </span><span class="s1">xc</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">a </span><span class="s2">= </span><span class="s1">xc</span>
            <span class="s1">b </span><span class="s2">= </span><span class="s1">xa</span>
        <span class="s1">deltax </span><span class="s2">= </span><span class="s6">0.0</span>
        <span class="s1">iter </span><span class="s2">= </span><span class="s6">0</span>

        <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">disp </span><span class="s2">&gt; </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot; &quot;</span><span class="s2">)</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">f&quot;</span><span class="s4">{</span><span class="s3">'Func-count'</span><span class="s4">:</span><span class="s3">^12</span><span class="s4">} {</span><span class="s3">'x'</span><span class="s4">:</span><span class="s3">^12</span><span class="s4">} {</span><span class="s3">'f(x)'</span><span class="s4">: </span><span class="s3">^12</span><span class="s4">}</span><span class="s3">&quot;</span><span class="s2">)</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">f&quot;</span><span class="s4">{</span><span class="s1">funcalls</span><span class="s4">:</span><span class="s3">^12g</span><span class="s4">} {</span><span class="s1">x</span><span class="s4">:</span><span class="s3">^12.6g</span><span class="s4">} {</span><span class="s1">fx</span><span class="s4">:</span><span class="s3">^12.6g</span><span class="s4">}</span><span class="s3">&quot;</span><span class="s2">)</span>

        <span class="s4">while </span><span class="s2">(</span><span class="s1">iter </span><span class="s2">&lt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">maxiter</span><span class="s2">):</span>
            <span class="s1">tol1 </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tol </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) + </span><span class="s1">_mintol</span>
            <span class="s1">tol2 </span><span class="s2">= </span><span class="s6">2.0 </span><span class="s2">* </span><span class="s1">tol1</span>
            <span class="s1">xmid </span><span class="s2">= </span><span class="s6">0.5 </span><span class="s2">* (</span><span class="s1">a </span><span class="s2">+ </span><span class="s1">b</span><span class="s2">)</span>
            <span class="s0"># check for convergence</span>
            <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">x </span><span class="s2">- </span><span class="s1">xmid</span><span class="s2">) &lt; (</span><span class="s1">tol2 </span><span class="s2">- </span><span class="s6">0.5 </span><span class="s2">* (</span><span class="s1">b </span><span class="s2">- </span><span class="s1">a</span><span class="s2">)):</span>
                <span class="s4">break</span>
            <span class="s0"># XXX In the first iteration, rat is only bound in the true case</span>
            <span class="s0"># of this conditional. This used to cause an UnboundLocalError</span>
            <span class="s0"># (gh-4140). It should be set before the if (but to what?).</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">deltax</span><span class="s2">) &lt;= </span><span class="s1">tol1</span><span class="s2">):</span>
                <span class="s4">if </span><span class="s2">(</span><span class="s1">x </span><span class="s2">&gt;= </span><span class="s1">xmid</span><span class="s2">):</span>
                    <span class="s1">deltax </span><span class="s2">= </span><span class="s1">a </span><span class="s2">- </span><span class="s1">x       </span><span class="s0"># do a golden section step</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">deltax </span><span class="s2">= </span><span class="s1">b </span><span class="s2">- </span><span class="s1">x</span>
                <span class="s1">rat </span><span class="s2">= </span><span class="s1">_cg </span><span class="s2">* </span><span class="s1">deltax</span>
            <span class="s4">else</span><span class="s2">:                              </span><span class="s0"># do a parabolic step</span>
                <span class="s1">tmp1 </span><span class="s2">= (</span><span class="s1">x </span><span class="s2">- </span><span class="s1">w</span><span class="s2">) * (</span><span class="s1">fx </span><span class="s2">- </span><span class="s1">fv</span><span class="s2">)</span>
                <span class="s1">tmp2 </span><span class="s2">= (</span><span class="s1">x </span><span class="s2">- </span><span class="s1">v</span><span class="s2">) * (</span><span class="s1">fx </span><span class="s2">- </span><span class="s1">fw</span><span class="s2">)</span>
                <span class="s1">p </span><span class="s2">= (</span><span class="s1">x </span><span class="s2">- </span><span class="s1">v</span><span class="s2">) * </span><span class="s1">tmp2 </span><span class="s2">- (</span><span class="s1">x </span><span class="s2">- </span><span class="s1">w</span><span class="s2">) * </span><span class="s1">tmp1</span>
                <span class="s1">tmp2 </span><span class="s2">= </span><span class="s6">2.0 </span><span class="s2">* (</span><span class="s1">tmp2 </span><span class="s2">- </span><span class="s1">tmp1</span><span class="s2">)</span>
                <span class="s4">if </span><span class="s2">(</span><span class="s1">tmp2 </span><span class="s2">&gt; </span><span class="s6">0.0</span><span class="s2">):</span>
                    <span class="s1">p </span><span class="s2">= -</span><span class="s1">p</span>
                <span class="s1">tmp2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">tmp2</span><span class="s2">)</span>
                <span class="s1">dx_temp </span><span class="s2">= </span><span class="s1">deltax</span>
                <span class="s1">deltax </span><span class="s2">= </span><span class="s1">rat</span>
                <span class="s0"># check parabolic fit</span>
                <span class="s4">if </span><span class="s2">((</span><span class="s1">p </span><span class="s2">&gt; </span><span class="s1">tmp2 </span><span class="s2">* (</span><span class="s1">a </span><span class="s2">- </span><span class="s1">x</span><span class="s2">)) </span><span class="s4">and </span><span class="s2">(</span><span class="s1">p </span><span class="s2">&lt; </span><span class="s1">tmp2 </span><span class="s2">* (</span><span class="s1">b </span><span class="s2">- </span><span class="s1">x</span><span class="s2">)) </span><span class="s4">and</span>
                        <span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">p</span><span class="s2">) &lt; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s6">0.5 </span><span class="s2">* </span><span class="s1">tmp2 </span><span class="s2">* </span><span class="s1">dx_temp</span><span class="s2">))):</span>
                    <span class="s1">rat </span><span class="s2">= </span><span class="s1">p </span><span class="s2">* </span><span class="s6">1.0 </span><span class="s2">/ </span><span class="s1">tmp2        </span><span class="s0"># if parabolic step is useful.</span>
                    <span class="s1">u </span><span class="s2">= </span><span class="s1">x </span><span class="s2">+ </span><span class="s1">rat</span>
                    <span class="s4">if </span><span class="s2">((</span><span class="s1">u </span><span class="s2">- </span><span class="s1">a</span><span class="s2">) &lt; </span><span class="s1">tol2 </span><span class="s4">or </span><span class="s2">(</span><span class="s1">b </span><span class="s2">- </span><span class="s1">u</span><span class="s2">) &lt; </span><span class="s1">tol2</span><span class="s2">):</span>
                        <span class="s4">if </span><span class="s1">xmid </span><span class="s2">- </span><span class="s1">x </span><span class="s2">&gt;= </span><span class="s6">0</span><span class="s2">:</span>
                            <span class="s1">rat </span><span class="s2">= </span><span class="s1">tol1</span>
                        <span class="s4">else</span><span class="s2">:</span>
                            <span class="s1">rat </span><span class="s2">= -</span><span class="s1">tol1</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s4">if </span><span class="s2">(</span><span class="s1">x </span><span class="s2">&gt;= </span><span class="s1">xmid</span><span class="s2">):</span>
                        <span class="s1">deltax </span><span class="s2">= </span><span class="s1">a </span><span class="s2">- </span><span class="s1">x  </span><span class="s0"># if it's not do a golden section step</span>
                    <span class="s4">else</span><span class="s2">:</span>
                        <span class="s1">deltax </span><span class="s2">= </span><span class="s1">b </span><span class="s2">- </span><span class="s1">x</span>
                    <span class="s1">rat </span><span class="s2">= </span><span class="s1">_cg </span><span class="s2">* </span><span class="s1">deltax</span>

            <span class="s4">if </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">rat</span><span class="s2">) &lt; </span><span class="s1">tol1</span><span class="s2">):            </span><span class="s0"># update by at least tol1</span>
                <span class="s4">if </span><span class="s1">rat </span><span class="s2">&gt;= </span><span class="s6">0</span><span class="s2">:</span>
                    <span class="s1">u </span><span class="s2">= </span><span class="s1">x </span><span class="s2">+ </span><span class="s1">tol1</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">u </span><span class="s2">= </span><span class="s1">x </span><span class="s2">- </span><span class="s1">tol1</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">u </span><span class="s2">= </span><span class="s1">x </span><span class="s2">+ </span><span class="s1">rat</span>
            <span class="s1">fu </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">u</span><span class="s2">,) + </span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">))      </span><span class="s0"># calculate new output value</span>
            <span class="s1">funcalls </span><span class="s2">+= </span><span class="s6">1</span>

            <span class="s4">if </span><span class="s2">(</span><span class="s1">fu </span><span class="s2">&gt; </span><span class="s1">fx</span><span class="s2">):                 </span><span class="s0"># if it's bigger than current</span>
                <span class="s4">if </span><span class="s2">(</span><span class="s1">u </span><span class="s2">&lt; </span><span class="s1">x</span><span class="s2">):</span>
                    <span class="s1">a </span><span class="s2">= </span><span class="s1">u</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">b </span><span class="s2">= </span><span class="s1">u</span>
                <span class="s4">if </span><span class="s2">(</span><span class="s1">fu </span><span class="s2">&lt;= </span><span class="s1">fw</span><span class="s2">) </span><span class="s4">or </span><span class="s2">(</span><span class="s1">w </span><span class="s2">== </span><span class="s1">x</span><span class="s2">):</span>
                    <span class="s1">v </span><span class="s2">= </span><span class="s1">w</span>
                    <span class="s1">w </span><span class="s2">= </span><span class="s1">u</span>
                    <span class="s1">fv </span><span class="s2">= </span><span class="s1">fw</span>
                    <span class="s1">fw </span><span class="s2">= </span><span class="s1">fu</span>
                <span class="s4">elif </span><span class="s2">(</span><span class="s1">fu </span><span class="s2">&lt;= </span><span class="s1">fv</span><span class="s2">) </span><span class="s4">or </span><span class="s2">(</span><span class="s1">v </span><span class="s2">== </span><span class="s1">x</span><span class="s2">) </span><span class="s4">or </span><span class="s2">(</span><span class="s1">v </span><span class="s2">== </span><span class="s1">w</span><span class="s2">):</span>
                    <span class="s1">v </span><span class="s2">= </span><span class="s1">u</span>
                    <span class="s1">fv </span><span class="s2">= </span><span class="s1">fu</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s4">if </span><span class="s2">(</span><span class="s1">u </span><span class="s2">&gt;= </span><span class="s1">x</span><span class="s2">):</span>
                    <span class="s1">a </span><span class="s2">= </span><span class="s1">x</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">b </span><span class="s2">= </span><span class="s1">x</span>
                <span class="s1">v </span><span class="s2">= </span><span class="s1">w</span>
                <span class="s1">w </span><span class="s2">= </span><span class="s1">x</span>
                <span class="s1">x </span><span class="s2">= </span><span class="s1">u</span>
                <span class="s1">fv </span><span class="s2">= </span><span class="s1">fw</span>
                <span class="s1">fw </span><span class="s2">= </span><span class="s1">fx</span>
                <span class="s1">fx </span><span class="s2">= </span><span class="s1">fu</span>

            <span class="s4">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">disp </span><span class="s2">&gt; </span><span class="s6">2</span><span class="s2">:</span>
                <span class="s1">print</span><span class="s2">(</span><span class="s3">f&quot;</span><span class="s4">{</span><span class="s1">funcalls</span><span class="s4">:</span><span class="s3">^12g</span><span class="s4">} {</span><span class="s1">x</span><span class="s4">:</span><span class="s3">^12.6g</span><span class="s4">} {</span><span class="s1">fx</span><span class="s4">:</span><span class="s3">^12.6g</span><span class="s4">}</span><span class="s3">&quot;</span><span class="s2">)</span>

            <span class="s1">iter </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s0">#################################</span>
        <span class="s0">#END CORE ALGORITHM</span>
        <span class="s0">#################################</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">xmin </span><span class="s2">= </span><span class="s1">x</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">fval </span><span class="s2">= </span><span class="s1">fx</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">iter </span><span class="s2">= </span><span class="s1">iter</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">funcalls </span><span class="s2">= </span><span class="s1">funcalls</span>

    <span class="s4">def </span><span class="s1">get_result</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">full_output</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fval</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">iter</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">funcalls</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">xmin</span>


<span class="s4">def </span><span class="s1">brent</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">brack</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s6">1.48e-8</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s6">500</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Given a function of one variable and a possible bracket, return 
    a local minimizer of the function isolated to a fractional precision 
    of tol. 
 
    Parameters 
    ---------- 
    func : callable f(x,*args) 
        Objective function. 
    args : tuple, optional 
        Additional arguments (if present). 
    brack : tuple, optional 
        Either a triple ``(xa, xb, xc)`` satisfying ``xa &lt; xb &lt; xc`` and 
        ``func(xb) &lt; func(xa) and  func(xb) &lt; func(xc)``, or a pair 
        ``(xa, xb)`` to be used as initial points for a downhill bracket search 
        (see `scipy.optimize.bracket`). 
        The minimizer ``x`` will not necessarily satisfy ``xa &lt;= x &lt;= xb``. 
    tol : float, optional 
        Relative error in solution `xopt` acceptable for convergence. 
    full_output : bool, optional 
        If True, return all output args (xmin, fval, iter, 
        funcalls). 
    maxiter : int, optional 
        Maximum number of iterations in solution. 
 
    Returns 
    ------- 
    xmin : ndarray 
        Optimum point. 
    fval : float 
        (Optional output) Optimum function value. 
    iter : int 
        (Optional output) Number of iterations. 
    funcalls : int 
        (Optional output) Number of objective function evaluations made. 
 
    See also 
    -------- 
    minimize_scalar: Interface to minimization algorithms for scalar 
        univariate functions. See the 'Brent' `method` in particular. 
 
    Notes 
    ----- 
    Uses inverse parabolic interpolation when possible to speed up 
    convergence of golden section method. 
 
    Does not ensure that the minimum lies in the range specified by 
    `brack`. See `scipy.optimize.fminbound`. 
 
    Examples 
    -------- 
    We illustrate the behaviour of the function when `brack` is of 
    size 2 and 3 respectively. In the case where `brack` is of the 
    form ``(xa, xb)``, we can see for the given values, the output does 
    not necessarily lie in the range ``(xa, xb)``. 
 
    &gt;&gt;&gt; def f(x): 
    ...     return (x-1)**2 
 
    &gt;&gt;&gt; from scipy import optimize 
 
    &gt;&gt;&gt; minimizer = optimize.brent(f, brack=(1, 2)) 
    &gt;&gt;&gt; minimizer 
    1 
    &gt;&gt;&gt; res = optimize.brent(f, brack=(-1, 0.5, 2), full_output=True) 
    &gt;&gt;&gt; xmin, fval, iter, funcalls = res 
    &gt;&gt;&gt; f(xmin), fval 
    (0.0, 0.0) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">options </span><span class="s2">= {</span><span class="s3">'xtol'</span><span class="s2">: </span><span class="s1">tol</span><span class="s2">,</span>
               <span class="s3">'maxiter'</span><span class="s2">: </span><span class="s1">maxiter</span><span class="s2">}</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">_minimize_scalar_brent</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">brack</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, **</span><span class="s1">options</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">full_output</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'fun'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'nit'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'nfev'</span><span class="s2">]</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">]</span>


<span class="s4">def </span><span class="s1">_minimize_scalar_brent</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">brack</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">xtol</span><span class="s2">=</span><span class="s6">1.48e-8</span><span class="s2">,</span>
                           <span class="s1">maxiter</span><span class="s2">=</span><span class="s6">500</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s6">0</span><span class="s2">,</span>
                           <span class="s2">**</span><span class="s1">unknown_options</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Options 
    ------- 
    maxiter : int 
        Maximum number of iterations to perform. 
    xtol : float 
        Relative error in solution `xopt` acceptable for convergence. 
    disp: int, optional 
        If non-zero, print messages. 
            0 : no message printing. 
            1 : non-convergence notification messages only. 
            2 : print a message on convergence too. 
            3 : print iteration results. 
    Notes 
    ----- 
    Uses inverse parabolic interpolation when possible to speed up 
    convergence of golden section method. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_unknown_options</span><span class="s2">(</span><span class="s1">unknown_options</span><span class="s2">)</span>
    <span class="s1">tol </span><span class="s2">= </span><span class="s1">xtol</span>
    <span class="s4">if </span><span class="s1">tol </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'tolerance should be &gt;= 0, got %r' </span><span class="s2">% </span><span class="s1">tol</span><span class="s2">)</span>

    <span class="s1">brent </span><span class="s2">= </span><span class="s1">Brent</span><span class="s2">(</span><span class="s1">func</span><span class="s2">=</span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s1">tol</span><span class="s2">,</span>
                  <span class="s1">full_output</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s1">maxiter</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s1">disp</span><span class="s2">)</span>
    <span class="s1">brent</span><span class="s2">.</span><span class="s1">set_bracket</span><span class="s2">(</span><span class="s1">brack</span><span class="s2">)</span>
    <span class="s1">brent</span><span class="s2">.</span><span class="s1">optimize</span><span class="s2">()</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">fval</span><span class="s2">, </span><span class="s1">nit</span><span class="s2">, </span><span class="s1">nfev </span><span class="s2">= </span><span class="s1">brent</span><span class="s2">.</span><span class="s1">get_result</span><span class="s2">(</span><span class="s1">full_output</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>

    <span class="s1">success </span><span class="s2">= </span><span class="s1">nit </span><span class="s2">&lt; </span><span class="s1">maxiter </span><span class="s4">and not </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s4">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">fval</span><span class="s2">))</span>

    <span class="s4">if </span><span class="s1">success</span><span class="s2">:</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Optimization terminated successfully;</span><span class="s4">\n</span><span class="s3">&quot;</span>
                   <span class="s3">&quot;The returned value satisfies the termination criteria</span><span class="s4">\n</span><span class="s3">&quot;</span>
                   <span class="s3">f&quot;(using xtol = </span><span class="s4">{</span><span class="s1">xtol</span><span class="s4">} </span><span class="s3">)&quot;</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">nit </span><span class="s2">&gt;= </span><span class="s1">maxiter</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= </span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Maximum number of iterations exceeded&quot;</span>
        <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s4">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">fval</span><span class="s2">):</span>
            <span class="s1">message </span><span class="s2">= </span><span class="s3">f&quot;</span><span class="s4">{</span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'nan'</span><span class="s2">]</span><span class="s4">}</span><span class="s3">&quot;</span>

    <span class="s4">if </span><span class="s1">disp</span><span class="s2">:</span>
        <span class="s1">_print_success_message_or_warn</span><span class="s2">(</span><span class="s4">not </span><span class="s1">success</span><span class="s2">, </span><span class="s1">message</span><span class="s2">)</span>

    <span class="s4">return </span><span class="s1">OptimizeResult</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">=</span><span class="s1">fval</span><span class="s2">, </span><span class="s1">x</span><span class="s2">=</span><span class="s1">x</span><span class="s2">, </span><span class="s1">nit</span><span class="s2">=</span><span class="s1">nit</span><span class="s2">, </span><span class="s1">nfev</span><span class="s2">=</span><span class="s1">nfev</span><span class="s2">,</span>
                          <span class="s1">success</span><span class="s2">=</span><span class="s1">success</span><span class="s2">, </span><span class="s1">message</span><span class="s2">=</span><span class="s1">message</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">golden</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">brack</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s1">_epsilon</span><span class="s2">,</span>
           <span class="s1">full_output</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s6">5000</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Return the minimizer of a function of one variable using the golden section 
    method. 
 
    Given a function of one variable and a possible bracketing interval, 
    return a minimizer of the function isolated to a fractional precision of 
    tol. 
 
    Parameters 
    ---------- 
    func : callable func(x,*args) 
        Objective function to minimize. 
    args : tuple, optional 
        Additional arguments (if present), passed to func. 
    brack : tuple, optional 
        Either a triple ``(xa, xb, xc)`` where ``xa &lt; xb &lt; xc`` and 
        ``func(xb) &lt; func(xa) and  func(xb) &lt; func(xc)``, or a pair (xa, xb) 
        to be used as initial points for a downhill bracket search (see 
        `scipy.optimize.bracket`). 
        The minimizer ``x`` will not necessarily satisfy ``xa &lt;= x &lt;= xb``. 
    tol : float, optional 
        x tolerance stop criterion 
    full_output : bool, optional 
        If True, return optional outputs. 
    maxiter : int 
        Maximum number of iterations to perform. 
 
    Returns 
    ------- 
    xmin : ndarray 
        Optimum point. 
    fval : float 
        (Optional output) Optimum function value. 
    funcalls : int 
        (Optional output) Number of objective function evaluations made. 
 
    See also 
    -------- 
    minimize_scalar: Interface to minimization algorithms for scalar 
        univariate functions. See the 'Golden' `method` in particular. 
 
    Notes 
    ----- 
    Uses analog of bisection method to decrease the bracketed 
    interval. 
 
    Examples 
    -------- 
    We illustrate the behaviour of the function when `brack` is of 
    size 2 and 3, respectively. In the case where `brack` is of the 
    form (xa,xb), we can see for the given values, the output need 
    not necessarily lie in the range ``(xa, xb)``. 
 
    &gt;&gt;&gt; def f(x): 
    ...     return (x-1)**2 
 
    &gt;&gt;&gt; from scipy import optimize 
 
    &gt;&gt;&gt; minimizer = optimize.golden(f, brack=(1, 2)) 
    &gt;&gt;&gt; minimizer 
    1 
    &gt;&gt;&gt; res = optimize.golden(f, brack=(-1, 0.5, 2), full_output=True) 
    &gt;&gt;&gt; xmin, fval, funcalls = res 
    &gt;&gt;&gt; f(xmin), fval 
    (9.925165290385052e-18, 9.925165290385052e-18) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">options </span><span class="s2">= {</span><span class="s3">'xtol'</span><span class="s2">: </span><span class="s1">tol</span><span class="s2">, </span><span class="s3">'maxiter'</span><span class="s2">: </span><span class="s1">maxiter</span><span class="s2">}</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">_minimize_scalar_golden</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">brack</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, **</span><span class="s1">options</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">full_output</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'fun'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'nfev'</span><span class="s2">]</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">]</span>


<span class="s4">def </span><span class="s1">_minimize_scalar_golden</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">brack</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(),</span>
                            <span class="s1">xtol</span><span class="s2">=</span><span class="s1">_epsilon</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s6">5000</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s6">0</span><span class="s2">,</span>
                            <span class="s2">**</span><span class="s1">unknown_options</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Options 
    ------- 
    xtol : float 
        Relative error in solution `xopt` acceptable for convergence. 
    maxiter : int 
        Maximum number of iterations to perform. 
    disp: int, optional 
        If non-zero, print messages. 
            0 : no message printing. 
            1 : non-convergence notification messages only. 
            2 : print a message on convergence too. 
            3 : print iteration results. 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_unknown_options</span><span class="s2">(</span><span class="s1">unknown_options</span><span class="s2">)</span>
    <span class="s1">tol </span><span class="s2">= </span><span class="s1">xtol</span>
    <span class="s4">if </span><span class="s1">brack </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">xa</span><span class="s2">, </span><span class="s1">xb</span><span class="s2">, </span><span class="s1">xc</span><span class="s2">, </span><span class="s1">fa</span><span class="s2">, </span><span class="s1">fb</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">, </span><span class="s1">funcalls </span><span class="s2">= </span><span class="s1">bracket</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s4">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">brack</span><span class="s2">) == </span><span class="s6">2</span><span class="s2">:</span>
        <span class="s1">xa</span><span class="s2">, </span><span class="s1">xb</span><span class="s2">, </span><span class="s1">xc</span><span class="s2">, </span><span class="s1">fa</span><span class="s2">, </span><span class="s1">fb</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">, </span><span class="s1">funcalls </span><span class="s2">= </span><span class="s1">bracket</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">xa</span><span class="s2">=</span><span class="s1">brack</span><span class="s2">[</span><span class="s6">0</span><span class="s2">],</span>
                                                   <span class="s1">xb</span><span class="s2">=</span><span class="s1">brack</span><span class="s2">[</span><span class="s6">1</span><span class="s2">], </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s4">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">brack</span><span class="s2">) == </span><span class="s6">3</span><span class="s2">:</span>
        <span class="s1">xa</span><span class="s2">, </span><span class="s1">xb</span><span class="s2">, </span><span class="s1">xc </span><span class="s2">= </span><span class="s1">brack</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s1">xa </span><span class="s2">&gt; </span><span class="s1">xc</span><span class="s2">):  </span><span class="s0"># swap so xa &lt; xc can be assumed</span>
            <span class="s1">xc</span><span class="s2">, </span><span class="s1">xa </span><span class="s2">= </span><span class="s1">xa</span><span class="s2">, </span><span class="s1">xc</span>
        <span class="s4">if not </span><span class="s2">((</span><span class="s1">xa </span><span class="s2">&lt; </span><span class="s1">xb</span><span class="s2">) </span><span class="s4">and </span><span class="s2">(</span><span class="s1">xb </span><span class="s2">&lt; </span><span class="s1">xc</span><span class="s2">)):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s3">&quot;Bracketing values (xa, xb, xc) do not&quot;</span>
                <span class="s3">&quot; fulfill this requirement: (xa &lt; xb) and (xb &lt; xc)&quot;</span>
            <span class="s2">)</span>
        <span class="s1">fa </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">xa</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
        <span class="s1">fb </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">xb</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
        <span class="s1">fc </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">xc</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
        <span class="s4">if not </span><span class="s2">((</span><span class="s1">fb </span><span class="s2">&lt; </span><span class="s1">fa</span><span class="s2">) </span><span class="s4">and </span><span class="s2">(</span><span class="s1">fb </span><span class="s2">&lt; </span><span class="s1">fc</span><span class="s2">)):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s3">&quot;Bracketing values (xa, xb, xc) do not fulfill&quot;</span>
                <span class="s3">&quot; this requirement: (f(xb) &lt; f(xa)) and (f(xb) &lt; f(xc))&quot;</span>
            <span class="s2">)</span>
        <span class="s1">funcalls </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Bracketing interval must be length 2 or 3 sequence.&quot;</span><span class="s2">)</span>

    <span class="s1">_gR </span><span class="s2">= </span><span class="s6">0.61803399  </span><span class="s0"># golden ratio conjugate: 2.0/(1.0+sqrt(5.0))</span>
    <span class="s1">_gC </span><span class="s2">= </span><span class="s6">1.0 </span><span class="s2">- </span><span class="s1">_gR</span>
    <span class="s1">x3 </span><span class="s2">= </span><span class="s1">xc</span>
    <span class="s1">x0 </span><span class="s2">= </span><span class="s1">xa</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">xc </span><span class="s2">- </span><span class="s1">xb</span><span class="s2">) &gt; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">xb </span><span class="s2">- </span><span class="s1">xa</span><span class="s2">)):</span>
        <span class="s1">x1 </span><span class="s2">= </span><span class="s1">xb</span>
        <span class="s1">x2 </span><span class="s2">= </span><span class="s1">xb </span><span class="s2">+ </span><span class="s1">_gC </span><span class="s2">* (</span><span class="s1">xc </span><span class="s2">- </span><span class="s1">xb</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">x2 </span><span class="s2">= </span><span class="s1">xb</span>
        <span class="s1">x1 </span><span class="s2">= </span><span class="s1">xb </span><span class="s2">- </span><span class="s1">_gC </span><span class="s2">* (</span><span class="s1">xb </span><span class="s2">- </span><span class="s1">xa</span><span class="s2">)</span>
    <span class="s1">f1 </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">x1</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
    <span class="s1">f2 </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">x2</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
    <span class="s1">funcalls </span><span class="s2">+= </span><span class="s6">2</span>
    <span class="s1">nit </span><span class="s2">= </span><span class="s6">0</span>

    <span class="s4">if </span><span class="s1">disp </span><span class="s2">&gt; </span><span class="s6">2</span><span class="s2">:</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot; &quot;</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">f&quot;</span><span class="s4">{</span><span class="s3">'Func-count'</span><span class="s4">:</span><span class="s3">^12</span><span class="s4">} {</span><span class="s3">'x'</span><span class="s4">:</span><span class="s3">^12</span><span class="s4">} {</span><span class="s3">'f(x)'</span><span class="s4">: </span><span class="s3">^12</span><span class="s4">}</span><span class="s3">&quot;</span><span class="s2">)</span>

    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">x3 </span><span class="s2">- </span><span class="s1">x0</span><span class="s2">) &lt;= </span><span class="s1">tol </span><span class="s2">* (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">) + </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">)):</span>
            <span class="s4">break</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s1">f2 </span><span class="s2">&lt; </span><span class="s1">f1</span><span class="s2">):</span>
            <span class="s1">x0 </span><span class="s2">= </span><span class="s1">x1</span>
            <span class="s1">x1 </span><span class="s2">= </span><span class="s1">x2</span>
            <span class="s1">x2 </span><span class="s2">= </span><span class="s1">_gR </span><span class="s2">* </span><span class="s1">x1 </span><span class="s2">+ </span><span class="s1">_gC </span><span class="s2">* </span><span class="s1">x3</span>
            <span class="s1">f1 </span><span class="s2">= </span><span class="s1">f2</span>
            <span class="s1">f2 </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">x2</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">x3 </span><span class="s2">= </span><span class="s1">x2</span>
            <span class="s1">x2 </span><span class="s2">= </span><span class="s1">x1</span>
            <span class="s1">x1 </span><span class="s2">= </span><span class="s1">_gR </span><span class="s2">* </span><span class="s1">x2 </span><span class="s2">+ </span><span class="s1">_gC </span><span class="s2">* </span><span class="s1">x0</span>
            <span class="s1">f2 </span><span class="s2">= </span><span class="s1">f1</span>
            <span class="s1">f1 </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">x1</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
        <span class="s1">funcalls </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s4">if </span><span class="s1">disp </span><span class="s2">&gt; </span><span class="s6">2</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s1">f1 </span><span class="s2">&lt; </span><span class="s1">f2</span><span class="s2">):</span>
                <span class="s1">xmin</span><span class="s2">, </span><span class="s1">fval </span><span class="s2">= </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">f1</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">xmin</span><span class="s2">, </span><span class="s1">fval </span><span class="s2">= </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">f2</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">f&quot;</span><span class="s4">{</span><span class="s1">funcalls</span><span class="s4">:</span><span class="s3">^12g</span><span class="s4">} {</span><span class="s1">xmin</span><span class="s4">:</span><span class="s3">^12.6g</span><span class="s4">} {</span><span class="s1">fval</span><span class="s4">:</span><span class="s3">^12.6g</span><span class="s4">}</span><span class="s3">&quot;</span><span class="s2">)</span>

        <span class="s1">nit </span><span class="s2">+= </span><span class="s6">1</span>
    <span class="s0"># end of iteration loop</span>

    <span class="s4">if </span><span class="s2">(</span><span class="s1">f1 </span><span class="s2">&lt; </span><span class="s1">f2</span><span class="s2">):</span>
        <span class="s1">xmin </span><span class="s2">= </span><span class="s1">x1</span>
        <span class="s1">fval </span><span class="s2">= </span><span class="s1">f1</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">xmin </span><span class="s2">= </span><span class="s1">x2</span>
        <span class="s1">fval </span><span class="s2">= </span><span class="s1">f2</span>

    <span class="s1">success </span><span class="s2">= </span><span class="s1">nit </span><span class="s2">&lt; </span><span class="s1">maxiter </span><span class="s4">and not </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">fval</span><span class="s2">) </span><span class="s4">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">xmin</span><span class="s2">))</span>

    <span class="s4">if </span><span class="s1">success</span><span class="s2">:</span>
        <span class="s1">message </span><span class="s2">= (</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Optimization terminated successfully;</span><span class="s4">\n</span><span class="s3">&quot;</span>
                   <span class="s3">&quot;The returned value satisfies the termination criteria</span><span class="s4">\n</span><span class="s3">&quot;</span>
                   <span class="s3">f&quot;(using xtol = </span><span class="s4">{</span><span class="s1">xtol</span><span class="s4">} </span><span class="s3">)&quot;</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">nit </span><span class="s2">&gt;= </span><span class="s1">maxiter</span><span class="s2">:</span>
            <span class="s1">message </span><span class="s2">= </span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Maximum number of iterations exceeded&quot;</span>
        <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">xmin</span><span class="s2">) </span><span class="s4">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">fval</span><span class="s2">):</span>
            <span class="s1">message </span><span class="s2">= </span><span class="s3">f&quot;</span><span class="s4">{</span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'nan'</span><span class="s2">]</span><span class="s4">}</span><span class="s3">&quot;</span>

    <span class="s4">if </span><span class="s1">disp</span><span class="s2">:</span>
        <span class="s1">_print_success_message_or_warn</span><span class="s2">(</span><span class="s4">not </span><span class="s1">success</span><span class="s2">, </span><span class="s1">message</span><span class="s2">)</span>

    <span class="s4">return </span><span class="s1">OptimizeResult</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">=</span><span class="s1">fval</span><span class="s2">, </span><span class="s1">nfev</span><span class="s2">=</span><span class="s1">funcalls</span><span class="s2">, </span><span class="s1">x</span><span class="s2">=</span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">nit</span><span class="s2">=</span><span class="s1">nit</span><span class="s2">,</span>
                          <span class="s1">success</span><span class="s2">=</span><span class="s1">success</span><span class="s2">, </span><span class="s1">message</span><span class="s2">=</span><span class="s1">message</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">bracket</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">xa</span><span class="s2">=</span><span class="s6">0.0</span><span class="s2">, </span><span class="s1">xb</span><span class="s2">=</span><span class="s6">1.0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">grow_limit</span><span class="s2">=</span><span class="s6">110.0</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s6">1000</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Bracket the minimum of a function. 
 
    Given a function and distinct initial points, search in the 
    downhill direction (as defined by the initial points) and return 
    three points that bracket the minimum of the function. 
 
    Parameters 
    ---------- 
    func : callable f(x,*args) 
        Objective function to minimize. 
    xa, xb : float, optional 
        Initial points. Defaults `xa` to 0.0, and `xb` to 1.0. 
        A local minimum need not be contained within this interval. 
    args : tuple, optional 
        Additional arguments (if present), passed to `func`. 
    grow_limit : float, optional 
        Maximum grow limit.  Defaults to 110.0 
    maxiter : int, optional 
        Maximum number of iterations to perform. Defaults to 1000. 
 
    Returns 
    ------- 
    xa, xb, xc : float 
        Final points of the bracket. 
    fa, fb, fc : float 
        Objective function values at the bracket points. 
    funcalls : int 
        Number of function evaluations made. 
 
    Raises 
    ------ 
    BracketError 
        If no valid bracket is found before the algorithm terminates. 
        See notes for conditions of a valid bracket. 
 
    Notes 
    ----- 
    The algorithm attempts to find three strictly ordered points (i.e. 
    :math:`x_a &lt; x_b &lt; x_c` or :math:`x_c &lt; x_b &lt; x_a`) satisfying 
    :math:`f(x_b) ≤ f(x_a)` and :math:`f(x_b) ≤ f(x_c)`, where one of the 
    inequalities must be satistfied strictly and all :math:`x_i` must be 
    finite. 
 
    Examples 
    -------- 
    This function can find a downward convex region of a function: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.optimize import bracket 
    &gt;&gt;&gt; def f(x): 
    ...     return 10*x**2 + 3*x + 5 
    &gt;&gt;&gt; x = np.linspace(-2, 2) 
    &gt;&gt;&gt; y = f(x) 
    &gt;&gt;&gt; init_xa, init_xb = 0.1, 1 
    &gt;&gt;&gt; xa, xb, xc, fa, fb, fc, funcalls = bracket(f, xa=init_xa, xb=init_xb) 
    &gt;&gt;&gt; plt.axvline(x=init_xa, color=&quot;k&quot;, linestyle=&quot;--&quot;) 
    &gt;&gt;&gt; plt.axvline(x=init_xb, color=&quot;k&quot;, linestyle=&quot;--&quot;) 
    &gt;&gt;&gt; plt.plot(x, y, &quot;-k&quot;) 
    &gt;&gt;&gt; plt.plot(xa, fa, &quot;bx&quot;) 
    &gt;&gt;&gt; plt.plot(xb, fb, &quot;rx&quot;) 
    &gt;&gt;&gt; plt.plot(xc, fc, &quot;bx&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    Note that both initial points were to the right of the minimum, and the 
    third point was found in the &quot;downhill&quot; direction: the direction 
    in which the function appeared to be decreasing (to the left). 
    The final points are strictly ordered, and the function value 
    at the middle point is less than the function values at the endpoints; 
    it follows that a minimum must lie within the bracket. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_gold </span><span class="s2">= </span><span class="s6">1.618034  </span><span class="s0"># golden ratio: (1.0+sqrt(5.0))/2.0</span>
    <span class="s1">_verysmall_num </span><span class="s2">= </span><span class="s6">1e-21</span>
    <span class="s0"># convert to numpy floats if not already</span>
    <span class="s1">xa</span><span class="s2">, </span><span class="s1">xb </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">([</span><span class="s1">xa</span><span class="s2">, </span><span class="s1">xb</span><span class="s2">])</span>
    <span class="s1">fa </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*(</span><span class="s1">xa</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">)</span>
    <span class="s1">fb </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*(</span><span class="s1">xb</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s1">fa </span><span class="s2">&lt; </span><span class="s1">fb</span><span class="s2">):                      </span><span class="s0"># Switch so fa &gt; fb</span>
        <span class="s1">xa</span><span class="s2">, </span><span class="s1">xb </span><span class="s2">= </span><span class="s1">xb</span><span class="s2">, </span><span class="s1">xa</span>
        <span class="s1">fa</span><span class="s2">, </span><span class="s1">fb </span><span class="s2">= </span><span class="s1">fb</span><span class="s2">, </span><span class="s1">fa</span>
    <span class="s1">xc </span><span class="s2">= </span><span class="s1">xb </span><span class="s2">+ </span><span class="s1">_gold </span><span class="s2">* (</span><span class="s1">xb </span><span class="s2">- </span><span class="s1">xa</span><span class="s2">)</span>
    <span class="s1">fc </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">xc</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
    <span class="s1">funcalls </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s1">iter </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s4">while </span><span class="s2">(</span><span class="s1">fc </span><span class="s2">&lt; </span><span class="s1">fb</span><span class="s2">):</span>
        <span class="s1">tmp1 </span><span class="s2">= (</span><span class="s1">xb </span><span class="s2">- </span><span class="s1">xa</span><span class="s2">) * (</span><span class="s1">fb </span><span class="s2">- </span><span class="s1">fc</span><span class="s2">)</span>
        <span class="s1">tmp2 </span><span class="s2">= (</span><span class="s1">xb </span><span class="s2">- </span><span class="s1">xc</span><span class="s2">) * (</span><span class="s1">fb </span><span class="s2">- </span><span class="s1">fa</span><span class="s2">)</span>
        <span class="s1">val </span><span class="s2">= </span><span class="s1">tmp2 </span><span class="s2">- </span><span class="s1">tmp1</span>
        <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">val</span><span class="s2">) &lt; </span><span class="s1">_verysmall_num</span><span class="s2">:</span>
            <span class="s1">denom </span><span class="s2">= </span><span class="s6">2.0 </span><span class="s2">* </span><span class="s1">_verysmall_num</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">denom </span><span class="s2">= </span><span class="s6">2.0 </span><span class="s2">* </span><span class="s1">val</span>
        <span class="s1">w </span><span class="s2">= </span><span class="s1">xb </span><span class="s2">- ((</span><span class="s1">xb </span><span class="s2">- </span><span class="s1">xc</span><span class="s2">) * </span><span class="s1">tmp2 </span><span class="s2">- (</span><span class="s1">xb </span><span class="s2">- </span><span class="s1">xa</span><span class="s2">) * </span><span class="s1">tmp1</span><span class="s2">) / </span><span class="s1">denom</span>
        <span class="s1">wlim </span><span class="s2">= </span><span class="s1">xb </span><span class="s2">+ </span><span class="s1">grow_limit </span><span class="s2">* (</span><span class="s1">xc </span><span class="s2">- </span><span class="s1">xb</span><span class="s2">)</span>
        <span class="s1">msg </span><span class="s2">= (</span><span class="s3">&quot;No valid bracket was found before the iteration limit was &quot;</span>
               <span class="s3">&quot;reached. Consider trying different initial points or &quot;</span>
               <span class="s3">&quot;increasing `maxiter`.&quot;</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">iter </span><span class="s2">&gt; </span><span class="s1">maxiter</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
        <span class="s1">iter </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s1">w </span><span class="s2">- </span><span class="s1">xc</span><span class="s2">) * (</span><span class="s1">xb </span><span class="s2">- </span><span class="s1">w</span><span class="s2">) &gt; </span><span class="s6">0.0</span><span class="s2">:</span>
            <span class="s1">fw </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">w</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
            <span class="s1">funcalls </span><span class="s2">+= </span><span class="s6">1</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s1">fw </span><span class="s2">&lt; </span><span class="s1">fc</span><span class="s2">):</span>
                <span class="s1">xa </span><span class="s2">= </span><span class="s1">xb</span>
                <span class="s1">xb </span><span class="s2">= </span><span class="s1">w</span>
                <span class="s1">fa </span><span class="s2">= </span><span class="s1">fb</span>
                <span class="s1">fb </span><span class="s2">= </span><span class="s1">fw</span>
                <span class="s4">break</span>
            <span class="s4">elif </span><span class="s2">(</span><span class="s1">fw </span><span class="s2">&gt; </span><span class="s1">fb</span><span class="s2">):</span>
                <span class="s1">xc </span><span class="s2">= </span><span class="s1">w</span>
                <span class="s1">fc </span><span class="s2">= </span><span class="s1">fw</span>
                <span class="s4">break</span>
            <span class="s1">w </span><span class="s2">= </span><span class="s1">xc </span><span class="s2">+ </span><span class="s1">_gold </span><span class="s2">* (</span><span class="s1">xc </span><span class="s2">- </span><span class="s1">xb</span><span class="s2">)</span>
            <span class="s1">fw </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">w</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
            <span class="s1">funcalls </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s4">elif </span><span class="s2">(</span><span class="s1">w </span><span class="s2">- </span><span class="s1">wlim</span><span class="s2">)*(</span><span class="s1">wlim </span><span class="s2">- </span><span class="s1">xc</span><span class="s2">) &gt;= </span><span class="s6">0.0</span><span class="s2">:</span>
            <span class="s1">w </span><span class="s2">= </span><span class="s1">wlim</span>
            <span class="s1">fw </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">w</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
            <span class="s1">funcalls </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s4">elif </span><span class="s2">(</span><span class="s1">w </span><span class="s2">- </span><span class="s1">wlim</span><span class="s2">)*(</span><span class="s1">xc </span><span class="s2">- </span><span class="s1">w</span><span class="s2">) &gt; </span><span class="s6">0.0</span><span class="s2">:</span>
            <span class="s1">fw </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">w</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
            <span class="s1">funcalls </span><span class="s2">+= </span><span class="s6">1</span>
            <span class="s4">if </span><span class="s2">(</span><span class="s1">fw </span><span class="s2">&lt; </span><span class="s1">fc</span><span class="s2">):</span>
                <span class="s1">xb </span><span class="s2">= </span><span class="s1">xc</span>
                <span class="s1">xc </span><span class="s2">= </span><span class="s1">w</span>
                <span class="s1">w </span><span class="s2">= </span><span class="s1">xc </span><span class="s2">+ </span><span class="s1">_gold </span><span class="s2">* (</span><span class="s1">xc </span><span class="s2">- </span><span class="s1">xb</span><span class="s2">)</span>
                <span class="s1">fb </span><span class="s2">= </span><span class="s1">fc</span>
                <span class="s1">fc </span><span class="s2">= </span><span class="s1">fw</span>
                <span class="s1">fw </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">w</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
                <span class="s1">funcalls </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">w </span><span class="s2">= </span><span class="s1">xc </span><span class="s2">+ </span><span class="s1">_gold </span><span class="s2">* (</span><span class="s1">xc </span><span class="s2">- </span><span class="s1">xb</span><span class="s2">)</span>
            <span class="s1">fw </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(*((</span><span class="s1">w</span><span class="s2">,) + </span><span class="s1">args</span><span class="s2">))</span>
            <span class="s1">funcalls </span><span class="s2">+= </span><span class="s6">1</span>
        <span class="s1">xa </span><span class="s2">= </span><span class="s1">xb</span>
        <span class="s1">xb </span><span class="s2">= </span><span class="s1">xc</span>
        <span class="s1">xc </span><span class="s2">= </span><span class="s1">w</span>
        <span class="s1">fa </span><span class="s2">= </span><span class="s1">fb</span>
        <span class="s1">fb </span><span class="s2">= </span><span class="s1">fc</span>
        <span class="s1">fc </span><span class="s2">= </span><span class="s1">fw</span>

    <span class="s0"># three conditions for a valid bracket</span>
    <span class="s1">cond1 </span><span class="s2">= (</span><span class="s1">fb </span><span class="s2">&lt; </span><span class="s1">fc </span><span class="s4">and </span><span class="s1">fb </span><span class="s2">&lt;= </span><span class="s1">fa</span><span class="s2">) </span><span class="s4">or </span><span class="s2">(</span><span class="s1">fb </span><span class="s2">&lt; </span><span class="s1">fa </span><span class="s4">and </span><span class="s1">fb </span><span class="s2">&lt;= </span><span class="s1">fc</span><span class="s2">)</span>
    <span class="s1">cond2 </span><span class="s2">= (</span><span class="s1">xa </span><span class="s2">&lt; </span><span class="s1">xb </span><span class="s2">&lt; </span><span class="s1">xc </span><span class="s4">or </span><span class="s1">xc </span><span class="s2">&lt; </span><span class="s1">xb </span><span class="s2">&lt; </span><span class="s1">xa</span><span class="s2">)</span>
    <span class="s1">cond3 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">xa</span><span class="s2">) </span><span class="s4">and </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">xb</span><span class="s2">) </span><span class="s4">and </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">xc</span><span class="s2">)</span>
    <span class="s1">msg </span><span class="s2">= (</span><span class="s3">&quot;The algorithm terminated without finding a valid bracket. &quot;</span>
           <span class="s3">&quot;Consider trying different initial points.&quot;</span><span class="s2">)</span>
    <span class="s4">if not </span><span class="s2">(</span><span class="s1">cond1 </span><span class="s4">and </span><span class="s1">cond2 </span><span class="s4">and </span><span class="s1">cond3</span><span class="s2">):</span>
        <span class="s1">e </span><span class="s2">= </span><span class="s1">BracketError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
        <span class="s1">e</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= (</span><span class="s1">xa</span><span class="s2">, </span><span class="s1">xb</span><span class="s2">, </span><span class="s1">xc</span><span class="s2">, </span><span class="s1">fa</span><span class="s2">, </span><span class="s1">fb</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">, </span><span class="s1">funcalls</span><span class="s2">)</span>
        <span class="s4">raise </span><span class="s1">e</span>

    <span class="s4">return </span><span class="s1">xa</span><span class="s2">, </span><span class="s1">xb</span><span class="s2">, </span><span class="s1">xc</span><span class="s2">, </span><span class="s1">fa</span><span class="s2">, </span><span class="s1">fb</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">, </span><span class="s1">funcalls</span>


<span class="s4">class </span><span class="s1">BracketError</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">):</span>
    <span class="s4">pass</span>


<span class="s4">def </span><span class="s1">_recover_from_bracket_error</span><span class="s2">(</span><span class="s1">solver</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">bracket</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, **</span><span class="s1">options</span><span class="s2">):</span>
    <span class="s0"># `bracket` was originally written without checking whether the resulting</span>
    <span class="s0"># bracket is valid. `brent` and `golden` built on top of it without</span>
    <span class="s0"># checking the returned bracket for validity, and their output can be</span>
    <span class="s0"># incorrect without warning/error if the original bracket is invalid.</span>
    <span class="s0"># gh-14858 noticed the problem, and the following is the desired</span>
    <span class="s0"># behavior:</span>
    <span class="s0"># - `scipy.optimize.bracket`, `scipy.optimize.brent`, and</span>
    <span class="s0">#   `scipy.optimize.golden` should raise an error if the bracket is</span>
    <span class="s0">#   invalid, as opposed to silently returning garbage</span>
    <span class="s0"># - `scipy.optimize.minimize_scalar` should return with `success=False`</span>
    <span class="s0">#   and other information</span>
    <span class="s0"># The changes that would be required to achieve this the traditional</span>
    <span class="s0"># way (`return`ing all the required information from bracket all the way</span>
    <span class="s0"># up to `minimizer_scalar`) are extensive and invasive. (See a6aa40d.)</span>
    <span class="s0"># We can achieve the same thing by raising the error in `bracket`, but</span>
    <span class="s0"># storing the information needed by `minimize_scalar` in the error object,</span>
    <span class="s0"># and intercepting it here.</span>
    <span class="s4">try</span><span class="s2">:</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">solver</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">, </span><span class="s1">bracket</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, **</span><span class="s1">options</span><span class="s2">)</span>
    <span class="s4">except </span><span class="s1">BracketError </span><span class="s4">as </span><span class="s1">e</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">str</span><span class="s2">(</span><span class="s1">e</span><span class="s2">)</span>
        <span class="s1">xa</span><span class="s2">, </span><span class="s1">xb</span><span class="s2">, </span><span class="s1">xc</span><span class="s2">, </span><span class="s1">fa</span><span class="s2">, </span><span class="s1">fb</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">, </span><span class="s1">funcalls </span><span class="s2">= </span><span class="s1">e</span><span class="s2">.</span><span class="s1">data</span>
        <span class="s1">xs</span><span class="s2">, </span><span class="s1">fs </span><span class="s2">= [</span><span class="s1">xa</span><span class="s2">, </span><span class="s1">xb</span><span class="s2">, </span><span class="s1">xc</span><span class="s2">], [</span><span class="s1">fa</span><span class="s2">, </span><span class="s1">fb</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">]</span>
        <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">([</span><span class="s1">xs</span><span class="s2">, </span><span class="s1">fs</span><span class="s2">])):</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">fun </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">imin </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argmin</span><span class="s2">(</span><span class="s1">fs</span><span class="s2">)</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">fun </span><span class="s2">= </span><span class="s1">xs</span><span class="s2">[</span><span class="s1">imin</span><span class="s2">], </span><span class="s1">fs</span><span class="s2">[</span><span class="s1">imin</span><span class="s2">]</span>
        <span class="s4">return </span><span class="s1">OptimizeResult</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">=</span><span class="s1">fun</span><span class="s2">, </span><span class="s1">nfev</span><span class="s2">=</span><span class="s1">funcalls</span><span class="s2">, </span><span class="s1">x</span><span class="s2">=</span><span class="s1">x</span><span class="s2">,</span>
                              <span class="s1">nit</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">success</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">message</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">res</span>


<span class="s4">def </span><span class="s1">_line_for_search</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">lower_bound</span><span class="s2">, </span><span class="s1">upper_bound</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Given a parameter vector ``x0`` with length ``n`` and a direction 
    vector ``alpha`` with length ``n``, and lower and upper bounds on 
    each of the ``n`` parameters, what are the bounds on a scalar 
    ``l`` such that ``lower_bound &lt;= x0 + alpha * l &lt;= upper_bound``. 
 
 
    Parameters 
    ---------- 
    x0 : np.array. 
        The vector representing the current location. 
        Note ``np.shape(x0) == (n,)``. 
    alpha : np.array. 
        The vector representing the direction. 
        Note ``np.shape(alpha) == (n,)``. 
    lower_bound : np.array. 
        The lower bounds for each parameter in ``x0``. If the ``i``th 
        parameter in ``x0`` is unbounded below, then ``lower_bound[i]`` 
        should be ``-np.inf``. 
        Note ``np.shape(lower_bound) == (n,)``. 
    upper_bound : np.array. 
        The upper bounds for each parameter in ``x0``. If the ``i``th 
        parameter in ``x0`` is unbounded above, then ``upper_bound[i]`` 
        should be ``np.inf``. 
        Note ``np.shape(upper_bound) == (n,)``. 
 
    Returns 
    ------- 
    res : tuple ``(lmin, lmax)`` 
        The bounds for ``l`` such that 
            ``lower_bound[i] &lt;= x0[i] + alpha[i] * l &lt;= upper_bound[i]`` 
        for all ``i``. 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># get nonzero indices of alpha so we don't get any zero division errors.</span>
    <span class="s0"># alpha will not be all zero, since it is called from _linesearch_powell</span>
    <span class="s0"># where we have a check for this.</span>
    <span class="s1">nonzero</span><span class="s2">, = </span><span class="s1">alpha</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">()</span>
    <span class="s1">lower_bound</span><span class="s2">, </span><span class="s1">upper_bound </span><span class="s2">= </span><span class="s1">lower_bound</span><span class="s2">[</span><span class="s1">nonzero</span><span class="s2">], </span><span class="s1">upper_bound</span><span class="s2">[</span><span class="s1">nonzero</span><span class="s2">]</span>
    <span class="s1">x0</span><span class="s2">, </span><span class="s1">alpha </span><span class="s2">= </span><span class="s1">x0</span><span class="s2">[</span><span class="s1">nonzero</span><span class="s2">], </span><span class="s1">alpha</span><span class="s2">[</span><span class="s1">nonzero</span><span class="s2">]</span>
    <span class="s1">low </span><span class="s2">= (</span><span class="s1">lower_bound </span><span class="s2">- </span><span class="s1">x0</span><span class="s2">) / </span><span class="s1">alpha</span>
    <span class="s1">high </span><span class="s2">= (</span><span class="s1">upper_bound </span><span class="s2">- </span><span class="s1">x0</span><span class="s2">) / </span><span class="s1">alpha</span>

    <span class="s0"># positive and negative indices</span>
    <span class="s1">pos </span><span class="s2">= </span><span class="s1">alpha </span><span class="s2">&gt; </span><span class="s6">0</span>

    <span class="s1">lmin_pos </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">pos</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>
    <span class="s1">lmin_neg </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">pos</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s1">high</span><span class="s2">)</span>
    <span class="s1">lmax_pos </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">pos</span><span class="s2">, </span><span class="s1">high</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>
    <span class="s1">lmax_neg </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">pos</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s1">low</span><span class="s2">)</span>

    <span class="s1">lmin </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">lmin_pos </span><span class="s2">+ </span><span class="s1">lmin_neg</span><span class="s2">)</span>
    <span class="s1">lmax </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">lmax_pos </span><span class="s2">+ </span><span class="s1">lmax_neg</span><span class="s2">)</span>

    <span class="s0"># if x0 is outside the bounds, then it is possible that there is</span>
    <span class="s0"># no way to get back in the bounds for the parameters being updated</span>
    <span class="s0"># with the current direction alpha.</span>
    <span class="s0"># when this happens, lmax &lt; lmin.</span>
    <span class="s0"># If this is the case, then we can just return (0, 0)</span>
    <span class="s4">return </span><span class="s2">(</span><span class="s1">lmin</span><span class="s2">, </span><span class="s1">lmax</span><span class="s2">) </span><span class="s4">if </span><span class="s1">lmax </span><span class="s2">&gt;= </span><span class="s1">lmin </span><span class="s4">else </span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">_linesearch_powell</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">xi</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s6">1e-3</span><span class="s2">,</span>
                       <span class="s1">lower_bound</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">upper_bound</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">fval</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Line-search algorithm using fminbound. 
 
    Find the minimum of the function ``func(x0 + alpha*direc)``. 
 
    lower_bound : np.array. 
        The lower bounds for each parameter in ``x0``. If the ``i``th 
        parameter in ``x0`` is unbounded below, then ``lower_bound[i]`` 
        should be ``-np.inf``. 
        Note ``np.shape(lower_bound) == (n,)``. 
    upper_bound : np.array. 
        The upper bounds for each parameter in ``x0``. If the ``i``th 
        parameter in ``x0`` is unbounded above, then ``upper_bound[i]`` 
        should be ``np.inf``. 
        Note ``np.shape(upper_bound) == (n,)``. 
    fval : number. 
        ``fval`` is equal to ``func(p)``, the idea is just to avoid 
        recomputing it so we can limit the ``fevals``. 
 
    &quot;&quot;&quot;</span>
    <span class="s4">def </span><span class="s1">myfunc</span><span class="s2">(</span><span class="s1">alpha</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">func</span><span class="s2">(</span><span class="s1">p </span><span class="s2">+ </span><span class="s1">alpha</span><span class="s2">*</span><span class="s1">xi</span><span class="s2">)</span>

    <span class="s0"># if xi is zero, then don't optimize</span>
    <span class="s4">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">xi</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s2">((</span><span class="s1">fval</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">xi</span><span class="s2">) </span><span class="s4">if </span><span class="s1">fval </span><span class="s4">is not None else </span><span class="s2">(</span><span class="s1">func</span><span class="s2">(</span><span class="s1">p</span><span class="s2">), </span><span class="s1">p</span><span class="s2">, </span><span class="s1">xi</span><span class="s2">))</span>
    <span class="s4">elif </span><span class="s1">lower_bound </span><span class="s4">is None and </span><span class="s1">upper_bound </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s0"># non-bounded minimization</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">_recover_from_bracket_error</span><span class="s2">(</span><span class="s1">_minimize_scalar_brent</span><span class="s2">,</span>
                                          <span class="s1">myfunc</span><span class="s2">, </span><span class="s4">None</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">(), </span><span class="s1">xtol</span><span class="s2">=</span><span class="s1">tol</span><span class="s2">)</span>
        <span class="s1">alpha_min</span><span class="s2">, </span><span class="s1">fret </span><span class="s2">= </span><span class="s1">res</span><span class="s2">.</span><span class="s1">x</span><span class="s2">, </span><span class="s1">res</span><span class="s2">.</span><span class="s1">fun</span>
        <span class="s1">xi </span><span class="s2">= </span><span class="s1">alpha_min </span><span class="s2">* </span><span class="s1">xi</span>
        <span class="s4">return </span><span class="s1">squeeze</span><span class="s2">(</span><span class="s1">fret</span><span class="s2">), </span><span class="s1">p </span><span class="s2">+ </span><span class="s1">xi</span><span class="s2">, </span><span class="s1">xi</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">bound </span><span class="s2">= </span><span class="s1">_line_for_search</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">xi</span><span class="s2">, </span><span class="s1">lower_bound</span><span class="s2">, </span><span class="s1">upper_bound</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isneginf</span><span class="s2">(</span><span class="s1">bound</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]) </span><span class="s4">and </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isposinf</span><span class="s2">(</span><span class="s1">bound</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]):</span>
            <span class="s0"># equivalent to unbounded</span>
            <span class="s4">return </span><span class="s1">_linesearch_powell</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">xi</span><span class="s2">, </span><span class="s1">fval</span><span class="s2">=</span><span class="s1">fval</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s1">tol</span><span class="s2">)</span>
        <span class="s4">elif not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isneginf</span><span class="s2">(</span><span class="s1">bound</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]) </span><span class="s4">and not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isposinf</span><span class="s2">(</span><span class="s1">bound</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]):</span>
            <span class="s0"># we can use a bounded scalar minimization</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">_minimize_scalar_bounded</span><span class="s2">(</span><span class="s1">myfunc</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">, </span><span class="s1">xatol</span><span class="s2">=</span><span class="s1">tol </span><span class="s2">/ </span><span class="s6">100</span><span class="s2">)</span>
            <span class="s1">xi </span><span class="s2">= </span><span class="s1">res</span><span class="s2">.</span><span class="s1">x </span><span class="s2">* </span><span class="s1">xi</span>
            <span class="s4">return </span><span class="s1">squeeze</span><span class="s2">(</span><span class="s1">res</span><span class="s2">.</span><span class="s1">fun</span><span class="s2">), </span><span class="s1">p </span><span class="s2">+ </span><span class="s1">xi</span><span class="s2">, </span><span class="s1">xi</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s0"># only bounded on one side. use the tangent function to convert</span>
            <span class="s0"># the infinity bound to a finite bound. The new bounded region</span>
            <span class="s0"># is a subregion of the region bounded by -np.pi/2 and np.pi/2.</span>
            <span class="s1">bound </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arctan</span><span class="s2">(</span><span class="s1">bound</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arctan</span><span class="s2">(</span><span class="s1">bound</span><span class="s2">[</span><span class="s6">1</span><span class="s2">])</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">_minimize_scalar_bounded</span><span class="s2">(</span>
                <span class="s4">lambda </span><span class="s1">x</span><span class="s2">: </span><span class="s1">myfunc</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">tan</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)),</span>
                <span class="s1">bound</span><span class="s2">,</span>
                <span class="s1">xatol</span><span class="s2">=</span><span class="s1">tol </span><span class="s2">/ </span><span class="s6">100</span><span class="s2">)</span>
            <span class="s1">xi </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">tan</span><span class="s2">(</span><span class="s1">res</span><span class="s2">.</span><span class="s1">x</span><span class="s2">) * </span><span class="s1">xi</span>
            <span class="s4">return </span><span class="s1">squeeze</span><span class="s2">(</span><span class="s1">res</span><span class="s2">.</span><span class="s1">fun</span><span class="s2">), </span><span class="s1">p </span><span class="s2">+ </span><span class="s1">xi</span><span class="s2">, </span><span class="s1">xi</span>


<span class="s4">def </span><span class="s1">fmin_powell</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">xtol</span><span class="s2">=</span><span class="s6">1e-4</span><span class="s2">, </span><span class="s1">ftol</span><span class="s2">=</span><span class="s6">1e-4</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                <span class="s1">maxfun</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s6">1</span><span class="s2">, </span><span class="s1">retall</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                <span class="s1">direc</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Minimize a function using modified Powell's method. 
 
    This method only uses function values, not derivatives. 
 
    Parameters 
    ---------- 
    func : callable f(x,*args) 
        Objective function to be minimized. 
    x0 : ndarray 
        Initial guess. 
    args : tuple, optional 
        Extra arguments passed to func. 
    xtol : float, optional 
        Line-search error tolerance. 
    ftol : float, optional 
        Relative error in ``func(xopt)`` acceptable for convergence. 
    maxiter : int, optional 
        Maximum number of iterations to perform. 
    maxfun : int, optional 
        Maximum number of function evaluations to make. 
    full_output : bool, optional 
        If True, ``fopt``, ``xi``, ``direc``, ``iter``, ``funcalls``, and 
        ``warnflag`` are returned. 
    disp : bool, optional 
        If True, print convergence messages. 
    retall : bool, optional 
        If True, return a list of the solution at each iteration. 
    callback : callable, optional 
        An optional user-supplied function, called after each 
        iteration.  Called as ``callback(xk)``, where ``xk`` is the 
        current parameter vector. 
    direc : ndarray, optional 
        Initial fitting step and parameter order set as an (N, N) array, where N 
        is the number of fitting parameters in `x0`. Defaults to step size 1.0 
        fitting all parameters simultaneously (``np.eye((N, N))``). To 
        prevent initial consideration of values in a step or to change initial 
        step size, set to 0 or desired step size in the Jth position in the Mth 
        block, where J is the position in `x0` and M is the desired evaluation 
        step, with steps being evaluated in index order. Step size and ordering 
        will change freely as minimization proceeds. 
 
    Returns 
    ------- 
    xopt : ndarray 
        Parameter which minimizes `func`. 
    fopt : number 
        Value of function at minimum: ``fopt = func(xopt)``. 
    direc : ndarray 
        Current direction set. 
    iter : int 
        Number of iterations. 
    funcalls : int 
        Number of function calls made. 
    warnflag : int 
        Integer warning flag: 
            1 : Maximum number of function evaluations. 
            2 : Maximum number of iterations. 
            3 : NaN result encountered. 
            4 : The result is out of the provided bounds. 
    allvecs : list 
        List of solutions at each iteration. 
 
    See also 
    -------- 
    minimize: Interface to unconstrained minimization algorithms for 
        multivariate functions. See the 'Powell' method in particular. 
 
    Notes 
    ----- 
    Uses a modification of Powell's method to find the minimum of 
    a function of N variables. Powell's method is a conjugate 
    direction method. 
 
    The algorithm has two loops. The outer loop merely iterates over the inner 
    loop. The inner loop minimizes over each current direction in the direction 
    set. At the end of the inner loop, if certain conditions are met, the 
    direction that gave the largest decrease is dropped and replaced with the 
    difference between the current estimated x and the estimated x from the 
    beginning of the inner-loop. 
 
    The technical conditions for replacing the direction of greatest 
    increase amount to checking that 
 
    1. No further gain can be made along the direction of greatest increase 
       from that iteration. 
    2. The direction of greatest increase accounted for a large sufficient 
       fraction of the decrease in the function value from that iteration of 
       the inner loop. 
 
    References 
    ---------- 
    Powell M.J.D. (1964) An efficient method for finding the minimum of a 
    function of several variables without calculating derivatives, 
    Computer Journal, 7 (2):155-162. 
 
    Press W., Teukolsky S.A., Vetterling W.T., and Flannery B.P.: 
    Numerical Recipes (any edition), Cambridge University Press 
 
    Examples 
    -------- 
    &gt;&gt;&gt; def f(x): 
    ...     return x**2 
 
    &gt;&gt;&gt; from scipy import optimize 
 
    &gt;&gt;&gt; minimum = optimize.fmin_powell(f, -1) 
    Optimization terminated successfully. 
             Current function value: 0.000000 
             Iterations: 2 
             Function evaluations: 16 
    &gt;&gt;&gt; minimum 
    array(0.0) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">opts </span><span class="s2">= {</span><span class="s3">'xtol'</span><span class="s2">: </span><span class="s1">xtol</span><span class="s2">,</span>
            <span class="s3">'ftol'</span><span class="s2">: </span><span class="s1">ftol</span><span class="s2">,</span>
            <span class="s3">'maxiter'</span><span class="s2">: </span><span class="s1">maxiter</span><span class="s2">,</span>
            <span class="s3">'maxfev'</span><span class="s2">: </span><span class="s1">maxfun</span><span class="s2">,</span>
            <span class="s3">'disp'</span><span class="s2">: </span><span class="s1">disp</span><span class="s2">,</span>
            <span class="s3">'direc'</span><span class="s2">: </span><span class="s1">direc</span><span class="s2">,</span>
            <span class="s3">'return_all'</span><span class="s2">: </span><span class="s1">retall</span><span class="s2">}</span>

    <span class="s1">callback </span><span class="s2">= </span><span class="s1">_wrap_callback</span><span class="s2">(</span><span class="s1">callback</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">_minimize_powell</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">=</span><span class="s1">callback</span><span class="s2">, **</span><span class="s1">opts</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">full_output</span><span class="s2">:</span>
        <span class="s1">retlist </span><span class="s2">= (</span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'fun'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'direc'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'nit'</span><span class="s2">],</span>
                   <span class="s1">res</span><span class="s2">[</span><span class="s3">'nfev'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'status'</span><span class="s2">])</span>
        <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
            <span class="s1">retlist </span><span class="s2">+= (</span><span class="s1">res</span><span class="s2">[</span><span class="s3">'allvecs'</span><span class="s2">], )</span>
        <span class="s4">return </span><span class="s1">retlist</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">], </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'allvecs'</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">res</span><span class="s2">[</span><span class="s3">'x'</span><span class="s2">]</span>


<span class="s4">def </span><span class="s1">_minimize_powell</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">callback</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                     <span class="s1">xtol</span><span class="s2">=</span><span class="s6">1e-4</span><span class="s2">, </span><span class="s1">ftol</span><span class="s2">=</span><span class="s6">1e-4</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">maxfev</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                     <span class="s1">disp</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">direc</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">return_all</span><span class="s2">=</span><span class="s4">False</span><span class="s2">,</span>
                     <span class="s2">**</span><span class="s1">unknown_options</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Minimization of scalar function of one or more variables using the 
    modified Powell algorithm. 
 
    Parameters 
    ---------- 
    fun : callable 
        The objective function to be minimized. 
 
            ``fun(x, *args) -&gt; float`` 
 
        where ``x`` is a 1-D array with shape (n,) and ``args`` 
        is a tuple of the fixed parameters needed to completely 
        specify the function. 
    x0 : ndarray, shape (n,) 
        Initial guess. Array of real elements of size (n,), 
        where ``n`` is the number of independent variables. 
    args : tuple, optional 
        Extra arguments passed to the objective function and its 
        derivatives (`fun`, `jac` and `hess` functions). 
    method : str or callable, optional 
        The present documentation is specific to ``method='powell'``, but other 
        options are available. See documentation for `scipy.optimize.minimize`. 
    bounds : sequence or `Bounds`, optional 
        Bounds on decision variables. There are two ways to specify the bounds: 
 
            1. Instance of `Bounds` class. 
            2. Sequence of ``(min, max)`` pairs for each element in `x`. None 
               is used to specify no bound. 
 
        If bounds are not provided, then an unbounded line search will be used. 
        If bounds are provided and the initial guess is within the bounds, then 
        every function evaluation throughout the minimization procedure will be 
        within the bounds. If bounds are provided, the initial guess is outside 
        the bounds, and `direc` is full rank (or left to default), then some 
        function evaluations during the first iteration may be outside the 
        bounds, but every function evaluation after the first iteration will be 
        within the bounds. If `direc` is not full rank, then some parameters 
        may not be optimized and the solution is not guaranteed to be within 
        the bounds. 
 
    options : dict, optional 
        A dictionary of solver options. All methods accept the following 
        generic options: 
 
            maxiter : int 
                Maximum number of iterations to perform. Depending on the 
                method each iteration may use several function evaluations. 
            disp : bool 
                Set to True to print convergence messages. 
 
        See method-specific options for ``method='powell'`` below. 
    callback : callable, optional 
        Called after each iteration. The signature is: 
 
            ``callback(xk)`` 
 
        where ``xk`` is the current parameter vector. 
 
    Returns 
    ------- 
    res : OptimizeResult 
        The optimization result represented as a ``OptimizeResult`` object. 
        Important attributes are: ``x`` the solution array, ``success`` a 
        Boolean flag indicating if the optimizer exited successfully and 
        ``message`` which describes the cause of the termination. See 
        `OptimizeResult` for a description of other attributes. 
 
    Options 
    ------- 
    disp : bool 
        Set to True to print convergence messages. 
    xtol : float 
        Relative error in solution `xopt` acceptable for convergence. 
    ftol : float 
        Relative error in ``fun(xopt)`` acceptable for convergence. 
    maxiter, maxfev : int 
        Maximum allowed number of iterations and function evaluations. 
        Will default to ``N*1000``, where ``N`` is the number of 
        variables, if neither `maxiter` or `maxfev` is set. If both 
        `maxiter` and `maxfev` are set, minimization will stop at the 
        first reached. 
    direc : ndarray 
        Initial set of direction vectors for the Powell method. 
    return_all : bool, optional 
        Set to True to return a list of the best solution at each of the 
        iterations. 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_unknown_options</span><span class="s2">(</span><span class="s1">unknown_options</span><span class="s2">)</span>
    <span class="s1">maxfun </span><span class="s2">= </span><span class="s1">maxfev</span>
    <span class="s1">retall </span><span class="s2">= </span><span class="s1">return_all</span>

    <span class="s1">x </span><span class="s2">= </span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">).</span><span class="s1">flatten</span><span class="s2">()</span>
    <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
        <span class="s1">allvecs </span><span class="s2">= [</span><span class="s1">x</span><span class="s2">]</span>
    <span class="s1">N </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s0"># If neither are set, then set both to default</span>
    <span class="s4">if </span><span class="s1">maxiter </span><span class="s4">is None and </span><span class="s1">maxfun </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">N </span><span class="s2">* </span><span class="s6">1000</span>
        <span class="s1">maxfun </span><span class="s2">= </span><span class="s1">N </span><span class="s2">* </span><span class="s6">1000</span>
    <span class="s4">elif </span><span class="s1">maxiter </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s0"># Convert remaining Nones, to np.inf, unless the other is np.inf, in</span>
        <span class="s0"># which case use the default to avoid unbounded iteration</span>
        <span class="s4">if </span><span class="s1">maxfun </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">:</span>
            <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">N </span><span class="s2">* </span><span class="s6">1000</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>
    <span class="s4">elif </span><span class="s1">maxfun </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">maxiter </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">:</span>
            <span class="s1">maxfun </span><span class="s2">= </span><span class="s1">N </span><span class="s2">* </span><span class="s6">1000</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">maxfun </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>

    <span class="s0"># we need to use a mutable object here that we can update in the</span>
    <span class="s0"># wrapper function</span>
    <span class="s1">fcalls</span><span class="s2">, </span><span class="s1">func </span><span class="s2">= </span><span class="s1">_wrap_scalar_function_maxfun_validation</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">maxfun</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">direc </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">direc </span><span class="s2">= </span><span class="s1">eye</span><span class="s2">(</span><span class="s1">N</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">direc </span><span class="s2">= </span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">direc</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">float</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">matrix_rank</span><span class="s2">(</span><span class="s1">direc</span><span class="s2">) != </span><span class="s1">direc</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]:</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s3">&quot;direc input is not full rank, some parameters may &quot;</span>
                          <span class="s3">&quot;not be optimized&quot;</span><span class="s2">,</span>
                          <span class="s1">OptimizeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">3</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">bounds </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s0"># don't make these arrays of all +/- inf. because</span>
        <span class="s0"># _linesearch_powell will do an unnecessary check of all the elements.</span>
        <span class="s0"># just keep them None, _linesearch_powell will not have to check</span>
        <span class="s0"># all the elements.</span>
        <span class="s1">lower_bound</span><span class="s2">, </span><span class="s1">upper_bound </span><span class="s2">= </span><span class="s4">None</span><span class="s2">, </span><span class="s4">None</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s0"># bounds is standardized in _minimize.py.</span>
        <span class="s1">lower_bound</span><span class="s2">, </span><span class="s1">upper_bound </span><span class="s2">= </span><span class="s1">bounds</span><span class="s2">.</span><span class="s1">lb</span><span class="s2">, </span><span class="s1">bounds</span><span class="s2">.</span><span class="s1">ub</span>
        <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">lower_bound </span><span class="s2">&gt; </span><span class="s1">x0</span><span class="s2">) </span><span class="s4">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">x0 </span><span class="s2">&gt; </span><span class="s1">upper_bound</span><span class="s2">):</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s3">&quot;Initial guess is not within the specified bounds&quot;</span><span class="s2">,</span>
                          <span class="s1">OptimizeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">3</span><span class="s2">)</span>

    <span class="s1">fval </span><span class="s2">= </span><span class="s1">squeeze</span><span class="s2">(</span><span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">))</span>
    <span class="s1">x1 </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
    <span class="s1">iter </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s4">while True</span><span class="s2">:</span>
        <span class="s4">try</span><span class="s2">:</span>
            <span class="s1">fx </span><span class="s2">= </span><span class="s1">fval</span>
            <span class="s1">bigind </span><span class="s2">= </span><span class="s6">0</span>
            <span class="s1">delta </span><span class="s2">= </span><span class="s6">0.0</span>
            <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">N</span><span class="s2">):</span>
                <span class="s1">direc1 </span><span class="s2">= </span><span class="s1">direc</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
                <span class="s1">fx2 </span><span class="s2">= </span><span class="s1">fval</span>
                <span class="s1">fval</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">direc1 </span><span class="s2">= </span><span class="s1">_linesearch_powell</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">direc1</span><span class="s2">,</span>
                                                     <span class="s1">tol</span><span class="s2">=</span><span class="s1">xtol </span><span class="s2">* </span><span class="s6">100</span><span class="s2">,</span>
                                                     <span class="s1">lower_bound</span><span class="s2">=</span><span class="s1">lower_bound</span><span class="s2">,</span>
                                                     <span class="s1">upper_bound</span><span class="s2">=</span><span class="s1">upper_bound</span><span class="s2">,</span>
                                                     <span class="s1">fval</span><span class="s2">=</span><span class="s1">fval</span><span class="s2">)</span>
                <span class="s4">if </span><span class="s2">(</span><span class="s1">fx2 </span><span class="s2">- </span><span class="s1">fval</span><span class="s2">) &gt; </span><span class="s1">delta</span><span class="s2">:</span>
                    <span class="s1">delta </span><span class="s2">= </span><span class="s1">fx2 </span><span class="s2">- </span><span class="s1">fval</span>
                    <span class="s1">bigind </span><span class="s2">= </span><span class="s1">i</span>
            <span class="s1">iter </span><span class="s2">+= </span><span class="s6">1</span>
            <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
                <span class="s1">allvecs</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
            <span class="s1">intermediate_result </span><span class="s2">= </span><span class="s1">OptimizeResult</span><span class="s2">(</span><span class="s1">x</span><span class="s2">=</span><span class="s1">x</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">=</span><span class="s1">fval</span><span class="s2">)</span>
            <span class="s4">if </span><span class="s1">_call_callback_maybe_halt</span><span class="s2">(</span><span class="s1">callback</span><span class="s2">, </span><span class="s1">intermediate_result</span><span class="s2">):</span>
                <span class="s4">break</span>
            <span class="s1">bnd </span><span class="s2">= </span><span class="s1">ftol </span><span class="s2">* (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">fx</span><span class="s2">) + </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">fval</span><span class="s2">)) + </span><span class="s6">1e-20</span>
            <span class="s4">if </span><span class="s6">2.0 </span><span class="s2">* (</span><span class="s1">fx </span><span class="s2">- </span><span class="s1">fval</span><span class="s2">) &lt;= </span><span class="s1">bnd</span><span class="s2">:</span>
                <span class="s4">break</span>
            <span class="s4">if </span><span class="s1">fcalls</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] &gt;= </span><span class="s1">maxfun</span><span class="s2">:</span>
                <span class="s4">break</span>
            <span class="s4">if </span><span class="s1">iter </span><span class="s2">&gt;= </span><span class="s1">maxiter</span><span class="s2">:</span>
                <span class="s4">break</span>
            <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">fx</span><span class="s2">) </span><span class="s4">and </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">fval</span><span class="s2">):</span>
                <span class="s0"># Ended up in a nan-region: bail out</span>
                <span class="s4">break</span>

            <span class="s0"># Construct the extrapolated point</span>
            <span class="s1">direc1 </span><span class="s2">= </span><span class="s1">x </span><span class="s2">- </span><span class="s1">x1</span>
            <span class="s1">x1 </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s0"># make sure that we don't go outside the bounds when extrapolating</span>
            <span class="s4">if </span><span class="s1">lower_bound </span><span class="s4">is None and </span><span class="s1">upper_bound </span><span class="s4">is None</span><span class="s2">:</span>
                <span class="s1">lmax </span><span class="s2">= </span><span class="s6">1</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">_</span><span class="s2">, </span><span class="s1">lmax </span><span class="s2">= </span><span class="s1">_line_for_search</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">direc1</span><span class="s2">, </span><span class="s1">lower_bound</span><span class="s2">, </span><span class="s1">upper_bound</span><span class="s2">)</span>
            <span class="s1">x2 </span><span class="s2">= </span><span class="s1">x </span><span class="s2">+ </span><span class="s1">min</span><span class="s2">(</span><span class="s1">lmax</span><span class="s2">, </span><span class="s6">1</span><span class="s2">) * </span><span class="s1">direc1</span>
            <span class="s1">fx2 </span><span class="s2">= </span><span class="s1">squeeze</span><span class="s2">(</span><span class="s1">func</span><span class="s2">(</span><span class="s1">x2</span><span class="s2">))</span>

            <span class="s4">if </span><span class="s2">(</span><span class="s1">fx </span><span class="s2">&gt; </span><span class="s1">fx2</span><span class="s2">):</span>
                <span class="s1">t </span><span class="s2">= </span><span class="s6">2.0</span><span class="s2">*(</span><span class="s1">fx </span><span class="s2">+ </span><span class="s1">fx2 </span><span class="s2">- </span><span class="s6">2.0</span><span class="s2">*</span><span class="s1">fval</span><span class="s2">)</span>
                <span class="s1">temp </span><span class="s2">= (</span><span class="s1">fx </span><span class="s2">- </span><span class="s1">fval </span><span class="s2">- </span><span class="s1">delta</span><span class="s2">)</span>
                <span class="s1">t </span><span class="s2">*= </span><span class="s1">temp</span><span class="s2">*</span><span class="s1">temp</span>
                <span class="s1">temp </span><span class="s2">= </span><span class="s1">fx </span><span class="s2">- </span><span class="s1">fx2</span>
                <span class="s1">t </span><span class="s2">-= </span><span class="s1">delta</span><span class="s2">*</span><span class="s1">temp</span><span class="s2">*</span><span class="s1">temp</span>
                <span class="s4">if </span><span class="s1">t </span><span class="s2">&lt; </span><span class="s6">0.0</span><span class="s2">:</span>
                    <span class="s1">fval</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">direc1 </span><span class="s2">= </span><span class="s1">_linesearch_powell</span><span class="s2">(</span>
                        <span class="s1">func</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">direc1</span><span class="s2">,</span>
                        <span class="s1">tol</span><span class="s2">=</span><span class="s1">xtol </span><span class="s2">* </span><span class="s6">100</span><span class="s2">,</span>
                        <span class="s1">lower_bound</span><span class="s2">=</span><span class="s1">lower_bound</span><span class="s2">,</span>
                        <span class="s1">upper_bound</span><span class="s2">=</span><span class="s1">upper_bound</span><span class="s2">,</span>
                        <span class="s1">fval</span><span class="s2">=</span><span class="s1">fval</span>
                    <span class="s2">)</span>
                    <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">direc1</span><span class="s2">):</span>
                        <span class="s1">direc</span><span class="s2">[</span><span class="s1">bigind</span><span class="s2">] = </span><span class="s1">direc</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">]</span>
                        <span class="s1">direc</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] = </span><span class="s1">direc1</span>
        <span class="s4">except </span><span class="s1">_MaxFuncCallError</span><span class="s2">:</span>
            <span class="s4">break</span>

    <span class="s1">warnflag </span><span class="s2">= </span><span class="s6">0</span>
    <span class="s1">msg </span><span class="s2">= </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'success'</span><span class="s2">]</span>
    <span class="s0"># out of bounds is more urgent than exceeding function evals or iters,</span>
    <span class="s0"># but I don't want to cause inconsistencies by changing the</span>
    <span class="s0"># established warning flags for maxfev and maxiter, so the out of bounds</span>
    <span class="s0"># warning flag becomes 3, but is checked for first.</span>
    <span class="s4">if </span><span class="s1">bounds </span><span class="s4">and </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">lower_bound </span><span class="s2">&gt; </span><span class="s1">x</span><span class="s2">) </span><span class="s4">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">any</span><span class="s2">(</span><span class="s1">x </span><span class="s2">&gt; </span><span class="s1">upper_bound</span><span class="s2">)):</span>
        <span class="s1">warnflag </span><span class="s2">= </span><span class="s6">4</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'out_of_bounds'</span><span class="s2">]</span>
    <span class="s4">elif </span><span class="s1">fcalls</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] &gt;= </span><span class="s1">maxfun</span><span class="s2">:</span>
        <span class="s1">warnflag </span><span class="s2">= </span><span class="s6">1</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'maxfev'</span><span class="s2">]</span>
    <span class="s4">elif </span><span class="s1">iter </span><span class="s2">&gt;= </span><span class="s1">maxiter</span><span class="s2">:</span>
        <span class="s1">warnflag </span><span class="s2">= </span><span class="s6">2</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'maxiter'</span><span class="s2">]</span>
    <span class="s4">elif </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">fval</span><span class="s2">) </span><span class="s4">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">x</span><span class="s2">).</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s1">warnflag </span><span class="s2">= </span><span class="s6">3</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'nan'</span><span class="s2">]</span>

    <span class="s4">if </span><span class="s1">disp</span><span class="s2">:</span>
        <span class="s1">_print_success_message_or_warn</span><span class="s2">(</span><span class="s1">warnflag</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">RuntimeWarning</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Current function value: %f&quot; </span><span class="s2">% </span><span class="s1">fval</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Iterations: %d&quot; </span><span class="s2">% </span><span class="s1">iter</span><span class="s2">)</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;         Function evaluations: %d&quot; </span><span class="s2">% </span><span class="s1">fcalls</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>

    <span class="s1">result </span><span class="s2">= </span><span class="s1">OptimizeResult</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">=</span><span class="s1">fval</span><span class="s2">, </span><span class="s1">direc</span><span class="s2">=</span><span class="s1">direc</span><span class="s2">, </span><span class="s1">nit</span><span class="s2">=</span><span class="s1">iter</span><span class="s2">, </span><span class="s1">nfev</span><span class="s2">=</span><span class="s1">fcalls</span><span class="s2">[</span><span class="s6">0</span><span class="s2">],</span>
                            <span class="s1">status</span><span class="s2">=</span><span class="s1">warnflag</span><span class="s2">, </span><span class="s1">success</span><span class="s2">=(</span><span class="s1">warnflag </span><span class="s2">== </span><span class="s6">0</span><span class="s2">),</span>
                            <span class="s1">message</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">x</span><span class="s2">=</span><span class="s1">x</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">retall</span><span class="s2">:</span>
        <span class="s1">result</span><span class="s2">[</span><span class="s3">'allvecs'</span><span class="s2">] = </span><span class="s1">allvecs</span>
    <span class="s4">return </span><span class="s1">result</span>


<span class="s4">def </span><span class="s1">_endprint</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">flag</span><span class="s2">, </span><span class="s1">fval</span><span class="s2">, </span><span class="s1">maxfun</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">):</span>
    <span class="s4">if </span><span class="s1">flag </span><span class="s2">== </span><span class="s6">0</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">disp </span><span class="s2">&gt; </span><span class="s6">1</span><span class="s2">:</span>
            <span class="s1">print</span><span class="s2">(</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Optimization terminated successfully;</span><span class="s4">\n</span><span class="s3">&quot;</span>
                  <span class="s3">&quot;The returned value satisfies the termination criteria</span><span class="s4">\n</span><span class="s3">&quot;</span>
                  <span class="s3">&quot;(using xtol = &quot;</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">, </span><span class="s3">&quot;)&quot;</span><span class="s2">)</span>
        <span class="s4">return</span>

    <span class="s4">if </span><span class="s1">flag </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= (</span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">Maximum number of function evaluations exceeded --- &quot;</span>
               <span class="s3">&quot;increase maxfun argument.</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s2">)</span>
    <span class="s4">elif </span><span class="s1">flag </span><span class="s2">== </span><span class="s6">2</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">{}&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">_status_message</span><span class="s2">[</span><span class="s3">'nan'</span><span class="s2">])</span>

    <span class="s1">_print_success_message_or_warn</span><span class="s2">(</span><span class="s1">flag</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">)</span>
    <span class="s4">return</span>


<span class="s4">def </span><span class="s1">brute</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">ranges</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">Ns</span><span class="s2">=</span><span class="s6">20</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s6">0</span><span class="s2">, </span><span class="s1">finish</span><span class="s2">=</span><span class="s1">fmin</span><span class="s2">,</span>
          <span class="s1">disp</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">workers</span><span class="s2">=</span><span class="s6">1</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Minimize a function over a given range by brute force. 
 
    Uses the &quot;brute force&quot; method, i.e., computes the function's value 
    at each point of a multidimensional grid of points, to find the global 
    minimum of the function. 
 
    The function is evaluated everywhere in the range with the datatype of the 
    first call to the function, as enforced by the ``vectorize`` NumPy 
    function. The value and type of the function evaluation returned when 
    ``full_output=True`` are affected in addition by the ``finish`` argument 
    (see Notes). 
 
    The brute force approach is inefficient because the number of grid points 
    increases exponentially - the number of grid points to evaluate is 
    ``Ns ** len(x)``. Consequently, even with coarse grid spacing, even 
    moderately sized problems can take a long time to run, and/or run into 
    memory limitations. 
 
    Parameters 
    ---------- 
    func : callable 
        The objective function to be minimized. Must be in the 
        form ``f(x, *args)``, where ``x`` is the argument in 
        the form of a 1-D array and ``args`` is a tuple of any 
        additional fixed parameters needed to completely specify 
        the function. 
    ranges : tuple 
        Each component of the `ranges` tuple must be either a 
        &quot;slice object&quot; or a range tuple of the form ``(low, high)``. 
        The program uses these to create the grid of points on which 
        the objective function will be computed. See `Note 2` for 
        more detail. 
    args : tuple, optional 
        Any additional fixed parameters needed to completely specify 
        the function. 
    Ns : int, optional 
        Number of grid points along the axes, if not otherwise 
        specified. See `Note2`. 
    full_output : bool, optional 
        If True, return the evaluation grid and the objective function's 
        values on it. 
    finish : callable, optional 
        An optimization function that is called with the result of brute force 
        minimization as initial guess. `finish` should take `func` and 
        the initial guess as positional arguments, and take `args` as 
        keyword arguments. It may additionally take `full_output` 
        and/or `disp` as keyword arguments. Use None if no &quot;polishing&quot; 
        function is to be used. See Notes for more details. 
    disp : bool, optional 
        Set to True to print convergence messages from the `finish` callable. 
    workers : int or map-like callable, optional 
        If `workers` is an int the grid is subdivided into `workers` 
        sections and evaluated in parallel (uses 
        `multiprocessing.Pool &lt;multiprocessing&gt;`). 
        Supply `-1` to use all cores available to the Process. 
        Alternatively supply a map-like callable, such as 
        `multiprocessing.Pool.map` for evaluating the grid in parallel. 
        This evaluation is carried out as ``workers(func, iterable)``. 
        Requires that `func` be pickleable. 
 
        .. versionadded:: 1.3.0 
 
    Returns 
    ------- 
    x0 : ndarray 
        A 1-D array containing the coordinates of a point at which the 
        objective function had its minimum value. (See `Note 1` for 
        which point is returned.) 
    fval : float 
        Function value at the point `x0`. (Returned when `full_output` is 
        True.) 
    grid : tuple 
        Representation of the evaluation grid. It has the same 
        length as `x0`. (Returned when `full_output` is True.) 
    Jout : ndarray 
        Function values at each point of the evaluation 
        grid, i.e., ``Jout = func(*grid)``. (Returned 
        when `full_output` is True.) 
 
    See Also 
    -------- 
    basinhopping, differential_evolution 
 
    Notes 
    ----- 
    *Note 1*: The program finds the gridpoint at which the lowest value 
    of the objective function occurs. If `finish` is None, that is the 
    point returned. When the global minimum occurs within (or not very far 
    outside) the grid's boundaries, and the grid is fine enough, that 
    point will be in the neighborhood of the global minimum. 
 
    However, users often employ some other optimization program to 
    &quot;polish&quot; the gridpoint values, i.e., to seek a more precise 
    (local) minimum near `brute's` best gridpoint. 
    The `brute` function's `finish` option provides a convenient way to do 
    that. Any polishing program used must take `brute's` output as its 
    initial guess as a positional argument, and take `brute's` input values 
    for `args` as keyword arguments, otherwise an error will be raised. 
    It may additionally take `full_output` and/or `disp` as keyword arguments. 
 
    `brute` assumes that the `finish` function returns either an 
    `OptimizeResult` object or a tuple in the form: 
    ``(xmin, Jmin, ... , statuscode)``, where ``xmin`` is the minimizing 
    value of the argument, ``Jmin`` is the minimum value of the objective 
    function, &quot;...&quot; may be some other returned values (which are not used 
    by `brute`), and ``statuscode`` is the status code of the `finish` program. 
 
    Note that when `finish` is not None, the values returned are those 
    of the `finish` program, *not* the gridpoint ones. Consequently, 
    while `brute` confines its search to the input grid points, 
    the `finish` program's results usually will not coincide with any 
    gridpoint, and may fall outside the grid's boundary. Thus, if a 
    minimum only needs to be found over the provided grid points, make 
    sure to pass in `finish=None`. 
 
    *Note 2*: The grid of points is a `numpy.mgrid` object. 
    For `brute` the `ranges` and `Ns` inputs have the following effect. 
    Each component of the `ranges` tuple can be either a slice object or a 
    two-tuple giving a range of values, such as (0, 5). If the component is a 
    slice object, `brute` uses it directly. If the component is a two-tuple 
    range, `brute` internally converts it to a slice object that interpolates 
    `Ns` points from its low-value to its high-value, inclusive. 
 
    Examples 
    -------- 
    We illustrate the use of `brute` to seek the global minimum of a function 
    of two variables that is given as the sum of a positive-definite 
    quadratic and two deep &quot;Gaussian-shaped&quot; craters. Specifically, define 
    the objective function `f` as the sum of three other functions, 
    ``f = f1 + f2 + f3``. We suppose each of these has a signature 
    ``(z, *params)``, where ``z = (x, y)``,  and ``params`` and the functions 
    are as defined below. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; params = (2, 3, 7, 8, 9, 10, 44, -1, 2, 26, 1, -2, 0.5) 
    &gt;&gt;&gt; def f1(z, *params): 
    ...     x, y = z 
    ...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params 
    ...     return (a * x**2 + b * x * y + c * y**2 + d*x + e*y + f) 
 
    &gt;&gt;&gt; def f2(z, *params): 
    ...     x, y = z 
    ...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params 
    ...     return (-g*np.exp(-((x-h)**2 + (y-i)**2) / scale)) 
 
    &gt;&gt;&gt; def f3(z, *params): 
    ...     x, y = z 
    ...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params 
    ...     return (-j*np.exp(-((x-k)**2 + (y-l)**2) / scale)) 
 
    &gt;&gt;&gt; def f(z, *params): 
    ...     return f1(z, *params) + f2(z, *params) + f3(z, *params) 
 
    Thus, the objective function may have local minima near the minimum 
    of each of the three functions of which it is composed. To 
    use `fmin` to polish its gridpoint result, we may then continue as 
    follows: 
 
    &gt;&gt;&gt; rranges = (slice(-4, 4, 0.25), slice(-4, 4, 0.25)) 
    &gt;&gt;&gt; from scipy import optimize 
    &gt;&gt;&gt; resbrute = optimize.brute(f, rranges, args=params, full_output=True, 
    ...                           finish=optimize.fmin) 
    &gt;&gt;&gt; resbrute[0]  # global minimum 
    array([-1.05665192,  1.80834843]) 
    &gt;&gt;&gt; resbrute[1]  # function value at global minimum 
    -3.4085818767 
 
    Note that if `finish` had been set to None, we would have gotten the 
    gridpoint [-1.0 1.75] where the rounded function value is -2.892. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">N </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">ranges</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">N </span><span class="s2">&gt; </span><span class="s6">40</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;Brute Force not possible with more &quot;</span>
                         <span class="s3">&quot;than 40 variables.&quot;</span><span class="s2">)</span>
    <span class="s1">lrange </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">ranges</span><span class="s2">)</span>
    <span class="s4">for </span><span class="s1">k </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">N</span><span class="s2">):</span>
        <span class="s4">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">lrange</span><span class="s2">[</span><span class="s1">k</span><span class="s2">], </span><span class="s1">slice</span><span class="s2">):</span>
            <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">lrange</span><span class="s2">[</span><span class="s1">k</span><span class="s2">]) &lt; </span><span class="s6">3</span><span class="s2">:</span>
                <span class="s1">lrange</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">lrange</span><span class="s2">[</span><span class="s1">k</span><span class="s2">]) + (</span><span class="s1">complex</span><span class="s2">(</span><span class="s1">Ns</span><span class="s2">),)</span>
            <span class="s1">lrange</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">slice</span><span class="s2">(*</span><span class="s1">lrange</span><span class="s2">[</span><span class="s1">k</span><span class="s2">])</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s1">N </span><span class="s2">== </span><span class="s6">1</span><span class="s2">):</span>
        <span class="s1">lrange </span><span class="s2">= </span><span class="s1">lrange</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>

    <span class="s1">grid </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">mgrid</span><span class="s2">[</span><span class="s1">lrange</span><span class="s2">]</span>

    <span class="s0"># obtain an array of parameters that is iterable by a map-like callable</span>
    <span class="s1">inpt_shape </span><span class="s2">= </span><span class="s1">grid</span><span class="s2">.</span><span class="s1">shape</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s1">N </span><span class="s2">&gt; </span><span class="s6">1</span><span class="s2">):</span>
        <span class="s1">grid </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">grid</span><span class="s2">, (</span><span class="s1">inpt_shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">], </span><span class="s1">np</span><span class="s2">.</span><span class="s1">prod</span><span class="s2">(</span><span class="s1">inpt_shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:]))).</span><span class="s1">T</span>

    <span class="s4">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">iterable</span><span class="s2">(</span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">args </span><span class="s2">= (</span><span class="s1">args</span><span class="s2">,)</span>

    <span class="s1">wrapped_func </span><span class="s2">= </span><span class="s1">_Brute_Wrapper</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>

    <span class="s0"># iterate over input arrays, possibly in parallel</span>
    <span class="s4">with </span><span class="s1">MapWrapper</span><span class="s2">(</span><span class="s1">pool</span><span class="s2">=</span><span class="s1">workers</span><span class="s2">) </span><span class="s4">as </span><span class="s1">mapper</span><span class="s2">:</span>
        <span class="s1">Jout </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">mapper</span><span class="s2">(</span><span class="s1">wrapped_func</span><span class="s2">, </span><span class="s1">grid</span><span class="s2">)))</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s1">N </span><span class="s2">== </span><span class="s6">1</span><span class="s2">):</span>
            <span class="s1">grid </span><span class="s2">= (</span><span class="s1">grid</span><span class="s2">,)</span>
            <span class="s1">Jout </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">squeeze</span><span class="s2">(</span><span class="s1">Jout</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s2">(</span><span class="s1">N </span><span class="s2">&gt; </span><span class="s6">1</span><span class="s2">):</span>
            <span class="s1">Jout </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">Jout</span><span class="s2">, </span><span class="s1">inpt_shape</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:])</span>
            <span class="s1">grid </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">grid</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">inpt_shape</span><span class="s2">)</span>

    <span class="s1">Nshape </span><span class="s2">= </span><span class="s1">shape</span><span class="s2">(</span><span class="s1">Jout</span><span class="s2">)</span>

    <span class="s1">indx </span><span class="s2">= </span><span class="s1">argmin</span><span class="s2">(</span><span class="s1">Jout</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">(), </span><span class="s1">axis</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">)</span>
    <span class="s1">Nindx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">N</span><span class="s2">, </span><span class="s1">int</span><span class="s2">)</span>
    <span class="s1">xmin </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">N</span><span class="s2">, </span><span class="s1">float</span><span class="s2">)</span>
    <span class="s4">for </span><span class="s1">k </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">N </span><span class="s2">- </span><span class="s6">1</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">, -</span><span class="s6">1</span><span class="s2">):</span>
        <span class="s1">thisN </span><span class="s2">= </span><span class="s1">Nshape</span><span class="s2">[</span><span class="s1">k</span><span class="s2">]</span>
        <span class="s1">Nindx</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">indx </span><span class="s2">% </span><span class="s1">Nshape</span><span class="s2">[</span><span class="s1">k</span><span class="s2">]</span>
        <span class="s1">indx </span><span class="s2">= </span><span class="s1">indx </span><span class="s2">// </span><span class="s1">thisN</span>
    <span class="s4">for </span><span class="s1">k </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">N</span><span class="s2">):</span>
        <span class="s1">xmin</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">grid</span><span class="s2">[</span><span class="s1">k</span><span class="s2">][</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">Nindx</span><span class="s2">)]</span>

    <span class="s1">Jmin </span><span class="s2">= </span><span class="s1">Jout</span><span class="s2">[</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">Nindx</span><span class="s2">)]</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s1">N </span><span class="s2">== </span><span class="s6">1</span><span class="s2">):</span>
        <span class="s1">grid </span><span class="s2">= </span><span class="s1">grid</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
        <span class="s1">xmin </span><span class="s2">= </span><span class="s1">xmin</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>

    <span class="s4">if </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">finish</span><span class="s2">):</span>
        <span class="s0"># set up kwargs for `finish` function</span>
        <span class="s1">finish_args </span><span class="s2">= </span><span class="s1">_getfullargspec</span><span class="s2">(</span><span class="s1">finish</span><span class="s2">).</span><span class="s1">args</span>
        <span class="s1">finish_kwargs </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">()</span>
        <span class="s4">if </span><span class="s3">'full_output' </span><span class="s4">in </span><span class="s1">finish_args</span><span class="s2">:</span>
            <span class="s1">finish_kwargs</span><span class="s2">[</span><span class="s3">'full_output'</span><span class="s2">] = </span><span class="s6">1</span>
        <span class="s4">if </span><span class="s3">'disp' </span><span class="s4">in </span><span class="s1">finish_args</span><span class="s2">:</span>
            <span class="s1">finish_kwargs</span><span class="s2">[</span><span class="s3">'disp'</span><span class="s2">] = </span><span class="s1">disp</span>
        <span class="s4">elif </span><span class="s3">'options' </span><span class="s4">in </span><span class="s1">finish_args</span><span class="s2">:</span>
            <span class="s0"># pass 'disp' as `options`</span>
            <span class="s0"># (e.g., if `finish` is `minimize`)</span>
            <span class="s1">finish_kwargs</span><span class="s2">[</span><span class="s3">'options'</span><span class="s2">] = {</span><span class="s3">'disp'</span><span class="s2">: </span><span class="s1">disp</span><span class="s2">}</span>

        <span class="s0"># run minimizer</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">finish</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">finish_kwargs</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s1">OptimizeResult</span><span class="s2">):</span>
            <span class="s1">xmin </span><span class="s2">= </span><span class="s1">res</span><span class="s2">.</span><span class="s1">x</span>
            <span class="s1">Jmin </span><span class="s2">= </span><span class="s1">res</span><span class="s2">.</span><span class="s1">fun</span>
            <span class="s1">success </span><span class="s2">= </span><span class="s1">res</span><span class="s2">.</span><span class="s1">success</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">xmin </span><span class="s2">= </span><span class="s1">res</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
            <span class="s1">Jmin </span><span class="s2">= </span><span class="s1">res</span><span class="s2">[</span><span class="s6">1</span><span class="s2">]</span>
            <span class="s1">success </span><span class="s2">= </span><span class="s1">res</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">] == </span><span class="s6">0</span>
        <span class="s4">if not </span><span class="s1">success</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">disp</span><span class="s2">:</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s3">&quot;Either final optimization did not succeed or `finish` &quot;</span>
                              <span class="s3">&quot;does not return `statuscode` as its last argument.&quot;</span><span class="s2">,</span>
                              <span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">2</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">full_output</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">Jmin</span><span class="s2">, </span><span class="s1">grid</span><span class="s2">, </span><span class="s1">Jout</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">xmin</span>


<span class="s4">class </span><span class="s1">_Brute_Wrapper</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot; 
    Object to wrap user cost function for optimize.brute, allowing picklability 
    &quot;&quot;&quot;</span>

    <span class="s4">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">f </span><span class="s2">= </span><span class="s1">f</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">args </span><span class="s2">= [] </span><span class="s4">if </span><span class="s1">args </span><span class="s4">is None else </span><span class="s1">args</span>

    <span class="s4">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0"># flatten needed for one dimensional case.</span>
        <span class="s4">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">f</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">).</span><span class="s1">flatten</span><span class="s2">(), *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">show_options</span><span class="s2">(</span><span class="s1">solver</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s4">True</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Show documentation for additional options of optimization solvers. 
 
    These are method-specific options that can be supplied through the 
    ``options`` dict. 
 
    Parameters 
    ---------- 
    solver : str 
        Type of optimization solver. One of 'minimize', 'minimize_scalar', 
        'root', 'root_scalar', 'linprog', or 'quadratic_assignment'. 
    method : str, optional 
        If not given, shows all methods of the specified solver. Otherwise, 
        show only the options for the specified method. Valid values 
        corresponds to methods' names of respective solver (e.g., 'BFGS' for 
        'minimize'). 
    disp : bool, optional 
        Whether to print the result rather than returning it. 
 
    Returns 
    ------- 
    text 
        Either None (for disp=True) or the text string (disp=False) 
 
    Notes 
    ----- 
    The solver-specific methods are: 
 
    `scipy.optimize.minimize` 
 
    - :ref:`Nelder-Mead &lt;optimize.minimize-neldermead&gt;` 
    - :ref:`Powell      &lt;optimize.minimize-powell&gt;` 
    - :ref:`CG          &lt;optimize.minimize-cg&gt;` 
    - :ref:`BFGS        &lt;optimize.minimize-bfgs&gt;` 
    - :ref:`Newton-CG   &lt;optimize.minimize-newtoncg&gt;` 
    - :ref:`L-BFGS-B    &lt;optimize.minimize-lbfgsb&gt;` 
    - :ref:`TNC         &lt;optimize.minimize-tnc&gt;` 
    - :ref:`COBYLA      &lt;optimize.minimize-cobyla&gt;` 
    - :ref:`COBYQA      &lt;optimize.minimize-cobyqa&gt;` 
    - :ref:`SLSQP       &lt;optimize.minimize-slsqp&gt;` 
    - :ref:`dogleg      &lt;optimize.minimize-dogleg&gt;` 
    - :ref:`trust-ncg   &lt;optimize.minimize-trustncg&gt;` 
 
    `scipy.optimize.root` 
 
    - :ref:`hybr              &lt;optimize.root-hybr&gt;` 
    - :ref:`lm                &lt;optimize.root-lm&gt;` 
    - :ref:`broyden1          &lt;optimize.root-broyden1&gt;` 
    - :ref:`broyden2          &lt;optimize.root-broyden2&gt;` 
    - :ref:`anderson          &lt;optimize.root-anderson&gt;` 
    - :ref:`linearmixing      &lt;optimize.root-linearmixing&gt;` 
    - :ref:`diagbroyden       &lt;optimize.root-diagbroyden&gt;` 
    - :ref:`excitingmixing    &lt;optimize.root-excitingmixing&gt;` 
    - :ref:`krylov            &lt;optimize.root-krylov&gt;` 
    - :ref:`df-sane           &lt;optimize.root-dfsane&gt;` 
 
    `scipy.optimize.minimize_scalar` 
 
    - :ref:`brent       &lt;optimize.minimize_scalar-brent&gt;` 
    - :ref:`golden      &lt;optimize.minimize_scalar-golden&gt;` 
    - :ref:`bounded     &lt;optimize.minimize_scalar-bounded&gt;` 
 
    `scipy.optimize.root_scalar` 
 
    - :ref:`bisect  &lt;optimize.root_scalar-bisect&gt;` 
    - :ref:`brentq  &lt;optimize.root_scalar-brentq&gt;` 
    - :ref:`brenth  &lt;optimize.root_scalar-brenth&gt;` 
    - :ref:`ridder  &lt;optimize.root_scalar-ridder&gt;` 
    - :ref:`toms748 &lt;optimize.root_scalar-toms748&gt;` 
    - :ref:`newton  &lt;optimize.root_scalar-newton&gt;` 
    - :ref:`secant  &lt;optimize.root_scalar-secant&gt;` 
    - :ref:`halley  &lt;optimize.root_scalar-halley&gt;` 
 
    `scipy.optimize.linprog` 
 
    - :ref:`simplex           &lt;optimize.linprog-simplex&gt;` 
    - :ref:`interior-point    &lt;optimize.linprog-interior-point&gt;` 
    - :ref:`revised simplex   &lt;optimize.linprog-revised_simplex&gt;` 
    - :ref:`highs             &lt;optimize.linprog-highs&gt;` 
    - :ref:`highs-ds          &lt;optimize.linprog-highs-ds&gt;` 
    - :ref:`highs-ipm         &lt;optimize.linprog-highs-ipm&gt;` 
 
    `scipy.optimize.quadratic_assignment` 
 
    - :ref:`faq             &lt;optimize.qap-faq&gt;` 
    - :ref:`2opt            &lt;optimize.qap-2opt&gt;` 
 
    Examples 
    -------- 
    We can print documentations of a solver in stdout: 
 
    &gt;&gt;&gt; from scipy.optimize import show_options 
    &gt;&gt;&gt; show_options(solver=&quot;minimize&quot;) 
    ... 
 
    Specifying a method is possible: 
 
    &gt;&gt;&gt; show_options(solver=&quot;minimize&quot;, method=&quot;Nelder-Mead&quot;) 
    ... 
 
    We can also get the documentations as a string: 
 
    &gt;&gt;&gt; show_options(solver=&quot;minimize&quot;, method=&quot;Nelder-Mead&quot;, disp=False) 
    Minimization of scalar function of one or more variables using the ... 
 
    &quot;&quot;&quot;</span>
    <span class="s4">import </span><span class="s1">textwrap</span>

    <span class="s1">doc_routines </span><span class="s2">= {</span>
        <span class="s3">'minimize'</span><span class="s2">: (</span>
            <span class="s2">(</span><span class="s3">'bfgs'</span><span class="s2">, </span><span class="s3">'scipy.optimize._optimize._minimize_bfgs'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'cg'</span><span class="s2">, </span><span class="s3">'scipy.optimize._optimize._minimize_cg'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'cobyla'</span><span class="s2">, </span><span class="s3">'scipy.optimize._cobyla_py._minimize_cobyla'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'cobyqa'</span><span class="s2">, </span><span class="s3">'scipy.optimize._cobyqa_py._minimize_cobyqa'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'dogleg'</span><span class="s2">, </span><span class="s3">'scipy.optimize._trustregion_dogleg._minimize_dogleg'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'l-bfgs-b'</span><span class="s2">, </span><span class="s3">'scipy.optimize._lbfgsb_py._minimize_lbfgsb'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'nelder-mead'</span><span class="s2">, </span><span class="s3">'scipy.optimize._optimize._minimize_neldermead'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'newton-cg'</span><span class="s2">, </span><span class="s3">'scipy.optimize._optimize._minimize_newtoncg'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'powell'</span><span class="s2">, </span><span class="s3">'scipy.optimize._optimize._minimize_powell'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'slsqp'</span><span class="s2">, </span><span class="s3">'scipy.optimize._slsqp_py._minimize_slsqp'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'tnc'</span><span class="s2">, </span><span class="s3">'scipy.optimize._tnc._minimize_tnc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'trust-ncg'</span><span class="s2">,</span>
             <span class="s3">'scipy.optimize._trustregion_ncg._minimize_trust_ncg'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'trust-constr'</span><span class="s2">,</span>
             <span class="s3">'scipy.optimize._trustregion_constr.'</span>
             <span class="s3">'_minimize_trustregion_constr'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'trust-exact'</span><span class="s2">,</span>
             <span class="s3">'scipy.optimize._trustregion_exact._minimize_trustregion_exact'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'trust-krylov'</span><span class="s2">,</span>
             <span class="s3">'scipy.optimize._trustregion_krylov._minimize_trust_krylov'</span><span class="s2">),</span>
        <span class="s2">),</span>
        <span class="s3">'root'</span><span class="s2">: (</span>
            <span class="s2">(</span><span class="s3">'hybr'</span><span class="s2">, </span><span class="s3">'scipy.optimize._minpack_py._root_hybr'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'lm'</span><span class="s2">, </span><span class="s3">'scipy.optimize._root._root_leastsq'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'broyden1'</span><span class="s2">, </span><span class="s3">'scipy.optimize._root._root_broyden1_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'broyden2'</span><span class="s2">, </span><span class="s3">'scipy.optimize._root._root_broyden2_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'anderson'</span><span class="s2">, </span><span class="s3">'scipy.optimize._root._root_anderson_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'diagbroyden'</span><span class="s2">, </span><span class="s3">'scipy.optimize._root._root_diagbroyden_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'excitingmixing'</span><span class="s2">, </span><span class="s3">'scipy.optimize._root._root_excitingmixing_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'linearmixing'</span><span class="s2">, </span><span class="s3">'scipy.optimize._root._root_linearmixing_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'krylov'</span><span class="s2">, </span><span class="s3">'scipy.optimize._root._root_krylov_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'df-sane'</span><span class="s2">, </span><span class="s3">'scipy.optimize._spectral._root_df_sane'</span><span class="s2">),</span>
        <span class="s2">),</span>
        <span class="s3">'root_scalar'</span><span class="s2">: (</span>
            <span class="s2">(</span><span class="s3">'bisect'</span><span class="s2">, </span><span class="s3">'scipy.optimize._root_scalar._root_scalar_bisect_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'brentq'</span><span class="s2">, </span><span class="s3">'scipy.optimize._root_scalar._root_scalar_brentq_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'brenth'</span><span class="s2">, </span><span class="s3">'scipy.optimize._root_scalar._root_scalar_brenth_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'ridder'</span><span class="s2">, </span><span class="s3">'scipy.optimize._root_scalar._root_scalar_ridder_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'toms748'</span><span class="s2">, </span><span class="s3">'scipy.optimize._root_scalar._root_scalar_toms748_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'secant'</span><span class="s2">, </span><span class="s3">'scipy.optimize._root_scalar._root_scalar_secant_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'newton'</span><span class="s2">, </span><span class="s3">'scipy.optimize._root_scalar._root_scalar_newton_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'halley'</span><span class="s2">, </span><span class="s3">'scipy.optimize._root_scalar._root_scalar_halley_doc'</span><span class="s2">),</span>
        <span class="s2">),</span>
        <span class="s3">'linprog'</span><span class="s2">: (</span>
            <span class="s2">(</span><span class="s3">'simplex'</span><span class="s2">, </span><span class="s3">'scipy.optimize._linprog._linprog_simplex_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'interior-point'</span><span class="s2">, </span><span class="s3">'scipy.optimize._linprog._linprog_ip_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'revised simplex'</span><span class="s2">, </span><span class="s3">'scipy.optimize._linprog._linprog_rs_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'highs-ipm'</span><span class="s2">, </span><span class="s3">'scipy.optimize._linprog._linprog_highs_ipm_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'highs-ds'</span><span class="s2">, </span><span class="s3">'scipy.optimize._linprog._linprog_highs_ds_doc'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'highs'</span><span class="s2">, </span><span class="s3">'scipy.optimize._linprog._linprog_highs_doc'</span><span class="s2">),</span>
        <span class="s2">),</span>
        <span class="s3">'quadratic_assignment'</span><span class="s2">: (</span>
            <span class="s2">(</span><span class="s3">'faq'</span><span class="s2">, </span><span class="s3">'scipy.optimize._qap._quadratic_assignment_faq'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'2opt'</span><span class="s2">, </span><span class="s3">'scipy.optimize._qap._quadratic_assignment_2opt'</span><span class="s2">),</span>
        <span class="s2">),</span>
        <span class="s3">'minimize_scalar'</span><span class="s2">: (</span>
            <span class="s2">(</span><span class="s3">'brent'</span><span class="s2">, </span><span class="s3">'scipy.optimize._optimize._minimize_scalar_brent'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'bounded'</span><span class="s2">, </span><span class="s3">'scipy.optimize._optimize._minimize_scalar_bounded'</span><span class="s2">),</span>
            <span class="s2">(</span><span class="s3">'golden'</span><span class="s2">, </span><span class="s3">'scipy.optimize._optimize._minimize_scalar_golden'</span><span class="s2">),</span>
        <span class="s2">),</span>
    <span class="s2">}</span>

    <span class="s4">if </span><span class="s1">solver </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">text </span><span class="s2">= [</span><span class="s3">&quot;</span><span class="s4">\n\n\n</span><span class="s3">========</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;minimize</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;========</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s2">]</span>
        <span class="s1">text</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">show_options</span><span class="s2">(</span><span class="s3">'minimize'</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s4">False</span><span class="s2">))</span>
        <span class="s1">text</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">([</span><span class="s3">&quot;</span><span class="s4">\n\n</span><span class="s3">===============</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;minimize_scalar</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s2">,</span>
                     <span class="s3">&quot;===============</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s2">])</span>
        <span class="s1">text</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">show_options</span><span class="s2">(</span><span class="s3">'minimize_scalar'</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s4">False</span><span class="s2">))</span>
        <span class="s1">text</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">([</span><span class="s3">&quot;</span><span class="s4">\n\n\n</span><span class="s3">====</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;root</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s2">,</span>
                     <span class="s3">&quot;====</span><span class="s4">\n</span><span class="s3">&quot;</span><span class="s2">])</span>
        <span class="s1">text</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">show_options</span><span class="s2">(</span><span class="s3">'root'</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s4">False</span><span class="s2">))</span>
        <span class="s1">text</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">([</span><span class="s3">'</span><span class="s4">\n\n\n</span><span class="s3">=======</span><span class="s4">\n</span><span class="s3">'</span><span class="s2">, </span><span class="s3">'linprog</span><span class="s4">\n</span><span class="s3">'</span><span class="s2">,</span>
                     <span class="s3">'=======</span><span class="s4">\n</span><span class="s3">'</span><span class="s2">])</span>
        <span class="s1">text</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">show_options</span><span class="s2">(</span><span class="s3">'linprog'</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s4">False</span><span class="s2">))</span>
        <span class="s1">text </span><span class="s2">= </span><span class="s3">&quot;&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">text</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">solver </span><span class="s2">= </span><span class="s1">solver</span><span class="s2">.</span><span class="s1">lower</span><span class="s2">()</span>
        <span class="s4">if </span><span class="s1">solver </span><span class="s4">not in </span><span class="s1">doc_routines</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'Unknown solver </span><span class="s4">{</span><span class="s1">solver</span><span class="s4">!r}</span><span class="s3">'</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">method </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s1">text </span><span class="s2">= []</span>
            <span class="s4">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">_ </span><span class="s4">in </span><span class="s1">doc_routines</span><span class="s2">[</span><span class="s1">solver</span><span class="s2">]:</span>
                <span class="s1">text</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">([</span><span class="s3">&quot;</span><span class="s4">\n\n</span><span class="s3">&quot; </span><span class="s2">+ </span><span class="s1">name</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s4">\n</span><span class="s3">&quot; </span><span class="s2">+ </span><span class="s3">&quot;=&quot;</span><span class="s2">*</span><span class="s1">len</span><span class="s2">(</span><span class="s1">name</span><span class="s2">) + </span><span class="s3">&quot;</span><span class="s4">\n\n</span><span class="s3">&quot;</span><span class="s2">])</span>
                <span class="s1">text</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">show_options</span><span class="s2">(</span><span class="s1">solver</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s4">False</span><span class="s2">))</span>
            <span class="s1">text </span><span class="s2">= </span><span class="s3">&quot;&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">text</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">method </span><span class="s2">= </span><span class="s1">method</span><span class="s2">.</span><span class="s1">lower</span><span class="s2">()</span>
            <span class="s1">methods </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">doc_routines</span><span class="s2">[</span><span class="s1">solver</span><span class="s2">])</span>
            <span class="s4">if </span><span class="s1">method </span><span class="s4">not in </span><span class="s1">methods</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f&quot;Unknown method </span><span class="s4">{</span><span class="s1">method</span><span class="s4">!r}</span><span class="s3">&quot;</span><span class="s2">)</span>
            <span class="s1">name </span><span class="s2">= </span><span class="s1">methods</span><span class="s2">[</span><span class="s1">method</span><span class="s2">]</span>

            <span class="s0"># Import function object</span>
            <span class="s1">parts </span><span class="s2">= </span><span class="s1">name</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s3">'.'</span><span class="s2">)</span>
            <span class="s1">mod_name </span><span class="s2">= </span><span class="s3">&quot;.&quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">parts</span><span class="s2">[:-</span><span class="s6">1</span><span class="s2">])</span>
            <span class="s1">__import__</span><span class="s2">(</span><span class="s1">mod_name</span><span class="s2">)</span>
            <span class="s1">obj </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">sys</span><span class="s2">.</span><span class="s1">modules</span><span class="s2">[</span><span class="s1">mod_name</span><span class="s2">], </span><span class="s1">parts</span><span class="s2">[-</span><span class="s6">1</span><span class="s2">])</span>

            <span class="s0"># Get doc</span>
            <span class="s1">doc </span><span class="s2">= </span><span class="s1">obj</span><span class="s2">.</span><span class="s1">__doc__</span>
            <span class="s4">if </span><span class="s1">doc </span><span class="s4">is not None</span><span class="s2">:</span>
                <span class="s1">text </span><span class="s2">= </span><span class="s1">textwrap</span><span class="s2">.</span><span class="s1">dedent</span><span class="s2">(</span><span class="s1">doc</span><span class="s2">).</span><span class="s1">strip</span><span class="s2">()</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">text </span><span class="s2">= </span><span class="s3">&quot;&quot;</span>

    <span class="s4">if </span><span class="s1">disp</span><span class="s2">:</span>
        <span class="s1">print</span><span class="s2">(</span><span class="s1">text</span><span class="s2">)</span>
        <span class="s4">return</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">text</span>
</pre>
</body>
</html>