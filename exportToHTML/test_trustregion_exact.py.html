<html>
<head>
<title>test_trustregion_exact.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_trustregion_exact.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Unit tests for trust-region iterative subproblem. 
 
To run it in its simplest form:: 
  nosetests test_optimize.py 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">optimize</span><span class="s3">.</span><span class="s1">_trustregion_exact </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">estimate_smallest_singular_value</span><span class="s3">,</span>
    <span class="s1">singular_leading_submatrix</span><span class="s3">,</span>
    <span class="s1">IterativeSubproblem</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">linalg </span><span class="s2">import </span><span class="s3">(</span><span class="s1">svd</span><span class="s3">, </span><span class="s1">get_lapack_funcs</span><span class="s3">, </span><span class="s1">det</span><span class="s3">, </span><span class="s1">qr</span><span class="s3">, </span><span class="s1">norm</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">testing </span><span class="s2">import </span><span class="s3">(</span><span class="s1">assert_array_equal</span><span class="s3">,</span>
                           <span class="s1">assert_equal</span><span class="s3">, </span><span class="s1">assert_array_almost_equal</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">random_entry</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">min_eig</span><span class="s3">, </span><span class="s1">max_eig</span><span class="s3">, </span><span class="s1">case</span><span class="s3">):</span>

    <span class="s4"># Generate random matrix</span>
    <span class="s1">rand </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, (</span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">))</span>

    <span class="s4"># QR decomposition</span>
    <span class="s1">Q</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">qr</span><span class="s3">(</span><span class="s1">rand</span><span class="s3">, </span><span class="s1">pivoting</span><span class="s3">=</span><span class="s6">'True'</span><span class="s3">)</span>

    <span class="s4"># Generate random eigenvalues</span>
    <span class="s1">eigvalues </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">min_eig</span><span class="s3">, </span><span class="s1">max_eig</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">eigvalues </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">eigvalues</span><span class="s3">)[::-</span><span class="s5">1</span><span class="s3">]</span>

    <span class="s4"># Generate matrix</span>
    <span class="s1">Qaux </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">eigvalues</span><span class="s3">, </span><span class="s1">Q</span><span class="s3">)</span>
    <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">Qaux</span><span class="s3">, </span><span class="s1">Q</span><span class="s3">.</span><span class="s1">T</span><span class="s3">)</span>

    <span class="s4"># Generate gradient vector accordingly</span>
    <span class="s4"># to the case is being tested.</span>
    <span class="s2">if </span><span class="s1">case </span><span class="s3">== </span><span class="s6">'hard'</span><span class="s3">:</span>
        <span class="s1">g </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">g</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">-</span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">g </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">Q</span><span class="s3">, </span><span class="s1">g</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">case </span><span class="s3">== </span><span class="s6">'jac_equal_zero'</span><span class="s3">:</span>
        <span class="s1">g </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">g </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">A</span><span class="s3">, </span><span class="s1">g</span>


<span class="s2">class </span><span class="s1">TestEstimateSmallestSingularValue</span><span class="s3">:</span>

    <span class="s2">def </span><span class="s1">test_for_ill_condiotioned_matrix</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s4"># Ill-conditioned triangular matrix</span>
        <span class="s1">C </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">],</span>
                      <span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0.05</span><span class="s3">, </span><span class="s5">60</span><span class="s3">, </span><span class="s5">7</span><span class="s3">],</span>
                      <span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0.8</span><span class="s3">, </span><span class="s5">9</span><span class="s3">],</span>
                      <span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">10</span><span class="s3">]])</span>

        <span class="s4"># Get svd decomposition</span>
        <span class="s1">U</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">Vt </span><span class="s3">= </span><span class="s1">svd</span><span class="s3">(</span><span class="s1">C</span><span class="s3">)</span>

        <span class="s4"># Get smallest singular value and correspondent right singular vector.</span>
        <span class="s1">smin_svd </span><span class="s3">= </span><span class="s1">s</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s1">zmin_svd </span><span class="s3">= </span><span class="s1">Vt</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">, :]</span>

        <span class="s4"># Estimate smallest singular value</span>
        <span class="s1">smin</span><span class="s3">, </span><span class="s1">zmin </span><span class="s3">= </span><span class="s1">estimate_smallest_singular_value</span><span class="s3">(</span><span class="s1">C</span><span class="s3">)</span>

        <span class="s4"># Check the estimation</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">smin</span><span class="s3">, </span><span class="s1">smin_svd</span><span class="s3">, </span><span class="s1">decimal</span><span class="s3">=</span><span class="s5">8</span><span class="s3">)</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">zmin</span><span class="s3">), </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">zmin_svd</span><span class="s3">), </span><span class="s1">decimal</span><span class="s3">=</span><span class="s5">8</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">TestSingularLeadingSubmatrix</span><span class="s3">:</span>

    <span class="s2">def </span><span class="s1">test_for_already_singular_leading_submatrix</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s4"># Define test matrix A.</span>
        <span class="s4"># Note that the leading 2x2 submatrix is singular.</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">],</span>
                      <span class="s3">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">],</span>
                      <span class="s3">[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s3">]])</span>

        <span class="s4"># Get Cholesky from lapack functions</span>
        <span class="s1">cholesky</span><span class="s3">, = </span><span class="s1">get_lapack_funcs</span><span class="s3">((</span><span class="s6">'potrf'</span><span class="s3">,), (</span><span class="s1">A</span><span class="s3">,))</span>

        <span class="s4"># Compute Cholesky Decomposition</span>
        <span class="s1">c</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">cholesky</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">overwrite_a</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">clean</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s1">delta</span><span class="s3">, </span><span class="s1">v </span><span class="s3">= </span><span class="s1">singular_leading_submatrix</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>

        <span class="s1">A</span><span class="s3">[</span><span class="s1">k</span><span class="s3">-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">k</span><span class="s3">-</span><span class="s5">1</span><span class="s3">] += </span><span class="s1">delta</span>

        <span class="s4"># Check if the leading submatrix is singular.</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">det</span><span class="s3">(</span><span class="s1">A</span><span class="s3">[:</span><span class="s1">k</span><span class="s3">, :</span><span class="s1">k</span><span class="s3">]), </span><span class="s5">0</span><span class="s3">)</span>

        <span class="s4"># Check if `v` fulfil the specified properties</span>
        <span class="s1">quadratic_term </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">v</span><span class="s3">))</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">quadratic_term</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_for_simetric_indefinite_matrix</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s4"># Define test matrix A.</span>
        <span class="s4"># Note that the leading 5x5 submatrix is indefinite.</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">([[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">8</span><span class="s3">],</span>
                        <span class="s3">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">0</span><span class="s3">],</span>
                        <span class="s3">[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">11</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">],</span>
                        <span class="s3">[</span><span class="s5">7</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">5</span><span class="s3">],</span>
                        <span class="s3">[</span><span class="s5">8</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">8</span><span class="s3">]])</span>

        <span class="s4"># Get Cholesky from lapack functions</span>
        <span class="s1">cholesky</span><span class="s3">, = </span><span class="s1">get_lapack_funcs</span><span class="s3">((</span><span class="s6">'potrf'</span><span class="s3">,), (</span><span class="s1">A</span><span class="s3">,))</span>

        <span class="s4"># Compute Cholesky Decomposition</span>
        <span class="s1">c</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">cholesky</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">overwrite_a</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">clean</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s1">delta</span><span class="s3">, </span><span class="s1">v </span><span class="s3">= </span><span class="s1">singular_leading_submatrix</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>

        <span class="s1">A</span><span class="s3">[</span><span class="s1">k</span><span class="s3">-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">k</span><span class="s3">-</span><span class="s5">1</span><span class="s3">] += </span><span class="s1">delta</span>

        <span class="s4"># Check if the leading submatrix is singular.</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">det</span><span class="s3">(</span><span class="s1">A</span><span class="s3">[:</span><span class="s1">k</span><span class="s3">, :</span><span class="s1">k</span><span class="s3">]), </span><span class="s5">0</span><span class="s3">)</span>

        <span class="s4"># Check if `v` fulfil the specified properties</span>
        <span class="s1">quadratic_term </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">v</span><span class="s3">))</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">quadratic_term</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_for_first_element_equal_to_zero</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s4"># Define test matrix A.</span>
        <span class="s4"># Note that the leading 2x2 submatrix is singular.</span>
        <span class="s1">A </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">11</span><span class="s3">],</span>
                      <span class="s3">[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">12</span><span class="s3">, </span><span class="s5">5</span><span class="s3">],</span>
                      <span class="s3">[</span><span class="s5">11</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s3">]])</span>

        <span class="s4"># Get Cholesky from lapack functions</span>
        <span class="s1">cholesky</span><span class="s3">, = </span><span class="s1">get_lapack_funcs</span><span class="s3">((</span><span class="s6">'potrf'</span><span class="s3">,), (</span><span class="s1">A</span><span class="s3">,))</span>

        <span class="s4"># Compute Cholesky Decomposition</span>
        <span class="s1">c</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">cholesky</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">lower</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">overwrite_a</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">clean</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s1">delta</span><span class="s3">, </span><span class="s1">v </span><span class="s3">= </span><span class="s1">singular_leading_submatrix</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k</span><span class="s3">)</span>

        <span class="s1">A</span><span class="s3">[</span><span class="s1">k</span><span class="s3">-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">k</span><span class="s3">-</span><span class="s5">1</span><span class="s3">] += </span><span class="s1">delta</span>

        <span class="s4"># Check if the leading submatrix is singular</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">det</span><span class="s3">(</span><span class="s1">A</span><span class="s3">[:</span><span class="s1">k</span><span class="s3">, :</span><span class="s1">k</span><span class="s3">]), </span><span class="s5">0</span><span class="s3">)</span>

        <span class="s4"># Check if `v` fulfil the specified properties</span>
        <span class="s1">quadratic_term </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">v</span><span class="s3">))</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">quadratic_term</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>


<span class="s2">class </span><span class="s1">TestIterativeSubproblem</span><span class="s3">:</span>

    <span class="s2">def </span><span class="s1">test_for_the_easy_case</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s4"># `H` is chosen such that `g` is not orthogonal to the</span>
        <span class="s4"># eigenvector associated with the smallest eigenvalue `s`.</span>
        <span class="s1">H </span><span class="s3">= [[</span><span class="s5">10</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">],</span>
             <span class="s3">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
             <span class="s3">[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">7</span><span class="s3">],</span>
             <span class="s3">[</span><span class="s5">4</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">2</span><span class="s3">]]</span>
        <span class="s1">g </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]</span>

        <span class="s4"># Trust Radius</span>
        <span class="s1">trust_radius </span><span class="s3">= </span><span class="s5">1</span>

        <span class="s4"># Solve Subproblem</span>
        <span class="s1">subprob </span><span class="s3">= </span><span class="s1">IterativeSubproblem</span><span class="s3">(</span><span class="s1">x</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
                                      <span class="s1">fun</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s5">0</span><span class="s3">,</span>
                                      <span class="s1">jac</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">g</span><span class="s3">),</span>
                                      <span class="s1">hess</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">H</span><span class="s3">),</span>
                                      <span class="s1">k_easy</span><span class="s3">=</span><span class="s5">1e-10</span><span class="s3">,</span>
                                      <span class="s1">k_hard</span><span class="s3">=</span><span class="s5">1e-10</span><span class="s3">)</span>
        <span class="s1">p</span><span class="s3">, </span><span class="s1">hits_boundary </span><span class="s3">= </span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">solve</span><span class="s3">(</span><span class="s1">trust_radius</span><span class="s3">)</span>

        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, [</span><span class="s5">0.00393332</span><span class="s3">, -</span><span class="s5">0.55260862</span><span class="s3">,</span>
                                      <span class="s5">0.67065477</span><span class="s3">, -</span><span class="s5">0.49480341</span><span class="s3">])</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">hits_boundary</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_for_the_hard_case</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s4"># `H` is chosen such that `g` is orthogonal to the</span>
        <span class="s4"># eigenvector associated with the smallest eigenvalue `s`.</span>
        <span class="s1">H </span><span class="s3">= [[</span><span class="s5">10</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">],</span>
             <span class="s3">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
             <span class="s3">[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">7</span><span class="s3">],</span>
             <span class="s3">[</span><span class="s5">4</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">2</span><span class="s3">]]</span>
        <span class="s1">g </span><span class="s3">= [</span><span class="s5">6.4852641521327437</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]</span>
        <span class="s1">s </span><span class="s3">= -</span><span class="s5">8.2151519874416614</span>

        <span class="s4"># Trust Radius</span>
        <span class="s1">trust_radius </span><span class="s3">= </span><span class="s5">1</span>

        <span class="s4"># Solve Subproblem</span>
        <span class="s1">subprob </span><span class="s3">= </span><span class="s1">IterativeSubproblem</span><span class="s3">(</span><span class="s1">x</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
                                      <span class="s1">fun</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s5">0</span><span class="s3">,</span>
                                      <span class="s1">jac</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">g</span><span class="s3">),</span>
                                      <span class="s1">hess</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">H</span><span class="s3">),</span>
                                      <span class="s1">k_easy</span><span class="s3">=</span><span class="s5">1e-10</span><span class="s3">,</span>
                                      <span class="s1">k_hard</span><span class="s3">=</span><span class="s5">1e-10</span><span class="s3">)</span>
        <span class="s1">p</span><span class="s3">, </span><span class="s1">hits_boundary </span><span class="s3">= </span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">solve</span><span class="s3">(</span><span class="s1">trust_radius</span><span class="s3">)</span>

        <span class="s1">assert_array_almost_equal</span><span class="s3">(-</span><span class="s1">s</span><span class="s3">, </span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">lambda_current</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_for_interior_convergence</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s1">H </span><span class="s3">= [[</span><span class="s5">1.812159</span><span class="s3">, </span><span class="s5">0.82687265</span><span class="s3">, </span><span class="s5">0.21838879</span><span class="s3">, -</span><span class="s5">0.52487006</span><span class="s3">, </span><span class="s5">0.25436988</span><span class="s3">],</span>
             <span class="s3">[</span><span class="s5">0.82687265</span><span class="s3">, </span><span class="s5">2.66380283</span><span class="s3">, </span><span class="s5">0.31508988</span><span class="s3">, -</span><span class="s5">0.40144163</span><span class="s3">, </span><span class="s5">0.08811588</span><span class="s3">],</span>
             <span class="s3">[</span><span class="s5">0.21838879</span><span class="s3">, </span><span class="s5">0.31508988</span><span class="s3">, </span><span class="s5">2.38020726</span><span class="s3">, -</span><span class="s5">0.3166346</span><span class="s3">, </span><span class="s5">0.27363867</span><span class="s3">],</span>
             <span class="s3">[-</span><span class="s5">0.52487006</span><span class="s3">, -</span><span class="s5">0.40144163</span><span class="s3">, -</span><span class="s5">0.3166346</span><span class="s3">, </span><span class="s5">1.61927182</span><span class="s3">, -</span><span class="s5">0.42140166</span><span class="s3">],</span>
             <span class="s3">[</span><span class="s5">0.25436988</span><span class="s3">, </span><span class="s5">0.08811588</span><span class="s3">, </span><span class="s5">0.27363867</span><span class="s3">, -</span><span class="s5">0.42140166</span><span class="s3">, </span><span class="s5">1.33243101</span><span class="s3">]]</span>

        <span class="s1">g </span><span class="s3">= [</span><span class="s5">0.75798952</span><span class="s3">, </span><span class="s5">0.01421945</span><span class="s3">, </span><span class="s5">0.33847612</span><span class="s3">, </span><span class="s5">0.83725004</span><span class="s3">, -</span><span class="s5">0.47909534</span><span class="s3">]</span>

        <span class="s4"># Solve Subproblem</span>
        <span class="s1">subprob </span><span class="s3">= </span><span class="s1">IterativeSubproblem</span><span class="s3">(</span><span class="s1">x</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
                                      <span class="s1">fun</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s5">0</span><span class="s3">,</span>
                                      <span class="s1">jac</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">g</span><span class="s3">),</span>
                                      <span class="s1">hess</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">H</span><span class="s3">))</span>
        <span class="s1">p</span><span class="s3">, </span><span class="s1">hits_boundary </span><span class="s3">= </span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">solve</span><span class="s3">(</span><span class="s5">1.1</span><span class="s3">)</span>

        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, [-</span><span class="s5">0.68585435</span><span class="s3">, </span><span class="s5">0.1222621</span><span class="s3">, -</span><span class="s5">0.22090999</span><span class="s3">,</span>
                                      <span class="s3">-</span><span class="s5">0.67005053</span><span class="s3">, </span><span class="s5">0.31586769</span><span class="s3">])</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">hits_boundary</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">lambda_current</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">niter</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_for_jac_equal_zero</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s1">H </span><span class="s3">= [[</span><span class="s5">0.88547534</span><span class="s3">, </span><span class="s5">2.90692271</span><span class="s3">, </span><span class="s5">0.98440885</span><span class="s3">, -</span><span class="s5">0.78911503</span><span class="s3">, -</span><span class="s5">0.28035809</span><span class="s3">],</span>
             <span class="s3">[</span><span class="s5">2.90692271</span><span class="s3">, -</span><span class="s5">0.04618819</span><span class="s3">, </span><span class="s5">0.32867263</span><span class="s3">, -</span><span class="s5">0.83737945</span><span class="s3">, </span><span class="s5">0.17116396</span><span class="s3">],</span>
             <span class="s3">[</span><span class="s5">0.98440885</span><span class="s3">, </span><span class="s5">0.32867263</span><span class="s3">, -</span><span class="s5">0.87355957</span><span class="s3">, -</span><span class="s5">0.06521957</span><span class="s3">, -</span><span class="s5">1.43030957</span><span class="s3">],</span>
             <span class="s3">[-</span><span class="s5">0.78911503</span><span class="s3">, -</span><span class="s5">0.83737945</span><span class="s3">, -</span><span class="s5">0.06521957</span><span class="s3">, -</span><span class="s5">1.645709</span><span class="s3">, -</span><span class="s5">0.33887298</span><span class="s3">],</span>
             <span class="s3">[-</span><span class="s5">0.28035809</span><span class="s3">, </span><span class="s5">0.17116396</span><span class="s3">, -</span><span class="s5">1.43030957</span><span class="s3">, -</span><span class="s5">0.33887298</span><span class="s3">, -</span><span class="s5">1.68586978</span><span class="s3">]]</span>

        <span class="s1">g </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>

        <span class="s4"># Solve Subproblem</span>
        <span class="s1">subprob </span><span class="s3">= </span><span class="s1">IterativeSubproblem</span><span class="s3">(</span><span class="s1">x</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
                                      <span class="s1">fun</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s5">0</span><span class="s3">,</span>
                                      <span class="s1">jac</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">g</span><span class="s3">),</span>
                                      <span class="s1">hess</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">H</span><span class="s3">),</span>
                                      <span class="s1">k_easy</span><span class="s3">=</span><span class="s5">1e-10</span><span class="s3">,</span>
                                      <span class="s1">k_hard</span><span class="s3">=</span><span class="s5">1e-10</span><span class="s3">)</span>
        <span class="s1">p</span><span class="s3">, </span><span class="s1">hits_boundary </span><span class="s3">= </span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">solve</span><span class="s3">(</span><span class="s5">1.1</span><span class="s3">)</span>

        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, [</span><span class="s5">0.06910534</span><span class="s3">, -</span><span class="s5">0.01432721</span><span class="s3">,</span>
                                      <span class="s3">-</span><span class="s5">0.65311947</span><span class="s3">, -</span><span class="s5">0.23815972</span><span class="s3">,</span>
                                      <span class="s3">-</span><span class="s5">0.84954934</span><span class="s3">])</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">hits_boundary</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">test_for_jac_very_close_to_zero</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>

        <span class="s1">H </span><span class="s3">= [[</span><span class="s5">0.88547534</span><span class="s3">, </span><span class="s5">2.90692271</span><span class="s3">, </span><span class="s5">0.98440885</span><span class="s3">, -</span><span class="s5">0.78911503</span><span class="s3">, -</span><span class="s5">0.28035809</span><span class="s3">],</span>
             <span class="s3">[</span><span class="s5">2.90692271</span><span class="s3">, -</span><span class="s5">0.04618819</span><span class="s3">, </span><span class="s5">0.32867263</span><span class="s3">, -</span><span class="s5">0.83737945</span><span class="s3">, </span><span class="s5">0.17116396</span><span class="s3">],</span>
             <span class="s3">[</span><span class="s5">0.98440885</span><span class="s3">, </span><span class="s5">0.32867263</span><span class="s3">, -</span><span class="s5">0.87355957</span><span class="s3">, -</span><span class="s5">0.06521957</span><span class="s3">, -</span><span class="s5">1.43030957</span><span class="s3">],</span>
             <span class="s3">[-</span><span class="s5">0.78911503</span><span class="s3">, -</span><span class="s5">0.83737945</span><span class="s3">, -</span><span class="s5">0.06521957</span><span class="s3">, -</span><span class="s5">1.645709</span><span class="s3">, -</span><span class="s5">0.33887298</span><span class="s3">],</span>
             <span class="s3">[-</span><span class="s5">0.28035809</span><span class="s3">, </span><span class="s5">0.17116396</span><span class="s3">, -</span><span class="s5">1.43030957</span><span class="s3">, -</span><span class="s5">0.33887298</span><span class="s3">, -</span><span class="s5">1.68586978</span><span class="s3">]]</span>

        <span class="s1">g </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1e-15</span><span class="s3">]</span>

        <span class="s4"># Solve Subproblem</span>
        <span class="s1">subprob </span><span class="s3">= </span><span class="s1">IterativeSubproblem</span><span class="s3">(</span><span class="s1">x</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
                                      <span class="s1">fun</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s5">0</span><span class="s3">,</span>
                                      <span class="s1">jac</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">g</span><span class="s3">),</span>
                                      <span class="s1">hess</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">H</span><span class="s3">),</span>
                                      <span class="s1">k_easy</span><span class="s3">=</span><span class="s5">1e-10</span><span class="s3">,</span>
                                      <span class="s1">k_hard</span><span class="s3">=</span><span class="s5">1e-10</span><span class="s3">)</span>
        <span class="s1">p</span><span class="s3">, </span><span class="s1">hits_boundary </span><span class="s3">= </span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">solve</span><span class="s3">(</span><span class="s5">1.1</span><span class="s3">)</span>

        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, [</span><span class="s5">0.06910534</span><span class="s3">, -</span><span class="s5">0.01432721</span><span class="s3">,</span>
                                      <span class="s3">-</span><span class="s5">0.65311947</span><span class="s3">, -</span><span class="s5">0.23815972</span><span class="s3">,</span>
                                      <span class="s3">-</span><span class="s5">0.84954934</span><span class="s3">])</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">hits_boundary</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">fail_slow</span><span class="s3">(</span><span class="s5">5</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">test_for_random_entries</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s4"># Seed</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">seed</span><span class="s3">(</span><span class="s5">1</span><span class="s3">)</span>

        <span class="s4"># Dimension</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s5">5</span>

        <span class="s2">for </span><span class="s1">case </span><span class="s2">in </span><span class="s3">(</span><span class="s6">'easy'</span><span class="s3">, </span><span class="s6">'hard'</span><span class="s3">, </span><span class="s6">'jac_equal_zero'</span><span class="s3">):</span>

            <span class="s1">eig_limits </span><span class="s3">= [(-</span><span class="s5">20</span><span class="s3">, -</span><span class="s5">15</span><span class="s3">),</span>
                          <span class="s3">(-</span><span class="s5">10</span><span class="s3">, -</span><span class="s5">5</span><span class="s3">),</span>
                          <span class="s3">(-</span><span class="s5">10</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),</span>
                          <span class="s3">(-</span><span class="s5">5</span><span class="s3">, </span><span class="s5">5</span><span class="s3">),</span>
                          <span class="s3">(-</span><span class="s5">10</span><span class="s3">, </span><span class="s5">10</span><span class="s3">),</span>
                          <span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">10</span><span class="s3">),</span>
                          <span class="s3">(</span><span class="s5">5</span><span class="s3">, </span><span class="s5">10</span><span class="s3">),</span>
                          <span class="s3">(</span><span class="s5">15</span><span class="s3">, </span><span class="s5">20</span><span class="s3">)]</span>

            <span class="s2">for </span><span class="s1">min_eig</span><span class="s3">, </span><span class="s1">max_eig </span><span class="s2">in </span><span class="s1">eig_limits</span><span class="s3">:</span>
                <span class="s4"># Generate random symmetric matrix H with</span>
                <span class="s4"># eigenvalues between min_eig and max_eig.</span>
                <span class="s1">H</span><span class="s3">, </span><span class="s1">g </span><span class="s3">= </span><span class="s1">random_entry</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">min_eig</span><span class="s3">, </span><span class="s1">max_eig</span><span class="s3">, </span><span class="s1">case</span><span class="s3">)</span>

                <span class="s4"># Trust radius</span>
                <span class="s1">trust_radius_list </span><span class="s3">= [</span><span class="s5">0.1</span><span class="s3">, </span><span class="s5">0.3</span><span class="s3">, </span><span class="s5">0.6</span><span class="s3">, </span><span class="s5">0.8</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1.2</span><span class="s3">, </span><span class="s5">3.3</span><span class="s3">, </span><span class="s5">5.5</span><span class="s3">, </span><span class="s5">10</span><span class="s3">]</span>

                <span class="s2">for </span><span class="s1">trust_radius </span><span class="s2">in </span><span class="s1">trust_radius_list</span><span class="s3">:</span>
                    <span class="s4"># Solve subproblem with very high accuracy</span>
                    <span class="s1">subprob_ac </span><span class="s3">= </span><span class="s1">IterativeSubproblem</span><span class="s3">(</span><span class="s5">0</span><span class="s3">,</span>
                                                     <span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s5">0</span><span class="s3">,</span>
                                                     <span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">g</span><span class="s3">,</span>
                                                     <span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">H</span><span class="s3">,</span>
                                                     <span class="s1">k_easy</span><span class="s3">=</span><span class="s5">1e-10</span><span class="s3">,</span>
                                                     <span class="s1">k_hard</span><span class="s3">=</span><span class="s5">1e-10</span><span class="s3">)</span>

                    <span class="s1">p_ac</span><span class="s3">, </span><span class="s1">hits_boundary_ac </span><span class="s3">= </span><span class="s1">subprob_ac</span><span class="s3">.</span><span class="s1">solve</span><span class="s3">(</span><span class="s1">trust_radius</span><span class="s3">)</span>

                    <span class="s4"># Compute objective function value</span>
                    <span class="s1">J_ac </span><span class="s3">= </span><span class="s5">1</span><span class="s3">/</span><span class="s5">2</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">p_ac</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">H</span><span class="s3">, </span><span class="s1">p_ac</span><span class="s3">))+</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">g</span><span class="s3">, </span><span class="s1">p_ac</span><span class="s3">)</span>

                    <span class="s1">stop_criteria </span><span class="s3">= [(</span><span class="s5">0.1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">),</span>
                                     <span class="s3">(</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">1.1</span><span class="s3">),</span>
                                     <span class="s3">(</span><span class="s5">0.9</span><span class="s3">, </span><span class="s5">1.01</span><span class="s3">)]</span>

                    <span class="s2">for </span><span class="s1">k_opt</span><span class="s3">, </span><span class="s1">k_trf </span><span class="s2">in </span><span class="s1">stop_criteria</span><span class="s3">:</span>

                        <span class="s4"># k_easy and k_hard computed in function</span>
                        <span class="s4"># of k_opt and k_trf accordingly to</span>
                        <span class="s4"># Conn, A. R., Gould, N. I., &amp; Toint, P. L. (2000).</span>
                        <span class="s4"># &quot;Trust region methods&quot;. Siam. p. 197.</span>
                        <span class="s1">k_easy </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">k_trf</span><span class="s3">-</span><span class="s5">1</span><span class="s3">,</span>
                                     <span class="s5">1</span><span class="s3">-</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">k_opt</span><span class="s3">))</span>
                        <span class="s1">k_hard </span><span class="s3">= </span><span class="s5">1</span><span class="s3">-</span><span class="s1">k_opt</span>

                        <span class="s4"># Solve subproblem</span>
                        <span class="s1">subprob </span><span class="s3">= </span><span class="s1">IterativeSubproblem</span><span class="s3">(</span><span class="s5">0</span><span class="s3">,</span>
                                                      <span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s5">0</span><span class="s3">,</span>
                                                      <span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">g</span><span class="s3">,</span>
                                                      <span class="s2">lambda </span><span class="s1">x</span><span class="s3">: </span><span class="s1">H</span><span class="s3">,</span>
                                                      <span class="s1">k_easy</span><span class="s3">=</span><span class="s1">k_easy</span><span class="s3">,</span>
                                                      <span class="s1">k_hard</span><span class="s3">=</span><span class="s1">k_hard</span><span class="s3">)</span>
                        <span class="s1">p</span><span class="s3">, </span><span class="s1">hits_boundary </span><span class="s3">= </span><span class="s1">subprob</span><span class="s3">.</span><span class="s1">solve</span><span class="s3">(</span><span class="s1">trust_radius</span><span class="s3">)</span>

                        <span class="s4"># Compute objective function value</span>
                        <span class="s1">J </span><span class="s3">= </span><span class="s5">1</span><span class="s3">/</span><span class="s5">2</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">H</span><span class="s3">, </span><span class="s1">p</span><span class="s3">))+</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">g</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>

                        <span class="s4"># Check if it respect k_trf</span>
                        <span class="s2">if </span><span class="s1">hits_boundary</span><span class="s3">:</span>
                            <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">norm</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)-</span><span class="s1">trust_radius</span><span class="s3">) &lt;=</span>
                                               <span class="s3">(</span><span class="s1">k_trf</span><span class="s3">-</span><span class="s5">1</span><span class="s3">)*</span><span class="s1">trust_radius</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>
                        <span class="s2">else</span><span class="s3">:</span>
                            <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">norm</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) &lt;= </span><span class="s1">trust_radius</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>

                        <span class="s4"># Check if it respect k_opt</span>
                        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">J </span><span class="s3">&lt;= </span><span class="s1">k_opt</span><span class="s3">*</span><span class="s1">J_ac</span><span class="s3">, </span><span class="s2">True</span><span class="s3">)</span>

</pre>
</body>
</html>