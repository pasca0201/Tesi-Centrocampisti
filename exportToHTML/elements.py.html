<html>
<head>
<title>elements.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
elements.py</font>
</center></td></tr></table>
<pre><span class="s0"># sql/elements.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>
<span class="s0"># mypy: allow-untyped-defs, allow-untyped-calls</span>

<span class="s2">&quot;&quot;&quot;Core SQL expression elements, including :class:`_expression.ClauseElement`, 
:class:`_expression.ColumnElement`, and derived classes. 
 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">from </span><span class="s1">decimal </span><span class="s3">import </span><span class="s1">Decimal</span>
<span class="s3">from </span><span class="s1">enum </span><span class="s3">import </span><span class="s1">Enum</span>
<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">import </span><span class="s1">operator</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">typing</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">AbstractSet</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Dict</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">FrozenSet</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Generic</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterator</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Mapping</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">overload</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Sequence</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Set</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Tuple </span><span class="s3">as </span><span class="s1">typing_Tuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Type</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TypeVar</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>

<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">coercions</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">operators</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">roles</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">traversals</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">type_api</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">has_schema_attr</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">is_named_from_clause</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">is_quoted_name</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">is_tuple_type</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">annotation </span><span class="s3">import </span><span class="s1">Annotated</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">annotation </span><span class="s3">import </span><span class="s1">SupportsWrappingAnnotations</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_clone</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_expand_cloned</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_generative</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_NoArg</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">Executable</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">Generative</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">HasMemoized</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">Immutable</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">NO_ARG</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">SingletonConstant</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">cache_key </span><span class="s3">import </span><span class="s1">MemoizedHasCacheKey</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">cache_key </span><span class="s3">import </span><span class="s1">NO_CACHE</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">coercions </span><span class="s3">import </span><span class="s1">_document_text_coercion  </span><span class="s0"># noqa</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">operators </span><span class="s3">import </span><span class="s1">ColumnOperators</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">traversals </span><span class="s3">import </span><span class="s1">HasCopyInternals</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">visitors </span><span class="s3">import </span><span class="s1">cloned_traverse</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">visitors </span><span class="s3">import </span><span class="s1">ExternallyTraversible</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">visitors </span><span class="s3">import </span><span class="s1">InternalTraversal</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">visitors </span><span class="s3">import </span><span class="s1">traverse</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">visitors </span><span class="s3">import </span><span class="s1">Visitable</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">exc</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">inspection</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util </span><span class="s3">import </span><span class="s1">HasMemoized_ro_memoized_attribute</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util </span><span class="s3">import </span><span class="s1">TypingOnly</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Literal</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">ParamSpec</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Self</span>

<span class="s3">if </span><span class="s1">typing</span><span class="s4">.</span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_ByArgument</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_ColumnExpressionArgument</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_ColumnExpressionOrStrLabelArgument</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_HasDialect</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_InfoType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_PropagateAttrsType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_TypeEngineArgument</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">cache_key </span><span class="s3">import </span><span class="s1">_CacheKeyTraversalType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">cache_key </span><span class="s3">import </span><span class="s1">CacheKey</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">compiler </span><span class="s3">import </span><span class="s1">Compiled</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">compiler </span><span class="s3">import </span><span class="s1">SQLCompiler</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">functions </span><span class="s3">import </span><span class="s1">FunctionElement</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">operators </span><span class="s3">import </span><span class="s1">OperatorType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">Column</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">DefaultGenerator</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">FetchedValue</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">ForeignKey</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">_SelectIterable</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">FromClause</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">NamedFromClause</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">TextualSelect</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">sqltypes </span><span class="s3">import </span><span class="s1">TupleType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">type_api </span><span class="s3">import </span><span class="s1">TypeEngine</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">visitors </span><span class="s3">import </span><span class="s1">_CloneCallableType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">visitors </span><span class="s3">import </span><span class="s1">_TraverseInternalsType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">visitors </span><span class="s3">import </span><span class="s1">anon_map</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">Connection</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">Dialect</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">_CoreMultiExecuteParams</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">CacheStats</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">CompiledCacheType</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">CoreExecuteOptionsParameter</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">SchemaTranslateMapType</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">result </span><span class="s3">import </span><span class="s1">Result</span>

<span class="s1">_NUMERIC </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">float</span><span class="s4">, </span><span class="s1">Decimal</span><span class="s4">]</span>
<span class="s1">_NUMBER </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">float</span><span class="s4">, </span><span class="s1">int</span><span class="s4">, </span><span class="s1">Decimal</span><span class="s4">]</span>

<span class="s1">_T </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_T&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s5">&quot;Any&quot;</span><span class="s4">)</span>
<span class="s1">_T_co </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_T_co&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">covariant</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
<span class="s1">_OPT </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_OPT&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s5">&quot;Any&quot;</span><span class="s4">)</span>
<span class="s1">_NT </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_NT&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s5">&quot;_NUMERIC&quot;</span><span class="s4">)</span>

<span class="s1">_NMT </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_NMT&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s5">&quot;_NUMBER&quot;</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">overload</span>
<span class="s3">def </span><span class="s1">literal</span><span class="s4">(</span>
    <span class="s1">value</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s1">type_</span><span class="s4">: </span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
    <span class="s1">literal_execute</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; BindParameter</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]: ...</span>


<span class="s4">@</span><span class="s1">overload</span>
<span class="s3">def </span><span class="s1">literal</span><span class="s4">(</span>
    <span class="s1">value</span><span class="s4">: </span><span class="s1">_T</span><span class="s4">,</span>
    <span class="s1">type_</span><span class="s4">: </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">literal_execute</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; BindParameter</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]: ...</span>


<span class="s4">@</span><span class="s1">overload</span>
<span class="s3">def </span><span class="s1">literal</span><span class="s4">(</span>
    <span class="s1">value</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s1">type_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">literal_execute</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; BindParameter</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>


<span class="s3">def </span><span class="s1">literal</span><span class="s4">(</span>
    <span class="s1">value</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s1">type_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">literal_execute</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
<span class="s4">) </span><span class="s1">-&gt; BindParameter</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
    <span class="s2">r&quot;&quot;&quot;Return a literal clause, bound to a bind parameter. 
 
    Literal clauses are created automatically when non- 
    :class:`_expression.ClauseElement` objects (such as strings, ints, dates, 
    etc.) are 
    used in a comparison operation with a :class:`_expression.ColumnElement` 
    subclass, 
    such as a :class:`~sqlalchemy.schema.Column` object.  Use this function 
    to force the generation of a literal clause, which will be created as a 
    :class:`BindParameter` with a bound value. 
 
    :param value: the value to be bound. Can be any Python object supported by 
     the underlying DB-API, or is translatable via the given type argument. 
 
    :param type\_: an optional :class:`~sqlalchemy.types.TypeEngine` which will 
     provide bind-parameter translation for this literal. 
 
    :param literal_execute: optional bool, when True, the SQL engine will 
     attempt to render the bound value directly in the SQL statement at 
     execution time rather than providing as a parameter value. 
 
     .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
        <span class="s1">roles</span><span class="s4">.</span><span class="s1">LiteralValueRole</span><span class="s4">,</span>
        <span class="s1">value</span><span class="s4">,</span>
        <span class="s1">type_</span><span class="s4">=</span><span class="s1">type_</span><span class="s4">,</span>
        <span class="s1">literal_execute</span><span class="s4">=</span><span class="s1">literal_execute</span><span class="s4">,</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">literal_column</span><span class="s4">(</span>
    <span class="s1">text</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]] = </span><span class="s3">None</span>
<span class="s4">) </span><span class="s1">-&gt; ColumnClause</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
    <span class="s2">r&quot;&quot;&quot;Produce a :class:`.ColumnClause` object that has the 
    :paramref:`_expression.column.is_literal` flag set to True. 
 
    :func:`_expression.literal_column` is similar to 
    :func:`_expression.column`, except that 
    it is more often used as a &quot;standalone&quot; column expression that renders 
    exactly as stated; while :func:`_expression.column` 
    stores a string name that 
    will be assumed to be part of a table and may be quoted as such, 
    :func:`_expression.literal_column` can be that, 
    or any other arbitrary column-oriented 
    expression. 
 
    :param text: the text of the expression; can be any SQL expression. 
      Quoting rules will not be applied. To specify a column-name expression 
      which should be subject to quoting rules, use the :func:`column` 
      function. 
 
    :param type\_: an optional :class:`~sqlalchemy.types.TypeEngine` 
      object which will 
      provide result-set translation and additional expression semantics for 
      this column. If left as ``None`` the type will be :class:`.NullType`. 
 
    .. seealso:: 
 
        :func:`_expression.column` 
 
        :func:`_expression.text` 
 
        :ref:`tutorial_select_arbitrary_text` 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">ColumnClause</span><span class="s4">(</span><span class="s1">text</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">=</span><span class="s1">type_</span><span class="s4">, </span><span class="s1">is_literal</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">CompilerElement</span><span class="s4">(</span><span class="s1">Visitable</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;base class for SQL elements that can be compiled to produce a 
    SQL string. 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s4">= ()</span>
    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;compiler_element&quot;</span>

    <span class="s1">supports_execution </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s1">stringify_dialect </span><span class="s4">= </span><span class="s5">&quot;default&quot;</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.engine.default&quot;</span><span class="s4">)</span>
    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.engine.url&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">compile</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">bind</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_HasDialect</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">dialect</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Dialect</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Compiled</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Compile this SQL expression. 
 
        The return value is a :class:`~.Compiled` object. 
        Calling ``str()`` or ``unicode()`` on the returned value will yield a 
        string representation of the result. The 
        :class:`~.Compiled` object also can return a 
        dictionary of bind parameter names and values 
        using the ``params`` accessor. 
 
        :param bind: An :class:`.Connection` or :class:`.Engine` which 
           can provide a :class:`.Dialect` in order to generate a 
           :class:`.Compiled` object.  If the ``bind`` and 
           ``dialect`` parameters are both omitted, a default SQL compiler 
           is used. 
 
        :param column_keys: Used for INSERT and UPDATE statements, a list of 
            column names which should be present in the VALUES clause of the 
            compiled statement. If ``None``, all columns from the target table 
            object are rendered. 
 
        :param dialect: A :class:`.Dialect` instance which can generate 
            a :class:`.Compiled` object.  This argument takes precedence over 
            the ``bind`` argument. 
 
        :param compile_kwargs: optional dictionary of additional parameters 
            that will be passed through to the compiler within all &quot;visit&quot; 
            methods.  This allows any custom flag to be passed through to 
            a custom compilation construct, for example.  It is also used 
            for the case of passing the ``literal_binds`` flag through:: 
 
                from sqlalchemy.sql import table, column, select 
 
                t = table('t', column('x')) 
 
                s = select(t).where(t.c.x == 5) 
 
                print(s.compile(compile_kwargs={&quot;literal_binds&quot;: True})) 
 
        .. seealso:: 
 
            :ref:`faq_sql_expression_string` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">dialect </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">bind</span><span class="s4">:</span>
                <span class="s1">dialect </span><span class="s4">= </span><span class="s1">bind</span><span class="s4">.</span><span class="s1">dialect</span>
            <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">stringify_dialect </span><span class="s4">== </span><span class="s5">&quot;default&quot;</span><span class="s4">:</span>
                <span class="s1">default </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">engine_default</span>
                <span class="s1">dialect </span><span class="s4">= </span><span class="s1">default</span><span class="s4">.</span><span class="s1">StrCompileDialect</span><span class="s4">()</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">url </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">engine_url</span>
                <span class="s1">dialect </span><span class="s4">= </span><span class="s1">url</span><span class="s4">.</span><span class="s1">URL</span><span class="s4">.</span><span class="s1">create</span><span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">stringify_dialect</span>
                <span class="s4">).</span><span class="s1">get_dialect</span><span class="s4">()()</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_compiler</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_compiler</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">: </span><span class="s1">Dialect</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Compiled</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a compiler appropriate for this ClauseElement, given a 
        Dialect.&quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">ClauseElement</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">statement_compiler</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__str__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">str</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">())</span>


<span class="s4">@</span><span class="s1">inspection</span><span class="s4">.</span><span class="s1">_self_inspects</span>
<span class="s3">class </span><span class="s1">ClauseElement</span><span class="s4">(</span>
    <span class="s1">SupportsWrappingAnnotations</span><span class="s4">,</span>
    <span class="s1">MemoizedHasCacheKey</span><span class="s4">,</span>
    <span class="s1">HasCopyInternals</span><span class="s4">,</span>
    <span class="s1">ExternallyTraversible</span><span class="s4">,</span>
    <span class="s1">CompilerElement</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Base class for elements of a programmatically constructed SQL 
    expression. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;clause&quot;</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
        <span class="s3">def </span><span class="s1">_propagate_attrs</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _PropagateAttrsType</span><span class="s4">:</span>
            <span class="s2">&quot;&quot;&quot;like annotations, however these propagate outwards liberally 
            as SQL constructs are built, and are set up at construction time. 
 
            &quot;&quot;&quot;</span>
            <span class="s4">...</span>

    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">_propagate_attrs </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_memoized_property</span>
    <span class="s3">def </span><span class="s1">description</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s3">return None</span>

    <span class="s1">_is_clone_of</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Self</span><span class="s4">] = </span><span class="s3">None</span>

    <span class="s1">is_clause_element </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">is_selectable </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">is_dml </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_column_element </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_keyed_column_element </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_table </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_gen_static_annotations_cache_key </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_textual </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_from_clause </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_returns_rows </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_text_clause </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_from_container </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_select_container </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_select_base </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_select_statement </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_bind_parameter </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_clause_list </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_lambda_element </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_singleton_constant </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_immutable </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_star </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_order_by_label_element</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">Label</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">return None</span>

    <span class="s1">_cache_key_traversal</span><span class="s4">: </span><span class="s1">_CacheKeyTraversalType </span><span class="s4">= </span><span class="s3">None</span>

    <span class="s1">negation_clause</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]</span>

    <span class="s3">if </span><span class="s1">typing</span><span class="s4">.</span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s3">def </span><span class="s1">get_children</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, *, </span><span class="s1">omit_attrs</span><span class="s4">: </span><span class="s1">typing_Tuple</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, ...] = ..., **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
        <span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">ClauseElement</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s4">[]</span>

    <span class="s3">def </span><span class="s1">_set_propagate_attrs</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">values</span><span class="s4">: </span><span class="s1">Mapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s0"># usually, self._propagate_attrs is empty here.  one case where it's</span>
        <span class="s0"># not is a subquery against ORM select, that is then pulled as a</span>
        <span class="s0"># property of an aliased class.   should all be good</span>

        <span class="s0"># assert not self._propagate_attrs</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_propagate_attrs </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">immutabledict</span><span class="s4">(</span><span class="s1">values</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_clone</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Create a shallow copy of this ClauseElement. 
 
        This method may be used by a generative API.  Its also used as 
        part of the &quot;deep&quot; copy afforded by a traversal that combines 
        the _copy_internals() method. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">skip </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_memoized_keys</span>
        <span class="s1">c </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">skip</span><span class="s4">:</span>
            <span class="s0"># ensure this iteration remains atomic</span>
            <span class="s1">c</span><span class="s4">.</span><span class="s1">__dict__ </span><span class="s4">= {</span>
                <span class="s1">k</span><span class="s4">: </span><span class="s1">v </span><span class="s3">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">().</span><span class="s1">items</span><span class="s4">() </span><span class="s3">if </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">skip</span>
            <span class="s4">}</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">c</span><span class="s4">.</span><span class="s1">__dict__ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">()</span>

        <span class="s0"># this is a marker that helps to &quot;equate&quot; clauses to each other</span>
        <span class="s0"># when a Select returns its list of FROM clauses.  the cloning</span>
        <span class="s0"># process leaves around a lot of remnants of the previous clause</span>
        <span class="s0"># typically in the form of column expressions still attached to the</span>
        <span class="s0"># old table.</span>
        <span class="s1">cc </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_clone_of</span>
        <span class="s1">c</span><span class="s4">.</span><span class="s1">_is_clone_of </span><span class="s4">= </span><span class="s1">cc </span><span class="s3">if </span><span class="s1">cc </span><span class="s3">is not None else </span><span class="s1">self</span>
        <span class="s3">return </span><span class="s1">c</span>

    <span class="s3">def </span><span class="s1">_negate_in_binary</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">negated_op</span><span class="s4">, </span><span class="s1">original_op</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;a hook to allow the right side of a binary expression to respond 
        to a negation of the binary expression. 
 
        Used for the special case of expanding bind parameter with IN. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_with_binary_element_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;in the context of binary expression, convert the type of this 
        object to the one given. 
 
        applies only to :class:`_expression.ColumnElement` classes. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_constructor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;return the 'constructor' for this ClauseElement. 
 
        This is for the purposes for creating a new object of 
        this type.   Usually, its just the element's __class__. 
        However, the &quot;Annotated&quot; version of the object overrides 
        to return the class of its proxied element. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span>

    <span class="s4">@</span><span class="s1">HasMemoized</span><span class="s4">.</span><span class="s1">memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_cloned_set</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Return the set consisting all cloned ancestors of this 
        ClauseElement. 
 
        Includes this ClauseElement.  This accessor tends to be used for 
        FromClause objects to identify 'equivalent' FROM clauses, regardless 
        of transformative operations. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">s </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">column_set</span><span class="s4">()</span>
        <span class="s1">f</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ClauseElement</span><span class="s4">] = </span><span class="s1">self</span>

        <span class="s0"># note this creates a cycle, asserted in test_memusage. however,</span>
        <span class="s0"># turning this into a plain @property adds tends of thousands of method</span>
        <span class="s0"># calls to Core / ORM performance tests, so the small overhead</span>
        <span class="s0"># introduced by the relatively small amount of short term cycles</span>
        <span class="s0"># produced here is preferable</span>
        <span class="s3">while </span><span class="s1">f </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">s</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
            <span class="s1">f </span><span class="s4">= </span><span class="s1">f</span><span class="s4">.</span><span class="s1">_is_clone_of</span>
        <span class="s3">return </span><span class="s1">s</span>

    <span class="s3">def </span><span class="s1">_de_clone</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">while </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_clone_of </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_clone_of</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">entity_namespace</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span>
            <span class="s5">&quot;This SQL expression has no entity namespace &quot;</span>
            <span class="s5">&quot;with which to filter from.&quot;</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__getstate__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">d </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">()</span>
        <span class="s1">d</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;_is_clone_of&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s1">d</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;_generate_cache_key&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">d</span>

    <span class="s3">def </span><span class="s1">_execute_on_connection</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">distilled_params</span><span class="s4">: </span><span class="s1">_CoreMultiExecuteParams</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">CoreExecuteOptionsParameter</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Result</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">supports_execution</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
                <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">Executable</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">connection</span><span class="s4">.</span><span class="s1">_execute_clauseelement</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">, </span><span class="s1">distilled_params</span><span class="s4">, </span><span class="s1">execution_options</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ObjectNotExecutableError</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_execute_on_scalar</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">connection</span><span class="s4">: </span><span class="s1">Connection</span><span class="s4">,</span>
        <span class="s1">distilled_params</span><span class="s4">: </span><span class="s1">_CoreMultiExecuteParams</span><span class="s4">,</span>
        <span class="s1">execution_options</span><span class="s4">: </span><span class="s1">CoreExecuteOptionsParameter</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;an additional hook for subclasses to provide a different 
        implementation for connection.scalar() vs. connection.execute(). 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_execute_on_connection</span><span class="s4">(</span>
            <span class="s1">connection</span><span class="s4">, </span><span class="s1">distilled_params</span><span class="s4">, </span><span class="s1">execution_options</span>
        <span class="s4">).</span><span class="s1">scalar</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_get_embedded_bindparams</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Sequence</span><span class="s4">[</span><span class="s1">BindParameter</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;Return the list of :class:`.BindParameter` objects embedded in the 
        object. 
 
        This accomplishes the same purpose as ``visitors.traverse()`` or 
        similar would provide, however by making use of the cache key 
        it takes advantage of memoization of the key to result in fewer 
        net method calls, assuming the statement is also going to be 
        executed. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">key </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_generate_cache_key</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">bindparams</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">BindParameter</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = []</span>

            <span class="s1">traverse</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, {}, {</span><span class="s5">&quot;bindparam&quot;</span><span class="s4">: </span><span class="s1">bindparams</span><span class="s4">.</span><span class="s1">append</span><span class="s4">})</span>
            <span class="s3">return </span><span class="s1">bindparams</span>

        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">key</span><span class="s4">.</span><span class="s1">bindparams</span>

    <span class="s3">def </span><span class="s1">unique_params</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__optionaldict</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a copy with :func:`_expression.bindparam` elements 
        replaced. 
 
        Same functionality as :meth:`_expression.ClauseElement.params`, 
        except adds `unique=True` 
        to affected bind parameters so that multiple statements can be 
        used. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_replace_params</span><span class="s4">(</span><span class="s3">True</span><span class="s4">, </span><span class="s1">__optionaldict</span><span class="s4">, </span><span class="s1">kwargs</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">params</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__optionaldict</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Mapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a copy with :func:`_expression.bindparam` elements 
        replaced. 
 
        Returns a copy of this ClauseElement with 
        :func:`_expression.bindparam` 
        elements replaced with values taken from the given dictionary:: 
 
          &gt;&gt;&gt; clause = column('x') + bindparam('foo') 
          &gt;&gt;&gt; print(clause.compile().params) 
          {'foo':None} 
          &gt;&gt;&gt; print(clause.params({'foo':7}).compile().params) 
          {'foo':7} 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_replace_params</span><span class="s4">(</span><span class="s3">False</span><span class="s4">, </span><span class="s1">__optionaldict</span><span class="s4">, </span><span class="s1">kwargs</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_replace_params</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">unique</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">,</span>
        <span class="s1">optionaldict</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Mapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]],</span>
        <span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">optionaldict</span><span class="s4">:</span>
            <span class="s1">kwargs</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">optionaldict</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">visit_bindparam</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">: </span><span class="s1">BindParameter</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">bind</span><span class="s4">.</span><span class="s1">key </span><span class="s3">in </span><span class="s1">kwargs</span><span class="s4">:</span>
                <span class="s1">bind</span><span class="s4">.</span><span class="s1">value </span><span class="s4">= </span><span class="s1">kwargs</span><span class="s4">[</span><span class="s1">bind</span><span class="s4">.</span><span class="s1">key</span><span class="s4">]</span>
                <span class="s1">bind</span><span class="s4">.</span><span class="s1">required </span><span class="s4">= </span><span class="s3">False</span>
            <span class="s3">if </span><span class="s1">unique</span><span class="s4">:</span>
                <span class="s1">bind</span><span class="s4">.</span><span class="s1">_convert_to_unique</span><span class="s4">()</span>

        <span class="s3">return </span><span class="s1">cloned_traverse</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s4">{</span><span class="s5">&quot;maintain_key&quot;</span><span class="s4">: </span><span class="s3">True</span><span class="s4">, </span><span class="s5">&quot;detect_subquery_cols&quot;</span><span class="s4">: </span><span class="s3">True</span><span class="s4">},</span>
            <span class="s4">{</span><span class="s5">&quot;bindparam&quot;</span><span class="s4">: </span><span class="s1">visit_bindparam</span><span class="s4">},</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">compare</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">ClauseElement</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Compare this :class:`_expression.ClauseElement` to 
        the given :class:`_expression.ClauseElement`. 
 
        Subclasses should override the default behavior, which is a 
        straight identity comparison. 
 
        \**kw are arguments consumed by subclass ``compare()`` methods and 
        may be used to modify the criteria for comparison 
        (see :class:`_expression.ColumnElement`). 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">traversals</span><span class="s4">.</span><span class="s1">compare</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; ClauseElement</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Apply a 'grouping' to this :class:`_expression.ClauseElement`. 
 
        This method is overridden by subclasses to return a &quot;grouping&quot; 
        construct, i.e. parenthesis.   In particular it's used by &quot;binary&quot; 
        expressions to provide a grouping around themselves when placed into a 
        larger expression, as well as by :func:`_expression.select` 
        constructs when placed into the FROM clause of another 
        :func:`_expression.select`.  (Note that subqueries should be 
        normally created using the :meth:`_expression.Select.alias` method, 
        as many 
        platforms require nested SELECT statements to be named). 
 
        As expressions are composed together, the application of 
        :meth:`self_group` is automatic - end-user code should never 
        need to use this method directly.  Note that SQLAlchemy's 
        clause constructs take operator precedence into account - 
        so parenthesis might not be needed, for example, in 
        an expression like ``x OR (y AND z)`` - AND takes precedence 
        over OR. 
 
        The base :meth:`self_group` method of 
        :class:`_expression.ClauseElement` 
        just returns self. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_ungroup</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ClauseElement</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return this :class:`_expression.ClauseElement` 
        without any groupings. 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_compile_w_cache</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">dialect</span><span class="s4">: </span><span class="s1">Dialect</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">compiled_cache</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">CompiledCacheType</span><span class="s4">],</span>
        <span class="s1">column_keys</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">str</span><span class="s4">],</span>
        <span class="s1">for_executemany</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">schema_translate_map</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">SchemaTranslateMapType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; typing_Tuple</span><span class="s4">[</span>
        <span class="s1">Compiled</span><span class="s4">, </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">BindParameter</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]], </span><span class="s1">CacheStats</span>
    <span class="s4">]:</span>
        <span class="s1">elem_cache_key</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">CacheKey</span><span class="s4">]</span>

        <span class="s3">if </span><span class="s1">compiled_cache </span><span class="s3">is not None and </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">_supports_statement_cache</span><span class="s4">:</span>
            <span class="s1">elem_cache_key </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_generate_cache_key</span><span class="s4">()</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">elem_cache_key </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">elem_cache_key </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
                <span class="s3">assert </span><span class="s1">compiled_cache </span><span class="s3">is not None</span>

            <span class="s1">cache_key</span><span class="s4">, </span><span class="s1">extracted_params </span><span class="s4">= </span><span class="s1">elem_cache_key</span>
            <span class="s1">key </span><span class="s4">= (</span>
                <span class="s1">dialect</span><span class="s4">,</span>
                <span class="s1">cache_key</span><span class="s4">,</span>
                <span class="s1">tuple</span><span class="s4">(</span><span class="s1">column_keys</span><span class="s4">),</span>
                <span class="s1">bool</span><span class="s4">(</span><span class="s1">schema_translate_map</span><span class="s4">),</span>
                <span class="s1">for_executemany</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s1">compiled_sql </span><span class="s4">= </span><span class="s1">compiled_cache</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">key</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">compiled_sql </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">cache_hit </span><span class="s4">= </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">CACHE_MISS</span>
                <span class="s1">compiled_sql </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_compiler</span><span class="s4">(</span>
                    <span class="s1">dialect</span><span class="s4">,</span>
                    <span class="s1">cache_key</span><span class="s4">=</span><span class="s1">elem_cache_key</span><span class="s4">,</span>
                    <span class="s1">column_keys</span><span class="s4">=</span><span class="s1">column_keys</span><span class="s4">,</span>
                    <span class="s1">for_executemany</span><span class="s4">=</span><span class="s1">for_executemany</span><span class="s4">,</span>
                    <span class="s1">schema_translate_map</span><span class="s4">=</span><span class="s1">schema_translate_map</span><span class="s4">,</span>
                    <span class="s4">**</span><span class="s1">kw</span><span class="s4">,</span>
                <span class="s4">)</span>
                <span class="s1">compiled_cache</span><span class="s4">[</span><span class="s1">key</span><span class="s4">] = </span><span class="s1">compiled_sql</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">cache_hit </span><span class="s4">= </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">CACHE_HIT</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">extracted_params </span><span class="s4">= </span><span class="s3">None</span>
            <span class="s1">compiled_sql </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_compiler</span><span class="s4">(</span>
                <span class="s1">dialect</span><span class="s4">,</span>
                <span class="s1">cache_key</span><span class="s4">=</span><span class="s1">elem_cache_key</span><span class="s4">,</span>
                <span class="s1">column_keys</span><span class="s4">=</span><span class="s1">column_keys</span><span class="s4">,</span>
                <span class="s1">for_executemany</span><span class="s4">=</span><span class="s1">for_executemany</span><span class="s4">,</span>
                <span class="s1">schema_translate_map</span><span class="s4">=</span><span class="s1">schema_translate_map</span><span class="s4">,</span>
                <span class="s4">**</span><span class="s1">kw</span><span class="s4">,</span>
            <span class="s4">)</span>

            <span class="s3">if not </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">_supports_statement_cache</span><span class="s4">:</span>
                <span class="s1">cache_hit </span><span class="s4">= </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">NO_DIALECT_SUPPORT</span>
            <span class="s3">elif </span><span class="s1">compiled_cache </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">cache_hit </span><span class="s4">= </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">CACHING_DISABLED</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">cache_hit </span><span class="s4">= </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">NO_CACHE_KEY</span>

        <span class="s3">return </span><span class="s1">compiled_sql</span><span class="s4">, </span><span class="s1">extracted_params</span><span class="s4">, </span><span class="s1">cache_hit</span>

    <span class="s3">def </span><span class="s1">__invert__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0"># undocumented element currently used by the ORM for</span>
        <span class="s0"># relationship.contains()</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;negation_clause&quot;</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">negation_clause</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_negate</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_negate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ClauseElement</span><span class="s4">:</span>
        <span class="s1">grouped </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">against</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">inv</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">grouped</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">UnaryExpression</span><span class="s4">(</span><span class="s1">grouped</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">inv</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__bool__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;Boolean value of this clause is not defined&quot;</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__repr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">friendly </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">description</span>
        <span class="s3">if </span><span class="s1">friendly </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">object</span><span class="s4">.</span><span class="s1">__repr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s5">&quot;&lt;%s.%s at 0x%x; %s&gt;&quot; </span><span class="s4">% (</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">__module__</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">,</span>
                <span class="s1">id</span><span class="s4">(</span><span class="s1">self</span><span class="s4">),</span>
                <span class="s1">friendly</span><span class="s4">,</span>
            <span class="s4">)</span>


<span class="s3">class </span><span class="s1">DQLDMLClauseElement</span><span class="s4">(</span><span class="s1">ClauseElement</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;represents a :class:`.ClauseElement` that compiles to a DQL or DML 
    expression, not DDL. 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">typing</span><span class="s4">.</span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s3">def </span><span class="s1">_compiler</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">: </span><span class="s1">Dialect</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; SQLCompiler</span><span class="s4">:</span>
            <span class="s2">&quot;&quot;&quot;Return a compiler appropriate for this ClauseElement, given a 
            Dialect.&quot;&quot;&quot;</span>
            <span class="s4">...</span>

        <span class="s3">def </span><span class="s1">compile</span><span class="s4">(  </span><span class="s0"># noqa: A001</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">bind</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_HasDialect</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
            <span class="s1">dialect</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Dialect</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
            <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; SQLCompiler</span><span class="s4">: ...</span>


<span class="s3">class </span><span class="s1">CompilerColumnElement</span><span class="s4">(</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">DMLColumnRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">DDLConstraintColumnRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">ColumnsClauseRole</span><span class="s4">,</span>
    <span class="s1">CompilerElement</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A compiler-only column element used for ad-hoc string compilations. 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s4">= ()</span>

    <span class="s1">_propagate_attrs </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span>
    <span class="s1">_is_collection_aggregate </span><span class="s4">= </span><span class="s3">False</span>


<span class="s0"># SQLCoreOperations should be suiting the ExpressionElementRole</span>
<span class="s0"># and ColumnsClauseRole.   however the MRO issues become too elaborate</span>
<span class="s0"># at the moment.</span>
<span class="s3">class </span><span class="s1">SQLCoreOperations</span><span class="s4">(</span><span class="s1">Generic</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">], </span><span class="s1">ColumnOperators</span><span class="s4">, </span><span class="s1">TypingOnly</span><span class="s4">):</span>
    <span class="s1">__slots__ </span><span class="s4">= ()</span>

    <span class="s0"># annotations for comparison methods</span>
    <span class="s0"># these are from operators-&gt;Operators / ColumnOperators,</span>
    <span class="s0"># redefined with the specific types returned by ColumnElement hierarchies</span>
    <span class="s3">if </span><span class="s1">typing</span><span class="s4">.</span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">non_memoized_property</span>
        <span class="s3">def </span><span class="s1">_propagate_attrs</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _PropagateAttrsType</span><span class="s4">: ...</span>

        <span class="s3">def </span><span class="s1">operate</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">op</span><span class="s4">: </span><span class="s1">OperatorType</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">reverse_operate</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">op</span><span class="s4">: </span><span class="s1">OperatorType</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">op</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">opstring</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
            <span class="s1">precedence</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= ...,</span>
            <span class="s1">is_comparison</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= ...,</span>
            <span class="s4">*,</span>
            <span class="s1">return_type</span><span class="s4">: </span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">_OPT</span><span class="s4">],</span>
            <span class="s1">python_impl</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">[[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">BinaryExpression</span><span class="s4">[</span><span class="s1">_OPT</span><span class="s4">]]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">op</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">opstring</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
            <span class="s1">precedence</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= ...,</span>
            <span class="s1">is_comparison</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= ...,</span>
            <span class="s1">return_type</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = ...,</span>
            <span class="s1">python_impl</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">]] = ...,</span>
        <span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">[[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">BinaryExpression</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]: ...</span>

        <span class="s3">def </span><span class="s1">op</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">opstring</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
            <span class="s1">precedence</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= </span><span class="s6">0</span><span class="s4">,</span>
            <span class="s1">is_comparison</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">return_type</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
            <span class="s1">python_impl</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">[[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">BinaryExpression</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]: ...</span>

        <span class="s3">def </span><span class="s1">bool_op</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">opstring</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
            <span class="s1">precedence</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= </span><span class="s6">0</span><span class="s4">,</span>
            <span class="s1">python_impl</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">[[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">BinaryExpression</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]]: ...</span>

        <span class="s3">def </span><span class="s1">__and__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; BooleanClauseList</span><span class="s4">: ...</span>

        <span class="s3">def </span><span class="s1">__or__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; BooleanClauseList</span><span class="s4">: ...</span>

        <span class="s3">def </span><span class="s1">__invert__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__lt__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__le__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s0"># declare also that this class has an hash method otherwise</span>
        <span class="s0"># it may be assumed to be None by type checkers since the</span>
        <span class="s0"># object defines __eq__ and python sets it to None in that case:</span>
        <span class="s0"># https://docs.python.org/3/reference/datamodel.html#object.__hash__</span>
        <span class="s3">def </span><span class="s1">__hash__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">: ...</span>

        <span class="s3">def </span><span class="s1">__eq__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]:  </span><span class="s0"># type: ignore[override]  # noqa: E501</span>
            <span class="s4">...</span>

        <span class="s3">def </span><span class="s1">__ne__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]:  </span><span class="s0"># type: ignore[override]  # noqa: E501</span>
            <span class="s4">...</span>

        <span class="s3">def </span><span class="s1">is_distinct_from</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">is_not_distinct_from</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__gt__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__ge__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__neg__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; UnaryExpression</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__contains__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__getitem__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">index</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__lshift__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">int</span><span class="s4">], </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__lshift__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__lshift__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__rshift__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">int</span><span class="s4">], </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__rshift__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__rshift__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">concat</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">concat</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">concat</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">like</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">escape</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>
        <span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">ilike</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">escape</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>
        <span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">bitwise_xor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">bitwise_or</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">bitwise_and</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">bitwise_not</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; UnaryExpression</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">bitwise_lshift</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">bitwise_rshift</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">in_</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">other</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
                <span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">BindParameter</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">roles</span><span class="s4">.</span><span class="s1">InElementRole</span>
            <span class="s4">],</span>
        <span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">not_in</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">other</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
                <span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">BindParameter</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">roles</span><span class="s4">.</span><span class="s1">InElementRole</span>
            <span class="s4">],</span>
        <span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">notin_</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">other</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
                <span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">BindParameter</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">roles</span><span class="s4">.</span><span class="s1">InElementRole</span>
            <span class="s4">],</span>
        <span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">not_like</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">escape</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>
        <span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">notlike</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">escape</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>
        <span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">not_ilike</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">escape</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>
        <span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">notilike</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">escape</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>
        <span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">is_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">is_not</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">isnot</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">startswith</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
            <span class="s1">escape</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
            <span class="s1">autoescape</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">istartswith</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
            <span class="s1">escape</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
            <span class="s1">autoescape</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">endswith</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
            <span class="s1">escape</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
            <span class="s1">autoescape</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">iendswith</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
            <span class="s1">escape</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
            <span class="s1">autoescape</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">contains</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">icontains</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">match</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">regexp_match</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">pattern</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">flags</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">regexp_replace</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">pattern</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">replacement</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">flags</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">desc</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; UnaryExpression</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">asc</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; UnaryExpression</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">nulls_first</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; UnaryExpression</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">nullsfirst</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; UnaryExpression</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">nulls_last</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; UnaryExpression</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">nullslast</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; UnaryExpression</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">collate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">collation</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; CollationClause</span><span class="s4">: ...</span>

        <span class="s3">def </span><span class="s1">between</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">cleft</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">cright</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">symmetric</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">distinct</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]) </span><span class="s1">-&gt; UnaryExpression</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">any_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; CollectionAggregate</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">all_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; CollectionAggregate</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s0"># numeric overloads.  These need more tweaking</span>
        <span class="s0"># in particular they all need to have a variant for Optiona[_T]</span>
        <span class="s0"># because Optional only applies to the data side, not the expression</span>
        <span class="s0"># side</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__add__</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">],</span>
            <span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__add__</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">str</span><span class="s4">],</span>
            <span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__add__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__add__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__radd__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">], </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__radd__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__radd__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__sub__</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">],</span>
            <span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__sub__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__sub__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__rsub__</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">],</span>
            <span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__rsub__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__rsub__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__mul__</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">],</span>
            <span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__mul__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__mul__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__rmul__</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">],</span>
            <span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__rmul__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__rmul__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__mod__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">], </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__mod__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__mod__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__rmod__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">], </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__rmod__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__rmod__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__truediv__</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">int</span><span class="s4">], </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_NUMERIC</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__truediv__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">_NT</span><span class="s4">], </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_NT</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__truediv__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__truediv__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__rtruediv__</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">], </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_NUMERIC</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__rtruediv__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__rtruediv__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__floordiv__</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">], </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__floordiv__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__floordiv__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__rfloordiv__</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">: </span><span class="s1">_SQO</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">], </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span>
        <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_NMT</span><span class="s4">]: ...</span>

        <span class="s4">@</span><span class="s1">overload</span>
        <span class="s3">def </span><span class="s1">__rfloordiv__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

        <span class="s3">def </span><span class="s1">__rfloordiv__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>


<span class="s3">class </span><span class="s1">SQLColumnExpression</span><span class="s4">(</span>
    <span class="s1">SQLCoreOperations</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">], </span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">[</span><span class="s1">_T_co</span><span class="s4">], </span><span class="s1">TypingOnly</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A type that may be used to indicate any SQL column element or object 
    that acts in place of one. 
 
    :class:`.SQLColumnExpression` is a base of 
    :class:`.ColumnElement`, as well as within the bases of ORM elements 
    such as :class:`.InstrumentedAttribute`, and may be used in :pep:`484` 
    typing to indicate arguments or return values that should behave 
    as column expressions. 
 
    .. versionadded:: 2.0.0b4 
 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s4">= ()</span>


<span class="s1">_SQO </span><span class="s4">= </span><span class="s1">SQLCoreOperations</span>


<span class="s3">class </span><span class="s1">ColumnElement</span><span class="s4">(</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">ColumnArgumentOrKeyRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">StatementOptionRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">WhereHavingRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">BinaryElementRole</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">OrderByRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">ColumnsClauseRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">LimitOffsetRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">DMLColumnRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">DDLConstraintColumnRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">DDLExpressionRole</span><span class="s4">,</span>
    <span class="s1">SQLColumnExpression</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
    <span class="s1">DQLDMLClauseElement</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represent a column-oriented SQL expression suitable for usage in the 
    &quot;columns&quot; clause, WHERE clause etc. of a statement. 
 
    While the most familiar kind of :class:`_expression.ColumnElement` is the 
    :class:`_schema.Column` object, :class:`_expression.ColumnElement` 
    serves as the basis 
    for any unit that may be present in a SQL expression, including 
    the expressions themselves, SQL functions, bound parameters, 
    literal expressions, keywords such as ``NULL``, etc. 
    :class:`_expression.ColumnElement` 
    is the ultimate base class for all such elements. 
 
    A wide variety of SQLAlchemy Core functions work at the SQL expression 
    level, and are intended to accept instances of 
    :class:`_expression.ColumnElement` as 
    arguments.  These functions will typically document that they accept a 
    &quot;SQL expression&quot; as an argument.  What this means in terms of SQLAlchemy 
    usually refers to an input which is either already in the form of a 
    :class:`_expression.ColumnElement` object, 
    or a value which can be **coerced** into 
    one.  The coercion rules followed by most, but not all, SQLAlchemy Core 
    functions with regards to SQL expressions are as follows: 
 
        * a literal Python value, such as a string, integer or floating 
          point value, boolean, datetime, ``Decimal`` object, or virtually 
          any other Python object, will be coerced into a &quot;literal bound 
          value&quot;.  This generally means that a :func:`.bindparam` will be 
          produced featuring the given value embedded into the construct; the 
          resulting :class:`.BindParameter` object is an instance of 
          :class:`_expression.ColumnElement`. 
          The Python value will ultimately be sent 
          to the DBAPI at execution time as a parameterized argument to the 
          ``execute()`` or ``executemany()`` methods, after SQLAlchemy 
          type-specific converters (e.g. those provided by any associated 
          :class:`.TypeEngine` objects) are applied to the value. 
 
        * any special object value, typically ORM-level constructs, which 
          feature an accessor called ``__clause_element__()``.  The Core 
          expression system looks for this method when an object of otherwise 
          unknown type is passed to a function that is looking to coerce the 
          argument into a :class:`_expression.ColumnElement` and sometimes a 
          :class:`_expression.SelectBase` expression. 
          It is used within the ORM to 
          convert from ORM-specific objects like mapped classes and 
          mapped attributes into Core expression objects. 
 
        * The Python ``None`` value is typically interpreted as ``NULL``, 
          which in SQLAlchemy Core produces an instance of :func:`.null`. 
 
    A :class:`_expression.ColumnElement` provides the ability to generate new 
    :class:`_expression.ColumnElement` 
    objects using Python expressions.  This means that Python operators 
    such as ``==``, ``!=`` and ``&lt;`` are overloaded to mimic SQL operations, 
    and allow the instantiation of further :class:`_expression.ColumnElement` 
    instances 
    which are composed from other, more fundamental 
    :class:`_expression.ColumnElement` 
    objects.  For example, two :class:`.ColumnClause` objects can be added 
    together with the addition operator ``+`` to produce 
    a :class:`.BinaryExpression`. 
    Both :class:`.ColumnClause` and :class:`.BinaryExpression` are subclasses 
    of :class:`_expression.ColumnElement`: 
 
    .. sourcecode:: pycon+sql 
 
        &gt;&gt;&gt; from sqlalchemy.sql import column 
        &gt;&gt;&gt; column('a') + column('b') 
        &lt;sqlalchemy.sql.expression.BinaryExpression object at 0x101029dd0&gt; 
        &gt;&gt;&gt; print(column('a') + column('b')) 
        {printsql}a + b 
 
    .. seealso:: 
 
        :class:`_schema.Column` 
 
        :func:`_expression.column` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;column_element&quot;</span>

    <span class="s1">primary_key</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_clone_of</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]</span>
    <span class="s1">_is_column_element </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">_insert_sentinel</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_omit_from_statements </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_collection_aggregate </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s1">foreign_keys</span><span class="s4">: </span><span class="s1">AbstractSet</span><span class="s4">[</span><span class="s1">ForeignKey</span><span class="s4">] = </span><span class="s1">frozenset</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_proxies</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">return </span><span class="s4">[]</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_tq_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;The named label that can be used to target 
        this column in a result set in a &quot;table qualified&quot; context. 
 
        This label is almost always the label used when 
        rendering &lt;expr&gt; AS &lt;label&gt; in a SELECT statement when using 
        the LABEL_STYLE_TABLENAME_PLUS_COL label style, which is what the 
        legacy ORM ``Query`` object uses as well. 
 
        For a regular Column bound to a Table, this is typically the label 
        &lt;tablename&gt;_&lt;columnname&gt;.  For other constructs, different rules 
        may apply, such as anonymized labels and others. 
 
        .. versionchanged:: 1.4.21 renamed from ``._label`` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return None</span>

    <span class="s1">key</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s5">&quot;&quot;&quot;The 'key' that in some circumstances refers to this object in a 
    Python namespace. 
 
    This typically refers to the &quot;key&quot; of the column as present in the 
    ``.c`` collection of a selectable, e.g. ``sometable.c[&quot;somekey&quot;]`` would 
    return a :class:`_schema.Column` with a ``.key`` of &quot;somekey&quot;. 
 
    &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">HasMemoized</span><span class="s4">.</span><span class="s1">memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_tq_key_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;A label-based version of 'key' that in some circumstances refers 
        to this object in a Python namespace. 
 
 
        _tq_key_label comes into play when a select() statement is constructed 
        with apply_labels(); in this case, all Column objects in the ``.c`` 
        collection are rendered as &lt;tablename&gt;_&lt;columnname&gt; in SQL; this is 
        essentially the value of ._label. But to locate those columns in the 
        ``.c`` collection, the name is along the lines of &lt;tablename&gt;_&lt;key&gt;; 
        that's the typical value of .key_label. 
 
        .. versionchanged:: 1.4.21 renamed from ``._key_label`` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_proxy_key</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_key_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;legacy; renamed to _tq_key_label&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tq_key_label</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;legacy; renamed to _tq_label&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tq_label</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_non_anon_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;the 'name' that naturally applies this element when rendered in 
        SQL. 
 
        Concretely, this is the &quot;name&quot; of a column or a label in a 
        SELECT statement; ``&lt;columnname&gt;`` and ``&lt;labelname&gt;`` below:: 
 
            SELECT &lt;columnmame&gt; FROM table 
 
            SELECT column AS &lt;labelname&gt; FROM table 
 
        Above, the two names noted will be what's present in the DBAPI 
        ``cursor.description`` as the names. 
 
        If this attribute returns ``None``, it means that the SQL element as 
        written does not have a 100% fully predictable &quot;name&quot; that would appear 
        in the ``cursor.description``. Examples include SQL functions, CAST 
        functions, etc. While such things do return names in 
        ``cursor.description``, they are only predictable on a 
        database-specific basis; e.g. an expression like ``MAX(table.col)`` may 
        appear as the string ``max`` on one database (like PostgreSQL) or may 
        appear as the whole expression ``max(table.col)`` on SQLite. 
 
        The default implementation looks for a ``.name`` attribute on the 
        object, as has been the precedent established in SQLAlchemy for many 
        years.  An exception is made on the ``FunctionElement`` subclass 
        so that the return value is always ``None``. 
 
        .. versionadded:: 1.4.21 
 
 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>

    <span class="s1">_render_label_in_columns_clause </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s5">&quot;&quot;&quot;A flag used by select._columns_plus_names that helps to determine 
    we are actually going to render in terms of &quot;SELECT &lt;col&gt; AS &lt;label&gt;&quot;. 
    This flag can be returned as False for some Column objects that want 
    to be rendered as simple &quot;SELECT &lt;col&gt;&quot;; typically columns that don't have 
    any parent table and are named the same as what the label would be 
    in any case. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_allow_label_resolve </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s5">&quot;&quot;&quot;A flag that can be flipped to prevent a column from being resolvable 
    by string label name. 
 
    The joined eager loader strategy in the ORM uses this, for example. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_is_implicitly_boolean </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s1">_alt_names</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = ()</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s3">None </span><span class="s4">= </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">against </span><span class="s3">in </span><span class="s4">(</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">and_</span><span class="s4">, </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">or_</span><span class="s4">, </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">_asbool</span><span class="s4">)</span>
            <span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">_type_affinity </span><span class="s3">is </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">BOOLEANTYPE</span><span class="s4">.</span><span class="s1">_type_affinity</span>
        <span class="s4">):</span>
            <span class="s3">return </span><span class="s1">AsBoolean</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_true</span><span class="s4">, </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_false</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">against </span><span class="s3">in </span><span class="s4">(</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">any_op</span><span class="s4">, </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">all_op</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">Grouping</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">_negate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">_negate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">_negate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">_type_affinity </span><span class="s3">is </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">BOOLEANTYPE</span><span class="s4">.</span><span class="s1">_type_affinity</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">AsBoolean</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_false</span><span class="s4">, </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_true</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">grouped </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">against</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">inv</span><span class="s4">)</span>
            <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">grouped</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">UnaryExpression</span><span class="s4">(</span>
                <span class="s1">grouped</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">inv</span><span class="s4">, </span><span class="s1">wraps_column_expression</span><span class="s4">=</span><span class="s3">True</span>
            <span class="s4">)</span>

    <span class="s1">type</span><span class="s4">: </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>

    <span class="s3">if not </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
        <span class="s3">def </span><span class="s1">type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:  </span><span class="s0"># noqa: A001</span>
            <span class="s0"># used for delayed setup of</span>
            <span class="s0"># type_api</span>
            <span class="s3">return </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">NULLTYPE</span>

    <span class="s4">@</span><span class="s1">HasMemoized</span><span class="s4">.</span><span class="s1">memoized_attribute</span>
    <span class="s3">def </span><span class="s1">comparator</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">comparator_factory </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">comparator_factory</span>
        <span class="s3">except </span><span class="s1">AttributeError </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span>
                <span class="s5">&quot;Object %r associated with '.type' attribute &quot;</span>
                <span class="s5">&quot;is not a TypeEngine class or object&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span>
            <span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">comparator_factory</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__setstate__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__getattr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">comparator</span><span class="s4">, </span><span class="s1">key</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">AttributeError </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span>
                <span class="s5">&quot;Neither %r object nor %r object has an attribute %r&quot;</span>
                <span class="s4">% (</span>
                    <span class="s1">type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">).</span><span class="s1">__name__</span><span class="s4">,</span>
                    <span class="s1">type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">comparator</span><span class="s4">).</span><span class="s1">__name__</span><span class="s4">,</span>
                    <span class="s1">key</span><span class="s4">,</span>
                <span class="s4">)</span>
            <span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>

    <span class="s3">def </span><span class="s1">operate</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">op</span><span class="s4">: </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">OperatorType</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">op</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">comparator</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)  </span><span class="s0"># type: ignore[no-any-return]  # noqa: E501</span>

    <span class="s3">def </span><span class="s1">reverse_operate</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">op</span><span class="s4">: </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">OperatorType</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">op</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">comparator</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)  </span><span class="s0"># type: ignore[no-any-return]  # noqa: E501</span>

    <span class="s3">def </span><span class="s1">_bind_param</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">operator</span><span class="s4">: </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">OperatorType</span><span class="s4">,</span>
        <span class="s1">obj</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s1">type_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">expanding</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; BindParameter</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">BindParameter</span><span class="s4">(</span>
            <span class="s3">None</span><span class="s4">,</span>
            <span class="s1">obj</span><span class="s4">,</span>
            <span class="s1">_compared_to_operator</span><span class="s4">=</span><span class="s1">operator</span><span class="s4">,</span>
            <span class="s1">type_</span><span class="s4">=</span><span class="s1">type_</span><span class="s4">,</span>
            <span class="s1">_compared_to_type</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">,</span>
            <span class="s1">unique</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s1">expanding</span><span class="s4">=</span><span class="s1">expanding</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">expression</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a column expression. 
 
        Part of the inspection interface; returns self. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_select_iterable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _SelectIterable</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">self</span><span class="s4">,)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">base_columns</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; FrozenSet</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">return </span><span class="s1">frozenset</span><span class="s4">(</span><span class="s1">c </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">proxy_set </span><span class="s3">if not </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_proxies</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">proxy_set</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; FrozenSet</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;set of all columns we are proxying 
 
        as of 2.0 this is explicitly deannotated columns.  previously it was 
        effectively deannotated columns but wasn't enforced.  annotated 
        columns should basically not go into sets if at all possible because 
        their hashing behavior is very non-performant. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">frozenset</span><span class="s4">([</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_deannotate</span><span class="s4">()]).</span><span class="s1">union</span><span class="s4">(</span>
            <span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(*[</span><span class="s1">c</span><span class="s4">.</span><span class="s1">proxy_set </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_proxies</span><span class="s4">])</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_expanded_proxy_set</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; FrozenSet</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">return </span><span class="s1">frozenset</span><span class="s4">(</span><span class="s1">_expand_cloned</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">proxy_set</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">_uncached_proxy_list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;An 'uncached' version of proxy set. 
 
        This list includes annotated columns which perform very poorly in 
        set operations. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s4">[</span><span class="s1">self</span><span class="s4">] + </span><span class="s1">list</span><span class="s4">(</span>
            <span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(*[</span><span class="s1">c</span><span class="s4">.</span><span class="s1">_uncached_proxy_list</span><span class="s4">() </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_proxies</span><span class="s4">])</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">shares_lineage</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">othercolumn</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return True if the given :class:`_expression.ColumnElement` 
        has a common ancestor to this :class:`_expression.ColumnElement`.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">bool</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">proxy_set</span><span class="s4">.</span><span class="s1">intersection</span><span class="s4">(</span><span class="s1">othercolumn</span><span class="s4">.</span><span class="s1">proxy_set</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">_compare_name_for_result</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return True if the given column element compares to this one 
        when targeting within a result row.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">hasattr</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s5">&quot;name&quot;</span><span class="s4">)</span>
            <span class="s3">and </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;name&quot;</span><span class="s4">)</span>
            <span class="s3">and </span><span class="s1">other</span><span class="s4">.</span><span class="s1">name </span><span class="s4">== </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">HasMemoized</span><span class="s4">.</span><span class="s1">memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_proxy_key</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_annotations </span><span class="s3">and </span><span class="s5">&quot;proxy_key&quot; </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_annotations</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">cast</span><span class="s4">(</span><span class="s1">str</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_annotations</span><span class="s4">[</span><span class="s5">&quot;proxy_key&quot;</span><span class="s4">])</span>

        <span class="s1">name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">key</span>
        <span class="s3">if not </span><span class="s1">name</span><span class="s4">:</span>
            <span class="s0"># there's a bit of a seeming contradiction which is that the</span>
            <span class="s0"># &quot;_non_anon_label&quot; of a column can in fact be an</span>
            <span class="s0"># &quot;_anonymous_label&quot;; this is when it's on a column that is</span>
            <span class="s0"># proxying for an anonymous expression in a subquery.</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_non_anon_label</span>

        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">_anonymous_label</span><span class="s4">):</span>
            <span class="s3">return None</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">name</span>

    <span class="s4">@</span><span class="s1">HasMemoized</span><span class="s4">.</span><span class="s1">memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_expression_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;a suggested label to use in the case that the column has no name, 
        which should be used if possible as the explicit 'AS &lt;label&gt;' 
        where this expression would normally have an anon label. 
 
        this is essentially mostly what _proxy_key does except it returns 
        None if the column has a normal name that can be used. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">return None</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_annotations </span><span class="s3">and </span><span class="s5">&quot;proxy_key&quot; </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_annotations</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">cast</span><span class="s4">(</span><span class="s1">str</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_annotations</span><span class="s4">[</span><span class="s5">&quot;proxy_key&quot;</span><span class="s4">])</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">_make_proxy</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">selectable</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">key</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">name_is_truncatable</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">compound_select_cols</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; typing_Tuple</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;Create a new :class:`_expression.ColumnElement` representing this 
        :class:`_expression.ColumnElement` as it appears in the select list of 
        a descending selectable. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_anon_name_label</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">key </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_proxy_key</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">key </span><span class="s4">= </span><span class="s1">name</span>

        <span class="s3">assert </span><span class="s1">key </span><span class="s3">is not None</span>

        <span class="s1">co</span><span class="s4">: </span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">] = </span><span class="s1">ColumnClause</span><span class="s4">(</span>
            <span class="s4">(</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">TruncatedLabelRole</span><span class="s4">, </span><span class="s1">name</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">name_is_truncatable</span>
                <span class="s3">else </span><span class="s1">name</span>
            <span class="s4">),</span>
            <span class="s1">type_</span><span class="s4">=</span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;type&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">),</span>
            <span class="s1">_selectable</span><span class="s4">=</span><span class="s1">selectable</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s1">co</span><span class="s4">.</span><span class="s1">_propagate_attrs </span><span class="s4">= </span><span class="s1">selectable</span><span class="s4">.</span><span class="s1">_propagate_attrs</span>
        <span class="s3">if </span><span class="s1">compound_select_cols</span><span class="s4">:</span>
            <span class="s1">co</span><span class="s4">.</span><span class="s1">_proxies </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">compound_select_cols</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">co</span><span class="s4">.</span><span class="s1">_proxies </span><span class="s4">= [</span><span class="s1">self</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">selectable</span><span class="s4">.</span><span class="s1">_is_clone_of </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">co</span><span class="s4">.</span><span class="s1">_is_clone_of </span><span class="s4">= </span><span class="s1">selectable</span><span class="s4">.</span><span class="s1">_is_clone_of</span><span class="s4">.</span><span class="s1">columns</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">key</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">key</span><span class="s4">, </span><span class="s1">co</span>

    <span class="s3">def </span><span class="s1">cast</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">: </span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">_OPT</span><span class="s4">]) </span><span class="s1">-&gt; Cast</span><span class="s4">[</span><span class="s1">_OPT</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Produce a type cast, i.e. ``CAST(&lt;expression&gt; AS &lt;type&gt;)``. 
 
        This is a shortcut to the :func:`_expression.cast` function. 
 
        .. seealso:: 
 
            :ref:`tutorial_casts` 
 
            :func:`_expression.cast` 
 
            :func:`_expression.type_coerce` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Cast</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]) </span><span class="s1">-&gt; Label</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Produce a column label, i.e. ``&lt;columnname&gt; AS &lt;name&gt;``. 
 
        This is a shortcut to the :func:`_expression.label` function. 
 
        If 'name' is ``None``, an anonymous label name will be generated. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Label</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_anon_label</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">seed</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], </span><span class="s1">add_hash</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; _anonymous_label</span><span class="s4">:</span>
        <span class="s3">while </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_clone_of </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_clone_of</span>

        <span class="s0"># as of 1.4 anonymous label for ColumnElement uses hash(), not id(),</span>
        <span class="s0"># as the identifier, because a column and its annotated version are</span>
        <span class="s0"># the same thing in a SQL statement</span>
        <span class="s1">hash_value </span><span class="s4">= </span><span class="s1">hash</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">add_hash</span><span class="s4">:</span>
            <span class="s0"># this path is used for disambiguating anon labels that would</span>
            <span class="s0"># otherwise be the same name for the same element repeated.</span>
            <span class="s0"># an additional numeric value is factored in for each label.</span>

            <span class="s0"># shift hash(self) (which is id(self), typically 8 byte integer)</span>
            <span class="s0"># 16 bits leftward.  fill extra add_hash on right</span>
            <span class="s3">assert </span><span class="s1">add_hash </span><span class="s4">&lt; (</span><span class="s6">2 </span><span class="s4">&lt;&lt; </span><span class="s6">15</span><span class="s4">)</span>
            <span class="s3">assert </span><span class="s1">seed</span>
            <span class="s1">hash_value </span><span class="s4">= (</span><span class="s1">hash_value </span><span class="s4">&lt;&lt; </span><span class="s6">16</span><span class="s4">) | </span><span class="s1">add_hash</span>

            <span class="s0"># extra underscore is added for labels with extra hash</span>
            <span class="s0"># values, to isolate the &quot;deduped anon&quot; namespace from the</span>
            <span class="s0"># regular namespace.  eliminates chance of these</span>
            <span class="s0"># manufactured hash values overlapping with regular ones for some</span>
            <span class="s0"># undefined python interpreter</span>
            <span class="s1">seed </span><span class="s4">= </span><span class="s1">seed </span><span class="s4">+ </span><span class="s5">&quot;_&quot;</span>

        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">seed</span><span class="s4">, </span><span class="s1">_anonymous_label</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">_anonymous_label</span><span class="s4">.</span><span class="s1">safe_construct</span><span class="s4">(</span>
                <span class="s1">hash_value</span><span class="s4">, </span><span class="s5">&quot;&quot;</span><span class="s4">, </span><span class="s1">enclosing_label</span><span class="s4">=</span><span class="s1">seed</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">_anonymous_label</span><span class="s4">.</span><span class="s1">safe_construct</span><span class="s4">(</span><span class="s1">hash_value</span><span class="s4">, </span><span class="s1">seed </span><span class="s3">or </span><span class="s5">&quot;anon&quot;</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_anon_name_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Provides a constant 'anonymous label' for this ColumnElement. 
 
        This is a label() expression which will be named at compile time. 
        The same label() is returned each time ``anon_label`` is called so 
        that expressions can reference ``anon_label`` multiple times, 
        producing the same label name at compile time. 
 
        The compiler uses this function automatically at compile time 
        for expressions that are known to be 'unnamed' like binary 
        expressions and function calls. 
 
        .. versionchanged:: 1.4.9 - this attribute was not intended to be 
           public and is renamed to _anon_name_label.  anon_name exists 
           for backwards compat 
 
        &quot;&quot;&quot;</span>
        <span class="s1">name </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_anon_label</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_anon_key_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _anonymous_label</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Provides a constant 'anonymous key label' for this ColumnElement. 
 
        Compare to ``anon_label``, except that the &quot;key&quot; of the column, 
        if available, is used to generate the label. 
 
        This is used when a deduplicating key is placed into the columns 
        collection of a selectable. 
 
        .. versionchanged:: 1.4.9 - this attribute was not intended to be 
           public and is renamed to _anon_key_label.  anon_key_label exists 
           for backwards compat 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_anon_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_proxy_key</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">deprecated</span><span class="s4">(</span>
        <span class="s5">&quot;1.4&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;The :attr:`_expression.ColumnElement.anon_label` attribute is now &quot;</span>
        <span class="s5">&quot;private, and the public accessor is deprecated.&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">anon_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_anon_name_label</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">deprecated</span><span class="s4">(</span>
        <span class="s5">&quot;1.4&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;The :attr:`_expression.ColumnElement.anon_key_label` attribute is &quot;</span>
        <span class="s5">&quot;now private, and the public accessor is deprecated.&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">anon_key_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_anon_key_label</span>

    <span class="s3">def </span><span class="s1">_dedupe_anon_label_idx</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">: </span><span class="s1">int</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;label to apply to a column that is anon labeled, but repeated 
        in the SELECT, so that we have to make an &quot;extra anon&quot; label that 
        disambiguates it from the previous appearance. 
 
        these labels come out like &quot;foo_bar_id__1&quot; and have double underscores 
        in them. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">label </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>

        <span class="s0"># current convention is that if the element doesn't have a</span>
        <span class="s0"># &quot;.name&quot; (usually because it is not NamedColumn), we try to</span>
        <span class="s0"># use a &quot;table qualified&quot; form for the &quot;dedupe anon&quot; label,</span>
        <span class="s0"># based on the notion that a label like</span>
        <span class="s0"># &quot;CAST(casttest.v1 AS DECIMAL) AS casttest_v1__1&quot; looks better than</span>
        <span class="s0"># &quot;CAST(casttest.v1 AS DECIMAL) AS anon__1&quot;</span>

        <span class="s3">if </span><span class="s1">label </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dedupe_anon_tq_label_idx</span><span class="s4">(</span><span class="s1">idx</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_anon_label</span><span class="s4">(</span><span class="s1">label</span><span class="s4">, </span><span class="s1">add_hash</span><span class="s4">=</span><span class="s1">idx</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_anon_tq_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _anonymous_label</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_anon_label</span><span class="s4">(</span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;_tq_label&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">))</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_anon_tq_key_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _anonymous_label</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_anon_label</span><span class="s4">(</span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;_tq_key_label&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">_dedupe_anon_tq_label_idx</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">: </span><span class="s1">int</span><span class="s4">) </span><span class="s1">-&gt; _anonymous_label</span><span class="s4">:</span>
        <span class="s1">label </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;_tq_label&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">or </span><span class="s5">&quot;anon&quot;</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_anon_label</span><span class="s4">(</span><span class="s1">label</span><span class="s4">, </span><span class="s1">add_hash</span><span class="s4">=</span><span class="s1">idx</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">KeyedColumnElement</span><span class="s4">(</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;ColumnElement where ``.key`` is non-None.&quot;&quot;&quot;</span>

    <span class="s1">_is_keyed_column_element </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">key</span><span class="s4">: </span><span class="s1">str</span>


<span class="s3">class </span><span class="s1">WrapsColumnExpression</span><span class="s4">(</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Mixin that defines a :class:`_expression.ColumnElement` 
    as a wrapper with special 
    labeling behavior for an expression that already has a name. 
 
    .. versionadded:: 1.4 
 
    .. seealso:: 
 
        :ref:`change_4449` 
 
 
    &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">wrapped_column_expression</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_tq_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s1">wce </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">wrapped_column_expression</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">wce</span><span class="s4">, </span><span class="s5">&quot;_tq_label&quot;</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">wce</span><span class="s4">.</span><span class="s1">_tq_label</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return None</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tq_label</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_non_anon_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s3">return None</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_anon_name_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s1">wce </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">wrapped_column_expression</span>

        <span class="s0"># this logic tries to get the WrappedColumnExpression to render</span>
        <span class="s0"># with &quot;&lt;expr&gt; AS &lt;name&gt;&quot;, where &quot;&lt;name&gt;&quot; is the natural name</span>
        <span class="s0"># within the expression itself.   e.g. &quot;CAST(table.foo) AS foo&quot;.</span>
        <span class="s3">if not </span><span class="s1">wce</span><span class="s4">.</span><span class="s1">_is_text_clause</span><span class="s4">:</span>
            <span class="s1">nal </span><span class="s4">= </span><span class="s1">wce</span><span class="s4">.</span><span class="s1">_non_anon_label</span>
            <span class="s3">if </span><span class="s1">nal</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">nal</span>
            <span class="s3">elif </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">wce</span><span class="s4">, </span><span class="s5">&quot;_anon_name_label&quot;</span><span class="s4">):</span>
                <span class="s3">return </span><span class="s1">wce</span><span class="s4">.</span><span class="s1">_anon_name_label</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">_anon_name_label</span>

    <span class="s3">def </span><span class="s1">_dedupe_anon_label_idx</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">: </span><span class="s1">int</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s1">wce </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">wrapped_column_expression</span>
        <span class="s1">nal </span><span class="s4">= </span><span class="s1">wce</span><span class="s4">.</span><span class="s1">_non_anon_label</span>
        <span class="s3">if </span><span class="s1">nal</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_anon_label</span><span class="s4">(</span><span class="s1">nal </span><span class="s4">+ </span><span class="s5">&quot;_&quot;</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_dedupe_anon_tq_label_idx</span><span class="s4">(</span><span class="s1">idx</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_proxy_key</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s1">wce </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">wrapped_column_expression</span>

        <span class="s3">if not </span><span class="s1">wce</span><span class="s4">.</span><span class="s1">_is_text_clause</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">wce</span><span class="s4">.</span><span class="s1">_proxy_key</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">_proxy_key</span>


<span class="s3">class </span><span class="s1">BindParameter</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">InElementRole</span><span class="s4">, </span><span class="s1">KeyedColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">r&quot;&quot;&quot;Represent a &quot;bound expression&quot;. 
 
    :class:`.BindParameter` is invoked explicitly using the 
    :func:`.bindparam` function, as in:: 
 
        from sqlalchemy import bindparam 
 
        stmt = select(users_table).where( 
            users_table.c.name == bindparam(&quot;username&quot;) 
        ) 
 
    Detailed discussion of how :class:`.BindParameter` is used is 
    at :func:`.bindparam`. 
 
    .. seealso:: 
 
        :func:`.bindparam` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;bindparam&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;key&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_anon_name</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;type&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_type</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;callable&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_plain_dict</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;value&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_plain_obj</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;literal_execute&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_boolean</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">key</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">type</span><span class="s4">: </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
    <span class="s1">value</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>

    <span class="s1">_is_crud </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_is_bind_parameter </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">_key_is_anon </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s0"># bindparam implements its own _gen_cache_key() method however</span>
    <span class="s0"># we check subclasses for this flag, else no cache key is generated</span>
    <span class="s1">inherit_cache </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">key</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">],</span>
        <span class="s1">value</span><span class="s4">: </span><span class="s1">Any </span><span class="s4">= </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">,</span>
        <span class="s1">type_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">unique</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">required</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">, </span><span class="s1">Literal</span><span class="s4">[</span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">]] = </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">,</span>
        <span class="s1">quote</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">callable_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Callable</span><span class="s4">[[], </span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">expanding</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">isoutparam</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">literal_execute</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">_compared_to_operator</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_compared_to_type</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_is_crud</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s3">if </span><span class="s1">required </span><span class="s3">is </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">:</span>
            <span class="s1">required </span><span class="s4">= </span><span class="s1">value </span><span class="s3">is </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG </span><span class="s3">and </span><span class="s1">callable_ </span><span class="s3">is None</span>
        <span class="s3">if </span><span class="s1">value </span><span class="s3">is </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">:</span>
            <span class="s1">value </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">quote </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">key </span><span class="s4">= </span><span class="s1">quoted_name</span><span class="s4">.</span><span class="s1">construct</span><span class="s4">(</span><span class="s1">key</span><span class="s4">, </span><span class="s1">quote</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">unique</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">key </span><span class="s4">= </span><span class="s1">_anonymous_label</span><span class="s4">.</span><span class="s1">safe_construct</span><span class="s4">(</span>
                <span class="s1">id</span><span class="s4">(</span><span class="s1">self</span><span class="s4">),</span>
                <span class="s4">(</span>
                    <span class="s1">key</span>
                    <span class="s3">if </span><span class="s1">key </span><span class="s3">is not None</span>
                    <span class="s3">and not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">key</span><span class="s4">, </span><span class="s1">_anonymous_label</span><span class="s4">)</span>
                    <span class="s3">else </span><span class="s5">&quot;param&quot;</span>
                <span class="s4">),</span>
                <span class="s1">sanitize_key</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_key_is_anon </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s3">elif </span><span class="s1">key</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">key </span><span class="s4">= </span><span class="s1">key</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">key </span><span class="s4">= </span><span class="s1">_anonymous_label</span><span class="s4">.</span><span class="s1">safe_construct</span><span class="s4">(</span><span class="s1">id</span><span class="s4">(</span><span class="s1">self</span><span class="s4">), </span><span class="s5">&quot;param&quot;</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_key_is_anon </span><span class="s4">= </span><span class="s3">True</span>

        <span class="s0"># identifying key that won't change across</span>
        <span class="s0"># clones, used to identify the bind's logical</span>
        <span class="s0"># identity</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_identifying_key </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">key</span>

        <span class="s0"># key that was passed in the first place, used to</span>
        <span class="s0"># generate new keys</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_orig_key </span><span class="s4">= </span><span class="s1">key </span><span class="s3">or </span><span class="s5">&quot;param&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">unique </span><span class="s4">= </span><span class="s1">unique</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">value </span><span class="s4">= </span><span class="s1">value</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">callable </span><span class="s4">= </span><span class="s1">callable_</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">isoutparam </span><span class="s4">= </span><span class="s1">isoutparam</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">required </span><span class="s4">= </span><span class="s1">required</span>

        <span class="s0"># indicate an &quot;expanding&quot; parameter; the compiler sets this</span>
        <span class="s0"># automatically in the compiler _render_in_expr_w_bindparam method</span>
        <span class="s0"># for an IN expression</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">expanding </span><span class="s4">= </span><span class="s1">expanding</span>

        <span class="s0"># this is another hint to help w/ expanding and is typically</span>
        <span class="s0"># set in the compiler _render_in_expr_w_bindparam method for an</span>
        <span class="s0"># IN expression</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">expand_op </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">literal_execute </span><span class="s4">= </span><span class="s1">literal_execute</span>
        <span class="s3">if </span><span class="s1">_is_crud</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_is_crud </span><span class="s4">= </span><span class="s3">True</span>

        <span class="s3">if </span><span class="s1">type_ </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">expanding</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">value</span><span class="s4">:</span>
                    <span class="s1">check_value </span><span class="s4">= </span><span class="s1">value</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">check_value </span><span class="s4">= </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">_NO_VALUE_IN_LIST</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">check_value </span><span class="s4">= </span><span class="s1">value</span>
            <span class="s3">if </span><span class="s1">_compared_to_type </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">_compared_to_type</span><span class="s4">.</span><span class="s1">coerce_compared_value</span><span class="s4">(</span>
                    <span class="s1">_compared_to_operator</span><span class="s4">, </span><span class="s1">check_value</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">_resolve_value_to_type</span><span class="s4">(</span><span class="s1">check_value</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">, </span><span class="s1">type</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_</span><span class="s4">()</span>
        <span class="s3">elif </span><span class="s1">is_tuple_type</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">value</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">expanding</span><span class="s4">:</span>
                    <span class="s1">check_value </span><span class="s4">= </span><span class="s1">value</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">check_value </span><span class="s4">= </span><span class="s1">value</span>
                <span class="s1">cast</span><span class="s4">(</span><span class="s5">&quot;BindParameter[typing_Tuple[Any, ...]]&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">).</span><span class="s1">type </span><span class="s4">= (</span>
                    <span class="s1">type_</span><span class="s4">.</span><span class="s1">_resolve_values_to_types</span><span class="s4">(</span><span class="s1">check_value</span><span class="s4">)</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">cast</span><span class="s4">(</span><span class="s5">&quot;BindParameter[typing_Tuple[Any, ...]]&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">).</span><span class="s1">type </span><span class="s4">= (</span>
                    <span class="s1">type_</span>
                <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_</span>

    <span class="s3">def </span><span class="s1">_with_value</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">, </span><span class="s1">maintain_key</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">required</span><span class="s4">=</span><span class="s1">NO_ARG</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Return a copy of this :class:`.BindParameter` with the given value 
        set. 
        &quot;&quot;&quot;</span>
        <span class="s1">cloned </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_clone</span><span class="s4">(</span><span class="s1">maintain_key</span><span class="s4">=</span><span class="s1">maintain_key</span><span class="s4">)</span>
        <span class="s1">cloned</span><span class="s4">.</span><span class="s1">value </span><span class="s4">= </span><span class="s1">value</span>
        <span class="s1">cloned</span><span class="s4">.</span><span class="s1">callable </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">cloned</span><span class="s4">.</span><span class="s1">required </span><span class="s4">= </span><span class="s1">required </span><span class="s3">if </span><span class="s1">required </span><span class="s3">is not </span><span class="s1">NO_ARG </span><span class="s3">else </span><span class="s1">self</span><span class="s4">.</span><span class="s1">required</span>
        <span class="s3">if </span><span class="s1">cloned</span><span class="s4">.</span><span class="s1">type </span><span class="s3">is </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">NULLTYPE</span><span class="s4">:</span>
            <span class="s1">cloned</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">_resolve_value_to_type</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">cloned</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">effective_value</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the value of this bound parameter, 
        taking into account if the ``callable`` parameter 
        was set. 
 
        The ``callable`` value will be evaluated 
        and returned if present, else ``value``. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">callable</span><span class="s4">:</span>
            <span class="s0"># TODO: set up protocol for bind parameter callable</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">callable</span><span class="s4">()  </span><span class="s0"># type: ignore</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">render_literal_execute</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; BindParameter</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Produce a copy of this bound parameter that will enable the 
        :paramref:`_sql.BindParameter.literal_execute` flag. 
 
        The :paramref:`_sql.BindParameter.literal_execute` flag will 
        have the effect of the parameter rendered in the compiled SQL 
        string using ``[POSTCOMPILE]`` form, which is a special form that 
        is converted to be a rendering of the literal value of the parameter 
        at SQL execution time.    The rationale is to support caching 
        of SQL statement strings that can embed per-statement literal values, 
        such as LIMIT and OFFSET parameters, in the final SQL string that 
        is passed to the DBAPI.   Dialects in particular may want to use 
        this method within custom compilation schemes. 
 
        .. versionadded:: 1.4.5 
 
        .. seealso:: 
 
            :ref:`engine_thirdparty_caching` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">c </span><span class="s4">= </span><span class="s1">ClauseElement</span><span class="s4">.</span><span class="s1">_clone</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s1">c</span><span class="s4">.</span><span class="s1">literal_execute </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s1">c</span>

    <span class="s3">def </span><span class="s1">_negate_in_binary</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">negated_op</span><span class="s4">, </span><span class="s1">original_op</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">expand_op </span><span class="s3">is </span><span class="s1">original_op</span><span class="s4">:</span>
            <span class="s1">bind </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_clone</span><span class="s4">()</span>
            <span class="s1">bind</span><span class="s4">.</span><span class="s1">expand_op </span><span class="s4">= </span><span class="s1">negated_op</span>
            <span class="s3">return </span><span class="s1">bind</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_with_binary_element_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">):</span>
        <span class="s1">c </span><span class="s4">= </span><span class="s1">ClauseElement</span><span class="s4">.</span><span class="s1">_clone</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s1">c</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_</span>
        <span class="s3">return </span><span class="s1">c</span>

    <span class="s3">def </span><span class="s1">_clone</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">maintain_key</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s1">c </span><span class="s4">= </span><span class="s1">ClauseElement</span><span class="s4">.</span><span class="s1">_clone</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s0"># ensure all the BindParameter objects stay in cloned set.</span>
        <span class="s0"># in #7823, we changed &quot;clone&quot; so that a clone only keeps a reference</span>
        <span class="s0"># to the &quot;original&quot; element, since for column correspondence, that's</span>
        <span class="s0"># all we need.   However, for BindParam, _cloned_set is used by</span>
        <span class="s0"># the &quot;cache key bind match&quot; lookup, which means if any of those</span>
        <span class="s0"># interim BindParameter objects became part of a cache key in the</span>
        <span class="s0"># cache, we need it.  So here, make sure all clones keep carrying</span>
        <span class="s0"># forward.</span>
        <span class="s1">c</span><span class="s4">.</span><span class="s1">_cloned_set</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_cloned_set</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">maintain_key </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">unique</span><span class="s4">:</span>
            <span class="s1">c</span><span class="s4">.</span><span class="s1">key </span><span class="s4">= </span><span class="s1">_anonymous_label</span><span class="s4">.</span><span class="s1">safe_construct</span><span class="s4">(</span>
                <span class="s1">id</span><span class="s4">(</span><span class="s1">c</span><span class="s4">), </span><span class="s1">c</span><span class="s4">.</span><span class="s1">_orig_key </span><span class="s3">or </span><span class="s5">&quot;param&quot;</span><span class="s4">, </span><span class="s1">sanitize_key</span><span class="s4">=</span><span class="s3">True</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">c</span>

    <span class="s3">def </span><span class="s1">_gen_cache_key</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">anon_map</span><span class="s4">, </span><span class="s1">bindparams</span><span class="s4">):</span>
        <span class="s1">_gen_cache_ok </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;inherit_cache&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">_gen_cache_ok</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">anon_map </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">anon_map</span><span class="s4">[</span><span class="s1">NO_CACHE</span><span class="s4">] = </span><span class="s3">True</span>
            <span class="s3">return None</span>

        <span class="s1">id_</span><span class="s4">, </span><span class="s1">found </span><span class="s4">= </span><span class="s1">anon_map</span><span class="s4">.</span><span class="s1">get_anon</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">found</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">(</span><span class="s1">id_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">bindparams </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">bindparams</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">id_</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">_static_cache_key</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">key </span><span class="s4">% </span><span class="s1">anon_map </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_key_is_anon </span><span class="s3">else </span><span class="s1">self</span><span class="s4">.</span><span class="s1">key</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">literal_execute</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_convert_to_unique</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">unique</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">unique </span><span class="s4">= </span><span class="s3">True</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">key </span><span class="s4">= </span><span class="s1">_anonymous_label</span><span class="s4">.</span><span class="s1">safe_construct</span><span class="s4">(</span>
                <span class="s1">id</span><span class="s4">(</span><span class="s1">self</span><span class="s4">), </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_orig_key </span><span class="s3">or </span><span class="s5">&quot;param&quot;</span><span class="s4">, </span><span class="s1">sanitize_key</span><span class="s4">=</span><span class="s3">True</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__getstate__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;execute a deferred value for serialization purposes.&quot;&quot;&quot;</span>

        <span class="s1">d </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">()</span>
        <span class="s1">v </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">value</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">callable</span><span class="s4">:</span>
            <span class="s1">v </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">callable</span><span class="s4">()</span>
            <span class="s1">d</span><span class="s4">[</span><span class="s5">&quot;callable&quot;</span><span class="s4">] = </span><span class="s3">None</span>
        <span class="s1">d</span><span class="s4">[</span><span class="s5">&quot;value&quot;</span><span class="s4">] = </span><span class="s1">v</span>
        <span class="s3">return </span><span class="s1">d</span>

    <span class="s3">def </span><span class="s1">__setstate__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;unique&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">):</span>
            <span class="s1">state</span><span class="s4">[</span><span class="s5">&quot;key&quot;</span><span class="s4">] = </span><span class="s1">_anonymous_label</span><span class="s4">.</span><span class="s1">safe_construct</span><span class="s4">(</span>
                <span class="s1">id</span><span class="s4">(</span><span class="s1">self</span><span class="s4">), </span><span class="s1">state</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;_orig_key&quot;</span><span class="s4">, </span><span class="s5">&quot;param&quot;</span><span class="s4">), </span><span class="s1">sanitize_key</span><span class="s4">=</span><span class="s3">True</span>
            <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__repr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s5">&quot;%s(%r, %r, type_=%r)&quot; </span><span class="s4">% (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">key</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">value</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">,</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">TypeClause</span><span class="s4">(</span><span class="s1">DQLDMLClauseElement</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Handle a type keyword in a SQL statement. 
 
    Used by the ``Case`` statement. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;typeclause&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;type&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_type</span><span class="s4">)</span>
    <span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_</span>


<span class="s3">class </span><span class="s1">TextClause</span><span class="s4">(</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">DDLConstraintColumnRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">DDLExpressionRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">StatementOptionRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">WhereHavingRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">OrderByRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">FromClauseRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">SelectStatementRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">InElementRole</span><span class="s4">,</span>
    <span class="s1">Generative</span><span class="s4">,</span>
    <span class="s1">Executable</span><span class="s4">,</span>
    <span class="s1">DQLDMLClauseElement</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">BinaryElementRole</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s1">inspection</span><span class="s4">.</span><span class="s1">Inspectable</span><span class="s4">[</span><span class="s5">&quot;TextClause&quot;</span><span class="s4">],</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represent a literal SQL text fragment. 
 
    E.g.:: 
 
        from sqlalchemy import text 
 
        t = text(&quot;SELECT * FROM users&quot;) 
        result = connection.execute(t) 
 
 
    The :class:`_expression.TextClause` construct is produced using the 
    :func:`_expression.text` 
    function; see that function for full documentation. 
 
    .. seealso:: 
 
        :func:`_expression.text` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;textclause&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;_bindparams&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_string_clauseelement_dict</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;text&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_string</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">_is_text_clause </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">_is_textual </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">_bind_params_regex </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s5">r&quot;(?&lt;![:\w\x5c]):(\w+)(?!:)&quot;</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">UNICODE</span><span class="s4">)</span>
    <span class="s1">_is_implicitly_boolean </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s1">_render_label_in_columns_clause </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s1">_omit_from_statements </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s1">_is_collection_aggregate </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_hide_froms</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">__and__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s0"># support use in select.where(), query.filter()</span>
        <span class="s3">return </span><span class="s1">and_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_select_iterable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _SelectIterable</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">self</span><span class="s4">,)</span>

    <span class="s0"># help in those cases where text() is</span>
    <span class="s0"># interpreted in a column expression situation</span>
    <span class="s1">key</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s1">_label</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>

    <span class="s1">_allow_label_resolve </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_is_star</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">text </span><span class="s4">== </span><span class="s5">&quot;*&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">text</span><span class="s4">: </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_bindparams</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">BindParameter</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = {}</span>

        <span class="s3">def </span><span class="s1">repl</span><span class="s4">(</span><span class="s1">m</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_bindparams</span><span class="s4">[</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)] = </span><span class="s1">BindParameter</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">1</span><span class="s4">))</span>
            <span class="s3">return </span><span class="s5">&quot;:%s&quot; </span><span class="s4">% </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)</span>

        <span class="s0"># scan the string and search for bind parameter names, add them</span>
        <span class="s0"># to the list of bindparams</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">text </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_bind_params_regex</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">(</span><span class="s1">repl</span><span class="s4">, </span><span class="s1">text</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">bindparams</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">binds</span><span class="s4">: </span><span class="s1">BindParameter</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s4">**</span><span class="s1">names_to_values</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Establish the values and/or types of bound parameters within 
        this :class:`_expression.TextClause` construct. 
 
        Given a text construct such as:: 
 
            from sqlalchemy import text 
            stmt = text(&quot;SELECT id, name FROM user WHERE name=:name &quot; 
                        &quot;AND timestamp=:timestamp&quot;) 
 
        the :meth:`_expression.TextClause.bindparams` 
        method can be used to establish 
        the initial value of ``:name`` and ``:timestamp``, 
        using simple keyword arguments:: 
 
            stmt = stmt.bindparams(name='jack', 
                        timestamp=datetime.datetime(2012, 10, 8, 15, 12, 5)) 
 
        Where above, new :class:`.BindParameter` objects 
        will be generated with the names ``name`` and ``timestamp``, and 
        values of ``jack`` and ``datetime.datetime(2012, 10, 8, 15, 12, 5)``, 
        respectively.  The types will be 
        inferred from the values given, in this case :class:`.String` and 
        :class:`.DateTime`. 
 
        When specific typing behavior is needed, the positional ``*binds`` 
        argument can be used in which to specify :func:`.bindparam` constructs 
        directly.  These constructs must include at least the ``key`` 
        argument, then an optional value and type:: 
 
            from sqlalchemy import bindparam 
            stmt = stmt.bindparams( 
                            bindparam('name', value='jack', type_=String), 
                            bindparam('timestamp', type_=DateTime) 
                        ) 
 
        Above, we specified the type of :class:`.DateTime` for the 
        ``timestamp`` bind, and the type of :class:`.String` for the ``name`` 
        bind.  In the case of ``name`` we also set the default value of 
        ``&quot;jack&quot;``. 
 
        Additional bound parameters can be supplied at statement execution 
        time, e.g.:: 
 
            result = connection.execute(stmt, 
                        timestamp=datetime.datetime(2012, 10, 8, 15, 12, 5)) 
 
        The :meth:`_expression.TextClause.bindparams` 
        method can be called repeatedly, 
        where it will re-use existing :class:`.BindParameter` objects to add 
        new information.  For example, we can call 
        :meth:`_expression.TextClause.bindparams` 
        first with typing information, and a 
        second time with value information, and it will be combined:: 
 
            stmt = text(&quot;SELECT id, name FROM user WHERE name=:name &quot; 
                        &quot;AND timestamp=:timestamp&quot;) 
            stmt = stmt.bindparams( 
                bindparam('name', type_=String), 
                bindparam('timestamp', type_=DateTime) 
            ) 
            stmt = stmt.bindparams( 
                name='jack', 
                timestamp=datetime.datetime(2012, 10, 8, 15, 12, 5) 
            ) 
 
        The :meth:`_expression.TextClause.bindparams` 
        method also supports the concept of 
        **unique** bound parameters.  These are parameters that are 
        &quot;uniquified&quot; on name at statement compilation time, so that  multiple 
        :func:`_expression.text` 
        constructs may be combined together without the names 
        conflicting.  To use this feature, specify the 
        :paramref:`.BindParameter.unique` flag on each :func:`.bindparam` 
        object:: 
 
            stmt1 = text(&quot;select id from table where name=:name&quot;).bindparams( 
                bindparam(&quot;name&quot;, value='name1', unique=True) 
            ) 
            stmt2 = text(&quot;select id from table where name=:name&quot;).bindparams( 
                bindparam(&quot;name&quot;, value='name2', unique=True) 
            ) 
 
            union = union_all( 
                stmt1.columns(column(&quot;id&quot;)), 
                stmt2.columns(column(&quot;id&quot;)) 
            ) 
 
        The above statement will render as:: 
 
            select id from table where name=:name_1 
            UNION ALL select id from table where name=:name_2 
 
        .. versionadded:: 1.3.11  Added support for the 
           :paramref:`.BindParameter.unique` flag to work with 
           :func:`_expression.text` 
           constructs. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_bindparams </span><span class="s4">= </span><span class="s1">new_params </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_bindparams</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">()</span>

        <span class="s3">for </span><span class="s1">bind </span><span class="s3">in </span><span class="s1">binds</span><span class="s4">:</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s0"># the regex used for text() currently will not match</span>
                <span class="s0"># a unique/anonymous key in any case, so use the _orig_key</span>
                <span class="s0"># so that a text() construct can support unique parameters</span>
                <span class="s1">existing </span><span class="s4">= </span><span class="s1">new_params</span><span class="s4">[</span><span class="s1">bind</span><span class="s4">.</span><span class="s1">_orig_key</span><span class="s4">]</span>
            <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                    <span class="s5">&quot;This text() construct doesn't define a &quot;</span>
                    <span class="s5">&quot;bound parameter named %r&quot; </span><span class="s4">% </span><span class="s1">bind</span><span class="s4">.</span><span class="s1">_orig_key</span>
                <span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">new_params</span><span class="s4">[</span><span class="s1">existing</span><span class="s4">.</span><span class="s1">_orig_key</span><span class="s4">] = </span><span class="s1">bind</span>

        <span class="s3">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">names_to_values</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">existing </span><span class="s4">= </span><span class="s1">new_params</span><span class="s4">[</span><span class="s1">key</span><span class="s4">]</span>
            <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                    <span class="s5">&quot;This text() construct doesn't define a &quot;</span>
                    <span class="s5">&quot;bound parameter named %r&quot; </span><span class="s4">% </span><span class="s1">key</span>
                <span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">new_params</span><span class="s4">[</span><span class="s1">key</span><span class="s4">] = </span><span class="s1">existing</span><span class="s4">.</span><span class="s1">_with_value</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">required</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.selectable&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *</span><span class="s1">cols</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], **</span><span class="s1">types</span><span class="s4">: </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; TextualSelect</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Turn this :class:`_expression.TextClause` object into a 
        :class:`_expression.TextualSelect` 
        object that serves the same role as a SELECT 
        statement. 
 
        The :class:`_expression.TextualSelect` is part of the 
        :class:`_expression.SelectBase` 
        hierarchy and can be embedded into another statement by using the 
        :meth:`_expression.TextualSelect.subquery` method to produce a 
        :class:`.Subquery` 
        object, which can then be SELECTed from. 
 
        This function essentially bridges the gap between an entirely 
        textual SELECT statement and the SQL expression language concept 
        of a &quot;selectable&quot;:: 
 
            from sqlalchemy.sql import column, text 
 
            stmt = text(&quot;SELECT id, name FROM some_table&quot;) 
            stmt = stmt.columns(column('id'), column('name')).subquery('st') 
 
            stmt = select(mytable).\ 
                    select_from( 
                        mytable.join(stmt, mytable.c.name == stmt.c.name) 
                    ).where(stmt.c.id &gt; 5) 
 
        Above, we pass a series of :func:`_expression.column` elements to the 
        :meth:`_expression.TextClause.columns` method positionally.  These 
        :func:`_expression.column` 
        elements now become first class elements upon the 
        :attr:`_expression.TextualSelect.selected_columns` column collection, 
        which then 
        become part of the :attr:`.Subquery.c` collection after 
        :meth:`_expression.TextualSelect.subquery` is invoked. 
 
        The column expressions we pass to 
        :meth:`_expression.TextClause.columns` may 
        also be typed; when we do so, these :class:`.TypeEngine` objects become 
        the effective return type of the column, so that SQLAlchemy's 
        result-set-processing systems may be used on the return values. 
        This is often needed for types such as date or boolean types, as well 
        as for unicode processing on some dialect configurations:: 
 
            stmt = text(&quot;SELECT id, name, timestamp FROM some_table&quot;) 
            stmt = stmt.columns( 
                        column('id', Integer), 
                        column('name', Unicode), 
                        column('timestamp', DateTime) 
                    ) 
 
            for id, name, timestamp in connection.execute(stmt): 
                print(id, name, timestamp) 
 
        As a shortcut to the above syntax, keyword arguments referring to 
        types alone may be used, if only type conversion is needed:: 
 
            stmt = text(&quot;SELECT id, name, timestamp FROM some_table&quot;) 
            stmt = stmt.columns( 
                        id=Integer, 
                        name=Unicode, 
                        timestamp=DateTime 
                    ) 
 
            for id, name, timestamp in connection.execute(stmt): 
                print(id, name, timestamp) 
 
        The positional form of :meth:`_expression.TextClause.columns` 
        also provides the 
        unique feature of **positional column targeting**, which is 
        particularly useful when using the ORM with complex textual queries. If 
        we specify the columns from our model to 
        :meth:`_expression.TextClause.columns`, 
        the result set will match to those columns positionally, meaning the 
        name or origin of the column in the textual SQL doesn't matter:: 
 
            stmt = text(&quot;SELECT users.id, addresses.id, users.id, &quot; 
                 &quot;users.name, addresses.email_address AS email &quot; 
                 &quot;FROM users JOIN addresses ON users.id=addresses.user_id &quot; 
                 &quot;WHERE users.id = 1&quot;).columns( 
                    User.id, 
                    Address.id, 
                    Address.user_id, 
                    User.name, 
                    Address.email_address 
                 ) 
 
            query = session.query(User).from_statement(stmt).options( 
                contains_eager(User.addresses)) 
 
        The :meth:`_expression.TextClause.columns` method provides a direct 
        route to calling :meth:`_expression.FromClause.subquery` as well as 
        :meth:`_expression.SelectBase.cte` 
        against a textual SELECT statement:: 
 
            stmt = stmt.columns(id=Integer, name=String).cte('st') 
 
            stmt = select(sometable).where(sometable.c.id == stmt.c.id) 
 
        :param \*cols: A series of :class:`_expression.ColumnElement` objects, 
         typically 
         :class:`_schema.Column` objects from a :class:`_schema.Table` 
         or ORM level 
         column-mapped attributes, representing a set of columns that this 
         textual string will SELECT from. 
 
        :param \**types: A mapping of string names to :class:`.TypeEngine` 
         type objects indicating the datatypes to use for names that are 
         SELECTed from the textual string.  Prefer to use the ``*cols`` 
         argument as it also indicates positional ordering. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">selectable </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_selectable</span>

        <span class="s1">input_cols</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">NamedColumn</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = [</span>
            <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">LabeledColumnExprRole</span><span class="s4">, </span><span class="s1">col</span><span class="s4">) </span><span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">cols</span>
        <span class="s4">]</span>

        <span class="s1">positional_input_cols </span><span class="s4">= [</span>
            <span class="s4">(</span>
                <span class="s1">ColumnClause</span><span class="s4">(</span><span class="s1">col</span><span class="s4">.</span><span class="s1">key</span><span class="s4">, </span><span class="s1">types</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">col</span><span class="s4">.</span><span class="s1">key</span><span class="s4">))</span>
                <span class="s3">if </span><span class="s1">col</span><span class="s4">.</span><span class="s1">key </span><span class="s3">in </span><span class="s1">types</span>
                <span class="s3">else </span><span class="s1">col</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">input_cols</span>
        <span class="s4">]</span>
        <span class="s1">keyed_input_cols</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">NamedColumn</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = [</span>
            <span class="s1">ColumnClause</span><span class="s4">(</span><span class="s1">key</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">) </span><span class="s3">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">type_ </span><span class="s3">in </span><span class="s1">types</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()</span>
        <span class="s4">]</span>

        <span class="s1">elem </span><span class="s4">= </span><span class="s1">selectable</span><span class="s4">.</span><span class="s1">TextualSelect</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">selectable</span><span class="s4">.</span><span class="s1">TextualSelect</span><span class="s4">)</span>
        <span class="s1">elem</span><span class="s4">.</span><span class="s1">_init</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">positional_input_cols </span><span class="s4">+ </span><span class="s1">keyed_input_cols</span><span class="s4">,</span>
            <span class="s1">positional</span><span class="s4">=</span><span class="s1">bool</span><span class="s4">(</span><span class="s1">positional_input_cols</span><span class="s4">) </span><span class="s3">and not </span><span class="s1">keyed_input_cols</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">elem</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">NULLTYPE</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">comparator</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0"># TODO: this seems wrong, it seems like we might not</span>
        <span class="s0"># be using this method.</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">comparator_factory</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)  </span><span class="s0"># type: ignore</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">Self</span><span class="s4">, </span><span class="s1">Grouping</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">if </span><span class="s1">against </span><span class="s3">is </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">in_op</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">Grouping</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">Null</span><span class="s4">(</span><span class="s1">SingletonConstant</span><span class="s4">, </span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ConstExprRole</span><span class="s4">[</span><span class="s3">None</span><span class="s4">], </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s3">None</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent the NULL keyword in a SQL statement. 
 
    :class:`.Null` is accessed as a constant via the 
    :func:`.null` function. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;null&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= []</span>
    <span class="s1">_singleton</span><span class="s4">: </span><span class="s1">Null</span>

    <span class="s3">if not </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
        <span class="s3">def </span><span class="s1">type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:  </span><span class="s0"># noqa: A001</span>
            <span class="s3">return </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">NULLTYPE</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_instance</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">) </span><span class="s1">-&gt; Null</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a constant :class:`.Null` construct.&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">Null</span><span class="s4">.</span><span class="s1">_singleton</span>


<span class="s1">Null</span><span class="s4">.</span><span class="s1">_create_singleton</span><span class="s4">()</span>


<span class="s3">class </span><span class="s1">False_</span><span class="s4">(</span>
    <span class="s1">SingletonConstant</span><span class="s4">, </span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ConstExprRole</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">], </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represent the ``false`` keyword, or equivalent, in a SQL statement. 
 
    :class:`.False_` is accessed as a constant via the 
    :func:`.false` function. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;false&quot;</span>
    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= []</span>
    <span class="s1">_singleton</span><span class="s4">: </span><span class="s1">False_</span>

    <span class="s3">if not </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
        <span class="s3">def </span><span class="s1">type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:  </span><span class="s0"># noqa: A001</span>
            <span class="s3">return </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">BOOLEANTYPE</span>

    <span class="s3">def </span><span class="s1">_negate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; True_</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">True_</span><span class="s4">.</span><span class="s1">_singleton</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_instance</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">) </span><span class="s1">-&gt; False_</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">False_</span><span class="s4">.</span><span class="s1">_singleton</span>


<span class="s1">False_</span><span class="s4">.</span><span class="s1">_create_singleton</span><span class="s4">()</span>


<span class="s3">class </span><span class="s1">True_</span><span class="s4">(</span><span class="s1">SingletonConstant</span><span class="s4">, </span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ConstExprRole</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">], </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent the ``true`` keyword, or equivalent, in a SQL statement. 
 
    :class:`.True_` is accessed as a constant via the 
    :func:`.true` function. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;true&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= []</span>
    <span class="s1">_singleton</span><span class="s4">: </span><span class="s1">True_</span>

    <span class="s3">if not </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
        <span class="s3">def </span><span class="s1">type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:  </span><span class="s0"># noqa: A001</span>
            <span class="s3">return </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">BOOLEANTYPE</span>

    <span class="s3">def </span><span class="s1">_negate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; False_</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">False_</span><span class="s4">.</span><span class="s1">_singleton</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_ifnone</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">other</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>
    <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">other </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_instance</span><span class="s4">()</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">other</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_instance</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">) </span><span class="s1">-&gt; True_</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">True_</span><span class="s4">.</span><span class="s1">_singleton</span>


<span class="s1">True_</span><span class="s4">.</span><span class="s1">_create_singleton</span><span class="s4">()</span>


<span class="s3">class </span><span class="s1">ClauseList</span><span class="s4">(</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">InElementRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">OrderByRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">ColumnsClauseRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">DMLColumnRole</span><span class="s4">,</span>
    <span class="s1">DQLDMLClauseElement</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Describe a list of clauses, separated by an operator. 
 
    By default, is comma-separated, such as a column listing. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;clauselist&quot;</span>

    <span class="s0"># this is used only by the ORM in a legacy use case for</span>
    <span class="s0"># composite attributes</span>
    <span class="s1">_is_clause_list </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;clauses&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_list</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;operator&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_operator</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">clauses</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">clauses</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">operator</span><span class="s4">: </span><span class="s1">OperatorType </span><span class="s4">= </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">comma_op</span><span class="s4">,</span>
        <span class="s1">group</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">group_contents</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">_literal_as_text_role</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">SQLRole</span><span class="s4">] = </span><span class="s1">roles</span><span class="s4">.</span><span class="s1">WhereHavingRole</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">operator </span><span class="s4">= </span><span class="s1">operator</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">group </span><span class="s4">= </span><span class="s1">group</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">group_contents </span><span class="s4">= </span><span class="s1">group_contents</span>
        <span class="s1">clauses_iterator</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s1">clauses</span>
        <span class="s1">text_converter_role</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">SQLRole</span><span class="s4">] = </span><span class="s1">_literal_as_text_role</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_text_converter_role </span><span class="s4">= </span><span class="s1">text_converter_role</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">group_contents</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">clauses </span><span class="s4">= [</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                    <span class="s1">text_converter_role</span><span class="s4">, </span><span class="s1">clause</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
                <span class="s4">).</span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">against</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">clause </span><span class="s3">in </span><span class="s1">clauses_iterator</span>
            <span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">clauses </span><span class="s4">= [</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                    <span class="s1">text_converter_role</span><span class="s4">, </span><span class="s1">clause</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
                <span class="s4">)</span>
                <span class="s3">for </span><span class="s1">clause </span><span class="s3">in </span><span class="s1">clauses_iterator</span>
            <span class="s4">]</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_is_implicitly_boolean </span><span class="s4">= </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_boolean</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_construct_raw</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">operator</span><span class="s4">: </span><span class="s1">OperatorType</span><span class="s4">,</span>
        <span class="s1">clauses</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ClauseList</span><span class="s4">:</span>
        <span class="s1">self </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">clauses </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">clauses</span><span class="s4">) </span><span class="s3">if </span><span class="s1">clauses </span><span class="s3">else </span><span class="s4">[]</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">group </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">operator </span><span class="s4">= </span><span class="s1">operator</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">group_contents </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_is_implicitly_boolean </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__iter__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">return </span><span class="s1">iter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__len__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_select_iterable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _SelectIterable</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">.</span><span class="s1">from_iterable</span><span class="s4">(</span>
            <span class="s4">[</span><span class="s1">elem</span><span class="s4">.</span><span class="s1">_select_iterable </span><span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">]</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">append</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">clause</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">group_contents</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_text_converter_role</span><span class="s4">, </span><span class="s1">clause</span><span class="s4">).</span><span class="s1">self_group</span><span class="s4">(</span>
                    <span class="s1">against</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">operator</span>
                <span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_text_converter_role</span><span class="s4">, </span><span class="s1">clause</span><span class="s4">)</span>
            <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">list</span><span class="s4">(</span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(*[</span><span class="s1">c</span><span class="s4">.</span><span class="s1">_from_objects </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">]))</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">Self</span><span class="s4">, </span><span class="s1">Grouping</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">group </span><span class="s3">and </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_precedent</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">, </span><span class="s1">against</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">Grouping</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">OperatorExpression</span><span class="s4">(</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;base for expressions that contain an operator and operands 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">operator</span><span class="s4">: </span><span class="s1">OperatorType</span>
    <span class="s1">type</span><span class="s4">: </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>

    <span class="s1">group</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">is_comparison</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_comparison</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">Self</span><span class="s4">, </span><span class="s1">Grouping</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">group</span>
            <span class="s3">and </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_precedent</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">, </span><span class="s1">against</span><span class="s4">)</span>
            <span class="s3">or </span><span class="s4">(</span>
                <span class="s0"># a negate against a non-boolean operator</span>
                <span class="s0"># doesn't make too much sense but we should</span>
                <span class="s0"># group for that</span>
                <span class="s1">against </span><span class="s3">is </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">inv</span>
                <span class="s3">and not </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_boolean</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s4">):</span>
            <span class="s3">return </span><span class="s1">Grouping</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_flattened_operator_clauses</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; typing_Tuple</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], ...]:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_construct_for_op</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">left</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">right</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">op</span><span class="s4">: </span><span class="s1">OperatorType</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">type_</span><span class="s4">: </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
        <span class="s1">negate</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">modifiers</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Mapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; OperatorExpression</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_associative</span><span class="s4">(</span><span class="s1">op</span><span class="s4">):</span>
            <span class="s3">assert </span><span class="s4">(</span>
                <span class="s1">negate </span><span class="s3">is None</span>
            <span class="s4">), </span><span class="s5">f&quot;negate not supported for associative operator </span><span class="s3">{</span><span class="s1">op</span><span class="s3">}</span><span class="s5">&quot;</span>

            <span class="s1">multi </span><span class="s4">= </span><span class="s3">False</span>
            <span class="s3">if </span><span class="s1">getattr</span><span class="s4">(</span>
                <span class="s1">left</span><span class="s4">, </span><span class="s5">&quot;operator&quot;</span><span class="s4">, </span><span class="s3">None</span>
            <span class="s4">) </span><span class="s3">is </span><span class="s1">op </span><span class="s3">and </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">_compare_type_affinity</span><span class="s4">(</span><span class="s1">left</span><span class="s4">.</span><span class="s1">type</span><span class="s4">):</span>
                <span class="s1">multi </span><span class="s4">= </span><span class="s3">True</span>
                <span class="s1">left_flattened </span><span class="s4">= </span><span class="s1">left</span><span class="s4">.</span><span class="s1">_flattened_operator_clauses</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">left_flattened </span><span class="s4">= (</span><span class="s1">left</span><span class="s4">,)</span>

            <span class="s3">if </span><span class="s1">getattr</span><span class="s4">(</span>
                <span class="s1">right</span><span class="s4">, </span><span class="s5">&quot;operator&quot;</span><span class="s4">, </span><span class="s3">None</span>
            <span class="s4">) </span><span class="s3">is </span><span class="s1">op </span><span class="s3">and </span><span class="s1">type_</span><span class="s4">.</span><span class="s1">_compare_type_affinity</span><span class="s4">(</span><span class="s1">right</span><span class="s4">.</span><span class="s1">type</span><span class="s4">):</span>
                <span class="s1">multi </span><span class="s4">= </span><span class="s3">True</span>
                <span class="s1">right_flattened </span><span class="s4">= </span><span class="s1">right</span><span class="s4">.</span><span class="s1">_flattened_operator_clauses</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">right_flattened </span><span class="s4">= (</span><span class="s1">right</span><span class="s4">,)</span>

            <span class="s3">if </span><span class="s1">multi</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">ExpressionClauseList</span><span class="s4">.</span><span class="s1">_construct_for_list</span><span class="s4">(</span>
                    <span class="s1">op</span><span class="s4">,</span>
                    <span class="s1">type_</span><span class="s4">,</span>
                    <span class="s4">*(</span><span class="s1">left_flattened </span><span class="s4">+ </span><span class="s1">right_flattened</span><span class="s4">),</span>
                <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">right</span><span class="s4">.</span><span class="s1">_is_collection_aggregate</span><span class="s4">:</span>
            <span class="s1">negate </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s3">return </span><span class="s1">BinaryExpression</span><span class="s4">(</span>
            <span class="s1">left</span><span class="s4">, </span><span class="s1">right</span><span class="s4">, </span><span class="s1">op</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">=</span><span class="s1">type_</span><span class="s4">, </span><span class="s1">negate</span><span class="s4">=</span><span class="s1">negate</span><span class="s4">, </span><span class="s1">modifiers</span><span class="s4">=</span><span class="s1">modifiers</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">ExpressionClauseList</span><span class="s4">(</span><span class="s1">OperatorExpression</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Describe a list of clauses, separated by an operator, 
    in a column expression context. 
 
    :class:`.ExpressionClauseList` differs from :class:`.ClauseList` in that 
    it represents a column-oriented DQL expression only, not an open ended 
    list of anything comma separated. 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;expression_clauselist&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;clauses&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_tuple</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;operator&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_operator</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">clauses</span><span class="s4">: </span><span class="s1">typing_Tuple</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], ...]</span>

    <span class="s1">group</span><span class="s4">: </span><span class="s1">bool</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">operator</span><span class="s4">: </span><span class="s1">OperatorType</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">clauses</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">type_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">operator </span><span class="s4">= </span><span class="s1">operator</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">clauses </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span>
            <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                <span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">, </span><span class="s1">clause</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">clause </span><span class="s3">in </span><span class="s1">clauses</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_is_implicitly_boolean </span><span class="s4">= </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_boolean</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">to_instance</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">)  </span><span class="s0"># type: ignore</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_flattened_operator_clauses</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; typing_Tuple</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], ...]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">clauses</span>

    <span class="s3">def </span><span class="s1">__iter__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">return </span><span class="s1">iter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__len__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_select_iterable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _SelectIterable</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">self</span><span class="s4">,)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">list</span><span class="s4">(</span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(*[</span><span class="s1">c</span><span class="s4">.</span><span class="s1">_from_objects </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">]))</span>

    <span class="s3">def </span><span class="s1">_append_inplace</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">clause</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">clauses </span><span class="s4">+= (</span><span class="s1">clause</span><span class="s4">,)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_construct_for_list</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">operator</span><span class="s4">: </span><span class="s1">OperatorType</span><span class="s4">,</span>
        <span class="s1">type_</span><span class="s4">: </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
        <span class="s4">*</span><span class="s1">clauses</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">group</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ExpressionClauseList</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s1">self </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">group </span><span class="s4">= </span><span class="s1">group</span>
        <span class="s3">if </span><span class="s1">group</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">clauses </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span>
                <span class="s1">c</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">against</span><span class="s4">=</span><span class="s1">operator</span><span class="s4">) </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">clauses</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">clauses </span><span class="s4">= </span><span class="s1">clauses</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">operator </span><span class="s4">= </span><span class="s1">operator</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_negate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s1">grouped </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">against</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">inv</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">grouped</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">UnaryExpression</span><span class="s4">(</span>
            <span class="s1">grouped</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">inv</span><span class="s4">, </span><span class="s1">wraps_column_expression</span><span class="s4">=</span><span class="s3">True</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">BooleanClauseList</span><span class="s4">(</span><span class="s1">ExpressionClauseList</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]):</span>
    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;expression_clauselist&quot;</span>
    <span class="s1">inherit_cache </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">arg</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">(</span>
            <span class="s5">&quot;BooleanClauseList has a private constructor&quot;</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_process_clauses_for_boolean</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">operator</span><span class="s4">: </span><span class="s1">OperatorType</span><span class="s4">,</span>
        <span class="s1">continue_on</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s1">skip_on</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s1">clauses</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
    <span class="s4">) </span><span class="s1">-&gt; typing_Tuple</span><span class="s4">[</span><span class="s1">int</span><span class="s4">, </span><span class="s1">List</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]]:</span>
        <span class="s1">has_continue_on </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s1">convert_clauses </span><span class="s4">= []</span>

        <span class="s1">against </span><span class="s4">= </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">_asbool</span>
        <span class="s1">lcc </span><span class="s4">= </span><span class="s6">0</span>

        <span class="s3">for </span><span class="s1">clause </span><span class="s3">in </span><span class="s1">clauses</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">clause </span><span class="s3">is </span><span class="s1">continue_on</span><span class="s4">:</span>
                <span class="s0"># instance of continue_on, like and_(x, y, True, z), store it</span>
                <span class="s0"># if we didn't find one already, we will use it if there</span>
                <span class="s0"># are no other expressions here.</span>
                <span class="s1">has_continue_on </span><span class="s4">= </span><span class="s1">clause</span>
            <span class="s3">elif </span><span class="s1">clause </span><span class="s3">is </span><span class="s1">skip_on</span><span class="s4">:</span>
                <span class="s0"># instance of skip_on, e.g. and_(x, y, False, z), cancels</span>
                <span class="s0"># the rest out</span>
                <span class="s1">convert_clauses </span><span class="s4">= [</span><span class="s1">clause</span><span class="s4">]</span>
                <span class="s1">lcc </span><span class="s4">= </span><span class="s6">1</span>
                <span class="s3">break</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if not </span><span class="s1">lcc</span><span class="s4">:</span>
                    <span class="s1">lcc </span><span class="s4">= </span><span class="s6">1</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">against </span><span class="s4">= </span><span class="s1">operator</span>
                    <span class="s0"># technically this would be len(convert_clauses) + 1</span>
                    <span class="s0"># however this only needs to indicate &quot;greater than one&quot;</span>
                    <span class="s1">lcc </span><span class="s4">= </span><span class="s6">2</span>
                <span class="s1">convert_clauses</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">clause</span><span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">convert_clauses </span><span class="s3">and </span><span class="s1">has_continue_on </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">convert_clauses </span><span class="s4">= [</span><span class="s1">has_continue_on</span><span class="s4">]</span>
            <span class="s1">lcc </span><span class="s4">= </span><span class="s6">1</span>

        <span class="s3">return </span><span class="s1">lcc</span><span class="s4">, [</span><span class="s1">c</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">against</span><span class="s4">=</span><span class="s1">against</span><span class="s4">) </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">convert_clauses</span><span class="s4">]</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_construct</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">operator</span><span class="s4">: </span><span class="s1">OperatorType</span><span class="s4">,</span>
        <span class="s1">continue_on</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s1">skip_on</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s1">initial_clause</span><span class="s4">: </span><span class="s1">Any </span><span class="s4">= </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">clauses</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">initial_clause </span><span class="s3">is </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">:</span>
            <span class="s0"># no elements period.  deprecated use case.  return an empty</span>
            <span class="s0"># ClauseList construct that generates nothing unless it has</span>
            <span class="s0"># elements added to it.</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s1">operator</span><span class="s4">.</span><span class="s1">__name__</span>

            <span class="s1">util</span><span class="s4">.</span><span class="s1">warn_deprecated</span><span class="s4">(</span>
                <span class="s5">f&quot;Invoking </span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s5">() without arguments is deprecated, and &quot;</span>
                <span class="s5">f&quot;will be disallowed in a future release.   For an empty &quot;</span>
                <span class="s5">f&quot;&quot;&quot;</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s5">() construct, use '</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s5">(</span><span class="s3">{</span>
                    <span class="s5">'true()' </span><span class="s3">if </span><span class="s1">continue_on </span><span class="s3">is </span><span class="s1">True_</span><span class="s4">.</span><span class="s1">_singleton </span><span class="s3">else </span><span class="s5">'false()'</span>
                <span class="s3">}</span><span class="s5">, *args)' &quot;&quot;&quot;</span>
                <span class="s5">f&quot;&quot;&quot;or '</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s5">(</span><span class="s3">{</span>
                    <span class="s5">'True' </span><span class="s3">if </span><span class="s1">continue_on </span><span class="s3">is </span><span class="s1">True_</span><span class="s4">.</span><span class="s1">_singleton </span><span class="s3">else </span><span class="s5">'False'</span>
                <span class="s3">}</span><span class="s5">, *args)'.&quot;&quot;&quot;</span><span class="s4">,</span>
                <span class="s1">version</span><span class="s4">=</span><span class="s5">&quot;1.4&quot;</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s3">return </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_construct_raw</span><span class="s4">(</span><span class="s1">operator</span><span class="s4">)</span>

        <span class="s1">lcc</span><span class="s4">, </span><span class="s1">convert_clauses </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_process_clauses_for_boolean</span><span class="s4">(</span>
            <span class="s1">operator</span><span class="s4">,</span>
            <span class="s1">continue_on</span><span class="s4">,</span>
            <span class="s1">skip_on</span><span class="s4">,</span>
            <span class="s4">[</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">WhereHavingRole</span><span class="s4">, </span><span class="s1">clause</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">clause </span><span class="s3">in </span><span class="s1">util</span><span class="s4">.</span><span class="s1">coerce_generator_arg</span><span class="s4">(</span>
                    <span class="s4">(</span><span class="s1">initial_clause</span><span class="s4">,) + </span><span class="s1">clauses</span>
                <span class="s4">)</span>
            <span class="s4">],</span>
        <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">lcc </span><span class="s4">&gt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s0"># multiple elements.  Return regular BooleanClauseList</span>
            <span class="s0"># which will link elements against the operator.</span>

            <span class="s1">flattened_clauses </span><span class="s4">= </span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">.</span><span class="s1">from_iterable</span><span class="s4">(</span>
                <span class="s4">(</span>
                    <span class="s4">(</span><span class="s1">c </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">to_flat</span><span class="s4">.</span><span class="s1">_flattened_operator_clauses</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">to_flat</span><span class="s4">, </span><span class="s5">&quot;operator&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">is </span><span class="s1">operator</span>
                    <span class="s3">else </span><span class="s4">(</span><span class="s1">to_flat</span><span class="s4">,)</span>
                <span class="s4">)</span>
                <span class="s3">for </span><span class="s1">to_flat </span><span class="s3">in </span><span class="s1">convert_clauses</span>
            <span class="s4">)</span>

            <span class="s3">return </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_construct_raw</span><span class="s4">(</span><span class="s1">operator</span><span class="s4">, </span><span class="s1">flattened_clauses</span><span class="s4">)  </span><span class="s0"># type: ignore # noqa: E501</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">lcc</span>
            <span class="s0"># just one element.  return it as a single boolean element,</span>
            <span class="s0"># not a list and discard the operator.</span>
            <span class="s3">return </span><span class="s1">convert_clauses</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_construct_for_whereclause</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">clauses</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]]:</span>
        <span class="s1">operator</span><span class="s4">, </span><span class="s1">continue_on</span><span class="s4">, </span><span class="s1">skip_on </span><span class="s4">= (</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">and_</span><span class="s4">,</span>
            <span class="s1">True_</span><span class="s4">.</span><span class="s1">_singleton</span><span class="s4">,</span>
            <span class="s1">False_</span><span class="s4">.</span><span class="s1">_singleton</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s1">lcc</span><span class="s4">, </span><span class="s1">convert_clauses </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_process_clauses_for_boolean</span><span class="s4">(</span>
            <span class="s1">operator</span><span class="s4">,</span>
            <span class="s1">continue_on</span><span class="s4">,</span>
            <span class="s1">skip_on</span><span class="s4">,</span>
            <span class="s1">clauses</span><span class="s4">,  </span><span class="s0"># these are assumed to be coerced already</span>
        <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">lcc </span><span class="s4">&gt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s0"># multiple elements.  Return regular BooleanClauseList</span>
            <span class="s0"># which will link elements against the operator.</span>
            <span class="s3">return </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_construct_raw</span><span class="s4">(</span><span class="s1">operator</span><span class="s4">, </span><span class="s1">convert_clauses</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">lcc </span><span class="s4">== </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s0"># just one element.  return it as a single boolean element,</span>
            <span class="s0"># not a list and discard the operator.</span>
            <span class="s3">return </span><span class="s1">convert_clauses</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return None</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_construct_raw</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">operator</span><span class="s4">: </span><span class="s1">OperatorType</span><span class="s4">,</span>
        <span class="s1">clauses</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; BooleanClauseList</span><span class="s4">:</span>
        <span class="s1">self </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">clauses </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">clauses</span><span class="s4">) </span><span class="s3">if </span><span class="s1">clauses </span><span class="s3">else </span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">group </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">operator </span><span class="s4">= </span><span class="s1">operator</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">BOOLEANTYPE</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_is_implicitly_boolean </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">and_</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">initial_clause</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
            <span class="s1">Literal</span><span class="s4">[</span><span class="s3">True</span><span class="s4">], </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">], </span><span class="s1">_NoArg</span>
        <span class="s4">] = </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">clauses</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]:</span>
        <span class="s2">r&quot;&quot;&quot;Produce a conjunction of expressions joined by ``AND``. 
 
        See :func:`_sql.and_` for full documentation. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_construct</span><span class="s4">(</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">and_</span><span class="s4">,</span>
            <span class="s1">True_</span><span class="s4">.</span><span class="s1">_singleton</span><span class="s4">,</span>
            <span class="s1">False_</span><span class="s4">.</span><span class="s1">_singleton</span><span class="s4">,</span>
            <span class="s1">initial_clause</span><span class="s4">,</span>
            <span class="s4">*</span><span class="s1">clauses</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">or_</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">initial_clause</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
            <span class="s1">Literal</span><span class="s4">[</span><span class="s3">False</span><span class="s4">], </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">], </span><span class="s1">_NoArg</span>
        <span class="s4">] = </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">clauses</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Produce a conjunction of expressions joined by ``OR``. 
 
        See :func:`_sql.or_` for full documentation. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_construct</span><span class="s4">(</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">or_</span><span class="s4">,</span>
            <span class="s1">False_</span><span class="s4">.</span><span class="s1">_singleton</span><span class="s4">,</span>
            <span class="s1">True_</span><span class="s4">.</span><span class="s1">_singleton</span><span class="s4">,</span>
            <span class="s1">initial_clause</span><span class="s4">,</span>
            <span class="s4">*</span><span class="s1">clauses</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_select_iterable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _SelectIterable</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">self</span><span class="s4">,)</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">Self</span><span class="s4">, </span><span class="s1">Grouping</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]]:</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">clauses</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">against</span><span class="s4">=</span><span class="s1">against</span><span class="s4">)</span>


<span class="s1">and_ </span><span class="s4">= </span><span class="s1">BooleanClauseList</span><span class="s4">.</span><span class="s1">and_</span>
<span class="s1">or_ </span><span class="s4">= </span><span class="s1">BooleanClauseList</span><span class="s4">.</span><span class="s1">or_</span>


<span class="s3">class </span><span class="s1">Tuple</span><span class="s4">(</span><span class="s1">ClauseList</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">typing_Tuple</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, ...]]):</span>
    <span class="s2">&quot;&quot;&quot;Represent a SQL tuple.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;tuple&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= (</span>
        <span class="s1">ClauseList</span><span class="s4">.</span><span class="s1">_traverse_internals </span><span class="s4">+ []</span>
    <span class="s4">)</span>

    <span class="s1">type</span><span class="s4">: </span><span class="s1">TupleType</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.sqltypes&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">clauses</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">types</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">sqltypes </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_sqltypes</span>

        <span class="s3">if </span><span class="s1">types </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">init_clauses</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = [</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">, </span><span class="s1">c</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">clauses</span>
            <span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">types</span><span class="s4">) != </span><span class="s1">len</span><span class="s4">(</span><span class="s1">clauses</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                    <span class="s5">&quot;Wrong number of elements for %d-tuple: %r &quot;</span>
                    <span class="s4">% (</span><span class="s1">len</span><span class="s4">(</span><span class="s1">types</span><span class="s4">), </span><span class="s1">clauses</span><span class="s4">)</span>
                <span class="s4">)</span>
            <span class="s1">init_clauses </span><span class="s4">= [</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                    <span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">,</span>
                    <span class="s1">c</span><span class="s4">,</span>
                    <span class="s1">type_</span><span class="s4">=</span><span class="s1">typ </span><span class="s3">if not </span><span class="s1">typ</span><span class="s4">.</span><span class="s1">_isnull </span><span class="s3">else None</span><span class="s4">,</span>
                <span class="s4">)</span>
                <span class="s3">for </span><span class="s1">typ</span><span class="s4">, </span><span class="s1">c </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">types</span><span class="s4">, </span><span class="s1">clauses</span><span class="s4">)</span>
            <span class="s4">]</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">TupleType</span><span class="s4">(*[</span><span class="s1">arg</span><span class="s4">.</span><span class="s1">type </span><span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">init_clauses</span><span class="s4">])</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(*</span><span class="s1">init_clauses</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_select_iterable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _SelectIterable</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">self</span><span class="s4">,)</span>

    <span class="s3">def </span><span class="s1">_bind_param</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">expanding</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">expanding</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">BindParameter</span><span class="s4">(</span>
                <span class="s3">None</span><span class="s4">,</span>
                <span class="s1">value</span><span class="s4">=</span><span class="s1">obj</span><span class="s4">,</span>
                <span class="s1">_compared_to_operator</span><span class="s4">=</span><span class="s1">operator</span><span class="s4">,</span>
                <span class="s1">unique</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                <span class="s1">expanding</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                <span class="s1">type_</span><span class="s4">=</span><span class="s1">type_</span><span class="s4">,</span>
                <span class="s1">_compared_to_type</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">Tuple</span><span class="s4">(</span>
                <span class="s4">*[</span>
                    <span class="s1">BindParameter</span><span class="s4">(</span>
                        <span class="s3">None</span><span class="s4">,</span>
                        <span class="s1">o</span><span class="s4">,</span>
                        <span class="s1">_compared_to_operator</span><span class="s4">=</span><span class="s1">operator</span><span class="s4">,</span>
                        <span class="s1">_compared_to_type</span><span class="s4">=</span><span class="s1">compared_to_type</span><span class="s4">,</span>
                        <span class="s1">unique</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                        <span class="s1">type_</span><span class="s4">=</span><span class="s1">type_</span><span class="s4">,</span>
                    <span class="s4">)</span>
                    <span class="s3">for </span><span class="s1">o</span><span class="s4">, </span><span class="s1">compared_to_type </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">types</span><span class="s4">)</span>
                <span class="s4">]</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s0"># Tuple is parenthesized by definition.</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">Case</span><span class="s4">(</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent a ``CASE`` expression. 
 
    :class:`.Case` is produced using the :func:`.case` factory function, 
    as in:: 
 
        from sqlalchemy import case 
 
        stmt = select(users_table).\ 
                    where( 
                        case( 
                            (users_table.c.name == 'wendy', 'W'), 
                            (users_table.c.name == 'jack', 'J'), 
                            else_='E' 
                        ) 
                    ) 
 
    Details on :class:`.Case` usage is at :func:`.case`. 
 
    .. seealso:: 
 
        :func:`.case` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;case&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;value&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;whens&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_tuples</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;else_&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s0"># for case(), the type is derived from the whens.  so for the moment</span>
    <span class="s0"># users would have to cast() the case to get a specific type</span>

    <span class="s1">whens</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">typing_Tuple</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">], </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]]</span>
    <span class="s1">else_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]</span>
    <span class="s1">value</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">whens</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
            <span class="s1">typing_Tuple</span><span class="s4">[</span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">], </span><span class="s1">Any</span><span class="s4">],</span>
            <span class="s1">Mapping</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s4">],</span>
        <span class="s1">value</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">else_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">new_whens</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">_expression_collection_was_a_list</span><span class="s4">(</span>
            <span class="s5">&quot;whens&quot;</span><span class="s4">, </span><span class="s5">&quot;case&quot;</span><span class="s4">, </span><span class="s1">whens</span>
        <span class="s4">)</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">new_whens </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">dictlike_iteritems</span><span class="s4">(</span><span class="s1">new_whens</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">TypeError</span><span class="s4">:</span>
            <span class="s3">pass</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">whens </span><span class="s4">= [</span>
            <span class="s4">(</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                    <span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">,</span>
                    <span class="s1">c</span><span class="s4">,</span>
                    <span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">,</span>
                <span class="s4">).</span><span class="s1">self_group</span><span class="s4">(),</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">, </span><span class="s1">r</span><span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s4">(</span><span class="s1">c</span><span class="s4">, </span><span class="s1">r</span><span class="s4">) </span><span class="s3">in </span><span class="s1">new_whens</span>
        <span class="s4">]</span>

        <span class="s3">if </span><span class="s1">value </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">value </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">value </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">else_ </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">else_ </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">, </span><span class="s1">else_</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">else_ </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s1">type_ </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span>
            <span class="s4">(</span>
                <span class="s1">then</span><span class="s4">.</span><span class="s1">type</span>
                <span class="s0"># Iterate `whens` in reverse to match previous behaviour</span>
                <span class="s0"># where type of final element took priority</span>
                <span class="s3">for </span><span class="s4">*</span><span class="s1">_</span><span class="s4">, </span><span class="s1">then </span><span class="s3">in </span><span class="s1">reversed</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">whens</span><span class="s4">)</span>
                <span class="s3">if not </span><span class="s1">then</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">_isnull</span>
            <span class="s4">),</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">else_</span><span class="s4">.</span><span class="s1">type </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">else_ </span><span class="s3">is not None else </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">NULLTYPE</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">cast</span><span class="s4">(</span><span class="s1">_T</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">list</span><span class="s4">(</span>
            <span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(*[</span><span class="s1">x</span><span class="s4">.</span><span class="s1">_from_objects </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_children</span><span class="s4">()])</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">Cast</span><span class="s4">(</span><span class="s1">WrapsColumnExpression</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent a ``CAST`` expression. 
 
    :class:`.Cast` is produced using the :func:`.cast` factory function, 
    as in:: 
 
        from sqlalchemy import cast, Numeric 
 
        stmt = select(cast(product_table.c.unit_price, Numeric(10, 4))) 
 
    Details on :class:`.Cast` usage is at :func:`.cast`. 
 
    .. seealso:: 
 
        :ref:`tutorial_casts` 
 
        :func:`.cast` 
 
        :func:`.try_cast` 
 
        :func:`.type_coerce` - an alternative to CAST that coerces the type 
        on the Python side only, which is often sufficient to generate the 
        correct SQL and data coercion. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;cast&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;clause&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;type&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_type</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">clause</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s1">type</span><span class="s4">: </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
    <span class="s1">typeclause</span><span class="s4">: </span><span class="s1">TypeClause</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">expression</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">type_</span><span class="s4">: </span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">to_instance</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">clause </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">,</span>
            <span class="s1">expression</span><span class="s4">,</span>
            <span class="s1">type_</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">,</span>
            <span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">typeclause </span><span class="s4">= </span><span class="s1">TypeClause</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">clause</span><span class="s4">.</span><span class="s1">_from_objects</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">wrapped_column_expression</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">clause</span>


<span class="s3">class </span><span class="s1">TryCast</span><span class="s4">(</span><span class="s1">Cast</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent a TRY_CAST expression. 
 
    Details on :class:`.TryCast` usage is at :func:`.try_cast`. 
 
    .. seealso:: 
 
        :func:`.try_cast` 
 
        :ref:`tutorial_casts` 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;try_cast&quot;</span>
    <span class="s1">inherit_cache </span><span class="s4">= </span><span class="s3">True</span>


<span class="s3">class </span><span class="s1">TypeCoerce</span><span class="s4">(</span><span class="s1">WrapsColumnExpression</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent a Python-side type-coercion wrapper. 
 
    :class:`.TypeCoerce` supplies the :func:`_expression.type_coerce` 
    function; see that function for usage details. 
 
    .. seealso:: 
 
        :func:`_expression.type_coerce` 
 
        :func:`.cast` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;type_coerce&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;clause&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;type&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_type</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">clause</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s1">type</span><span class="s4">: </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">expression</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">type_</span><span class="s4">: </span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">to_instance</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">clause </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">,</span>
            <span class="s1">expression</span><span class="s4">,</span>
            <span class="s1">type_</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">,</span>
            <span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">clause</span><span class="s4">.</span><span class="s1">_from_objects</span>

    <span class="s4">@</span><span class="s1">HasMemoized</span><span class="s4">.</span><span class="s1">memoized_attribute</span>
    <span class="s3">def </span><span class="s1">typed_expression</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">clause</span><span class="s4">, </span><span class="s1">BindParameter</span><span class="s4">):</span>
            <span class="s1">bp </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">clause</span><span class="s4">.</span><span class="s1">_clone</span><span class="s4">()</span>
            <span class="s1">bp</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span>
            <span class="s3">return </span><span class="s1">bp</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">clause</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">wrapped_column_expression</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">clause</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; TypeCoerce</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s1">grouped </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">clause</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">against</span><span class="s4">=</span><span class="s1">against</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">grouped </span><span class="s3">is not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">clause</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">TypeCoerce</span><span class="s4">(</span><span class="s1">grouped</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">Extract</span><span class="s4">(</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent a SQL EXTRACT clause, ``extract(field FROM expr)``.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;extract&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;expr&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;field&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_string</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">expr</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s1">field</span><span class="s4">: </span><span class="s1">str</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">field</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">expr</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">INTEGERTYPE</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">field </span><span class="s4">= </span><span class="s1">field</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">expr </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">, </span><span class="s1">expr</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span><span class="s4">.</span><span class="s1">_from_objects</span>


<span class="s3">class </span><span class="s1">_label_reference</span><span class="s4">(</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Wrap a column expression as it appears in a 'reference' context. 
 
    This expression is any that includes an _order_by_label_element, 
    which is a Label, or a DESC / ASC construct wrapping a Label. 
 
    The production of _label_reference() should occur when an expression 
    is added to this context; this includes the ORDER BY or GROUP BY of a 
    SELECT statement, as well as a few other places, such as the ORDER BY 
    within an OVER clause. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;label_reference&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;element&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">)</span>
    <span class="s4">]</span>

    <span class="s1">element</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">element</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s4">[]</span>


<span class="s3">class </span><span class="s1">_textual_label_reference</span><span class="s4">(</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]):</span>
    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;textual_label_reference&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;element&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_string</span><span class="s4">)</span>
    <span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">: </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">element</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_text_clause</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; TextClause</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">TextClause</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">UnaryExpression</span><span class="s4">(</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Define a 'unary' expression. 
 
    A unary expression has a single column expression 
    and an operator.  The operator can be placed on the left 
    (where it is called the 'operator') or right (where it is called the 
    'modifier') of the column expression. 
 
    :class:`.UnaryExpression` is the basis for several unary operators 
    including those used by :func:`.desc`, :func:`.asc`, :func:`.distinct`, 
    :func:`.nulls_first` and :func:`.nulls_last`. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;unary&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;element&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;operator&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_operator</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;modifier&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_operator</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">element</span><span class="s4">: </span><span class="s1">ClauseElement</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">element</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">operator</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">modifier</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">type_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">wraps_column_expression</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">operator </span><span class="s4">= </span><span class="s1">operator</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">modifier </span><span class="s4">= </span><span class="s1">modifier</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_propagate_attrs </span><span class="s4">= </span><span class="s1">element</span><span class="s4">.</span><span class="s1">_propagate_attrs</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">element</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">(</span>
            <span class="s1">against</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">operator </span><span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">modifier</span>
        <span class="s4">)</span>

        <span class="s0"># if type is None, we get NULLTYPE, which is our _T.  But I don't</span>
        <span class="s0"># know how to get the overloads to express that correctly</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">to_instance</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">)  </span><span class="s0"># type: ignore</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">wraps_column_expression </span><span class="s4">= </span><span class="s1">wraps_column_expression</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_create_nulls_first</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">column</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; UnaryExpression</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">UnaryExpression</span><span class="s4">(</span>
            <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ByOfRole</span><span class="s4">, </span><span class="s1">column</span><span class="s4">),</span>
            <span class="s1">modifier</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">nulls_first_op</span><span class="s4">,</span>
            <span class="s1">wraps_column_expression</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_create_nulls_last</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">column</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; UnaryExpression</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">UnaryExpression</span><span class="s4">(</span>
            <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ByOfRole</span><span class="s4">, </span><span class="s1">column</span><span class="s4">),</span>
            <span class="s1">modifier</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">nulls_last_op</span><span class="s4">,</span>
            <span class="s1">wraps_column_expression</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_create_desc</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">column</span><span class="s4">: </span><span class="s1">_ColumnExpressionOrStrLabelArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; UnaryExpression</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">UnaryExpression</span><span class="s4">(</span>
            <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ByOfRole</span><span class="s4">, </span><span class="s1">column</span><span class="s4">),</span>
            <span class="s1">modifier</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">desc_op</span><span class="s4">,</span>
            <span class="s1">wraps_column_expression</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_create_asc</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">column</span><span class="s4">: </span><span class="s1">_ColumnExpressionOrStrLabelArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; UnaryExpression</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">UnaryExpression</span><span class="s4">(</span>
            <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ByOfRole</span><span class="s4">, </span><span class="s1">column</span><span class="s4">),</span>
            <span class="s1">modifier</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">asc_op</span><span class="s4">,</span>
            <span class="s1">wraps_column_expression</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_create_distinct</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">expr</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; UnaryExpression</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s1">col_expr</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">] = </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">, </span><span class="s1">expr</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">UnaryExpression</span><span class="s4">(</span>
            <span class="s1">col_expr</span><span class="s4">,</span>
            <span class="s1">operator</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">distinct_op</span><span class="s4">,</span>
            <span class="s1">type_</span><span class="s4">=</span><span class="s1">col_expr</span><span class="s4">.</span><span class="s1">type</span><span class="s4">,</span>
            <span class="s1">wraps_column_expression</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_create_bitwise_not</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">expr</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; UnaryExpression</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s1">col_expr</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">] = </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">, </span><span class="s1">expr</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">UnaryExpression</span><span class="s4">(</span>
            <span class="s1">col_expr</span><span class="s4">,</span>
            <span class="s1">operator</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">bitwise_not_op</span><span class="s4">,</span>
            <span class="s1">type_</span><span class="s4">=</span><span class="s1">col_expr</span><span class="s4">.</span><span class="s1">type</span><span class="s4">,</span>
            <span class="s1">wraps_column_expression</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_order_by_label_element</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">Label</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">if </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_order_by_modifier</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">modifier</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_order_by_label_element</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return None</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_from_objects</span>

    <span class="s3">def </span><span class="s1">_negate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">_type_affinity </span><span class="s3">is </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">BOOLEANTYPE</span><span class="s4">.</span><span class="s1">_type_affinity</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">UnaryExpression</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">against</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">inv</span><span class="s4">),</span>
                <span class="s1">operator</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">inv</span><span class="s4">,</span>
                <span class="s1">type_</span><span class="s4">=</span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">BOOLEANTYPE</span><span class="s4">,</span>
                <span class="s1">wraps_column_expression</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">wraps_column_expression</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">ClauseElement</span><span class="s4">.</span><span class="s1">_negate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">Self</span><span class="s4">, </span><span class="s1">Grouping</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">operator </span><span class="s3">and </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_precedent</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">, </span><span class="s1">against</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">Grouping</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">CollectionAggregate</span><span class="s4">(</span><span class="s1">UnaryExpression</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Forms the basis for right-hand collection operator modifiers 
    ANY and ALL. 
 
    The ANY and ALL keywords are available in different ways on different 
    backends.  On PostgreSQL, they only work for an ARRAY type.  On 
    MySQL, they only work for subqueries. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">inherit_cache </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">_is_collection_aggregate </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_create_any</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">expr</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; CollectionAggregate</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]:</span>
        <span class="s1">col_expr</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">] = </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">,</span>
            <span class="s1">expr</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">col_expr </span><span class="s4">= </span><span class="s1">col_expr</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">CollectionAggregate</span><span class="s4">(</span>
            <span class="s1">col_expr</span><span class="s4">,</span>
            <span class="s1">operator</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">any_op</span><span class="s4">,</span>
            <span class="s1">type_</span><span class="s4">=</span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">BOOLEANTYPE</span><span class="s4">,</span>
            <span class="s1">wraps_column_expression</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_create_all</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">expr</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; CollectionAggregate</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]:</span>
        <span class="s1">col_expr</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">] = </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">,</span>
            <span class="s1">expr</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">col_expr </span><span class="s4">= </span><span class="s1">col_expr</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">CollectionAggregate</span><span class="s4">(</span>
            <span class="s1">col_expr</span><span class="s4">,</span>
            <span class="s1">operator</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">all_op</span><span class="s4">,</span>
            <span class="s1">type_</span><span class="s4">=</span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">BOOLEANTYPE</span><span class="s4">,</span>
            <span class="s1">wraps_column_expression</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s0"># operate and reverse_operate are hardwired to</span>
    <span class="s0"># dispatch onto the type comparator directly, so that we can</span>
    <span class="s0"># ensure &quot;reversed&quot; behavior.</span>
    <span class="s3">def </span><span class="s1">operate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">op</span><span class="s4">, *</span><span class="s1">other</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_comparison</span><span class="s4">(</span><span class="s1">op</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                <span class="s5">&quot;Only comparison operators may be used with ANY/ALL&quot;</span>
            <span class="s4">)</span>
        <span class="s1">kwargs</span><span class="s4">[</span><span class="s5">&quot;reverse&quot;</span><span class="s4">] = </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">comparator</span><span class="s4">.</span><span class="s1">operate</span><span class="s4">(</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">mirror</span><span class="s4">(</span><span class="s1">op</span><span class="s4">), *</span><span class="s1">other</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">reverse_operate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">op</span><span class="s4">, </span><span class="s1">other</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s0"># comparison operators should never call reverse_operate</span>
        <span class="s3">assert not </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_comparison</span><span class="s4">(</span><span class="s1">op</span><span class="s4">)</span>
        <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
            <span class="s5">&quot;Only comparison operators may be used with ANY/ALL&quot;</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">AsBoolean</span><span class="s4">(</span><span class="s1">WrapsColumnExpression</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">], </span><span class="s1">UnaryExpression</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]):</span>
    <span class="s1">inherit_cache </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">, </span><span class="s1">negate</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">element</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">BOOLEANTYPE</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">operator </span><span class="s4">= </span><span class="s1">operator</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">negate </span><span class="s4">= </span><span class="s1">negate</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">modifier </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">wraps_column_expression </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_is_implicitly_boolean </span><span class="s4">= </span><span class="s1">element</span><span class="s4">.</span><span class="s1">_is_implicitly_boolean</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">wrapped_column_expression</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_negate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">, (</span><span class="s1">True_</span><span class="s4">, </span><span class="s1">False_</span><span class="s4">)):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_negate</span><span class="s4">()</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">AsBoolean</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">negate</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">BinaryExpression</span><span class="s4">(</span><span class="s1">OperatorExpression</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent an expression that is ``LEFT &lt;operator&gt; RIGHT``. 
 
    A :class:`.BinaryExpression` is generated automatically 
    whenever two column expressions are used in a Python binary expression: 
 
    .. sourcecode:: pycon+sql 
 
        &gt;&gt;&gt; from sqlalchemy.sql import column 
        &gt;&gt;&gt; column('a') + column('b') 
        &lt;sqlalchemy.sql.expression.BinaryExpression object at 0x101029dd0&gt; 
        &gt;&gt;&gt; print(column('a') + column('b')) 
        {printsql}a + b 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;binary&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;left&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;right&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;operator&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_operator</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;negate&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_operator</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;modifiers&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_plain_dict</span><span class="s4">),</span>
        <span class="s4">(</span>
            <span class="s5">&quot;type&quot;</span><span class="s4">,</span>
            <span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_type</span><span class="s4">,</span>
        <span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">_cache_key_traversal </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;left&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;right&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;operator&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_operator</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;modifiers&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_plain_dict</span><span class="s4">),</span>
        <span class="s0"># &quot;type&quot; affects JSON CAST operators, so while redundant in most cases,</span>
        <span class="s0"># is needed for that one</span>
        <span class="s4">(</span>
            <span class="s5">&quot;type&quot;</span><span class="s4">,</span>
            <span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_type</span><span class="s4">,</span>
        <span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">_is_implicitly_boolean </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s5">&quot;&quot;&quot;Indicates that any database will know this is a boolean expression 
    even if the database does not have an explicit boolean datatype. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">modifiers</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Mapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]]</span>

    <span class="s1">left</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s1">right</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">left</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">right</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">operator</span><span class="s4">: </span><span class="s1">OperatorType</span><span class="s4">,</span>
        <span class="s1">type_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">negate</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">modifiers</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Mapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s0"># allow compatibility with libraries that</span>
        <span class="s0"># refer to BinaryExpression directly and pass strings</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">operator</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
            <span class="s1">operator </span><span class="s4">= </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">custom_op</span><span class="s4">(</span><span class="s1">operator</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_orig </span><span class="s4">= (</span><span class="s1">left</span><span class="s4">.</span><span class="s1">__hash__</span><span class="s4">(), </span><span class="s1">right</span><span class="s4">.</span><span class="s1">__hash__</span><span class="s4">())</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_propagate_attrs </span><span class="s4">= </span><span class="s1">left</span><span class="s4">.</span><span class="s1">_propagate_attrs </span><span class="s3">or </span><span class="s1">right</span><span class="s4">.</span><span class="s1">_propagate_attrs</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">left </span><span class="s4">= </span><span class="s1">left</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">against</span><span class="s4">=</span><span class="s1">operator</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">right </span><span class="s4">= </span><span class="s1">right</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">against</span><span class="s4">=</span><span class="s1">operator</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">operator </span><span class="s4">= </span><span class="s1">operator</span>

        <span class="s0"># if type is None, we get NULLTYPE, which is our _T.  But I don't</span>
        <span class="s0"># know how to get the overloads to express that correctly</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">to_instance</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">)  </span><span class="s0"># type: ignore</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">negate </span><span class="s4">= </span><span class="s1">negate</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_is_implicitly_boolean </span><span class="s4">= </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_boolean</span><span class="s4">(</span><span class="s1">operator</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">modifiers </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">modifiers </span><span class="s4">= {}</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">modifiers </span><span class="s4">= </span><span class="s1">modifiers</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_flattened_operator_clauses</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; typing_Tuple</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], ...]:</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">left</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">right</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__bool__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Implement Python-side &quot;bool&quot; for BinaryExpression as a 
        simple &quot;identity&quot; check for the left and right attributes, 
        if the operator is &quot;eq&quot; or &quot;ne&quot;.  Otherwise the expression 
        continues to not support &quot;bool&quot; like all other column expressions. 
 
        The rationale here is so that ColumnElement objects can be hashable. 
        What?  Well, suppose you do this:: 
 
            c1, c2 = column('x'), column('y') 
            s1 = set([c1, c2]) 
 
        We do that **a lot**, columns inside of sets is an extremely basic 
        thing all over the ORM for example. 
 
        So what happens if we do this? :: 
 
            c1 in s1 
 
        Hashing means it will normally use ``__hash__()`` of the object, 
        but in case of hash collision, it's going to also do ``c1 == c1`` 
        and/or ``c1 == c2`` inside.  Those operations need to return a 
        True/False value.   But because we override ``==`` and ``!=``, they're 
        going to get a BinaryExpression.  Hence we implement ``__bool__`` here 
        so that these comparisons behave in this particular context mostly 
        like regular object comparisons.  Thankfully Python is OK with 
        that!  Otherwise we'd have to use special set classes for columns 
        (which we used to do, decades ago). 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">operator </span><span class="s3">in </span><span class="s4">(</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">eq</span><span class="s4">, </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">ne</span><span class="s4">):</span>
            <span class="s0"># this is using the eq/ne operator given int hash values,</span>
            <span class="s0"># rather than Operator, so that &quot;bool&quot; can be based on</span>
            <span class="s0"># identity</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">(*</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_orig</span><span class="s4">)  </span><span class="s0"># type: ignore</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;Boolean value of this clause is not defined&quot;</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">typing</span><span class="s4">.</span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s3">def </span><span class="s1">__invert__</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">: </span><span class="s1">BinaryExpression</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
        <span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">left</span><span class="s4">.</span><span class="s1">_from_objects </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">right</span><span class="s4">.</span><span class="s1">_from_objects</span>

    <span class="s3">def </span><span class="s1">_negate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">negate </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">BinaryExpression</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">left</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">right</span><span class="s4">.</span><span class="s1">_negate_in_binary</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">negate</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">),</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">negate</span><span class="s4">,</span>
                <span class="s1">negate</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">operator</span><span class="s4">,</span>
                <span class="s1">type_</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">,</span>
                <span class="s1">modifiers</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">modifiers</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">().</span><span class="s1">_negate</span><span class="s4">()</span>


<span class="s3">class </span><span class="s1">Slice</span><span class="s4">(</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent SQL for a Python array-slice object. 
 
    This is not a specific SQL construct at this level, but 
    may be interpreted by specific dialects, e.g. PostgreSQL. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;slice&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;start&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;stop&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;step&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">start</span><span class="s4">, </span><span class="s1">stop</span><span class="s4">, </span><span class="s1">step</span><span class="s4">, </span><span class="s1">_name</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">,</span>
            <span class="s1">start</span><span class="s4">,</span>
            <span class="s1">name</span><span class="s4">=</span><span class="s1">_name</span><span class="s4">,</span>
            <span class="s1">type_</span><span class="s4">=</span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">INTEGERTYPE</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">stop </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">,</span>
            <span class="s1">stop</span><span class="s4">,</span>
            <span class="s1">name</span><span class="s4">=</span><span class="s1">_name</span><span class="s4">,</span>
            <span class="s1">type_</span><span class="s4">=</span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">INTEGERTYPE</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">step </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">,</span>
            <span class="s1">step</span><span class="s4">,</span>
            <span class="s1">name</span><span class="s4">=</span><span class="s1">_name</span><span class="s4">,</span>
            <span class="s1">type_</span><span class="s4">=</span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">INTEGERTYPE</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">NULLTYPE</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s3">assert </span><span class="s1">against </span><span class="s3">is </span><span class="s1">operator</span><span class="s4">.</span><span class="s1">getitem</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">IndexExpression</span><span class="s4">(</span><span class="s1">BinaryExpression</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent the class of expressions that are like an &quot;index&quot; 
    operation.&quot;&quot;&quot;</span>

    <span class="s1">inherit_cache </span><span class="s4">= </span><span class="s3">True</span>


<span class="s3">class </span><span class="s1">GroupedElement</span><span class="s4">(</span><span class="s1">DQLDMLClauseElement</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represent any parenthesized expression&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;grouping&quot;</span>

    <span class="s1">element</span><span class="s4">: </span><span class="s1">ClauseElement</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_ungroup</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_ungroup</span><span class="s4">()</span>


<span class="s3">class </span><span class="s1">Grouping</span><span class="s4">(</span><span class="s1">GroupedElement</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent a grouping within a column expression&quot;&quot;&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;element&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;type&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_type</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">_cache_key_traversal </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;element&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">element</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">TextClause</span><span class="s4">, </span><span class="s1">ClauseList</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">TextClause</span><span class="s4">, </span><span class="s1">ClauseList</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">element</span>

        <span class="s0"># nulltype assignment issue</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">element</span><span class="s4">, </span><span class="s5">&quot;type&quot;</span><span class="s4">, </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">NULLTYPE</span><span class="s4">)  </span><span class="s0"># type: ignore</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_propagate_attrs </span><span class="s4">= </span><span class="s1">element</span><span class="s4">.</span><span class="s1">_propagate_attrs</span>

    <span class="s3">def </span><span class="s1">_with_binary_element_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_with_binary_element_type</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">))</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_is_implicitly_boolean</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_is_implicitly_boolean</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_tq_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">, </span><span class="s5">&quot;_tq_label&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_anon_name_label</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_proxies</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">[]</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_from_objects</span>

    <span class="s3">def </span><span class="s1">__getattr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__getstate__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">{</span><span class="s5">&quot;element&quot;</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">, </span><span class="s5">&quot;type&quot;</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__setstate__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">state</span><span class="s4">[</span><span class="s5">&quot;element&quot;</span><span class="s4">]</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">state</span><span class="s4">[</span><span class="s5">&quot;type&quot;</span><span class="s4">]</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
        <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">: ...</span>


<span class="s3">class </span><span class="s1">_OverrideBinds</span><span class="s4">(</span><span class="s1">Grouping</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;used by cache_key-&gt;_apply_params_to_element to allow compilation / 
    execution of a SQL element that's been cached, using an alternate set of 
    bound parameter values. 
 
    This is used by the ORM to swap new parameter values into expressions 
    that are embedded into loader options like with_expression(), 
    selectinload().  Previously, this task was accomplished using the 
    .params() method which would perform a deep-copy instead.  This deep 
    copy proved to be too expensive for more complex expressions. 
 
    See #11085 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;override_binds&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">element</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
        <span class="s1">bindparams</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">BindParameter</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
        <span class="s1">replaces_params</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">BindParameter</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">element</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">translate </span><span class="s4">= {</span>
            <span class="s1">k</span><span class="s4">.</span><span class="s1">key</span><span class="s4">: </span><span class="s1">v</span><span class="s4">.</span><span class="s1">value </span><span class="s3">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">replaces_params</span><span class="s4">, </span><span class="s1">bindparams</span><span class="s4">)</span>
        <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">_gen_cache_key</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">anon_map</span><span class="s4">: </span><span class="s1">anon_map</span><span class="s4">, </span><span class="s1">bindparams</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">BindParameter</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">typing_Tuple</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, ...]]:</span>
        <span class="s2">&quot;&quot;&quot;generate a cache key for the given element, substituting its bind 
        values for the translation values present.&quot;&quot;&quot;</span>

        <span class="s1">existing_bps</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">BindParameter</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = []</span>
        <span class="s1">ck </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_gen_cache_key</span><span class="s4">(</span><span class="s1">anon_map</span><span class="s4">, </span><span class="s1">existing_bps</span><span class="s4">)</span>

        <span class="s1">bindparams</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span>
            <span class="s4">(</span>
                <span class="s1">bp</span><span class="s4">.</span><span class="s1">_with_value</span><span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">translate</span><span class="s4">[</span><span class="s1">bp</span><span class="s4">.</span><span class="s1">key</span><span class="s4">], </span><span class="s1">maintain_key</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">required</span><span class="s4">=</span><span class="s3">False</span>
                <span class="s4">)</span>
                <span class="s3">if </span><span class="s1">bp</span><span class="s4">.</span><span class="s1">key </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">translate</span>
                <span class="s3">else </span><span class="s1">bp</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">bp </span><span class="s3">in </span><span class="s1">existing_bps</span>
        <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">ck</span>


<span class="s3">class </span><span class="s1">_OverRange</span><span class="s4">(</span><span class="s1">Enum</span><span class="s4">):</span>
    <span class="s1">RANGE_UNBOUNDED </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s1">RANGE_CURRENT </span><span class="s4">= </span><span class="s6">1</span>


<span class="s1">RANGE_UNBOUNDED </span><span class="s4">= </span><span class="s1">_OverRange</span><span class="s4">.</span><span class="s1">RANGE_UNBOUNDED</span>
<span class="s1">RANGE_CURRENT </span><span class="s4">= </span><span class="s1">_OverRange</span><span class="s4">.</span><span class="s1">RANGE_CURRENT</span>

<span class="s1">_IntOrRange </span><span class="s4">= </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">int</span><span class="s4">, </span><span class="s1">_OverRange</span><span class="s4">]</span>


<span class="s3">class </span><span class="s1">Over</span><span class="s4">(</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent an OVER clause. 
 
    This is a special operator against a so-called 
    &quot;window&quot; function, as well as any aggregate function, 
    which produces results relative to the result set 
    itself.  Most modern SQL backends now support window functions. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;over&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;element&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;order_by&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;partition_by&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;range_&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_plain_obj</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;rows&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_plain_obj</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">order_by</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ClauseList</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s1">partition_by</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ClauseList</span><span class="s4">] = </span><span class="s3">None</span>

    <span class="s1">element</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
    <span class="s5">&quot;&quot;&quot;The underlying expression object to which this :class:`.Over` 
    object refers.&quot;&quot;&quot;</span>

    <span class="s1">range_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">typing_Tuple</span><span class="s4">[</span><span class="s1">_IntOrRange</span><span class="s4">, </span><span class="s1">_IntOrRange</span><span class="s4">]]</span>
    <span class="s1">rows</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">typing_Tuple</span><span class="s4">[</span><span class="s1">_IntOrRange</span><span class="s4">, </span><span class="s1">_IntOrRange</span><span class="s4">]]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">element</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
        <span class="s1">partition_by</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_ByArgument</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">order_by</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_ByArgument</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">range_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">typing_Tuple</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">], </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">rows</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">typing_Tuple</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">], </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">element</span>
        <span class="s3">if </span><span class="s1">order_by </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">order_by </span><span class="s4">= </span><span class="s1">ClauseList</span><span class="s4">(</span>
                <span class="s4">*</span><span class="s1">util</span><span class="s4">.</span><span class="s1">to_list</span><span class="s4">(</span><span class="s1">order_by</span><span class="s4">), </span><span class="s1">_literal_as_text_role</span><span class="s4">=</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ByOfRole</span>
            <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">partition_by </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">partition_by </span><span class="s4">= </span><span class="s1">ClauseList</span><span class="s4">(</span>
                <span class="s4">*</span><span class="s1">util</span><span class="s4">.</span><span class="s1">to_list</span><span class="s4">(</span><span class="s1">partition_by</span><span class="s4">),</span>
                <span class="s1">_literal_as_text_role</span><span class="s4">=</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ByOfRole</span><span class="s4">,</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">range_</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">range_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_interpret_range</span><span class="s4">(</span><span class="s1">range_</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">rows</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                    <span class="s5">&quot;'range_' and 'rows' are mutually exclusive&quot;</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">rows </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">elif </span><span class="s1">rows</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">rows </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_interpret_range</span><span class="s4">(</span><span class="s1">rows</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">range_ </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">rows </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">range_ </span><span class="s4">= </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__reduce__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">, (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">partition_by</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">order_by</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">range_</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">rows</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_interpret_range</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">range_</span><span class="s4">: </span><span class="s1">typing_Tuple</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_IntOrRange</span><span class="s4">], </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_IntOrRange</span><span class="s4">]],</span>
    <span class="s4">) </span><span class="s1">-&gt; typing_Tuple</span><span class="s4">[</span><span class="s1">_IntOrRange</span><span class="s4">, </span><span class="s1">_IntOrRange</span><span class="s4">]:</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">range_</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">) </span><span class="s3">or </span><span class="s1">len</span><span class="s4">(</span><span class="s1">range_</span><span class="s4">) != </span><span class="s6">2</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span><span class="s5">&quot;2-tuple expected for range/rows&quot;</span><span class="s4">)</span>

        <span class="s1">r0</span><span class="s4">, </span><span class="s1">r1 </span><span class="s4">= </span><span class="s1">range_</span>

        <span class="s1">lower</span><span class="s4">: </span><span class="s1">_IntOrRange</span>
        <span class="s1">upper</span><span class="s4">: </span><span class="s1">_IntOrRange</span>

        <span class="s3">if </span><span class="s1">r0 </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">lower </span><span class="s4">= </span><span class="s1">RANGE_UNBOUNDED</span>
        <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">r0</span><span class="s4">, </span><span class="s1">_OverRange</span><span class="s4">):</span>
            <span class="s1">lower </span><span class="s4">= </span><span class="s1">r0</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">lower </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">r0</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                    <span class="s5">&quot;Integer or None expected for range value&quot;</span>
                <span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">lower </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
                    <span class="s1">lower </span><span class="s4">= </span><span class="s1">RANGE_CURRENT</span>

        <span class="s3">if </span><span class="s1">r1 </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">upper </span><span class="s4">= </span><span class="s1">RANGE_UNBOUNDED</span>
        <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">r1</span><span class="s4">, </span><span class="s1">_OverRange</span><span class="s4">):</span>
            <span class="s1">upper </span><span class="s4">= </span><span class="s1">r1</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">upper </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">r1</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                    <span class="s5">&quot;Integer or None expected for range value&quot;</span>
                <span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">upper </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
                    <span class="s1">upper </span><span class="s4">= </span><span class="s1">RANGE_CURRENT</span>

        <span class="s3">return </span><span class="s1">lower</span><span class="s4">, </span><span class="s1">upper</span>

    <span class="s3">if not </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
        <span class="s3">def </span><span class="s1">type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:  </span><span class="s0"># noqa: A001</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">type</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">list</span><span class="s4">(</span>
            <span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(</span>
                <span class="s4">*[</span>
                    <span class="s1">c</span><span class="s4">.</span><span class="s1">_from_objects</span>
                    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">partition_by</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">order_by</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">c </span><span class="s3">is not None</span>
                <span class="s4">]</span>
            <span class="s4">)</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">WithinGroup</span><span class="s4">(</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent a WITHIN GROUP (ORDER BY) clause. 
 
    This is a special operator against so-called 
    &quot;ordered set aggregate&quot; and &quot;hypothetical 
    set aggregate&quot; functions, including ``percentile_cont()``, 
    ``rank()``, ``dense_rank()``, etc. 
 
    It's supported only by certain database backends, such as PostgreSQL, 
    Oracle and MS SQL Server. 
 
    The :class:`.WithinGroup` construct extracts its type from the 
    method :meth:`.FunctionElement.within_group_type`.  If this returns 
    ``None``, the function's ``.type`` is used. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;withingroup&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;element&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;order_by&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">order_by</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ClauseList</span><span class="s4">] = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">element</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">FunctionElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">], </span><span class="s1">FunctionFilter</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]],</span>
        <span class="s4">*</span><span class="s1">order_by</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">element </span><span class="s4">= </span><span class="s1">element</span>
        <span class="s3">if </span><span class="s1">order_by </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">order_by </span><span class="s4">= </span><span class="s1">ClauseList</span><span class="s4">(</span>
                <span class="s4">*</span><span class="s1">util</span><span class="s4">.</span><span class="s1">to_list</span><span class="s4">(</span><span class="s1">order_by</span><span class="s4">), </span><span class="s1">_literal_as_text_role</span><span class="s4">=</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ByOfRole</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__reduce__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">, (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">,) + (</span>
            <span class="s1">tuple</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">order_by</span><span class="s4">) </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">order_by </span><span class="s3">is not None else </span><span class="s4">()</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">over</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">partition_by</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_ByArgument</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">order_by</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_ByArgument</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">rows</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">typing_Tuple</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">], </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">range_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">typing_Tuple</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">], </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Over</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Produce an OVER clause against this :class:`.WithinGroup` 
        construct. 
 
        This function has the same signature as that of 
        :meth:`.FunctionElement.over`. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Over</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">partition_by</span><span class="s4">=</span><span class="s1">partition_by</span><span class="s4">,</span>
            <span class="s1">order_by</span><span class="s4">=</span><span class="s1">order_by</span><span class="s4">,</span>
            <span class="s1">range_</span><span class="s4">=</span><span class="s1">range_</span><span class="s4">,</span>
            <span class="s1">rows</span><span class="s4">=</span><span class="s1">rows</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">filter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">filter</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__criterion0</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">],</span>
        <span class="s4">*</span><span class="s1">criterion</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; FunctionFilter</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">filter</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *</span><span class="s1">criterion</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">Self</span><span class="s4">, </span><span class="s1">FunctionFilter</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;Produce a FILTER clause against this function.&quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">criterion</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>
        <span class="s3">return </span><span class="s1">FunctionFilter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">criterion</span><span class="s4">)</span>

    <span class="s3">if not </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
        <span class="s3">def </span><span class="s1">type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:  </span><span class="s0"># noqa: A001</span>
            <span class="s1">wgt </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">within_group_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">wgt </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">wgt</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">type</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">list</span><span class="s4">(</span>
            <span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(</span>
                <span class="s4">*[</span>
                    <span class="s1">c</span><span class="s4">.</span><span class="s1">_from_objects</span>
                    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">order_by</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">c </span><span class="s3">is not None</span>
                <span class="s4">]</span>
            <span class="s4">)</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">FunctionFilter</span><span class="s4">(</span><span class="s1">Generative</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent a function FILTER clause. 
 
    This is a special operator against aggregate and window functions, 
    which controls which rows are passed to it. 
    It's supported only by certain database backends. 
 
    Invocation of :class:`.FunctionFilter` is via 
    :meth:`.FunctionElement.filter`:: 
 
        func.count(1).filter(True) 
 
    .. seealso:: 
 
        :meth:`.FunctionElement.filter` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;funcfilter&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;func&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;criterion&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">criterion</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]] = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">func</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">FunctionElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">], </span><span class="s1">WithinGroup</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]],</span>
        <span class="s4">*</span><span class="s1">criterion</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">],</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">func </span><span class="s4">= </span><span class="s1">func</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">filter</span><span class="s4">.</span><span class="s1">non_generative</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">criterion</span><span class="s4">)  </span><span class="s0"># type: ignore</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">filter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">criterion</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Produce an additional FILTER against the function. 
 
        This method adds additional criteria to the initial criteria 
        set up by :meth:`.FunctionElement.filter`. 
 
        Multiple criteria are joined together at SQL render time 
        via ``AND``. 
 
 
        &quot;&quot;&quot;</span>

        <span class="s3">for </span><span class="s1">crit </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">criterion</span><span class="s4">):</span>
            <span class="s1">crit </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">WhereHavingRole</span><span class="s4">, </span><span class="s1">crit</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">criterion </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">criterion </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">criterion </span><span class="s4">&amp; </span><span class="s1">crit</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">criterion </span><span class="s4">= </span><span class="s1">crit</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">over</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">partition_by</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span>
            <span class="s1">Union</span><span class="s4">[</span>
                <span class="s1">Iterable</span><span class="s4">[</span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
                <span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
            <span class="s4">]</span>
        <span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">order_by</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span>
            <span class="s1">Union</span><span class="s4">[</span>
                <span class="s1">Iterable</span><span class="s4">[</span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
                <span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
            <span class="s4">]</span>
        <span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">range_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">typing_Tuple</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">], </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">rows</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">typing_Tuple</span><span class="s4">[</span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">], </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Over</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Produce an OVER clause against this filtered function. 
 
        Used against aggregate or so-called &quot;window&quot; functions, 
        for database backends that support window functions. 
 
        The expression:: 
 
            func.rank().filter(MyClass.y &gt; 5).over(order_by='x') 
 
        is shorthand for:: 
 
            from sqlalchemy import over, funcfilter 
            over(funcfilter(func.rank(), MyClass.y &gt; 5), order_by='x') 
 
        See :func:`_expression.over` for a full description. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Over</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">partition_by</span><span class="s4">=</span><span class="s1">partition_by</span><span class="s4">,</span>
            <span class="s1">order_by</span><span class="s4">=</span><span class="s1">order_by</span><span class="s4">,</span>
            <span class="s1">range_</span><span class="s4">=</span><span class="s1">range_</span><span class="s4">,</span>
            <span class="s1">rows</span><span class="s4">=</span><span class="s1">rows</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">within_group</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *</span><span class="s1">order_by</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; WithinGroup</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Produce a WITHIN GROUP (ORDER BY expr) clause against 
        this function. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">WithinGroup</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">order_by</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">within_group_type</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">within_group</span><span class="s4">: </span><span class="s1">WithinGroup</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">Self</span><span class="s4">, </span><span class="s1">Grouping</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
        <span class="s3">if </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_precedent</span><span class="s4">(</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">filter_op</span><span class="s4">, </span><span class="s1">against</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">Grouping</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">if not </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
        <span class="s3">def </span><span class="s1">type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:  </span><span class="s0"># noqa: A001</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">type</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">list</span><span class="s4">(</span>
            <span class="s1">itertools</span><span class="s4">.</span><span class="s1">chain</span><span class="s4">(</span>
                <span class="s4">*[</span>
                    <span class="s1">c</span><span class="s4">.</span><span class="s1">_from_objects</span>
                    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">func</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">criterion</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">c </span><span class="s3">is not None</span>
                <span class="s4">]</span>
            <span class="s4">)</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">NamedColumn</span><span class="s4">(</span><span class="s1">KeyedColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s1">is_literal </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">table</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s1">name</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s1">key</span><span class="s4">: </span><span class="s1">str</span>

    <span class="s3">def </span><span class="s1">_compare_name_for_result</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s5">&quot;name&quot;</span><span class="s4">) </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">== </span><span class="s1">other</span><span class="s4">.</span><span class="s1">name</span><span class="s4">) </span><span class="s3">or </span><span class="s4">(</span>
            <span class="s1">hasattr</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s5">&quot;_label&quot;</span><span class="s4">) </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label </span><span class="s4">== </span><span class="s1">other</span><span class="s4">.</span><span class="s1">_label</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_memoized_property</span>
    <span class="s3">def </span><span class="s1">description</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span>

    <span class="s4">@</span><span class="s1">HasMemoized</span><span class="s4">.</span><span class="s1">memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_tq_key_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;table qualified label based on column key. 
 
        for table-bound columns this is &lt;tablename&gt;_&lt;column key/proxy key&gt;; 
 
        all other expressions it resolves to key/proxy key. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">proxy_key </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_proxy_key</span>
        <span class="s3">if </span><span class="s1">proxy_key </span><span class="s3">and </span><span class="s1">proxy_key </span><span class="s4">!= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_gen_tq_label</span><span class="s4">(</span><span class="s1">proxy_key</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tq_label</span>

    <span class="s4">@</span><span class="s1">HasMemoized</span><span class="s4">.</span><span class="s1">memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_tq_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;table qualified label based on column name. 
 
        for table-bound columns this is &lt;tablename&gt;_&lt;columnname&gt;; all other 
        expressions it resolves to .name. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_gen_tq_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">HasMemoized</span><span class="s4">.</span><span class="s1">memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_render_label_in_columns_clause</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return True</span>

    <span class="s4">@</span><span class="s1">HasMemoized</span><span class="s4">.</span><span class="s1">memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_non_anon_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span>

    <span class="s3">def </span><span class="s1">_gen_tq_label</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">dedupe_on_key</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">name</span>

    <span class="s3">def </span><span class="s1">_bind_param</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">operator</span><span class="s4">: </span><span class="s1">OperatorType</span><span class="s4">,</span>
        <span class="s1">obj</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
        <span class="s1">type_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">expanding</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; BindParameter</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">BindParameter</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">key</span><span class="s4">,</span>
            <span class="s1">obj</span><span class="s4">,</span>
            <span class="s1">_compared_to_operator</span><span class="s4">=</span><span class="s1">operator</span><span class="s4">,</span>
            <span class="s1">_compared_to_type</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">,</span>
            <span class="s1">type_</span><span class="s4">=</span><span class="s1">type_</span><span class="s4">,</span>
            <span class="s1">unique</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s1">expanding</span><span class="s4">=</span><span class="s1">expanding</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_make_proxy</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">selectable</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">key</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">name_is_truncatable</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">compound_select_cols</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">disallow_is_literal</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; typing_Tuple</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
        <span class="s1">c </span><span class="s4">= </span><span class="s1">ColumnClause</span><span class="s4">(</span>
            <span class="s4">(</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">TruncatedLabelRole</span><span class="s4">, </span><span class="s1">name </span><span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">name_is_truncatable</span>
                <span class="s3">else </span><span class="s4">(</span><span class="s1">name </span><span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">)</span>
            <span class="s4">),</span>
            <span class="s1">type_</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">,</span>
            <span class="s1">_selectable</span><span class="s4">=</span><span class="s1">selectable</span><span class="s4">,</span>
            <span class="s1">is_literal</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s1">c</span><span class="s4">.</span><span class="s1">_propagate_attrs </span><span class="s4">= </span><span class="s1">selectable</span><span class="s4">.</span><span class="s1">_propagate_attrs</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">c</span><span class="s4">.</span><span class="s1">key </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">key</span>
        <span class="s3">if </span><span class="s1">compound_select_cols</span><span class="s4">:</span>
            <span class="s1">c</span><span class="s4">.</span><span class="s1">_proxies </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">compound_select_cols</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">c</span><span class="s4">.</span><span class="s1">_proxies </span><span class="s4">= [</span><span class="s1">self</span><span class="s4">]</span>

        <span class="s3">if </span><span class="s1">selectable</span><span class="s4">.</span><span class="s1">_is_clone_of </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">c</span><span class="s4">.</span><span class="s1">_is_clone_of </span><span class="s4">= </span><span class="s1">selectable</span><span class="s4">.</span><span class="s1">_is_clone_of</span><span class="s4">.</span><span class="s1">columns</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">c</span><span class="s4">.</span><span class="s1">key</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">c</span><span class="s4">.</span><span class="s1">key</span><span class="s4">, </span><span class="s1">c</span>


<span class="s1">_PS </span><span class="s4">= </span><span class="s1">ParamSpec</span><span class="s4">(</span><span class="s5">&quot;_PS&quot;</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">Label</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">LabeledColumnExprRole</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">], </span><span class="s1">NamedColumn</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represents a column label (AS). 
 
    Represent a label, as typically applied to any column-level 
    element using the ``AS`` sql keyword. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;label&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_anon_name</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;type&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_type</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;_element&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">_cache_key_traversal </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_anon_name</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;_element&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">_element</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]</span>
    <span class="s1">name</span><span class="s4">: </span><span class="s1">str</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">],</span>
        <span class="s1">element</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
        <span class="s1">type_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">orig_element </span><span class="s4">= </span><span class="s1">element</span>
        <span class="s1">element </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">,</span>
            <span class="s1">element</span><span class="s4">,</span>
            <span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">while </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">element</span><span class="s4">, </span><span class="s1">Label</span><span class="s4">):</span>
            <span class="s0"># TODO: this is only covered in test_text.py, but nothing</span>
            <span class="s0"># fails if it's removed.  determine rationale</span>
            <span class="s1">element </span><span class="s4">= </span><span class="s1">element</span><span class="s4">.</span><span class="s1">element</span>

        <span class="s3">if </span><span class="s1">name</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">name</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">_anonymous_label</span><span class="s4">.</span><span class="s1">safe_construct</span><span class="s4">(</span>
                <span class="s1">id</span><span class="s4">(</span><span class="s1">self</span><span class="s4">), </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">element</span><span class="s4">, </span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s5">&quot;anon&quot;</span><span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">orig_element</span><span class="s4">, </span><span class="s1">Label</span><span class="s4">):</span>
                <span class="s0"># TODO: no coverage for this block, again would be in</span>
                <span class="s0"># test_text.py where the resolve_label concept is important</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_resolve_label </span><span class="s4">= </span><span class="s1">orig_element</span><span class="s4">.</span><span class="s1">_label</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">key </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tq_label </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tq_key_label </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_element </span><span class="s4">= </span><span class="s1">element</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= (</span>
            <span class="s1">type_api</span><span class="s4">.</span><span class="s1">to_instance</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">type_ </span><span class="s3">is not None</span>
            <span class="s3">else </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_element</span><span class="s4">.</span><span class="s1">type</span>
        <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_proxies </span><span class="s4">= [</span><span class="s1">element</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__reduce__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">, (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_element</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">HasMemoized</span><span class="s4">.</span><span class="s1">memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_render_label_in_columns_clause</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return True</span>

    <span class="s3">def </span><span class="s1">_bind_param</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">expanding</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">BindParameter</span><span class="s4">(</span>
            <span class="s3">None</span><span class="s4">,</span>
            <span class="s1">obj</span><span class="s4">,</span>
            <span class="s1">_compared_to_operator</span><span class="s4">=</span><span class="s1">operator</span><span class="s4">,</span>
            <span class="s1">type_</span><span class="s4">=</span><span class="s1">type_</span><span class="s4">,</span>
            <span class="s1">_compared_to_type</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">,</span>
            <span class="s1">unique</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s1">expanding</span><span class="s4">=</span><span class="s1">expanding</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_is_implicitly_boolean</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_is_implicitly_boolean</span>

    <span class="s4">@</span><span class="s1">HasMemoized</span><span class="s4">.</span><span class="s1">memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_allow_label_resolve</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_allow_label_resolve</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_order_by_label_element</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">HasMemoized</span><span class="s4">.</span><span class="s1">memoized_attribute</span>
    <span class="s3">def </span><span class="s1">element</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_element</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">against</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">as_</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">self_group</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">against</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; Label</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_apply_to_inner</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_element</span><span class="s4">.</span><span class="s1">self_group</span><span class="s4">, </span><span class="s1">against</span><span class="s4">=</span><span class="s1">against</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_negate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_apply_to_inner</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_element</span><span class="s4">.</span><span class="s1">_negate</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_apply_to_inner</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">fn</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[</span><span class="s1">_PS</span><span class="s4">, </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]],</span>
        <span class="s4">*</span><span class="s1">arg</span><span class="s4">: </span><span class="s1">_PS</span><span class="s4">.</span><span class="s1">args</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">_PS</span><span class="s4">.</span><span class="s1">kwargs</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Label</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s1">sub_element </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">(*</span><span class="s1">arg</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">sub_element </span><span class="s3">is not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_element</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">Label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">, </span><span class="s1">sub_element</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">primary_key</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">primary_key</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">foreign_keys</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">foreign_keys</span>

    <span class="s3">def </span><span class="s1">_copy_internals</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">clone</span><span class="s4">: </span><span class="s1">_CloneCallableType </span><span class="s4">= </span><span class="s1">_clone</span><span class="s4">,</span>
        <span class="s1">anonymize_labels</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_reset_memoizations</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_element </span><span class="s4">= </span><span class="s1">clone</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_element</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">anonymize_labels</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">_anonymous_label</span><span class="s4">.</span><span class="s1">safe_construct</span><span class="s4">(</span>
                <span class="s1">id</span><span class="s4">(</span><span class="s1">self</span><span class="s4">), </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">, </span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s5">&quot;anon&quot;</span><span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">key </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tq_label </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tq_key_label </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_from_objects</span>

    <span class="s3">def </span><span class="s1">_make_proxy</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">selectable</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">compound_select_cols</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; typing_Tuple</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
        <span class="s1">name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s3">if not </span><span class="s1">name </span><span class="s3">else </span><span class="s1">name</span>

        <span class="s1">key</span><span class="s4">, </span><span class="s1">e </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">element</span><span class="s4">.</span><span class="s1">_make_proxy</span><span class="s4">(</span>
            <span class="s1">selectable</span><span class="s4">,</span>
            <span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">,</span>
            <span class="s1">disallow_is_literal</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s1">name_is_truncatable</span><span class="s4">=</span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">_truncated_label</span><span class="s4">),</span>
            <span class="s1">compound_select_cols</span><span class="s4">=</span><span class="s1">compound_select_cols</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s0"># there was a note here to remove this assertion, which was here</span>
        <span class="s0"># to determine if we later could support a use case where</span>
        <span class="s0"># the key and name of a label are separate.  But I don't know what</span>
        <span class="s0"># that case was.  For now, this is an unexpected case that occurs</span>
        <span class="s0"># when a label name conflicts with other columns and select()</span>
        <span class="s0"># is attempting to disambiguate an explicit label, which is not what</span>
        <span class="s0"># the user would want.   See issue #6090.</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s4">!= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s3">and not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">, </span><span class="s1">_anonymous_label</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;Label name %s is being renamed to an anonymous label due &quot;</span>
                <span class="s5">&quot;to disambiguation &quot;</span>
                <span class="s5">&quot;which is not supported right now.  Please use unique names &quot;</span>
                <span class="s5">&quot;for explicit labels.&quot; </span><span class="s4">% (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">)</span>
            <span class="s4">)</span>

        <span class="s1">e</span><span class="s4">.</span><span class="s1">_propagate_attrs </span><span class="s4">= </span><span class="s1">selectable</span><span class="s4">.</span><span class="s1">_propagate_attrs</span>
        <span class="s1">e</span><span class="s4">.</span><span class="s1">_proxies</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">e</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">key</span><span class="s4">, </span><span class="s1">e</span>


<span class="s3">class </span><span class="s1">ColumnClause</span><span class="s4">(</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">DDLReferredColumnRole</span><span class="s4">,</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">LabeledColumnExprRole</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
    <span class="s1">roles</span><span class="s4">.</span><span class="s1">StrAsPlainColumnRole</span><span class="s4">,</span>
    <span class="s1">Immutable</span><span class="s4">,</span>
    <span class="s1">NamedColumn</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represents a column expression from any textual string. 
 
    The :class:`.ColumnClause`, a lightweight analogue to the 
    :class:`_schema.Column` class, is typically invoked using the 
    :func:`_expression.column` function, as in:: 
 
        from sqlalchemy import column 
 
        id, name = column(&quot;id&quot;), column(&quot;name&quot;) 
        stmt = select(id, name).select_from(&quot;user&quot;) 
 
    The above statement would produce SQL like:: 
 
        SELECT id, name FROM user 
 
    :class:`.ColumnClause` is the immediate superclass of the schema-specific 
    :class:`_schema.Column` object.  While the :class:`_schema.Column` 
    class has all the 
    same capabilities as :class:`.ColumnClause`, the :class:`.ColumnClause` 
    class is usable by itself in those cases where behavioral requirements 
    are limited to simple SQL expression generation.  The object has none of 
    the associations with schema-level metadata or with execution-time 
    behavior that :class:`_schema.Column` does, 
    so in that sense is a &quot;lightweight&quot; 
    version of :class:`_schema.Column`. 
 
    Full details on :class:`.ColumnClause` usage is at 
    :func:`_expression.column`. 
 
    .. seealso:: 
 
        :func:`_expression.column` 
 
        :class:`_schema.Column` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">table</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]</span>
    <span class="s1">is_literal</span><span class="s4">: </span><span class="s1">bool</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;column&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_anon_name</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;type&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_type</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;table&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;is_literal&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_boolean</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s1">onupdate</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">DefaultGenerator</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s1">default</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">DefaultGenerator</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s1">server_default</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">FetchedValue</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s1">server_onupdate</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">FetchedValue</span><span class="s4">] = </span><span class="s3">None</span>

    <span class="s1">_is_multiparam_column </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_is_star</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">is_literal </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">== </span><span class="s5">&quot;*&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">text</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">type_</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">is_literal</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">_selectable</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">key </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">text</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">table </span><span class="s4">= </span><span class="s1">_selectable</span>

        <span class="s0"># if type is None, we get NULLTYPE, which is our _T.  But I don't</span>
        <span class="s0"># know how to get the overloads to express that correctly</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">to_instance</span><span class="s4">(</span><span class="s1">type_</span><span class="s4">)  </span><span class="s0"># type: ignore</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">is_literal </span><span class="s4">= </span><span class="s1">is_literal</span>

    <span class="s3">def </span><span class="s1">get_children</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *, </span><span class="s1">column_tables</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s0"># override base get_children() to not return the Table</span>
        <span class="s0"># or selectable that is parent to this column.  Traversals</span>
        <span class="s0"># expect the columns of tables and subqueries to be leaf nodes.</span>
        <span class="s3">return </span><span class="s4">[]</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">entity_namespace</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">table </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">table</span><span class="s4">.</span><span class="s1">entity_namespace</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">entity_namespace</span>

    <span class="s3">def </span><span class="s1">_clone</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">detect_subquery_cols</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">detect_subquery_cols</span>
            <span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">table </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">table</span><span class="s4">.</span><span class="s1">_is_subquery</span>
        <span class="s4">):</span>
            <span class="s1">clone </span><span class="s4">= </span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;clone&quot;</span><span class="s4">)</span>
            <span class="s1">table </span><span class="s4">= </span><span class="s1">clone</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">table</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
            <span class="s1">new </span><span class="s4">= </span><span class="s1">table</span><span class="s4">.</span><span class="s1">c</span><span class="s4">.</span><span class="s1">corresponding_column</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">new</span>

        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">_clone</span><span class="s4">(**</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">HasMemoized_ro_memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s1">t </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">table</span>
        <span class="s3">if </span><span class="s1">t </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">[</span><span class="s1">t</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">[]</span>

    <span class="s4">@</span><span class="s1">HasMemoized</span><span class="s4">.</span><span class="s1">memoized_attribute</span>
    <span class="s3">def </span><span class="s1">_render_label_in_columns_clause</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">table </span><span class="s3">is not None</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_ddl_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_gen_tq_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">, </span><span class="s1">dedupe_on_key</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_compare_name_for_result</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">is_literal</span>
            <span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">table </span><span class="s3">is None</span>
            <span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">table</span><span class="s4">.</span><span class="s1">_is_textual</span>
            <span class="s3">or not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s5">&quot;proxy_set&quot;</span><span class="s4">)</span>
            <span class="s3">or </span><span class="s4">(</span>
                <span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">ColumnClause</span><span class="s4">)</span>
                <span class="s3">and </span><span class="s4">(</span>
                    <span class="s1">other</span><span class="s4">.</span><span class="s1">is_literal</span>
                    <span class="s3">or </span><span class="s1">other</span><span class="s4">.</span><span class="s1">table </span><span class="s3">is None</span>
                    <span class="s3">or </span><span class="s1">other</span><span class="s4">.</span><span class="s1">table</span><span class="s4">.</span><span class="s1">_is_textual</span>
                <span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s4">):</span>
            <span class="s3">return </span><span class="s4">(</span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s5">&quot;name&quot;</span><span class="s4">) </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">== </span><span class="s1">other</span><span class="s4">.</span><span class="s1">name</span><span class="s4">) </span><span class="s3">or </span><span class="s4">(</span>
                <span class="s1">hasattr</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s5">&quot;_tq_label&quot;</span><span class="s4">)</span>
                <span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_tq_label </span><span class="s4">== </span><span class="s1">other</span><span class="s4">.</span><span class="s1">_tq_label</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">other</span><span class="s4">.</span><span class="s1">proxy_set</span><span class="s4">.</span><span class="s1">intersection</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">proxy_set</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_gen_tq_label</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">dedupe_on_key</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;generate table-qualified label 
 
        for a table-bound column this is &lt;tablename&gt;_&lt;columnname&gt;. 
 
        used primarily for LABEL_STYLE_TABLENAME_PLUS_COL 
        as well as the .columns collection on a Join object. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">label</span><span class="s4">: </span><span class="s1">str</span>
        <span class="s1">t </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">table</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">is_literal</span><span class="s4">:</span>
            <span class="s3">return None</span>
        <span class="s3">elif </span><span class="s1">t </span><span class="s3">is not None and </span><span class="s1">is_named_from_clause</span><span class="s4">(</span><span class="s1">t</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">has_schema_attr</span><span class="s4">(</span><span class="s1">t</span><span class="s4">) </span><span class="s3">and </span><span class="s1">t</span><span class="s4">.</span><span class="s1">schema</span><span class="s4">:</span>
                <span class="s1">label </span><span class="s4">= </span><span class="s1">t</span><span class="s4">.</span><span class="s1">schema</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s5">&quot;.&quot;</span><span class="s4">, </span><span class="s5">&quot;_&quot;</span><span class="s4">) + </span><span class="s5">&quot;_&quot; </span><span class="s4">+ </span><span class="s1">t</span><span class="s4">.</span><span class="s1">name </span><span class="s4">+ </span><span class="s5">&quot;_&quot; </span><span class="s4">+ </span><span class="s1">name</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">assert not </span><span class="s1">TYPE_CHECKING </span><span class="s3">or </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">t</span><span class="s4">, </span><span class="s1">NamedFromClause</span><span class="s4">)</span>
                <span class="s1">label </span><span class="s4">= </span><span class="s1">t</span><span class="s4">.</span><span class="s1">name </span><span class="s4">+ </span><span class="s5">&quot;_&quot; </span><span class="s4">+ </span><span class="s1">name</span>

            <span class="s0"># propagate name quoting rules for labels.</span>
            <span class="s3">if </span><span class="s1">is_quoted_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">) </span><span class="s3">and </span><span class="s1">name</span><span class="s4">.</span><span class="s1">quote </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">is_quoted_name</span><span class="s4">(</span><span class="s1">label</span><span class="s4">):</span>
                    <span class="s1">label</span><span class="s4">.</span><span class="s1">quote </span><span class="s4">= </span><span class="s1">name</span><span class="s4">.</span><span class="s1">quote</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">label </span><span class="s4">= </span><span class="s1">quoted_name</span><span class="s4">(</span><span class="s1">label</span><span class="s4">, </span><span class="s1">name</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">is_quoted_name</span><span class="s4">(</span><span class="s1">t</span><span class="s4">.</span><span class="s1">name</span><span class="s4">) </span><span class="s3">and </span><span class="s1">t</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">quote </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s0"># can't get this situation to occur, so let's</span>
                <span class="s0"># assert false on it for now</span>
                <span class="s3">assert not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">label</span><span class="s4">, </span><span class="s1">quoted_name</span><span class="s4">)</span>
                <span class="s1">label </span><span class="s4">= </span><span class="s1">quoted_name</span><span class="s4">(</span><span class="s1">label</span><span class="s4">, </span><span class="s1">t</span><span class="s4">.</span><span class="s1">name</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">dedupe_on_key</span><span class="s4">:</span>
                <span class="s0"># ensure the label name doesn't conflict with that of an</span>
                <span class="s0"># existing column.   note that this implies that any Column</span>
                <span class="s0"># must **not** set up its _label before its parent table has</span>
                <span class="s0"># all of its other Column objects set up.  There are several</span>
                <span class="s0"># tables in the test suite which will fail otherwise; example:</span>
                <span class="s0"># table &quot;owner&quot; has columns &quot;name&quot; and &quot;owner_name&quot;.  Therefore</span>
                <span class="s0"># column owner.name cannot use the label &quot;owner_name&quot;, it has</span>
                <span class="s0"># to be &quot;owner_name_1&quot;.</span>
                <span class="s3">if </span><span class="s1">label </span><span class="s3">in </span><span class="s1">t</span><span class="s4">.</span><span class="s1">c</span><span class="s4">:</span>
                    <span class="s1">_label </span><span class="s4">= </span><span class="s1">label</span>
                    <span class="s1">counter </span><span class="s4">= </span><span class="s6">1</span>
                    <span class="s3">while </span><span class="s1">_label </span><span class="s3">in </span><span class="s1">t</span><span class="s4">.</span><span class="s1">c</span><span class="s4">:</span>
                        <span class="s1">_label </span><span class="s4">= </span><span class="s1">label </span><span class="s4">+ </span><span class="s5">&quot;_&quot; </span><span class="s4">+ </span><span class="s1">str</span><span class="s4">(</span><span class="s1">counter</span><span class="s4">)</span>
                        <span class="s1">counter </span><span class="s4">+= </span><span class="s6">1</span>
                    <span class="s1">label </span><span class="s4">= </span><span class="s1">_label</span>

            <span class="s3">return </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">TruncatedLabelRole</span><span class="s4">, </span><span class="s1">label</span><span class="s4">)</span>

        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">name</span>

    <span class="s3">def </span><span class="s1">_make_proxy</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">selectable</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">key</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">name_is_truncatable</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">compound_select_cols</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">disallow_is_literal</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; typing_Tuple</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
        <span class="s0"># the &quot;is_literal&quot; flag normally should never be propagated; a proxied</span>
        <span class="s0"># column is always a SQL identifier and never the actual expression</span>
        <span class="s0"># being evaluated. however, there is a case where the &quot;is_literal&quot; flag</span>
        <span class="s0"># might be used to allow the given identifier to have a fixed quoting</span>
        <span class="s0"># pattern already, so maintain the flag for the proxy unless a</span>
        <span class="s0"># :class:`.Label` object is creating the proxy.  See [ticket:4730].</span>
        <span class="s1">is_literal </span><span class="s4">= (</span>
            <span class="s3">not </span><span class="s1">disallow_is_literal</span>
            <span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">is_literal</span>
            <span class="s3">and </span><span class="s4">(</span>
                <span class="s0"># note this does not accommodate for quoted_name differences</span>
                <span class="s0"># right now</span>
                <span class="s1">name </span><span class="s3">is None</span>
                <span class="s3">or </span><span class="s1">name </span><span class="s4">== </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span>
            <span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s1">c </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_constructor</span><span class="s4">(</span>
            <span class="s4">(</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">TruncatedLabelRole</span><span class="s4">, </span><span class="s1">name </span><span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">name_is_truncatable</span>
                <span class="s3">else </span><span class="s4">(</span><span class="s1">name </span><span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">)</span>
            <span class="s4">),</span>
            <span class="s1">type_</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">,</span>
            <span class="s1">_selectable</span><span class="s4">=</span><span class="s1">selectable</span><span class="s4">,</span>
            <span class="s1">is_literal</span><span class="s4">=</span><span class="s1">is_literal</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">c</span><span class="s4">.</span><span class="s1">_propagate_attrs </span><span class="s4">= </span><span class="s1">selectable</span><span class="s4">.</span><span class="s1">_propagate_attrs</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">c</span><span class="s4">.</span><span class="s1">key </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">key</span>
        <span class="s3">if </span><span class="s1">compound_select_cols</span><span class="s4">:</span>
            <span class="s1">c</span><span class="s4">.</span><span class="s1">_proxies </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">compound_select_cols</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">c</span><span class="s4">.</span><span class="s1">_proxies </span><span class="s4">= [</span><span class="s1">self</span><span class="s4">]</span>

        <span class="s3">if </span><span class="s1">selectable</span><span class="s4">.</span><span class="s1">_is_clone_of </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">c</span><span class="s4">.</span><span class="s1">_is_clone_of </span><span class="s4">= </span><span class="s1">selectable</span><span class="s4">.</span><span class="s1">_is_clone_of</span><span class="s4">.</span><span class="s1">columns</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">c</span><span class="s4">.</span><span class="s1">key</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">c</span><span class="s4">.</span><span class="s1">key</span><span class="s4">, </span><span class="s1">c</span>


<span class="s3">class </span><span class="s1">TableValuedColumn</span><span class="s4">(</span><span class="s1">NamedColumn</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;table_valued_column&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_anon_name</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;type&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_type</span><span class="s4">),</span>
        <span class="s4">(</span><span class="s5">&quot;scalar_alias&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">scalar_alias</span><span class="s4">: </span><span class="s1">NamedFromClause</span><span class="s4">, </span><span class="s1">type_</span><span class="s4">: </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">scalar_alias </span><span class="s4">= </span><span class="s1">scalar_alias</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">key </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">scalar_alias</span><span class="s4">.</span><span class="s1">name</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">type_</span>

    <span class="s3">def </span><span class="s1">_copy_internals</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">clone</span><span class="s4">: </span><span class="s1">_CloneCallableType </span><span class="s4">= </span><span class="s1">_clone</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">scalar_alias </span><span class="s4">= </span><span class="s1">clone</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">scalar_alias</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">key </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">scalar_alias</span><span class="s4">.</span><span class="s1">name</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_from_objects</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">scalar_alias</span><span class="s4">]</span>


<span class="s3">class </span><span class="s1">CollationClause</span><span class="s4">(</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]):</span>
    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;collation&quot;</span>

    <span class="s1">_traverse_internals</span><span class="s4">: </span><span class="s1">_TraverseInternalsType </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;collation&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_string</span><span class="s4">)</span>
    <span class="s4">]</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.sqltypes&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">_create_collation_expression</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">expression</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], </span><span class="s1">collation</span><span class="s4">: </span><span class="s1">str</span>
    <span class="s4">) </span><span class="s1">-&gt; BinaryExpression</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]:</span>

        <span class="s1">sqltypes </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_sqltypes</span>

        <span class="s1">expr </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ExpressionElementRole</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], </span><span class="s1">expression</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">expr</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">_type_affinity </span><span class="s3">is </span><span class="s1">sqltypes</span><span class="s4">.</span><span class="s1">String</span><span class="s4">:</span>
            <span class="s1">collate_type </span><span class="s4">= </span><span class="s1">expr</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">_with_collation</span><span class="s4">(</span><span class="s1">collation</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">collate_type </span><span class="s4">= </span><span class="s1">expr</span><span class="s4">.</span><span class="s1">type</span>

        <span class="s3">return </span><span class="s1">BinaryExpression</span><span class="s4">(</span>
            <span class="s1">expr</span><span class="s4">,</span>
            <span class="s1">CollationClause</span><span class="s4">(</span><span class="s1">collation</span><span class="s4">),</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">collate</span><span class="s4">,</span>
            <span class="s1">type_</span><span class="s4">=</span><span class="s1">collate_type</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">collation</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">collation </span><span class="s4">= </span><span class="s1">collation</span>


<span class="s3">class </span><span class="s1">_IdentifiedClause</span><span class="s4">(</span><span class="s1">Executable</span><span class="s4">, </span><span class="s1">ClauseElement</span><span class="s4">):</span>
    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;identified&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">ident</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">ident </span><span class="s4">= </span><span class="s1">ident</span>


<span class="s3">class </span><span class="s1">SavepointClause</span><span class="s4">(</span><span class="s1">_IdentifiedClause</span><span class="s4">):</span>
    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;savepoint&quot;</span>
    <span class="s1">inherit_cache </span><span class="s4">= </span><span class="s3">False</span>


<span class="s3">class </span><span class="s1">RollbackToSavepointClause</span><span class="s4">(</span><span class="s1">_IdentifiedClause</span><span class="s4">):</span>
    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;rollback_to_savepoint&quot;</span>
    <span class="s1">inherit_cache </span><span class="s4">= </span><span class="s3">False</span>


<span class="s3">class </span><span class="s1">ReleaseSavepointClause</span><span class="s4">(</span><span class="s1">_IdentifiedClause</span><span class="s4">):</span>
    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;release_savepoint&quot;</span>
    <span class="s1">inherit_cache </span><span class="s4">= </span><span class="s3">False</span>


<span class="s3">class </span><span class="s1">quoted_name</span><span class="s4">(</span><span class="s1">util</span><span class="s4">.</span><span class="s1">MemoizedSlots</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represent a SQL identifier combined with quoting preferences. 
 
    :class:`.quoted_name` is a Python unicode/str subclass which 
    represents a particular identifier name along with a 
    ``quote`` flag.  This ``quote`` flag, when set to 
    ``True`` or ``False``, overrides automatic quoting behavior 
    for this identifier in order to either unconditionally quote 
    or to not quote the name.  If left at its default of ``None``, 
    quoting behavior is applied to the identifier on a per-backend basis 
    based on an examination of the token itself. 
 
    A :class:`.quoted_name` object with ``quote=True`` is also 
    prevented from being modified in the case of a so-called 
    &quot;name normalize&quot; option.  Certain database backends, such as 
    Oracle, Firebird, and DB2 &quot;normalize&quot; case-insensitive names 
    as uppercase.  The SQLAlchemy dialects for these backends 
    convert from SQLAlchemy's lower-case-means-insensitive convention 
    to the upper-case-means-insensitive conventions of those backends. 
    The ``quote=True`` flag here will prevent this conversion from occurring 
    to support an identifier that's quoted as all lower case against 
    such a backend. 
 
    The :class:`.quoted_name` object is normally created automatically 
    when specifying the name for key schema constructs such as 
    :class:`_schema.Table`, :class:`_schema.Column`, and others. 
    The class can also be 
    passed explicitly as the name to any function that receives a name which 
    can be quoted.  Such as to use the :meth:`_engine.Engine.has_table` 
    method with 
    an unconditionally quoted name:: 
 
        from sqlalchemy import create_engine 
        from sqlalchemy import inspect 
        from sqlalchemy.sql import quoted_name 
 
        engine = create_engine(&quot;oracle+cx_oracle://some_dsn&quot;) 
        print(inspect(engine).has_table(quoted_name(&quot;some_table&quot;, True))) 
 
    The above logic will run the &quot;has table&quot; logic against the Oracle backend, 
    passing the name exactly as ``&quot;some_table&quot;`` without converting to 
    upper case. 
 
    .. versionchanged:: 1.2 The :class:`.quoted_name` construct is now 
       importable from ``sqlalchemy.sql``, in addition to the previous 
       location of ``sqlalchemy.sql.elements``. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s4">= </span><span class="s5">&quot;quote&quot;</span><span class="s4">, </span><span class="s5">&quot;lower&quot;</span><span class="s4">, </span><span class="s5">&quot;upper&quot;</span>

    <span class="s1">quote</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">construct</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">quote</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]) </span><span class="s1">-&gt; quoted_name</span><span class="s4">: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">construct</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s3">None</span><span class="s4">, </span><span class="s1">quote</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">: ...</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">construct</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], </span><span class="s1">quote</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">quoted_name</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">value </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return None</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">quoted_name</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">quote</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">quote</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]) </span><span class="s1">-&gt; quoted_name</span><span class="s4">:</span>
        <span class="s3">assert </span><span class="s4">(</span>
            <span class="s1">value </span><span class="s3">is not None</span>
        <span class="s4">), </span><span class="s5">&quot;use quoted_name.construct() for None passthrough&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">) </span><span class="s3">and </span><span class="s4">(</span><span class="s1">quote </span><span class="s3">is None or </span><span class="s1">value</span><span class="s4">.</span><span class="s1">quote </span><span class="s4">== </span><span class="s1">quote</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">value</span>
        <span class="s1">self </span><span class="s4">= </span><span class="s1">super</span><span class="s4">().</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">quote </span><span class="s4">= </span><span class="s1">quote</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__reduce__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">quoted_name</span><span class="s4">, (</span><span class="s1">str</span><span class="s4">(</span><span class="s1">self</span><span class="s4">), </span><span class="s1">self</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_memoized_method_lower</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">str</span><span class="s4">(</span><span class="s1">self</span><span class="s4">).</span><span class="s1">lower</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_memoized_method_upper</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">str</span><span class="s4">(</span><span class="s1">self</span><span class="s4">).</span><span class="s1">upper</span><span class="s4">()</span>


<span class="s3">def </span><span class="s1">_find_columns</span><span class="s4">(</span><span class="s1">clause</span><span class="s4">: </span><span class="s1">ClauseElement</span><span class="s4">) </span><span class="s1">-&gt; Set</span><span class="s4">[</span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
    <span class="s2">&quot;&quot;&quot;locate Column objects within the given expression.&quot;&quot;&quot;</span>

    <span class="s1">cols</span><span class="s4">: </span><span class="s1">Set</span><span class="s4">[</span><span class="s1">ColumnClause</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s1">set</span><span class="s4">()</span>
    <span class="s1">traverse</span><span class="s4">(</span><span class="s1">clause</span><span class="s4">, {}, {</span><span class="s5">&quot;column&quot;</span><span class="s4">: </span><span class="s1">cols</span><span class="s4">.</span><span class="s1">add</span><span class="s4">})</span>
    <span class="s3">return </span><span class="s1">cols</span>


<span class="s3">def </span><span class="s1">_type_from_args</span><span class="s4">(</span><span class="s1">args</span><span class="s4">: </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args</span><span class="s4">:</span>
        <span class="s3">if not </span><span class="s1">a</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">_isnull</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">a</span><span class="s4">.</span><span class="s1">type</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">NULLTYPE  </span><span class="s0"># type: ignore</span>


<span class="s3">def </span><span class="s1">_corresponding_column_or_error</span><span class="s4">(</span><span class="s1">fromclause</span><span class="s4">, </span><span class="s1">column</span><span class="s4">, </span><span class="s1">require_embedded</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s1">c </span><span class="s4">= </span><span class="s1">fromclause</span><span class="s4">.</span><span class="s1">corresponding_column</span><span class="s4">(</span>
        <span class="s1">column</span><span class="s4">, </span><span class="s1">require_embedded</span><span class="s4">=</span><span class="s1">require_embedded</span>
    <span class="s4">)</span>
    <span class="s3">if </span><span class="s1">c </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
            <span class="s5">&quot;Given column '%s', attached to table '%s', &quot;</span>
            <span class="s5">&quot;failed to locate a corresponding column from table '%s'&quot;</span>
            <span class="s4">% (</span><span class="s1">column</span><span class="s4">, </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">column</span><span class="s4">, </span><span class="s5">&quot;table&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">), </span><span class="s1">fromclause</span><span class="s4">.</span><span class="s1">description</span><span class="s4">)</span>
        <span class="s4">)</span>
    <span class="s3">return </span><span class="s1">c</span>


<span class="s3">class </span><span class="s1">_memoized_property_but_not_nulltype</span><span class="s4">(</span>
    <span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span><span class="s4">[</span><span class="s5">&quot;TypeEngine[_T]&quot;</span><span class="s4">]</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;memoized property, but dont memoize NullType&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__get__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">obj </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fget</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">result</span><span class="s4">.</span><span class="s1">_isnull</span><span class="s4">:</span>
            <span class="s1">obj</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">] = </span><span class="s1">result</span>
        <span class="s3">return </span><span class="s1">result</span>


<span class="s3">class </span><span class="s1">AnnotatedColumnElement</span><span class="s4">(</span><span class="s1">Annotated</span><span class="s4">):</span>
    <span class="s1">_Annotated__element</span><span class="s4">: </span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">, </span><span class="s1">values</span><span class="s4">):</span>
        <span class="s1">Annotated</span><span class="s4">.</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">element</span><span class="s4">, </span><span class="s1">values</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s4">(</span>
            <span class="s5">&quot;comparator&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_proxy_key&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_tq_key_label&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_tq_label&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_non_anon_label&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;type&quot;</span><span class="s4">,</span>
        <span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s4">(</span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s5">&quot;key&quot;</span><span class="s4">, </span><span class="s5">&quot;table&quot;</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">, </span><span class="s3">False</span><span class="s4">) </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_with_annotations</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">values</span><span class="s4">):</span>
        <span class="s1">clone </span><span class="s4">= </span><span class="s1">super</span><span class="s4">().</span><span class="s1">_with_annotations</span><span class="s4">(</span><span class="s1">values</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s4">(</span>
            <span class="s5">&quot;comparator&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_proxy_key&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_tq_key_label&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_tq_label&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_non_anon_label&quot;</span><span class="s4">,</span>
        <span class="s4">):</span>
            <span class="s1">clone</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">clone</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">name</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;pull 'name' from parent, if not present&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_Annotated__element</span><span class="s4">.</span><span class="s1">name</span>

    <span class="s4">@</span><span class="s1">_memoized_property_but_not_nulltype</span>
    <span class="s3">def </span><span class="s1">type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;pull 'type' from parent and don't cache if null. 
 
        type is routinely changed on existing columns within the 
        mapped_column() initialization process, and &quot;type&quot; is also consulted 
        during the creation of SQL expressions.  Therefore it can change after 
        it was already retrieved.  At the same time we don't want annotated 
        objects having overhead when expressions are produced, so continue 
        to memoize, but only when we have a non-null type. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_Annotated__element</span><span class="s4">.</span><span class="s1">type</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">table</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;pull 'table' from parent, if not present&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_Annotated__element</span><span class="s4">.</span><span class="s1">table</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">key</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;pull 'key' from parent, if not present&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_Annotated__element</span><span class="s4">.</span><span class="s1">key</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">info</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _InfoType</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_Annotated__element</span><span class="s4">, </span><span class="s1">Column</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_Annotated__element</span><span class="s4">.</span><span class="s1">info</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_anon_name_label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_Annotated__element</span><span class="s4">.</span><span class="s1">_anon_name_label</span>


<span class="s3">class </span><span class="s1">_truncated_label</span><span class="s4">(</span><span class="s1">quoted_name</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A unicode subclass used to identify symbolic &quot; 
    &quot;names that may require truncation.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s4">= ()</span>

    <span class="s3">def </span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">quote</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s1">quote </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s5">&quot;quote&quot;</span><span class="s4">, </span><span class="s1">quote</span><span class="s4">)</span>
        <span class="s0"># return super(_truncated_label, cls).__new__(cls, value, quote, True)</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">__new__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">value</span><span class="s4">, </span><span class="s1">quote</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__reduce__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">, (</span><span class="s1">str</span><span class="s4">(</span><span class="s1">self</span><span class="s4">), </span><span class="s1">self</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">apply_map</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">map_</span><span class="s4">: </span><span class="s1">Mapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">conv</span><span class="s4">(</span><span class="s1">_truncated_label</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Mark a string indicating that a name has already been converted 
    by a naming convention. 
 
    This is a string subclass that indicates a name that should not be 
    subject to any further naming conventions. 
 
    E.g. when we create a :class:`.Constraint` using a naming convention 
    as follows:: 
 
        m = MetaData(naming_convention={ 
            &quot;ck&quot;: &quot;ck_%(table_name)s_%(constraint_name)s&quot; 
        }) 
        t = Table('t', m, Column('x', Integer), 
                        CheckConstraint('x &gt; 5', name='x5')) 
 
    The name of the above constraint will be rendered as ``&quot;ck_t_x5&quot;``. 
    That is, the existing name ``x5`` is used in the naming convention as the 
    ``constraint_name`` token. 
 
    In some situations, such as in migration scripts, we may be rendering 
    the above :class:`.CheckConstraint` with a name that's already been 
    converted.  In order to make sure the name isn't double-modified, the 
    new name is applied using the :func:`_schema.conv` marker.  We can 
    use this explicitly as follows:: 
 
 
        m = MetaData(naming_convention={ 
            &quot;ck&quot;: &quot;ck_%(table_name)s_%(constraint_name)s&quot; 
        }) 
        t = Table('t', m, Column('x', Integer), 
                        CheckConstraint('x &gt; 5', name=conv('ck_t_x5'))) 
 
    Where above, the :func:`_schema.conv` marker indicates that the constraint 
    name here is final, and the name will render as ``&quot;ck_t_x5&quot;`` and not 
    ``&quot;ck_t_ck_t_x5&quot;`` 
 
    .. seealso:: 
 
        :ref:`constraint_naming_conventions` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s4">= ()</span>


<span class="s0"># for backwards compatibility in case</span>
<span class="s0"># someone is re-implementing the</span>
<span class="s0"># _truncated_identifier() sequence in a custom</span>
<span class="s0"># compiler</span>
<span class="s1">_generated_label </span><span class="s4">= </span><span class="s1">_truncated_label</span>


<span class="s3">class </span><span class="s1">_anonymous_label</span><span class="s4">(</span><span class="s1">_truncated_label</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A unicode subclass used to identify anonymously 
    generated names.&quot;&quot;&quot;</span>

    <span class="s1">__slots__ </span><span class="s4">= ()</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">safe_construct</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">,</span>
        <span class="s1">seed</span><span class="s4">: </span><span class="s1">int</span><span class="s4">,</span>
        <span class="s1">body</span><span class="s4">: </span><span class="s1">str</span><span class="s4">,</span>
        <span class="s1">enclosing_label</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">sanitize_key</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; _anonymous_label</span><span class="s4">:</span>
        <span class="s0"># need to escape chars that interfere with format</span>
        <span class="s0"># strings in any case, issue #8724</span>
        <span class="s1">body </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">(</span><span class="s5">r&quot;[%\(\) \$]+&quot;</span><span class="s4">, </span><span class="s5">&quot;_&quot;</span><span class="s4">, </span><span class="s1">body</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">sanitize_key</span><span class="s4">:</span>
            <span class="s0"># sanitize_key is then an extra step used by BindParameter</span>
            <span class="s1">body </span><span class="s4">= </span><span class="s1">body</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">(</span><span class="s5">&quot;_&quot;</span><span class="s4">)</span>

        <span class="s1">label </span><span class="s4">= </span><span class="s5">&quot;%%(%d %s)s&quot; </span><span class="s4">% (</span><span class="s1">seed</span><span class="s4">, </span><span class="s1">body</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s5">&quot;%&quot;</span><span class="s4">, </span><span class="s5">&quot;%%&quot;</span><span class="s4">))</span>
        <span class="s3">if </span><span class="s1">enclosing_label</span><span class="s4">:</span>
            <span class="s1">label </span><span class="s4">= </span><span class="s5">&quot;%s%s&quot; </span><span class="s4">% (</span><span class="s1">enclosing_label</span><span class="s4">, </span><span class="s1">label</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">_anonymous_label</span><span class="s4">(</span><span class="s1">label</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__add__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s5">&quot;%&quot; </span><span class="s3">in </span><span class="s1">other </span><span class="s3">and not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">_anonymous_label</span><span class="s4">):</span>
            <span class="s1">other </span><span class="s4">= </span><span class="s1">str</span><span class="s4">(</span><span class="s1">other</span><span class="s4">).</span><span class="s1">replace</span><span class="s4">(</span><span class="s5">&quot;%&quot;</span><span class="s4">, </span><span class="s5">&quot;%%&quot;</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">other </span><span class="s4">= </span><span class="s1">str</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">_anonymous_label</span><span class="s4">(</span>
            <span class="s1">quoted_name</span><span class="s4">(</span>
                <span class="s1">str</span><span class="s4">.</span><span class="s1">__add__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">),</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__radd__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s5">&quot;%&quot; </span><span class="s3">in </span><span class="s1">other </span><span class="s3">and not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">_anonymous_label</span><span class="s4">):</span>
            <span class="s1">other </span><span class="s4">= </span><span class="s1">str</span><span class="s4">(</span><span class="s1">other</span><span class="s4">).</span><span class="s1">replace</span><span class="s4">(</span><span class="s5">&quot;%&quot;</span><span class="s4">, </span><span class="s5">&quot;%%&quot;</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">other </span><span class="s4">= </span><span class="s1">str</span><span class="s4">(</span><span class="s1">other</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">_anonymous_label</span><span class="s4">(</span>
            <span class="s1">quoted_name</span><span class="s4">(</span>
                <span class="s1">str</span><span class="s4">.</span><span class="s1">__add__</span><span class="s4">(</span><span class="s1">other</span><span class="s4">, </span><span class="s1">self</span><span class="s4">),</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">apply_map</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">map_</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">quote </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s0"># preserve quoting only if necessary</span>
            <span class="s3">return </span><span class="s1">quoted_name</span><span class="s4">(</span><span class="s1">self </span><span class="s4">% </span><span class="s1">map_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">quote</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s0"># else skip the constructor call</span>
            <span class="s3">return </span><span class="s1">self </span><span class="s4">% </span><span class="s1">map_</span>
</pre>
</body>
</html>